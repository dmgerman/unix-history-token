begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Perform instruction reorganizations for delay slot filling.    Copyright (C) 1992, 93, 94, 95, 96, 97, 1998 Free Software Foundation, Inc.    Contributed by Richard Kenner (kenner@vlsi1.ultra.nyu.edu).    Hacked by Michael Tiemann (tiemann@cygnus.com).  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* Instruction reorganization pass.     This pass runs after register allocation and final jump    optimization.  It should be the last pass to run before peephole.    It serves primarily to fill delay slots of insns, typically branch    and call insns.  Other insns typically involve more complicated    interactions of data dependencies and resource constraints, and    are better handled by scheduling before register allocation (by the    function `schedule_insns').     The Branch Penalty is the number of extra cycles that are needed to    execute a branch insn.  On an ideal machine, branches take a single    cycle, and the Branch Penalty is 0.  Several RISC machines approach    branch delays differently:     The MIPS and AMD 29000 have a single branch delay slot.  Most insns    (except other branches) can be used to fill this slot.  When the    slot is filled, two insns execute in two cycles, reducing the    branch penalty to zero.     The Motorola 88000 conditionally exposes its branch delay slot,    so code is shorter when it is turned off, but will run faster    when useful insns are scheduled there.     The IBM ROMP has two forms of branch and call insns, both with and    without a delay slot.  Much like the 88k, insns not using the delay    slot can be shorted (2 bytes vs. 4 bytes), but will run slowed.     The SPARC always has a branch delay slot, but its effects can be    annulled when the branch is not taken.  This means that failing to    find other sources of insns, we can hoist an insn from the branch    target that would only be safe to execute knowing that the branch    is taken.     The HP-PA always has a branch delay slot.  For unconditional branches    its effects can be annulled when the branch is taken.  The effects     of the delay slot in a conditional branch can be nullified for forward    taken branches, or for untaken backward branches.  This means    we can hoist insns from the fall-through path for forward branches or    steal insns from the target of backward branches.     Three techniques for filling delay slots have been implemented so far:     (1) `fill_simple_delay_slots' is the simplest, most efficient way    to fill delay slots.  This pass first looks for insns which come    from before the branch and which are safe to execute after the    branch.  Then it searches after the insn requiring delay slots or,    in the case of a branch, for insns that are after the point at    which the branch merges into the fallthrough code, if such a point    exists.  When such insns are found, the branch penalty decreases    and no code expansion takes place.     (2) `fill_eager_delay_slots' is more complicated: it is used for    scheduling conditional jumps, or for scheduling jumps which cannot    be filled using (1).  A machine need not have annulled jumps to use    this strategy, but it helps (by keeping more options open).    `fill_eager_delay_slots' tries to guess the direction the branch    will go; if it guesses right 100% of the time, it can reduce the    branch penalty as much as `fill_simple_delay_slots' does.  If it    guesses wrong 100% of the time, it might as well schedule nops (or    on the m88k, unexpose the branch slot).  When    `fill_eager_delay_slots' takes insns from the fall-through path of    the jump, usually there is no code expansion; when it takes insns    from the branch target, there is code expansion if it is not the    only way to reach that target.     (3) `relax_delay_slots' uses a set of rules to simplify code that    has been reorganized by (1) and (2).  It finds cases where    conditional test can be eliminated, jumps can be threaded, extra    insns can be eliminated, etc.  It is the job of (1) and (2) to do a    good job of scheduling locally; `relax_delay_slots' takes care of    making the various individual schedules work well together.  It is    especially tuned to handle the control flow interactions of branch    insns.  It does nothing for insns with delay slots that do not    branch.     On machines that use CC0, we are very conservative.  We will not make    a copy of an insn involving CC0 since we want to maintain a 1-1    correspondence between the insn that sets and uses CC0.  The insns are    allowed to be separated by placing an insn that sets CC0 (but not an insn    that uses CC0; we could do this, but it doesn't seem worthwhile) in a    delay slot.  In that case, we point each insn at the other with REG_CC_USER    and REG_CC_SETTER notes.  Note that these restrictions affect very few    machines because most RISC machines with delay slots will not use CC0    (the RT is the only known exception at this point).     Not yet implemented:     The Acorn Risc Machine can conditionally execute most insns, so    it is profitable to move single insns into a position to execute    based on the condition code of the previous insn.     The HP-PA can conditionally nullify insns, providing a similar    effect to the ARM, differing mostly in which insn is "in charge".   */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"conditions.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"insn-flags.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_comment
comment|/* Import list of registers used as spill regs from reload.  */
end_comment

begin_decl_stmt
specifier|extern
name|HARD_REG_SET
name|used_spill_regs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Import highest label used in function at end of reload.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|max_label_num_after_reload
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DELAY_SLOTS
end_ifdef

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|ANNUL_IFTRUE_SLOTS
end_ifndef

begin_define
define|#
directive|define
name|eligible_for_annul_true
parameter_list|(
name|INSN
parameter_list|,
name|SLOTS
parameter_list|,
name|TRIAL
parameter_list|,
name|FLAGS
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ANNUL_IFFALSE_SLOTS
end_ifndef

begin_define
define|#
directive|define
name|eligible_for_annul_false
parameter_list|(
name|INSN
parameter_list|,
name|SLOTS
parameter_list|,
name|TRIAL
parameter_list|,
name|FLAGS
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Insns which have delay slots that have not yet been filled.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|unfilled_slots_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|unfilled_firstobj
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Define macros to refer to the first and last slot containing unfilled    insns.  These are used because the list may move and its address    should be recomputed at each use.  */
end_comment

begin_define
define|#
directive|define
name|unfilled_slots_base
define|\
value|((rtx *) obstack_base (&unfilled_slots_obstack))
end_define

begin_define
define|#
directive|define
name|unfilled_slots_next
define|\
value|((rtx *) obstack_next_free (&unfilled_slots_obstack))
end_define

begin_comment
comment|/* This structure is used to indicate which hardware resources are set or    needed by insns so far.  */
end_comment

begin_struct
struct|struct
name|resources
block|{
name|char
name|memory
decl_stmt|;
comment|/* Insn sets or needs a memory location.  */
name|char
name|unch_memory
decl_stmt|;
comment|/* Insn sets of needs a "unchanging" MEM.  */
name|char
name|volatil
decl_stmt|;
comment|/* Insn sets or needs a volatile memory loc.  */
name|char
name|cc
decl_stmt|;
comment|/* Insn sets or needs the condition codes.  */
name|HARD_REG_SET
name|regs
decl_stmt|;
comment|/* Which registers are set or needed.  */
block|}
struct|;
end_struct

begin_comment
comment|/* Macro to clear all resources.  */
end_comment

begin_define
define|#
directive|define
name|CLEAR_RESOURCE
parameter_list|(
name|RES
parameter_list|)
define|\
value|do { (RES)->memory = (RES)->unch_memory = (RES)->volatil = (RES)->cc = 0; \       CLEAR_HARD_REG_SET ((RES)->regs); } while (0)
end_define

begin_comment
comment|/* Indicates what resources are required at the beginning of the epilogue.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|resources
name|start_of_epilogue_needs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indicates what resources are required at function end.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|resources
name|end_of_function_needs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Points to the label before the end of the function.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|end_of_function_label
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This structure is used to record liveness information at the targets or    fallthrough insns of branches.  We will most likely need the information    at targets again, so save them in a hash table rather than recomputing them    each time.  */
end_comment

begin_struct
struct|struct
name|target_info
block|{
name|int
name|uid
decl_stmt|;
comment|/* INSN_UID of target.  */
name|struct
name|target_info
modifier|*
name|next
decl_stmt|;
comment|/* Next info for same hash bucket.  */
name|HARD_REG_SET
name|live_regs
decl_stmt|;
comment|/* Registers live at target.  */
name|int
name|block
decl_stmt|;
comment|/* Basic block number containing target.  */
name|int
name|bb_tick
decl_stmt|;
comment|/* Generation count of basic block info.  */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|TARGET_HASH_PRIME
value|257
end_define

begin_comment
comment|/* Define the hash table itself.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|target_info
modifier|*
modifier|*
name|target_hash_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For each basic block, we maintain a generation number of its basic    block info, which is updated each time we move an insn from the    target of a jump.  This is the generation number indexed by block    number.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|bb_ticks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Mapping between INSN_UID's and position in the code since INSN_UID's do    not always monotonically increase.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|uid_to_ruid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Highest valid index in `uid_to_ruid'.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_uid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_referenced_resources
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
expr|struct
name|resources
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_set_resources
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
expr|struct
name|resources
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|stop_search_p
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|resource_conflicts_p
name|PROTO
argument_list|(
operator|(
expr|struct
name|resources
operator|*
operator|,
expr|struct
name|resources
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|insn_references_resource_p
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
expr|struct
name|resources
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|insn_sets_resource_p
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
expr|struct
name|resources
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|find_end_label
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|emit_delay_sequence
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|add_to_delay_list
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|delete_from_delay_slot
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|delete_scheduled_jump
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|note_delay_statistics
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|optimize_skip
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_jump_flags
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rare_destination
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mostly_true_jump
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|get_branch_condition
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|condition_dominates_p
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|steal_delay_list_from_target
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
expr|struct
name|resources
operator|*
operator|,
expr|struct
name|resources
operator|*
operator|,
expr|struct
name|resources
operator|*
operator|,
name|int
operator|,
name|int
operator|*
operator|,
name|int
operator|*
operator|,
name|rtx
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|steal_delay_list_from_fallthrough
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
expr|struct
name|resources
operator|*
operator|,
expr|struct
name|resources
operator|*
operator|,
expr|struct
name|resources
operator|*
operator|,
name|int
operator|,
name|int
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|try_merge_delay_insns
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|redundant_insn
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|own_thread_p
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|find_basic_block
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|update_block
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reorg_redirect_jump
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|update_reg_dead_notes
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fix_reg_dead_note
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|update_reg_unused_notes
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|update_live_status
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|next_insn_no_annul
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|find_dead_or_set_registers
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
expr|struct
name|resources
operator|*
operator|,
name|rtx
operator|*
operator|,
name|int
operator|,
expr|struct
name|resources
operator|,
expr|struct
name|resources
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_target_live_regs
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
expr|struct
name|resources
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fill_simple_delay_slots
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|fill_slots_from_thread
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|*
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fill_eager_delay_slots
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|relax_delay_slots
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|make_return_insns
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|redirect_with_delay_slots_safe_p
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|redirect_with_delay_list_safe_p
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Given X, some rtl, and RES, a pointer to a `struct resource', mark    which resources are references by the insn.  If INCLUDE_DELAYED_EFFECTS    is TRUE, resources used by the called routine will be included for    CALL_INSNs.  */
end_comment

begin_function
specifier|static
name|void
name|mark_referenced_resources
parameter_list|(
name|x
parameter_list|,
name|res
parameter_list|,
name|include_delayed_effects
parameter_list|)
specifier|register
name|rtx
name|x
decl_stmt|;
specifier|register
name|struct
name|resources
modifier|*
name|res
decl_stmt|;
specifier|register
name|int
name|include_delayed_effects
decl_stmt|;
block|{
specifier|register
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|char
modifier|*
name|format_ptr
decl_stmt|;
comment|/* Handle leaf items for which we set resource flags.  Also, special-case      CALL, SET and CLOBBER operators.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONST
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|PC
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
return|return;
case|case
name|SUBREG
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
name|mark_referenced_resources
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|,
name|res
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|+
name|SUBREG_WORD
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|int
name|last_regno
init|=
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
name|regno
init|;
name|i
operator|<
name|last_regno
condition|;
name|i
operator|++
control|)
name|SET_HARD_REG_BIT
argument_list|(
name|res
operator|->
name|regs
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|REG
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HARD_REGNO_NREGS
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
name|SET_HARD_REG_BIT
argument_list|(
name|res
operator|->
name|regs
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
operator|+
name|i
argument_list|)
expr_stmt|;
return|return;
case|case
name|MEM
case|:
comment|/* If this memory shouldn't change, it really isn't referencing 	 memory.  */
if|if
condition|(
name|RTX_UNCHANGING_P
argument_list|(
name|x
argument_list|)
condition|)
name|res
operator|->
name|unch_memory
operator|=
literal|1
expr_stmt|;
else|else
name|res
operator|->
name|memory
operator|=
literal|1
expr_stmt|;
name|res
operator|->
name|volatil
operator|=
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* Mark registers used to access memory.  */
name|mark_referenced_resources
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|res
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
name|CC0
case|:
name|res
operator|->
name|cc
operator|=
literal|1
expr_stmt|;
return|return;
case|case
name|UNSPEC_VOLATILE
case|:
case|case
name|ASM_INPUT
case|:
comment|/* Traditional asm's are always volatile.  */
name|res
operator|->
name|volatil
operator|=
literal|1
expr_stmt|;
return|return;
case|case
name|TRAP_IF
case|:
name|res
operator|->
name|volatil
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ASM_OPERANDS
case|:
name|res
operator|->
name|volatil
operator|=
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* For all ASM_OPERANDS, we must traverse the vector of input operands. 	 We can not just fall through here since then we would be confused 	 by the ASM_INPUT rtx inside ASM_OPERANDS, which do not indicate 	 traditional asms unlike their normal usage.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|x
argument_list|)
condition|;
name|i
operator|++
control|)
name|mark_referenced_resources
argument_list|(
name|ASM_OPERANDS_INPUT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|res
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
name|CALL
case|:
comment|/* The first operand will be a (MEM (xxx)) but doesn't really reference 	 memory.  The second operand may be referenced, though.  */
name|mark_referenced_resources
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|res
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mark_referenced_resources
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|res
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
name|SET
case|:
comment|/* Usually, the first operand of SET is set, not referenced.  But 	 registers used to access memory are referenced.  SET_DEST is 	 also referenced if it is a ZERO_EXTRACT or SIGN_EXTRACT.  */
name|mark_referenced_resources
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|res
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|x
operator|=
name|SET_DEST
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|ZERO_EXTRACT
condition|)
name|mark_referenced_resources
argument_list|(
name|x
argument_list|,
name|res
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
condition|)
name|x
operator|=
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
name|mark_referenced_resources
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|res
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
name|CLOBBER
case|:
return|return;
case|case
name|CALL_INSN
case|:
if|if
condition|(
name|include_delayed_effects
condition|)
block|{
comment|/* A CALL references memory, the frame pointer if it exists, the 	     stack pointer, any global registers and any registers given in 	     USE insns immediately in front of the CALL.  	     However, we may have moved some of the parameter loading insns 	     into the delay slot of this CALL.  If so, the USE's for them 	     don't count and should be skipped.  */
name|rtx
name|insn
init|=
name|PREV_INSN
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|rtx
name|sequence
init|=
literal|0
decl_stmt|;
name|int
name|seq_size
init|=
literal|0
decl_stmt|;
name|rtx
name|next
init|=
name|NEXT_INSN
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* If we are part of a delay slot sequence, point at the SEQUENCE.  */
if|if
condition|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|!=
name|x
condition|)
block|{
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|sequence
operator|=
name|PATTERN
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|seq_size
operator|=
name|XVECLEN
argument_list|(
name|sequence
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|sequence
argument_list|)
operator|!=
name|SEQUENCE
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
name|res
operator|->
name|memory
operator|=
literal|1
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|res
operator|->
name|regs
argument_list|,
name|STACK_POINTER_REGNUM
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
name|SET_HARD_REG_BIT
argument_list|(
name|res
operator|->
name|regs
argument_list|,
name|FRAME_POINTER_REGNUM
argument_list|)
expr_stmt|;
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|HARD_FRAME_POINTER_REGNUM
name|SET_HARD_REG_BIT
argument_list|(
name|res
operator|->
name|regs
argument_list|,
name|HARD_FRAME_POINTER_REGNUM
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|global_regs
index|[
name|i
index|]
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|res
operator|->
name|regs
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Check for a NOTE_INSN_SETJMP.  If it exists, then we must 	     assume that this call can need any register.  	     This is done to be more conservative about how we handle setjmp. 	     We assume that they both use and set all registers.  Using all 	     registers ensures that a register will not be considered dead 	     just because it crosses a setjmp call.  A register should be 	     considered dead only if the setjmp call returns non-zero.  */
if|if
condition|(
name|next
operator|&&
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|next
argument_list|)
operator|==
name|NOTE_INSN_SETJMP
condition|)
name|SET_HARD_REG_SET
argument_list|(
name|res
operator|->
name|regs
argument_list|)
expr_stmt|;
block|{
name|rtx
name|link
decl_stmt|;
for|for
control|(
name|link
operator|=
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|x
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|USE
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|seq_size
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|slot_pat
init|=
name|PATTERN
argument_list|(
name|XVECEXP
argument_list|(
name|sequence
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|slot_pat
argument_list|)
operator|==
name|SET
operator|&&
name|rtx_equal_p
argument_list|(
name|SET_DEST
argument_list|(
name|slot_pat
argument_list|)
argument_list|,
name|SET_DEST
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|>=
name|seq_size
condition|)
name|mark_referenced_resources
argument_list|(
name|SET_DEST
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|res
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* ... fall through to other INSN processing ...  */
case|case
name|INSN
case|:
case|case
name|JUMP_INSN
case|:
ifdef|#
directive|ifdef
name|INSN_REFERENCES_ARE_DELAYED
if|if
condition|(
operator|!
name|include_delayed_effects
operator|&&
name|INSN_REFERENCES_ARE_DELAYED
argument_list|(
name|x
argument_list|)
condition|)
return|return;
endif|#
directive|endif
comment|/* No special processing, just speed up.  */
name|mark_referenced_resources
argument_list|(
name|PATTERN
argument_list|(
name|x
argument_list|)
argument_list|,
name|res
argument_list|,
name|include_delayed_effects
argument_list|)
expr_stmt|;
return|return;
default|default:
break|break;
block|}
comment|/* Process each sub-expression and flag what it needs.  */
name|format_ptr
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
condition|;
name|i
operator|++
control|)
switch|switch
condition|(
operator|*
name|format_ptr
operator|++
condition|)
block|{
case|case
literal|'e'
case|:
name|mark_referenced_resources
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|res
argument_list|,
name|include_delayed_effects
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|mark_referenced_resources
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|res
argument_list|,
name|include_delayed_effects
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given X, a part of an insn, and a pointer to a `struct resource',    RES, indicate which resources are modified by the insn. If    INCLUDE_DELAYED_EFFECTS is nonzero, also mark resources potentially    set by the called routine.     If IN_DEST is nonzero, it means we are inside a SET.  Otherwise,    objects are being referenced instead of set.     We never mark the insn as modifying the condition code unless it explicitly    SETs CC0 even though this is not totally correct.  The reason for this is    that we require a SET of CC0 to immediately precede the reference to CC0.    So if some other insn sets CC0 as a side-effect, we know it cannot affect    our computation and thus may be placed in a delay slot.   */
end_comment

begin_function
specifier|static
name|void
name|mark_set_resources
parameter_list|(
name|x
parameter_list|,
name|res
parameter_list|,
name|in_dest
parameter_list|,
name|include_delayed_effects
parameter_list|)
specifier|register
name|rtx
name|x
decl_stmt|;
specifier|register
name|struct
name|resources
modifier|*
name|res
decl_stmt|;
name|int
name|in_dest
decl_stmt|;
name|int
name|include_delayed_effects
decl_stmt|;
block|{
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|char
modifier|*
name|format_ptr
decl_stmt|;
name|restart
label|:
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|NOTE
case|:
case|case
name|BARRIER
case|:
case|case
name|CODE_LABEL
case|:
case|case
name|USE
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|LABEL_REF
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CONST
case|:
case|case
name|PC
case|:
comment|/* These don't set any resources.  */
return|return;
case|case
name|CC0
case|:
if|if
condition|(
name|in_dest
condition|)
name|res
operator|->
name|cc
operator|=
literal|1
expr_stmt|;
return|return;
case|case
name|CALL_INSN
case|:
comment|/* Called routine modifies the condition code, memory, any registers 	 that aren't saved across calls, global registers and anything 	 explicitly CLOBBERed immediately after the CALL_INSN.  */
if|if
condition|(
name|include_delayed_effects
condition|)
block|{
name|rtx
name|next
init|=
name|NEXT_INSN
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|rtx
name|prev
init|=
name|PREV_INSN
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|rtx
name|link
decl_stmt|;
name|res
operator|->
name|cc
operator|=
name|res
operator|->
name|memory
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|call_used_regs
index|[
name|i
index|]
operator|||
name|global_regs
index|[
name|i
index|]
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|res
operator|->
name|regs
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* If X is part of a delay slot sequence, then NEXT should be 	     the first insn after the sequence.  */
if|if
condition|(
name|NEXT_INSN
argument_list|(
name|prev
argument_list|)
operator|!=
name|x
condition|)
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|NEXT_INSN
argument_list|(
name|prev
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|link
operator|=
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|x
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
name|mark_set_resources
argument_list|(
name|SET_DEST
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|res
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Check for a NOTE_INSN_SETJMP.  If it exists, then we must 	     assume that this call can clobber any register.  */
if|if
condition|(
name|next
operator|&&
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|next
argument_list|)
operator|==
name|NOTE_INSN_SETJMP
condition|)
name|SET_HARD_REG_SET
argument_list|(
name|res
operator|->
name|regs
argument_list|)
expr_stmt|;
block|}
comment|/* ... and also what its RTL says it modifies, if anything.  */
case|case
name|JUMP_INSN
case|:
case|case
name|INSN
case|:
comment|/* An insn consisting of just a CLOBBER (or USE) is just for flow 	   and doesn't actually do anything, so we ignore it.  */
ifdef|#
directive|ifdef
name|INSN_SETS_ARE_DELAYED
if|if
condition|(
operator|!
name|include_delayed_effects
operator|&&
name|INSN_SETS_ARE_DELAYED
argument_list|(
name|x
argument_list|)
condition|)
return|return;
endif|#
directive|endif
name|x
operator|=
name|PATTERN
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CLOBBER
condition|)
goto|goto
name|restart
goto|;
return|return;
case|case
name|SET
case|:
comment|/* If the source of a SET is a CALL, this is actually done by 	 the called routine.  So only include it if we are to include the 	 effects of the calling routine.  */
name|mark_set_resources
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|res
argument_list|,
operator|(
name|include_delayed_effects
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|CALL
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mark_set_resources
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|res
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
name|CLOBBER
case|:
name|mark_set_resources
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|res
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
name|SEQUENCE
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
operator|(
name|INSN_ANNULLED_BRANCH_P
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|INSN_FROM_TARGET_P
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|)
condition|)
name|mark_set_resources
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|res
argument_list|,
literal|0
argument_list|,
name|include_delayed_effects
argument_list|)
expr_stmt|;
return|return;
case|case
name|POST_INC
case|:
case|case
name|PRE_INC
case|:
case|case
name|POST_DEC
case|:
case|case
name|PRE_DEC
case|:
name|mark_set_resources
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|res
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
name|ZERO_EXTRACT
case|:
name|mark_set_resources
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|res
argument_list|,
name|in_dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mark_set_resources
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|res
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mark_set_resources
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|,
name|res
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
name|MEM
case|:
if|if
condition|(
name|in_dest
condition|)
block|{
name|res
operator|->
name|memory
operator|=
literal|1
expr_stmt|;
name|res
operator|->
name|unch_memory
operator|=
name|RTX_UNCHANGING_P
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|res
operator|->
name|volatil
operator|=
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
name|mark_set_resources
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|res
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
name|SUBREG
case|:
if|if
condition|(
name|in_dest
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
name|mark_set_resources
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|,
name|res
argument_list|,
name|in_dest
argument_list|,
name|include_delayed_effects
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|+
name|SUBREG_WORD
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|int
name|last_regno
init|=
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
name|regno
init|;
name|i
operator|<
name|last_regno
condition|;
name|i
operator|++
control|)
name|SET_HARD_REG_BIT
argument_list|(
name|res
operator|->
name|regs
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
case|case
name|REG
case|:
if|if
condition|(
name|in_dest
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HARD_REGNO_NREGS
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
name|SET_HARD_REG_BIT
argument_list|(
name|res
operator|->
name|regs
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
operator|+
name|i
argument_list|)
expr_stmt|;
return|return;
default|default:
break|break;
block|}
comment|/* Process each sub-expression and flag what it needs.  */
name|format_ptr
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
condition|;
name|i
operator|++
control|)
switch|switch
condition|(
operator|*
name|format_ptr
operator|++
condition|)
block|{
case|case
literal|'e'
case|:
name|mark_set_resources
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|res
argument_list|,
name|in_dest
argument_list|,
name|include_delayed_effects
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|mark_set_resources
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|res
argument_list|,
name|in_dest
argument_list|,
name|include_delayed_effects
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return TRUE if this insn should stop the search for insn to fill delay    slots.  LABELS_P indicates that labels should terminate the search.    In all cases, jumps terminate the search.  */
end_comment

begin_function
specifier|static
name|int
name|stop_search_p
parameter_list|(
name|insn
parameter_list|,
name|labels_p
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|int
name|labels_p
decl_stmt|;
block|{
if|if
condition|(
name|insn
operator|==
literal|0
condition|)
return|return
literal|1
return|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|NOTE
case|:
case|case
name|CALL_INSN
case|:
return|return
literal|0
return|;
case|case
name|CODE_LABEL
case|:
return|return
name|labels_p
return|;
case|case
name|JUMP_INSN
case|:
case|case
name|BARRIER
case|:
return|return
literal|1
return|;
case|case
name|INSN
case|:
comment|/* OK unless it contains a delay slot or is an `asm' insn of some type. 	 We don't know anything about these.  */
return|return
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ASM_INPUT
operator|||
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|>=
literal|0
operator|)
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return TRUE if any resources are marked in both RES1 and RES2 or if either    resource set contains a volatile memory reference.  Otherwise, return FALSE.  */
end_comment

begin_function
specifier|static
name|int
name|resource_conflicts_p
parameter_list|(
name|res1
parameter_list|,
name|res2
parameter_list|)
name|struct
name|resources
modifier|*
name|res1
decl_stmt|,
decl|*
name|res2
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
operator|(
name|res1
operator|->
name|cc
operator|&&
name|res2
operator|->
name|cc
operator|)
operator|||
operator|(
name|res1
operator|->
name|memory
operator|&&
name|res2
operator|->
name|memory
operator|)
operator|||
operator|(
name|res1
operator|->
name|unch_memory
operator|&&
name|res2
operator|->
name|unch_memory
operator|)
operator|||
name|res1
operator|->
name|volatil
operator|||
name|res2
operator|->
name|volatil
condition|)
return|return
literal|1
return|;
ifdef|#
directive|ifdef
name|HARD_REG_SET
return|return
operator|(
name|res1
operator|->
name|regs
operator|&
name|res2
operator|->
name|regs
operator|)
operator|!=
name|HARD_CONST
argument_list|(
literal|0
argument_list|)
return|;
else|#
directive|else
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HARD_REG_SET_LONGS
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|res1
operator|->
name|regs
index|[
name|i
index|]
operator|&
name|res2
operator|->
name|regs
index|[
name|i
index|]
operator|)
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/* Return TRUE if any resource marked in RES, a `struct resources', is    referenced by INSN.  If INCLUDE_DELAYED_EFFECTS is set, return if the called    routine is using those resources.     We compute this by computing all the resources referenced by INSN and    seeing if this conflicts with RES.  It might be faster to directly check    ourselves, and this is the way it used to work, but it means duplicating    a large block of complex code.  */
end_comment

begin_function
specifier|static
name|int
name|insn_references_resource_p
parameter_list|(
name|insn
parameter_list|,
name|res
parameter_list|,
name|include_delayed_effects
parameter_list|)
specifier|register
name|rtx
name|insn
decl_stmt|;
specifier|register
name|struct
name|resources
modifier|*
name|res
decl_stmt|;
name|int
name|include_delayed_effects
decl_stmt|;
block|{
name|struct
name|resources
name|insn_res
decl_stmt|;
name|CLEAR_RESOURCE
argument_list|(
operator|&
name|insn_res
argument_list|)
expr_stmt|;
name|mark_referenced_resources
argument_list|(
name|insn
argument_list|,
operator|&
name|insn_res
argument_list|,
name|include_delayed_effects
argument_list|)
expr_stmt|;
return|return
name|resource_conflicts_p
argument_list|(
operator|&
name|insn_res
argument_list|,
name|res
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE if INSN modifies resources that are marked in RES.    INCLUDE_DELAYED_EFFECTS is set if the actions of that routine should be    included.   CC0 is only modified if it is explicitly set; see comments    in front of mark_set_resources for details.  */
end_comment

begin_function
specifier|static
name|int
name|insn_sets_resource_p
parameter_list|(
name|insn
parameter_list|,
name|res
parameter_list|,
name|include_delayed_effects
parameter_list|)
specifier|register
name|rtx
name|insn
decl_stmt|;
specifier|register
name|struct
name|resources
modifier|*
name|res
decl_stmt|;
name|int
name|include_delayed_effects
decl_stmt|;
block|{
name|struct
name|resources
name|insn_sets
decl_stmt|;
name|CLEAR_RESOURCE
argument_list|(
operator|&
name|insn_sets
argument_list|)
expr_stmt|;
name|mark_set_resources
argument_list|(
name|insn
argument_list|,
operator|&
name|insn_sets
argument_list|,
literal|0
argument_list|,
name|include_delayed_effects
argument_list|)
expr_stmt|;
return|return
name|resource_conflicts_p
argument_list|(
operator|&
name|insn_sets
argument_list|,
name|res
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find a label at the end of the function or before a RETURN.  If there is    none, make one.  */
end_comment

begin_function
specifier|static
name|rtx
name|find_end_label
parameter_list|()
block|{
name|rtx
name|insn
decl_stmt|;
comment|/* If we found one previously, return it.  */
if|if
condition|(
name|end_of_function_label
condition|)
return|return
name|end_of_function_label
return|;
comment|/* Otherwise, see if there is a label at the end of the function.  If there      is, it must be that RETURN insns aren't needed, so that is our return      label and we don't have to do anything else.  */
name|insn
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|||
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
operator|)
operator|)
condition|)
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* When a target threads its epilogue we might already have a       suitable return insn.  If so put a label before it for the      end_of_function_label.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|BARRIER
operator|&&
name|GET_CODE
argument_list|(
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|RETURN
condition|)
block|{
name|rtx
name|temp
init|=
name|PREV_INSN
argument_list|(
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
decl_stmt|;
name|end_of_function_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|end_of_function_label
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Put the label before an USE insns that may proceed the RETURN insn.  */
while|while
condition|(
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|USE
condition|)
name|temp
operator|=
name|PREV_INSN
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|emit_label_after
argument_list|(
name|end_of_function_label
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|end_of_function_label
operator|=
name|insn
expr_stmt|;
else|else
block|{
comment|/* Otherwise, make a new label and emit a RETURN and BARRIER, 	 if needed.  */
name|end_of_function_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|end_of_function_label
argument_list|)
operator|=
literal|0
expr_stmt|;
name|emit_label
argument_list|(
name|end_of_function_label
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_return
if|if
condition|(
name|HAVE_return
condition|)
block|{
comment|/* The return we make may have delay slots too.  */
name|rtx
name|insn
init|=
name|gen_return
argument_list|()
decl_stmt|;
name|insn
operator|=
name|emit_jump_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
if|if
condition|(
name|num_delay_slots
argument_list|(
name|insn
argument_list|)
operator|>
literal|0
condition|)
name|obstack_ptr_grow
argument_list|(
operator|&
name|unfilled_slots_obstack
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
comment|/* Show one additional use for this label so it won't go away until      we are done.  */
operator|++
name|LABEL_NUSES
argument_list|(
name|end_of_function_label
argument_list|)
expr_stmt|;
return|return
name|end_of_function_label
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Put INSN and LIST together in a SEQUENCE rtx of LENGTH, and replace    the pattern of INSN with the SEQUENCE.     Chain the insns so that NEXT_INSN of each insn in the sequence points to    the next and NEXT_INSN of the last insn in the sequence points to    the first insn after the sequence.  Similarly for PREV_INSN.  This makes    it easier to scan all insns.     Returns the SEQUENCE that replaces INSN.  */
end_comment

begin_function
specifier|static
name|rtx
name|emit_delay_sequence
parameter_list|(
name|insn
parameter_list|,
name|list
parameter_list|,
name|length
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|list
decl_stmt|;
name|int
name|length
decl_stmt|;
block|{
specifier|register
name|int
name|i
init|=
literal|1
decl_stmt|;
specifier|register
name|rtx
name|li
decl_stmt|;
name|int
name|had_barrier
init|=
literal|0
decl_stmt|;
comment|/* Allocate the rtvec to hold the insns and the SEQUENCE.  */
name|rtvec
name|seqv
init|=
name|rtvec_alloc
argument_list|(
name|length
operator|+
literal|1
argument_list|)
decl_stmt|;
name|rtx
name|seq
init|=
name|gen_rtx_SEQUENCE
argument_list|(
name|VOIDmode
argument_list|,
name|seqv
argument_list|)
decl_stmt|;
name|rtx
name|seq_insn
init|=
name|make_insn_raw
argument_list|(
name|seq
argument_list|)
decl_stmt|;
name|rtx
name|first
init|=
name|get_insns
argument_list|()
decl_stmt|;
name|rtx
name|last
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
comment|/* Make a copy of the insn having delay slots.  */
name|rtx
name|delay_insn
init|=
name|copy_rtx
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* If INSN is followed by a BARRIER, delete the BARRIER since it will only      confuse further processing.  Update LAST in case it was the last insn.        We will put the BARRIER back in later.  */
if|if
condition|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|BARRIER
condition|)
block|{
name|delete_insn
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|last
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|had_barrier
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Splice our SEQUENCE into the insn stream where INSN used to be.  */
name|NEXT_INSN
argument_list|(
name|seq_insn
argument_list|)
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|PREV_INSN
argument_list|(
name|seq_insn
argument_list|)
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|!=
name|last
condition|)
name|PREV_INSN
argument_list|(
name|NEXT_INSN
argument_list|(
name|seq_insn
argument_list|)
argument_list|)
operator|=
name|seq_insn
expr_stmt|;
if|if
condition|(
name|insn
operator|!=
name|first
condition|)
name|NEXT_INSN
argument_list|(
name|PREV_INSN
argument_list|(
name|seq_insn
argument_list|)
argument_list|)
operator|=
name|seq_insn
expr_stmt|;
comment|/* Note the calls to set_new_first_and_last_insn must occur after      SEQ_INSN has been completely spliced into the insn stream.       Otherwise CUR_INSN_UID will get set to an incorrect value because      set_new_first_and_last_insn will not find SEQ_INSN in the chain.  */
if|if
condition|(
name|insn
operator|==
name|last
condition|)
name|set_new_first_and_last_insn
argument_list|(
name|first
argument_list|,
name|seq_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|first
condition|)
name|set_new_first_and_last_insn
argument_list|(
name|seq_insn
argument_list|,
name|last
argument_list|)
expr_stmt|;
comment|/* Build our SEQUENCE and rebuild the insn chain.  */
name|XVECEXP
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|=
name|delay_insn
expr_stmt|;
name|INSN_DELETED_P
argument_list|(
name|delay_insn
argument_list|)
operator|=
literal|0
expr_stmt|;
name|PREV_INSN
argument_list|(
name|delay_insn
argument_list|)
operator|=
name|PREV_INSN
argument_list|(
name|seq_insn
argument_list|)
expr_stmt|;
for|for
control|(
name|li
operator|=
name|list
init|;
name|li
condition|;
name|li
operator|=
name|XEXP
argument_list|(
name|li
argument_list|,
literal|1
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
name|rtx
name|tem
init|=
name|XEXP
argument_list|(
name|li
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|note
decl_stmt|;
comment|/* Show that this copy of the insn isn't deleted.  */
name|INSN_DELETED_P
argument_list|(
name|tem
argument_list|)
operator|=
literal|0
expr_stmt|;
name|XVECEXP
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
operator|=
name|tem
expr_stmt|;
name|PREV_INSN
argument_list|(
name|tem
argument_list|)
operator|=
name|XVECEXP
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|,
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|XVECEXP
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|,
name|i
operator|-
literal|1
argument_list|)
argument_list|)
operator|=
name|tem
expr_stmt|;
comment|/* Remove any REG_DEAD notes because we can't rely on them now 	 that the insn has been moved.  */
for|for
control|(
name|note
operator|=
name|REG_NOTES
argument_list|(
name|tem
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_DEAD
condition|)
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
operator|=
name|const0_rtx
expr_stmt|;
block|}
name|NEXT_INSN
argument_list|(
name|XVECEXP
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|,
name|length
argument_list|)
argument_list|)
operator|=
name|NEXT_INSN
argument_list|(
name|seq_insn
argument_list|)
expr_stmt|;
comment|/* If the previous insn is a SEQUENCE, update the NEXT_INSN pointer on the      last insn in that SEQUENCE to point to us.  Similarly for the first      insn in the following insn if it is a SEQUENCE.  */
if|if
condition|(
name|PREV_INSN
argument_list|(
name|seq_insn
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|PREV_INSN
argument_list|(
name|seq_insn
argument_list|)
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|PREV_INSN
argument_list|(
name|seq_insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
condition|)
name|NEXT_INSN
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|PREV_INSN
argument_list|(
name|seq_insn
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|PREV_INSN
argument_list|(
name|seq_insn
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|)
operator|=
name|seq_insn
expr_stmt|;
if|if
condition|(
name|NEXT_INSN
argument_list|(
name|seq_insn
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|NEXT_INSN
argument_list|(
name|seq_insn
argument_list|)
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|NEXT_INSN
argument_list|(
name|seq_insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
condition|)
name|PREV_INSN
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|NEXT_INSN
argument_list|(
name|seq_insn
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
name|seq_insn
expr_stmt|;
comment|/* If there used to be a BARRIER, put it back.  */
if|if
condition|(
name|had_barrier
condition|)
name|emit_barrier_after
argument_list|(
name|seq_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|length
operator|+
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|seq_insn
return|;
block|}
end_function

begin_comment
comment|/* Add INSN to DELAY_LIST and return the head of the new list.  The list must    be in the order in which the insns are to be executed.  */
end_comment

begin_function
specifier|static
name|rtx
name|add_to_delay_list
parameter_list|(
name|insn
parameter_list|,
name|delay_list
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|delay_list
decl_stmt|;
block|{
comment|/* If we have an empty list, just make a new list element.  If      INSN has its block number recorded, clear it since we may      be moving the insn to a new block.  */
if|if
condition|(
name|delay_list
operator|==
literal|0
condition|)
block|{
name|struct
name|target_info
modifier|*
name|tinfo
decl_stmt|;
for|for
control|(
name|tinfo
operator|=
name|target_hash_table
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|%
name|TARGET_HASH_PRIME
index|]
init|;
name|tinfo
condition|;
name|tinfo
operator|=
name|tinfo
operator|->
name|next
control|)
if|if
condition|(
name|tinfo
operator|->
name|uid
operator|==
name|INSN_UID
argument_list|(
name|insn
argument_list|)
condition|)
break|break;
if|if
condition|(
name|tinfo
condition|)
name|tinfo
operator|->
name|block
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|gen_rtx_INSN_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|insn
argument_list|,
name|NULL_RTX
argument_list|)
return|;
block|}
comment|/* Otherwise this must be an INSN_LIST.  Add INSN to the end of the      list.  */
name|XEXP
argument_list|(
name|delay_list
argument_list|,
literal|1
argument_list|)
operator|=
name|add_to_delay_list
argument_list|(
name|insn
argument_list|,
name|XEXP
argument_list|(
name|delay_list
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|delay_list
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Delete INSN from the delay slot of the insn that it is in.  This may    produce an insn without anything in its delay slots.  */
end_comment

begin_function
specifier|static
name|void
name|delete_from_delay_slot
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|trial
decl_stmt|,
name|seq_insn
decl_stmt|,
name|seq
decl_stmt|,
name|prev
decl_stmt|;
name|rtx
name|delay_list
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* We first must find the insn containing the SEQUENCE with INSN in its      delay slot.  Do this by finding an insn, TRIAL, where      PREV_INSN (NEXT_INSN (TRIAL)) != TRIAL.  */
for|for
control|(
name|trial
operator|=
name|insn
init|;
name|PREV_INSN
argument_list|(
name|NEXT_INSN
argument_list|(
name|trial
argument_list|)
argument_list|)
operator|==
name|trial
condition|;
name|trial
operator|=
name|NEXT_INSN
argument_list|(
name|trial
argument_list|)
control|)
empty_stmt|;
name|seq_insn
operator|=
name|PREV_INSN
argument_list|(
name|NEXT_INSN
argument_list|(
name|trial
argument_list|)
argument_list|)
expr_stmt|;
name|seq
operator|=
name|PATTERN
argument_list|(
name|seq_insn
argument_list|)
expr_stmt|;
comment|/* Create a delay list consisting of all the insns other than the one      we are deleting (unless we were the only one).  */
if|if
condition|(
name|XVECLEN
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|)
operator|>
literal|2
condition|)
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|XVECEXP
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
operator|!=
name|insn
condition|)
name|delay_list
operator|=
name|add_to_delay_list
argument_list|(
name|XVECEXP
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|delay_list
argument_list|)
expr_stmt|;
comment|/* Delete the old SEQUENCE, re-emit the insn that used to have the delay      list, and rebuild the delay list if non-empty.  */
name|prev
operator|=
name|PREV_INSN
argument_list|(
name|seq_insn
argument_list|)
expr_stmt|;
name|trial
operator|=
name|XVECEXP
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|seq_insn
argument_list|)
expr_stmt|;
name|add_insn_after
argument_list|(
name|trial
argument_list|,
name|prev
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|trial
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
operator|(
name|simplejump_p
argument_list|(
name|trial
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|trial
argument_list|)
argument_list|)
operator|==
name|RETURN
operator|)
condition|)
name|emit_barrier_after
argument_list|(
name|trial
argument_list|)
expr_stmt|;
comment|/* If there are any delay insns, remit them.  Otherwise clear the      annul flag.  */
if|if
condition|(
name|delay_list
condition|)
name|trial
operator|=
name|emit_delay_sequence
argument_list|(
name|trial
argument_list|,
name|delay_list
argument_list|,
name|XVECLEN
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|)
operator|-
literal|2
argument_list|)
expr_stmt|;
else|else
name|INSN_ANNULLED_BRANCH_P
argument_list|(
name|trial
argument_list|)
operator|=
literal|0
expr_stmt|;
name|INSN_FROM_TARGET_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Show we need to fill this insn again.  */
name|obstack_ptr_grow
argument_list|(
operator|&
name|unfilled_slots_obstack
argument_list|,
name|trial
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Delete INSN, a JUMP_INSN.  If it is a conditional jump, we must track down    the insn that sets CC0 for it and delete it too.  */
end_comment

begin_function
specifier|static
name|void
name|delete_scheduled_jump
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
comment|/* Delete the insn that sets cc0 for us.  On machines without cc0, we could      delete the insn that sets the condition code, but it is hard to find it.      Since this case is rare anyway, don't bother trying; there would likely      be other insns that became dead anyway, which we wouldn't know to      delete.  */
ifdef|#
directive|ifdef
name|HAVE_cc0
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|cc0_rtx
argument_list|,
name|insn
argument_list|)
condition|)
block|{
name|rtx
name|note
init|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_CC_SETTER
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
comment|/* If a reg-note was found, it points to an insn to set CC0.  This 	 insn is in the delay list of some other insn.  So delete it from 	 the delay list it was in.  */
if|if
condition|(
name|note
condition|)
block|{
if|if
condition|(
operator|!
name|FIND_REG_INC_NOTE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
operator|&&
name|sets_cc0_p
argument_list|(
name|PATTERN
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|1
condition|)
name|delete_from_delay_slot
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The insn setting CC0 is our previous insn, but it may be in 	     a delay slot.  It will be the last insn in the delay slot, if 	     it is.  */
name|rtx
name|trial
init|=
name|previous_insn
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|trial
argument_list|)
operator|==
name|NOTE
condition|)
name|trial
operator|=
name|prev_nonnote_insn
argument_list|(
name|trial
argument_list|)
expr_stmt|;
if|if
condition|(
name|sets_cc0_p
argument_list|(
name|PATTERN
argument_list|(
name|trial
argument_list|)
argument_list|)
operator|!=
literal|1
operator|||
name|FIND_REG_INC_NOTE
argument_list|(
name|trial
argument_list|,
literal|0
argument_list|)
condition|)
return|return;
if|if
condition|(
name|PREV_INSN
argument_list|(
name|NEXT_INSN
argument_list|(
name|trial
argument_list|)
argument_list|)
operator|==
name|trial
condition|)
name|delete_insn
argument_list|(
name|trial
argument_list|)
expr_stmt|;
else|else
name|delete_from_delay_slot
argument_list|(
name|trial
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Counters for delay-slot filling.  */
end_comment

begin_define
define|#
directive|define
name|NUM_REORG_FUNCTIONS
value|2
end_define

begin_define
define|#
directive|define
name|MAX_DELAY_HISTOGRAM
value|3
end_define

begin_define
define|#
directive|define
name|MAX_REORG_PASSES
value|2
end_define

begin_decl_stmt
specifier|static
name|int
name|num_insns_needing_delays
index|[
name|NUM_REORG_FUNCTIONS
index|]
index|[
name|MAX_REORG_PASSES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|num_filled_delays
index|[
name|NUM_REORG_FUNCTIONS
index|]
index|[
name|MAX_DELAY_HISTOGRAM
operator|+
literal|1
index|]
index|[
name|MAX_REORG_PASSES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reorg_pass_number
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|note_delay_statistics
parameter_list|(
name|slots_filled
parameter_list|,
name|index
parameter_list|)
name|int
name|slots_filled
decl_stmt|,
name|index
decl_stmt|;
block|{
name|num_insns_needing_delays
index|[
name|index
index|]
index|[
name|reorg_pass_number
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|slots_filled
operator|>
name|MAX_DELAY_HISTOGRAM
condition|)
name|slots_filled
operator|=
name|MAX_DELAY_HISTOGRAM
expr_stmt|;
name|num_filled_delays
index|[
name|index
index|]
index|[
name|slots_filled
index|]
index|[
name|reorg_pass_number
index|]
operator|++
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
name|defined
argument_list|(
name|ANNUL_IFFALSE_SLOTS
argument_list|)
operator|||
name|defined
argument_list|(
name|ANNUL_IFTRUE_SLOTS
argument_list|)
end_if

begin_comment
comment|/* Optimize the following cases:     1.  When a conditional branch skips over only one instruction,        use an annulling branch and put that insn in the delay slot.        Use either a branch that annuls when the condition if true or        invert the test with a branch that annuls when the condition is        false.  This saves insns, since otherwise we must copy an insn        from the L1 target.          (orig)		 (skip)		(otherwise) 	Bcc.n L1	Bcc',a L1	Bcc,a L1' 	insn		insn		insn2       L1:	      L1:	      L1: 	insn2		insn2		insn2 	insn3		insn3	      L1': 					insn3     2.  When a conditional branch skips over only one instruction,        and after that, it unconditionally branches somewhere else,        perform the similar optimization. This saves executing the        second branch in the case where the inverted condition is true.  	Bcc.n L1	Bcc',a L2 	insn		insn       L1:	      L1: 	Bra L2		Bra L2     INSN is a JUMP_INSN.     This should be expanded to skip over N insns, where N is the number    of delay slots required.  */
end_comment

begin_function
specifier|static
name|rtx
name|optimize_skip
parameter_list|(
name|insn
parameter_list|)
specifier|register
name|rtx
name|insn
decl_stmt|;
block|{
specifier|register
name|rtx
name|trial
init|=
name|next_nonnote_insn
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|next_trial
init|=
name|next_active_insn
argument_list|(
name|trial
argument_list|)
decl_stmt|;
name|rtx
name|delay_list
init|=
literal|0
decl_stmt|;
name|rtx
name|target_label
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|flags
operator|=
name|get_jump_flags
argument_list|(
name|insn
argument_list|,
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|trial
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|trial
argument_list|)
operator|!=
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|trial
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
operator|||
name|recog_memoized
argument_list|(
name|trial
argument_list|)
operator|<
literal|0
operator|||
operator|(
operator|!
name|eligible_for_annul_false
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|,
name|trial
argument_list|,
name|flags
argument_list|)
operator|&&
operator|!
name|eligible_for_annul_true
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|,
name|trial
argument_list|,
name|flags
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
comment|/* There are two cases where we are just executing one insn (we assume      here that a branch requires only one insn; this should be generalized      at some point):  Where the branch goes around a single insn or where      we have one insn followed by a branch to the same label we branch to.      In both of these cases, inverting the jump and annulling the delay      slot give the same effect in fewer insns.  */
if|if
condition|(
operator|(
name|next_trial
operator|==
name|next_active_insn
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|next_trial
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|next_trial
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_LABEL
argument_list|(
name|next_trial
argument_list|)
operator|&&
operator|(
name|simplejump_p
argument_list|(
name|next_trial
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|next_trial
argument_list|)
argument_list|)
operator|==
name|RETURN
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|eligible_for_annul_false
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|,
name|trial
argument_list|,
name|flags
argument_list|)
condition|)
block|{
if|if
condition|(
name|invert_jump
argument_list|(
name|insn
argument_list|,
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
name|INSN_FROM_TARGET_P
argument_list|(
name|trial
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|eligible_for_annul_true
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|,
name|trial
argument_list|,
name|flags
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
name|delay_list
operator|=
name|add_to_delay_list
argument_list|(
name|trial
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|next_trial
operator|=
name|next_active_insn
argument_list|(
name|trial
argument_list|)
expr_stmt|;
name|update_block
argument_list|(
name|trial
argument_list|,
name|trial
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|trial
argument_list|)
expr_stmt|;
comment|/* Also, if we are targeting an unconditional 	 branch, thread our jump to the target of that branch.  Don't 	 change this into a RETURN here, because it may not accept what 	 we have in the delay slot.  We'll fix this up later.  */
if|if
condition|(
name|next_trial
operator|&&
name|GET_CODE
argument_list|(
name|next_trial
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
operator|(
name|simplejump_p
argument_list|(
name|next_trial
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|next_trial
argument_list|)
argument_list|)
operator|==
name|RETURN
operator|)
condition|)
block|{
name|target_label
operator|=
name|JUMP_LABEL
argument_list|(
name|next_trial
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_label
operator|==
literal|0
condition|)
name|target_label
operator|=
name|find_end_label
argument_list|()
expr_stmt|;
comment|/* Recompute the flags based on TARGET_LABEL since threading 	     the jump to TARGET_LABEL may change the direction of the 	     jump (which may change the circumstances in which the 	     delay slot is nullified).  */
name|flags
operator|=
name|get_jump_flags
argument_list|(
name|insn
argument_list|,
name|target_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|eligible_for_annul_true
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|,
name|trial
argument_list|,
name|flags
argument_list|)
condition|)
name|reorg_redirect_jump
argument_list|(
name|insn
argument_list|,
name|target_label
argument_list|)
expr_stmt|;
block|}
name|INSN_ANNULLED_BRANCH_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|delay_list
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/*  Encode and return branch direction and prediction information for     INSN assuming it will jump to LABEL.      Non conditional branches return no direction information and     are predicted as very likely taken.  */
end_comment

begin_function
specifier|static
name|int
name|get_jump_flags
parameter_list|(
name|insn
parameter_list|,
name|label
parameter_list|)
name|rtx
name|insn
decl_stmt|,
name|label
decl_stmt|;
block|{
name|int
name|flags
decl_stmt|;
comment|/* get_jump_flags can be passed any insn with delay slots, these may      be INSNs, CALL_INSNs, or JUMP_INSNs.  Only JUMP_INSNs have branch      direction information, and only if they are conditional jumps.       If LABEL is zero, then there is no way to determine the branch      direction.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
operator|(
name|condjump_p
argument_list|(
name|insn
argument_list|)
operator|||
name|condjump_in_parallel_p
argument_list|(
name|insn
argument_list|)
operator|)
operator|&&
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|<=
name|max_uid
operator|&&
name|label
operator|!=
literal|0
operator|&&
name|INSN_UID
argument_list|(
name|label
argument_list|)
operator|<=
name|max_uid
condition|)
name|flags
operator|=
operator|(
name|uid_to_ruid
index|[
name|INSN_UID
argument_list|(
name|label
argument_list|)
index|]
operator|>
name|uid_to_ruid
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
operator|)
condition|?
name|ATTR_FLAG_forward
else|:
name|ATTR_FLAG_backward
expr_stmt|;
comment|/* No valid direction information.  */
else|else
name|flags
operator|=
literal|0
expr_stmt|;
comment|/* If insn is a conditional branch call mostly_true_jump to get      determine the branch prediction.         Non conditional branches are predicted as very likely taken.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
operator|(
name|condjump_p
argument_list|(
name|insn
argument_list|)
operator|||
name|condjump_in_parallel_p
argument_list|(
name|insn
argument_list|)
operator|)
condition|)
block|{
name|int
name|prediction
decl_stmt|;
name|prediction
operator|=
name|mostly_true_jump
argument_list|(
name|insn
argument_list|,
name|get_branch_condition
argument_list|(
name|insn
argument_list|,
name|label
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|prediction
condition|)
block|{
case|case
literal|2
case|:
name|flags
operator||=
operator|(
name|ATTR_FLAG_very_likely
operator||
name|ATTR_FLAG_likely
operator|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|flags
operator||=
name|ATTR_FLAG_likely
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|flags
operator||=
name|ATTR_FLAG_unlikely
expr_stmt|;
break|break;
case|case
operator|-
literal|1
case|:
name|flags
operator||=
operator|(
name|ATTR_FLAG_very_unlikely
operator||
name|ATTR_FLAG_unlikely
operator|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
else|else
name|flags
operator||=
operator|(
name|ATTR_FLAG_very_likely
operator||
name|ATTR_FLAG_likely
operator|)
expr_stmt|;
return|return
name|flags
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if INSN is a destination that will be branched to rarely (the    return point of a function); return 2 if DEST will be branched to very    rarely (a call to a function that doesn't return).  Otherwise,    return 0.  */
end_comment

begin_function
specifier|static
name|int
name|rare_destination
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|int
name|jump_count
init|=
literal|0
decl_stmt|;
name|rtx
name|next
decl_stmt|;
for|for
control|(
init|;
name|insn
condition|;
name|insn
operator|=
name|next
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
condition|)
name|insn
operator|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|CODE_LABEL
case|:
return|return
literal|0
return|;
case|case
name|BARRIER
case|:
comment|/* A BARRIER can either be after a JUMP_INSN or a CALL_INSN.  We  	     don't scan past JUMP_INSNs, so any barrier we find here must 	     have been after a CALL_INSN and hence mean the call doesn't 	     return.  */
return|return
literal|2
return|;
case|case
name|JUMP_INSN
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|RETURN
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|simplejump_p
argument_list|(
name|insn
argument_list|)
operator|&&
name|jump_count
operator|++
operator|<
literal|10
condition|)
name|next
operator|=
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
expr_stmt|;
else|else
return|return
literal|0
return|;
default|default:
break|break;
block|}
block|}
comment|/* If we got here it means we hit the end of the function.  So this      is an unlikely destination.  */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return truth value of the statement that this branch    is mostly taken.  If we think that the branch is extremely likely    to be taken, we return 2.  If the branch is slightly more likely to be    taken, return 1.  If the branch is slightly less likely to be taken,    return 0 and if the branch is highly unlikely to be taken, return -1.     CONDITION, if non-zero, is the condition that JUMP_INSN is testing.  */
end_comment

begin_function
specifier|static
name|int
name|mostly_true_jump
parameter_list|(
name|jump_insn
parameter_list|,
name|condition
parameter_list|)
name|rtx
name|jump_insn
decl_stmt|,
name|condition
decl_stmt|;
block|{
name|rtx
name|target_label
init|=
name|JUMP_LABEL
argument_list|(
name|jump_insn
argument_list|)
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|rare_dest
init|=
name|rare_destination
argument_list|(
name|target_label
argument_list|)
decl_stmt|;
name|int
name|rare_fallthrough
init|=
name|rare_destination
argument_list|(
name|NEXT_INSN
argument_list|(
name|jump_insn
argument_list|)
argument_list|)
decl_stmt|;
comment|/* If branch probabilities are available, then use that number since it      always gives a correct answer.  */
if|if
condition|(
name|flag_branch_probabilities
condition|)
block|{
name|rtx
name|note
init|=
name|find_reg_note
argument_list|(
name|jump_insn
argument_list|,
name|REG_BR_PROB
argument_list|,
literal|0
argument_list|)
decl_stmt|;
empty_stmt|;
if|if
condition|(
name|note
condition|)
block|{
name|int
name|prob
init|=
name|XINT
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|prob
operator|>=
name|REG_BR_PROB_BASE
operator|*
literal|9
operator|/
literal|10
condition|)
return|return
literal|2
return|;
elseif|else
if|if
condition|(
name|prob
operator|>=
name|REG_BR_PROB_BASE
operator|/
literal|2
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|prob
operator|>=
name|REG_BR_PROB_BASE
operator|/
literal|10
condition|)
return|return
literal|0
return|;
else|else
return|return
operator|-
literal|1
return|;
block|}
block|}
comment|/* If this is a branch outside a loop, it is highly unlikely.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|jump_insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|jump_insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|IF_THEN_ELSE
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|jump_insn
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|LABEL_OUTSIDE_LOOP_P
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|jump_insn
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|jump_insn
argument_list|)
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|LABEL_OUTSIDE_LOOP_P
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|jump_insn
argument_list|)
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|target_label
condition|)
block|{
comment|/* If this is the test of a loop, it is very likely true.  We scan 	 backwards from the target label.  If we find a NOTE_INSN_LOOP_BEG 	 before the next real insn, we assume the branch is to the top of  	 the loop.  */
for|for
control|(
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|target_label
argument_list|)
init|;
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
condition|)
return|return
literal|2
return|;
comment|/* If this is a jump to the test of a loop, it is likely true.  We scan 	 forwards from the target label.  If we find a NOTE_INSN_LOOP_VTOP 	 before the next real insn, we assume the branch is to the loop branch 	 test.  */
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|target_label
argument_list|)
init|;
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_VTOP
condition|)
return|return
literal|1
return|;
block|}
comment|/* Look at the relative rarities of the fallthrough and destination.  If      they differ, we can predict the branch that way.  */
switch|switch
condition|(
name|rare_fallthrough
operator|-
name|rare_dest
condition|)
block|{
case|case
operator|-
literal|2
case|:
return|return
operator|-
literal|1
return|;
case|case
operator|-
literal|1
case|:
return|return
literal|0
return|;
case|case
literal|0
case|:
break|break;
case|case
literal|1
case|:
return|return
literal|1
return|;
case|case
literal|2
case|:
return|return
literal|2
return|;
block|}
comment|/* If we couldn't figure out what this jump was, assume it won't be       taken.  This should be rare.  */
if|if
condition|(
name|condition
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* EQ tests are usually false and NE tests are usually true.  Also,      most quantities are positive, so we can make the appropriate guesses      about signed comparisons against zero.  */
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|condition
argument_list|)
condition|)
block|{
case|case
name|CONST_INT
case|:
comment|/* Unconditional branch.  */
return|return
literal|1
return|;
case|case
name|EQ
case|:
return|return
literal|0
return|;
case|case
name|NE
case|:
return|return
literal|1
return|;
case|case
name|LE
case|:
case|case
name|LT
case|:
if|if
condition|(
name|XEXP
argument_list|(
name|condition
argument_list|,
literal|1
argument_list|)
operator|==
name|const0_rtx
condition|)
return|return
literal|0
return|;
break|break;
case|case
name|GE
case|:
case|case
name|GT
case|:
if|if
condition|(
name|XEXP
argument_list|(
name|condition
argument_list|,
literal|1
argument_list|)
operator|==
name|const0_rtx
condition|)
return|return
literal|1
return|;
break|break;
default|default:
break|break;
block|}
comment|/* Predict backward branches usually take, forward branches usually not.  If      we don't know whether this is forward or backward, assume the branch      will be taken, since most are.  */
return|return
operator|(
name|target_label
operator|==
literal|0
operator|||
name|INSN_UID
argument_list|(
name|jump_insn
argument_list|)
operator|>
name|max_uid
operator|||
name|INSN_UID
argument_list|(
name|target_label
argument_list|)
operator|>
name|max_uid
operator|||
operator|(
name|uid_to_ruid
index|[
name|INSN_UID
argument_list|(
name|jump_insn
argument_list|)
index|]
operator|>
name|uid_to_ruid
index|[
name|INSN_UID
argument_list|(
name|target_label
argument_list|)
index|]
operator|)
operator|)
return|;
empty_stmt|;
block|}
end_function

begin_comment
comment|/* Return the condition under which INSN will branch to TARGET.  If TARGET    is zero, return the condition under which INSN will return.  If INSN is    an unconditional branch, return const_true_rtx.  If INSN isn't a simple    type of jump, or it doesn't go to TARGET, return 0.  */
end_comment

begin_function
specifier|static
name|rtx
name|get_branch_condition
parameter_list|(
name|insn
parameter_list|,
name|target
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|target
decl_stmt|;
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|src
decl_stmt|;
if|if
condition|(
name|condjump_in_parallel_p
argument_list|(
name|insn
argument_list|)
condition|)
name|pat
operator|=
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|RETURN
condition|)
return|return
name|target
operator|==
literal|0
condition|?
name|const_true_rtx
else|:
literal|0
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|!=
name|SET
operator|||
name|SET_DEST
argument_list|(
name|pat
argument_list|)
operator|!=
name|pc_rtx
condition|)
return|return
literal|0
return|;
name|src
operator|=
name|SET_SRC
argument_list|(
name|pat
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
operator|==
name|target
condition|)
return|return
name|const_true_rtx
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|IF_THEN_ELSE
operator|&&
operator|(
operator|(
name|target
operator|==
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|RETURN
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|target
operator|)
operator|)
operator|&&
name|XEXP
argument_list|(
name|src
argument_list|,
literal|2
argument_list|)
operator|==
name|pc_rtx
condition|)
return|return
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|IF_THEN_ELSE
operator|&&
operator|(
operator|(
name|target
operator|==
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|RETURN
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|target
operator|)
operator|)
operator|&&
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
operator|==
name|pc_rtx
condition|)
return|return
name|gen_rtx_fmt_ee
argument_list|(
name|reverse_condition
argument_list|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if CONDITION is more strict than the condition of    INSN, i.e., if INSN will always branch if CONDITION is true.  */
end_comment

begin_function
specifier|static
name|int
name|condition_dominates_p
parameter_list|(
name|condition
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|condition
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|other_condition
init|=
name|get_branch_condition
argument_list|(
name|insn
argument_list|,
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
decl_stmt|;
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|condition
argument_list|)
decl_stmt|;
name|enum
name|rtx_code
name|other_code
decl_stmt|;
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|condition
argument_list|,
name|other_condition
argument_list|)
operator|||
name|other_condition
operator|==
name|const_true_rtx
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|condition
operator|==
name|const_true_rtx
operator|||
name|other_condition
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|other_code
operator|=
name|GET_CODE
argument_list|(
name|other_condition
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|!=
literal|2
operator|||
name|GET_RTX_LENGTH
argument_list|(
name|other_code
argument_list|)
operator|!=
literal|2
operator|||
operator|!
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|condition
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|other_condition
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
operator|!
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|condition
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|other_condition
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|comparison_dominates_p
argument_list|(
name|code
argument_list|,
name|other_code
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if redirecting JUMP to NEWLABEL does not invalidate    any insns already in the delay slot of JUMP.  */
end_comment

begin_function
specifier|static
name|int
name|redirect_with_delay_slots_safe_p
parameter_list|(
name|jump
parameter_list|,
name|newlabel
parameter_list|,
name|seq
parameter_list|)
name|rtx
name|jump
decl_stmt|,
name|newlabel
decl_stmt|,
name|seq
decl_stmt|;
block|{
name|int
name|flags
decl_stmt|,
name|i
decl_stmt|;
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|seq
argument_list|)
decl_stmt|;
comment|/* Make sure all the delay slots of this jump would still      be valid after threading the jump.  If they are still      valid, then return non-zero.  */
name|flags
operator|=
name|get_jump_flags
argument_list|(
name|jump
argument_list|,
name|newlabel
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
operator|(
ifdef|#
directive|ifdef
name|ANNUL_IFFALSE_SLOTS
operator|(
name|INSN_ANNULLED_BRANCH_P
argument_list|(
name|jump
argument_list|)
operator|&&
name|INSN_FROM_TARGET_P
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|)
condition|?
name|eligible_for_annul_false
argument_list|(
name|jump
argument_list|,
name|i
operator|-
literal|1
argument_list|,
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|flags
argument_list|)
else|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ANNUL_IFTRUE_SLOTS
operator|(
name|INSN_ANNULLED_BRANCH_P
argument_list|(
name|jump
argument_list|)
operator|&&
operator|!
name|INSN_FROM_TARGET_P
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|)
condition|?
name|eligible_for_annul_true
argument_list|(
name|jump
argument_list|,
name|i
operator|-
literal|1
argument_list|,
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|flags
argument_list|)
else|:
endif|#
directive|endif
name|eligible_for_delay
argument_list|(
name|jump
argument_list|,
name|i
operator|-
literal|1
argument_list|,
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|flags
argument_list|)
operator|)
condition|)
break|break;
return|return
operator|(
name|i
operator|==
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if redirecting JUMP to NEWLABEL does not invalidate    any insns we wish to place in the delay slot of JUMP.  */
end_comment

begin_function
specifier|static
name|int
name|redirect_with_delay_list_safe_p
parameter_list|(
name|jump
parameter_list|,
name|newlabel
parameter_list|,
name|delay_list
parameter_list|)
name|rtx
name|jump
decl_stmt|,
name|newlabel
decl_stmt|,
name|delay_list
decl_stmt|;
block|{
name|int
name|flags
decl_stmt|,
name|i
decl_stmt|;
name|rtx
name|li
decl_stmt|;
comment|/* Make sure all the insns in DELAY_LIST would still be      valid after threading the jump.  If they are still      valid, then return non-zero.  */
name|flags
operator|=
name|get_jump_flags
argument_list|(
name|jump
argument_list|,
name|newlabel
argument_list|)
expr_stmt|;
for|for
control|(
name|li
operator|=
name|delay_list
operator|,
name|i
operator|=
literal|0
init|;
name|li
condition|;
name|li
operator|=
name|XEXP
argument_list|(
name|li
argument_list|,
literal|1
argument_list|)
operator|,
name|i
operator|++
control|)
if|if
condition|(
operator|!
operator|(
ifdef|#
directive|ifdef
name|ANNUL_IFFALSE_SLOTS
operator|(
name|INSN_ANNULLED_BRANCH_P
argument_list|(
name|jump
argument_list|)
operator|&&
name|INSN_FROM_TARGET_P
argument_list|(
name|XEXP
argument_list|(
name|li
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|?
name|eligible_for_annul_false
argument_list|(
name|jump
argument_list|,
name|i
argument_list|,
name|XEXP
argument_list|(
name|li
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
argument_list|)
else|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ANNUL_IFTRUE_SLOTS
operator|(
name|INSN_ANNULLED_BRANCH_P
argument_list|(
name|jump
argument_list|)
operator|&&
operator|!
name|INSN_FROM_TARGET_P
argument_list|(
name|XEXP
argument_list|(
name|li
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|?
name|eligible_for_annul_true
argument_list|(
name|jump
argument_list|,
name|i
argument_list|,
name|XEXP
argument_list|(
name|li
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
argument_list|)
else|:
endif|#
directive|endif
name|eligible_for_delay
argument_list|(
name|jump
argument_list|,
name|i
argument_list|,
name|XEXP
argument_list|(
name|li
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
argument_list|)
operator|)
condition|)
break|break;
return|return
operator|(
name|li
operator|==
name|NULL
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* INSN branches to an insn whose pattern SEQ is a SEQUENCE.  Given that    the condition tested by INSN is CONDITION and the resources shown in    OTHER_NEEDED are needed after INSN, see whether INSN can take all the insns    from SEQ's delay list, in addition to whatever insns it may execute    (in DELAY_LIST).   SETS and NEEDED are denote resources already set and    needed while searching for delay slot insns.  Return the concatenated    delay list if possible, otherwise, return 0.     SLOTS_TO_FILL is the total number of slots required by INSN, and    PSLOTS_FILLED points to the number filled so far (also the number of    insns in DELAY_LIST).  It is updated with the number that have been    filled from the SEQUENCE, if any.     PANNUL_P points to a non-zero value if we already know that we need    to annul INSN.  If this routine determines that annulling is needed,    it may set that value non-zero.     PNEW_THREAD points to a location that is to receive the place at which    execution should continue.  */
end_comment

begin_function
specifier|static
name|rtx
name|steal_delay_list_from_target
parameter_list|(
name|insn
parameter_list|,
name|condition
parameter_list|,
name|seq
parameter_list|,
name|delay_list
parameter_list|,
name|sets
parameter_list|,
name|needed
parameter_list|,
name|other_needed
parameter_list|,
name|slots_to_fill
parameter_list|,
name|pslots_filled
parameter_list|,
name|pannul_p
parameter_list|,
name|pnew_thread
parameter_list|)
name|rtx
name|insn
decl_stmt|,
name|condition
decl_stmt|;
name|rtx
name|seq
decl_stmt|;
name|rtx
name|delay_list
decl_stmt|;
name|struct
name|resources
modifier|*
name|sets
decl_stmt|,
decl|*
name|needed
decl_stmt|,
modifier|*
name|other_needed
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|slots_to_fill
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|pslots_filled
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|pannul_p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
modifier|*
name|pnew_thread
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|rtx
name|temp
decl_stmt|;
name|int
name|slots_remaining
init|=
name|slots_to_fill
operator|-
operator|*
name|pslots_filled
decl_stmt|;
name|int
name|total_slots_filled
init|=
operator|*
name|pslots_filled
decl_stmt|;
name|rtx
name|new_delay_list
init|=
literal|0
decl_stmt|;
name|int
name|must_annul
init|=
operator|*
name|pannul_p
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* We can't do anything if there are more delay slots in SEQ than we      can handle, or if we don't know that it will be a taken branch.      We know that it will be a taken branch if it is either an unconditional      branch or a conditional branch with a stricter branch condition.       Also, exit if the branch has more than one set, since then it is computing      other results that can't be ignored, e.g. the HPPA mov&branch instruction.      ??? It may be possible to move other sets into INSN in addition to      moving the instructions in the delay slots.  */
if|if
condition|(
name|XVECLEN
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
operator|>
name|slots_remaining
operator|||
operator|!
name|condition_dominates_p
argument_list|(
name|condition
argument_list|,
name|XVECEXP
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
operator|!
name|single_set
argument_list|(
name|XVECEXP
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|delay_list
return|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|trial
init|=
name|XVECEXP
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|int
name|flags
decl_stmt|;
if|if
condition|(
name|insn_references_resource_p
argument_list|(
name|trial
argument_list|,
name|sets
argument_list|,
literal|0
argument_list|)
operator|||
name|insn_sets_resource_p
argument_list|(
name|trial
argument_list|,
name|needed
argument_list|,
literal|0
argument_list|)
operator|||
name|insn_sets_resource_p
argument_list|(
name|trial
argument_list|,
name|sets
argument_list|,
literal|0
argument_list|)
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* If TRIAL sets CC0, we can't copy it, so we can't steal this 	     delay list.  */
operator|||
name|find_reg_note
argument_list|(
name|trial
argument_list|,
name|REG_CC_USER
argument_list|,
name|NULL_RTX
argument_list|)
endif|#
directive|endif
comment|/* If TRIAL is from the fallthrough code of an annulled branch insn 	     in SEQ, we cannot use it.  */
operator|||
operator|(
name|INSN_ANNULLED_BRANCH_P
argument_list|(
name|XVECEXP
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|!
name|INSN_FROM_TARGET_P
argument_list|(
name|trial
argument_list|)
operator|)
condition|)
return|return
name|delay_list
return|;
comment|/* If this insn was already done (usually in a previous delay slot), 	 pretend we put it in our delay slot.  */
if|if
condition|(
name|redundant_insn
argument_list|(
name|trial
argument_list|,
name|insn
argument_list|,
name|new_delay_list
argument_list|)
condition|)
continue|continue;
comment|/* We will end up re-vectoring this branch, so compute flags 	 based on jumping to the new label.  */
name|flags
operator|=
name|get_jump_flags
argument_list|(
name|insn
argument_list|,
name|JUMP_LABEL
argument_list|(
name|XVECEXP
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|must_annul
operator|&&
operator|(
operator|(
name|condition
operator|==
name|const_true_rtx
operator|||
operator|(
operator|!
name|insn_sets_resource_p
argument_list|(
name|trial
argument_list|,
name|other_needed
argument_list|,
literal|0
argument_list|)
operator|&&
operator|!
name|may_trap_p
argument_list|(
name|PATTERN
argument_list|(
name|trial
argument_list|)
argument_list|)
operator|)
operator|)
operator|)
condition|?
name|eligible_for_delay
argument_list|(
name|insn
argument_list|,
name|total_slots_filled
argument_list|,
name|trial
argument_list|,
name|flags
argument_list|)
else|:
operator|(
name|must_annul
operator|=
literal|1
operator|,
name|eligible_for_annul_false
argument_list|(
name|insn
argument_list|,
name|total_slots_filled
argument_list|,
name|trial
argument_list|,
name|flags
argument_list|)
operator|)
condition|)
block|{
name|temp
operator|=
name|copy_rtx
argument_list|(
name|trial
argument_list|)
expr_stmt|;
name|INSN_FROM_TARGET_P
argument_list|(
name|temp
argument_list|)
operator|=
literal|1
expr_stmt|;
name|new_delay_list
operator|=
name|add_to_delay_list
argument_list|(
name|temp
argument_list|,
name|new_delay_list
argument_list|)
expr_stmt|;
name|total_slots_filled
operator|++
expr_stmt|;
if|if
condition|(
operator|--
name|slots_remaining
operator|==
literal|0
condition|)
break|break;
block|}
else|else
return|return
name|delay_list
return|;
block|}
comment|/* Show the place to which we will be branching.  */
operator|*
name|pnew_thread
operator|=
name|next_active_insn
argument_list|(
name|JUMP_LABEL
argument_list|(
name|XVECEXP
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Add any new insns to the delay list and update the count of the      number of slots filled.  */
operator|*
name|pslots_filled
operator|=
name|total_slots_filled
expr_stmt|;
operator|*
name|pannul_p
operator|=
name|must_annul
expr_stmt|;
if|if
condition|(
name|delay_list
operator|==
literal|0
condition|)
return|return
name|new_delay_list
return|;
for|for
control|(
name|temp
operator|=
name|new_delay_list
init|;
name|temp
condition|;
name|temp
operator|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|1
argument_list|)
control|)
name|delay_list
operator|=
name|add_to_delay_list
argument_list|(
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|delay_list
argument_list|)
expr_stmt|;
return|return
name|delay_list
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Similar to steal_delay_list_from_target except that SEQ is on the     fallthrough path of INSN.  Here we only do something if the delay insn    of SEQ is an unconditional branch.  In that case we steal its delay slot    for INSN since unconditional branches are much easier to fill.  */
end_comment

begin_function
specifier|static
name|rtx
name|steal_delay_list_from_fallthrough
parameter_list|(
name|insn
parameter_list|,
name|condition
parameter_list|,
name|seq
parameter_list|,
name|delay_list
parameter_list|,
name|sets
parameter_list|,
name|needed
parameter_list|,
name|other_needed
parameter_list|,
name|slots_to_fill
parameter_list|,
name|pslots_filled
parameter_list|,
name|pannul_p
parameter_list|)
name|rtx
name|insn
decl_stmt|,
name|condition
decl_stmt|;
name|rtx
name|seq
decl_stmt|;
name|rtx
name|delay_list
decl_stmt|;
name|struct
name|resources
modifier|*
name|sets
decl_stmt|,
decl|*
name|needed
decl_stmt|,
modifier|*
name|other_needed
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|slots_to_fill
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|pslots_filled
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|pannul_p
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|flags
operator|=
name|get_jump_flags
argument_list|(
name|insn
argument_list|,
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We can't do anything if SEQ's delay insn isn't an      unconditional branch.  */
if|if
condition|(
operator|!
name|simplejump_p
argument_list|(
name|XVECEXP
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|XVECEXP
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|RETURN
condition|)
return|return
name|delay_list
return|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|trial
init|=
name|XVECEXP
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
comment|/* If TRIAL sets CC0, stealing it will move it too far from the use 	 of CC0.  */
if|if
condition|(
name|insn_references_resource_p
argument_list|(
name|trial
argument_list|,
name|sets
argument_list|,
literal|0
argument_list|)
operator|||
name|insn_sets_resource_p
argument_list|(
name|trial
argument_list|,
name|needed
argument_list|,
literal|0
argument_list|)
operator|||
name|insn_sets_resource_p
argument_list|(
name|trial
argument_list|,
name|sets
argument_list|,
literal|0
argument_list|)
ifdef|#
directive|ifdef
name|HAVE_cc0
operator|||
name|sets_cc0_p
argument_list|(
name|PATTERN
argument_list|(
name|trial
argument_list|)
argument_list|)
endif|#
directive|endif
condition|)
break|break;
comment|/* If this insn was already done, we don't need it.  */
if|if
condition|(
name|redundant_insn
argument_list|(
name|trial
argument_list|,
name|insn
argument_list|,
name|delay_list
argument_list|)
condition|)
block|{
name|delete_from_delay_slot
argument_list|(
name|trial
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
operator|*
name|pannul_p
operator|&&
operator|(
operator|(
name|condition
operator|==
name|const_true_rtx
operator|||
operator|(
operator|!
name|insn_sets_resource_p
argument_list|(
name|trial
argument_list|,
name|other_needed
argument_list|,
literal|0
argument_list|)
operator|&&
operator|!
name|may_trap_p
argument_list|(
name|PATTERN
argument_list|(
name|trial
argument_list|)
argument_list|)
operator|)
operator|)
operator|)
condition|?
name|eligible_for_delay
argument_list|(
name|insn
argument_list|,
operator|*
name|pslots_filled
argument_list|,
name|trial
argument_list|,
name|flags
argument_list|)
else|:
operator|(
operator|*
name|pannul_p
operator|=
literal|1
operator|,
name|eligible_for_annul_true
argument_list|(
name|insn
argument_list|,
operator|*
name|pslots_filled
argument_list|,
name|trial
argument_list|,
name|flags
argument_list|)
operator|)
condition|)
block|{
name|delete_from_delay_slot
argument_list|(
name|trial
argument_list|)
expr_stmt|;
name|delay_list
operator|=
name|add_to_delay_list
argument_list|(
name|trial
argument_list|,
name|delay_list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
operator|(
operator|*
name|pslots_filled
operator|)
operator|==
name|slots_to_fill
condition|)
break|break;
block|}
else|else
break|break;
block|}
return|return
name|delay_list
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Try merging insns starting at THREAD which match exactly the insns in    INSN's delay list.     If all insns were matched and the insn was previously annulling, the    annul bit will be cleared.     For each insn that is merged, if the branch is or will be non-annulling,    we delete the merged insn.  */
end_comment

begin_function
specifier|static
name|void
name|try_merge_delay_insns
parameter_list|(
name|insn
parameter_list|,
name|thread
parameter_list|)
name|rtx
name|insn
decl_stmt|,
name|thread
decl_stmt|;
block|{
name|rtx
name|trial
decl_stmt|,
name|next_trial
decl_stmt|;
name|rtx
name|delay_insn
init|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|annul_p
init|=
name|INSN_ANNULLED_BRANCH_P
argument_list|(
name|delay_insn
argument_list|)
decl_stmt|;
name|int
name|slot_number
init|=
literal|1
decl_stmt|;
name|int
name|num_slots
init|=
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|next_to_match
init|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|slot_number
argument_list|)
decl_stmt|;
name|struct
name|resources
name|set
decl_stmt|,
name|needed
decl_stmt|;
name|rtx
name|merged_insns
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|flags
operator|=
name|get_jump_flags
argument_list|(
name|delay_insn
argument_list|,
name|JUMP_LABEL
argument_list|(
name|delay_insn
argument_list|)
argument_list|)
expr_stmt|;
name|CLEAR_RESOURCE
argument_list|(
operator|&
name|needed
argument_list|)
expr_stmt|;
name|CLEAR_RESOURCE
argument_list|(
operator|&
name|set
argument_list|)
expr_stmt|;
comment|/* If this is not an annulling branch, take into account anything needed in      NEXT_TO_MATCH.  This prevents two increments from being incorrectly      folded into one.  If we are annulling, this would be the correct      thing to do.  (The alternative, looking at things set in NEXT_TO_MATCH      will essentially disable this optimization.  This method is somewhat of      a kludge, but I don't see a better way.)  */
if|if
condition|(
operator|!
name|annul_p
condition|)
name|mark_referenced_resources
argument_list|(
name|next_to_match
argument_list|,
operator|&
name|needed
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|trial
operator|=
name|thread
init|;
operator|!
name|stop_search_p
argument_list|(
name|trial
argument_list|,
literal|1
argument_list|)
condition|;
name|trial
operator|=
name|next_trial
control|)
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|trial
argument_list|)
decl_stmt|;
name|rtx
name|oldtrial
init|=
name|trial
decl_stmt|;
name|next_trial
operator|=
name|next_nonnote_insn
argument_list|(
name|trial
argument_list|)
expr_stmt|;
comment|/* TRIAL must be a CALL_INSN or INSN.  Skip USE and CLOBBER.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|trial
argument_list|)
operator|==
name|INSN
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|CLOBBER
operator|)
condition|)
continue|continue;
if|if
condition|(
name|GET_CODE
argument_list|(
name|next_to_match
argument_list|)
operator|==
name|GET_CODE
argument_list|(
name|trial
argument_list|)
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* We can't share an insn that sets cc0.  */
operator|&&
operator|!
name|sets_cc0_p
argument_list|(
name|pat
argument_list|)
endif|#
directive|endif
operator|&&
operator|!
name|insn_references_resource_p
argument_list|(
name|trial
argument_list|,
operator|&
name|set
argument_list|,
literal|1
argument_list|)
operator|&&
operator|!
name|insn_sets_resource_p
argument_list|(
name|trial
argument_list|,
operator|&
name|set
argument_list|,
literal|1
argument_list|)
operator|&&
operator|!
name|insn_sets_resource_p
argument_list|(
name|trial
argument_list|,
operator|&
name|needed
argument_list|,
literal|1
argument_list|)
operator|&&
operator|(
name|trial
operator|=
name|try_split
argument_list|(
name|pat
argument_list|,
name|trial
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
comment|/* Update next_trial, in case try_split succeeded.  */
operator|&&
operator|(
name|next_trial
operator|=
name|next_nonnote_insn
argument_list|(
name|trial
argument_list|)
operator|)
comment|/* Likewise THREAD.  */
operator|&&
operator|(
name|thread
operator|=
name|oldtrial
operator|==
name|thread
condition|?
name|trial
else|:
name|thread
operator|)
operator|&&
name|rtx_equal_p
argument_list|(
name|PATTERN
argument_list|(
name|next_to_match
argument_list|)
argument_list|,
name|PATTERN
argument_list|(
name|trial
argument_list|)
argument_list|)
comment|/* Have to test this condition if annul condition is different 	     from (and less restrictive than) non-annulling one.  */
operator|&&
name|eligible_for_delay
argument_list|(
name|delay_insn
argument_list|,
name|slot_number
operator|-
literal|1
argument_list|,
name|trial
argument_list|,
name|flags
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|annul_p
condition|)
block|{
name|update_block
argument_list|(
name|trial
argument_list|,
name|thread
argument_list|)
expr_stmt|;
if|if
condition|(
name|trial
operator|==
name|thread
condition|)
name|thread
operator|=
name|next_active_insn
argument_list|(
name|thread
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|trial
argument_list|)
expr_stmt|;
name|INSN_FROM_TARGET_P
argument_list|(
name|next_to_match
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|merged_insns
operator|=
name|gen_rtx_INSN_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|trial
argument_list|,
name|merged_insns
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|slot_number
operator|==
name|num_slots
condition|)
break|break;
name|next_to_match
operator|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|slot_number
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|annul_p
condition|)
name|mark_referenced_resources
argument_list|(
name|next_to_match
argument_list|,
operator|&
name|needed
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|mark_set_resources
argument_list|(
name|trial
argument_list|,
operator|&
name|set
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mark_referenced_resources
argument_list|(
name|trial
argument_list|,
operator|&
name|needed
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* See if we stopped on a filled insn.  If we did, try to see if its      delay slots match.  */
if|if
condition|(
name|slot_number
operator|!=
name|num_slots
operator|&&
name|trial
operator|&&
name|GET_CODE
argument_list|(
name|trial
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|trial
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
operator|&&
operator|!
name|INSN_ANNULLED_BRANCH_P
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|trial
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|trial
argument_list|)
decl_stmt|;
name|rtx
name|filled_insn
init|=
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* Account for resources set/needed by the filled insn.  */
name|mark_set_resources
argument_list|(
name|filled_insn
argument_list|,
operator|&
name|set
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mark_referenced_resources
argument_list|(
name|filled_insn
argument_list|,
operator|&
name|needed
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|dtrial
init|=
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|insn_references_resource_p
argument_list|(
name|dtrial
argument_list|,
operator|&
name|set
argument_list|,
literal|1
argument_list|)
operator|&&
operator|!
name|insn_sets_resource_p
argument_list|(
name|dtrial
argument_list|,
operator|&
name|set
argument_list|,
literal|1
argument_list|)
operator|&&
operator|!
name|insn_sets_resource_p
argument_list|(
name|dtrial
argument_list|,
operator|&
name|needed
argument_list|,
literal|1
argument_list|)
ifdef|#
directive|ifdef
name|HAVE_cc0
operator|&&
operator|!
name|sets_cc0_p
argument_list|(
name|PATTERN
argument_list|(
name|dtrial
argument_list|)
argument_list|)
endif|#
directive|endif
operator|&&
name|rtx_equal_p
argument_list|(
name|PATTERN
argument_list|(
name|next_to_match
argument_list|)
argument_list|,
name|PATTERN
argument_list|(
name|dtrial
argument_list|)
argument_list|)
operator|&&
name|eligible_for_delay
argument_list|(
name|delay_insn
argument_list|,
name|slot_number
operator|-
literal|1
argument_list|,
name|dtrial
argument_list|,
name|flags
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|annul_p
condition|)
block|{
name|update_block
argument_list|(
name|dtrial
argument_list|,
name|thread
argument_list|)
expr_stmt|;
name|delete_from_delay_slot
argument_list|(
name|dtrial
argument_list|)
expr_stmt|;
name|INSN_FROM_TARGET_P
argument_list|(
name|next_to_match
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|merged_insns
operator|=
name|gen_rtx_INSN_LIST
argument_list|(
name|SImode
argument_list|,
name|dtrial
argument_list|,
name|merged_insns
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|slot_number
operator|==
name|num_slots
condition|)
break|break;
name|next_to_match
operator|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|slot_number
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* If all insns in the delay slot have been matched and we were previously      annulling the branch, we need not any more.  In that case delete all the      merged insns.  Also clear the INSN_FROM_TARGET_P bit of each insn in      the delay list so that we know that it isn't only being used at the      target.  */
if|if
condition|(
name|slot_number
operator|==
name|num_slots
operator|&&
name|annul_p
condition|)
block|{
for|for
control|(
init|;
name|merged_insns
condition|;
name|merged_insns
operator|=
name|XEXP
argument_list|(
name|merged_insns
argument_list|,
literal|1
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|merged_insns
argument_list|)
operator|==
name|SImode
condition|)
block|{
name|update_block
argument_list|(
name|XEXP
argument_list|(
name|merged_insns
argument_list|,
literal|0
argument_list|)
argument_list|,
name|thread
argument_list|)
expr_stmt|;
name|delete_from_delay_slot
argument_list|(
name|XEXP
argument_list|(
name|merged_insns
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|update_block
argument_list|(
name|XEXP
argument_list|(
name|merged_insns
argument_list|,
literal|0
argument_list|)
argument_list|,
name|thread
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|XEXP
argument_list|(
name|merged_insns
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|INSN_ANNULLED_BRANCH_P
argument_list|(
name|delay_insn
argument_list|)
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
name|INSN_FROM_TARGET_P
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* See if INSN is redundant with an insn in front of TARGET.  Often this    is called when INSN is a candidate for a delay slot of TARGET.    DELAY_LIST are insns that will be placed in delay slots of TARGET in front    of INSN.  Often INSN will be redundant with an insn in a delay slot of    some previous insn.  This happens when we have a series of branches to the    same label; in that case the first insn at the target might want to go    into each of the delay slots.     If we are not careful, this routine can take up a significant fraction    of the total compilation time (4%), but only wins rarely.  Hence we    speed this routine up by making two passes.  The first pass goes back    until it hits a label and sees if it find an insn with an identical    pattern.  Only in this (relatively rare) event does it check for    data conflicts.     We do not split insns we encounter.  This could cause us not to find a    redundant insn, but the cost of splitting seems greater than the possible    gain in rare cases.  */
end_comment

begin_function
specifier|static
name|rtx
name|redundant_insn
parameter_list|(
name|insn
parameter_list|,
name|target
parameter_list|,
name|delay_list
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|rtx
name|delay_list
decl_stmt|;
block|{
name|rtx
name|target_main
init|=
name|target
decl_stmt|;
name|rtx
name|ipat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|trial
decl_stmt|,
name|pat
decl_stmt|;
name|struct
name|resources
name|needed
decl_stmt|,
name|set
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* If INSN has any REG_UNUSED notes, it can't match anything since we      are allowed to not actually assign to such a register.  */
if|if
condition|(
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_UNUSED
argument_list|,
name|NULL_RTX
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Scan backwards looking for a match.  */
for|for
control|(
name|trial
operator|=
name|PREV_INSN
argument_list|(
name|target
argument_list|)
init|;
name|trial
condition|;
name|trial
operator|=
name|PREV_INSN
argument_list|(
name|trial
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|trial
argument_list|)
operator|==
name|CODE_LABEL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|trial
argument_list|)
argument_list|)
operator|!=
literal|'i'
condition|)
continue|continue;
name|pat
operator|=
name|PATTERN
argument_list|(
name|trial
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|CLOBBER
condition|)
continue|continue;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SEQUENCE
condition|)
block|{
comment|/* Stop for a CALL and its delay slots because it is difficult to 	     track its resource needs correctly.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CALL_INSN
condition|)
return|return
literal|0
return|;
comment|/* Stop for an INSN or JUMP_INSN with delayed effects and its delay 	     slots because it is difficult to track its resource needs  	     correctly.  */
ifdef|#
directive|ifdef
name|INSN_SETS_ARE_DELAYED
if|if
condition|(
name|INSN_SETS_ARE_DELAYED
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INSN_REFERENCES_ARE_DELAYED
if|if
condition|(
name|INSN_REFERENCES_ARE_DELAYED
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* See if any of the insns in the delay slot match, updating 	     resource requirements as we go.  */
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|&&
name|rtx_equal_p
argument_list|(
name|PATTERN
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|,
name|ipat
argument_list|)
operator|&&
operator|!
name|find_reg_note
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|REG_UNUSED
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
break|break;
comment|/* If found a match, exit this loop early.  */
if|if
condition|(
name|i
operator|>
literal|0
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|trial
argument_list|)
operator|==
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|&&
name|rtx_equal_p
argument_list|(
name|pat
argument_list|,
name|ipat
argument_list|)
operator|&&
operator|!
name|find_reg_note
argument_list|(
name|trial
argument_list|,
name|REG_UNUSED
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
break|break;
block|}
comment|/* If we didn't find an insn that matches, return 0.  */
if|if
condition|(
name|trial
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* See what resources this insn sets and needs.  If they overlap, or      if this insn references CC0, it can't be redundant.  */
name|CLEAR_RESOURCE
argument_list|(
operator|&
name|needed
argument_list|)
expr_stmt|;
name|CLEAR_RESOURCE
argument_list|(
operator|&
name|set
argument_list|)
expr_stmt|;
name|mark_set_resources
argument_list|(
name|insn
argument_list|,
operator|&
name|set
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mark_referenced_resources
argument_list|(
name|insn
argument_list|,
operator|&
name|needed
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* If TARGET is a SEQUENCE, get the main insn.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|target
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
condition|)
name|target_main
operator|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|target
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|resource_conflicts_p
argument_list|(
operator|&
name|needed
argument_list|,
operator|&
name|set
argument_list|)
ifdef|#
directive|ifdef
name|HAVE_cc0
operator|||
name|reg_mentioned_p
argument_list|(
name|cc0_rtx
argument_list|,
name|ipat
argument_list|)
endif|#
directive|endif
comment|/* The insn requiring the delay may not set anything needed or set by 	 INSN.  */
operator|||
name|insn_sets_resource_p
argument_list|(
name|target_main
argument_list|,
operator|&
name|needed
argument_list|,
literal|1
argument_list|)
operator|||
name|insn_sets_resource_p
argument_list|(
name|target_main
argument_list|,
operator|&
name|set
argument_list|,
literal|1
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Insns we pass may not set either NEEDED or SET, so merge them for      simpler tests.  */
name|needed
operator|.
name|memory
operator||=
name|set
operator|.
name|memory
expr_stmt|;
name|needed
operator|.
name|unch_memory
operator||=
name|set
operator|.
name|unch_memory
expr_stmt|;
name|IOR_HARD_REG_SET
argument_list|(
name|needed
operator|.
name|regs
argument_list|,
name|set
operator|.
name|regs
argument_list|)
expr_stmt|;
comment|/* This insn isn't redundant if it conflicts with an insn that either is      or will be in a delay slot of TARGET.  */
while|while
condition|(
name|delay_list
condition|)
block|{
if|if
condition|(
name|insn_sets_resource_p
argument_list|(
name|XEXP
argument_list|(
name|delay_list
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|needed
argument_list|,
literal|1
argument_list|)
condition|)
return|return
literal|0
return|;
name|delay_list
operator|=
name|XEXP
argument_list|(
name|delay_list
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|target
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
condition|)
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|target
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|insn_sets_resource_p
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|target
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
operator|&
name|needed
argument_list|,
literal|1
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Scan backwards until we reach a label or an insn that uses something      INSN sets or sets something insn uses or sets.  */
for|for
control|(
name|trial
operator|=
name|PREV_INSN
argument_list|(
name|target
argument_list|)
init|;
name|trial
operator|&&
name|GET_CODE
argument_list|(
name|trial
argument_list|)
operator|!=
name|CODE_LABEL
condition|;
name|trial
operator|=
name|PREV_INSN
argument_list|(
name|trial
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|trial
argument_list|)
operator|!=
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|trial
argument_list|)
operator|!=
name|CALL_INSN
operator|&&
name|GET_CODE
argument_list|(
name|trial
argument_list|)
operator|!=
name|JUMP_INSN
condition|)
continue|continue;
name|pat
operator|=
name|PATTERN
argument_list|(
name|trial
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|CLOBBER
condition|)
continue|continue;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SEQUENCE
condition|)
block|{
comment|/* If this is a CALL_INSN and its delay slots, it is hard to track 	     the resource needs properly, so give up.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CALL_INSN
condition|)
return|return
literal|0
return|;
comment|/* If this is an INSN or JUMP_INSN with delayed effects, it 	     is hard to track the resource needs properly, so give up.  */
ifdef|#
directive|ifdef
name|INSN_SETS_ARE_DELAYED
if|if
condition|(
name|INSN_SETS_ARE_DELAYED
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INSN_REFERENCES_ARE_DELAYED
if|if
condition|(
name|INSN_REFERENCES_ARE_DELAYED
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* See if any of the insns in the delay slot match, updating 	     resource requirements as we go.  */
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|rtx
name|candidate
init|=
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
comment|/* If an insn will be annulled if the branch is false, it isn't 		 considered as a possible duplicate insn.  */
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|PATTERN
argument_list|(
name|candidate
argument_list|)
argument_list|,
name|ipat
argument_list|)
operator|&&
operator|!
operator|(
name|INSN_ANNULLED_BRANCH_P
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|INSN_FROM_TARGET_P
argument_list|(
name|candidate
argument_list|)
operator|)
condition|)
block|{
comment|/* Show that this insn will be used in the sequel.  */
name|INSN_FROM_TARGET_P
argument_list|(
name|candidate
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|candidate
return|;
block|}
comment|/* Unless this is an annulled insn from the target of a branch, 		 we must stop if it sets anything needed or set by INSN.  */
if|if
condition|(
operator|(
operator|!
name|INSN_ANNULLED_BRANCH_P
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
operator|!
name|INSN_FROM_TARGET_P
argument_list|(
name|candidate
argument_list|)
operator|)
operator|&&
name|insn_sets_resource_p
argument_list|(
name|candidate
argument_list|,
operator|&
name|needed
argument_list|,
literal|1
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
comment|/* If the insn requiring the delay slot conflicts with INSN, we  	     must stop.  */
if|if
condition|(
name|insn_sets_resource_p
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|needed
argument_list|,
literal|1
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
else|else
block|{
comment|/* See if TRIAL is the same as INSN.  */
name|pat
operator|=
name|PATTERN
argument_list|(
name|trial
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|pat
argument_list|,
name|ipat
argument_list|)
condition|)
return|return
name|trial
return|;
comment|/* Can't go any further if TRIAL conflicts with INSN.  */
if|if
condition|(
name|insn_sets_resource_p
argument_list|(
name|trial
argument_list|,
operator|&
name|needed
argument_list|,
literal|1
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if THREAD can only be executed in one way.  If LABEL is non-zero,    it is the target of the branch insn being scanned.  If ALLOW_FALLTHROUGH    is non-zero, we are allowed to fall into this thread; otherwise, we are    not.     If LABEL is used more than one or we pass a label other than LABEL before    finding an active insn, we do not own this thread.  */
end_comment

begin_function
specifier|static
name|int
name|own_thread_p
parameter_list|(
name|thread
parameter_list|,
name|label
parameter_list|,
name|allow_fallthrough
parameter_list|)
name|rtx
name|thread
decl_stmt|;
name|rtx
name|label
decl_stmt|;
name|int
name|allow_fallthrough
decl_stmt|;
block|{
name|rtx
name|active_insn
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
comment|/* We don't own the function end.  */
if|if
condition|(
name|thread
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Get the first active insn, or THREAD, if it is an active insn.  */
name|active_insn
operator|=
name|next_active_insn
argument_list|(
name|PREV_INSN
argument_list|(
name|thread
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|thread
init|;
name|insn
operator|!=
name|active_insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
operator|&&
operator|(
name|insn
operator|!=
name|label
operator|||
name|LABEL_NUSES
argument_list|(
name|insn
argument_list|)
operator|!=
literal|1
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|allow_fallthrough
condition|)
return|return
literal|1
return|;
comment|/* Ensure that we reach a BARRIER before any insn or label.  */
for|for
control|(
name|insn
operator|=
name|prev_nonnote_insn
argument_list|(
name|thread
argument_list|)
init|;
name|insn
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|BARRIER
condition|;
name|insn
operator|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|insn
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
operator|||
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|CLOBBER
operator|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find the number of the basic block that starts closest to INSN.  Return -1    if we couldn't find such a basic block.  */
end_comment

begin_function
specifier|static
name|int
name|find_basic_block
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
comment|/* Scan backwards to the previous BARRIER.  Then see if we can find a      label that starts a basic block.  Return the basic block number.  */
for|for
control|(
name|insn
operator|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
init|;
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|BARRIER
condition|;
name|insn
operator|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
control|)
empty_stmt|;
comment|/* The start of the function is basic block zero.  */
if|if
condition|(
name|insn
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* See if any of the upcoming CODE_LABELs start a basic block.  If we reach      anything other than a CODE_LABEL or note, we can't find this code.  */
for|for
control|(
name|insn
operator|=
name|next_nonnote_insn
argument_list|(
name|insn
argument_list|)
init|;
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|;
name|insn
operator|=
name|next_nonnote_insn
argument_list|(
name|insn
argument_list|)
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|insn
operator|==
name|basic_block_head
index|[
name|i
index|]
condition|)
return|return
name|i
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Called when INSN is being moved from a location near the target of a jump.    We leave a marker of the form (use (INSN)) immediately in front    of WHERE for mark_target_live_regs.  These markers will be deleted when    reorg finishes.     We used to try to update the live status of registers if WHERE is at    the start of a basic block, but that can't work since we may remove a    BARRIER in relax_delay_slots.  */
end_comment

begin_function
specifier|static
name|void
name|update_block
parameter_list|(
name|insn
parameter_list|,
name|where
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|where
decl_stmt|;
block|{
name|int
name|b
decl_stmt|;
comment|/* Ignore if this was in a delay slot and it came from the target of       a branch.  */
if|if
condition|(
name|INSN_FROM_TARGET_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return;
name|emit_insn_before
argument_list|(
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|insn
argument_list|)
argument_list|,
name|where
argument_list|)
expr_stmt|;
comment|/* INSN might be making a value live in a block where it didn't use to      be.  So recompute liveness information for this block.  */
name|b
operator|=
name|find_basic_block
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|!=
operator|-
literal|1
condition|)
name|bb_ticks
index|[
name|b
index|]
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Similar to REDIRECT_JUMP except that we update the BB_TICKS entry for    the basic block containing the jump.  */
end_comment

begin_function
specifier|static
name|int
name|reorg_redirect_jump
parameter_list|(
name|jump
parameter_list|,
name|nlabel
parameter_list|)
name|rtx
name|jump
decl_stmt|;
name|rtx
name|nlabel
decl_stmt|;
block|{
name|int
name|b
init|=
name|find_basic_block
argument_list|(
name|jump
argument_list|)
decl_stmt|;
if|if
condition|(
name|b
operator|!=
operator|-
literal|1
condition|)
name|bb_ticks
index|[
name|b
index|]
operator|++
expr_stmt|;
return|return
name|redirect_jump
argument_list|(
name|jump
argument_list|,
name|nlabel
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Called when INSN is being moved forward into a delay slot of DELAYED_INSN.    We check every instruction between INSN and DELAYED_INSN for REG_DEAD notes    that reference values used in INSN.  If we find one, then we move the    REG_DEAD note to INSN.     This is needed to handle the case where an later insn (after INSN) has a    REG_DEAD note for a register used by INSN, and this later insn subsequently    gets moved before a CODE_LABEL because it is a redundant insn.  In this    case, mark_target_live_regs may be confused into thinking the register    is dead because it sees a REG_DEAD note immediately before a CODE_LABEL.  */
end_comment

begin_function
specifier|static
name|void
name|update_reg_dead_notes
parameter_list|(
name|insn
parameter_list|,
name|delayed_insn
parameter_list|)
name|rtx
name|insn
decl_stmt|,
name|delayed_insn
decl_stmt|;
block|{
name|rtx
name|p
decl_stmt|,
name|link
decl_stmt|,
name|next
decl_stmt|;
for|for
control|(
name|p
operator|=
name|next_nonnote_insn
argument_list|(
name|insn
argument_list|)
init|;
name|p
operator|!=
name|delayed_insn
condition|;
name|p
operator|=
name|next_nonnote_insn
argument_list|(
name|p
argument_list|)
control|)
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|p
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|next
control|)
block|{
name|next
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|!=
name|REG_DEAD
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
continue|continue;
if|if
condition|(
name|reg_referenced_p
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Move the REG_DEAD note from P to INSN.  */
name|remove_note
argument_list|(
name|p
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|link
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Called when an insn redundant with start_insn is deleted.  If there    is a REG_DEAD note for the target of start_insn between start_insn    and stop_insn, then the REG_DEAD note needs to be deleted since the    value no longer dies there.     If the REG_DEAD note isn't deleted, then mark_target_live_regs may be    confused into thinking the register is dead.  */
end_comment

begin_function
specifier|static
name|void
name|fix_reg_dead_note
parameter_list|(
name|start_insn
parameter_list|,
name|stop_insn
parameter_list|)
name|rtx
name|start_insn
decl_stmt|,
name|stop_insn
decl_stmt|;
block|{
name|rtx
name|p
decl_stmt|,
name|link
decl_stmt|,
name|next
decl_stmt|;
for|for
control|(
name|p
operator|=
name|next_nonnote_insn
argument_list|(
name|start_insn
argument_list|)
init|;
name|p
operator|!=
name|stop_insn
condition|;
name|p
operator|=
name|next_nonnote_insn
argument_list|(
name|p
argument_list|)
control|)
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|p
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|next
control|)
block|{
name|next
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|!=
name|REG_DEAD
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
continue|continue;
if|if
condition|(
name|reg_set_p
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|,
name|PATTERN
argument_list|(
name|start_insn
argument_list|)
argument_list|)
condition|)
block|{
name|remove_note
argument_list|(
name|p
argument_list|,
name|link
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Delete any REG_UNUSED notes that exist on INSN but not on REDUNDANT_INSN.     This handles the case of udivmodXi4 instructions which optimize their    output depending on whether any REG_UNUSED notes are present.    we must make sure that INSN calculates as many results as REDUNDANT_INSN    does.  */
end_comment

begin_function
specifier|static
name|void
name|update_reg_unused_notes
parameter_list|(
name|insn
parameter_list|,
name|redundant_insn
parameter_list|)
name|rtx
name|insn
decl_stmt|,
name|redundant_insn
decl_stmt|;
block|{
name|rtx
name|link
decl_stmt|,
name|next
decl_stmt|;
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|next
control|)
block|{
name|next
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|!=
name|REG_UNUSED
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
continue|continue;
if|if
condition|(
operator|!
name|find_regno_note
argument_list|(
name|redundant_insn
argument_list|,
name|REG_UNUSED
argument_list|,
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
name|remove_note
argument_list|(
name|insn
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Marks registers possibly live at the current place being scanned by    mark_target_live_regs.  Used only by next two function.    */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|current_live_regs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Marks registers for which we have seen a REG_DEAD note but no assignment.    Also only used by the next two functions.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|pending_dead_regs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Utility function called from mark_target_live_regs via note_stores.    It deadens any CLOBBERed registers and livens any SET registers.  */
end_comment

begin_function
specifier|static
name|void
name|update_live_status
parameter_list|(
name|dest
parameter_list|,
name|x
parameter_list|)
name|rtx
name|dest
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
name|int
name|first_regno
decl_stmt|,
name|last_regno
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|!=
name|REG
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|!=
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|!=
name|REG
operator|)
condition|)
return|return;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
condition|)
name|first_regno
operator|=
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|+
name|SUBREG_WORD
argument_list|(
name|dest
argument_list|)
expr_stmt|;
else|else
name|first_regno
operator|=
name|REGNO
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|last_regno
operator|=
name|first_regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|first_regno
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CLOBBER
condition|)
for|for
control|(
name|i
operator|=
name|first_regno
init|;
name|i
operator|<
name|last_regno
condition|;
name|i
operator|++
control|)
name|CLEAR_HARD_REG_BIT
argument_list|(
name|current_live_regs
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
name|first_regno
init|;
name|i
operator|<
name|last_regno
condition|;
name|i
operator|++
control|)
block|{
name|SET_HARD_REG_BIT
argument_list|(
name|current_live_regs
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_BIT
argument_list|(
name|pending_dead_regs
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Similar to next_insn, but ignores insns in the delay slots of    an annulled branch.  */
end_comment

begin_function
specifier|static
name|rtx
name|next_insn_no_annul
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
if|if
condition|(
name|insn
condition|)
block|{
comment|/* If INSN is an annulled branch, skip any insns from the target 	 of the branch.  */
if|if
condition|(
name|INSN_ANNULLED_BRANCH_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|NEXT_INSN
argument_list|(
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|insn
condition|)
while|while
condition|(
name|INSN_FROM_TARGET_P
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
condition|)
name|insn
operator|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|insn
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A subroutine of mark_target_live_regs.  Search forward from TARGET    looking for registers that are set before they are used.  These are dead.     Stop after passing a few conditional jumps, and/or a small    number of unconditional branches.  */
end_comment

begin_function
specifier|static
name|rtx
name|find_dead_or_set_registers
parameter_list|(
name|target
parameter_list|,
name|res
parameter_list|,
name|jump_target
parameter_list|,
name|jump_count
parameter_list|,
name|set
parameter_list|,
name|needed
parameter_list|)
name|rtx
name|target
decl_stmt|;
name|struct
name|resources
modifier|*
name|res
decl_stmt|;
name|rtx
modifier|*
name|jump_target
decl_stmt|;
name|int
name|jump_count
decl_stmt|;
name|struct
name|resources
name|set
decl_stmt|,
name|needed
decl_stmt|;
block|{
name|HARD_REG_SET
name|scratch
decl_stmt|;
name|rtx
name|insn
decl_stmt|,
name|next
decl_stmt|;
name|rtx
name|jump_insn
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|target
init|;
name|insn
condition|;
name|insn
operator|=
name|next
control|)
block|{
name|rtx
name|this_jump_insn
init|=
name|insn
decl_stmt|;
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|CODE_LABEL
case|:
comment|/* After a label, any pending dead registers that weren't yet 	     used can be made dead.  */
name|AND_COMPL_HARD_REG_SET
argument_list|(
name|pending_dead_regs
argument_list|,
name|needed
operator|.
name|regs
argument_list|)
expr_stmt|;
name|AND_COMPL_HARD_REG_SET
argument_list|(
name|res
operator|->
name|regs
argument_list|,
name|pending_dead_regs
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|pending_dead_regs
argument_list|)
expr_stmt|;
if|if
condition|(
name|CODE_LABEL_NUMBER
argument_list|(
name|insn
argument_list|)
operator|<
name|max_label_num_after_reload
condition|)
block|{
comment|/* All spill registers are dead at a label, so kill all of the 		 ones that aren't needed also.  */
name|COPY_HARD_REG_SET
argument_list|(
name|scratch
argument_list|,
name|used_spill_regs
argument_list|)
expr_stmt|;
name|AND_COMPL_HARD_REG_SET
argument_list|(
name|scratch
argument_list|,
name|needed
operator|.
name|regs
argument_list|)
expr_stmt|;
name|AND_COMPL_HARD_REG_SET
argument_list|(
name|res
operator|->
name|regs
argument_list|,
name|scratch
argument_list|)
expr_stmt|;
block|}
continue|continue;
case|case
name|BARRIER
case|:
case|case
name|NOTE
case|:
continue|continue;
case|case
name|INSN
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|USE
condition|)
block|{
comment|/* If INSN is a USE made by update_block, we care about the 		 underlying insn.  Any registers set by the underlying insn 		 are live since the insn is being done somewhere else.  */
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
name|mark_set_resources
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|res
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* All other USE insns are to be ignored.  */
continue|continue;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
condition|)
block|{
comment|/* An unconditional jump can be used to fill the delay slot 		 of a call, so search for a JUMP_INSN in any position.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|this_jump_insn
operator|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|this_jump_insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
break|break;
block|}
block|}
default|default:
break|break;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|this_jump_insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
if|if
condition|(
name|jump_count
operator|++
operator|<
literal|10
condition|)
block|{
if|if
condition|(
name|simplejump_p
argument_list|(
name|this_jump_insn
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|this_jump_insn
argument_list|)
argument_list|)
operator|==
name|RETURN
condition|)
block|{
name|next
operator|=
name|JUMP_LABEL
argument_list|(
name|this_jump_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|jump_insn
operator|==
literal|0
condition|)
block|{
name|jump_insn
operator|=
name|insn
expr_stmt|;
if|if
condition|(
name|jump_target
condition|)
operator|*
name|jump_target
operator|=
name|JUMP_LABEL
argument_list|(
name|this_jump_insn
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|condjump_p
argument_list|(
name|this_jump_insn
argument_list|)
operator|||
name|condjump_in_parallel_p
argument_list|(
name|this_jump_insn
argument_list|)
condition|)
block|{
name|struct
name|resources
name|target_set
decl_stmt|,
name|target_res
decl_stmt|;
name|struct
name|resources
name|fallthrough_res
decl_stmt|;
comment|/* We can handle conditional branches here by following 		     both paths, and then IOR the results of the two paths 		     together, which will give us registers that are dead 		     on both paths.  Since this is expensive, we give it 		     a much higher cost than unconditional branches.  The 		     cost was chosen so that we will follow at most 1 		     conditional branch.  */
name|jump_count
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|jump_count
operator|>=
literal|10
condition|)
break|break;
name|mark_referenced_resources
argument_list|(
name|insn
argument_list|,
operator|&
name|needed
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* For an annulled branch, mark_set_resources ignores slots 		     filled by instructions from the target.  This is correct 		     if the branch is not taken.  Since we are following both 		     paths from the branch, we must also compute correct info 		     if the branch is taken.  We do this by inverting all of 		     the INSN_FROM_TARGET_P bits, calling mark_set_resources, 		     and then inverting the INSN_FROM_TARGET_P bits again.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
operator|&&
name|INSN_ANNULLED_BRANCH_P
argument_list|(
name|this_jump_insn
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
name|INSN_FROM_TARGET_P
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|=
operator|!
name|INSN_FROM_TARGET_P
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|target_set
operator|=
name|set
expr_stmt|;
name|mark_set_resources
argument_list|(
name|insn
argument_list|,
operator|&
name|target_set
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
name|INSN_FROM_TARGET_P
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|=
operator|!
name|INSN_FROM_TARGET_P
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|mark_set_resources
argument_list|(
name|insn
argument_list|,
operator|&
name|set
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mark_set_resources
argument_list|(
name|insn
argument_list|,
operator|&
name|set
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|target_set
operator|=
name|set
expr_stmt|;
block|}
name|target_res
operator|=
operator|*
name|res
expr_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|scratch
argument_list|,
name|target_set
operator|.
name|regs
argument_list|)
expr_stmt|;
name|AND_COMPL_HARD_REG_SET
argument_list|(
name|scratch
argument_list|,
name|needed
operator|.
name|regs
argument_list|)
expr_stmt|;
name|AND_COMPL_HARD_REG_SET
argument_list|(
name|target_res
operator|.
name|regs
argument_list|,
name|scratch
argument_list|)
expr_stmt|;
name|fallthrough_res
operator|=
operator|*
name|res
expr_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|scratch
argument_list|,
name|set
operator|.
name|regs
argument_list|)
expr_stmt|;
name|AND_COMPL_HARD_REG_SET
argument_list|(
name|scratch
argument_list|,
name|needed
operator|.
name|regs
argument_list|)
expr_stmt|;
name|AND_COMPL_HARD_REG_SET
argument_list|(
name|fallthrough_res
operator|.
name|regs
argument_list|,
name|scratch
argument_list|)
expr_stmt|;
name|find_dead_or_set_registers
argument_list|(
name|JUMP_LABEL
argument_list|(
name|this_jump_insn
argument_list|)
argument_list|,
operator|&
name|target_res
argument_list|,
literal|0
argument_list|,
name|jump_count
argument_list|,
name|target_set
argument_list|,
name|needed
argument_list|)
expr_stmt|;
name|find_dead_or_set_registers
argument_list|(
name|next
argument_list|,
operator|&
name|fallthrough_res
argument_list|,
literal|0
argument_list|,
name|jump_count
argument_list|,
name|set
argument_list|,
name|needed
argument_list|)
expr_stmt|;
name|IOR_HARD_REG_SET
argument_list|(
name|fallthrough_res
operator|.
name|regs
argument_list|,
name|target_res
operator|.
name|regs
argument_list|)
expr_stmt|;
name|AND_HARD_REG_SET
argument_list|(
name|res
operator|->
name|regs
argument_list|,
name|fallthrough_res
operator|.
name|regs
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
break|break;
block|}
else|else
block|{
comment|/* Don't try this optimization if we expired our jump count 		 above, since that would mean there may be an infinite loop 		 in the function being compiled.  */
name|jump_insn
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
name|mark_referenced_resources
argument_list|(
name|insn
argument_list|,
operator|&
name|needed
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mark_set_resources
argument_list|(
name|insn
argument_list|,
operator|&
name|set
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|scratch
argument_list|,
name|set
operator|.
name|regs
argument_list|)
expr_stmt|;
name|AND_COMPL_HARD_REG_SET
argument_list|(
name|scratch
argument_list|,
name|needed
operator|.
name|regs
argument_list|)
expr_stmt|;
name|AND_COMPL_HARD_REG_SET
argument_list|(
name|res
operator|->
name|regs
argument_list|,
name|scratch
argument_list|)
expr_stmt|;
block|}
return|return
name|jump_insn
return|;
block|}
end_function

begin_comment
comment|/* Set the resources that are live at TARGET.     If TARGET is zero, we refer to the end of the current function and can    return our precomputed value.     Otherwise, we try to find out what is live by consulting the basic block    information.  This is tricky, because we must consider the actions of    reload and jump optimization, which occur after the basic block information    has been computed.     Accordingly, we proceed as follows::     We find the previous BARRIER and look at all immediately following labels    (with no intervening active insns) to see if any of them start a basic    block.  If we hit the start of the function first, we use block 0.     Once we have found a basic block and a corresponding first insns, we can    accurately compute the live status from basic_block_live_regs and    reg_renumber.  (By starting at a label following a BARRIER, we are immune    to actions taken by reload and jump.)  Then we scan all insns between    that point and our target.  For each CLOBBER (or for call-clobbered regs    when we pass a CALL_INSN), mark the appropriate registers are dead.  For    a SET, mark them as live.     We have to be careful when using REG_DEAD notes because they are not    updated by such things as find_equiv_reg.  So keep track of registers    marked as dead that haven't been assigned to, and mark them dead at the    next CODE_LABEL since reload and jump won't propagate values across labels.     If we cannot find the start of a basic block (should be a very rare    case, if it can happen at all), mark everything as potentially live.     Next, scan forward from TARGET looking for things set or clobbered    before they are used.  These are not live.     Because we can be called many times on the same target, save our results    in a hash table indexed by INSN_UID.  */
end_comment

begin_function
specifier|static
name|void
name|mark_target_live_regs
parameter_list|(
name|target
parameter_list|,
name|res
parameter_list|)
name|rtx
name|target
decl_stmt|;
name|struct
name|resources
modifier|*
name|res
decl_stmt|;
block|{
name|int
name|b
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|target_info
modifier|*
name|tinfo
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|rtx
name|jump_insn
init|=
literal|0
decl_stmt|;
name|rtx
name|jump_target
decl_stmt|;
name|HARD_REG_SET
name|scratch
decl_stmt|;
name|struct
name|resources
name|set
decl_stmt|,
name|needed
decl_stmt|;
comment|/* Handle end of function.  */
if|if
condition|(
name|target
operator|==
literal|0
condition|)
block|{
operator|*
name|res
operator|=
name|end_of_function_needs
expr_stmt|;
return|return;
block|}
comment|/* We have to assume memory is needed, but the CC isn't.  */
name|res
operator|->
name|memory
operator|=
literal|1
expr_stmt|;
name|res
operator|->
name|volatil
operator|=
name|res
operator|->
name|unch_memory
operator|=
literal|0
expr_stmt|;
name|res
operator|->
name|cc
operator|=
literal|0
expr_stmt|;
comment|/* See if we have computed this value already.  */
for|for
control|(
name|tinfo
operator|=
name|target_hash_table
index|[
name|INSN_UID
argument_list|(
name|target
argument_list|)
operator|%
name|TARGET_HASH_PRIME
index|]
init|;
name|tinfo
condition|;
name|tinfo
operator|=
name|tinfo
operator|->
name|next
control|)
if|if
condition|(
name|tinfo
operator|->
name|uid
operator|==
name|INSN_UID
argument_list|(
name|target
argument_list|)
condition|)
break|break;
comment|/* Start by getting the basic block number.  If we have saved information,      we can get it from there unless the insn at the start of the basic block      has been deleted.  */
if|if
condition|(
name|tinfo
operator|&&
name|tinfo
operator|->
name|block
operator|!=
operator|-
literal|1
operator|&&
operator|!
name|INSN_DELETED_P
argument_list|(
name|basic_block_head
index|[
name|tinfo
operator|->
name|block
index|]
argument_list|)
condition|)
name|b
operator|=
name|tinfo
operator|->
name|block
expr_stmt|;
if|if
condition|(
name|b
operator|==
operator|-
literal|1
condition|)
name|b
operator|=
name|find_basic_block
argument_list|(
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|tinfo
condition|)
block|{
comment|/* If the information is up-to-date, use it.  Otherwise, we will 	 update it below.  */
if|if
condition|(
name|b
operator|==
name|tinfo
operator|->
name|block
operator|&&
name|b
operator|!=
operator|-
literal|1
operator|&&
name|tinfo
operator|->
name|bb_tick
operator|==
name|bb_ticks
index|[
name|b
index|]
condition|)
block|{
name|COPY_HARD_REG_SET
argument_list|(
name|res
operator|->
name|regs
argument_list|,
name|tinfo
operator|->
name|live_regs
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
comment|/* Allocate a place to put our results and chain it into the  	 hash table.  */
name|tinfo
operator|=
operator|(
expr|struct
name|target_info
operator|*
operator|)
name|oballoc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|target_info
argument_list|)
argument_list|)
expr_stmt|;
name|tinfo
operator|->
name|uid
operator|=
name|INSN_UID
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|tinfo
operator|->
name|block
operator|=
name|b
expr_stmt|;
name|tinfo
operator|->
name|next
operator|=
name|target_hash_table
index|[
name|INSN_UID
argument_list|(
name|target
argument_list|)
operator|%
name|TARGET_HASH_PRIME
index|]
expr_stmt|;
name|target_hash_table
index|[
name|INSN_UID
argument_list|(
name|target
argument_list|)
operator|%
name|TARGET_HASH_PRIME
index|]
operator|=
name|tinfo
expr_stmt|;
block|}
name|CLEAR_HARD_REG_SET
argument_list|(
name|pending_dead_regs
argument_list|)
expr_stmt|;
comment|/* If we found a basic block, get the live registers from it and update      them with anything set or killed between its start and the insn before      TARGET.  Otherwise, we must assume everything is live.  */
if|if
condition|(
name|b
operator|!=
operator|-
literal|1
condition|)
block|{
name|regset
name|regs_live
init|=
name|basic_block_live_at_start
index|[
name|b
index|]
decl_stmt|;
name|int
name|j
decl_stmt|;
name|int
name|regno
decl_stmt|;
name|rtx
name|start_insn
decl_stmt|,
name|stop_insn
decl_stmt|;
comment|/* Compute hard regs live at start of block -- this is the real hard regs 	 marked live, plus live pseudo regs that have been renumbered to 	 hard regs.  */
name|REG_SET_TO_HARD_REG_SET
argument_list|(
name|current_live_regs
argument_list|,
name|regs_live
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_REG_SET
argument_list|(
argument|regs_live
argument_list|,
argument|FIRST_PSEUDO_REGISTER
argument_list|,
argument|i
argument_list|,
argument|{ 	   if ((regno = reg_renumber[i])>=
literal|0
argument|) 	     for (j = regno; 		  j< regno + HARD_REGNO_NREGS (regno, 						PSEUDO_REGNO_MODE (i)); 		  j++) 	       SET_HARD_REG_BIT (current_live_regs, j); 	 }
argument_list|)
empty_stmt|;
comment|/* Get starting and ending insn, handling the case where each might 	 be a SEQUENCE.  */
name|start_insn
operator|=
operator|(
name|b
operator|==
literal|0
condition|?
name|get_insns
argument_list|()
else|:
name|basic_block_head
index|[
name|b
index|]
operator|)
expr_stmt|;
name|stop_insn
operator|=
name|target
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|start_insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|start_insn
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
condition|)
name|start_insn
operator|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|start_insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|stop_insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|stop_insn
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
condition|)
name|stop_insn
operator|=
name|next_insn
argument_list|(
name|PREV_INSN
argument_list|(
name|stop_insn
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|start_insn
init|;
name|insn
operator|!=
name|stop_insn
condition|;
name|insn
operator|=
name|next_insn_no_annul
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|rtx
name|link
decl_stmt|;
name|rtx
name|real_insn
init|=
name|insn
decl_stmt|;
comment|/* If this insn is from the target of a branch, it isn't going to 	     be used in the sequel.  If it is used in both cases, this 	     test will not be true.  */
if|if
condition|(
name|INSN_FROM_TARGET_P
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
comment|/* If this insn is a USE made by update_block, we care about the 	     underlying insn.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|USE
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
name|real_insn
operator|=
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|real_insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
comment|/* CALL clobbers all call-used regs that aren't fixed except 		 sp, ap, and fp.  Do this before setting the result of the 		 call live.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|call_used_regs
index|[
name|i
index|]
operator|&&
name|i
operator|!=
name|STACK_POINTER_REGNUM
operator|&&
name|i
operator|!=
name|FRAME_POINTER_REGNUM
operator|&&
name|i
operator|!=
name|ARG_POINTER_REGNUM
if|#
directive|if
name|HARD_FRAME_POINTER_REGNUM
operator|!=
name|FRAME_POINTER_REGNUM
operator|&&
name|i
operator|!=
name|HARD_FRAME_POINTER_REGNUM
endif|#
directive|endif
if|#
directive|if
name|ARG_POINTER_REGNUM
operator|!=
name|FRAME_POINTER_REGNUM
operator|&&
operator|!
operator|(
name|i
operator|==
name|ARG_POINTER_REGNUM
operator|&&
name|fixed_regs
index|[
name|i
index|]
operator|)
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PIC_OFFSET_TABLE_REGNUM
operator|&&
operator|!
operator|(
name|i
operator|==
name|PIC_OFFSET_TABLE_REGNUM
operator|&&
name|flag_pic
operator|)
endif|#
directive|endif
condition|)
name|CLEAR_HARD_REG_BIT
argument_list|(
name|current_live_regs
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* A CALL_INSN sets any global register live, since it may 		 have been modified by the call.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|global_regs
index|[
name|i
index|]
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|current_live_regs
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* Mark anything killed in an insn to be deadened at the next 	     label.  Ignore USE insns; the only REG_DEAD notes will be for 	     parameters.  But they might be early.  A CALL_INSN will usually 	     clobber registers used for parameters.  It isn't worth bothering 	     with the unlikely case when it won't.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|real_insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|real_insn
argument_list|)
argument_list|)
operator|!=
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|real_insn
argument_list|)
argument_list|)
operator|!=
name|CLOBBER
operator|)
operator|||
name|GET_CODE
argument_list|(
name|real_insn
argument_list|)
operator|==
name|JUMP_INSN
operator|||
name|GET_CODE
argument_list|(
name|real_insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|real_insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_DEAD
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|int
name|first_regno
init|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|last_regno
init|=
operator|(
name|first_regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|first_regno
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
decl_stmt|;
for|for
control|(
name|i
operator|=
name|first_regno
init|;
name|i
operator|<
name|last_regno
condition|;
name|i
operator|++
control|)
name|SET_HARD_REG_BIT
argument_list|(
name|pending_dead_regs
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|real_insn
argument_list|)
argument_list|,
name|update_live_status
argument_list|)
expr_stmt|;
comment|/* If any registers were unused after this insn, kill them. 		 These notes will always be accurate.  */
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|real_insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_UNUSED
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|int
name|first_regno
init|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|last_regno
init|=
operator|(
name|first_regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|first_regno
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
decl_stmt|;
for|for
control|(
name|i
operator|=
name|first_regno
init|;
name|i
operator|<
name|last_regno
condition|;
name|i
operator|++
control|)
name|CLEAR_HARD_REG_BIT
argument_list|(
name|current_live_regs
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|real_insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
block|{
comment|/* A label clobbers the pending dead registers since neither 		 reload nor jump will propagate a value across a label.  */
name|AND_COMPL_HARD_REG_SET
argument_list|(
name|current_live_regs
argument_list|,
name|pending_dead_regs
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|pending_dead_regs
argument_list|)
expr_stmt|;
block|}
comment|/* The beginning of the epilogue corresponds to the end of the 	     RTL chain when there are no epilogue insns.  Certain resources 	     are implicitly required at that point.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|real_insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|real_insn
argument_list|)
operator|==
name|NOTE_INSN_EPILOGUE_BEG
condition|)
name|IOR_HARD_REG_SET
argument_list|(
name|current_live_regs
argument_list|,
name|start_of_epilogue_needs
operator|.
name|regs
argument_list|)
expr_stmt|;
block|}
name|COPY_HARD_REG_SET
argument_list|(
name|res
operator|->
name|regs
argument_list|,
name|current_live_regs
argument_list|)
expr_stmt|;
name|tinfo
operator|->
name|block
operator|=
name|b
expr_stmt|;
name|tinfo
operator|->
name|bb_tick
operator|=
name|bb_ticks
index|[
name|b
index|]
expr_stmt|;
block|}
else|else
comment|/* We didn't find the start of a basic block.  Assume everything        in use.  This should happen only extremely rarely.  */
name|SET_HARD_REG_SET
argument_list|(
name|res
operator|->
name|regs
argument_list|)
expr_stmt|;
name|CLEAR_RESOURCE
argument_list|(
operator|&
name|set
argument_list|)
expr_stmt|;
name|CLEAR_RESOURCE
argument_list|(
operator|&
name|needed
argument_list|)
expr_stmt|;
name|jump_insn
operator|=
name|find_dead_or_set_registers
argument_list|(
name|target
argument_list|,
name|res
argument_list|,
operator|&
name|jump_target
argument_list|,
literal|0
argument_list|,
name|set
argument_list|,
name|needed
argument_list|)
expr_stmt|;
comment|/* If we hit an unconditional branch, we have another way of finding out      what is live: we can see what is live at the branch target and include      anything used but not set before the branch.  The only things that are      live are those that are live using the above test and the test below.  */
if|if
condition|(
name|jump_insn
condition|)
block|{
name|struct
name|resources
name|new_resources
decl_stmt|;
name|rtx
name|stop_insn
init|=
name|next_active_insn
argument_list|(
name|jump_insn
argument_list|)
decl_stmt|;
name|mark_target_live_regs
argument_list|(
name|next_active_insn
argument_list|(
name|jump_target
argument_list|)
argument_list|,
operator|&
name|new_resources
argument_list|)
expr_stmt|;
name|CLEAR_RESOURCE
argument_list|(
operator|&
name|set
argument_list|)
expr_stmt|;
name|CLEAR_RESOURCE
argument_list|(
operator|&
name|needed
argument_list|)
expr_stmt|;
comment|/* Include JUMP_INSN in the needed registers.  */
for|for
control|(
name|insn
operator|=
name|target
init|;
name|insn
operator|!=
name|stop_insn
condition|;
name|insn
operator|=
name|next_active_insn
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|mark_referenced_resources
argument_list|(
name|insn
argument_list|,
operator|&
name|needed
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|scratch
argument_list|,
name|needed
operator|.
name|regs
argument_list|)
expr_stmt|;
name|AND_COMPL_HARD_REG_SET
argument_list|(
name|scratch
argument_list|,
name|set
operator|.
name|regs
argument_list|)
expr_stmt|;
name|IOR_HARD_REG_SET
argument_list|(
name|new_resources
operator|.
name|regs
argument_list|,
name|scratch
argument_list|)
expr_stmt|;
name|mark_set_resources
argument_list|(
name|insn
argument_list|,
operator|&
name|set
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|AND_HARD_REG_SET
argument_list|(
name|res
operator|->
name|regs
argument_list|,
name|new_resources
operator|.
name|regs
argument_list|)
expr_stmt|;
block|}
name|COPY_HARD_REG_SET
argument_list|(
name|tinfo
operator|->
name|live_regs
argument_list|,
name|res
operator|->
name|regs
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Scan a function looking for insns that need a delay slot and find insns to    put into the delay slot.     NON_JUMPS_P is non-zero if we are to only try to fill non-jump insns (such    as calls).  We do these first since we don't want jump insns (that are    easier to fill) to get the only insns that could be used for non-jump insns.    When it is zero, only try to fill JUMP_INSNs.     When slots are filled in this manner, the insns (including the    delay_insn) are put together in a SEQUENCE rtx.  In this fashion,    it is possible to tell whether a delay slot has really been filled    or not.  `final' knows how to deal with this, by communicating    through FINAL_SEQUENCE.  */
end_comment

begin_function
specifier|static
name|void
name|fill_simple_delay_slots
parameter_list|(
name|non_jumps_p
parameter_list|)
name|int
name|non_jumps_p
decl_stmt|;
block|{
specifier|register
name|rtx
name|insn
decl_stmt|,
name|pat
decl_stmt|,
name|trial
decl_stmt|,
name|next_trial
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|num_unfilled_slots
init|=
name|unfilled_slots_next
operator|-
name|unfilled_slots_base
decl_stmt|;
name|struct
name|resources
name|needed
decl_stmt|,
name|set
decl_stmt|;
name|int
name|slots_to_fill
decl_stmt|,
name|slots_filled
decl_stmt|;
name|rtx
name|delay_list
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_unfilled_slots
condition|;
name|i
operator|++
control|)
block|{
name|int
name|flags
decl_stmt|;
comment|/* Get the next insn to fill.  If it has already had any slots assigned, 	 we can't do anything with it.  Maybe we'll improve this later.  */
name|insn
operator|=
name|unfilled_slots_base
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|insn
operator|==
literal|0
operator|||
name|INSN_DELETED_P
argument_list|(
name|insn
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|non_jumps_p
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|JUMP_INSN
operator|&&
operator|!
name|non_jumps_p
operator|)
condition|)
continue|continue;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
name|flags
operator|=
name|get_jump_flags
argument_list|(
name|insn
argument_list|,
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|flags
operator|=
name|get_jump_flags
argument_list|(
name|insn
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|slots_to_fill
operator|=
name|num_delay_slots
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Some machine description have defined instructions to have 	 delay slots only in certain circumstances which may depend on 	 nearby insns (which change due to reorg's actions).  	 For example, the PA port normally has delay slots for unconditional 	 jumps.  	 However, the PA port claims such jumps do not have a delay slot 	 if they are immediate successors of certain CALL_INSNs.  This 	 allows the port to favor filling the delay slot of the call with 	 the unconditional jump.  */
if|if
condition|(
name|slots_to_fill
operator|==
literal|0
condition|)
continue|continue;
comment|/* This insn needs, or can use, some delay slots.  SLOTS_TO_FILL 	 says how many.  After initialization, first try optimizing  	 call _foo		call _foo 	 nop			add %o7,.-L1,%o7 	 b,a L1 	 nop  	 If this case applies, the delay slot of the call is filled with 	 the unconditional jump.  This is done first to avoid having the 	 delay slot of the call filled in the backward scan.  Also, since 	 the unconditional jump is likely to also have a delay slot, that 	 insn must exist when it is subsequently scanned.  	 This is tried on each insn with delay slots as some machines 	 have insns which perform calls, but are not represented as  	 CALL_INSNs.  */
name|slots_filled
operator|=
literal|0
expr_stmt|;
name|delay_list
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|trial
operator|=
name|next_active_insn
argument_list|(
name|insn
argument_list|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|trial
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|simplejump_p
argument_list|(
name|trial
argument_list|)
operator|&&
name|eligible_for_delay
argument_list|(
name|insn
argument_list|,
name|slots_filled
argument_list|,
name|trial
argument_list|,
name|flags
argument_list|)
operator|&&
name|no_labels_between_p
argument_list|(
name|insn
argument_list|,
name|trial
argument_list|)
condition|)
block|{
name|rtx
modifier|*
name|tmp
decl_stmt|;
name|slots_filled
operator|++
expr_stmt|;
name|delay_list
operator|=
name|add_to_delay_list
argument_list|(
name|trial
argument_list|,
name|delay_list
argument_list|)
expr_stmt|;
comment|/* TRIAL may have had its delay slot filled, then unfilled.  When 	     the delay slot is unfilled, TRIAL is placed back on the unfilled 	     slots obstack.  Unfortunately, it is placed on the end of the 	     obstack, not in its original location.  Therefore, we must search 	     from entry i + 1 to the end of the unfilled slots obstack to 	     try and find TRIAL.  */
name|tmp
operator|=
operator|&
name|unfilled_slots_base
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|tmp
operator|!=
name|trial
operator|&&
name|tmp
operator|!=
name|unfilled_slots_next
condition|)
name|tmp
operator|++
expr_stmt|;
comment|/* Remove the unconditional jump from consideration for delay slot 	     filling and unthread it.   */
if|if
condition|(
operator|*
name|tmp
operator|==
name|trial
condition|)
operator|*
name|tmp
operator|=
literal|0
expr_stmt|;
block|{
name|rtx
name|next
init|=
name|NEXT_INSN
argument_list|(
name|trial
argument_list|)
decl_stmt|;
name|rtx
name|prev
init|=
name|PREV_INSN
argument_list|(
name|trial
argument_list|)
decl_stmt|;
if|if
condition|(
name|prev
condition|)
name|NEXT_INSN
argument_list|(
name|prev
argument_list|)
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|next
condition|)
name|PREV_INSN
argument_list|(
name|next
argument_list|)
operator|=
name|prev
expr_stmt|;
block|}
block|}
comment|/* Now, scan backwards from the insn to search for a potential 	 delay-slot candidate.  Stop searching when a label or jump is hit.  	 For each candidate, if it is to go into the delay slot (moved 	 forward in execution sequence), it must not need or set any resources 	 that were set by later insns and must not set any resources that 	 are needed for those insns. 	  	 The delay slot insn itself sets resources unless it is a call 	 (in which case the called routine, not the insn itself, is doing 	 the setting).  */
if|if
condition|(
name|slots_filled
operator|<
name|slots_to_fill
condition|)
block|{
name|CLEAR_RESOURCE
argument_list|(
operator|&
name|needed
argument_list|)
expr_stmt|;
name|CLEAR_RESOURCE
argument_list|(
operator|&
name|set
argument_list|)
expr_stmt|;
name|mark_set_resources
argument_list|(
name|insn
argument_list|,
operator|&
name|set
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mark_referenced_resources
argument_list|(
name|insn
argument_list|,
operator|&
name|needed
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|trial
operator|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
init|;
operator|!
name|stop_search_p
argument_list|(
name|trial
argument_list|,
literal|1
argument_list|)
condition|;
name|trial
operator|=
name|next_trial
control|)
block|{
name|next_trial
operator|=
name|prev_nonnote_insn
argument_list|(
name|trial
argument_list|)
expr_stmt|;
comment|/* This must be an INSN or CALL_INSN.  */
name|pat
operator|=
name|PATTERN
argument_list|(
name|trial
argument_list|)
expr_stmt|;
comment|/* USE and CLOBBER at this level was just for flow; ignore it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|CLOBBER
condition|)
continue|continue;
comment|/* Check for resource conflict first, to avoid unnecessary  		 splitting.  */
if|if
condition|(
operator|!
name|insn_references_resource_p
argument_list|(
name|trial
argument_list|,
operator|&
name|set
argument_list|,
literal|1
argument_list|)
operator|&&
operator|!
name|insn_sets_resource_p
argument_list|(
name|trial
argument_list|,
operator|&
name|set
argument_list|,
literal|1
argument_list|)
operator|&&
operator|!
name|insn_sets_resource_p
argument_list|(
name|trial
argument_list|,
operator|&
name|needed
argument_list|,
literal|1
argument_list|)
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* Can't separate set of cc0 from its use.  */
operator|&&
operator|!
operator|(
name|reg_mentioned_p
argument_list|(
name|cc0_rtx
argument_list|,
name|pat
argument_list|)
operator|&&
operator|!
name|sets_cc0_p
argument_list|(
name|cc0_rtx
argument_list|,
name|pat
argument_list|)
operator|)
endif|#
directive|endif
condition|)
block|{
name|trial
operator|=
name|try_split
argument_list|(
name|pat
argument_list|,
name|trial
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|next_trial
operator|=
name|prev_nonnote_insn
argument_list|(
name|trial
argument_list|)
expr_stmt|;
if|if
condition|(
name|eligible_for_delay
argument_list|(
name|insn
argument_list|,
name|slots_filled
argument_list|,
name|trial
argument_list|,
name|flags
argument_list|)
condition|)
block|{
comment|/* In this case, we are searching backward, so if we 			 find insns to put on the delay list, we want 			 to put them at the head, rather than the 			 tail, of the list.  */
name|update_reg_dead_notes
argument_list|(
name|trial
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|delay_list
operator|=
name|gen_rtx_INSN_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|trial
argument_list|,
name|delay_list
argument_list|)
expr_stmt|;
name|update_block
argument_list|(
name|trial
argument_list|,
name|trial
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|trial
argument_list|)
expr_stmt|;
if|if
condition|(
name|slots_to_fill
operator|==
operator|++
name|slots_filled
condition|)
break|break;
continue|continue;
block|}
block|}
name|mark_set_resources
argument_list|(
name|trial
argument_list|,
operator|&
name|set
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mark_referenced_resources
argument_list|(
name|trial
argument_list|,
operator|&
name|needed
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If all needed slots haven't been filled, we come here.  */
comment|/* Try to optimize case of jumping around a single insn.  */
if|#
directive|if
name|defined
argument_list|(
name|ANNUL_IFFALSE_SLOTS
argument_list|)
operator|||
name|defined
argument_list|(
name|ANNUL_IFTRUE_SLOTS
argument_list|)
if|if
condition|(
name|slots_filled
operator|!=
name|slots_to_fill
operator|&&
name|delay_list
operator|==
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
operator|(
name|condjump_p
argument_list|(
name|insn
argument_list|)
operator|||
name|condjump_in_parallel_p
argument_list|(
name|insn
argument_list|)
operator|)
condition|)
block|{
name|delay_list
operator|=
name|optimize_skip
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|delay_list
condition|)
name|slots_filled
operator|+=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Try to get insns from beyond the insn needing the delay slot. 	 These insns can neither set or reference resources set in insns being 	 skipped, cannot set resources in the insn being skipped, and, if this 	 is a CALL_INSN (or a CALL_INSN is passed), cannot trap (because the 	 call might not return).  	 There used to be code which continued past the target label if 	 we saw all uses of the target label.  This code did not work, 	 because it failed to account for some instructions which were 	 both annulled and marked as from the target.  This can happen as a 	 result of optimize_skip.  Since this code was redundant with 	 fill_eager_delay_slots anyways, it was just deleted.  */
if|if
condition|(
name|slots_filled
operator|!=
name|slots_to_fill
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|JUMP_INSN
operator|||
operator|(
operator|(
name|condjump_p
argument_list|(
name|insn
argument_list|)
operator|||
name|condjump_in_parallel_p
argument_list|(
name|insn
argument_list|)
operator|)
operator|&&
operator|!
name|simplejump_p
argument_list|(
name|insn
argument_list|)
operator|&&
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|!=
literal|0
operator|)
operator|)
condition|)
block|{
name|rtx
name|target
init|=
literal|0
decl_stmt|;
name|int
name|maybe_never
init|=
literal|0
decl_stmt|;
name|struct
name|resources
name|needed_at_jump
decl_stmt|;
name|CLEAR_RESOURCE
argument_list|(
operator|&
name|needed
argument_list|)
expr_stmt|;
name|CLEAR_RESOURCE
argument_list|(
operator|&
name|set
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|mark_set_resources
argument_list|(
name|insn
argument_list|,
operator|&
name|set
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mark_referenced_resources
argument_list|(
name|insn
argument_list|,
operator|&
name|needed
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|maybe_never
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|mark_set_resources
argument_list|(
name|insn
argument_list|,
operator|&
name|set
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mark_referenced_resources
argument_list|(
name|insn
argument_list|,
operator|&
name|needed
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
name|target
operator|=
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|trial
operator|=
name|next_nonnote_insn
argument_list|(
name|insn
argument_list|)
init|;
name|trial
condition|;
name|trial
operator|=
name|next_trial
control|)
block|{
name|rtx
name|pat
decl_stmt|,
name|trial_delay
decl_stmt|;
name|next_trial
operator|=
name|next_nonnote_insn
argument_list|(
name|trial
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|trial
argument_list|)
operator|==
name|CODE_LABEL
operator|||
name|GET_CODE
argument_list|(
name|trial
argument_list|)
operator|==
name|BARRIER
condition|)
break|break;
comment|/* We must have an INSN, JUMP_INSN, or CALL_INSN.  */
name|pat
operator|=
name|PATTERN
argument_list|(
name|trial
argument_list|)
expr_stmt|;
comment|/* Stand-alone USE and CLOBBER are just for flow.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|CLOBBER
condition|)
continue|continue;
comment|/* If this already has filled delay slots, get the insn needing 		 the delay slots.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SEQUENCE
condition|)
name|trial_delay
operator|=
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|trial_delay
operator|=
name|trial
expr_stmt|;
comment|/* If this is a jump insn to our target, indicate that we have 		 seen another jump to it.  If we aren't handling a conditional 		 jump, stop our search. Otherwise, compute the needs at its 		 target and add them to NEEDED.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|trial_delay
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
if|if
condition|(
name|target
operator|==
literal|0
condition|)
break|break;
elseif|else
if|if
condition|(
name|JUMP_LABEL
argument_list|(
name|trial_delay
argument_list|)
operator|!=
name|target
condition|)
block|{
name|mark_target_live_regs
argument_list|(
name|next_active_insn
argument_list|(
name|JUMP_LABEL
argument_list|(
name|trial_delay
argument_list|)
argument_list|)
argument_list|,
operator|&
name|needed_at_jump
argument_list|)
expr_stmt|;
name|needed
operator|.
name|memory
operator||=
name|needed_at_jump
operator|.
name|memory
expr_stmt|;
name|needed
operator|.
name|unch_memory
operator||=
name|needed_at_jump
operator|.
name|unch_memory
expr_stmt|;
name|IOR_HARD_REG_SET
argument_list|(
name|needed
operator|.
name|regs
argument_list|,
name|needed_at_jump
operator|.
name|regs
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* See if we have a resource problem before we try to 		 split.   */
if|if
condition|(
name|target
operator|==
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|!=
name|SEQUENCE
operator|&&
operator|!
name|insn_references_resource_p
argument_list|(
name|trial
argument_list|,
operator|&
name|set
argument_list|,
literal|1
argument_list|)
operator|&&
operator|!
name|insn_sets_resource_p
argument_list|(
name|trial
argument_list|,
operator|&
name|set
argument_list|,
literal|1
argument_list|)
operator|&&
operator|!
name|insn_sets_resource_p
argument_list|(
name|trial
argument_list|,
operator|&
name|needed
argument_list|,
literal|1
argument_list|)
ifdef|#
directive|ifdef
name|HAVE_cc0
operator|&&
operator|!
operator|(
name|reg_mentioned_p
argument_list|(
name|cc0_rtx
argument_list|,
name|pat
argument_list|)
operator|&&
operator|!
name|sets_cc0_p
argument_list|(
name|pat
argument_list|)
operator|)
endif|#
directive|endif
operator|&&
operator|!
operator|(
name|maybe_never
operator|&&
name|may_trap_p
argument_list|(
name|pat
argument_list|)
operator|)
operator|&&
operator|(
name|trial
operator|=
name|try_split
argument_list|(
name|pat
argument_list|,
name|trial
argument_list|,
literal|0
argument_list|)
operator|)
operator|&&
name|eligible_for_delay
argument_list|(
name|insn
argument_list|,
name|slots_filled
argument_list|,
name|trial
argument_list|,
name|flags
argument_list|)
condition|)
block|{
name|next_trial
operator|=
name|next_nonnote_insn
argument_list|(
name|trial
argument_list|)
expr_stmt|;
name|delay_list
operator|=
name|add_to_delay_list
argument_list|(
name|trial
argument_list|,
name|delay_list
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|cc0_rtx
argument_list|,
name|pat
argument_list|)
condition|)
name|link_cc0_insns
argument_list|(
name|trial
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|delete_insn
argument_list|(
name|trial
argument_list|)
expr_stmt|;
if|if
condition|(
name|slots_to_fill
operator|==
operator|++
name|slots_filled
condition|)
break|break;
continue|continue;
block|}
name|mark_set_resources
argument_list|(
name|trial
argument_list|,
operator|&
name|set
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mark_referenced_resources
argument_list|(
name|trial
argument_list|,
operator|&
name|needed
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Ensure we don't put insns between the setting of cc and the 		 comparison by moving a setting of cc into an earlier delay 		 slot since these insns could clobber the condition code.  */
name|set
operator|.
name|cc
operator|=
literal|1
expr_stmt|;
comment|/* If this is a call or jump, we might not get here.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|trial_delay
argument_list|)
operator|==
name|CALL_INSN
operator|||
name|GET_CODE
argument_list|(
name|trial_delay
argument_list|)
operator|==
name|JUMP_INSN
condition|)
name|maybe_never
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If there are slots left to fill and our search was stopped by an 	     unconditional branch, try the insn at the branch target.  We can 	     redirect the branch if it works.   	     Don't do this if the insn at the branch target is a branch.  */
if|if
condition|(
name|slots_to_fill
operator|!=
name|slots_filled
operator|&&
name|trial
operator|&&
name|GET_CODE
argument_list|(
name|trial
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|simplejump_p
argument_list|(
name|trial
argument_list|)
operator|&&
operator|(
name|target
operator|==
literal|0
operator|||
name|JUMP_LABEL
argument_list|(
name|trial
argument_list|)
operator|==
name|target
operator|)
operator|&&
operator|(
name|next_trial
operator|=
name|next_active_insn
argument_list|(
name|JUMP_LABEL
argument_list|(
name|trial
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|next_trial
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|next_trial
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|next_trial
argument_list|)
operator|!=
name|JUMP_INSN
operator|&&
operator|!
name|insn_references_resource_p
argument_list|(
name|next_trial
argument_list|,
operator|&
name|set
argument_list|,
literal|1
argument_list|)
operator|&&
operator|!
name|insn_sets_resource_p
argument_list|(
name|next_trial
argument_list|,
operator|&
name|set
argument_list|,
literal|1
argument_list|)
operator|&&
operator|!
name|insn_sets_resource_p
argument_list|(
name|next_trial
argument_list|,
operator|&
name|needed
argument_list|,
literal|1
argument_list|)
ifdef|#
directive|ifdef
name|HAVE_cc0
operator|&&
operator|!
name|reg_mentioned_p
argument_list|(
name|cc0_rtx
argument_list|,
name|PATTERN
argument_list|(
name|next_trial
argument_list|)
argument_list|)
endif|#
directive|endif
operator|&&
operator|!
operator|(
name|maybe_never
operator|&&
name|may_trap_p
argument_list|(
name|PATTERN
argument_list|(
name|next_trial
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|next_trial
operator|=
name|try_split
argument_list|(
name|PATTERN
argument_list|(
name|next_trial
argument_list|)
argument_list|,
name|next_trial
argument_list|,
literal|0
argument_list|)
operator|)
operator|&&
name|eligible_for_delay
argument_list|(
name|insn
argument_list|,
name|slots_filled
argument_list|,
name|next_trial
argument_list|,
name|flags
argument_list|)
condition|)
block|{
name|rtx
name|new_label
init|=
name|next_active_insn
argument_list|(
name|next_trial
argument_list|)
decl_stmt|;
if|if
condition|(
name|new_label
operator|!=
literal|0
condition|)
name|new_label
operator|=
name|get_label_before
argument_list|(
name|new_label
argument_list|)
expr_stmt|;
else|else
name|new_label
operator|=
name|find_end_label
argument_list|()
expr_stmt|;
name|delay_list
operator|=
name|add_to_delay_list
argument_list|(
name|copy_rtx
argument_list|(
name|next_trial
argument_list|)
argument_list|,
name|delay_list
argument_list|)
expr_stmt|;
name|slots_filled
operator|++
expr_stmt|;
name|reorg_redirect_jump
argument_list|(
name|trial
argument_list|,
name|new_label
argument_list|)
expr_stmt|;
comment|/* If we merged because we both jumped to the same place, 		 redirect the original insn also.  */
if|if
condition|(
name|target
condition|)
name|reorg_redirect_jump
argument_list|(
name|insn
argument_list|,
name|new_label
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If this is an unconditional jump, then try to get insns from the 	 target of the jump.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|simplejump_p
argument_list|(
name|insn
argument_list|)
operator|&&
name|slots_filled
operator|!=
name|slots_to_fill
condition|)
name|delay_list
operator|=
name|fill_slots_from_thread
argument_list|(
name|insn
argument_list|,
name|const_true_rtx
argument_list|,
name|next_active_insn
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|own_thread_p
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|,
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|slots_to_fill
argument_list|,
operator|&
name|slots_filled
argument_list|,
name|delay_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|delay_list
condition|)
name|unfilled_slots_base
index|[
name|i
index|]
operator|=
name|emit_delay_sequence
argument_list|(
name|insn
argument_list|,
name|delay_list
argument_list|,
name|slots_filled
argument_list|)
expr_stmt|;
if|if
condition|(
name|slots_to_fill
operator|==
name|slots_filled
condition|)
name|unfilled_slots_base
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|note_delay_statistics
argument_list|(
name|slots_filled
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DELAY_SLOTS_FOR_EPILOGUE
comment|/* See if the epilogue needs any delay slots.  Try to fill them if so.      The only thing we can do is scan backwards from the end of the       function.  If we did this in a previous pass, it is incorrect to do it      again.  */
if|if
condition|(
name|current_function_epilogue_delay_list
condition|)
return|return;
name|slots_to_fill
operator|=
name|DELAY_SLOTS_FOR_EPILOGUE
expr_stmt|;
if|if
condition|(
name|slots_to_fill
operator|==
literal|0
condition|)
return|return;
name|slots_filled
operator|=
literal|0
expr_stmt|;
name|CLEAR_RESOURCE
argument_list|(
operator|&
name|set
argument_list|)
expr_stmt|;
comment|/* The frame pointer and stack pointer are needed at the beginning of      the epilogue, so instructions setting them can not be put in the      epilogue delay slot.  However, everything else needed at function      end is safe, so we don't want to use end_of_function_needs here.  */
name|CLEAR_RESOURCE
argument_list|(
operator|&
name|needed
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
name|SET_HARD_REG_BIT
argument_list|(
name|needed
operator|.
name|regs
argument_list|,
name|FRAME_POINTER_REGNUM
argument_list|)
expr_stmt|;
if|#
directive|if
name|HARD_FRAME_POINTER_REGNUM
operator|!=
name|FRAME_POINTER_REGNUM
name|SET_HARD_REG_BIT
argument_list|(
name|needed
operator|.
name|regs
argument_list|,
name|HARD_FRAME_POINTER_REGNUM
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EXIT_IGNORE_STACK
if|if
condition|(
operator|!
name|EXIT_IGNORE_STACK
condition|)
endif|#
directive|endif
name|SET_HARD_REG_BIT
argument_list|(
name|needed
operator|.
name|regs
argument_list|,
name|STACK_POINTER_REGNUM
argument_list|)
expr_stmt|;
block|}
else|else
name|SET_HARD_REG_BIT
argument_list|(
name|needed
operator|.
name|regs
argument_list|,
name|STACK_POINTER_REGNUM
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EPILOGUE_USES
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|EPILOGUE_USES
argument_list|(
name|i
argument_list|)
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|needed
operator|.
name|regs
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
for|for
control|(
name|trial
operator|=
name|get_last_insn
argument_list|()
init|;
operator|!
name|stop_search_p
argument_list|(
name|trial
argument_list|,
literal|1
argument_list|)
condition|;
name|trial
operator|=
name|PREV_INSN
argument_list|(
name|trial
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|trial
argument_list|)
operator|==
name|NOTE
condition|)
continue|continue;
name|pat
operator|=
name|PATTERN
argument_list|(
name|trial
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|CLOBBER
condition|)
continue|continue;
if|if
condition|(
operator|!
name|insn_references_resource_p
argument_list|(
name|trial
argument_list|,
operator|&
name|set
argument_list|,
literal|1
argument_list|)
operator|&&
operator|!
name|insn_sets_resource_p
argument_list|(
name|trial
argument_list|,
operator|&
name|needed
argument_list|,
literal|1
argument_list|)
operator|&&
operator|!
name|insn_sets_resource_p
argument_list|(
name|trial
argument_list|,
operator|&
name|set
argument_list|,
literal|1
argument_list|)
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* Don't want to mess with cc0 here.  */
operator|&&
operator|!
name|reg_mentioned_p
argument_list|(
name|cc0_rtx
argument_list|,
name|pat
argument_list|)
endif|#
directive|endif
condition|)
block|{
name|trial
operator|=
name|try_split
argument_list|(
name|pat
argument_list|,
name|trial
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ELIGIBLE_FOR_EPILOGUE_DELAY
argument_list|(
name|trial
argument_list|,
name|slots_filled
argument_list|)
condition|)
block|{
comment|/* Here as well we are searching backward, so put the 		 insns we find on the head of the list.  */
name|current_function_epilogue_delay_list
operator|=
name|gen_rtx_INSN_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|trial
argument_list|,
name|current_function_epilogue_delay_list
argument_list|)
expr_stmt|;
name|mark_referenced_resources
argument_list|(
name|trial
argument_list|,
operator|&
name|end_of_function_needs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|update_block
argument_list|(
name|trial
argument_list|,
name|trial
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|trial
argument_list|)
expr_stmt|;
comment|/* Clear deleted bit so final.c will output the insn.  */
name|INSN_DELETED_P
argument_list|(
name|trial
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|slots_to_fill
operator|==
operator|++
name|slots_filled
condition|)
break|break;
continue|continue;
block|}
block|}
name|mark_set_resources
argument_list|(
name|trial
argument_list|,
operator|&
name|set
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mark_referenced_resources
argument_list|(
name|trial
argument_list|,
operator|&
name|needed
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|note_delay_statistics
argument_list|(
name|slots_filled
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Try to find insns to place in delay slots.     INSN is the jump needing SLOTS_TO_FILL delay slots.  It tests CONDITION    or is an unconditional branch if CONDITION is const_true_rtx.    *PSLOTS_FILLED is updated with the number of slots that we have filled.     THREAD is a flow-of-control, either the insns to be executed if the    branch is true or if the branch is false, THREAD_IF_TRUE says which.     OPPOSITE_THREAD is the thread in the opposite direction.  It is used    to see if any potential delay slot insns set things needed there.     LIKELY is non-zero if it is extremely likely that the branch will be    taken and THREAD_IF_TRUE is set.  This is used for the branch at the    end of a loop back up to the top.     OWN_THREAD and OWN_OPPOSITE_THREAD are true if we are the only user of the    thread.  I.e., it is the fallthrough code of our jump or the target of the    jump when we are the only jump going there.     If OWN_THREAD is false, it must be the "true" thread of a jump.  In that    case, we can only take insns from the head of the thread for our delay    slot.  We then adjust the jump to point after the insns we have taken.  */
end_comment

begin_function
specifier|static
name|rtx
name|fill_slots_from_thread
parameter_list|(
name|insn
parameter_list|,
name|condition
parameter_list|,
name|thread
parameter_list|,
name|opposite_thread
parameter_list|,
name|likely
parameter_list|,
name|thread_if_true
parameter_list|,
name|own_thread
parameter_list|,
name|slots_to_fill
parameter_list|,
name|pslots_filled
parameter_list|,
name|delay_list
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|condition
decl_stmt|;
name|rtx
name|thread
decl_stmt|,
name|opposite_thread
decl_stmt|;
name|int
name|likely
decl_stmt|;
name|int
name|thread_if_true
decl_stmt|;
name|int
name|own_thread
decl_stmt|;
name|int
name|slots_to_fill
decl_stmt|,
decl|*
name|pslots_filled
decl_stmt|;
end_function

begin_decl_stmt
name|rtx
name|delay_list
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|rtx
name|new_thread
decl_stmt|;
name|struct
name|resources
name|opposite_needed
decl_stmt|,
name|set
decl_stmt|,
name|needed
decl_stmt|;
name|rtx
name|trial
decl_stmt|;
name|int
name|lose
init|=
literal|0
decl_stmt|;
name|int
name|must_annul
init|=
literal|0
decl_stmt|;
name|int
name|flags
decl_stmt|;
comment|/* Validate our arguments.  */
if|if
condition|(
operator|(
name|condition
operator|==
name|const_true_rtx
operator|&&
operator|!
name|thread_if_true
operator|)
operator|||
operator|(
operator|!
name|own_thread
operator|&&
operator|!
name|thread_if_true
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|flags
operator|=
name|get_jump_flags
argument_list|(
name|insn
argument_list|,
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If our thread is the end of subroutine, we can't get any delay      insns from that.  */
if|if
condition|(
name|thread
operator|==
literal|0
condition|)
return|return
name|delay_list
return|;
comment|/* If this is an unconditional branch, nothing is needed at the      opposite thread.  Otherwise, compute what is needed there.  */
if|if
condition|(
name|condition
operator|==
name|const_true_rtx
condition|)
name|CLEAR_RESOURCE
argument_list|(
operator|&
name|opposite_needed
argument_list|)
expr_stmt|;
else|else
name|mark_target_live_regs
argument_list|(
name|opposite_thread
argument_list|,
operator|&
name|opposite_needed
argument_list|)
expr_stmt|;
comment|/* If the insn at THREAD can be split, do it here to avoid having to      update THREAD and NEW_THREAD if it is done in the loop below.  Also      initialize NEW_THREAD.  */
name|new_thread
operator|=
name|thread
operator|=
name|try_split
argument_list|(
name|PATTERN
argument_list|(
name|thread
argument_list|)
argument_list|,
name|thread
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Scan insns at THREAD.  We are looking for an insn that can be removed      from THREAD (it neither sets nor references resources that were set      ahead of it and it doesn't set anything needs by the insns ahead of      it) and that either can be placed in an annulling insn or aren't      needed at OPPOSITE_THREAD.  */
name|CLEAR_RESOURCE
argument_list|(
operator|&
name|needed
argument_list|)
expr_stmt|;
name|CLEAR_RESOURCE
argument_list|(
operator|&
name|set
argument_list|)
expr_stmt|;
comment|/* If we do not own this thread, we must stop as soon as we find      something that we can't put in a delay slot, since all we can do      is branch into THREAD at a later point.  Therefore, labels stop      the search if this is not the `true' thread.  */
for|for
control|(
name|trial
operator|=
name|thread
init|;
operator|!
name|stop_search_p
argument_list|(
name|trial
argument_list|,
operator|!
name|thread_if_true
argument_list|)
operator|&&
operator|(
operator|!
name|lose
operator|||
name|own_thread
operator|)
condition|;
name|trial
operator|=
name|next_nonnote_insn
argument_list|(
name|trial
argument_list|)
control|)
block|{
name|rtx
name|pat
decl_stmt|,
name|old_trial
decl_stmt|;
comment|/* If we have passed a label, we no longer own this thread.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|trial
argument_list|)
operator|==
name|CODE_LABEL
condition|)
block|{
name|own_thread
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|pat
operator|=
name|PATTERN
argument_list|(
name|trial
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|CLOBBER
condition|)
continue|continue;
comment|/* If TRIAL conflicts with the insns ahead of it, we lose.  Also, 	 don't separate or copy insns that set and use CC0.  */
if|if
condition|(
operator|!
name|insn_references_resource_p
argument_list|(
name|trial
argument_list|,
operator|&
name|set
argument_list|,
literal|1
argument_list|)
operator|&&
operator|!
name|insn_sets_resource_p
argument_list|(
name|trial
argument_list|,
operator|&
name|set
argument_list|,
literal|1
argument_list|)
operator|&&
operator|!
name|insn_sets_resource_p
argument_list|(
name|trial
argument_list|,
operator|&
name|needed
argument_list|,
literal|1
argument_list|)
ifdef|#
directive|ifdef
name|HAVE_cc0
operator|&&
operator|!
operator|(
name|reg_mentioned_p
argument_list|(
name|cc0_rtx
argument_list|,
name|pat
argument_list|)
operator|&&
operator|(
operator|!
name|own_thread
operator|||
operator|!
name|sets_cc0_p
argument_list|(
name|pat
argument_list|)
operator|)
operator|)
endif|#
directive|endif
condition|)
block|{
name|rtx
name|prior_insn
decl_stmt|;
comment|/* If TRIAL is redundant with some insn before INSN, we don't 	     actually need to add it to the delay list; we can merely pretend 	     we did.  */
if|if
condition|(
operator|(
name|prior_insn
operator|=
name|redundant_insn
argument_list|(
name|trial
argument_list|,
name|insn
argument_list|,
name|delay_list
argument_list|)
operator|)
condition|)
block|{
name|fix_reg_dead_note
argument_list|(
name|prior_insn
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|own_thread
condition|)
block|{
name|update_block
argument_list|(
name|trial
argument_list|,
name|thread
argument_list|)
expr_stmt|;
if|if
condition|(
name|trial
operator|==
name|thread
condition|)
block|{
name|thread
operator|=
name|next_active_insn
argument_list|(
name|thread
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_thread
operator|==
name|trial
condition|)
name|new_thread
operator|=
name|thread
expr_stmt|;
block|}
name|delete_insn
argument_list|(
name|trial
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|update_reg_unused_notes
argument_list|(
name|prior_insn
argument_list|,
name|trial
argument_list|)
expr_stmt|;
name|new_thread
operator|=
name|next_active_insn
argument_list|(
name|trial
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* There are two ways we can win:  If TRIAL doesn't set anything 	     needed at the opposite thread and can't trap, or if it can 	     go into an annulled delay slot.  */
if|if
condition|(
name|condition
operator|==
name|const_true_rtx
operator|||
operator|(
operator|!
name|insn_sets_resource_p
argument_list|(
name|trial
argument_list|,
operator|&
name|opposite_needed
argument_list|,
literal|1
argument_list|)
operator|&&
operator|!
name|may_trap_p
argument_list|(
name|pat
argument_list|)
operator|)
condition|)
block|{
name|old_trial
operator|=
name|trial
expr_stmt|;
name|trial
operator|=
name|try_split
argument_list|(
name|pat
argument_list|,
name|trial
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_thread
operator|==
name|old_trial
condition|)
name|new_thread
operator|=
name|trial
expr_stmt|;
if|if
condition|(
name|thread
operator|==
name|old_trial
condition|)
name|thread
operator|=
name|trial
expr_stmt|;
name|pat
operator|=
name|PATTERN
argument_list|(
name|trial
argument_list|)
expr_stmt|;
if|if
condition|(
name|eligible_for_delay
argument_list|(
name|insn
argument_list|,
operator|*
name|pslots_filled
argument_list|,
name|trial
argument_list|,
name|flags
argument_list|)
condition|)
goto|goto
name|winner
goto|;
block|}
elseif|else
if|if
condition|(
literal|0
ifdef|#
directive|ifdef
name|ANNUL_IFTRUE_SLOTS
operator|||
operator|!
name|thread_if_true
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ANNUL_IFFALSE_SLOTS
operator|||
name|thread_if_true
endif|#
directive|endif
condition|)
block|{
name|old_trial
operator|=
name|trial
expr_stmt|;
name|trial
operator|=
name|try_split
argument_list|(
name|pat
argument_list|,
name|trial
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_thread
operator|==
name|old_trial
condition|)
name|new_thread
operator|=
name|trial
expr_stmt|;
if|if
condition|(
name|thread
operator|==
name|old_trial
condition|)
name|thread
operator|=
name|trial
expr_stmt|;
name|pat
operator|=
name|PATTERN
argument_list|(
name|trial
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|thread_if_true
condition|?
name|eligible_for_annul_false
argument_list|(
name|insn
argument_list|,
operator|*
name|pslots_filled
argument_list|,
name|trial
argument_list|,
name|flags
argument_list|)
else|:
name|eligible_for_annul_true
argument_list|(
name|insn
argument_list|,
operator|*
name|pslots_filled
argument_list|,
name|trial
argument_list|,
name|flags
argument_list|)
operator|)
condition|)
block|{
name|rtx
name|temp
decl_stmt|;
name|must_annul
operator|=
literal|1
expr_stmt|;
name|winner
label|:
ifdef|#
directive|ifdef
name|HAVE_cc0
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|cc0_rtx
argument_list|,
name|pat
argument_list|)
condition|)
name|link_cc0_insns
argument_list|(
name|trial
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If we own this thread, delete the insn.  If this is the 		     destination of a branch, show that a basic block status 		     may have been updated.  In any case, mark the new 		     starting point of this thread.  */
if|if
condition|(
name|own_thread
condition|)
block|{
name|update_block
argument_list|(
name|trial
argument_list|,
name|thread
argument_list|)
expr_stmt|;
if|if
condition|(
name|trial
operator|==
name|thread
condition|)
block|{
name|thread
operator|=
name|next_active_insn
argument_list|(
name|thread
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_thread
operator|==
name|trial
condition|)
name|new_thread
operator|=
name|thread
expr_stmt|;
block|}
name|delete_insn
argument_list|(
name|trial
argument_list|)
expr_stmt|;
block|}
else|else
name|new_thread
operator|=
name|next_active_insn
argument_list|(
name|trial
argument_list|)
expr_stmt|;
name|temp
operator|=
name|own_thread
condition|?
name|trial
else|:
name|copy_rtx
argument_list|(
name|trial
argument_list|)
expr_stmt|;
if|if
condition|(
name|thread_if_true
condition|)
name|INSN_FROM_TARGET_P
argument_list|(
name|temp
argument_list|)
operator|=
literal|1
expr_stmt|;
name|delay_list
operator|=
name|add_to_delay_list
argument_list|(
name|temp
argument_list|,
name|delay_list
argument_list|)
expr_stmt|;
name|mark_set_resources
argument_list|(
name|trial
argument_list|,
operator|&
name|opposite_needed
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|slots_to_fill
operator|==
operator|++
operator|(
operator|*
name|pslots_filled
operator|)
condition|)
block|{
comment|/* Even though we have filled all the slots, we 			 may be branching to a location that has a 			 redundant insn.  Skip any if so.  */
while|while
condition|(
name|new_thread
operator|&&
operator|!
name|own_thread
operator|&&
operator|!
name|insn_sets_resource_p
argument_list|(
name|new_thread
argument_list|,
operator|&
name|set
argument_list|,
literal|1
argument_list|)
operator|&&
operator|!
name|insn_sets_resource_p
argument_list|(
name|new_thread
argument_list|,
operator|&
name|needed
argument_list|,
literal|1
argument_list|)
operator|&&
operator|!
name|insn_references_resource_p
argument_list|(
name|new_thread
argument_list|,
operator|&
name|set
argument_list|,
literal|1
argument_list|)
operator|&&
operator|(
name|prior_insn
operator|=
name|redundant_insn
argument_list|(
name|new_thread
argument_list|,
name|insn
argument_list|,
name|delay_list
argument_list|)
operator|)
condition|)
block|{
comment|/* We know we do not own the thread, so no need 			     to call update_block and delete_insn.  */
name|fix_reg_dead_note
argument_list|(
name|prior_insn
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|update_reg_unused_notes
argument_list|(
name|prior_insn
argument_list|,
name|new_thread
argument_list|)
expr_stmt|;
name|new_thread
operator|=
name|next_active_insn
argument_list|(
name|new_thread
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
continue|continue;
block|}
block|}
block|}
comment|/* This insn can't go into a delay slot.  */
name|lose
operator|=
literal|1
expr_stmt|;
name|mark_set_resources
argument_list|(
name|trial
argument_list|,
operator|&
name|set
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mark_referenced_resources
argument_list|(
name|trial
argument_list|,
operator|&
name|needed
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Ensure we don't put insns between the setting of cc and the comparison 	 by moving a setting of cc into an earlier delay slot since these insns 	 could clobber the condition code.  */
name|set
operator|.
name|cc
operator|=
literal|1
expr_stmt|;
comment|/* If this insn is a register-register copy and the next insn has 	 a use of our destination, change it to use our source.  That way, 	 it will become a candidate for our delay slot the next time 	 through this loop.  This case occurs commonly in loops that 	 scan a list.  	 We could check for more complex cases than those tested below, 	 but it doesn't seem worth it.  It might also be a good idea to try 	 to swap the two insns.  That might do better.  	 We can't do this if the next insn modifies our destination, because 	 that would make the replacement into the insn invalid.  We also can't 	 do this if it modifies our source, because it might be an earlyclobber 	 operand.  This latter test also prevents updating the contents of 	 a PRE_INC.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|trial
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|rtx
name|next
init|=
name|next_nonnote_insn
argument_list|(
name|trial
argument_list|)
decl_stmt|;
if|if
condition|(
name|next
operator|&&
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|)
operator|!=
name|USE
operator|&&
operator|!
name|reg_set_p
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|,
name|next
argument_list|)
operator|&&
operator|!
name|reg_set_p
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
name|next
argument_list|)
operator|&&
name|reg_referenced_p
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|,
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|)
condition|)
name|validate_replace_rtx
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If we stopped on a branch insn that has delay slots, see if we can      steal some of the insns in those slots.  */
if|if
condition|(
name|trial
operator|&&
name|GET_CODE
argument_list|(
name|trial
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|trial
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|trial
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
comment|/* If this is the `true' thread, we will want to follow the jump, 	 so we can only do this if we have taken everything up to here.  */
if|if
condition|(
name|thread_if_true
operator|&&
name|trial
operator|==
name|new_thread
operator|&&
operator|!
name|insn_references_resource_p
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|trial
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|opposite_needed
argument_list|,
literal|0
argument_list|)
condition|)
name|delay_list
operator|=
name|steal_delay_list_from_target
argument_list|(
name|insn
argument_list|,
name|condition
argument_list|,
name|PATTERN
argument_list|(
name|trial
argument_list|)
argument_list|,
name|delay_list
argument_list|,
operator|&
name|set
argument_list|,
operator|&
name|needed
argument_list|,
operator|&
name|opposite_needed
argument_list|,
name|slots_to_fill
argument_list|,
name|pslots_filled
argument_list|,
operator|&
name|must_annul
argument_list|,
operator|&
name|new_thread
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|thread_if_true
condition|)
name|delay_list
operator|=
name|steal_delay_list_from_fallthrough
argument_list|(
name|insn
argument_list|,
name|condition
argument_list|,
name|PATTERN
argument_list|(
name|trial
argument_list|)
argument_list|,
name|delay_list
argument_list|,
operator|&
name|set
argument_list|,
operator|&
name|needed
argument_list|,
operator|&
name|opposite_needed
argument_list|,
name|slots_to_fill
argument_list|,
name|pslots_filled
argument_list|,
operator|&
name|must_annul
argument_list|)
expr_stmt|;
block|}
comment|/* If we haven't found anything for this delay slot and it is very      likely that the branch will be taken, see if the insn at our target      increments or decrements a register with an increment that does not      depend on the destination register.  If so, try to place the opposite      arithmetic insn after the jump insn and put the arithmetic insn in the      delay slot.  If we can't do this, return.  */
if|if
condition|(
name|delay_list
operator|==
literal|0
operator|&&
name|likely
operator|&&
name|new_thread
operator|&&
name|GET_CODE
argument_list|(
name|new_thread
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|new_thread
argument_list|)
argument_list|)
operator|!=
name|ASM_INPUT
operator|&&
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|new_thread
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|new_thread
argument_list|)
decl_stmt|;
name|rtx
name|dest
decl_stmt|;
name|rtx
name|src
decl_stmt|;
name|trial
operator|=
name|new_thread
expr_stmt|;
name|pat
operator|=
name|PATTERN
argument_list|(
name|trial
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|trial
argument_list|)
operator|!=
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|!=
name|SET
operator|||
operator|!
name|eligible_for_delay
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|,
name|trial
argument_list|,
name|flags
argument_list|)
condition|)
return|return
literal|0
return|;
name|dest
operator|=
name|SET_DEST
argument_list|(
name|pat
argument_list|)
operator|,
name|src
operator|=
name|SET_SRC
argument_list|(
name|pat
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|MINUS
operator|)
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|,
name|dest
argument_list|)
operator|&&
operator|!
name|reg_overlap_mentioned_p
argument_list|(
name|dest
argument_list|,
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|other
init|=
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|rtx
name|new_arith
decl_stmt|;
name|rtx
name|ninsn
decl_stmt|;
comment|/* If this is a constant adjustment, use the same code with 	     the negated constant.  Otherwise, reverse the sense of the 	     arithmetic.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|other
argument_list|)
operator|==
name|CONST_INT
condition|)
name|new_arith
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|,
name|dest
argument_list|,
name|negate_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|,
name|other
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|new_arith
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|PLUS
condition|?
name|MINUS
else|:
name|PLUS
argument_list|,
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|,
name|dest
argument_list|,
name|other
argument_list|)
expr_stmt|;
name|ninsn
operator|=
name|emit_insn_after
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|dest
argument_list|,
name|new_arith
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|recog_memoized
argument_list|(
name|ninsn
argument_list|)
operator|<
literal|0
operator|||
operator|(
name|insn_extract
argument_list|(
name|ninsn
argument_list|)
operator|,
operator|!
name|constrain_operands
argument_list|(
name|INSN_CODE
argument_list|(
name|ninsn
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
block|{
name|delete_insn
argument_list|(
name|ninsn
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|own_thread
condition|)
block|{
name|update_block
argument_list|(
name|trial
argument_list|,
name|thread
argument_list|)
expr_stmt|;
if|if
condition|(
name|trial
operator|==
name|thread
condition|)
block|{
name|thread
operator|=
name|next_active_insn
argument_list|(
name|thread
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_thread
operator|==
name|trial
condition|)
name|new_thread
operator|=
name|thread
expr_stmt|;
block|}
name|delete_insn
argument_list|(
name|trial
argument_list|)
expr_stmt|;
block|}
else|else
name|new_thread
operator|=
name|next_active_insn
argument_list|(
name|trial
argument_list|)
expr_stmt|;
name|ninsn
operator|=
name|own_thread
condition|?
name|trial
else|:
name|copy_rtx
argument_list|(
name|trial
argument_list|)
expr_stmt|;
if|if
condition|(
name|thread_if_true
condition|)
name|INSN_FROM_TARGET_P
argument_list|(
name|ninsn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|delay_list
operator|=
name|add_to_delay_list
argument_list|(
name|ninsn
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pslots_filled
operator|)
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|delay_list
operator|&&
name|must_annul
condition|)
name|INSN_ANNULLED_BRANCH_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* If we are to branch into the middle of this thread, find an appropriate      label or make a new one if none, and redirect INSN to it.  If we hit the      end of the function, use the end-of-function label.  */
if|if
condition|(
name|new_thread
operator|!=
name|thread
condition|)
block|{
name|rtx
name|label
decl_stmt|;
if|if
condition|(
operator|!
name|thread_if_true
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|new_thread
operator|&&
name|GET_CODE
argument_list|(
name|new_thread
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
operator|(
name|simplejump_p
argument_list|(
name|new_thread
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|new_thread
argument_list|)
argument_list|)
operator|==
name|RETURN
operator|)
operator|&&
name|redirect_with_delay_list_safe_p
argument_list|(
name|insn
argument_list|,
name|JUMP_LABEL
argument_list|(
name|new_thread
argument_list|)
argument_list|,
name|delay_list
argument_list|)
condition|)
name|new_thread
operator|=
name|follow_jumps
argument_list|(
name|JUMP_LABEL
argument_list|(
name|new_thread
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_thread
operator|==
literal|0
condition|)
name|label
operator|=
name|find_end_label
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|new_thread
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|label
operator|=
name|new_thread
expr_stmt|;
else|else
name|label
operator|=
name|get_label_before
argument_list|(
name|new_thread
argument_list|)
expr_stmt|;
name|reorg_redirect_jump
argument_list|(
name|insn
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
return|return
name|delay_list
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Make another attempt to find insns to place in delay slots.     We previously looked for insns located in front of the delay insn    and, for non-jump delay insns, located behind the delay insn.     Here only try to schedule jump insns and try to move insns from either    the target or the following insns into the delay slot.  If annulling is    supported, we will be likely to do this.  Otherwise, we can do this only    if safe.  */
end_comment

begin_function
specifier|static
name|void
name|fill_eager_delay_slots
parameter_list|()
block|{
specifier|register
name|rtx
name|insn
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|num_unfilled_slots
init|=
name|unfilled_slots_next
operator|-
name|unfilled_slots_base
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_unfilled_slots
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|condition
decl_stmt|;
name|rtx
name|target_label
decl_stmt|,
name|insn_at_target
decl_stmt|,
name|fallthrough_insn
decl_stmt|;
name|rtx
name|delay_list
init|=
literal|0
decl_stmt|;
name|int
name|own_target
decl_stmt|;
name|int
name|own_fallthrough
decl_stmt|;
name|int
name|prediction
decl_stmt|,
name|slots_to_fill
decl_stmt|,
name|slots_filled
decl_stmt|;
name|insn
operator|=
name|unfilled_slots_base
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|insn
operator|==
literal|0
operator|||
name|INSN_DELETED_P
argument_list|(
name|insn
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|JUMP_INSN
operator|||
operator|!
operator|(
name|condjump_p
argument_list|(
name|insn
argument_list|)
operator|||
name|condjump_in_parallel_p
argument_list|(
name|insn
argument_list|)
operator|)
condition|)
continue|continue;
name|slots_to_fill
operator|=
name|num_delay_slots
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Some machine description have defined instructions to have 	 delay slots only in certain circumstances which may depend on 	 nearby insns (which change due to reorg's actions).   	 For example, the PA port normally has delay slots for unconditional 	 jumps.  	 However, the PA port claims such jumps do not have a delay slot 	 if they are immediate successors of certain CALL_INSNs.  This 	 allows the port to favor filling the delay slot of the call with 	 the unconditional jump.  */
if|if
condition|(
name|slots_to_fill
operator|==
literal|0
condition|)
continue|continue;
name|slots_filled
operator|=
literal|0
expr_stmt|;
name|target_label
operator|=
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|condition
operator|=
name|get_branch_condition
argument_list|(
name|insn
argument_list|,
name|target_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|condition
operator|==
literal|0
condition|)
continue|continue;
comment|/* Get the next active fallthrough and target insns and see if we own 	 them.  Then see whether the branch is likely true.  We don't need 	 to do a lot of this for unconditional branches.  */
name|insn_at_target
operator|=
name|next_active_insn
argument_list|(
name|target_label
argument_list|)
expr_stmt|;
name|own_target
operator|=
name|own_thread_p
argument_list|(
name|target_label
argument_list|,
name|target_label
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|condition
operator|==
name|const_true_rtx
condition|)
block|{
name|own_fallthrough
operator|=
literal|0
expr_stmt|;
name|fallthrough_insn
operator|=
literal|0
expr_stmt|;
name|prediction
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|fallthrough_insn
operator|=
name|next_active_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|own_fallthrough
operator|=
name|own_thread_p
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|prediction
operator|=
name|mostly_true_jump
argument_list|(
name|insn
argument_list|,
name|condition
argument_list|)
expr_stmt|;
block|}
comment|/* If this insn is expected to branch, first try to get insns from our 	 target, then our fallthrough insns.  If it is not, expected to branch, 	 try the other order.  */
if|if
condition|(
name|prediction
operator|>
literal|0
condition|)
block|{
name|delay_list
operator|=
name|fill_slots_from_thread
argument_list|(
name|insn
argument_list|,
name|condition
argument_list|,
name|insn_at_target
argument_list|,
name|fallthrough_insn
argument_list|,
name|prediction
operator|==
literal|2
argument_list|,
literal|1
argument_list|,
name|own_target
argument_list|,
name|slots_to_fill
argument_list|,
operator|&
name|slots_filled
argument_list|,
name|delay_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|delay_list
operator|==
literal|0
operator|&&
name|own_fallthrough
condition|)
block|{
comment|/* Even though we didn't find anything for delay slots, 		 we might have found a redundant insn which we deleted 		 from the thread that was filled.  So we have to recompute 		 the next insn at the target.  */
name|target_label
operator|=
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|insn_at_target
operator|=
name|next_active_insn
argument_list|(
name|target_label
argument_list|)
expr_stmt|;
name|delay_list
operator|=
name|fill_slots_from_thread
argument_list|(
name|insn
argument_list|,
name|condition
argument_list|,
name|fallthrough_insn
argument_list|,
name|insn_at_target
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|own_fallthrough
argument_list|,
name|slots_to_fill
argument_list|,
operator|&
name|slots_filled
argument_list|,
name|delay_list
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|own_fallthrough
condition|)
name|delay_list
operator|=
name|fill_slots_from_thread
argument_list|(
name|insn
argument_list|,
name|condition
argument_list|,
name|fallthrough_insn
argument_list|,
name|insn_at_target
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|own_fallthrough
argument_list|,
name|slots_to_fill
argument_list|,
operator|&
name|slots_filled
argument_list|,
name|delay_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|delay_list
operator|==
literal|0
condition|)
name|delay_list
operator|=
name|fill_slots_from_thread
argument_list|(
name|insn
argument_list|,
name|condition
argument_list|,
name|insn_at_target
argument_list|,
name|next_active_insn
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|own_target
argument_list|,
name|slots_to_fill
argument_list|,
operator|&
name|slots_filled
argument_list|,
name|delay_list
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|delay_list
condition|)
name|unfilled_slots_base
index|[
name|i
index|]
operator|=
name|emit_delay_sequence
argument_list|(
name|insn
argument_list|,
name|delay_list
argument_list|,
name|slots_filled
argument_list|)
expr_stmt|;
if|if
condition|(
name|slots_to_fill
operator|==
name|slots_filled
condition|)
name|unfilled_slots_base
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|note_delay_statistics
argument_list|(
name|slots_filled
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Once we have tried two ways to fill a delay slot, make a pass over the    code to try to improve the results and to do such things as more jump    threading.  */
end_comment

begin_function
specifier|static
name|void
name|relax_delay_slots
parameter_list|(
name|first
parameter_list|)
name|rtx
name|first
decl_stmt|;
block|{
specifier|register
name|rtx
name|insn
decl_stmt|,
name|next
decl_stmt|,
name|pat
decl_stmt|;
specifier|register
name|rtx
name|trial
decl_stmt|,
name|delay_insn
decl_stmt|,
name|target_label
decl_stmt|;
comment|/* Look at every JUMP_INSN and see if we can improve it.  */
for|for
control|(
name|insn
operator|=
name|first
init|;
name|insn
condition|;
name|insn
operator|=
name|next
control|)
block|{
name|rtx
name|other
decl_stmt|;
name|next
operator|=
name|next_active_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* If this is a jump insn, see if it now jumps to a jump, jumps to 	 the next insn, or jumps to a label that is not the last of a 	 group of consecutive labels.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
operator|(
name|condjump_p
argument_list|(
name|insn
argument_list|)
operator|||
name|condjump_in_parallel_p
argument_list|(
name|insn
argument_list|)
operator|)
operator|&&
operator|(
name|target_label
operator|=
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|target_label
operator|=
name|follow_jumps
argument_list|(
name|target_label
argument_list|)
expr_stmt|;
name|target_label
operator|=
name|prev_label
argument_list|(
name|next_active_insn
argument_list|(
name|target_label
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_label
operator|==
literal|0
condition|)
name|target_label
operator|=
name|find_end_label
argument_list|()
expr_stmt|;
if|if
condition|(
name|next_active_insn
argument_list|(
name|target_label
argument_list|)
operator|==
name|next
operator|&&
operator|!
name|condjump_in_parallel_p
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|delete_jump
argument_list|(
name|insn
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|target_label
operator|!=
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
condition|)
name|reorg_redirect_jump
argument_list|(
name|insn
argument_list|,
name|target_label
argument_list|)
expr_stmt|;
comment|/* See if this jump branches around a unconditional jump. 	     If so, invert this jump and point it to the target of the 	     second jump.  */
if|if
condition|(
name|next
operator|&&
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
operator|(
name|simplejump_p
argument_list|(
name|next
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|)
operator|==
name|RETURN
operator|)
operator|&&
name|next_active_insn
argument_list|(
name|target_label
argument_list|)
operator|==
name|next_active_insn
argument_list|(
name|next
argument_list|)
operator|&&
name|no_labels_between_p
argument_list|(
name|insn
argument_list|,
name|next
argument_list|)
condition|)
block|{
name|rtx
name|label
init|=
name|JUMP_LABEL
argument_list|(
name|next
argument_list|)
decl_stmt|;
comment|/* Be careful how we do this to avoid deleting code or 		 labels that are momentarily dead.  See similar optimization 		 in jump.c.  		 We also need to ensure we properly handle the case when 		 invert_jump fails.  */
operator|++
name|LABEL_NUSES
argument_list|(
name|target_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|label
condition|)
operator|++
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
name|invert_jump
argument_list|(
name|insn
argument_list|,
name|label
argument_list|)
condition|)
block|{
name|delete_insn
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|next
operator|=
name|insn
expr_stmt|;
block|}
if|if
condition|(
name|label
condition|)
operator|--
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|LABEL_NUSES
argument_list|(
name|target_label
argument_list|)
operator|==
literal|0
condition|)
name|delete_insn
argument_list|(
name|target_label
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* If this is an unconditional jump and the previous insn is a 	 conditional jump, try reversing the condition of the previous 	 insn and swapping our targets.  The next pass might be able to 	 fill the slots.  	 Don't do this if we expect the conditional branch to be true, because 	 we would then be making the more common case longer.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
operator|(
name|simplejump_p
argument_list|(
name|insn
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|RETURN
operator|)
operator|&&
operator|(
name|other
operator|=
name|prev_active_insn
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|condjump_p
argument_list|(
name|other
argument_list|)
operator|||
name|condjump_in_parallel_p
argument_list|(
name|other
argument_list|)
operator|)
operator|&&
name|no_labels_between_p
argument_list|(
name|other
argument_list|,
name|insn
argument_list|)
operator|&&
literal|0
operator|<
name|mostly_true_jump
argument_list|(
name|other
argument_list|,
name|get_branch_condition
argument_list|(
name|other
argument_list|,
name|JUMP_LABEL
argument_list|(
name|other
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|other_target
init|=
name|JUMP_LABEL
argument_list|(
name|other
argument_list|)
decl_stmt|;
name|target_label
operator|=
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Increment the count of OTHER_TARGET, so it doesn't get deleted 	     as we move the label.  */
if|if
condition|(
name|other_target
condition|)
operator|++
name|LABEL_NUSES
argument_list|(
name|other_target
argument_list|)
expr_stmt|;
if|if
condition|(
name|invert_jump
argument_list|(
name|other
argument_list|,
name|target_label
argument_list|)
condition|)
name|reorg_redirect_jump
argument_list|(
name|insn
argument_list|,
name|other_target
argument_list|)
expr_stmt|;
if|if
condition|(
name|other_target
condition|)
operator|--
name|LABEL_NUSES
argument_list|(
name|other_target
argument_list|)
expr_stmt|;
block|}
comment|/* Now look only at cases where we have filled a delay slot.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|SEQUENCE
condition|)
continue|continue;
name|pat
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|delay_insn
operator|=
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* See if the first insn in the delay slot is redundant with some 	 previous insn.  Remove it from the delay slot if so; then set up 	 to reprocess this insn.  */
if|if
condition|(
name|redundant_insn
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|delay_insn
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|delete_from_delay_slot
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|next
operator|=
name|prev_active_insn
argument_list|(
name|next
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Now look only at the cases where we have a filled JUMP_INSN.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|JUMP_INSN
operator|||
operator|!
operator|(
name|condjump_p
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
name|condjump_in_parallel_p
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
continue|continue;
name|target_label
operator|=
name|JUMP_LABEL
argument_list|(
name|delay_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_label
condition|)
block|{
comment|/* If this jump goes to another unconditional jump, thread it, but 	     don't convert a jump into a RETURN here.  */
name|trial
operator|=
name|follow_jumps
argument_list|(
name|target_label
argument_list|)
expr_stmt|;
comment|/* We use next_real_insn instead of next_active_insn, so that 	     the special USE insns emitted by reorg won't be ignored. 	     If they are ignored, then they will get deleted if target_label 	     is now unreachable, and that would cause mark_target_live_regs 	     to fail.  */
name|trial
operator|=
name|prev_label
argument_list|(
name|next_real_insn
argument_list|(
name|trial
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|trial
operator|==
literal|0
operator|&&
name|target_label
operator|!=
literal|0
condition|)
name|trial
operator|=
name|find_end_label
argument_list|()
expr_stmt|;
if|if
condition|(
name|trial
operator|!=
name|target_label
operator|&&
name|redirect_with_delay_slots_safe_p
argument_list|(
name|delay_insn
argument_list|,
name|trial
argument_list|,
name|insn
argument_list|)
condition|)
block|{
name|reorg_redirect_jump
argument_list|(
name|delay_insn
argument_list|,
name|trial
argument_list|)
expr_stmt|;
name|target_label
operator|=
name|trial
expr_stmt|;
block|}
comment|/* If the first insn at TARGET_LABEL is redundant with a previous 	     insn, redirect the jump to the following insn process again.  */
name|trial
operator|=
name|next_active_insn
argument_list|(
name|target_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|trial
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|trial
argument_list|)
argument_list|)
operator|!=
name|SEQUENCE
operator|&&
name|redundant_insn
argument_list|(
name|trial
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|rtx
name|tmp
decl_stmt|;
comment|/* Figure out where to emit the special USE insn so we don't 		 later incorrectly compute register live/death info.  */
name|tmp
operator|=
name|next_active_insn
argument_list|(
name|trial
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
literal|0
condition|)
name|tmp
operator|=
name|find_end_label
argument_list|()
expr_stmt|;
comment|/* Insert the special USE insn and update dataflow info.  */
name|update_block
argument_list|(
name|trial
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* Now emit a label before the special USE insn, and 		 redirect our jump to the new label.  */
name|target_label
operator|=
name|get_label_before
argument_list|(
name|PREV_INSN
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|reorg_redirect_jump
argument_list|(
name|delay_insn
argument_list|,
name|target_label
argument_list|)
expr_stmt|;
name|next
operator|=
name|insn
expr_stmt|;
continue|continue;
block|}
comment|/* Similarly, if it is an unconditional jump with one insn in its 	     delay list and that insn is redundant, thread the jump.  */
if|if
condition|(
name|trial
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|trial
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
operator|&&
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|trial
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
literal|2
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|trial
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
operator|(
name|simplejump_p
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|trial
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|trial
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|RETURN
operator|)
operator|&&
name|redundant_insn
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|trial
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|target_label
operator|=
name|JUMP_LABEL
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|trial
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_label
operator|==
literal|0
condition|)
name|target_label
operator|=
name|find_end_label
argument_list|()
expr_stmt|;
if|if
condition|(
name|redirect_with_delay_slots_safe_p
argument_list|(
name|delay_insn
argument_list|,
name|target_label
argument_list|,
name|insn
argument_list|)
condition|)
block|{
name|reorg_redirect_jump
argument_list|(
name|delay_insn
argument_list|,
name|target_label
argument_list|)
expr_stmt|;
name|next
operator|=
name|insn
expr_stmt|;
continue|continue;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|INSN_ANNULLED_BRANCH_P
argument_list|(
name|delay_insn
argument_list|)
operator|&&
name|prev_active_insn
argument_list|(
name|target_label
argument_list|)
operator|==
name|insn
operator|&&
operator|!
name|condjump_in_parallel_p
argument_list|(
name|delay_insn
argument_list|)
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* If the last insn in the delay slot sets CC0 for some insn, 	     various code assumes that it is in a delay slot.  We could 	     put it back where it belonged and delete the register notes, 	     but it doesn't seem worthwhile in this uncommon case.  */
operator|&&
operator|!
name|find_reg_note
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|,
name|REG_CC_USER
argument_list|,
name|NULL_RTX
argument_list|)
endif|#
directive|endif
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* All this insn does is execute its delay list and jump to the 	     following insn.  So delete the jump and just execute the delay 	     list insns.  	     We do this by deleting the INSN containing the SEQUENCE, then 	     re-emitting the insns separately, and then deleting the jump. 	     This allows the count of the jump target to be properly 	     decremented.  */
comment|/* Clear the from target bit, since these insns are no longer 	     in delay slots.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
name|INSN_FROM_TARGET_P
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|trial
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|emit_insn_after
argument_list|(
name|pat
argument_list|,
name|trial
argument_list|)
expr_stmt|;
name|delete_scheduled_jump
argument_list|(
name|delay_insn
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* See if this is an unconditional jump around a single insn which is 	 identical to the one in its delay slot.  In this case, we can just 	 delete the branch and the insn in its delay slot.  */
if|if
condition|(
name|next
operator|&&
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|INSN
operator|&&
name|prev_label
argument_list|(
name|next_active_insn
argument_list|(
name|next
argument_list|)
argument_list|)
operator|==
name|target_label
operator|&&
name|simplejump_p
argument_list|(
name|insn
argument_list|)
operator|&&
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
operator|==
literal|2
operator|&&
name|rtx_equal_p
argument_list|(
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|,
name|PATTERN
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* See if this jump (with its delay slots) branches around another 	 jump (without delay slots).  If so, invert this jump and point 	 it to the target of the second jump.  We cannot do this for 	 annulled jumps, though.  Again, don't convert a jump to a RETURN 	 here.  */
if|if
condition|(
operator|!
name|INSN_ANNULLED_BRANCH_P
argument_list|(
name|delay_insn
argument_list|)
operator|&&
name|next
operator|&&
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
operator|(
name|simplejump_p
argument_list|(
name|next
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|)
operator|==
name|RETURN
operator|)
operator|&&
name|next_active_insn
argument_list|(
name|target_label
argument_list|)
operator|==
name|next_active_insn
argument_list|(
name|next
argument_list|)
operator|&&
name|no_labels_between_p
argument_list|(
name|insn
argument_list|,
name|next
argument_list|)
condition|)
block|{
name|rtx
name|label
init|=
name|JUMP_LABEL
argument_list|(
name|next
argument_list|)
decl_stmt|;
name|rtx
name|old_label
init|=
name|JUMP_LABEL
argument_list|(
name|delay_insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|label
operator|==
literal|0
condition|)
name|label
operator|=
name|find_end_label
argument_list|()
expr_stmt|;
if|if
condition|(
name|redirect_with_delay_slots_safe_p
argument_list|(
name|delay_insn
argument_list|,
name|label
argument_list|,
name|insn
argument_list|)
condition|)
block|{
comment|/* Be careful how we do this to avoid deleting code or labels 		 that are momentarily dead.  See similar optimization in 		 jump.c  */
if|if
condition|(
name|old_label
condition|)
operator|++
name|LABEL_NUSES
argument_list|(
name|old_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|invert_jump
argument_list|(
name|delay_insn
argument_list|,
name|label
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Must update the INSN_FROM_TARGET_P bits now that 		     the branch is reversed, so that mark_target_live_regs 		     will handle the delay slot insn correctly.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|slot
init|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|INSN_FROM_TARGET_P
argument_list|(
name|slot
argument_list|)
operator|=
operator|!
name|INSN_FROM_TARGET_P
argument_list|(
name|slot
argument_list|)
expr_stmt|;
block|}
name|delete_insn
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|next
operator|=
name|insn
expr_stmt|;
block|}
if|if
condition|(
name|old_label
operator|&&
operator|--
name|LABEL_NUSES
argument_list|(
name|old_label
argument_list|)
operator|==
literal|0
condition|)
name|delete_insn
argument_list|(
name|old_label
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* If we own the thread opposite the way this insn branches, see if we 	 can merge its delay slots with following insns.  */
if|if
condition|(
name|INSN_FROM_TARGET_P
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|own_thread_p
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
name|try_merge_delay_insns
argument_list|(
name|insn
argument_list|,
name|next
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|INSN_FROM_TARGET_P
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|own_thread_p
argument_list|(
name|target_label
argument_list|,
name|target_label
argument_list|,
literal|0
argument_list|)
condition|)
name|try_merge_delay_insns
argument_list|(
name|insn
argument_list|,
name|next_active_insn
argument_list|(
name|target_label
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we get here, we haven't deleted INSN.  But we may have deleted 	 NEXT, so recompute it.  */
name|next
operator|=
name|next_active_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_return
end_ifdef

begin_comment
comment|/* Look for filled jumps to the end of function label.  We can try to convert    them into RETURN insns if the insns in the delay slot are valid for the    RETURN as well.  */
end_comment

begin_function
specifier|static
name|void
name|make_return_insns
parameter_list|(
name|first
parameter_list|)
name|rtx
name|first
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|,
name|jump_insn
decl_stmt|,
name|pat
decl_stmt|;
name|rtx
name|real_return_label
init|=
name|end_of_function_label
decl_stmt|;
name|int
name|slots
decl_stmt|,
name|i
decl_stmt|;
comment|/* See if there is a RETURN insn in the function other than the one we      made for END_OF_FUNCTION_LABEL.  If so, set up anything we can't change      into a RETURN to jump to it.  */
for|for
control|(
name|insn
operator|=
name|first
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|RETURN
condition|)
block|{
name|real_return_label
operator|=
name|get_label_before
argument_list|(
name|insn
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Show an extra usage of REAL_RETURN_LABEL so it won't go away if it      was equal to END_OF_FUNCTION_LABEL.  */
name|LABEL_NUSES
argument_list|(
name|real_return_label
argument_list|)
operator|++
expr_stmt|;
comment|/* Clear the list of insns to fill so we can use it.  */
name|obstack_free
argument_list|(
operator|&
name|unfilled_slots_obstack
argument_list|,
name|unfilled_firstobj
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|first
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|int
name|flags
decl_stmt|;
comment|/* Only look at filled JUMP_INSNs that go to the end of function 	 label.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|SEQUENCE
operator|||
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|JUMP_INSN
operator|||
name|JUMP_LABEL
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|end_of_function_label
condition|)
continue|continue;
name|pat
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|jump_insn
operator|=
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If we can't make the jump into a RETURN, try to redirect it to the best 	 RETURN and go on to the next insn.  */
if|if
condition|(
operator|!
name|reorg_redirect_jump
argument_list|(
name|jump_insn
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
block|{
comment|/* Make sure redirecting the jump will not invalidate the delay 	     slot insns.  */
if|if
condition|(
name|redirect_with_delay_slots_safe_p
argument_list|(
name|jump_insn
argument_list|,
name|real_return_label
argument_list|,
name|insn
argument_list|)
condition|)
name|reorg_redirect_jump
argument_list|(
name|jump_insn
argument_list|,
name|real_return_label
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* See if this RETURN can accept the insns current in its delay slot. 	 It can if it has more or an equal number of slots and the contents 	 of each is valid.  */
name|flags
operator|=
name|get_jump_flags
argument_list|(
name|jump_insn
argument_list|,
name|JUMP_LABEL
argument_list|(
name|jump_insn
argument_list|)
argument_list|)
expr_stmt|;
name|slots
operator|=
name|num_delay_slots
argument_list|(
name|jump_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|slots
operator|>=
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
operator|(
ifdef|#
directive|ifdef
name|ANNUL_IFFALSE_SLOTS
operator|(
name|INSN_ANNULLED_BRANCH_P
argument_list|(
name|jump_insn
argument_list|)
operator|&&
name|INSN_FROM_TARGET_P
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|)
condition|?
name|eligible_for_annul_false
argument_list|(
name|jump_insn
argument_list|,
name|i
operator|-
literal|1
argument_list|,
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|flags
argument_list|)
else|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ANNUL_IFTRUE_SLOTS
operator|(
name|INSN_ANNULLED_BRANCH_P
argument_list|(
name|jump_insn
argument_list|)
operator|&&
operator|!
name|INSN_FROM_TARGET_P
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|)
condition|?
name|eligible_for_annul_true
argument_list|(
name|jump_insn
argument_list|,
name|i
operator|-
literal|1
argument_list|,
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|flags
argument_list|)
else|:
endif|#
directive|endif
name|eligible_for_delay
argument_list|(
name|jump_insn
argument_list|,
name|i
operator|-
literal|1
argument_list|,
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|flags
argument_list|)
operator|)
condition|)
break|break;
block|}
else|else
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
condition|)
continue|continue;
comment|/* We have to do something with this insn.  If it is an unconditional 	 RETURN, delete the SEQUENCE and output the individual insns, 	 followed by the RETURN.  Then set things up so we try to find 	 insns for its delay slots, if it needs some.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|jump_insn
argument_list|)
argument_list|)
operator|==
name|RETURN
condition|)
block|{
name|rtx
name|prev
init|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
name|prev
operator|=
name|emit_insn_after
argument_list|(
name|PATTERN
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|,
name|prev
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_jump_insn_after
argument_list|(
name|PATTERN
argument_list|(
name|jump_insn
argument_list|)
argument_list|,
name|prev
argument_list|)
expr_stmt|;
name|emit_barrier_after
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|slots
condition|)
name|obstack_ptr_grow
argument_list|(
operator|&
name|unfilled_slots_obstack
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* It is probably more efficient to keep this with its current 	   delay slot as a branch to a RETURN.  */
name|reorg_redirect_jump
argument_list|(
name|jump_insn
argument_list|,
name|real_return_label
argument_list|)
expr_stmt|;
block|}
comment|/* Now delete REAL_RETURN_LABEL if we never used it.  Then try to fill any      new delay slots we have created.  */
if|if
condition|(
operator|--
name|LABEL_NUSES
argument_list|(
name|real_return_label
argument_list|)
operator|==
literal|0
condition|)
name|delete_insn
argument_list|(
name|real_return_label
argument_list|)
expr_stmt|;
name|fill_simple_delay_slots
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|fill_simple_delay_slots
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Try to find insns to place in delay slots.  */
end_comment

begin_function
name|void
name|dbr_schedule
parameter_list|(
name|first
parameter_list|,
name|file
parameter_list|)
name|rtx
name|first
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|,
name|next
decl_stmt|,
name|epilogue_insn
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
if|#
directive|if
literal|0
block|int old_flag_no_peephole = flag_no_peephole;
comment|/* Execute `final' once in prescan mode to delete any insns that won't be      used.  Don't let final try to do any peephole optimization--it will      ruin dataflow information for this pass.  */
block|flag_no_peephole = 1;   final (first, 0, NO_DEBUG, 1, 1);   flag_no_peephole = old_flag_no_peephole;
endif|#
directive|endif
comment|/* If the current function has no insns other than the prologue and       epilogue, then do not try to fill any delay slots.  */
if|if
condition|(
name|n_basic_blocks
operator|==
literal|0
condition|)
return|return;
comment|/* Find the highest INSN_UID and allocate and initialize our map from      INSN_UID's to position in code.  */
for|for
control|(
name|max_uid
operator|=
literal|0
operator|,
name|insn
operator|=
name|first
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|>
name|max_uid
condition|)
name|max_uid
operator|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_EPILOGUE_BEG
condition|)
name|epilogue_insn
operator|=
name|insn
expr_stmt|;
block|}
name|uid_to_ruid
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|max_uid
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|insn
operator|=
name|first
init|;
name|insn
condition|;
name|i
operator|++
operator|,
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
name|uid_to_ruid
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
operator|=
name|i
expr_stmt|;
comment|/* Initialize the list of insns that need filling.  */
if|if
condition|(
name|unfilled_firstobj
operator|==
literal|0
condition|)
block|{
name|gcc_obstack_init
argument_list|(
operator|&
name|unfilled_slots_obstack
argument_list|)
expr_stmt|;
name|unfilled_firstobj
operator|=
operator|(
name|rtx
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|unfilled_slots_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|insn
operator|=
name|next_active_insn
argument_list|(
name|first
argument_list|)
init|;
name|insn
condition|;
name|insn
operator|=
name|next_active_insn
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|rtx
name|target
decl_stmt|;
name|INSN_ANNULLED_BRANCH_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
name|INSN_FROM_TARGET_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Skip vector tables.  We can't get attributes for them.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ADDR_VEC
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
operator|)
condition|)
continue|continue;
if|if
condition|(
name|num_delay_slots
argument_list|(
name|insn
argument_list|)
operator|>
literal|0
condition|)
name|obstack_ptr_grow
argument_list|(
operator|&
name|unfilled_slots_obstack
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* Ensure all jumps go to the last of a set of consecutive labels.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
operator|(
name|condjump_p
argument_list|(
name|insn
argument_list|)
operator|||
name|condjump_in_parallel_p
argument_list|(
name|insn
argument_list|)
operator|)
operator|&&
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|target
operator|=
name|prev_label
argument_list|(
name|next_active_insn
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|!=
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|)
condition|)
name|redirect_jump
argument_list|(
name|insn
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
comment|/* Indicate what resources are required to be valid at the end of the current      function.  The condition code never is and memory always is.  If the      frame pointer is needed, it is and so is the stack pointer unless      EXIT_IGNORE_STACK is non-zero.  If the frame pointer is not needed, the      stack pointer is.  Registers used to return the function value are      needed.  Registers holding global variables are needed.  */
name|end_of_function_needs
operator|.
name|cc
operator|=
literal|0
expr_stmt|;
name|end_of_function_needs
operator|.
name|memory
operator|=
literal|1
expr_stmt|;
name|end_of_function_needs
operator|.
name|unch_memory
operator|=
literal|0
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|end_of_function_needs
operator|.
name|regs
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
name|SET_HARD_REG_BIT
argument_list|(
name|end_of_function_needs
operator|.
name|regs
argument_list|,
name|FRAME_POINTER_REGNUM
argument_list|)
expr_stmt|;
if|#
directive|if
name|HARD_FRAME_POINTER_REGNUM
operator|!=
name|FRAME_POINTER_REGNUM
name|SET_HARD_REG_BIT
argument_list|(
name|end_of_function_needs
operator|.
name|regs
argument_list|,
name|HARD_FRAME_POINTER_REGNUM
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EXIT_IGNORE_STACK
if|if
condition|(
operator|!
name|EXIT_IGNORE_STACK
condition|)
endif|#
directive|endif
name|SET_HARD_REG_BIT
argument_list|(
name|end_of_function_needs
operator|.
name|regs
argument_list|,
name|STACK_POINTER_REGNUM
argument_list|)
expr_stmt|;
block|}
else|else
name|SET_HARD_REG_BIT
argument_list|(
name|end_of_function_needs
operator|.
name|regs
argument_list|,
name|STACK_POINTER_REGNUM
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_function_return_rtx
operator|!=
literal|0
condition|)
name|mark_referenced_resources
argument_list|(
name|current_function_return_rtx
argument_list|,
operator|&
name|end_of_function_needs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|global_regs
index|[
name|i
index|]
ifdef|#
directive|ifdef
name|EPILOGUE_USES
operator|||
name|EPILOGUE_USES
argument_list|(
name|i
argument_list|)
endif|#
directive|endif
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|end_of_function_needs
operator|.
name|regs
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* The registers required to be live at the end of the function are      represented in the flow information as being dead just prior to      reaching the end of the function.  For example, the return of a value      might be represented by a USE of the return register immediately      followed by an unconditional jump to the return label where the      return label is the end of the RTL chain.  The end of the RTL chain      is then taken to mean that the return register is live.       This sequence is no longer maintained when epilogue instructions are      added to the RTL chain.  To reconstruct the original meaning, the      start of the epilogue (NOTE_INSN_EPILOGUE_BEG) is regarded as the      point where these registers become live (start_of_epilogue_needs).      If epilogue instructions are present, the registers set by those      instructions won't have been processed by flow.  Thus, those      registers are additionally required at the end of the RTL chain      (end_of_function_needs).  */
name|start_of_epilogue_needs
operator|=
name|end_of_function_needs
expr_stmt|;
while|while
condition|(
operator|(
name|epilogue_insn
operator|=
name|next_nonnote_insn
argument_list|(
name|epilogue_insn
argument_list|)
operator|)
condition|)
name|mark_set_resources
argument_list|(
name|epilogue_insn
argument_list|,
operator|&
name|end_of_function_needs
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Show we haven't computed an end-of-function label yet.  */
name|end_of_function_label
operator|=
literal|0
expr_stmt|;
comment|/* Allocate and initialize the tables used by mark_target_live_regs.  */
name|target_hash_table
operator|=
operator|(
expr|struct
name|target_info
operator|*
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|TARGET_HASH_PRIME
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|target_info
operator|*
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|target_hash_table
argument_list|,
name|TARGET_HASH_PRIME
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|target_info
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|bb_ticks
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|n_basic_blocks
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|bb_ticks
argument_list|,
name|n_basic_blocks
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize the statistics for this function.  */
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|num_insns_needing_delays
argument_list|,
sizeof|sizeof
name|num_insns_needing_delays
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|num_filled_delays
argument_list|,
sizeof|sizeof
name|num_filled_delays
argument_list|)
expr_stmt|;
comment|/* Now do the delay slot filling.  Try everything twice in case earlier      changes make more slots fillable.  */
for|for
control|(
name|reorg_pass_number
operator|=
literal|0
init|;
name|reorg_pass_number
operator|<
name|MAX_REORG_PASSES
condition|;
name|reorg_pass_number
operator|++
control|)
block|{
name|fill_simple_delay_slots
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|fill_simple_delay_slots
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|fill_eager_delay_slots
argument_list|()
expr_stmt|;
name|relax_delay_slots
argument_list|(
name|first
argument_list|)
expr_stmt|;
block|}
comment|/* Delete any USE insns made by update_block; subsequent passes don't need      them or know how to deal with them.  */
for|for
control|(
name|insn
operator|=
name|first
init|;
name|insn
condition|;
name|insn
operator|=
name|next
control|)
block|{
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|USE
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
name|next
operator|=
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* If we made an end of function label, indicate that it is now      safe to delete it by undoing our prior adjustment to LABEL_NUSES.      If it is now unused, delete it.  */
if|if
condition|(
name|end_of_function_label
operator|&&
operator|--
name|LABEL_NUSES
argument_list|(
name|end_of_function_label
argument_list|)
operator|==
literal|0
condition|)
name|delete_insn
argument_list|(
name|end_of_function_label
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_return
if|if
condition|(
name|HAVE_return
operator|&&
name|end_of_function_label
operator|!=
literal|0
condition|)
name|make_return_insns
argument_list|(
name|first
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|obstack_free
argument_list|(
operator|&
name|unfilled_slots_obstack
argument_list|,
name|unfilled_firstobj
argument_list|)
expr_stmt|;
comment|/* It is not clear why the line below is needed, but it does seem to be.  */
name|unfilled_firstobj
operator|=
operator|(
name|rtx
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|unfilled_slots_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Reposition the prologue and epilogue notes in case we moved the      prologue/epilogue insns.  */
name|reposition_prologue_and_epilogue_notes
argument_list|(
name|first
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|need_comma
decl_stmt|;
for|for
control|(
name|reorg_pass_number
operator|=
literal|0
init|;
name|reorg_pass_number
operator|<
name|MAX_REORG_PASSES
condition|;
name|reorg_pass_number
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";; Reorg pass #%d:\n"
argument_list|,
name|reorg_pass_number
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_REORG_FUNCTIONS
condition|;
name|i
operator|++
control|)
block|{
name|need_comma
operator|=
literal|0
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";; Reorg function #%d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";; %d insns needing delay slots\n;; "
argument_list|,
name|num_insns_needing_delays
index|[
name|i
index|]
index|[
name|reorg_pass_number
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MAX_DELAY_HISTOGRAM
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|num_filled_delays
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|reorg_pass_number
index|]
condition|)
block|{
if|if
condition|(
name|need_comma
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|need_comma
operator|=
literal|1
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d got %d delays"
argument_list|,
name|num_filled_delays
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|reorg_pass_number
index|]
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* For all JUMP insns, fill in branch prediction notes, so that during      assembler output a target can set branch prediction bits in the code.      We have to do this now, as up until this point the destinations of      JUMPS can be moved around and changed, but past right here that cannot      happen.  */
for|for
control|(
name|insn
operator|=
name|first
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|int
name|pred_flags
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|JUMP_INSN
condition|)
continue|continue;
name|pred_flags
operator|=
name|get_jump_flags
argument_list|(
name|insn
argument_list|,
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_BR_PRED
argument_list|,
name|GEN_INT
argument_list|(
name|pred_flags
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DELAY_SLOTS */
end_comment

end_unit

