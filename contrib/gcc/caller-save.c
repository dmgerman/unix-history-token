begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Save and restore call-clobbered registers which are live across a call.    Copyright (C) 1989, 1992, 94-95, 1997, 1998 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"reload.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|MAX_MOVE_MAX
end_ifndef

begin_define
define|#
directive|define
name|MAX_MOVE_MAX
value|MOVE_MAX
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MIN_UNITS_PER_WORD
end_ifndef

begin_define
define|#
directive|define
name|MIN_UNITS_PER_WORD
value|UNITS_PER_WORD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Modes for each hard register that we can save.  The smallest mode is wide    enough to save the entire contents of the register.  When saving the    register because it is live we first try to save in multi-register modes.    If that is not possible the save is done one register at a time.  */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|machine_mode
name|regno_save_mode
index|[
name|FIRST_PSEUDO_REGISTER
index|]
index|[
name|MAX_MOVE_MAX
operator|/
name|MIN_UNITS_PER_WORD
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For each hard register, a place on the stack where it can be saved,    if needed.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|regno_save_mem
index|[
name|FIRST_PSEUDO_REGISTER
index|]
index|[
name|MAX_MOVE_MAX
operator|/
name|MIN_UNITS_PER_WORD
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We will only make a register eligible for caller-save if it can be    saved in its widest mode with a simple SET insn as long as the memory    address is valid.  We record the INSN_CODE is those insns here since    when we emit them, the addresses might not be valid, so they might not    be recognized.  */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|insn_code
name|reg_save_code
index|[
name|FIRST_PSEUDO_REGISTER
index|]
index|[
name|MAX_MOVE_MAX
operator|/
name|MIN_UNITS_PER_WORD
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|insn_code
name|reg_restore_code
index|[
name|FIRST_PSEUDO_REGISTER
index|]
index|[
name|MAX_MOVE_MAX
operator|/
name|MIN_UNITS_PER_WORD
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set of hard regs currently live (during scan of all insns).  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|hard_regs_live
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set of hard regs currently residing in save area (during insn scan).  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|hard_regs_saved
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set of hard regs which need to be restored before referenced.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|hard_regs_need_restore
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of registers currently in hard_regs_saved.  */
end_comment

begin_decl_stmt
name|int
name|n_regs_saved
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_reg_live
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|clear_reg_live
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|restore_referenced_regs
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
expr|enum
name|machine_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|insert_save_restore
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|,
name|int
operator|,
expr|enum
name|machine_mode
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Initialize for caller-save.     Look at all the hard registers that are used by a call and for which    regclass.c has not already excluded from being used across a call.     Ensure that we can find a mode to save the register and that there is a     simple insn to save and restore the register.  This latter check avoids    problems that would occur if we tried to save the MQ register of some    machines directly into memory.  */
end_comment

begin_function
name|void
name|init_caller_save
parameter_list|()
block|{
name|char
modifier|*
name|first_obj
init|=
operator|(
name|char
operator|*
operator|)
name|oballoc
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|addr_reg
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|rtx
name|address
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* First find all the registers that we need to deal with and all      the modes that they can have.  If we can't find a mode to use,      we can't have the register live over calls.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|call_used_regs
index|[
name|i
index|]
operator|&&
operator|!
name|call_fixed_regs
index|[
name|i
index|]
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|MOVE_MAX
operator|/
name|UNITS_PER_WORD
condition|;
name|j
operator|++
control|)
block|{
name|regno_save_mode
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|choose_hard_reg_mode
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno_save_mode
index|[
name|i
index|]
index|[
name|j
index|]
operator|==
name|VOIDmode
operator|&&
name|j
operator|==
literal|1
condition|)
block|{
name|call_fixed_regs
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|call_fixed_reg_set
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
name|regno_save_mode
index|[
name|i
index|]
index|[
literal|1
index|]
operator|=
name|VOIDmode
expr_stmt|;
block|}
comment|/* The following code tries to approximate the conditions under which      we can easily save and restore a register without scratch registers or      other complexities.  It will usually work, except under conditions where      the validity of an insn operand is dependent on the address offset.      No such cases are currently known.       We first find a typical offset from some BASE_REG_CLASS register.      This address is chosen by finding the first register in the class      and by finding the smallest power of two that is a valid offset from      that register in every mode we will use to save registers.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|BASE_REG_CLASS
index|]
argument_list|,
name|i
argument_list|)
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|FIRST_PSEUDO_REGISTER
condition|)
name|abort
argument_list|()
expr_stmt|;
name|addr_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|offset
operator|=
literal|1
operator|<<
operator|(
name|HOST_BITS_PER_INT
operator|/
literal|2
operator|)
init|;
name|offset
condition|;
name|offset
operator|>>=
literal|1
control|)
block|{
name|address
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|addr_reg
argument_list|,
name|GEN_INT
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regno_save_mode
index|[
name|i
index|]
index|[
literal|1
index|]
operator|!=
name|VOIDmode
operator|&&
operator|!
name|strict_memory_address_p
argument_list|(
name|regno_save_mode
index|[
name|i
index|]
index|[
literal|1
index|]
argument_list|,
name|address
argument_list|)
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|FIRST_PSEUDO_REGISTER
condition|)
break|break;
block|}
comment|/* If we didn't find a valid address, we must use register indirect.  */
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
name|address
operator|=
name|addr_reg
expr_stmt|;
comment|/* Next we try to form an insn to save and restore the register.  We      see if such an insn is recognized and meets its constraints.  */
name|start_sequence
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|MOVE_MAX
operator|/
name|UNITS_PER_WORD
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|regno_save_mode
index|[
name|i
index|]
index|[
name|j
index|]
operator|!=
name|VOIDmode
condition|)
block|{
name|rtx
name|mem
init|=
name|gen_rtx_MEM
argument_list|(
name|regno_save_mode
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|,
name|address
argument_list|)
decl_stmt|;
name|rtx
name|reg
init|=
name|gen_rtx_REG
argument_list|(
name|regno_save_mode
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|rtx
name|savepat
init|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|mem
argument_list|,
name|reg
argument_list|)
decl_stmt|;
name|rtx
name|restpat
init|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|mem
argument_list|)
decl_stmt|;
name|rtx
name|saveinsn
init|=
name|emit_insn
argument_list|(
name|savepat
argument_list|)
decl_stmt|;
name|rtx
name|restinsn
init|=
name|emit_insn
argument_list|(
name|restpat
argument_list|)
decl_stmt|;
name|int
name|ok
decl_stmt|;
name|reg_save_code
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|recog_memoized
argument_list|(
name|saveinsn
argument_list|)
expr_stmt|;
name|reg_restore_code
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|recog_memoized
argument_list|(
name|restinsn
argument_list|)
expr_stmt|;
comment|/* Now extract both insns and see if we can meet their              constraints.  */
name|ok
operator|=
operator|(
name|reg_save_code
index|[
name|i
index|]
index|[
name|j
index|]
operator|!=
operator|-
literal|1
operator|&&
name|reg_restore_code
index|[
name|i
index|]
index|[
name|j
index|]
operator|!=
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|ok
condition|)
block|{
name|insn_extract
argument_list|(
name|saveinsn
argument_list|)
expr_stmt|;
name|ok
operator|=
name|constrain_operands
argument_list|(
name|reg_save_code
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|insn_extract
argument_list|(
name|restinsn
argument_list|)
expr_stmt|;
name|ok
operator|&=
name|constrain_operands
argument_list|(
name|reg_restore_code
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|regno_save_mode
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|VOIDmode
expr_stmt|;
if|if
condition|(
name|j
operator|==
literal|1
condition|)
block|{
name|call_fixed_regs
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|call_fixed_reg_set
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|end_sequence
argument_list|()
expr_stmt|;
name|obfree
argument_list|(
name|first_obj
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Initialize save areas by showing that we haven't allocated any yet.  */
end_comment

begin_function
name|void
name|init_save_areas
parameter_list|()
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|MOVE_MAX
operator|/
name|UNITS_PER_WORD
condition|;
name|j
operator|++
control|)
name|regno_save_mem
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Allocate save areas for any hard registers that might need saving.    We take a conservative approach here and look for call-clobbered hard    registers that are assigned to pseudos that cross calls.  This may    overestimate slightly (especially if some of these registers are later    used as spill registers), but it should not be significant.     Then perform register elimination in the addresses of the save area    locations; return 1 if all eliminated addresses are strictly valid.    We assume that our caller has set up the elimination table to the    worst (largest) possible offsets.     Set *PCHANGED to 1 if we had to allocate some memory for the save area.       Future work:       In the fallback case we should iterate backwards across all possible      modes for the save, choosing the largest available one instead of       falling back to the smallest mode immediately.  (eg TF -> DF -> SF).       We do not try to use "move multiple" instructions that exist      on some machines (such as the 68k moveml).  It could be a win to try       and use them when possible.  The hard part is doing it in a way that is      machine independent since they might be saving non-consecutive       registers. (imagine caller-saving d0,d1,a0,a1 on the 68k) */
end_comment

begin_function
name|int
name|setup_save_areas
parameter_list|(
name|pchanged
parameter_list|)
name|int
modifier|*
name|pchanged
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|HARD_REG_SET
name|hard_regs_used
decl_stmt|;
name|int
name|ok
init|=
literal|1
decl_stmt|;
comment|/* Allocate space in the save area for the largest multi-register      pseudos first, then work backwards to single register      pseudos.  */
comment|/* Find and record all call-used hard-registers in this function.  */
name|CLEAR_HARD_REG_SET
argument_list|(
name|hard_regs_used
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
name|max_regno
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|reg_renumber
index|[
name|i
index|]
operator|>=
literal|0
operator|&&
name|REG_N_CALLS_CROSSED
argument_list|(
name|i
argument_list|)
operator|>
literal|0
condition|)
block|{
name|int
name|regno
init|=
name|reg_renumber
index|[
name|i
index|]
decl_stmt|;
name|int
name|endregno
init|=
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|regno_reg_rtx
index|[
name|i
index|]
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|nregs
init|=
name|endregno
operator|-
name|regno
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nregs
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|call_used_regs
index|[
name|regno
operator|+
name|j
index|]
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|hard_regs_used
argument_list|,
name|regno
operator|+
name|j
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now run through all the call-used hard-registers and allocate      space for them in the caller-save area.  Try to allocate space      in a manner which allows multi-register saves/restores to be done.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
name|MOVE_MAX
operator|/
name|UNITS_PER_WORD
init|;
name|j
operator|>
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|int
name|ok
init|=
literal|1
decl_stmt|;
name|int
name|do_save
decl_stmt|;
comment|/* If no mode exists for this size, try another.  Also break out 	   if we have already saved this hard register.  */
if|if
condition|(
name|regno_save_mode
index|[
name|i
index|]
index|[
name|j
index|]
operator|==
name|VOIDmode
operator|||
name|regno_save_mem
index|[
name|i
index|]
index|[
literal|1
index|]
operator|!=
literal|0
condition|)
continue|continue;
comment|/* See if any register in this group has been saved.  */
name|do_save
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|j
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|regno_save_mem
index|[
name|i
operator|+
name|k
index|]
index|[
literal|1
index|]
condition|)
block|{
name|do_save
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|do_save
condition|)
continue|continue;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|j
condition|;
name|k
operator|++
control|)
block|{
name|int
name|regno
init|=
name|i
operator|+
name|k
decl_stmt|;
name|ok
operator|&=
operator|(
name|TEST_HARD_REG_BIT
argument_list|(
name|hard_regs_used
argument_list|,
name|regno
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
comment|/* We have found an acceptable mode to store in.  */
if|if
condition|(
name|ok
condition|)
block|{
name|regno_save_mem
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|assign_stack_local
argument_list|(
name|regno_save_mode
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|regno_save_mode
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Setup single word save area just in case...  */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|j
condition|;
name|k
operator|++
control|)
block|{
comment|/* This should not depend on WORDS_BIG_ENDIAN. 		   The order of words in regs is the same as in memory.  */
name|rtx
name|temp
init|=
name|gen_rtx_MEM
argument_list|(
name|regno_save_mode
index|[
name|i
operator|+
name|k
index|]
index|[
literal|1
index|]
argument_list|,
name|XEXP
argument_list|(
name|regno_save_mem
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|regno_save_mem
index|[
name|i
operator|+
name|k
index|]
index|[
literal|1
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|temp
argument_list|,
name|k
operator|*
name|UNITS_PER_WORD
argument_list|)
expr_stmt|;
block|}
operator|*
name|pchanged
operator|=
literal|1
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|MOVE_MAX
operator|/
name|UNITS_PER_WORD
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|regno_save_mem
index|[
name|i
index|]
index|[
name|j
index|]
operator|!=
literal|0
condition|)
name|ok
operator|&=
name|strict_memory_address_p
argument_list|(
name|GET_MODE
argument_list|(
name|regno_save_mem
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|eliminate_regs
argument_list|(
name|regno_save_mem
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|,
literal|0
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ok
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find the places where hard regs are live across calls and save them.     INSN_MODE is the mode to assign to any insns that we add.  This is used    by reload to determine whether or not reloads or register eliminations    need be done on these insns.  */
end_comment

begin_function
name|void
name|save_call_clobbered_regs
parameter_list|(
name|insn_mode
parameter_list|)
name|enum
name|machine_mode
name|insn_mode
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
name|int
name|b
decl_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|n_basic_blocks
condition|;
name|b
operator|++
control|)
block|{
name|regset
name|regs_live
init|=
name|basic_block_live_at_start
index|[
name|b
index|]
decl_stmt|;
name|rtx
name|prev_block_last
init|=
name|PREV_INSN
argument_list|(
name|basic_block_head
index|[
name|b
index|]
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|regno
decl_stmt|;
comment|/* Compute hard regs live at start of block -- this is the 	 real hard regs marked live, plus live pseudo regs that 	 have been renumbered to hard regs.  No registers have yet been 	 saved because we restore all of them before the end of the basic 	 block.  */
name|REG_SET_TO_HARD_REG_SET
argument_list|(
name|hard_regs_live
argument_list|,
name|regs_live
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|hard_regs_saved
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|hard_regs_need_restore
argument_list|)
expr_stmt|;
name|n_regs_saved
operator|=
literal|0
expr_stmt|;
name|EXECUTE_IF_SET_IN_REG_SET
argument_list|(
argument|regs_live
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|{ 				   if ((regno = reg_renumber[i])>=
literal|0
argument|) 				     for (j = regno; 					  j< regno + HARD_REGNO_NREGS (regno, 									PSEUDO_REGNO_MODE (i)); 					  j++) 				       SET_HARD_REG_BIT (hard_regs_live, j); 				 }
argument_list|)
empty_stmt|;
comment|/* Now scan the insns in the block, keeping track of what hard 	 regs are live as we go.  When we see a call, save the live 	 call-clobbered hard regs.  */
for|for
control|(
name|insn
operator|=
name|basic_block_head
index|[
name|b
index|]
init|;
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'i'
condition|)
block|{
name|rtx
name|link
decl_stmt|;
comment|/* If some registers have been saved, see if INSN references 		 any of them.  We must restore them before the insn if so.  */
if|if
condition|(
name|n_regs_saved
condition|)
name|restore_referenced_regs
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|,
name|insn_mode
argument_list|)
expr_stmt|;
comment|/* NB: the normal procedure is to first enliven any 		 registers set by insn, then deaden any registers that 		 had their last use at insn.  This is incorrect now, 		 since multiple pseudos may have been mapped to the 		 same hard reg, and the death notes are ambiguous.  So 		 it must be done in the other, safe, order.  */
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_DEAD
condition|)
name|clear_reg_live
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* When we reach a call, we need to save all registers that are 		 live, call-used, not fixed, and not already saved.  We must 		 test at this point because registers that die in a CALL_INSN 		 are not live across the call and likewise for registers that 		 are born in the CALL_INSN. 		  		 If registers are filled with parameters for this function, 		 and some of these are also being set by this function, then 		 they will not appear to die (no REG_DEAD note for them), 		 to check if in fact they do, collect the set registers in 		 hard_regs_live first.  */
if|if
condition|(
name|code
operator|==
name|CALL_INSN
condition|)
block|{
name|HARD_REG_SET
name|this_call_sets
decl_stmt|;
block|{
name|HARD_REG_SET
name|old_hard_regs_live
decl_stmt|;
comment|/* Save the hard_regs_live information.  */
name|COPY_HARD_REG_SET
argument_list|(
name|old_hard_regs_live
argument_list|,
name|hard_regs_live
argument_list|)
expr_stmt|;
comment|/* Now calculate hard_regs_live for this CALL_INSN 		       only.  */
name|CLEAR_HARD_REG_SET
argument_list|(
name|hard_regs_live
argument_list|)
expr_stmt|;
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|set_reg_live
argument_list|)
expr_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|this_call_sets
argument_list|,
name|hard_regs_live
argument_list|)
expr_stmt|;
comment|/* Restore the hard_regs_live information.  */
name|COPY_HARD_REG_SET
argument_list|(
name|hard_regs_live
argument_list|,
name|old_hard_regs_live
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|call_used_regs
index|[
name|regno
index|]
operator|&&
operator|!
name|call_fixed_regs
index|[
name|regno
index|]
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|hard_regs_live
argument_list|,
name|regno
argument_list|)
comment|/* It must not be set by this instruction.  */
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|this_call_sets
argument_list|,
name|regno
argument_list|)
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|hard_regs_saved
argument_list|,
name|regno
argument_list|)
condition|)
name|regno
operator|+=
name|insert_save_restore
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|,
name|regno
argument_list|,
name|insn_mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Put the information for this CALL_INSN on top of what 		     we already had.  */
name|IOR_HARD_REG_SET
argument_list|(
name|hard_regs_live
argument_list|,
name|this_call_sets
argument_list|)
expr_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|hard_regs_need_restore
argument_list|,
name|hard_regs_saved
argument_list|)
expr_stmt|;
comment|/* Must recompute n_regs_saved.  */
name|n_regs_saved
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|hard_regs_saved
argument_list|,
name|regno
argument_list|)
condition|)
name|n_regs_saved
operator|++
expr_stmt|;
block|}
else|else
block|{
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|set_reg_live
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AUTO_INC_DEC
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_INC
condition|)
name|set_reg_live
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_UNUSED
condition|)
name|clear_reg_live
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|insn
operator|==
name|basic_block_end
index|[
name|b
index|]
condition|)
break|break;
block|}
comment|/* At the end of the basic block, we must restore any registers that 	 remain saved.  If the last insn in the block is a JUMP_INSN, put 	 the restore before the insn, otherwise, put it after the insn.  */
if|if
condition|(
name|n_regs_saved
condition|)
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|hard_regs_need_restore
argument_list|,
name|regno
argument_list|)
condition|)
name|regno
operator|+=
name|insert_save_restore
argument_list|(
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|?
name|insn
else|:
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|,
name|regno
argument_list|,
name|insn_mode
argument_list|,
name|MOVE_MAX
operator|/
name|UNITS_PER_WORD
argument_list|)
expr_stmt|;
comment|/* If we added any insns at the start of the block, update the start 	 of the block to point at those insns.  */
name|basic_block_head
index|[
name|b
index|]
operator|=
name|NEXT_INSN
argument_list|(
name|prev_block_last
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Here from note_stores when an insn stores a value in a register.    Set the proper bit or bits in hard_regs_live.  All pseudos that have    been assigned hard regs have had their register number changed already,    so we can ignore pseudos.  */
end_comment

begin_function
specifier|static
name|void
name|set_reg_live
parameter_list|(
name|reg
parameter_list|,
name|setter
parameter_list|)
name|rtx
name|reg
decl_stmt|;
name|rtx
name|setter
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
specifier|register
name|int
name|regno
decl_stmt|,
name|endregno
decl_stmt|,
name|i
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|reg
argument_list|)
decl_stmt|;
name|int
name|word
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|word
operator|=
name|SUBREG_WORD
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
return|return;
name|regno
operator|=
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|+
name|word
expr_stmt|;
name|endregno
operator|=
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|regno
init|;
name|i
operator|<
name|endregno
condition|;
name|i
operator|++
control|)
block|{
name|SET_HARD_REG_BIT
argument_list|(
name|hard_regs_live
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_BIT
argument_list|(
name|hard_regs_saved
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_BIT
argument_list|(
name|hard_regs_need_restore
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Here when a REG_DEAD note records the last use of a reg.  Clear    the appropriate bit or bits in hard_regs_live.  Again we can ignore    pseudos.  */
end_comment

begin_function
specifier|static
name|void
name|clear_reg_live
parameter_list|(
name|reg
parameter_list|)
name|rtx
name|reg
decl_stmt|;
block|{
specifier|register
name|int
name|regno
decl_stmt|,
name|endregno
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
return|return;
name|regno
operator|=
name|REGNO
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|endregno
operator|=
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|regno
init|;
name|i
operator|<
name|endregno
condition|;
name|i
operator|++
control|)
block|{
name|CLEAR_HARD_REG_BIT
argument_list|(
name|hard_regs_live
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_BIT
argument_list|(
name|hard_regs_need_restore
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_BIT
argument_list|(
name|hard_regs_saved
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If any register currently residing in the save area is referenced in X,    which is part of INSN, emit code to restore the register in front of INSN.    INSN_MODE is the mode to assign to any insns that we add.  */
end_comment

begin_function
specifier|static
name|void
name|restore_referenced_regs
parameter_list|(
name|x
parameter_list|,
name|insn
parameter_list|,
name|insn_mode
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|enum
name|machine_mode
name|insn_mode
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|CLOBBER
condition|)
return|return;
if|if
condition|(
name|code
operator|==
name|REG
condition|)
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|x
argument_list|)
decl_stmt|;
comment|/* If this is a pseudo, scan its memory location, since it might 	 involve the use of another register, which might be saved.  */
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|reg_equiv_mem
index|[
name|regno
index|]
operator|!=
literal|0
condition|)
name|restore_referenced_regs
argument_list|(
name|XEXP
argument_list|(
name|reg_equiv_mem
index|[
name|regno
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|,
name|insn_mode
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|reg_equiv_address
index|[
name|regno
index|]
operator|!=
literal|0
condition|)
name|restore_referenced_regs
argument_list|(
name|reg_equiv_address
index|[
name|regno
index|]
argument_list|,
name|insn
argument_list|,
name|insn_mode
argument_list|)
expr_stmt|;
comment|/* Otherwise if this is a hard register, restore any piece of it that 	 is currently saved.  */
elseif|else
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|int
name|numregs
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Save at most SAVEREGS at a time.  This can not be larger than 	     MOVE_MAX, because that causes insert_save_restore to fail.  */
name|int
name|saveregs
init|=
name|MIN
argument_list|(
name|numregs
argument_list|,
name|MOVE_MAX
operator|/
name|UNITS_PER_WORD
argument_list|)
decl_stmt|;
name|int
name|endregno
init|=
name|regno
operator|+
name|numregs
decl_stmt|;
for|for
control|(
name|i
operator|=
name|regno
init|;
name|i
operator|<
name|endregno
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|hard_regs_need_restore
argument_list|,
name|i
argument_list|)
condition|)
name|i
operator|+=
name|insert_save_restore
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|,
name|i
argument_list|,
name|insn_mode
argument_list|,
name|saveregs
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|restore_referenced_regs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|,
name|insn_mode
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|restore_referenced_regs
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|insn
argument_list|,
name|insn_mode
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Insert a sequence of insns to save or restore, SAVE_P says which,    REGNO.  Place these insns in front of INSN.  INSN_MODE is the mode    to assign to these insns.   MAXRESTORE is the maximum number of registers    which should be restored during this call (when SAVE_P == 0).  It should    never be less than 1 since we only work with entire registers.     Note that we have verified in init_caller_save that we can do this    with a simple SET, so use it.  Set INSN_CODE to what we save there    since the address might not be valid so the insn might not be recognized.    These insns will be reloaded and have register elimination done by    find_reload, so we need not worry about that here.     Return the extra number of registers saved.  */
end_comment

begin_function
specifier|static
name|int
name|insert_save_restore
parameter_list|(
name|insn
parameter_list|,
name|save_p
parameter_list|,
name|regno
parameter_list|,
name|insn_mode
parameter_list|,
name|maxrestore
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|int
name|save_p
decl_stmt|;
name|int
name|regno
decl_stmt|;
name|enum
name|machine_mode
name|insn_mode
decl_stmt|;
name|int
name|maxrestore
decl_stmt|;
block|{
name|rtx
name|pat
init|=
name|NULL_RTX
decl_stmt|;
name|enum
name|insn_code
name|code
init|=
name|CODE_FOR_nothing
decl_stmt|;
name|int
name|numregs
init|=
literal|0
decl_stmt|;
comment|/* A common failure mode if register status is not correct in the RTL      is for this routine to be called with a REGNO we didn't expect to      save.  That will cause us to write an insn with a (nil) SET_DEST      or SET_SRC.  Instead of doing so and causing a crash later, check      for this common case and abort here instead.  This will remove one      step in debugging such problems.  */
if|if
condition|(
name|regno_save_mem
index|[
name|regno
index|]
index|[
literal|1
index|]
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* If INSN references CC0, put our insns in front of the insn that sets      CC0.  This is always safe, since the only way we could be passed an      insn that references CC0 is for a restore, and doing a restore earlier      isn't a problem.  We do, however, assume here that CALL_INSNs don't      reference CC0.  Guard against non-INSN's like CODE_LABEL.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|)
operator|&&
name|reg_referenced_p
argument_list|(
name|cc0_rtx
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
name|insn
operator|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Get the pattern to emit and update our status.  */
if|if
condition|(
name|save_p
condition|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|int
name|ok
decl_stmt|;
comment|/* See if we can save several registers with a single instruction.   	 Work backwards to the single register case.  */
for|for
control|(
name|i
operator|=
name|MOVE_MAX
operator|/
name|UNITS_PER_WORD
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|ok
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|regno_save_mem
index|[
name|regno
index|]
index|[
name|i
index|]
operator|!=
literal|0
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|call_used_regs
index|[
name|regno
operator|+
name|j
index|]
operator|||
name|call_fixed_regs
index|[
name|regno
operator|+
name|j
index|]
operator|||
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|hard_regs_live
argument_list|,
name|regno
operator|+
name|j
argument_list|)
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|hard_regs_saved
argument_list|,
name|regno
operator|+
name|j
argument_list|)
condition|)
name|ok
operator|=
literal|0
expr_stmt|;
block|}
else|else
continue|continue;
comment|/* Must do this one save at a time */
if|if
condition|(
operator|!
name|ok
condition|)
continue|continue;
name|pat
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|regno_save_mem
index|[
name|regno
index|]
index|[
name|i
index|]
argument_list|,
name|gen_rtx_REG
argument_list|(
name|GET_MODE
argument_list|(
name|regno_save_mem
index|[
name|regno
index|]
index|[
name|i
index|]
argument_list|)
argument_list|,
name|regno
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|=
name|reg_save_code
index|[
name|regno
index|]
index|[
name|i
index|]
expr_stmt|;
comment|/* Set hard_regs_saved for all the registers we saved.  */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|i
condition|;
name|k
operator|++
control|)
block|{
name|SET_HARD_REG_BIT
argument_list|(
name|hard_regs_saved
argument_list|,
name|regno
operator|+
name|k
argument_list|)
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|hard_regs_need_restore
argument_list|,
name|regno
operator|+
name|k
argument_list|)
expr_stmt|;
name|n_regs_saved
operator|++
expr_stmt|;
block|}
name|numregs
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|int
name|ok
decl_stmt|;
comment|/* See if we can restore `maxrestore' registers at once.  Work 	 backwards to the single register case.  */
for|for
control|(
name|i
operator|=
name|maxrestore
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|ok
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|regno_save_mem
index|[
name|regno
index|]
index|[
name|i
index|]
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|hard_regs_need_restore
argument_list|,
name|regno
operator|+
name|j
argument_list|)
condition|)
name|ok
operator|=
literal|0
expr_stmt|;
block|}
else|else
continue|continue;
comment|/* Must do this one restore at a time */
if|if
condition|(
operator|!
name|ok
condition|)
continue|continue;
name|pat
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|GET_MODE
argument_list|(
name|regno_save_mem
index|[
name|regno
index|]
index|[
name|i
index|]
argument_list|)
argument_list|,
name|regno
argument_list|)
argument_list|,
name|regno_save_mem
index|[
name|regno
index|]
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|code
operator|=
name|reg_restore_code
index|[
name|regno
index|]
index|[
name|i
index|]
expr_stmt|;
comment|/* Clear status for all registers we restored.  */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|i
condition|;
name|k
operator|++
control|)
block|{
name|CLEAR_HARD_REG_BIT
argument_list|(
name|hard_regs_need_restore
argument_list|,
name|regno
operator|+
name|k
argument_list|)
expr_stmt|;
name|n_regs_saved
operator|--
expr_stmt|;
block|}
name|numregs
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
comment|/* Emit the insn and set the code and mode.  */
name|insn
operator|=
name|emit_insn_before
argument_list|(
name|pat
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|insn
argument_list|,
name|insn_mode
argument_list|)
expr_stmt|;
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|=
name|code
expr_stmt|;
comment|/* Tell our callers how many extra registers we saved/restored */
return|return
name|numregs
operator|-
literal|1
return|;
block|}
end_function

end_unit

