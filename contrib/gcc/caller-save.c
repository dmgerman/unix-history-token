begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Save and restore call-clobbered registers which are live across a call.    Copyright (C) 1989, 1992, 94-95, 97, 98, 1999 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"reload.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|MAX_MOVE_MAX
end_ifndef

begin_define
define|#
directive|define
name|MAX_MOVE_MAX
value|MOVE_MAX
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MIN_UNITS_PER_WORD
end_ifndef

begin_define
define|#
directive|define
name|MIN_UNITS_PER_WORD
value|UNITS_PER_WORD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|MOVE_MAX_WORDS
value|(MOVE_MAX / UNITS_PER_WORD)
end_define

begin_comment
comment|/* Modes for each hard register that we can save.  The smallest mode is wide    enough to save the entire contents of the register.  When saving the    register because it is live we first try to save in multi-register modes.    If that is not possible the save is done one register at a time.  */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|machine_mode
name|regno_save_mode
index|[
name|FIRST_PSEUDO_REGISTER
index|]
index|[
name|MAX_MOVE_MAX
operator|/
name|MIN_UNITS_PER_WORD
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For each hard register, a place on the stack where it can be saved,    if needed.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|regno_save_mem
index|[
name|FIRST_PSEUDO_REGISTER
index|]
index|[
name|MAX_MOVE_MAX
operator|/
name|MIN_UNITS_PER_WORD
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We will only make a register eligible for caller-save if it can be    saved in its widest mode with a simple SET insn as long as the memory    address is valid.  We record the INSN_CODE is those insns here since    when we emit them, the addresses might not be valid, so they might not    be recognized.  */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|insn_code
name|reg_save_code
index|[
name|FIRST_PSEUDO_REGISTER
index|]
index|[
name|MAX_MOVE_MAX
operator|/
name|MIN_UNITS_PER_WORD
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|insn_code
name|reg_restore_code
index|[
name|FIRST_PSEUDO_REGISTER
index|]
index|[
name|MAX_MOVE_MAX
operator|/
name|MIN_UNITS_PER_WORD
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set of hard regs currently residing in save area (during insn scan).  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|hard_regs_saved
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of registers currently in hard_regs_saved.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|n_regs_saved
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Computed by mark_referenced_regs, all regs referenced in a given    insn.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|referenced_regs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Computed in mark_set_regs, holds all registers set by the current    instruction.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|this_insn_sets
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_set_regs
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_referenced_regs
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|insert_save
name|PROTO
argument_list|(
operator|(
expr|struct
name|insn_chain
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|HARD_REG_SET
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|insert_restore
name|PROTO
argument_list|(
operator|(
expr|struct
name|insn_chain
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|insert_one_insn
name|PROTO
argument_list|(
operator|(
expr|struct
name|insn_chain
operator|*
operator|,
name|int
operator|,
expr|enum
name|insn_code
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Initialize for caller-save.     Look at all the hard registers that are used by a call and for which    regclass.c has not already excluded from being used across a call.     Ensure that we can find a mode to save the register and that there is a     simple insn to save and restore the register.  This latter check avoids    problems that would occur if we tried to save the MQ register of some    machines directly into memory.  */
end_comment

begin_function
name|void
name|init_caller_save
parameter_list|()
block|{
name|char
modifier|*
name|first_obj
init|=
operator|(
name|char
operator|*
operator|)
name|oballoc
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|addr_reg
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|rtx
name|address
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* First find all the registers that we need to deal with and all      the modes that they can have.  If we can't find a mode to use,      we can't have the register live over calls.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|call_used_regs
index|[
name|i
index|]
operator|&&
operator|!
name|call_fixed_regs
index|[
name|i
index|]
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|MOVE_MAX_WORDS
condition|;
name|j
operator|++
control|)
block|{
name|regno_save_mode
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|HARD_REGNO_CALLER_SAVE_MODE
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno_save_mode
index|[
name|i
index|]
index|[
name|j
index|]
operator|==
name|VOIDmode
operator|&&
name|j
operator|==
literal|1
condition|)
block|{
name|call_fixed_regs
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|call_fixed_reg_set
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
name|regno_save_mode
index|[
name|i
index|]
index|[
literal|1
index|]
operator|=
name|VOIDmode
expr_stmt|;
block|}
comment|/* The following code tries to approximate the conditions under which      we can easily save and restore a register without scratch registers or      other complexities.  It will usually work, except under conditions where      the validity of an insn operand is dependent on the address offset.      No such cases are currently known.       We first find a typical offset from some BASE_REG_CLASS register.      This address is chosen by finding the first register in the class      and by finding the smallest power of two that is a valid offset from      that register in every mode we will use to save registers.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|BASE_REG_CLASS
index|]
argument_list|,
name|i
argument_list|)
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|FIRST_PSEUDO_REGISTER
condition|)
name|abort
argument_list|()
expr_stmt|;
name|addr_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|offset
operator|=
literal|1
operator|<<
operator|(
name|HOST_BITS_PER_INT
operator|/
literal|2
operator|)
init|;
name|offset
condition|;
name|offset
operator|>>=
literal|1
control|)
block|{
name|address
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|addr_reg
argument_list|,
name|GEN_INT
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regno_save_mode
index|[
name|i
index|]
index|[
literal|1
index|]
operator|!=
name|VOIDmode
operator|&&
operator|!
name|strict_memory_address_p
argument_list|(
name|regno_save_mode
index|[
name|i
index|]
index|[
literal|1
index|]
argument_list|,
name|address
argument_list|)
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|FIRST_PSEUDO_REGISTER
condition|)
break|break;
block|}
comment|/* If we didn't find a valid address, we must use register indirect.  */
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
name|address
operator|=
name|addr_reg
expr_stmt|;
comment|/* Next we try to form an insn to save and restore the register.  We      see if such an insn is recognized and meets its constraints.  */
name|start_sequence
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|MOVE_MAX_WORDS
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|regno_save_mode
index|[
name|i
index|]
index|[
name|j
index|]
operator|!=
name|VOIDmode
condition|)
block|{
name|rtx
name|mem
init|=
name|gen_rtx_MEM
argument_list|(
name|regno_save_mode
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|,
name|address
argument_list|)
decl_stmt|;
name|rtx
name|reg
init|=
name|gen_rtx_REG
argument_list|(
name|regno_save_mode
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|rtx
name|savepat
init|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|mem
argument_list|,
name|reg
argument_list|)
decl_stmt|;
name|rtx
name|restpat
init|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|mem
argument_list|)
decl_stmt|;
name|rtx
name|saveinsn
init|=
name|emit_insn
argument_list|(
name|savepat
argument_list|)
decl_stmt|;
name|rtx
name|restinsn
init|=
name|emit_insn
argument_list|(
name|restpat
argument_list|)
decl_stmt|;
name|int
name|ok
decl_stmt|;
name|reg_save_code
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|recog_memoized
argument_list|(
name|saveinsn
argument_list|)
expr_stmt|;
name|reg_restore_code
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|recog_memoized
argument_list|(
name|restinsn
argument_list|)
expr_stmt|;
comment|/* Now extract both insns and see if we can meet their              constraints.  */
name|ok
operator|=
operator|(
name|reg_save_code
index|[
name|i
index|]
index|[
name|j
index|]
operator|!=
operator|(
expr|enum
name|insn_code
operator|)
operator|-
literal|1
operator|&&
name|reg_restore_code
index|[
name|i
index|]
index|[
name|j
index|]
operator|!=
operator|(
expr|enum
name|insn_code
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|ok
condition|)
block|{
name|extract_insn
argument_list|(
name|saveinsn
argument_list|)
expr_stmt|;
name|ok
operator|=
name|constrain_operands
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|extract_insn
argument_list|(
name|restinsn
argument_list|)
expr_stmt|;
name|ok
operator|&=
name|constrain_operands
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|regno_save_mode
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|VOIDmode
expr_stmt|;
if|if
condition|(
name|j
operator|==
literal|1
condition|)
block|{
name|call_fixed_regs
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|call_fixed_reg_set
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|end_sequence
argument_list|()
expr_stmt|;
name|obfree
argument_list|(
name|first_obj
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Initialize save areas by showing that we haven't allocated any yet.  */
end_comment

begin_function
name|void
name|init_save_areas
parameter_list|()
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|MOVE_MAX_WORDS
condition|;
name|j
operator|++
control|)
name|regno_save_mem
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Allocate save areas for any hard registers that might need saving.    We take a conservative approach here and look for call-clobbered hard    registers that are assigned to pseudos that cross calls.  This may    overestimate slightly (especially if some of these registers are later    used as spill registers), but it should not be significant.     Future work:       In the fallback case we should iterate backwards across all possible      modes for the save, choosing the largest available one instead of       falling back to the smallest mode immediately.  (eg TF -> DF -> SF).       We do not try to use "move multiple" instructions that exist      on some machines (such as the 68k moveml).  It could be a win to try       and use them when possible.  The hard part is doing it in a way that is      machine independent since they might be saving non-consecutive       registers. (imagine caller-saving d0,d1,a0,a1 on the 68k) */
end_comment

begin_function
name|void
name|setup_save_areas
parameter_list|()
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|HARD_REG_SET
name|hard_regs_used
decl_stmt|;
comment|/* Allocate space in the save area for the largest multi-register      pseudos first, then work backwards to single register      pseudos.  */
comment|/* Find and record all call-used hard-registers in this function.  */
name|CLEAR_HARD_REG_SET
argument_list|(
name|hard_regs_used
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
name|max_regno
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|reg_renumber
index|[
name|i
index|]
operator|>=
literal|0
operator|&&
name|REG_N_CALLS_CROSSED
argument_list|(
name|i
argument_list|)
operator|>
literal|0
condition|)
block|{
name|int
name|regno
init|=
name|reg_renumber
index|[
name|i
index|]
decl_stmt|;
name|int
name|endregno
init|=
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|regno_reg_rtx
index|[
name|i
index|]
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|nregs
init|=
name|endregno
operator|-
name|regno
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nregs
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|call_used_regs
index|[
name|regno
operator|+
name|j
index|]
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|hard_regs_used
argument_list|,
name|regno
operator|+
name|j
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now run through all the call-used hard-registers and allocate      space for them in the caller-save area.  Try to allocate space      in a manner which allows multi-register saves/restores to be done.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
name|MOVE_MAX_WORDS
init|;
name|j
operator|>
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|int
name|do_save
init|=
literal|1
decl_stmt|;
comment|/* If no mode exists for this size, try another.  Also break out 	   if we have already saved this hard register.  */
if|if
condition|(
name|regno_save_mode
index|[
name|i
index|]
index|[
name|j
index|]
operator|==
name|VOIDmode
operator|||
name|regno_save_mem
index|[
name|i
index|]
index|[
literal|1
index|]
operator|!=
literal|0
condition|)
continue|continue;
comment|/* See if any register in this group has been saved.  */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|j
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|regno_save_mem
index|[
name|i
operator|+
name|k
index|]
index|[
literal|1
index|]
condition|)
block|{
name|do_save
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|do_save
condition|)
continue|continue;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|j
condition|;
name|k
operator|++
control|)
if|if
condition|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|hard_regs_used
argument_list|,
name|i
operator|+
name|k
argument_list|)
condition|)
block|{
name|do_save
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|do_save
condition|)
continue|continue;
comment|/* We have found an acceptable mode to store in.  */
name|regno_save_mem
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|assign_stack_local
argument_list|(
name|regno_save_mode
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|regno_save_mode
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Setup single word save area just in case...  */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|j
condition|;
name|k
operator|++
control|)
block|{
comment|/* This should not depend on WORDS_BIG_ENDIAN. 	       The order of words in regs is the same as in memory.  */
name|rtx
name|temp
init|=
name|gen_rtx_MEM
argument_list|(
name|regno_save_mode
index|[
name|i
operator|+
name|k
index|]
index|[
literal|1
index|]
argument_list|,
name|XEXP
argument_list|(
name|regno_save_mem
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|regno_save_mem
index|[
name|i
operator|+
name|k
index|]
index|[
literal|1
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|temp
argument_list|,
name|k
operator|*
name|UNITS_PER_WORD
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find the places where hard regs are live across calls and save them.  */
end_comment

begin_function
name|void
name|save_call_clobbered_regs
parameter_list|()
block|{
name|struct
name|insn_chain
modifier|*
name|chain
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|hard_regs_saved
argument_list|)
expr_stmt|;
name|n_regs_saved
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|chain
operator|=
name|reload_insn_chain
init|;
name|chain
operator|!=
literal|0
condition|;
name|chain
operator|=
name|next
control|)
block|{
name|rtx
name|insn
init|=
name|chain
operator|->
name|insn
decl_stmt|;
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|next
operator|=
name|chain
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|chain
operator|->
name|is_caller_save_insn
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'i'
condition|)
block|{
comment|/* If some registers have been saved, see if INSN references 	     any of them.  We must restore them before the insn if so.  */
if|if
condition|(
name|n_regs_saved
condition|)
block|{
name|int
name|regno
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|JUMP_INSN
condition|)
comment|/* Restore all registers if this is a JUMP_INSN.  */
name|COPY_HARD_REG_SET
argument_list|(
name|referenced_regs
argument_list|,
name|hard_regs_saved
argument_list|)
expr_stmt|;
else|else
block|{
name|CLEAR_HARD_REG_SET
argument_list|(
name|referenced_regs
argument_list|)
expr_stmt|;
name|mark_referenced_regs
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|AND_HARD_REG_SET
argument_list|(
name|referenced_regs
argument_list|,
name|hard_regs_saved
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|referenced_regs
argument_list|,
name|regno
argument_list|)
condition|)
name|regno
operator|+=
name|insert_restore
argument_list|(
name|chain
argument_list|,
literal|1
argument_list|,
name|regno
argument_list|,
name|MOVE_MAX_WORDS
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|==
name|CALL_INSN
condition|)
block|{
name|rtx
name|x
decl_stmt|;
name|int
name|regno
decl_stmt|,
name|nregs
decl_stmt|;
name|HARD_REG_SET
name|hard_regs_to_save
decl_stmt|;
comment|/* Use the register life information in CHAIN to compute which 		 regs are live before the call.  */
name|REG_SET_TO_HARD_REG_SET
argument_list|(
name|hard_regs_to_save
argument_list|,
name|chain
operator|->
name|live_before
argument_list|)
expr_stmt|;
name|compute_use_by_pseudos
argument_list|(
operator|&
name|hard_regs_to_save
argument_list|,
name|chain
operator|->
name|live_before
argument_list|)
expr_stmt|;
comment|/* Record all registers set in this call insn.  These don't need 		 to be saved.  */
name|CLEAR_HARD_REG_SET
argument_list|(
name|this_insn_sets
argument_list|)
expr_stmt|;
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|mark_set_regs
argument_list|)
expr_stmt|;
comment|/* Compute which hard regs must be saved before this call.  */
name|AND_COMPL_HARD_REG_SET
argument_list|(
name|hard_regs_to_save
argument_list|,
name|call_fixed_reg_set
argument_list|)
expr_stmt|;
name|AND_COMPL_HARD_REG_SET
argument_list|(
name|hard_regs_to_save
argument_list|,
name|this_insn_sets
argument_list|)
expr_stmt|;
name|AND_COMPL_HARD_REG_SET
argument_list|(
name|hard_regs_to_save
argument_list|,
name|hard_regs_saved
argument_list|)
expr_stmt|;
name|AND_HARD_REG_SET
argument_list|(
name|hard_regs_to_save
argument_list|,
name|call_used_reg_set
argument_list|)
expr_stmt|;
comment|/* Registers used for function parameters need not be saved.  */
for|for
control|(
name|x
operator|=
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
init|;
name|x
operator|!=
literal|0
condition|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|rtx
name|y
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|USE
condition|)
continue|continue;
name|y
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|!=
name|REG
condition|)
name|abort
argument_list|()
expr_stmt|;
name|regno
operator|=
name|REGNO
argument_list|(
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|REGNO
argument_list|(
name|y
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|abort
argument_list|()
expr_stmt|;
name|nregs
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|y
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|nregs
operator|--
operator|>
literal|0
condition|)
name|CLEAR_HARD_REG_BIT
argument_list|(
name|hard_regs_to_save
argument_list|,
name|regno
operator|+
name|nregs
argument_list|)
expr_stmt|;
block|}
comment|/* Neither do registers for which we find a death note.  */
for|for
control|(
name|x
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|x
operator|!=
literal|0
condition|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|rtx
name|y
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|x
argument_list|)
operator|!=
name|REG_DEAD
condition|)
continue|continue;
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|!=
name|REG
condition|)
name|abort
argument_list|()
expr_stmt|;
name|regno
operator|=
name|REGNO
argument_list|(
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|regno
operator|=
name|reg_renumber
index|[
name|regno
index|]
expr_stmt|;
if|if
condition|(
name|regno
operator|<
literal|0
condition|)
continue|continue;
name|nregs
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|y
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|nregs
operator|--
operator|>
literal|0
condition|)
name|CLEAR_HARD_REG_BIT
argument_list|(
name|hard_regs_to_save
argument_list|,
name|regno
operator|+
name|nregs
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|hard_regs_to_save
argument_list|,
name|regno
argument_list|)
condition|)
name|regno
operator|+=
name|insert_save
argument_list|(
name|chain
argument_list|,
literal|1
argument_list|,
name|regno
argument_list|,
operator|&
name|hard_regs_to_save
argument_list|)
expr_stmt|;
comment|/* Must recompute n_regs_saved.  */
name|n_regs_saved
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|hard_regs_saved
argument_list|,
name|regno
argument_list|)
condition|)
name|n_regs_saved
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|chain
operator|->
name|next
operator|==
literal|0
operator|||
name|chain
operator|->
name|next
operator|->
name|block
operator|>
name|chain
operator|->
name|block
condition|)
block|{
name|int
name|regno
decl_stmt|;
comment|/* At the end of the basic block, we must restore any registers that 	     remain saved.  If the last insn in the block is a JUMP_INSN, put 	     the restore before the insn, otherwise, put it after the insn.  */
if|if
condition|(
name|n_regs_saved
condition|)
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|hard_regs_saved
argument_list|,
name|regno
argument_list|)
condition|)
name|regno
operator|+=
name|insert_restore
argument_list|(
name|chain
argument_list|,
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
argument_list|,
name|regno
argument_list|,
name|MOVE_MAX_WORDS
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Here from note_stores when an insn stores a value in a register.    Set the proper bit or bits in this_insn_sets.  All pseudos that have    been assigned hard regs have had their register number changed already,    so we can ignore pseudos.  */
end_comment

begin_function
specifier|static
name|void
name|mark_set_regs
parameter_list|(
name|reg
parameter_list|,
name|setter
parameter_list|)
name|rtx
name|reg
decl_stmt|;
name|rtx
name|setter
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
specifier|register
name|int
name|regno
decl_stmt|,
name|endregno
decl_stmt|,
name|i
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|reg
argument_list|)
decl_stmt|;
name|int
name|word
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|word
operator|=
name|SUBREG_WORD
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
return|return;
name|regno
operator|=
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|+
name|word
expr_stmt|;
name|endregno
operator|=
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|regno
init|;
name|i
operator|<
name|endregno
condition|;
name|i
operator|++
control|)
name|SET_HARD_REG_BIT
argument_list|(
name|this_insn_sets
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Walk X and record all referenced registers in REFERENCED_REGS.  */
end_comment

begin_function
specifier|static
name|void
name|mark_referenced_regs
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|SET
condition|)
name|mark_referenced_regs
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|SET
operator|||
name|code
operator|==
name|CLOBBER
condition|)
block|{
name|x
operator|=
name|SET_DEST
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|REG
operator|||
name|code
operator|==
name|PC
operator|||
name|code
operator|==
name|CC0
operator|||
operator|(
name|code
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
operator|)
condition|)
return|return;
block|}
if|if
condition|(
name|code
operator|==
name|MEM
operator|||
name|code
operator|==
name|SUBREG
condition|)
block|{
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|==
name|REG
condition|)
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|int
name|hardregno
init|=
operator|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|?
name|regno
else|:
name|reg_renumber
index|[
name|regno
index|]
operator|)
decl_stmt|;
if|if
condition|(
name|hardregno
operator|>=
literal|0
condition|)
block|{
name|int
name|nregs
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|hardregno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
name|nregs
operator|--
operator|>
literal|0
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|referenced_regs
argument_list|,
name|hardregno
operator|+
name|nregs
argument_list|)
expr_stmt|;
block|}
comment|/* If this is a pseudo that did not get a hard register, scan its 	 memory location, since it might involve the use of another 	 register, which might be saved.  */
elseif|else
if|if
condition|(
name|reg_equiv_mem
index|[
name|regno
index|]
operator|!=
literal|0
condition|)
name|mark_referenced_regs
argument_list|(
name|XEXP
argument_list|(
name|reg_equiv_mem
index|[
name|regno
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|reg_equiv_address
index|[
name|regno
index|]
operator|!=
literal|0
condition|)
name|mark_referenced_regs
argument_list|(
name|reg_equiv_address
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|mark_referenced_regs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|mark_referenced_regs
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Insert a sequence of insns to restore.  Place these insns in front of    CHAIN if BEFORE_P is nonzero, behind the insn otherwise.  MAXRESTORE is    the maximum number of registers which should be restored during this call.    It should never be less than 1 since we only work with entire registers.     Note that we have verified in init_caller_save that we can do this    with a simple SET, so use it.  Set INSN_CODE to what we save there    since the address might not be valid so the insn might not be recognized.    These insns will be reloaded and have register elimination done by    find_reload, so we need not worry about that here.     Return the extra number of registers saved.  */
end_comment

begin_function
specifier|static
name|int
name|insert_restore
parameter_list|(
name|chain
parameter_list|,
name|before_p
parameter_list|,
name|regno
parameter_list|,
name|maxrestore
parameter_list|)
name|struct
name|insn_chain
modifier|*
name|chain
decl_stmt|;
name|int
name|before_p
decl_stmt|;
name|int
name|regno
decl_stmt|;
name|int
name|maxrestore
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|rtx
name|pat
init|=
name|NULL_RTX
decl_stmt|;
name|enum
name|insn_code
name|code
init|=
name|CODE_FOR_nothing
decl_stmt|;
name|int
name|numregs
init|=
literal|0
decl_stmt|;
comment|/* A common failure mode if register status is not correct in the RTL      is for this routine to be called with a REGNO we didn't expect to      save.  That will cause us to write an insn with a (nil) SET_DEST      or SET_SRC.  Instead of doing so and causing a crash later, check      for this common case and abort here instead.  This will remove one      step in debugging such problems.  */
if|if
condition|(
name|regno_save_mem
index|[
name|regno
index|]
index|[
literal|1
index|]
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Get the pattern to emit and update our status.       See if we can restore `maxrestore' registers at once.  Work      backwards to the single register case.  */
for|for
control|(
name|i
operator|=
name|maxrestore
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|int
name|j
decl_stmt|,
name|k
decl_stmt|;
name|int
name|ok
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|regno_save_mem
index|[
name|regno
index|]
index|[
name|i
index|]
operator|==
literal|0
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|hard_regs_saved
argument_list|,
name|regno
operator|+
name|j
argument_list|)
condition|)
block|{
name|ok
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* Must do this one restore at a time */
if|if
condition|(
operator|!
name|ok
condition|)
continue|continue;
name|pat
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|GET_MODE
argument_list|(
name|regno_save_mem
index|[
name|regno
index|]
index|[
name|i
index|]
argument_list|)
argument_list|,
name|regno
argument_list|)
argument_list|,
name|regno_save_mem
index|[
name|regno
index|]
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|code
operator|=
name|reg_restore_code
index|[
name|regno
index|]
index|[
name|i
index|]
expr_stmt|;
comment|/* Clear status for all registers we restored.  */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|i
condition|;
name|k
operator|++
control|)
block|{
name|CLEAR_HARD_REG_BIT
argument_list|(
name|hard_regs_saved
argument_list|,
name|regno
operator|+
name|k
argument_list|)
expr_stmt|;
name|n_regs_saved
operator|--
expr_stmt|;
block|}
name|numregs
operator|=
name|i
expr_stmt|;
break|break;
block|}
name|insert_one_insn
argument_list|(
name|chain
argument_list|,
name|before_p
argument_list|,
name|code
argument_list|,
name|pat
argument_list|)
expr_stmt|;
comment|/* Tell our callers how many extra registers we saved/restored */
return|return
name|numregs
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Like insert_restore above, but save registers instead.  */
end_comment

begin_function
specifier|static
name|int
name|insert_save
parameter_list|(
name|chain
parameter_list|,
name|before_p
parameter_list|,
name|regno
parameter_list|,
name|to_save
parameter_list|)
name|struct
name|insn_chain
modifier|*
name|chain
decl_stmt|;
name|int
name|before_p
decl_stmt|;
name|int
name|regno
decl_stmt|;
name|HARD_REG_SET
modifier|*
name|to_save
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|rtx
name|pat
init|=
name|NULL_RTX
decl_stmt|;
name|enum
name|insn_code
name|code
init|=
name|CODE_FOR_nothing
decl_stmt|;
name|int
name|numregs
init|=
literal|0
decl_stmt|;
comment|/* A common failure mode if register status is not correct in the RTL      is for this routine to be called with a REGNO we didn't expect to      save.  That will cause us to write an insn with a (nil) SET_DEST      or SET_SRC.  Instead of doing so and causing a crash later, check      for this common case and abort here instead.  This will remove one      step in debugging such problems.  */
if|if
condition|(
name|regno_save_mem
index|[
name|regno
index|]
index|[
literal|1
index|]
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Get the pattern to emit and update our status.       See if we can save several registers with a single instruction.        Work backwards to the single register case.  */
for|for
control|(
name|i
operator|=
name|MOVE_MAX_WORDS
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|int
name|j
decl_stmt|,
name|k
decl_stmt|;
name|int
name|ok
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|regno_save_mem
index|[
name|regno
index|]
index|[
name|i
index|]
operator|==
literal|0
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
operator|*
name|to_save
argument_list|,
name|regno
operator|+
name|j
argument_list|)
condition|)
block|{
name|ok
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* Must do this one save at a time */
if|if
condition|(
operator|!
name|ok
condition|)
continue|continue;
name|pat
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|regno_save_mem
index|[
name|regno
index|]
index|[
name|i
index|]
argument_list|,
name|gen_rtx_REG
argument_list|(
name|GET_MODE
argument_list|(
name|regno_save_mem
index|[
name|regno
index|]
index|[
name|i
index|]
argument_list|)
argument_list|,
name|regno
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|=
name|reg_save_code
index|[
name|regno
index|]
index|[
name|i
index|]
expr_stmt|;
comment|/* Set hard_regs_saved for all the registers we saved.  */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|i
condition|;
name|k
operator|++
control|)
block|{
name|SET_HARD_REG_BIT
argument_list|(
name|hard_regs_saved
argument_list|,
name|regno
operator|+
name|k
argument_list|)
expr_stmt|;
name|n_regs_saved
operator|++
expr_stmt|;
block|}
name|numregs
operator|=
name|i
expr_stmt|;
break|break;
block|}
name|insert_one_insn
argument_list|(
name|chain
argument_list|,
name|before_p
argument_list|,
name|code
argument_list|,
name|pat
argument_list|)
expr_stmt|;
comment|/* Tell our callers how many extra registers we saved/restored */
return|return
name|numregs
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Emit a new caller-save insn and set the code.  */
end_comment

begin_function
specifier|static
name|void
name|insert_one_insn
parameter_list|(
name|chain
parameter_list|,
name|before_p
parameter_list|,
name|code
parameter_list|,
name|pat
parameter_list|)
name|struct
name|insn_chain
modifier|*
name|chain
decl_stmt|;
name|int
name|before_p
decl_stmt|;
name|enum
name|insn_code
name|code
decl_stmt|;
name|rtx
name|pat
decl_stmt|;
block|{
name|rtx
name|insn
init|=
name|chain
operator|->
name|insn
decl_stmt|;
name|struct
name|insn_chain
modifier|*
name|new
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* If INSN references CC0, put our insns in front of the insn that sets      CC0.  This is always safe, since the only way we could be passed an      insn that references CC0 is for a restore, and doing a restore earlier      isn't a problem.  We do, however, assume here that CALL_INSNs don't      reference CC0.  Guard against non-INSN's like CODE_LABEL.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|)
operator|&&
name|before_p
operator|&&
name|reg_referenced_p
argument_list|(
name|cc0_rtx
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
name|chain
operator|=
name|chain
operator|->
name|prev
operator|,
name|insn
operator|=
name|chain
operator|->
name|insn
expr_stmt|;
endif|#
directive|endif
name|new
operator|=
name|new_insn_chain
argument_list|()
expr_stmt|;
if|if
condition|(
name|before_p
condition|)
block|{
name|new
operator|->
name|prev
operator|=
name|chain
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|new
operator|->
name|prev
operator|!=
literal|0
condition|)
name|new
operator|->
name|prev
operator|->
name|next
operator|=
name|new
expr_stmt|;
else|else
name|reload_insn_chain
operator|=
name|new
expr_stmt|;
name|chain
operator|->
name|prev
operator|=
name|new
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|chain
expr_stmt|;
name|new
operator|->
name|insn
operator|=
name|emit_insn_before
argument_list|(
name|pat
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* ??? It would be nice if we could exclude the already / still saved 	 registers from the live sets.  */
name|COPY_REG_SET
argument_list|(
name|new
operator|->
name|live_before
argument_list|,
name|chain
operator|->
name|live_before
argument_list|)
expr_stmt|;
name|COPY_REG_SET
argument_list|(
name|new
operator|->
name|live_after
argument_list|,
name|chain
operator|->
name|live_before
argument_list|)
expr_stmt|;
if|if
condition|(
name|chain
operator|->
name|insn
operator|==
name|BLOCK_HEAD
argument_list|(
name|chain
operator|->
name|block
argument_list|)
condition|)
name|BLOCK_HEAD
argument_list|(
name|chain
operator|->
name|block
argument_list|)
operator|=
name|new
operator|->
name|insn
expr_stmt|;
block|}
else|else
block|{
name|new
operator|->
name|next
operator|=
name|chain
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|new
operator|->
name|next
operator|!=
literal|0
condition|)
name|new
operator|->
name|next
operator|->
name|prev
operator|=
name|new
expr_stmt|;
name|chain
operator|->
name|next
operator|=
name|new
expr_stmt|;
name|new
operator|->
name|prev
operator|=
name|chain
expr_stmt|;
name|new
operator|->
name|insn
operator|=
name|emit_insn_after
argument_list|(
name|pat
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* ??? It would be nice if we could exclude the already / still saved 	 registers from the live sets, and observe REG_UNUSED notes.  */
name|COPY_REG_SET
argument_list|(
name|new
operator|->
name|live_before
argument_list|,
name|chain
operator|->
name|live_after
argument_list|)
expr_stmt|;
name|COPY_REG_SET
argument_list|(
name|new
operator|->
name|live_after
argument_list|,
name|chain
operator|->
name|live_after
argument_list|)
expr_stmt|;
if|if
condition|(
name|chain
operator|->
name|insn
operator|==
name|BLOCK_END
argument_list|(
name|chain
operator|->
name|block
argument_list|)
condition|)
name|BLOCK_END
argument_list|(
name|chain
operator|->
name|block
argument_list|)
operator|=
name|new
operator|->
name|insn
expr_stmt|;
block|}
name|new
operator|->
name|block
operator|=
name|chain
operator|->
name|block
expr_stmt|;
name|new
operator|->
name|is_caller_save_insn
operator|=
literal|1
expr_stmt|;
name|INSN_CODE
argument_list|(
name|new
operator|->
name|insn
argument_list|)
operator|=
name|code
expr_stmt|;
block|}
end_function

end_unit

