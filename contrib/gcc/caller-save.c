begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Save and restore call-clobbered registers which are live across a call.    Copyright (C) 1989, 1992, 1994, 1995, 1997, 1998,    1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"reload.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|MAX_MOVE_MAX
end_ifndef

begin_define
define|#
directive|define
name|MAX_MOVE_MAX
value|MOVE_MAX
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MIN_UNITS_PER_WORD
end_ifndef

begin_define
define|#
directive|define
name|MIN_UNITS_PER_WORD
value|UNITS_PER_WORD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|MOVE_MAX_WORDS
value|(MOVE_MAX / UNITS_PER_WORD)
end_define

begin_comment
comment|/* Modes for each hard register that we can save.  The smallest mode is wide    enough to save the entire contents of the register.  When saving the    register because it is live we first try to save in multi-register modes.    If that is not possible the save is done one register at a time.  */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|machine_mode
name|regno_save_mode
index|[
name|FIRST_PSEUDO_REGISTER
index|]
index|[
name|MAX_MOVE_MAX
operator|/
name|MIN_UNITS_PER_WORD
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For each hard register, a place on the stack where it can be saved,    if needed.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|regno_save_mem
index|[
name|FIRST_PSEUDO_REGISTER
index|]
index|[
name|MAX_MOVE_MAX
operator|/
name|MIN_UNITS_PER_WORD
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We will only make a register eligible for caller-save if it can be    saved in its widest mode with a simple SET insn as long as the memory    address is valid.  We record the INSN_CODE is those insns here since    when we emit them, the addresses might not be valid, so they might not    be recognized.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|reg_save_code
index|[
name|FIRST_PSEUDO_REGISTER
index|]
index|[
name|MAX_MACHINE_MODE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reg_restore_code
index|[
name|FIRST_PSEUDO_REGISTER
index|]
index|[
name|MAX_MACHINE_MODE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set of hard regs currently residing in save area (during insn scan).  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|hard_regs_saved
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of registers currently in hard_regs_saved.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|n_regs_saved
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Computed by mark_referenced_regs, all regs referenced in a given    insn.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|referenced_regs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Computed in mark_set_regs, holds all registers set by the current    instruction.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|this_insn_sets
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|mark_set_regs
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mark_referenced_regs
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|insert_save
parameter_list|(
name|struct
name|insn_chain
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|HARD_REG_SET
modifier|*
parameter_list|,
name|enum
name|machine_mode
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|insert_restore
parameter_list|(
name|struct
name|insn_chain
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|enum
name|machine_mode
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|insn_chain
modifier|*
name|insert_one_insn
parameter_list|(
name|struct
name|insn_chain
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_stored_regs
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Initialize for caller-save.     Look at all the hard registers that are used by a call and for which    regclass.c has not already excluded from being used across a call.     Ensure that we can find a mode to save the register and that there is a    simple insn to save and restore the register.  This latter check avoids    problems that would occur if we tried to save the MQ register of some    machines directly into memory.  */
end_comment

begin_function
name|void
name|init_caller_save
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|addr_reg
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|rtx
name|address
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|savepat
decl_stmt|,
name|restpat
decl_stmt|;
name|rtx
name|test_reg
decl_stmt|,
name|test_mem
decl_stmt|;
name|rtx
name|saveinsn
decl_stmt|,
name|restinsn
decl_stmt|;
comment|/* First find all the registers that we need to deal with and all      the modes that they can have.  If we can't find a mode to use,      we can't have the register live over calls.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|call_used_regs
index|[
name|i
index|]
operator|&&
operator|!
name|call_fixed_regs
index|[
name|i
index|]
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|MOVE_MAX_WORDS
condition|;
name|j
operator|++
control|)
block|{
name|regno_save_mode
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|HARD_REGNO_CALLER_SAVE_MODE
argument_list|(
name|i
argument_list|,
name|j
argument_list|,
name|VOIDmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno_save_mode
index|[
name|i
index|]
index|[
name|j
index|]
operator|==
name|VOIDmode
operator|&&
name|j
operator|==
literal|1
condition|)
block|{
name|call_fixed_regs
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|call_fixed_reg_set
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
name|regno_save_mode
index|[
name|i
index|]
index|[
literal|1
index|]
operator|=
name|VOIDmode
expr_stmt|;
block|}
comment|/* The following code tries to approximate the conditions under which      we can easily save and restore a register without scratch registers or      other complexities.  It will usually work, except under conditions where      the validity of an insn operand is dependent on the address offset.      No such cases are currently known.       We first find a typical offset from some BASE_REG_CLASS register.      This address is chosen by finding the first register in the class      and by finding the smallest power of two that is a valid offset from      that register in every mode we will use to save registers.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|MODE_BASE_REG_CLASS
argument_list|(
name|regno_save_mode
index|[
name|i
index|]
index|[
literal|1
index|]
argument_list|)
index|]
argument_list|,
name|i
argument_list|)
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|FIRST_PSEUDO_REGISTER
condition|)
name|abort
argument_list|()
expr_stmt|;
name|addr_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|offset
operator|=
literal|1
operator|<<
operator|(
name|HOST_BITS_PER_INT
operator|/
literal|2
operator|)
init|;
name|offset
condition|;
name|offset
operator|>>=
literal|1
control|)
block|{
name|address
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|addr_reg
argument_list|,
name|GEN_INT
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regno_save_mode
index|[
name|i
index|]
index|[
literal|1
index|]
operator|!=
name|VOIDmode
operator|&&
operator|!
name|strict_memory_address_p
argument_list|(
name|regno_save_mode
index|[
name|i
index|]
index|[
literal|1
index|]
argument_list|,
name|address
argument_list|)
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|FIRST_PSEUDO_REGISTER
condition|)
break|break;
block|}
comment|/* If we didn't find a valid address, we must use register indirect.  */
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
name|address
operator|=
name|addr_reg
expr_stmt|;
comment|/* Next we try to form an insn to save and restore the register.  We      see if such an insn is recognized and meets its constraints.       To avoid lots of unnecessary RTL allocation, we construct all the RTL      once, then modify the memory and register operands in-place.  */
name|test_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|test_mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|VOIDmode
argument_list|,
name|address
argument_list|)
expr_stmt|;
name|savepat
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|test_mem
argument_list|,
name|test_reg
argument_list|)
expr_stmt|;
name|restpat
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|test_reg
argument_list|,
name|test_mem
argument_list|)
expr_stmt|;
name|saveinsn
operator|=
name|gen_rtx_INSN
argument_list|(
name|VOIDmode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|savepat
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|restinsn
operator|=
name|gen_rtx_INSN
argument_list|(
name|VOIDmode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|restpat
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
for|for
control|(
name|mode
operator|=
literal|0
init|;
name|mode
operator|<
name|MAX_MACHINE_MODE
condition|;
name|mode
operator|++
control|)
if|if
condition|(
name|HARD_REGNO_MODE_OK
argument_list|(
name|i
argument_list|,
name|mode
argument_list|)
condition|)
block|{
name|int
name|ok
decl_stmt|;
comment|/* Update the register number and modes of the register 	     and memory operand.  */
name|REGNO
argument_list|(
name|test_reg
argument_list|)
operator|=
name|i
expr_stmt|;
name|PUT_MODE
argument_list|(
name|test_reg
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|test_mem
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/* Force re-recognition of the modified insns.  */
name|INSN_CODE
argument_list|(
name|saveinsn
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
name|INSN_CODE
argument_list|(
name|restinsn
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
name|reg_save_code
index|[
name|i
index|]
index|[
name|mode
index|]
operator|=
name|recog_memoized
argument_list|(
name|saveinsn
argument_list|)
expr_stmt|;
name|reg_restore_code
index|[
name|i
index|]
index|[
name|mode
index|]
operator|=
name|recog_memoized
argument_list|(
name|restinsn
argument_list|)
expr_stmt|;
comment|/* Now extract both insns and see if we can meet their              constraints.  */
name|ok
operator|=
operator|(
name|reg_save_code
index|[
name|i
index|]
index|[
name|mode
index|]
operator|!=
operator|-
literal|1
operator|&&
name|reg_restore_code
index|[
name|i
index|]
index|[
name|mode
index|]
operator|!=
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|ok
condition|)
block|{
name|extract_insn
argument_list|(
name|saveinsn
argument_list|)
expr_stmt|;
name|ok
operator|=
name|constrain_operands
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|extract_insn
argument_list|(
name|restinsn
argument_list|)
expr_stmt|;
name|ok
operator|&=
name|constrain_operands
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|reg_save_code
index|[
name|i
index|]
index|[
name|mode
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|reg_restore_code
index|[
name|i
index|]
index|[
name|mode
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|reg_save_code
index|[
name|i
index|]
index|[
name|mode
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|reg_restore_code
index|[
name|i
index|]
index|[
name|mode
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|MOVE_MAX_WORDS
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|reg_save_code
index|[
name|i
index|]
index|[
name|regno_save_mode
index|[
name|i
index|]
index|[
name|j
index|]
index|]
operator|==
operator|-
literal|1
condition|)
block|{
name|regno_save_mode
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|VOIDmode
expr_stmt|;
if|if
condition|(
name|j
operator|==
literal|1
condition|)
block|{
name|call_fixed_regs
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|call_fixed_reg_set
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Initialize save areas by showing that we haven't allocated any yet.  */
end_comment

begin_function
name|void
name|init_save_areas
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|MOVE_MAX_WORDS
condition|;
name|j
operator|++
control|)
name|regno_save_mem
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Allocate save areas for any hard registers that might need saving.    We take a conservative approach here and look for call-clobbered hard    registers that are assigned to pseudos that cross calls.  This may    overestimate slightly (especially if some of these registers are later    used as spill registers), but it should not be significant.     Future work:       In the fallback case we should iterate backwards across all possible      modes for the save, choosing the largest available one instead of      falling back to the smallest mode immediately.  (eg TF -> DF -> SF).       We do not try to use "move multiple" instructions that exist      on some machines (such as the 68k moveml).  It could be a win to try      and use them when possible.  The hard part is doing it in a way that is      machine independent since they might be saving non-consecutive      registers. (imagine caller-saving d0,d1,a0,a1 on the 68k) */
end_comment

begin_function
name|void
name|setup_save_areas
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|unsigned
name|int
name|r
decl_stmt|;
name|HARD_REG_SET
name|hard_regs_used
decl_stmt|;
comment|/* Allocate space in the save area for the largest multi-register      pseudos first, then work backwards to single register      pseudos.  */
comment|/* Find and record all call-used hard-registers in this function.  */
name|CLEAR_HARD_REG_SET
argument_list|(
name|hard_regs_used
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
name|max_regno
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|reg_renumber
index|[
name|i
index|]
operator|>=
literal|0
operator|&&
name|REG_N_CALLS_CROSSED
argument_list|(
name|i
argument_list|)
operator|>
literal|0
condition|)
block|{
name|unsigned
name|int
name|regno
init|=
name|reg_renumber
index|[
name|i
index|]
decl_stmt|;
name|unsigned
name|int
name|endregno
init|=
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|regno_reg_rtx
index|[
name|i
index|]
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|r
operator|=
name|regno
init|;
name|r
operator|<
name|endregno
condition|;
name|r
operator|++
control|)
if|if
condition|(
name|call_used_regs
index|[
name|r
index|]
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|hard_regs_used
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
comment|/* Now run through all the call-used hard-registers and allocate      space for them in the caller-save area.  Try to allocate space      in a manner which allows multi-register saves/restores to be done.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
name|MOVE_MAX_WORDS
init|;
name|j
operator|>
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|int
name|do_save
init|=
literal|1
decl_stmt|;
comment|/* If no mode exists for this size, try another.  Also break out 	   if we have already saved this hard register.  */
if|if
condition|(
name|regno_save_mode
index|[
name|i
index|]
index|[
name|j
index|]
operator|==
name|VOIDmode
operator|||
name|regno_save_mem
index|[
name|i
index|]
index|[
literal|1
index|]
operator|!=
literal|0
condition|)
continue|continue;
comment|/* See if any register in this group has been saved.  */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|j
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|regno_save_mem
index|[
name|i
operator|+
name|k
index|]
index|[
literal|1
index|]
condition|)
block|{
name|do_save
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|do_save
condition|)
continue|continue;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|j
condition|;
name|k
operator|++
control|)
if|if
condition|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|hard_regs_used
argument_list|,
name|i
operator|+
name|k
argument_list|)
condition|)
block|{
name|do_save
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|do_save
condition|)
continue|continue;
comment|/* We have found an acceptable mode to store in.  */
name|regno_save_mem
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|assign_stack_local
argument_list|(
name|regno_save_mode
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|regno_save_mode
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Setup single word save area just in case...  */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|j
condition|;
name|k
operator|++
control|)
comment|/* This should not depend on WORDS_BIG_ENDIAN. 	     The order of words in regs is the same as in memory.  */
name|regno_save_mem
index|[
name|i
operator|+
name|k
index|]
index|[
literal|1
index|]
operator|=
name|adjust_address_nv
argument_list|(
name|regno_save_mem
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|,
name|regno_save_mode
index|[
name|i
operator|+
name|k
index|]
index|[
literal|1
index|]
argument_list|,
name|k
operator|*
name|UNITS_PER_WORD
argument_list|)
expr_stmt|;
block|}
comment|/* Now loop again and set the alias set of any save areas we made to      the alias set used to represent frame objects.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
name|MOVE_MAX_WORDS
init|;
name|j
operator|>
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|regno_save_mem
index|[
name|i
index|]
index|[
name|j
index|]
operator|!=
literal|0
condition|)
name|set_mem_alias_set
argument_list|(
name|regno_save_mem
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|,
name|get_frame_alias_set
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find the places where hard regs are live across calls and save them.  */
end_comment

begin_function
name|void
name|save_call_clobbered_regs
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|insn_chain
modifier|*
name|chain
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|enum
name|machine_mode
name|save_mode
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|hard_regs_saved
argument_list|)
expr_stmt|;
name|n_regs_saved
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|chain
operator|=
name|reload_insn_chain
init|;
name|chain
operator|!=
literal|0
condition|;
name|chain
operator|=
name|next
control|)
block|{
name|rtx
name|insn
init|=
name|chain
operator|->
name|insn
decl_stmt|;
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|next
operator|=
name|chain
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|chain
operator|->
name|is_caller_save_insn
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'i'
condition|)
block|{
comment|/* If some registers have been saved, see if INSN references 	     any of them.  We must restore them before the insn if so.  */
if|if
condition|(
name|n_regs_saved
condition|)
block|{
name|int
name|regno
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|JUMP_INSN
condition|)
comment|/* Restore all registers if this is a JUMP_INSN.  */
name|COPY_HARD_REG_SET
argument_list|(
name|referenced_regs
argument_list|,
name|hard_regs_saved
argument_list|)
expr_stmt|;
else|else
block|{
name|CLEAR_HARD_REG_SET
argument_list|(
name|referenced_regs
argument_list|)
expr_stmt|;
name|mark_referenced_regs
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|AND_HARD_REG_SET
argument_list|(
name|referenced_regs
argument_list|,
name|hard_regs_saved
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|referenced_regs
argument_list|,
name|regno
argument_list|)
condition|)
name|regno
operator|+=
name|insert_restore
argument_list|(
name|chain
argument_list|,
literal|1
argument_list|,
name|regno
argument_list|,
name|MOVE_MAX_WORDS
argument_list|,
name|save_mode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|==
name|CALL_INSN
operator|&&
operator|!
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_NORETURN
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|int
name|regno
decl_stmt|;
name|HARD_REG_SET
name|hard_regs_to_save
decl_stmt|;
comment|/* Use the register life information in CHAIN to compute which 		 regs are live during the call.  */
name|REG_SET_TO_HARD_REG_SET
argument_list|(
name|hard_regs_to_save
argument_list|,
operator|&
name|chain
operator|->
name|live_throughout
argument_list|)
expr_stmt|;
comment|/* Save hard registers always in the widest mode available.  */
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|hard_regs_to_save
argument_list|,
name|regno
argument_list|)
condition|)
name|save_mode
index|[
name|regno
index|]
operator|=
name|regno_save_mode
index|[
name|regno
index|]
index|[
literal|1
index|]
expr_stmt|;
else|else
name|save_mode
index|[
name|regno
index|]
operator|=
name|VOIDmode
expr_stmt|;
comment|/* Look through all live pseudos, mark their hard registers 		 and choose proper mode for saving.  */
name|EXECUTE_IF_SET_IN_REG_SET
argument_list|(
argument|&chain->live_throughout
argument_list|,
argument|FIRST_PSEUDO_REGISTER
argument_list|,
argument|regno
argument_list|,
argument|{ 		   int r = reg_renumber[regno]; 		   int nregs;  		   if (r>=
literal|0
argument|) 		     { 		       enum machine_mode mode;  		       nregs = HARD_REGNO_NREGS (r, PSEUDO_REGNO_MODE (regno)); 		       mode = HARD_REGNO_CALLER_SAVE_MODE 			        (r, nregs, PSEUDO_REGNO_MODE (regno)); 		       if (GET_MODE_BITSIZE (mode)> GET_MODE_BITSIZE (save_mode[r])) 			 save_mode[r] = mode; 		       while (nregs-->
literal|0
argument|) 			 SET_HARD_REG_BIT (hard_regs_to_save, r + nregs); 		     } 		   else 		     abort (); 		 }
argument_list|)
empty_stmt|;
comment|/* Record all registers set in this call insn.  These don't need 		 to be saved.  N.B. the call insn might set a subreg of a 		 multi-hard-reg pseudo; then the pseudo is considered live 		 during the call, but the subreg that is set isn't.  */
name|CLEAR_HARD_REG_SET
argument_list|(
name|this_insn_sets
argument_list|)
expr_stmt|;
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|mark_set_regs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Compute which hard regs must be saved before this call.  */
name|AND_COMPL_HARD_REG_SET
argument_list|(
name|hard_regs_to_save
argument_list|,
name|call_fixed_reg_set
argument_list|)
expr_stmt|;
name|AND_COMPL_HARD_REG_SET
argument_list|(
name|hard_regs_to_save
argument_list|,
name|this_insn_sets
argument_list|)
expr_stmt|;
name|AND_COMPL_HARD_REG_SET
argument_list|(
name|hard_regs_to_save
argument_list|,
name|hard_regs_saved
argument_list|)
expr_stmt|;
name|AND_HARD_REG_SET
argument_list|(
name|hard_regs_to_save
argument_list|,
name|call_used_reg_set
argument_list|)
expr_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|hard_regs_to_save
argument_list|,
name|regno
argument_list|)
condition|)
name|regno
operator|+=
name|insert_save
argument_list|(
name|chain
argument_list|,
literal|1
argument_list|,
name|regno
argument_list|,
operator|&
name|hard_regs_to_save
argument_list|,
name|save_mode
argument_list|)
expr_stmt|;
comment|/* Must recompute n_regs_saved.  */
name|n_regs_saved
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|hard_regs_saved
argument_list|,
name|regno
argument_list|)
condition|)
name|n_regs_saved
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|chain
operator|->
name|next
operator|==
literal|0
operator|||
name|chain
operator|->
name|next
operator|->
name|block
operator|>
name|chain
operator|->
name|block
condition|)
block|{
name|int
name|regno
decl_stmt|;
comment|/* At the end of the basic block, we must restore any registers that 	     remain saved.  If the last insn in the block is a JUMP_INSN, put 	     the restore before the insn, otherwise, put it after the insn.  */
if|if
condition|(
name|n_regs_saved
condition|)
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|hard_regs_saved
argument_list|,
name|regno
argument_list|)
condition|)
name|regno
operator|+=
name|insert_restore
argument_list|(
name|chain
argument_list|,
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
argument_list|,
name|regno
argument_list|,
name|MOVE_MAX_WORDS
argument_list|,
name|save_mode
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Here from note_stores when an insn stores a value in a register.    Set the proper bit or bits in this_insn_sets.  All pseudos that have    been assigned hard regs have had their register number changed already,    so we can ignore pseudos.  */
end_comment

begin_function
specifier|static
name|void
name|mark_set_regs
parameter_list|(
name|rtx
name|reg
parameter_list|,
name|rtx
name|setter
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
name|regno
decl_stmt|,
name|endregno
decl_stmt|,
name|i
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|reg
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|rtx
name|inner
init|=
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|inner
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|inner
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
return|return;
name|regno
operator|=
name|subreg_hard_regno
argument_list|(
name|reg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|regno
operator|=
name|REGNO
argument_list|(
name|reg
argument_list|)
expr_stmt|;
else|else
return|return;
name|endregno
operator|=
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|regno
init|;
name|i
operator|<
name|endregno
condition|;
name|i
operator|++
control|)
name|SET_HARD_REG_BIT
argument_list|(
name|this_insn_sets
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Here from note_stores when an insn stores a value in a register.    Set the proper bit or bits in the passed regset.  All pseudos that have    been assigned hard regs have had their register number changed already,    so we can ignore pseudos.  */
end_comment

begin_function
specifier|static
name|void
name|add_stored_regs
parameter_list|(
name|rtx
name|reg
parameter_list|,
name|rtx
name|setter
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|int
name|regno
decl_stmt|,
name|endregno
decl_stmt|,
name|i
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|reg
argument_list|)
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|setter
argument_list|)
operator|==
name|CLOBBER
condition|)
return|return;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|offset
operator|=
name|subreg_regno_offset
argument_list|(
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
argument_list|)
argument_list|,
name|SUBREG_BYTE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
name|reg
operator|=
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
return|return;
name|regno
operator|=
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|+
name|offset
expr_stmt|;
name|endregno
operator|=
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|regno
init|;
name|i
operator|<
name|endregno
condition|;
name|i
operator|++
control|)
name|SET_REGNO_REG_SET
argument_list|(
operator|(
name|regset
operator|)
name|data
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Walk X and record all referenced registers in REFERENCED_REGS.  */
end_comment

begin_function
specifier|static
name|void
name|mark_referenced_regs
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|SET
condition|)
name|mark_referenced_regs
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|SET
operator|||
name|code
operator|==
name|CLOBBER
condition|)
block|{
name|x
operator|=
name|SET_DEST
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|code
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
operator|||
name|code
operator|==
name|PC
operator|||
name|code
operator|==
name|CC0
operator|||
operator|(
name|code
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
comment|/* If we're setting only part of a multi-word register, 		 we shall mark it as referenced, because the words 		 that are not being set should be restored.  */
operator|&&
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|>=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|<=
name|UNITS_PER_WORD
operator|)
operator|)
operator|)
condition|)
return|return;
block|}
if|if
condition|(
name|code
operator|==
name|MEM
operator|||
name|code
operator|==
name|SUBREG
condition|)
block|{
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|==
name|REG
condition|)
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|int
name|hardregno
init|=
operator|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|?
name|regno
else|:
name|reg_renumber
index|[
name|regno
index|]
operator|)
decl_stmt|;
if|if
condition|(
name|hardregno
operator|>=
literal|0
condition|)
block|{
name|int
name|nregs
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|hardregno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
name|nregs
operator|--
operator|>
literal|0
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|referenced_regs
argument_list|,
name|hardregno
operator|+
name|nregs
argument_list|)
expr_stmt|;
block|}
comment|/* If this is a pseudo that did not get a hard register, scan its 	 memory location, since it might involve the use of another 	 register, which might be saved.  */
elseif|else
if|if
condition|(
name|reg_equiv_mem
index|[
name|regno
index|]
operator|!=
literal|0
condition|)
name|mark_referenced_regs
argument_list|(
name|XEXP
argument_list|(
name|reg_equiv_mem
index|[
name|regno
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|reg_equiv_address
index|[
name|regno
index|]
operator|!=
literal|0
condition|)
name|mark_referenced_regs
argument_list|(
name|reg_equiv_address
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|mark_referenced_regs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|mark_referenced_regs
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Insert a sequence of insns to restore.  Place these insns in front of    CHAIN if BEFORE_P is nonzero, behind the insn otherwise.  MAXRESTORE is    the maximum number of registers which should be restored during this call.    It should never be less than 1 since we only work with entire registers.     Note that we have verified in init_caller_save that we can do this    with a simple SET, so use it.  Set INSN_CODE to what we save there    since the address might not be valid so the insn might not be recognized.    These insns will be reloaded and have register elimination done by    find_reload, so we need not worry about that here.     Return the extra number of registers saved.  */
end_comment

begin_function
specifier|static
name|int
name|insert_restore
parameter_list|(
name|struct
name|insn_chain
modifier|*
name|chain
parameter_list|,
name|int
name|before_p
parameter_list|,
name|int
name|regno
parameter_list|,
name|int
name|maxrestore
parameter_list|,
name|enum
name|machine_mode
modifier|*
name|save_mode
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|k
decl_stmt|;
name|rtx
name|pat
init|=
name|NULL_RTX
decl_stmt|;
name|int
name|code
decl_stmt|;
name|unsigned
name|int
name|numregs
init|=
literal|0
decl_stmt|;
name|struct
name|insn_chain
modifier|*
name|new
decl_stmt|;
name|rtx
name|mem
decl_stmt|;
comment|/* A common failure mode if register status is not correct in the RTL      is for this routine to be called with a REGNO we didn't expect to      save.  That will cause us to write an insn with a (nil) SET_DEST      or SET_SRC.  Instead of doing so and causing a crash later, check      for this common case and abort here instead.  This will remove one      step in debugging such problems.  */
if|if
condition|(
name|regno_save_mem
index|[
name|regno
index|]
index|[
literal|1
index|]
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Get the pattern to emit and update our status.       See if we can restore `maxrestore' registers at once.  Work      backwards to the single register case.  */
for|for
control|(
name|i
operator|=
name|maxrestore
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|int
name|j
decl_stmt|;
name|int
name|ok
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|regno_save_mem
index|[
name|regno
index|]
index|[
name|i
index|]
operator|==
literal|0
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|hard_regs_saved
argument_list|,
name|regno
operator|+
name|j
argument_list|)
condition|)
block|{
name|ok
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* Must do this one restore at a time.  */
if|if
condition|(
operator|!
name|ok
condition|)
continue|continue;
name|numregs
operator|=
name|i
expr_stmt|;
break|break;
block|}
name|mem
operator|=
name|regno_save_mem
index|[
name|regno
index|]
index|[
name|numregs
index|]
expr_stmt|;
if|if
condition|(
name|save_mode
index|[
name|regno
index|]
operator|!=
name|VOIDmode
operator|&&
name|save_mode
index|[
name|regno
index|]
operator|!=
name|GET_MODE
argument_list|(
name|mem
argument_list|)
operator|&&
name|numregs
operator|==
operator|(
name|unsigned
name|int
operator|)
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|save_mode
index|[
name|regno
index|]
argument_list|)
condition|)
name|mem
operator|=
name|adjust_address
argument_list|(
name|mem
argument_list|,
name|save_mode
index|[
name|regno
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pat
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|GET_MODE
argument_list|(
name|mem
argument_list|)
argument_list|,
name|regno
argument_list|)
argument_list|,
name|mem
argument_list|)
expr_stmt|;
name|code
operator|=
name|reg_restore_code
index|[
name|regno
index|]
index|[
name|GET_MODE
argument_list|(
name|mem
argument_list|)
index|]
expr_stmt|;
name|new
operator|=
name|insert_one_insn
argument_list|(
name|chain
argument_list|,
name|before_p
argument_list|,
name|code
argument_list|,
name|pat
argument_list|)
expr_stmt|;
comment|/* Clear status for all registers we restored.  */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|i
condition|;
name|k
operator|++
control|)
block|{
name|CLEAR_HARD_REG_BIT
argument_list|(
name|hard_regs_saved
argument_list|,
name|regno
operator|+
name|k
argument_list|)
expr_stmt|;
name|SET_REGNO_REG_SET
argument_list|(
operator|&
name|new
operator|->
name|dead_or_set
argument_list|,
name|regno
operator|+
name|k
argument_list|)
expr_stmt|;
name|n_regs_saved
operator|--
expr_stmt|;
block|}
comment|/* Tell our callers how many extra registers we saved/restored.  */
return|return
name|numregs
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Like insert_restore above, but save registers instead.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|insert_save
argument_list|(
expr|struct
name|insn_chain
operator|*
name|chain
argument_list|,
name|int
name|before_p
argument_list|,
name|int
name|regno
argument_list|,
name|HARD_REG_SET
argument_list|(
operator|*
name|to_save
argument_list|)
argument_list|,
expr|enum
name|machine_mode
operator|*
name|save_mode
argument_list|)
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|k
decl_stmt|;
name|rtx
name|pat
init|=
name|NULL_RTX
decl_stmt|;
name|int
name|code
decl_stmt|;
name|unsigned
name|int
name|numregs
init|=
literal|0
decl_stmt|;
name|struct
name|insn_chain
modifier|*
name|new
decl_stmt|;
name|rtx
name|mem
decl_stmt|;
comment|/* A common failure mode if register status is not correct in the RTL      is for this routine to be called with a REGNO we didn't expect to      save.  That will cause us to write an insn with a (nil) SET_DEST      or SET_SRC.  Instead of doing so and causing a crash later, check      for this common case and abort here instead.  This will remove one      step in debugging such problems.  */
if|if
condition|(
name|regno_save_mem
index|[
name|regno
index|]
index|[
literal|1
index|]
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Get the pattern to emit and update our status.       See if we can save several registers with a single instruction.      Work backwards to the single register case.  */
for|for
control|(
name|i
operator|=
name|MOVE_MAX_WORDS
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|int
name|j
decl_stmt|;
name|int
name|ok
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|regno_save_mem
index|[
name|regno
index|]
index|[
name|i
index|]
operator|==
literal|0
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
operator|*
name|to_save
argument_list|,
name|regno
operator|+
name|j
argument_list|)
condition|)
block|{
name|ok
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* Must do this one save at a time.  */
if|if
condition|(
operator|!
name|ok
condition|)
continue|continue;
name|numregs
operator|=
name|i
expr_stmt|;
break|break;
block|}
name|mem
operator|=
name|regno_save_mem
index|[
name|regno
index|]
index|[
name|numregs
index|]
expr_stmt|;
if|if
condition|(
name|save_mode
index|[
name|regno
index|]
operator|!=
name|VOIDmode
operator|&&
name|save_mode
index|[
name|regno
index|]
operator|!=
name|GET_MODE
argument_list|(
name|mem
argument_list|)
operator|&&
name|numregs
operator|==
operator|(
name|unsigned
name|int
operator|)
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|save_mode
index|[
name|regno
index|]
argument_list|)
condition|)
name|mem
operator|=
name|adjust_address
argument_list|(
name|mem
argument_list|,
name|save_mode
index|[
name|regno
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pat
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|mem
argument_list|,
name|gen_rtx_REG
argument_list|(
name|GET_MODE
argument_list|(
name|mem
argument_list|)
argument_list|,
name|regno
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|=
name|reg_save_code
index|[
name|regno
index|]
index|[
name|GET_MODE
argument_list|(
name|mem
argument_list|)
index|]
expr_stmt|;
name|new
operator|=
name|insert_one_insn
argument_list|(
name|chain
argument_list|,
name|before_p
argument_list|,
name|code
argument_list|,
name|pat
argument_list|)
expr_stmt|;
comment|/* Set hard_regs_saved and dead_or_set for all the registers we saved.  */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|numregs
condition|;
name|k
operator|++
control|)
block|{
name|SET_HARD_REG_BIT
argument_list|(
name|hard_regs_saved
argument_list|,
name|regno
operator|+
name|k
argument_list|)
expr_stmt|;
name|SET_REGNO_REG_SET
argument_list|(
operator|&
name|new
operator|->
name|dead_or_set
argument_list|,
name|regno
operator|+
name|k
argument_list|)
expr_stmt|;
name|n_regs_saved
operator|++
expr_stmt|;
block|}
comment|/* Tell our callers how many extra registers we saved/restored.  */
return|return
name|numregs
operator|-
literal|1
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Emit a new caller-save insn and set the code.  */
end_comment

begin_function
specifier|static
name|struct
name|insn_chain
modifier|*
name|insert_one_insn
parameter_list|(
name|struct
name|insn_chain
modifier|*
name|chain
parameter_list|,
name|int
name|before_p
parameter_list|,
name|int
name|code
parameter_list|,
name|rtx
name|pat
parameter_list|)
block|{
name|rtx
name|insn
init|=
name|chain
operator|->
name|insn
decl_stmt|;
name|struct
name|insn_chain
modifier|*
name|new
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* If INSN references CC0, put our insns in front of the insn that sets      CC0.  This is always safe, since the only way we could be passed an      insn that references CC0 is for a restore, and doing a restore earlier      isn't a problem.  We do, however, assume here that CALL_INSNs don't      reference CC0.  Guard against non-INSN's like CODE_LABEL.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|)
operator|&&
name|before_p
operator|&&
name|reg_referenced_p
argument_list|(
name|cc0_rtx
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
name|chain
operator|=
name|chain
operator|->
name|prev
operator|,
name|insn
operator|=
name|chain
operator|->
name|insn
expr_stmt|;
endif|#
directive|endif
name|new
operator|=
name|new_insn_chain
argument_list|()
expr_stmt|;
if|if
condition|(
name|before_p
condition|)
block|{
name|rtx
name|link
decl_stmt|;
name|new
operator|->
name|prev
operator|=
name|chain
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|new
operator|->
name|prev
operator|!=
literal|0
condition|)
name|new
operator|->
name|prev
operator|->
name|next
operator|=
name|new
expr_stmt|;
else|else
name|reload_insn_chain
operator|=
name|new
expr_stmt|;
name|chain
operator|->
name|prev
operator|=
name|new
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|chain
expr_stmt|;
name|new
operator|->
name|insn
operator|=
name|emit_insn_before
argument_list|(
name|pat
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* ??? It would be nice if we could exclude the already / still saved 	 registers from the live sets.  */
name|COPY_REG_SET
argument_list|(
operator|&
name|new
operator|->
name|live_throughout
argument_list|,
operator|&
name|chain
operator|->
name|live_throughout
argument_list|)
expr_stmt|;
comment|/* Registers that die in CHAIN->INSN still live in the new insn.  */
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|chain
operator|->
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
block|{
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_DEAD
condition|)
block|{
name|rtx
name|reg
init|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|regno
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|!=
name|REG
condition|)
name|abort
argument_list|()
expr_stmt|;
name|regno
operator|=
name|REGNO
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|regno
operator|=
name|reg_renumber
index|[
name|regno
index|]
expr_stmt|;
if|if
condition|(
name|regno
operator|<
literal|0
condition|)
continue|continue;
for|for
control|(
name|i
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|SET_REGNO_REG_SET
argument_list|(
operator|&
name|new
operator|->
name|live_throughout
argument_list|,
name|regno
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
block|}
name|CLEAR_REG_SET
argument_list|(
operator|&
name|new
operator|->
name|dead_or_set
argument_list|)
expr_stmt|;
if|if
condition|(
name|chain
operator|->
name|insn
operator|==
name|BB_HEAD
argument_list|(
name|BASIC_BLOCK
argument_list|(
name|chain
operator|->
name|block
argument_list|)
argument_list|)
condition|)
name|BB_HEAD
argument_list|(
name|BASIC_BLOCK
argument_list|(
name|chain
operator|->
name|block
argument_list|)
argument_list|)
operator|=
name|new
operator|->
name|insn
expr_stmt|;
block|}
else|else
block|{
name|new
operator|->
name|next
operator|=
name|chain
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|new
operator|->
name|next
operator|!=
literal|0
condition|)
name|new
operator|->
name|next
operator|->
name|prev
operator|=
name|new
expr_stmt|;
name|chain
operator|->
name|next
operator|=
name|new
expr_stmt|;
name|new
operator|->
name|prev
operator|=
name|chain
expr_stmt|;
name|new
operator|->
name|insn
operator|=
name|emit_insn_after
argument_list|(
name|pat
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* ??? It would be nice if we could exclude the already / still saved 	 registers from the live sets, and observe REG_UNUSED notes.  */
name|COPY_REG_SET
argument_list|(
operator|&
name|new
operator|->
name|live_throughout
argument_list|,
operator|&
name|chain
operator|->
name|live_throughout
argument_list|)
expr_stmt|;
comment|/* Registers that are set in CHAIN->INSN live in the new insn.          (Unless there is a REG_UNUSED note for them, but we don't 	  look for them here.) */
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|chain
operator|->
name|insn
argument_list|)
argument_list|,
name|add_stored_regs
argument_list|,
operator|&
name|new
operator|->
name|live_throughout
argument_list|)
expr_stmt|;
name|CLEAR_REG_SET
argument_list|(
operator|&
name|new
operator|->
name|dead_or_set
argument_list|)
expr_stmt|;
if|if
condition|(
name|chain
operator|->
name|insn
operator|==
name|BB_END
argument_list|(
name|BASIC_BLOCK
argument_list|(
name|chain
operator|->
name|block
argument_list|)
argument_list|)
condition|)
name|BB_END
argument_list|(
name|BASIC_BLOCK
argument_list|(
name|chain
operator|->
name|block
argument_list|)
argument_list|)
operator|=
name|new
operator|->
name|insn
expr_stmt|;
block|}
name|new
operator|->
name|block
operator|=
name|chain
operator|->
name|block
expr_stmt|;
name|new
operator|->
name|is_caller_save_insn
operator|=
literal|1
expr_stmt|;
name|INSN_CODE
argument_list|(
name|new
operator|->
name|insn
argument_list|)
operator|=
name|code
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

end_unit

