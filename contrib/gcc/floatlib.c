begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ** libgcc support for software floating point. ** Copyright (C) 1991 by Pipeline Associates, Inc.  All rights reserved. ** Permission is granted to do *anything* you want with this file, ** commercial or otherwise, provided this message remains intact.  So there! ** I would appreciate receiving any updates/patches/changes that anyone ** makes, and am willing to be the repository for said changes (am I ** making a big mistake?).  Warning! Only single-precision is actually implemented.  This file won't really be much use until double-precision is supported.  However, once that is done, this file might eventually become a replacement for libgcc1.c.  It might also make possible cross-compilation for an IEEE target machine from a non-IEEE host such as a VAX.  If you'd like to work on completing this, please talk to rms@gnu.ai.mit.edu.  --> Double precision floating support added by James Carlson on 20 April 1998.  ** ** Pat Wood ** Pipeline Associates, Inc. ** pipeline!phw@motown.com or ** sun!pipeline!phw or ** uunet!motown!pipeline!phw ** ** 05/01/91 -- V1.0 -- first release to gcc mailing lists ** 05/04/91 -- V1.1 -- added float and double prototypes and return values **                  -- fixed problems with adding and subtracting zero **                  -- fixed rounding in truncdfsf2 **                  -- fixed SWAP define and tested on 386 */
end_comment

begin_comment
comment|/* ** The following are routines that replace the libgcc soft floating point ** routines that are called automatically when -msoft-float is selected. ** The support single and double precision IEEE format, with provisions ** for byte-swapped machines (tested on 386).  Some of the double-precision ** routines work at full precision, but most of the hard ones simply punt ** and call the single precision routines, producing a loss of accuracy. ** long long support is not assumed or included. ** Overall accuracy is close to IEEE (actually 68882) for single-precision ** arithmetic.  I think there may still be a 1 in 1000 chance of a bit ** being rounded the wrong way during a multiply.  I'm not fussy enough to ** bother with it, but if anyone is, knock yourself out. ** ** Efficiency has only been addressed where it was obvious that something ** would make a big difference.  Anyone who wants to do this right for ** best speed should go in and rewrite in assembler. ** ** I have tested this only on a 68030 workstation and 386/ix integrated ** in with -msoft-float. */
end_comment

begin_comment
comment|/* the following deal with IEEE single-precision numbers */
end_comment

begin_define
define|#
directive|define
name|EXCESS
value|126
end_define

begin_define
define|#
directive|define
name|SIGNBIT
value|0x80000000
end_define

begin_define
define|#
directive|define
name|HIDDEN
value|(1<< 23)
end_define

begin_define
define|#
directive|define
name|SIGN
parameter_list|(
name|fp
parameter_list|)
value|((fp)& SIGNBIT)
end_define

begin_define
define|#
directive|define
name|EXP
parameter_list|(
name|fp
parameter_list|)
value|(((fp)>> 23)& 0xFF)
end_define

begin_define
define|#
directive|define
name|MANT
parameter_list|(
name|fp
parameter_list|)
value|(((fp)& 0x7FFFFF) | HIDDEN)
end_define

begin_define
define|#
directive|define
name|PACK
parameter_list|(
name|s
parameter_list|,
name|e
parameter_list|,
name|m
parameter_list|)
value|((s) | ((e)<< 23) | (m))
end_define

begin_comment
comment|/* the following deal with IEEE double-precision numbers */
end_comment

begin_define
define|#
directive|define
name|EXCESSD
value|1022
end_define

begin_define
define|#
directive|define
name|HIDDEND
value|(1<< 20)
end_define

begin_define
define|#
directive|define
name|EXPD
parameter_list|(
name|fp
parameter_list|)
value|(((fp.l.upper)>> 20)& 0x7FF)
end_define

begin_define
define|#
directive|define
name|SIGND
parameter_list|(
name|fp
parameter_list|)
value|((fp.l.upper)& SIGNBIT)
end_define

begin_define
define|#
directive|define
name|MANTD
parameter_list|(
name|fp
parameter_list|)
value|(((((fp.l.upper)& 0xFFFFF) | HIDDEND)<< 10) | \ 				(fp.l.lower>> 22))
end_define

begin_define
define|#
directive|define
name|HIDDEND_LL
value|((long long)1<< 52)
end_define

begin_define
define|#
directive|define
name|MANTD_LL
parameter_list|(
name|fp
parameter_list|)
value|((fp.ll& (HIDDEND_LL-1)) | HIDDEND_LL)
end_define

begin_define
define|#
directive|define
name|PACKD_LL
parameter_list|(
name|s
parameter_list|,
name|e
parameter_list|,
name|m
parameter_list|)
value|(((long long)((s)+((e)<<20))<<32)|(m))
end_define

begin_comment
comment|/* define SWAP for 386/960 reverse-byte-order brain-damaged CPUs */
end_comment

begin_union
union|union
name|double_long
block|{
name|double
name|d
decl_stmt|;
ifdef|#
directive|ifdef
name|SWAP
struct|struct
block|{
name|unsigned
name|long
name|lower
decl_stmt|;
name|long
name|upper
decl_stmt|;
block|}
name|l
struct|;
else|#
directive|else
struct|struct
block|{
name|long
name|upper
decl_stmt|;
name|unsigned
name|long
name|lower
decl_stmt|;
block|}
name|l
struct|;
endif|#
directive|endif
name|long
name|long
name|ll
decl_stmt|;
block|}
union|;
end_union

begin_union
union|union
name|float_long
block|{
name|float
name|f
decl_stmt|;
name|long
name|l
decl_stmt|;
block|}
union|;
end_union

begin_comment
comment|/* add two floats */
end_comment

begin_function
name|float
name|__addsf3
parameter_list|(
name|float
name|a1
parameter_list|,
name|float
name|a2
parameter_list|)
block|{
specifier|register
name|long
name|mant1
decl_stmt|,
name|mant2
decl_stmt|;
specifier|register
name|union
name|float_long
name|fl1
decl_stmt|,
name|fl2
decl_stmt|;
specifier|register
name|int
name|exp1
decl_stmt|,
name|exp2
decl_stmt|;
name|int
name|sign
init|=
literal|0
decl_stmt|;
name|fl1
operator|.
name|f
operator|=
name|a1
expr_stmt|;
name|fl2
operator|.
name|f
operator|=
name|a2
expr_stmt|;
comment|/* check for zero args */
if|if
condition|(
operator|!
name|fl1
operator|.
name|l
condition|)
block|{
name|fl1
operator|.
name|f
operator|=
name|fl2
operator|.
name|f
expr_stmt|;
goto|goto
name|test_done
goto|;
block|}
if|if
condition|(
operator|!
name|fl2
operator|.
name|l
condition|)
goto|goto
name|test_done
goto|;
name|exp1
operator|=
name|EXP
argument_list|(
name|fl1
operator|.
name|l
argument_list|)
expr_stmt|;
name|exp2
operator|=
name|EXP
argument_list|(
name|fl2
operator|.
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp1
operator|>
name|exp2
operator|+
literal|25
condition|)
goto|goto
name|test_done
goto|;
if|if
condition|(
name|exp2
operator|>
name|exp1
operator|+
literal|25
condition|)
block|{
name|fl1
operator|.
name|f
operator|=
name|fl2
operator|.
name|f
expr_stmt|;
goto|goto
name|test_done
goto|;
block|}
comment|/* do everything in excess precision so's we can round later */
name|mant1
operator|=
name|MANT
argument_list|(
name|fl1
operator|.
name|l
argument_list|)
operator|<<
literal|6
expr_stmt|;
name|mant2
operator|=
name|MANT
argument_list|(
name|fl2
operator|.
name|l
argument_list|)
operator|<<
literal|6
expr_stmt|;
if|if
condition|(
name|SIGN
argument_list|(
name|fl1
operator|.
name|l
argument_list|)
condition|)
name|mant1
operator|=
operator|-
name|mant1
expr_stmt|;
if|if
condition|(
name|SIGN
argument_list|(
name|fl2
operator|.
name|l
argument_list|)
condition|)
name|mant2
operator|=
operator|-
name|mant2
expr_stmt|;
if|if
condition|(
name|exp1
operator|>
name|exp2
condition|)
block|{
name|mant2
operator|>>=
name|exp1
operator|-
name|exp2
expr_stmt|;
block|}
else|else
block|{
name|mant1
operator|>>=
name|exp2
operator|-
name|exp1
expr_stmt|;
name|exp1
operator|=
name|exp2
expr_stmt|;
block|}
name|mant1
operator|+=
name|mant2
expr_stmt|;
if|if
condition|(
name|mant1
operator|<
literal|0
condition|)
block|{
name|mant1
operator|=
operator|-
name|mant1
expr_stmt|;
name|sign
operator|=
name|SIGNBIT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|mant1
condition|)
block|{
name|fl1
operator|.
name|f
operator|=
literal|0
expr_stmt|;
goto|goto
name|test_done
goto|;
block|}
comment|/* normalize up */
while|while
condition|(
operator|!
operator|(
name|mant1
operator|&
literal|0xE0000000
operator|)
condition|)
block|{
name|mant1
operator|<<=
literal|1
expr_stmt|;
name|exp1
operator|--
expr_stmt|;
block|}
comment|/* normalize down? */
if|if
condition|(
name|mant1
operator|&
operator|(
literal|1
operator|<<
literal|30
operator|)
condition|)
block|{
name|mant1
operator|>>=
literal|1
expr_stmt|;
name|exp1
operator|++
expr_stmt|;
block|}
comment|/* round to even */
name|mant1
operator|+=
operator|(
name|mant1
operator|&
literal|0x40
operator|)
condition|?
literal|0x20
else|:
literal|0x1F
expr_stmt|;
comment|/* normalize down? */
if|if
condition|(
name|mant1
operator|&
operator|(
literal|1
operator|<<
literal|30
operator|)
condition|)
block|{
name|mant1
operator|>>=
literal|1
expr_stmt|;
name|exp1
operator|++
expr_stmt|;
block|}
comment|/* lose extra precision */
name|mant1
operator|>>=
literal|6
expr_stmt|;
comment|/* turn off hidden bit */
name|mant1
operator|&=
operator|~
name|HIDDEN
expr_stmt|;
comment|/* pack up and go home */
name|fl1
operator|.
name|l
operator|=
name|PACK
argument_list|(
name|sign
argument_list|,
name|exp1
argument_list|,
name|mant1
argument_list|)
expr_stmt|;
name|test_done
label|:
return|return
operator|(
name|fl1
operator|.
name|f
operator|)
return|;
block|}
end_function

begin_comment
comment|/* subtract two floats */
end_comment

begin_function
name|float
name|__subsf3
parameter_list|(
name|float
name|a1
parameter_list|,
name|float
name|a2
parameter_list|)
block|{
specifier|register
name|union
name|float_long
name|fl1
decl_stmt|,
name|fl2
decl_stmt|;
name|fl1
operator|.
name|f
operator|=
name|a1
expr_stmt|;
name|fl2
operator|.
name|f
operator|=
name|a2
expr_stmt|;
comment|/* check for zero args */
if|if
condition|(
operator|!
name|fl2
operator|.
name|l
condition|)
return|return
operator|(
name|fl1
operator|.
name|f
operator|)
return|;
if|if
condition|(
operator|!
name|fl1
operator|.
name|l
condition|)
return|return
operator|(
operator|-
name|fl2
operator|.
name|f
operator|)
return|;
comment|/* twiddle sign bit and add */
name|fl2
operator|.
name|l
operator|^=
name|SIGNBIT
expr_stmt|;
return|return
name|__addsf3
argument_list|(
name|a1
argument_list|,
name|fl2
operator|.
name|f
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* compare two floats */
end_comment

begin_function
name|long
name|__cmpsf2
parameter_list|(
name|float
name|a1
parameter_list|,
name|float
name|a2
parameter_list|)
block|{
specifier|register
name|union
name|float_long
name|fl1
decl_stmt|,
name|fl2
decl_stmt|;
name|fl1
operator|.
name|f
operator|=
name|a1
expr_stmt|;
name|fl2
operator|.
name|f
operator|=
name|a2
expr_stmt|;
if|if
condition|(
name|SIGN
argument_list|(
name|fl1
operator|.
name|l
argument_list|)
operator|&&
name|SIGN
argument_list|(
name|fl2
operator|.
name|l
argument_list|)
condition|)
block|{
name|fl1
operator|.
name|l
operator|^=
name|SIGNBIT
expr_stmt|;
name|fl2
operator|.
name|l
operator|^=
name|SIGNBIT
expr_stmt|;
block|}
if|if
condition|(
name|fl1
operator|.
name|l
operator|<
name|fl2
operator|.
name|l
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|fl1
operator|.
name|l
operator|>
name|fl2
operator|.
name|l
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* multiply two floats */
end_comment

begin_function
name|float
name|__mulsf3
parameter_list|(
name|float
name|a1
parameter_list|,
name|float
name|a2
parameter_list|)
block|{
specifier|register
name|union
name|float_long
name|fl1
decl_stmt|,
name|fl2
decl_stmt|;
specifier|register
name|unsigned
name|long
name|result
decl_stmt|;
specifier|register
name|int
name|exp
decl_stmt|;
name|int
name|sign
decl_stmt|;
name|fl1
operator|.
name|f
operator|=
name|a1
expr_stmt|;
name|fl2
operator|.
name|f
operator|=
name|a2
expr_stmt|;
if|if
condition|(
operator|!
name|fl1
operator|.
name|l
operator|||
operator|!
name|fl2
operator|.
name|l
condition|)
block|{
name|fl1
operator|.
name|f
operator|=
literal|0
expr_stmt|;
goto|goto
name|test_done
goto|;
block|}
comment|/* compute sign and exponent */
name|sign
operator|=
name|SIGN
argument_list|(
name|fl1
operator|.
name|l
argument_list|)
operator|^
name|SIGN
argument_list|(
name|fl2
operator|.
name|l
argument_list|)
expr_stmt|;
name|exp
operator|=
name|EXP
argument_list|(
name|fl1
operator|.
name|l
argument_list|)
operator|-
name|EXCESS
expr_stmt|;
name|exp
operator|+=
name|EXP
argument_list|(
name|fl2
operator|.
name|l
argument_list|)
expr_stmt|;
name|fl1
operator|.
name|l
operator|=
name|MANT
argument_list|(
name|fl1
operator|.
name|l
argument_list|)
expr_stmt|;
name|fl2
operator|.
name|l
operator|=
name|MANT
argument_list|(
name|fl2
operator|.
name|l
argument_list|)
expr_stmt|;
comment|/* the multiply is done as one 16x16 multiply and two 16x8 multiples */
name|result
operator|=
operator|(
name|fl1
operator|.
name|l
operator|>>
literal|8
operator|)
operator|*
operator|(
name|fl2
operator|.
name|l
operator|>>
literal|8
operator|)
expr_stmt|;
name|result
operator|+=
operator|(
operator|(
name|fl1
operator|.
name|l
operator|&
literal|0xFF
operator|)
operator|*
operator|(
name|fl2
operator|.
name|l
operator|>>
literal|8
operator|)
operator|)
operator|>>
literal|8
expr_stmt|;
name|result
operator|+=
operator|(
operator|(
name|fl2
operator|.
name|l
operator|&
literal|0xFF
operator|)
operator|*
operator|(
name|fl1
operator|.
name|l
operator|>>
literal|8
operator|)
operator|)
operator|>>
literal|8
expr_stmt|;
name|result
operator|>>=
literal|2
expr_stmt|;
if|if
condition|(
name|result
operator|&
literal|0x20000000
condition|)
block|{
comment|/* round */
name|result
operator|+=
literal|0x20
expr_stmt|;
name|result
operator|>>=
literal|6
expr_stmt|;
block|}
else|else
block|{
comment|/* round */
name|result
operator|+=
literal|0x10
expr_stmt|;
name|result
operator|>>=
literal|5
expr_stmt|;
name|exp
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|&
operator|(
name|HIDDEN
operator|<<
literal|1
operator|)
condition|)
block|{
name|result
operator|>>=
literal|1
expr_stmt|;
name|exp
operator|++
expr_stmt|;
block|}
name|result
operator|&=
operator|~
name|HIDDEN
expr_stmt|;
comment|/* pack up and go home */
name|fl1
operator|.
name|l
operator|=
name|PACK
argument_list|(
name|sign
argument_list|,
name|exp
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|test_done
label|:
return|return
operator|(
name|fl1
operator|.
name|f
operator|)
return|;
block|}
end_function

begin_comment
comment|/* divide two floats */
end_comment

begin_function
name|float
name|__divsf3
parameter_list|(
name|float
name|a1
parameter_list|,
name|float
name|a2
parameter_list|)
block|{
specifier|register
name|union
name|float_long
name|fl1
decl_stmt|,
name|fl2
decl_stmt|;
specifier|register
name|int
name|result
decl_stmt|;
specifier|register
name|int
name|mask
decl_stmt|;
specifier|register
name|int
name|exp
decl_stmt|,
name|sign
decl_stmt|;
name|fl1
operator|.
name|f
operator|=
name|a1
expr_stmt|;
name|fl2
operator|.
name|f
operator|=
name|a2
expr_stmt|;
comment|/* subtract exponents */
name|exp
operator|=
name|EXP
argument_list|(
name|fl1
operator|.
name|l
argument_list|)
operator|-
name|EXP
argument_list|(
name|fl2
operator|.
name|l
argument_list|)
operator|+
name|EXCESS
expr_stmt|;
comment|/* compute sign */
name|sign
operator|=
name|SIGN
argument_list|(
name|fl1
operator|.
name|l
argument_list|)
operator|^
name|SIGN
argument_list|(
name|fl2
operator|.
name|l
argument_list|)
expr_stmt|;
comment|/* divide by zero??? */
if|if
condition|(
operator|!
name|fl2
operator|.
name|l
condition|)
comment|/* return NaN or -NaN */
return|return
operator|(
name|sign
condition|?
literal|0xFFFFFFFF
else|:
literal|0x7FFFFFFF
operator|)
return|;
comment|/* numerator zero??? */
if|if
condition|(
operator|!
name|fl1
operator|.
name|l
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* now get mantissas */
name|fl1
operator|.
name|l
operator|=
name|MANT
argument_list|(
name|fl1
operator|.
name|l
argument_list|)
expr_stmt|;
name|fl2
operator|.
name|l
operator|=
name|MANT
argument_list|(
name|fl2
operator|.
name|l
argument_list|)
expr_stmt|;
comment|/* this assures we have 25 bits of precision in the end */
if|if
condition|(
name|fl1
operator|.
name|l
operator|<
name|fl2
operator|.
name|l
condition|)
block|{
name|fl1
operator|.
name|l
operator|<<=
literal|1
expr_stmt|;
name|exp
operator|--
expr_stmt|;
block|}
comment|/* now we perform repeated subtraction of fl2.l from fl1.l */
name|mask
operator|=
literal|0x1000000
expr_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|mask
condition|)
block|{
if|if
condition|(
name|fl1
operator|.
name|l
operator|>=
name|fl2
operator|.
name|l
condition|)
block|{
name|result
operator||=
name|mask
expr_stmt|;
name|fl1
operator|.
name|l
operator|-=
name|fl2
operator|.
name|l
expr_stmt|;
block|}
name|fl1
operator|.
name|l
operator|<<=
literal|1
expr_stmt|;
name|mask
operator|>>=
literal|1
expr_stmt|;
block|}
comment|/* round */
name|result
operator|+=
literal|1
expr_stmt|;
comment|/* normalize down */
name|exp
operator|++
expr_stmt|;
name|result
operator|>>=
literal|1
expr_stmt|;
name|result
operator|&=
operator|~
name|HIDDEN
expr_stmt|;
comment|/* pack up and go home */
name|fl1
operator|.
name|l
operator|=
name|PACK
argument_list|(
name|sign
argument_list|,
name|exp
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
operator|(
name|fl1
operator|.
name|f
operator|)
return|;
block|}
end_function

begin_comment
comment|/* convert int to double */
end_comment

begin_function
name|double
name|__floatsidf
parameter_list|(
specifier|register
name|long
name|a1
parameter_list|)
block|{
specifier|register
name|int
name|sign
init|=
literal|0
decl_stmt|,
name|exp
init|=
literal|31
operator|+
name|EXCESSD
decl_stmt|;
name|union
name|double_long
name|dl
decl_stmt|;
if|if
condition|(
operator|!
name|a1
condition|)
block|{
name|dl
operator|.
name|l
operator|.
name|upper
operator|=
name|dl
operator|.
name|l
operator|.
name|lower
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|dl
operator|.
name|d
operator|)
return|;
block|}
if|if
condition|(
name|a1
operator|<
literal|0
condition|)
block|{
name|sign
operator|=
name|SIGNBIT
expr_stmt|;
name|a1
operator|=
operator|-
name|a1
expr_stmt|;
block|}
while|while
condition|(
name|a1
operator|<
literal|0x1000000
condition|)
block|{
name|a1
operator|<<=
literal|4
expr_stmt|;
name|exp
operator|-=
literal|4
expr_stmt|;
block|}
while|while
condition|(
name|a1
operator|<
literal|0x40000000
condition|)
block|{
name|a1
operator|<<=
literal|1
expr_stmt|;
name|exp
operator|--
expr_stmt|;
block|}
comment|/* pack up and go home */
name|dl
operator|.
name|l
operator|.
name|upper
operator|=
name|sign
expr_stmt|;
name|dl
operator|.
name|l
operator|.
name|upper
operator||=
name|exp
operator|<<
literal|20
expr_stmt|;
name|dl
operator|.
name|l
operator|.
name|upper
operator||=
operator|(
name|a1
operator|>>
literal|10
operator|)
operator|&
operator|~
name|HIDDEND
expr_stmt|;
name|dl
operator|.
name|l
operator|.
name|lower
operator|=
name|a1
operator|<<
literal|22
expr_stmt|;
return|return
operator|(
name|dl
operator|.
name|d
operator|)
return|;
block|}
end_function

begin_function
name|double
name|__floatdidf
parameter_list|(
specifier|register
name|long
name|long
name|a1
parameter_list|)
block|{
specifier|register
name|int
name|exp
init|=
literal|63
operator|+
name|EXCESSD
decl_stmt|;
name|union
name|double_long
name|dl
decl_stmt|;
name|dl
operator|.
name|l
operator|.
name|upper
operator|=
name|dl
operator|.
name|l
operator|.
name|lower
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|a1
operator|==
literal|0
condition|)
return|return
operator|(
name|dl
operator|.
name|d
operator|)
return|;
if|if
condition|(
name|a1
operator|<
literal|0
condition|)
block|{
name|dl
operator|.
name|l
operator|.
name|upper
operator|=
name|SIGNBIT
expr_stmt|;
name|a1
operator|=
operator|-
name|a1
expr_stmt|;
block|}
while|while
condition|(
name|a1
operator|<
operator|(
name|long
name|long
operator|)
literal|1
operator|<<
literal|54
condition|)
block|{
name|a1
operator|<<=
literal|8
expr_stmt|;
name|exp
operator|-=
literal|8
expr_stmt|;
block|}
while|while
condition|(
name|a1
operator|<
operator|(
name|long
name|long
operator|)
literal|1
operator|<<
literal|62
condition|)
block|{
name|a1
operator|<<=
literal|1
expr_stmt|;
name|exp
operator|-=
literal|1
expr_stmt|;
block|}
comment|/* pack up and go home */
name|dl
operator|.
name|ll
operator||=
operator|(
name|a1
operator|>>
literal|10
operator|)
operator|&
operator|~
name|HIDDEND_LL
expr_stmt|;
name|dl
operator|.
name|l
operator|.
name|upper
operator||=
name|exp
operator|<<
literal|20
expr_stmt|;
return|return
operator|(
name|dl
operator|.
name|d
operator|)
return|;
block|}
end_function

begin_function
name|float
name|__floatsisf
parameter_list|(
specifier|register
name|long
name|a1
parameter_list|)
block|{
operator|(
name|float
operator|)
name|__floatsidf
argument_list|(
name|a1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|float
name|__floatdisf
parameter_list|(
specifier|register
name|long
name|long
name|a1
parameter_list|)
block|{
operator|(
name|float
operator|)
name|__floatdidf
argument_list|(
name|a1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* negate a float */
end_comment

begin_function
name|float
name|__negsf2
parameter_list|(
name|float
name|a1
parameter_list|)
block|{
specifier|register
name|union
name|float_long
name|fl1
decl_stmt|;
name|fl1
operator|.
name|f
operator|=
name|a1
expr_stmt|;
if|if
condition|(
operator|!
name|fl1
operator|.
name|l
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|fl1
operator|.
name|l
operator|^=
name|SIGNBIT
expr_stmt|;
return|return
operator|(
name|fl1
operator|.
name|f
operator|)
return|;
block|}
end_function

begin_comment
comment|/* negate a double */
end_comment

begin_function
name|double
name|__negdf2
parameter_list|(
name|double
name|a1
parameter_list|)
block|{
specifier|register
name|union
name|double_long
name|dl1
decl_stmt|;
name|dl1
operator|.
name|d
operator|=
name|a1
expr_stmt|;
if|if
condition|(
operator|!
name|dl1
operator|.
name|l
operator|.
name|upper
operator|&&
operator|!
name|dl1
operator|.
name|l
operator|.
name|lower
condition|)
return|return
operator|(
name|dl1
operator|.
name|d
operator|)
return|;
name|dl1
operator|.
name|l
operator|.
name|upper
operator|^=
name|SIGNBIT
expr_stmt|;
return|return
operator|(
name|dl1
operator|.
name|d
operator|)
return|;
block|}
end_function

begin_comment
comment|/* convert float to double */
end_comment

begin_function
name|double
name|__extendsfdf2
parameter_list|(
name|float
name|a1
parameter_list|)
block|{
specifier|register
name|union
name|float_long
name|fl1
decl_stmt|;
specifier|register
name|union
name|double_long
name|dl
decl_stmt|;
specifier|register
name|int
name|exp
decl_stmt|;
name|fl1
operator|.
name|f
operator|=
name|a1
expr_stmt|;
if|if
condition|(
operator|!
name|fl1
operator|.
name|l
condition|)
block|{
name|dl
operator|.
name|l
operator|.
name|upper
operator|=
name|dl
operator|.
name|l
operator|.
name|lower
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|dl
operator|.
name|d
operator|)
return|;
block|}
name|dl
operator|.
name|l
operator|.
name|upper
operator|=
name|SIGN
argument_list|(
name|fl1
operator|.
name|l
argument_list|)
expr_stmt|;
name|exp
operator|=
name|EXP
argument_list|(
name|fl1
operator|.
name|l
argument_list|)
operator|-
name|EXCESS
operator|+
name|EXCESSD
expr_stmt|;
name|dl
operator|.
name|l
operator|.
name|upper
operator||=
name|exp
operator|<<
literal|20
expr_stmt|;
name|dl
operator|.
name|l
operator|.
name|upper
operator||=
operator|(
name|MANT
argument_list|(
name|fl1
operator|.
name|l
argument_list|)
operator|&
operator|~
name|HIDDEN
operator|)
operator|>>
literal|3
expr_stmt|;
name|dl
operator|.
name|l
operator|.
name|lower
operator|=
name|MANT
argument_list|(
name|fl1
operator|.
name|l
argument_list|)
operator|<<
literal|29
expr_stmt|;
return|return
operator|(
name|dl
operator|.
name|d
operator|)
return|;
block|}
end_function

begin_comment
comment|/* convert double to float */
end_comment

begin_function
name|float
name|__truncdfsf2
parameter_list|(
name|double
name|a1
parameter_list|)
block|{
specifier|register
name|int
name|exp
decl_stmt|;
specifier|register
name|long
name|mant
decl_stmt|;
specifier|register
name|union
name|float_long
name|fl
decl_stmt|;
specifier|register
name|union
name|double_long
name|dl1
decl_stmt|;
name|dl1
operator|.
name|d
operator|=
name|a1
expr_stmt|;
if|if
condition|(
operator|!
name|dl1
operator|.
name|l
operator|.
name|upper
operator|&&
operator|!
name|dl1
operator|.
name|l
operator|.
name|lower
condition|)
return|return
call|(
name|float
call|)
argument_list|(
literal|0
argument_list|)
return|;
name|exp
operator|=
name|EXPD
argument_list|(
name|dl1
argument_list|)
operator|-
name|EXCESSD
operator|+
name|EXCESS
expr_stmt|;
comment|/* shift double mantissa 6 bits so we can round */
name|mant
operator|=
name|MANTD
argument_list|(
name|dl1
argument_list|)
operator|>>
literal|6
expr_stmt|;
comment|/* now round and shift down */
name|mant
operator|+=
literal|1
expr_stmt|;
name|mant
operator|>>=
literal|1
expr_stmt|;
comment|/* did the round overflow? */
if|if
condition|(
name|mant
operator|&
literal|0xFE000000
condition|)
block|{
name|mant
operator|>>=
literal|1
expr_stmt|;
name|exp
operator|++
expr_stmt|;
block|}
name|mant
operator|&=
operator|~
name|HIDDEN
expr_stmt|;
comment|/* pack up and go home */
name|fl
operator|.
name|l
operator|=
name|PACK
argument_list|(
name|SIGND
argument_list|(
name|dl1
argument_list|)
argument_list|,
name|exp
argument_list|,
name|mant
argument_list|)
expr_stmt|;
return|return
operator|(
name|fl
operator|.
name|f
operator|)
return|;
block|}
end_function

begin_comment
comment|/* compare two doubles */
end_comment

begin_function
name|long
name|__cmpdf2
parameter_list|(
name|double
name|a1
parameter_list|,
name|double
name|a2
parameter_list|)
block|{
specifier|register
name|union
name|double_long
name|dl1
decl_stmt|,
name|dl2
decl_stmt|;
name|dl1
operator|.
name|d
operator|=
name|a1
expr_stmt|;
name|dl2
operator|.
name|d
operator|=
name|a2
expr_stmt|;
if|if
condition|(
name|SIGND
argument_list|(
name|dl1
argument_list|)
operator|&&
name|SIGND
argument_list|(
name|dl2
argument_list|)
condition|)
block|{
name|dl1
operator|.
name|l
operator|.
name|upper
operator|^=
name|SIGNBIT
expr_stmt|;
name|dl2
operator|.
name|l
operator|.
name|upper
operator|^=
name|SIGNBIT
expr_stmt|;
block|}
if|if
condition|(
name|dl1
operator|.
name|l
operator|.
name|upper
operator|<
name|dl2
operator|.
name|l
operator|.
name|upper
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|dl1
operator|.
name|l
operator|.
name|upper
operator|>
name|dl2
operator|.
name|l
operator|.
name|upper
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|dl1
operator|.
name|l
operator|.
name|lower
operator|<
name|dl2
operator|.
name|l
operator|.
name|lower
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|dl1
operator|.
name|l
operator|.
name|lower
operator|>
name|dl2
operator|.
name|l
operator|.
name|lower
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* convert double to int */
end_comment

begin_function
name|long
name|__fixdfsi
parameter_list|(
name|double
name|a1
parameter_list|)
block|{
specifier|register
name|union
name|double_long
name|dl1
decl_stmt|;
specifier|register
name|int
name|exp
decl_stmt|;
specifier|register
name|long
name|l
decl_stmt|;
name|dl1
operator|.
name|d
operator|=
name|a1
expr_stmt|;
if|if
condition|(
operator|!
name|dl1
operator|.
name|l
operator|.
name|upper
operator|&&
operator|!
name|dl1
operator|.
name|l
operator|.
name|lower
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|exp
operator|=
name|EXPD
argument_list|(
name|dl1
argument_list|)
operator|-
name|EXCESSD
operator|-
literal|31
expr_stmt|;
name|l
operator|=
name|MANTD
argument_list|(
name|dl1
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|>
literal|0
condition|)
return|return
name|SIGND
argument_list|(
name|dl1
argument_list|)
condition|?
operator|(
literal|1
operator|<<
literal|31
operator|)
else|:
operator|(
operator|(
literal|1ul
operator|<<
literal|31
operator|)
operator|-
literal|1
operator|)
return|;
comment|/* shift down until exp = 0 or l = 0 */
if|if
condition|(
name|exp
operator|<
literal|0
operator|&&
name|exp
operator|>
operator|-
literal|32
operator|&&
name|l
condition|)
name|l
operator|>>=
operator|-
name|exp
expr_stmt|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|SIGND
argument_list|(
name|dl1
argument_list|)
condition|?
operator|-
name|l
else|:
name|l
operator|)
return|;
block|}
end_function

begin_comment
comment|/* convert double to int */
end_comment

begin_function
name|long
name|long
name|__fixdfdi
parameter_list|(
name|double
name|a1
parameter_list|)
block|{
specifier|register
name|union
name|double_long
name|dl1
decl_stmt|;
specifier|register
name|int
name|exp
decl_stmt|;
specifier|register
name|long
name|long
name|l
decl_stmt|;
name|dl1
operator|.
name|d
operator|=
name|a1
expr_stmt|;
if|if
condition|(
operator|!
name|dl1
operator|.
name|l
operator|.
name|upper
operator|&&
operator|!
name|dl1
operator|.
name|l
operator|.
name|lower
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|exp
operator|=
name|EXPD
argument_list|(
name|dl1
argument_list|)
operator|-
name|EXCESSD
operator|-
literal|64
expr_stmt|;
name|l
operator|=
name|MANTD_LL
argument_list|(
name|dl1
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|>
literal|0
condition|)
block|{
name|l
operator|=
operator|(
name|long
name|long
operator|)
literal|1
operator|<<
literal|63
expr_stmt|;
if|if
condition|(
operator|!
name|SIGND
argument_list|(
name|dl1
argument_list|)
condition|)
name|l
operator|--
expr_stmt|;
return|return
name|l
return|;
block|}
comment|/* shift down until exp = 0 or l = 0 */
if|if
condition|(
name|exp
operator|<
literal|0
operator|&&
name|exp
operator|>
operator|-
literal|64
operator|&&
name|l
condition|)
name|l
operator|>>=
operator|-
name|exp
expr_stmt|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|SIGND
argument_list|(
name|dl1
argument_list|)
condition|?
operator|-
name|l
else|:
name|l
operator|)
return|;
block|}
end_function

begin_comment
comment|/* convert double to unsigned int */
end_comment

begin_function
name|unsigned
name|long
name|__fixunsdfsi
parameter_list|(
name|double
name|a1
parameter_list|)
block|{
specifier|register
name|union
name|double_long
name|dl1
decl_stmt|;
specifier|register
name|int
name|exp
decl_stmt|;
specifier|register
name|unsigned
name|long
name|l
decl_stmt|;
name|dl1
operator|.
name|d
operator|=
name|a1
expr_stmt|;
if|if
condition|(
operator|!
name|dl1
operator|.
name|l
operator|.
name|upper
operator|&&
operator|!
name|dl1
operator|.
name|l
operator|.
name|lower
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|exp
operator|=
name|EXPD
argument_list|(
name|dl1
argument_list|)
operator|-
name|EXCESSD
operator|-
literal|32
expr_stmt|;
name|l
operator|=
operator|(
operator|(
operator|(
operator|(
operator|(
name|dl1
operator|.
name|l
operator|.
name|upper
operator|)
operator|&
literal|0xFFFFF
operator|)
operator||
name|HIDDEND
operator|)
operator|<<
literal|11
operator|)
operator||
operator|(
name|dl1
operator|.
name|l
operator|.
name|lower
operator|>>
literal|21
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|exp
operator|>
literal|0
condition|)
return|return
operator|(
literal|0xFFFFFFFFul
operator|)
return|;
comment|/* largest integer */
comment|/* shift down until exp = 0 or l = 0 */
if|if
condition|(
name|exp
operator|<
literal|0
operator|&&
name|exp
operator|>
operator|-
literal|32
operator|&&
name|l
condition|)
name|l
operator|>>=
operator|-
name|exp
expr_stmt|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|l
operator|)
return|;
block|}
end_function

begin_comment
comment|/* convert double to unsigned int */
end_comment

begin_function
name|unsigned
name|long
name|long
name|__fixunsdfdi
parameter_list|(
name|double
name|a1
parameter_list|)
block|{
specifier|register
name|union
name|double_long
name|dl1
decl_stmt|;
specifier|register
name|int
name|exp
decl_stmt|;
specifier|register
name|unsigned
name|long
name|long
name|l
decl_stmt|;
name|dl1
operator|.
name|d
operator|=
name|a1
expr_stmt|;
if|if
condition|(
name|dl1
operator|.
name|ll
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|exp
operator|=
name|EXPD
argument_list|(
name|dl1
argument_list|)
operator|-
name|EXCESSD
operator|-
literal|64
expr_stmt|;
name|l
operator|=
name|dl1
operator|.
name|ll
expr_stmt|;
if|if
condition|(
name|exp
operator|>
literal|0
condition|)
return|return
operator|(
name|unsigned
name|long
name|long
operator|)
operator|-
literal|1
return|;
comment|/* shift down until exp = 0 or l = 0 */
if|if
condition|(
name|exp
operator|<
literal|0
operator|&&
name|exp
operator|>
operator|-
literal|64
operator|&&
name|l
condition|)
name|l
operator|>>=
operator|-
name|exp
expr_stmt|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|l
operator|)
return|;
block|}
end_function

begin_comment
comment|/* addtwo doubles */
end_comment

begin_function
name|double
name|__adddf3
parameter_list|(
name|double
name|a1
parameter_list|,
name|double
name|a2
parameter_list|)
block|{
specifier|register
name|long
name|long
name|mant1
decl_stmt|,
name|mant2
decl_stmt|;
specifier|register
name|union
name|double_long
name|fl1
decl_stmt|,
name|fl2
decl_stmt|;
specifier|register
name|int
name|exp1
decl_stmt|,
name|exp2
decl_stmt|;
name|int
name|sign
init|=
literal|0
decl_stmt|;
name|fl1
operator|.
name|d
operator|=
name|a1
expr_stmt|;
name|fl2
operator|.
name|d
operator|=
name|a2
expr_stmt|;
comment|/* check for zero args */
if|if
condition|(
operator|!
name|fl2
operator|.
name|ll
condition|)
goto|goto
name|test_done
goto|;
if|if
condition|(
operator|!
name|fl1
operator|.
name|ll
condition|)
block|{
name|fl1
operator|.
name|d
operator|=
name|fl2
operator|.
name|d
expr_stmt|;
goto|goto
name|test_done
goto|;
block|}
name|exp1
operator|=
name|EXPD
argument_list|(
name|fl1
argument_list|)
expr_stmt|;
name|exp2
operator|=
name|EXPD
argument_list|(
name|fl2
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp1
operator|>
name|exp2
operator|+
literal|54
condition|)
goto|goto
name|test_done
goto|;
if|if
condition|(
name|exp2
operator|>
name|exp1
operator|+
literal|54
condition|)
block|{
name|fl1
operator|.
name|d
operator|=
name|fl2
operator|.
name|d
expr_stmt|;
goto|goto
name|test_done
goto|;
block|}
comment|/* do everything in excess precision so's we can round later */
name|mant1
operator|=
name|MANTD_LL
argument_list|(
name|fl1
argument_list|)
operator|<<
literal|9
expr_stmt|;
name|mant2
operator|=
name|MANTD_LL
argument_list|(
name|fl2
argument_list|)
operator|<<
literal|9
expr_stmt|;
if|if
condition|(
name|SIGND
argument_list|(
name|fl1
argument_list|)
condition|)
name|mant1
operator|=
operator|-
name|mant1
expr_stmt|;
if|if
condition|(
name|SIGND
argument_list|(
name|fl2
argument_list|)
condition|)
name|mant2
operator|=
operator|-
name|mant2
expr_stmt|;
if|if
condition|(
name|exp1
operator|>
name|exp2
condition|)
name|mant2
operator|>>=
name|exp1
operator|-
name|exp2
expr_stmt|;
else|else
block|{
name|mant1
operator|>>=
name|exp2
operator|-
name|exp1
expr_stmt|;
name|exp1
operator|=
name|exp2
expr_stmt|;
block|}
name|mant1
operator|+=
name|mant2
expr_stmt|;
if|if
condition|(
name|mant1
operator|<
literal|0
condition|)
block|{
name|mant1
operator|=
operator|-
name|mant1
expr_stmt|;
name|sign
operator|=
name|SIGNBIT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|mant1
condition|)
block|{
name|fl1
operator|.
name|d
operator|=
literal|0
expr_stmt|;
goto|goto
name|test_done
goto|;
block|}
comment|/* normalize up */
while|while
condition|(
operator|!
operator|(
name|mant1
operator|&
operator|(
operator|(
name|long
name|long
operator|)
literal|7
operator|<<
literal|61
operator|)
operator|)
condition|)
block|{
name|mant1
operator|<<=
literal|1
expr_stmt|;
name|exp1
operator|--
expr_stmt|;
block|}
comment|/* normalize down? */
if|if
condition|(
name|mant1
operator|&
operator|(
operator|(
name|long
name|long
operator|)
literal|3
operator|<<
literal|62
operator|)
condition|)
block|{
name|mant1
operator|>>=
literal|1
expr_stmt|;
name|exp1
operator|++
expr_stmt|;
block|}
comment|/* round to even */
name|mant1
operator|+=
operator|(
name|mant1
operator|&
operator|(
literal|1
operator|<<
literal|9
operator|)
operator|)
condition|?
operator|(
literal|1
operator|<<
literal|8
operator|)
else|:
operator|(
operator|(
literal|1
operator|<<
literal|8
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* normalize down? */
if|if
condition|(
name|mant1
operator|&
operator|(
operator|(
name|long
name|long
operator|)
literal|3
operator|<<
literal|62
operator|)
condition|)
block|{
name|mant1
operator|>>=
literal|1
expr_stmt|;
name|exp1
operator|++
expr_stmt|;
block|}
comment|/* lose extra precision */
name|mant1
operator|>>=
literal|9
expr_stmt|;
comment|/* turn off hidden bit */
name|mant1
operator|&=
operator|~
name|HIDDEND_LL
expr_stmt|;
comment|/* pack up and go home */
name|fl1
operator|.
name|ll
operator|=
name|PACKD_LL
argument_list|(
name|sign
argument_list|,
name|exp1
argument_list|,
name|mant1
argument_list|)
expr_stmt|;
name|test_done
label|:
return|return
operator|(
name|fl1
operator|.
name|d
operator|)
return|;
block|}
end_function

begin_comment
comment|/* subtract two doubles */
end_comment

begin_function
name|double
name|__subdf3
parameter_list|(
name|double
name|a1
parameter_list|,
name|double
name|a2
parameter_list|)
block|{
specifier|register
name|union
name|double_long
name|fl1
decl_stmt|,
name|fl2
decl_stmt|;
name|fl1
operator|.
name|d
operator|=
name|a1
expr_stmt|;
name|fl2
operator|.
name|d
operator|=
name|a2
expr_stmt|;
comment|/* check for zero args */
if|if
condition|(
operator|!
name|fl2
operator|.
name|ll
condition|)
return|return
operator|(
name|fl1
operator|.
name|d
operator|)
return|;
comment|/* twiddle sign bit and add */
name|fl2
operator|.
name|l
operator|.
name|upper
operator|^=
name|SIGNBIT
expr_stmt|;
if|if
condition|(
operator|!
name|fl1
operator|.
name|ll
condition|)
return|return
operator|(
name|fl2
operator|.
name|d
operator|)
return|;
return|return
name|__adddf3
argument_list|(
name|a1
argument_list|,
name|fl2
operator|.
name|d
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* multiply two doubles */
end_comment

begin_function
name|double
name|__muldf3
parameter_list|(
name|double
name|a1
parameter_list|,
name|double
name|a2
parameter_list|)
block|{
specifier|register
name|union
name|double_long
name|fl1
decl_stmt|,
name|fl2
decl_stmt|;
specifier|register
name|unsigned
name|long
name|long
name|result
decl_stmt|;
specifier|register
name|int
name|exp
decl_stmt|;
name|int
name|sign
decl_stmt|;
name|fl1
operator|.
name|d
operator|=
name|a1
expr_stmt|;
name|fl2
operator|.
name|d
operator|=
name|a2
expr_stmt|;
if|if
condition|(
operator|!
name|fl1
operator|.
name|ll
operator|||
operator|!
name|fl2
operator|.
name|ll
condition|)
block|{
name|fl1
operator|.
name|d
operator|=
literal|0
expr_stmt|;
goto|goto
name|test_done
goto|;
block|}
comment|/* compute sign and exponent */
name|sign
operator|=
name|SIGND
argument_list|(
name|fl1
argument_list|)
operator|^
name|SIGND
argument_list|(
name|fl2
argument_list|)
expr_stmt|;
name|exp
operator|=
name|EXPD
argument_list|(
name|fl1
argument_list|)
operator|-
name|EXCESSD
expr_stmt|;
name|exp
operator|+=
name|EXPD
argument_list|(
name|fl2
argument_list|)
expr_stmt|;
name|fl1
operator|.
name|ll
operator|=
name|MANTD_LL
argument_list|(
name|fl1
argument_list|)
expr_stmt|;
name|fl2
operator|.
name|ll
operator|=
name|MANTD_LL
argument_list|(
name|fl2
argument_list|)
expr_stmt|;
comment|/* the multiply is done as one 31x31 multiply and two 31x21 multiples */
name|result
operator|=
operator|(
name|fl1
operator|.
name|ll
operator|>>
literal|21
operator|)
operator|*
operator|(
name|fl2
operator|.
name|ll
operator|>>
literal|21
operator|)
expr_stmt|;
name|result
operator|+=
operator|(
operator|(
name|fl1
operator|.
name|ll
operator|&
literal|0x1FFFFF
operator|)
operator|*
operator|(
name|fl2
operator|.
name|ll
operator|>>
literal|21
operator|)
operator|)
operator|>>
literal|21
expr_stmt|;
name|result
operator|+=
operator|(
operator|(
name|fl2
operator|.
name|ll
operator|&
literal|0x1FFFFF
operator|)
operator|*
operator|(
name|fl1
operator|.
name|ll
operator|>>
literal|21
operator|)
operator|)
operator|>>
literal|21
expr_stmt|;
name|result
operator|>>=
literal|2
expr_stmt|;
if|if
condition|(
name|result
operator|&
operator|(
operator|(
name|long
name|long
operator|)
literal|1
operator|<<
literal|61
operator|)
condition|)
block|{
comment|/* round */
name|result
operator|+=
literal|1
operator|<<
literal|8
expr_stmt|;
name|result
operator|>>=
literal|9
expr_stmt|;
block|}
else|else
block|{
comment|/* round */
name|result
operator|+=
literal|1
operator|<<
literal|7
expr_stmt|;
name|result
operator|>>=
literal|8
expr_stmt|;
name|exp
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|&
operator|(
name|HIDDEND_LL
operator|<<
literal|1
operator|)
condition|)
block|{
name|result
operator|>>=
literal|1
expr_stmt|;
name|exp
operator|++
expr_stmt|;
block|}
name|result
operator|&=
operator|~
name|HIDDEND_LL
expr_stmt|;
comment|/* pack up and go home */
name|fl1
operator|.
name|ll
operator|=
name|PACKD_LL
argument_list|(
name|sign
argument_list|,
name|exp
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|test_done
label|:
return|return
operator|(
name|fl1
operator|.
name|d
operator|)
return|;
block|}
end_function

begin_comment
comment|/* divide two doubles */
end_comment

begin_function
name|double
name|__divdf3
parameter_list|(
name|double
name|a1
parameter_list|,
name|double
name|a2
parameter_list|)
block|{
specifier|register
name|union
name|double_long
name|fl1
decl_stmt|,
name|fl2
decl_stmt|;
specifier|register
name|long
name|long
name|mask
decl_stmt|,
name|result
decl_stmt|;
specifier|register
name|int
name|exp
decl_stmt|,
name|sign
decl_stmt|;
name|fl1
operator|.
name|d
operator|=
name|a1
expr_stmt|;
name|fl2
operator|.
name|d
operator|=
name|a2
expr_stmt|;
comment|/* subtract exponents */
name|exp
operator|=
name|EXPD
argument_list|(
name|fl1
argument_list|)
operator|-
name|EXPD
argument_list|(
name|fl2
argument_list|)
operator|+
name|EXCESSD
expr_stmt|;
comment|/* compute sign */
name|sign
operator|=
name|SIGND
argument_list|(
name|fl1
argument_list|)
operator|^
name|SIGND
argument_list|(
name|fl2
argument_list|)
expr_stmt|;
comment|/* numerator zero??? */
if|if
condition|(
name|fl1
operator|.
name|ll
operator|==
literal|0
condition|)
block|{
comment|/* divide by zero??? */
if|if
condition|(
name|fl2
operator|.
name|ll
operator|==
literal|0
condition|)
name|fl1
operator|.
name|ll
operator|=
operator|(
operator|(
name|unsigned
name|long
name|long
operator|)
literal|1
operator|<<
literal|63
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* NaN */
else|else
name|fl1
operator|.
name|ll
operator|=
literal|0
expr_stmt|;
goto|goto
name|test_done
goto|;
block|}
comment|/* return +Inf or -Inf */
if|if
condition|(
name|fl2
operator|.
name|ll
operator|==
literal|0
condition|)
block|{
name|fl1
operator|.
name|ll
operator|=
name|PACKD_LL
argument_list|(
name|SIGND
argument_list|(
name|fl1
argument_list|)
argument_list|,
literal|2047
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|test_done
goto|;
block|}
comment|/* now get mantissas */
name|fl1
operator|.
name|ll
operator|=
name|MANTD_LL
argument_list|(
name|fl1
argument_list|)
expr_stmt|;
name|fl2
operator|.
name|ll
operator|=
name|MANTD_LL
argument_list|(
name|fl2
argument_list|)
expr_stmt|;
comment|/* this assures we have 54 bits of precision in the end */
if|if
condition|(
name|fl1
operator|.
name|ll
operator|<
name|fl2
operator|.
name|ll
condition|)
block|{
name|fl1
operator|.
name|ll
operator|<<=
literal|1
expr_stmt|;
name|exp
operator|--
expr_stmt|;
block|}
comment|/* now we perform repeated subtraction of fl2.ll from fl1.ll */
name|mask
operator|=
operator|(
name|long
name|long
operator|)
literal|1
operator|<<
literal|53
expr_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|mask
condition|)
block|{
if|if
condition|(
name|fl1
operator|.
name|ll
operator|>=
name|fl2
operator|.
name|ll
condition|)
block|{
name|result
operator||=
name|mask
expr_stmt|;
name|fl1
operator|.
name|ll
operator|-=
name|fl2
operator|.
name|ll
expr_stmt|;
block|}
name|fl1
operator|.
name|ll
operator|<<=
literal|1
expr_stmt|;
name|mask
operator|>>=
literal|1
expr_stmt|;
block|}
comment|/* round */
name|result
operator|+=
literal|1
expr_stmt|;
comment|/* normalize down */
name|exp
operator|++
expr_stmt|;
name|result
operator|>>=
literal|1
expr_stmt|;
name|result
operator|&=
operator|~
name|HIDDEND_LL
expr_stmt|;
comment|/* pack up and go home */
name|fl1
operator|.
name|ll
operator|=
name|PACKD_LL
argument_list|(
name|sign
argument_list|,
name|exp
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|test_done
label|:
return|return
operator|(
name|fl1
operator|.
name|d
operator|)
return|;
block|}
end_function

begin_function
name|int
name|__gtdf2
parameter_list|(
name|double
name|a1
parameter_list|,
name|double
name|a2
parameter_list|)
block|{
return|return
name|__cmpdf2
argument_list|(
operator|(
name|float
operator|)
name|a1
argument_list|,
operator|(
name|float
operator|)
name|a2
argument_list|)
operator|>
literal|0
return|;
block|}
end_function

begin_function
name|int
name|__gedf2
parameter_list|(
name|double
name|a1
parameter_list|,
name|double
name|a2
parameter_list|)
block|{
return|return
operator|(
name|__cmpdf2
argument_list|(
operator|(
name|float
operator|)
name|a1
argument_list|,
operator|(
name|float
operator|)
name|a2
argument_list|)
operator|>=
literal|0
operator|)
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|int
name|__ltdf2
parameter_list|(
name|double
name|a1
parameter_list|,
name|double
name|a2
parameter_list|)
block|{
return|return
operator|-
operator|(
name|__cmpdf2
argument_list|(
operator|(
name|float
operator|)
name|a1
argument_list|,
operator|(
name|float
operator|)
name|a2
argument_list|)
operator|<
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|__ledf2
parameter_list|(
name|double
name|a1
parameter_list|,
name|double
name|a2
parameter_list|)
block|{
return|return
name|__cmpdf2
argument_list|(
operator|(
name|float
operator|)
name|a1
argument_list|,
operator|(
name|float
operator|)
name|a2
argument_list|)
operator|>
literal|0
return|;
block|}
end_function

begin_function
name|int
name|__eqdf2
parameter_list|(
name|double
name|a1
parameter_list|,
name|double
name|a2
parameter_list|)
block|{
return|return
operator|*
operator|(
name|long
name|long
operator|*
operator|)
operator|&
name|a1
operator|==
operator|*
operator|(
name|long
name|long
operator|*
operator|)
operator|&
name|a2
return|;
block|}
end_function

begin_function
name|int
name|__nedf2
parameter_list|(
name|double
name|a1
parameter_list|,
name|double
name|a2
parameter_list|)
block|{
return|return
operator|*
operator|(
name|long
name|long
operator|*
operator|)
operator|&
name|a1
operator|!=
operator|*
operator|(
name|long
name|long
operator|*
operator|)
operator|&
name|a2
return|;
block|}
end_function

end_unit

