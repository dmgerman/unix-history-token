begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Process declarations and variables for C compiler.    Copyright (C) 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,    2001, 2002 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* Process declarations and symbol lookup for C front end.    Also constructs types; the standard scalar types at initialization,    and structure, union, array and enum types when they are declared.  */
end_comment

begin_comment
comment|/* ??? not all decl nodes are given the most useful possible    line numbers.  For example, the CONST_DECLs for enum values.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"intl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"tree-inline.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"c-tree.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"cpplib.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"debug.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"c-common.h"
end_include

begin_include
include|#
directive|include
file|"c-pragma.h"
end_include

begin_include
include|#
directive|include
file|"libfuncs.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_comment
comment|/* In grokdeclarator, distinguish syntactic contexts of declarators.  */
end_comment

begin_enum
enum|enum
name|decl_context
block|{
name|NORMAL
block|,
comment|/* Ordinary declaration */
name|FUNCDEF
block|,
comment|/* Function definition */
name|PARM
block|,
comment|/* Declaration of parm before function body */
name|FIELD
block|,
comment|/* Declaration inside struct or union */
name|BITFIELD
block|,
comment|/* Likewise but with specified width */
name|TYPENAME
block|}
enum|;
end_enum

begin_comment
comment|/* Typename (inside cast or sizeof)  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Nonzero if we have seen an invalid cross reference    to a struct, union, or enum, but not yet printed the message.  */
end_comment

begin_decl_stmt
name|tree
name|pending_invalid_xref
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* File and line to appear in the eventual error message.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|pending_invalid_xref_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pending_invalid_xref_line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* While defining an enum type, this is 1 plus the last enumerator    constant value.  Note that will do not have to save this or `enum_overflow'    around nested function definition since such a definition could only    occur in an enum value expression and we don't use these variables in    that case.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|enum_next_value
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means that there was overflow computing enum_next_value.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|enum_overflow
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parsing a function declarator leaves a list of parameter names    or a chain or parameter decls here.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|last_function_parms
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parsing a function declarator leaves here a chain of structure    and enum types declared in the parmlist.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|last_function_parm_tags
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* After parsing the declarator that starts a function definition,    `start_function' puts here the list of parameter names or chain of decls.    `store_parm_decls' finds it here.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|current_function_parms
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Similar, for last_function_parm_tags.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|current_function_parm_tags
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Similar, for the file and line that the prototype came from if this is    an old-style definition.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|current_function_prototype_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|current_function_prototype_line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The current statement tree.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
expr|struct
name|stmt_tree_s
name|c_stmt_tree
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* The current scope statement stack.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|c_scope_stmt_stack
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* A list (chain of TREE_LIST nodes) of all LABEL_DECLs in the function    that have names.  Here so we can clear out their names' definitions    at the end of the function.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|named_labels
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* A list of LABEL_DECLs from outer contexts that are currently shadowed.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|shadowed_labels
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Set to 0 at beginning of a function definition, set to 1 if    a return statement that specifies a return value is seen.  */
end_comment

begin_decl_stmt
name|int
name|current_function_returns_value
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to 0 at beginning of a function definition, set to 1 if    a return statement with no argument is seen.  */
end_comment

begin_decl_stmt
name|int
name|current_function_returns_null
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to 0 at beginning of a function definition, set to 1 if    a call to a noreturn function is seen.  */
end_comment

begin_decl_stmt
name|int
name|current_function_returns_abnormally
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to nonzero by `grokdeclarator' for a function    whose return type is defaulted, if warnings for this are desired.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|warn_about_return_type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero when starting a function declared `extern inline'.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|current_extern_inline
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* For each binding contour we allocate a binding_level structure  * which records the names defined in that contour.  * Contours include:  *  0) the global one  *  1) one for each function definition,  *     where internal declarations of the parameters appear.  *  2) one for each compound statement,  *     to record its declarations.  *  * The current meaning of a name can be found by searching the levels from  * the current one out to the global one.  */
end_comment

begin_comment
comment|/* Note that the information in the `names' component of the global contour    is duplicated in the IDENTIFIER_GLOBAL_VALUEs of all identifiers.  */
end_comment

begin_decl_stmt
name|struct
name|binding_level
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
comment|/* A chain of _DECL nodes for all variables, constants, functions,        and typedef types.  These are in the reverse of the order supplied.      */
name|tree
name|names
decl_stmt|;
comment|/* A list of structure, union and enum definitions,      * for looking up tag names.      * It is a chain of TREE_LIST nodes, each of whose TREE_PURPOSE is a name,      * or NULL_TREE; and whose TREE_VALUE is a RECORD_TYPE, UNION_TYPE,      * or ENUMERAL_TYPE node.      */
name|tree
name|tags
decl_stmt|;
comment|/* For each level, a list of shadowed outer-level local definitions        to be restored when this level is popped.        Each link is a TREE_LIST whose TREE_PURPOSE is an identifier and        whose TREE_VALUE is its old definition (a kind of ..._DECL node).  */
name|tree
name|shadowed
decl_stmt|;
comment|/* For each level (except not the global one),        a chain of BLOCK nodes for all the levels        that were entered and exited one level down.  */
name|tree
name|blocks
decl_stmt|;
comment|/* The BLOCK node for this level, if one has been preallocated.        If 0, the BLOCK is allocated (if needed) when the level is popped.  */
name|tree
name|this_block
decl_stmt|;
comment|/* The binding level which this one is contained in (inherits from).  */
name|struct
name|binding_level
modifier|*
name|level_chain
decl_stmt|;
comment|/* Nonzero for the level that holds the parameters of a function.  */
name|char
name|parm_flag
decl_stmt|;
comment|/* Nonzero if this level "doesn't exist" for tags.  */
name|char
name|tag_transparent
decl_stmt|;
comment|/* Nonzero if sublevels of this level "don't exist" for tags.        This is set in the parm level of a function definition        while reading the function body, so that the outermost block        of the function body will be tag-transparent.  */
name|char
name|subblocks_tag_transparent
decl_stmt|;
comment|/* Nonzero means make a BLOCK for this level regardless of all else.  */
name|char
name|keep
decl_stmt|;
comment|/* Nonzero means make a BLOCK if this level has any subblocks.  */
name|char
name|keep_if_subblocks
decl_stmt|;
comment|/* List of decls in `names' that have incomplete structure or        union types.  */
name|tree
name|incomplete_list
decl_stmt|;
comment|/* A list of decls giving the (reversed) specified order of parms,        not including any forward-decls in the parmlist.        This is so we can put the parms in proper order for assign_parms.  */
name|tree
name|parm_order
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_define
define|#
directive|define
name|NULL_BINDING_LEVEL
value|(struct binding_level *) NULL
end_define

begin_comment
comment|/* The binding level currently in effect.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
expr|struct
name|binding_level
operator|*
name|current_binding_level
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* A chain of binding_level structures awaiting reuse.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|(deletable (
literal|""
argument|))
argument_list|)
expr|struct
name|binding_level
operator|*
name|free_binding_level
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* The outermost binding level, for names of file scope.    This is created when the compiler is started and exists    through the entire run.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
expr|struct
name|binding_level
operator|*
name|global_binding_level
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Binding level structures are initialized by copying this one.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|binding_level
name|clear_binding_level
init|=
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL_BINDING_LEVEL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means unconditionally make a BLOCK for the next level pushed.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|keep_next_level_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means make a BLOCK for the next level pushed    if it has subblocks.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|keep_next_if_subblocks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The chain of outer levels of label scopes.    This uses the same data structure used for binding levels,    but it works differently: each link in the chain records    saved values of named_labels and shadowed_labels for    a label binding level outside the current one.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
expr|struct
name|binding_level
operator|*
name|label_level_chain
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Functions called automatically at the beginning and end of execution.  */
end_comment

begin_decl_stmt
name|tree
name|static_ctors
decl_stmt|,
name|static_dtors
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward declarations.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|binding_level
modifier|*
name|make_binding_level
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pop_binding_level
name|PARAMS
argument_list|(
operator|(
expr|struct
name|binding_level
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|clear_limbo_values
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|duplicate_decls
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|redeclaration_error_message
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|storedecls
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|storetags
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|lookup_tag
name|PARAMS
argument_list|(
operator|(
expr|enum
name|tree_code
operator|,
name|tree
operator|,
expr|struct
name|binding_level
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|lookup_tag_reverse
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|grokdeclarator
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
expr|enum
name|decl_context
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|grokparms
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|layout_array_type
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|c_make_fname_decl
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|c_expand_body
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|warn_if_shadowing
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|flexible_array_type_p
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|set_save_expr_context
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|int
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* States indicating how grokdeclarator() should handle declspecs marked    with __attribute__((deprecated)).  An object declared as    __attribute__((deprecated)) suppresses warnings of uses of other    deprecated items.  */
end_comment

begin_enum
enum|enum
name|deprecated_states
block|{
name|DEPRECATED_NORMAL
block|,
name|DEPRECATED_SUPPRESS
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
name|enum
name|deprecated_states
name|deprecated_state
init|=
name|DEPRECATED_NORMAL
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|c_print_identifier
parameter_list|(
name|file
parameter_list|,
name|node
parameter_list|,
name|indent
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|tree
name|node
decl_stmt|;
name|int
name|indent
decl_stmt|;
block|{
name|print_node
argument_list|(
name|file
argument_list|,
literal|"global"
argument_list|,
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|node
argument_list|)
argument_list|,
name|indent
operator|+
literal|4
argument_list|)
expr_stmt|;
name|print_node
argument_list|(
name|file
argument_list|,
literal|"local"
argument_list|,
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|node
argument_list|)
argument_list|,
name|indent
operator|+
literal|4
argument_list|)
expr_stmt|;
name|print_node
argument_list|(
name|file
argument_list|,
literal|"label"
argument_list|,
name|IDENTIFIER_LABEL_VALUE
argument_list|(
name|node
argument_list|)
argument_list|,
name|indent
operator|+
literal|4
argument_list|)
expr_stmt|;
name|print_node
argument_list|(
name|file
argument_list|,
literal|"implicit"
argument_list|,
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|node
argument_list|)
argument_list|,
name|indent
operator|+
literal|4
argument_list|)
expr_stmt|;
name|print_node
argument_list|(
name|file
argument_list|,
literal|"error locus"
argument_list|,
name|IDENTIFIER_ERROR_LOCUS
argument_list|(
name|node
argument_list|)
argument_list|,
name|indent
operator|+
literal|4
argument_list|)
expr_stmt|;
name|print_node
argument_list|(
name|file
argument_list|,
literal|"limbo value"
argument_list|,
name|IDENTIFIER_LIMBO_VALUE
argument_list|(
name|node
argument_list|)
argument_list|,
name|indent
operator|+
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|C_IS_RESERVED_WORD
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|tree
name|rid
init|=
name|ridpointers
index|[
name|C_RID_CODE
argument_list|(
name|node
argument_list|)
index|]
decl_stmt|;
name|indent_to
argument_list|(
name|file
argument_list|,
name|indent
operator|+
literal|4
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"rid "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_PTR_PRINTF
argument_list|,
operator|(
name|void
operator|*
operator|)
name|rid
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" \"%s\""
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|rid
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Hook called at end of compilation to assume 1 elt    for a top-level tentative array defn that wasn't complete before.  */
end_comment

begin_function
name|void
name|c_finish_incomplete_decl
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|!=
name|error_mark_node
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
block|{
name|warning_with_decl
argument_list|(
name|decl
argument_list|,
literal|"array `%s' assumed to have one element"
argument_list|)
expr_stmt|;
name|complete_array_type
argument_list|(
name|type
argument_list|,
name|NULL_TREE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|layout_decl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Reuse or create a struct for this binding level.  */
end_comment

begin_function
specifier|static
name|struct
name|binding_level
modifier|*
name|make_binding_level
parameter_list|()
block|{
if|if
condition|(
name|free_binding_level
condition|)
block|{
name|struct
name|binding_level
modifier|*
name|result
init|=
name|free_binding_level
decl_stmt|;
name|free_binding_level
operator|=
name|result
operator|->
name|level_chain
expr_stmt|;
return|return
name|result
return|;
block|}
else|else
return|return
operator|(
expr|struct
name|binding_level
operator|*
operator|)
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|binding_level
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Remove a binding level from a list and add it to the level chain.  */
end_comment

begin_function
specifier|static
name|void
name|pop_binding_level
parameter_list|(
name|lp
parameter_list|)
name|struct
name|binding_level
modifier|*
modifier|*
name|lp
decl_stmt|;
block|{
name|struct
name|binding_level
modifier|*
name|l
init|=
operator|*
name|lp
decl_stmt|;
operator|*
name|lp
operator|=
name|l
operator|->
name|level_chain
expr_stmt|;
name|memset
argument_list|(
name|l
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|binding_level
argument_list|)
argument_list|)
expr_stmt|;
name|l
operator|->
name|level_chain
operator|=
name|free_binding_level
expr_stmt|;
name|free_binding_level
operator|=
name|l
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Nonzero if we are currently in the global binding level.  */
end_comment

begin_function
name|int
name|global_bindings_p
parameter_list|()
block|{
return|return
name|current_binding_level
operator|==
name|global_binding_level
return|;
block|}
end_function

begin_function
name|void
name|keep_next_level
parameter_list|()
block|{
name|keep_next_level_flag
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Nonzero if the current level needs to have a BLOCK made.  */
end_comment

begin_function
name|int
name|kept_level_p
parameter_list|()
block|{
return|return
operator|(
operator|(
name|current_binding_level
operator|->
name|keep_if_subblocks
operator|&&
name|current_binding_level
operator|->
name|blocks
operator|!=
literal|0
operator|)
operator|||
name|current_binding_level
operator|->
name|keep
operator|||
name|current_binding_level
operator|->
name|names
operator|!=
literal|0
operator|||
operator|(
name|current_binding_level
operator|->
name|tags
operator|!=
literal|0
operator|&&
operator|!
name|current_binding_level
operator|->
name|tag_transparent
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Identify this binding level as a level of parameters.    DEFINITION_FLAG is 1 for a definition, 0 for a declaration.    But it turns out there is no way to pass the right value for    DEFINITION_FLAG, so we ignore it.  */
end_comment

begin_function
name|void
name|declare_parm_level
parameter_list|(
name|definition_flag
parameter_list|)
name|int
name|definition_flag
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|current_binding_level
operator|->
name|parm_flag
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Nonzero if currently making parm declarations.  */
end_comment

begin_function
name|int
name|in_parm_level_p
parameter_list|()
block|{
return|return
name|current_binding_level
operator|->
name|parm_flag
return|;
block|}
end_function

begin_comment
comment|/* Enter a new binding level.    If TAG_TRANSPARENT is nonzero, do so only for the name space of variables,    not for that of tags.  */
end_comment

begin_function
name|void
name|pushlevel
parameter_list|(
name|tag_transparent
parameter_list|)
name|int
name|tag_transparent
decl_stmt|;
block|{
name|struct
name|binding_level
modifier|*
name|newlevel
init|=
name|NULL_BINDING_LEVEL
decl_stmt|;
comment|/* If this is the top level of a function,      just make sure that NAMED_LABELS is 0.  */
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
condition|)
block|{
name|named_labels
operator|=
literal|0
expr_stmt|;
block|}
name|newlevel
operator|=
name|make_binding_level
argument_list|()
expr_stmt|;
comment|/* Add this level to the front of the chain (stack) of levels that      are active.  */
operator|*
name|newlevel
operator|=
name|clear_binding_level
expr_stmt|;
name|newlevel
operator|->
name|tag_transparent
operator|=
operator|(
name|tag_transparent
operator|||
operator|(
name|current_binding_level
condition|?
name|current_binding_level
operator|->
name|subblocks_tag_transparent
else|:
literal|0
operator|)
operator|)
expr_stmt|;
name|newlevel
operator|->
name|level_chain
operator|=
name|current_binding_level
expr_stmt|;
name|current_binding_level
operator|=
name|newlevel
expr_stmt|;
name|newlevel
operator|->
name|keep
operator|=
name|keep_next_level_flag
expr_stmt|;
name|keep_next_level_flag
operator|=
literal|0
expr_stmt|;
name|newlevel
operator|->
name|keep_if_subblocks
operator|=
name|keep_next_if_subblocks
expr_stmt|;
name|keep_next_if_subblocks
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clear the limbo values of all identifiers defined in BLOCK or a subblock.  */
end_comment

begin_function
specifier|static
name|void
name|clear_limbo_values
parameter_list|(
name|block
parameter_list|)
name|tree
name|block
decl_stmt|;
block|{
name|tree
name|tem
decl_stmt|;
for|for
control|(
name|tem
operator|=
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
init|;
name|tem
condition|;
name|tem
operator|=
name|TREE_CHAIN
argument_list|(
name|tem
argument_list|)
control|)
if|if
condition|(
name|DECL_NAME
argument_list|(
name|tem
argument_list|)
operator|!=
literal|0
condition|)
name|IDENTIFIER_LIMBO_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|tem
operator|=
name|BLOCK_SUBBLOCKS
argument_list|(
name|block
argument_list|)
init|;
name|tem
condition|;
name|tem
operator|=
name|TREE_CHAIN
argument_list|(
name|tem
argument_list|)
control|)
name|clear_limbo_values
argument_list|(
name|tem
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Exit a binding level.    Pop the level off, and restore the state of the identifier-decl mappings    that were in effect when this level was entered.     If KEEP is nonzero, this level had explicit declarations, so    and create a "block" (a BLOCK node) for the level    to record its declarations and subblocks for symbol table output.     If FUNCTIONBODY is nonzero, this level is the body of a function,    so create a block as if KEEP were set and also clear out all    label names.     If REVERSE is nonzero, reverse the order of decls before putting    them into the BLOCK.  */
end_comment

begin_function
name|tree
name|poplevel
parameter_list|(
name|keep
parameter_list|,
name|reverse
parameter_list|,
name|functionbody
parameter_list|)
name|int
name|keep
decl_stmt|;
name|int
name|reverse
decl_stmt|;
name|int
name|functionbody
decl_stmt|;
block|{
name|tree
name|link
decl_stmt|;
comment|/* The chain of decls was accumulated in reverse order.      Put it into forward order, just for cleanliness.  */
name|tree
name|decls
decl_stmt|;
name|tree
name|tags
init|=
name|current_binding_level
operator|->
name|tags
decl_stmt|;
name|tree
name|subblocks
init|=
name|current_binding_level
operator|->
name|blocks
decl_stmt|;
name|tree
name|block
init|=
literal|0
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|int
name|block_previously_created
decl_stmt|;
name|keep
operator||=
name|current_binding_level
operator|->
name|keep
expr_stmt|;
comment|/* This warning is turned off because it causes warnings for      declarations like `extern struct foo *x'.  */
if|#
directive|if
literal|0
comment|/* Warn about incomplete structure types in this level.  */
block|for (link = tags; link; link = TREE_CHAIN (link))     if (!COMPLETE_TYPE_P (TREE_VALUE (link)))       { 	tree type = TREE_VALUE (link); 	tree type_name = TYPE_NAME (type); 	char *id = IDENTIFIER_POINTER (TREE_CODE (type_name) == IDENTIFIER_NODE 				       ? type_name 				       : DECL_NAME (type_name)); 	switch (TREE_CODE (type)) 	  { 	  case RECORD_TYPE: 	    error ("`struct %s' incomplete in scope ending here", id); 	    break; 	  case UNION_TYPE: 	    error ("`union %s' incomplete in scope ending here", id); 	    break; 	  case ENUMERAL_TYPE: 	    error ("`enum %s' incomplete in scope ending here", id); 	    break; 	  }       }
endif|#
directive|endif
comment|/* 0 */
comment|/* Get the decls in the order they were written.      Usually current_binding_level->names is in reverse order.      But parameter decls were previously put in forward order.  */
if|if
condition|(
name|reverse
condition|)
name|current_binding_level
operator|->
name|names
operator|=
name|decls
operator|=
name|nreverse
argument_list|(
name|current_binding_level
operator|->
name|names
argument_list|)
expr_stmt|;
else|else
name|decls
operator|=
name|current_binding_level
operator|->
name|names
expr_stmt|;
comment|/* Output any nested inline functions within this block      if they weren't already output.  */
for|for
control|(
name|decl
operator|=
name|decls
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_ADDRESSABLE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* If this decl was copied from a file-scope decl 	   on account of a block-scope extern decl, 	   propagate TREE_ADDRESSABLE to the file-scope decl.  	   DECL_ABSTRACT_ORIGIN can be set to itself if warn_return_type is 	   true, since then the decl goes through save_for_inline_copying.  */
if|if
condition|(
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|&&
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|decl
argument_list|)
operator|!=
name|decl
condition|)
name|TREE_ADDRESSABLE
argument_list|(
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* We used to warn about unused variables in expand_end_bindings,      i.e. while generating RTL.  But in function-at-a-time mode we may      choose to never expand a function at all (e.g. auto inlining), so      we do this explicitly now.  */
name|warn_about_unused_variables
argument_list|(
name|getdecls
argument_list|()
argument_list|)
expr_stmt|;
comment|/* If there were any declarations or structure tags in that level,      or if this level is a function body,      create a BLOCK to record them for the life of this function.  */
name|block
operator|=
literal|0
expr_stmt|;
name|block_previously_created
operator|=
operator|(
name|current_binding_level
operator|->
name|this_block
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|block_previously_created
condition|)
name|block
operator|=
name|current_binding_level
operator|->
name|this_block
expr_stmt|;
elseif|else
if|if
condition|(
name|keep
operator|||
name|functionbody
operator|||
operator|(
name|current_binding_level
operator|->
name|keep_if_subblocks
operator|&&
name|subblocks
operator|!=
literal|0
operator|)
condition|)
name|block
operator|=
name|make_node
argument_list|(
name|BLOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|block
operator|!=
literal|0
condition|)
block|{
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
operator|=
name|decls
expr_stmt|;
name|BLOCK_SUBBLOCKS
argument_list|(
name|block
argument_list|)
operator|=
name|subblocks
expr_stmt|;
block|}
comment|/* In each subblock, record that this is its superior.  */
for|for
control|(
name|link
operator|=
name|subblocks
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
name|BLOCK_SUPERCONTEXT
argument_list|(
name|link
argument_list|)
operator|=
name|block
expr_stmt|;
comment|/* Clear out the meanings of the local variables of this level.  */
for|for
control|(
name|link
operator|=
name|decls
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|link
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* If the ident. was used or addressed via a local extern decl, 	     don't forget that fact.  */
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|link
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_USED
argument_list|(
name|link
argument_list|)
condition|)
name|TREE_USED
argument_list|(
name|DECL_NAME
argument_list|(
name|link
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_ADDRESSABLE
argument_list|(
name|link
argument_list|)
condition|)
name|TREE_ADDRESSABLE
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|link
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|link
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Restore all name-meanings of the outer levels      that were shadowed by this level.  */
for|for
control|(
name|link
operator|=
name|current_binding_level
operator|->
name|shadowed
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
expr_stmt|;
comment|/* If the level being exited is the top level of a function,      check over all the labels, and clear out the current      (function local) meanings of their names.  */
if|if
condition|(
name|functionbody
condition|)
block|{
name|clear_limbo_values
argument_list|(
name|block
argument_list|)
expr_stmt|;
comment|/* If this is the top level block of a function, 	 the vars are the function's parameters. 	 Don't leave them in the BLOCK because they are 	 found in the FUNCTION_DECL instead.  */
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Clear out the definitions of all label names, 	 since their scopes end here, 	 and add them to BLOCK_VARS.  */
for|for
control|(
name|link
operator|=
name|named_labels
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
block|{
name|tree
name|label
init|=
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
decl_stmt|;
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|label
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error_with_decl
argument_list|(
name|label
argument_list|,
literal|"label `%s' used but not defined"
argument_list|)
expr_stmt|;
comment|/* Avoid crashing later.  */
name|define_label
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|DECL_NAME
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|warn_unused_label
operator|&&
operator|!
name|TREE_USED
argument_list|(
name|label
argument_list|)
condition|)
name|warning_with_decl
argument_list|(
name|label
argument_list|,
literal|"label `%s' defined but not used"
argument_list|)
expr_stmt|;
name|IDENTIFIER_LABEL_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|label
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Put the labels into the "variables" of the 	     top-level block, so debugger can see them.  */
name|TREE_CHAIN
argument_list|(
name|label
argument_list|)
operator|=
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
expr_stmt|;
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
operator|=
name|label
expr_stmt|;
block|}
block|}
comment|/* Pop the current level, and free the structure for reuse.  */
name|pop_binding_level
argument_list|(
operator|&
name|current_binding_level
argument_list|)
expr_stmt|;
comment|/* Dispose of the block that we just made inside some higher level.  */
if|if
condition|(
name|functionbody
condition|)
name|DECL_INITIAL
argument_list|(
name|current_function_decl
argument_list|)
operator|=
name|block
expr_stmt|;
elseif|else
if|if
condition|(
name|block
condition|)
block|{
if|if
condition|(
operator|!
name|block_previously_created
condition|)
name|current_binding_level
operator|->
name|blocks
operator|=
name|chainon
argument_list|(
name|current_binding_level
operator|->
name|blocks
argument_list|,
name|block
argument_list|)
expr_stmt|;
block|}
comment|/* If we did not make a block for the level just exited,      any blocks made for inner levels      (since they cannot be recorded as subblocks in that level)      must be carried forward so they will later become subblocks      of something else.  */
elseif|else
if|if
condition|(
name|subblocks
condition|)
name|current_binding_level
operator|->
name|blocks
operator|=
name|chainon
argument_list|(
name|current_binding_level
operator|->
name|blocks
argument_list|,
name|subblocks
argument_list|)
expr_stmt|;
comment|/* Set the TYPE_CONTEXTs for all of the tagged types belonging to this      binding contour so that they point to the appropriate construct, i.e.      either to the current FUNCTION_DECL node, or else to the BLOCK node      we just constructed.       Note that for tagged types whose scope is just the formal parameter      list for some function type specification, we can't properly set      their TYPE_CONTEXTs here, because we don't have a pointer to the      appropriate FUNCTION_TYPE node readily available to us.  For those      cases, the TYPE_CONTEXTs of the relevant tagged type nodes get set      in `grokdeclarator' as soon as we have created the FUNCTION_TYPE      node which will represent the "scope" for these "parameter list local"      tagged types.  */
if|if
condition|(
name|functionbody
condition|)
for|for
control|(
name|link
operator|=
name|tags
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
name|TYPE_CONTEXT
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
operator|=
name|current_function_decl
expr_stmt|;
elseif|else
if|if
condition|(
name|block
condition|)
for|for
control|(
name|link
operator|=
name|tags
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
name|TYPE_CONTEXT
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
operator|=
name|block
expr_stmt|;
if|if
condition|(
name|block
condition|)
name|TREE_USED
argument_list|(
name|block
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|block
return|;
block|}
end_function

begin_comment
comment|/* Insert BLOCK at the end of the list of subblocks of the    current binding level.  This is used when a BIND_EXPR is expanded,    to handle the BLOCK node inside the BIND_EXPR.  */
end_comment

begin_function
name|void
name|insert_block
parameter_list|(
name|block
parameter_list|)
name|tree
name|block
decl_stmt|;
block|{
name|TREE_USED
argument_list|(
name|block
argument_list|)
operator|=
literal|1
expr_stmt|;
name|current_binding_level
operator|->
name|blocks
operator|=
name|chainon
argument_list|(
name|current_binding_level
operator|->
name|blocks
argument_list|,
name|block
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the BLOCK node for the innermost scope    (the one we are currently in).  */
end_comment

begin_function
name|void
name|set_block
parameter_list|(
name|block
parameter_list|)
name|tree
name|block
decl_stmt|;
block|{
name|current_binding_level
operator|->
name|this_block
operator|=
name|block
expr_stmt|;
name|current_binding_level
operator|->
name|names
operator|=
name|chainon
argument_list|(
name|current_binding_level
operator|->
name|names
argument_list|,
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
argument_list|)
expr_stmt|;
name|current_binding_level
operator|->
name|blocks
operator|=
name|chainon
argument_list|(
name|current_binding_level
operator|->
name|blocks
argument_list|,
name|BLOCK_SUBBLOCKS
argument_list|(
name|block
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|push_label_level
parameter_list|()
block|{
name|struct
name|binding_level
modifier|*
name|newlevel
decl_stmt|;
name|newlevel
operator|=
name|make_binding_level
argument_list|()
expr_stmt|;
comment|/* Add this level to the front of the chain (stack) of label levels.  */
name|newlevel
operator|->
name|level_chain
operator|=
name|label_level_chain
expr_stmt|;
name|label_level_chain
operator|=
name|newlevel
expr_stmt|;
name|newlevel
operator|->
name|names
operator|=
name|named_labels
expr_stmt|;
name|newlevel
operator|->
name|shadowed
operator|=
name|shadowed_labels
expr_stmt|;
name|named_labels
operator|=
literal|0
expr_stmt|;
name|shadowed_labels
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pop_label_level
parameter_list|()
block|{
name|struct
name|binding_level
modifier|*
name|level
init|=
name|label_level_chain
decl_stmt|;
name|tree
name|link
decl_stmt|,
name|prev
decl_stmt|;
comment|/* Clear out the definitions of the declared labels in this level.      Leave in the list any ordinary, non-declared labels.  */
for|for
control|(
name|link
operator|=
name|named_labels
operator|,
name|prev
operator|=
literal|0
init|;
name|link
condition|;
control|)
block|{
if|if
condition|(
name|C_DECLARED_LABEL_FLAG
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_SOURCE_LINE
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error_with_decl
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|,
literal|"label `%s' used but not defined"
argument_list|)
expr_stmt|;
comment|/* Avoid crashing later.  */
name|define_label
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|DECL_NAME
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|warn_unused_label
operator|&&
operator|!
name|TREE_USED
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
condition|)
name|warning_with_decl
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|,
literal|"label `%s' defined but not used"
argument_list|)
expr_stmt|;
name|IDENTIFIER_LABEL_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Delete this element from the list.  */
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
condition|)
name|TREE_CHAIN
argument_list|(
name|prev
argument_list|)
operator|=
name|link
expr_stmt|;
else|else
name|named_labels
operator|=
name|link
expr_stmt|;
block|}
else|else
block|{
name|prev
operator|=
name|link
expr_stmt|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Bring back all the labels that were shadowed.  */
for|for
control|(
name|link
operator|=
name|shadowed_labels
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
if|if
condition|(
name|DECL_NAME
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|IDENTIFIER_LABEL_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
expr_stmt|;
name|named_labels
operator|=
name|chainon
argument_list|(
name|named_labels
argument_list|,
name|level
operator|->
name|names
argument_list|)
expr_stmt|;
name|shadowed_labels
operator|=
name|level
operator|->
name|shadowed
expr_stmt|;
comment|/* Pop the current level, and free the structure for reuse.  */
name|pop_binding_level
argument_list|(
operator|&
name|label_level_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Push a definition or a declaration of struct, union or enum tag "name".    "type" should be the type node.    We assume that the tag "name" is not already defined.     Note that the definition may really be just a forward reference.    In that case, the TYPE_SIZE will be zero.  */
end_comment

begin_function
name|void
name|pushtag
parameter_list|(
name|name
parameter_list|,
name|type
parameter_list|)
name|tree
name|name
decl_stmt|,
name|type
decl_stmt|;
block|{
name|struct
name|binding_level
modifier|*
name|b
decl_stmt|;
comment|/* Find the proper binding level for this type tag.  */
for|for
control|(
name|b
operator|=
name|current_binding_level
init|;
name|b
operator|->
name|tag_transparent
condition|;
name|b
operator|=
name|b
operator|->
name|level_chain
control|)
continue|continue;
if|if
condition|(
name|name
condition|)
block|{
comment|/* Record the identifier as the type's name if it has none.  */
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|=
name|name
expr_stmt|;
block|}
name|b
operator|->
name|tags
operator|=
name|tree_cons
argument_list|(
name|name
argument_list|,
name|type
argument_list|,
name|b
operator|->
name|tags
argument_list|)
expr_stmt|;
comment|/* Create a fake NULL-named TYPE_DECL node whose TREE_TYPE will be the      tagged type we just added to the current binding level.  This fake      NULL-named TYPE_DECL node helps dwarfout.c to know when it needs      to output a representation of a tagged type, and it also gives      us a convenient place to record the "scope start" address for the      tagged type.  */
name|TYPE_STUB_DECL
argument_list|(
name|type
argument_list|)
operator|=
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* An approximation for now, so we can tell this is a function-scope tag.      This will be updated in poplevel.  */
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
operator|=
name|DECL_CONTEXT
argument_list|(
name|TYPE_STUB_DECL
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Handle when a new declaration NEWDECL    has the same name as an old one OLDDECL    in the same binding contour.    Prints an error message if appropriate.     If safely possible, alter OLDDECL to look like NEWDECL, and return 1.    Otherwise, return 0.     When DIFFERENT_BINDING_LEVEL is true, NEWDECL is an external declaration,    and OLDDECL is in an outer binding level and should thus not be changed.  */
end_comment

begin_function
specifier|static
name|int
name|duplicate_decls
parameter_list|(
name|newdecl
parameter_list|,
name|olddecl
parameter_list|,
name|different_binding_level
parameter_list|)
name|tree
name|newdecl
decl_stmt|,
name|olddecl
decl_stmt|;
name|int
name|different_binding_level
decl_stmt|;
block|{
name|int
name|types_match
init|=
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|new_is_definition
init|=
operator|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|!=
literal|0
operator|)
decl_stmt|;
name|tree
name|oldtype
init|=
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
decl_stmt|;
name|tree
name|newtype
init|=
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
decl_stmt|;
name|int
name|errmsg
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|DECL_P
argument_list|(
name|olddecl
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|(
name|DECL_UNINLINABLE
argument_list|(
name|newdecl
argument_list|)
operator|||
name|DECL_UNINLINABLE
argument_list|(
name|olddecl
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|DECL_DECLARED_INLINE_P
argument_list|(
name|newdecl
argument_list|)
operator|&&
name|DECL_UNINLINABLE
argument_list|(
name|newdecl
argument_list|)
operator|&&
name|lookup_attribute
argument_list|(
literal|"noinline"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|newdecl
argument_list|)
argument_list|)
condition|)
comment|/* Already warned elsewhere.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|DECL_DECLARED_INLINE_P
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|DECL_UNINLINABLE
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|lookup_attribute
argument_list|(
literal|"noinline"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|olddecl
argument_list|)
argument_list|)
condition|)
comment|/* Already warned.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|DECL_DECLARED_INLINE_P
argument_list|(
name|newdecl
argument_list|)
operator|&&
operator|!
name|DECL_DECLARED_INLINE_P
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|DECL_UNINLINABLE
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|lookup_attribute
argument_list|(
literal|"noinline"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|olddecl
argument_list|)
argument_list|)
condition|)
block|{
name|warning_with_decl
argument_list|(
name|newdecl
argument_list|,
literal|"function `%s' redeclared as inline"
argument_list|)
expr_stmt|;
name|warning_with_decl
argument_list|(
name|olddecl
argument_list|,
literal|"previous declaration of function `%s' with attribute noinline"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_DECLARED_INLINE_P
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|DECL_UNINLINABLE
argument_list|(
name|newdecl
argument_list|)
operator|&&
name|lookup_attribute
argument_list|(
literal|"noinline"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|newdecl
argument_list|)
argument_list|)
condition|)
block|{
name|warning_with_decl
argument_list|(
name|newdecl
argument_list|,
literal|"function `%s' redeclared with attribute noinline"
argument_list|)
expr_stmt|;
name|warning_with_decl
argument_list|(
name|olddecl
argument_list|,
literal|"previous declaration of function `%s' was inline"
argument_list|)
expr_stmt|;
block|}
block|}
name|DECL_ATTRIBUTES
argument_list|(
name|newdecl
argument_list|)
operator|=
call|(
modifier|*
name|targetm
operator|.
name|merge_decl_attributes
call|)
argument_list|(
name|olddecl
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newtype
argument_list|)
operator|==
name|ERROR_MARK
operator|||
name|TREE_CODE
argument_list|(
name|oldtype
argument_list|)
operator|==
name|ERROR_MARK
condition|)
name|types_match
operator|=
literal|0
expr_stmt|;
comment|/* New decl is completely inconsistent with the old one =>      tell caller to replace the old one.      This is always an error except in the case of shadowing a builtin.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|(
name|DECL_BUILT_IN
argument_list|(
name|olddecl
argument_list|)
operator|||
name|DECL_BUILT_IN_NONANSI
argument_list|(
name|olddecl
argument_list|)
operator|)
condition|)
block|{
comment|/* If you declare a built-in or predefined function name as static, 	     the old definition is overridden, 	     but optionally warn this was a bad choice of name.  */
if|if
condition|(
operator|!
name|TREE_PUBLIC
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|warn_shadow
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|DECL_BUILT_IN
argument_list|(
name|olddecl
argument_list|)
condition|)
name|warning_with_decl
argument_list|(
name|newdecl
argument_list|,
literal|"shadowing built-in function `%s'"
argument_list|)
expr_stmt|;
else|else
name|warning_with_decl
argument_list|(
name|newdecl
argument_list|,
literal|"shadowing library function `%s'"
argument_list|)
expr_stmt|;
block|}
comment|/* Likewise, if the built-in is not ansi, then programs can 	     override it even globally without an error.  */
elseif|else
if|if
condition|(
operator|!
name|DECL_BUILT_IN
argument_list|(
name|olddecl
argument_list|)
condition|)
name|warning_with_decl
argument_list|(
name|newdecl
argument_list|,
literal|"library function `%s' declared as non-function"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_BUILT_IN_NONANSI
argument_list|(
name|olddecl
argument_list|)
condition|)
name|warning_with_decl
argument_list|(
name|newdecl
argument_list|,
literal|"built-in function `%s' declared as non-function"
argument_list|)
expr_stmt|;
else|else
name|warning_with_decl
argument_list|(
name|newdecl
argument_list|,
literal|"built-in function `%s' declared as non-function"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error_with_decl
argument_list|(
name|newdecl
argument_list|,
literal|"`%s' redeclared as different kind of symbol"
argument_list|)
expr_stmt|;
name|error_with_decl
argument_list|(
name|olddecl
argument_list|,
literal|"previous declaration of `%s'"
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
comment|/* For real parm decl following a forward decl,      return 1 so old decl will be reused.  */
if|if
condition|(
name|types_match
operator|&&
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|PARM_DECL
operator|&&
name|TREE_ASM_WRITTEN
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|newdecl
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* The new declaration is the same kind of object as the old one.      The declarations may partially match.  Print warnings if they don't      match enough.  Ultimately, copy most of the information from the new      decl to the old one, and keep using the old one.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_BUILT_IN
argument_list|(
name|olddecl
argument_list|)
condition|)
block|{
comment|/* A function declaration for a built-in function.  */
if|if
condition|(
operator|!
name|TREE_PUBLIC
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
comment|/* If you declare a built-in function name as static, the 	     built-in definition is overridden, 	     but optionally warn this was a bad choice of name.  */
if|if
condition|(
name|warn_shadow
condition|)
name|warning_with_decl
argument_list|(
name|newdecl
argument_list|,
literal|"shadowing built-in function `%s'"
argument_list|)
expr_stmt|;
comment|/* Discard the old built-in function.  */
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|types_match
condition|)
block|{
comment|/* Accept the return type of the new declaration if same modes.  */
name|tree
name|oldreturntype
init|=
name|TREE_TYPE
argument_list|(
name|oldtype
argument_list|)
decl_stmt|;
name|tree
name|newreturntype
init|=
name|TREE_TYPE
argument_list|(
name|newtype
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|oldreturntype
argument_list|)
operator|==
name|TYPE_MODE
argument_list|(
name|newreturntype
argument_list|)
condition|)
block|{
comment|/* Function types may be shared, so we can't just modify 		 the return type of olddecl's function type.  */
name|tree
name|trytype
init|=
name|build_function_type
argument_list|(
name|newreturntype
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|oldtype
argument_list|)
argument_list|)
decl_stmt|;
name|trytype
operator|=
name|build_type_attribute_variant
argument_list|(
name|trytype
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|oldtype
argument_list|)
argument_list|)
expr_stmt|;
name|types_match
operator|=
name|comptypes
argument_list|(
name|newtype
argument_list|,
name|trytype
argument_list|)
expr_stmt|;
if|if
condition|(
name|types_match
condition|)
name|oldtype
operator|=
name|trytype
expr_stmt|;
block|}
comment|/* Accept harmless mismatch in first argument type also. 	     This is for the ffs and fprintf builtins.  */
if|if
condition|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
operator|!=
literal|0
operator|&&
name|TYPE_ARG_TYPES
argument_list|(
name|oldtype
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_VALUE
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|newtype
argument_list|)
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_VALUE
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|oldtype
argument_list|)
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|TYPE_MODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|newtype
argument_list|)
argument_list|)
argument_list|)
operator|==
name|TYPE_MODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|oldtype
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
block|{
comment|/* Function types may be shared, so we can't just modify 		 the return type of olddecl's function type.  */
name|tree
name|trytype
init|=
name|build_function_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|oldtype
argument_list|)
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_VALUE
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|newtype
argument_list|)
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|oldtype
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|trytype
operator|=
name|build_type_attribute_variant
argument_list|(
name|trytype
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|oldtype
argument_list|)
argument_list|)
expr_stmt|;
name|types_match
operator|=
name|comptypes
argument_list|(
name|newtype
argument_list|,
name|trytype
argument_list|)
expr_stmt|;
if|if
condition|(
name|types_match
condition|)
name|oldtype
operator|=
name|trytype
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|different_binding_level
condition|)
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
operator|=
name|oldtype
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_ARG_TYPES
argument_list|(
name|oldtype
argument_list|)
operator|==
name|NULL
operator|&&
name|TYPE_ARG_TYPES
argument_list|(
name|newtype
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* For bcmp, bzero, fputs the builtin type has arguments not 	     specified.  Use the ones from the prototype so that type checking 	     is done for them.  */
name|tree
name|trytype
init|=
name|build_function_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|oldtype
argument_list|)
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|newtype
argument_list|)
argument_list|)
decl_stmt|;
name|trytype
operator|=
name|build_type_attribute_variant
argument_list|(
name|trytype
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|oldtype
argument_list|)
argument_list|)
expr_stmt|;
name|oldtype
operator|=
name|trytype
expr_stmt|;
if|if
condition|(
operator|!
name|different_binding_level
condition|)
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
operator|=
name|oldtype
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|types_match
condition|)
block|{
comment|/* If types don't match for a built-in, throw away the built-in.  */
name|warning_with_decl
argument_list|(
name|newdecl
argument_list|,
literal|"conflicting types for built-in function `%s'"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_SOURCE_LINE
argument_list|(
name|olddecl
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* A function declaration for a predeclared function 	 that isn't actually built in.  */
if|if
condition|(
operator|!
name|TREE_PUBLIC
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
comment|/* If you declare it as static, the 	     default definition is overridden.  */
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|types_match
condition|)
block|{
comment|/* If the types don't match, preserve volatility indication. 	     Later on, we will discard everything else about the 	     default declaration.  */
name|TREE_THIS_VOLATILE
argument_list|(
name|newdecl
argument_list|)
operator||=
name|TREE_THIS_VOLATILE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Permit char *foo () to match void *foo (...) if not pedantic,      if one of them came from a system header file.  */
elseif|else
if|if
condition|(
operator|!
name|types_match
operator|&&
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|oldtype
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|newtype
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
operator|(
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|olddecl
argument_list|)
operator|||
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|newdecl
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|newtype
argument_list|)
argument_list|)
argument_list|)
operator|==
name|void_type_node
operator|&&
name|TYPE_ARG_TYPES
argument_list|(
name|oldtype
argument_list|)
operator|==
literal|0
operator|&&
name|self_promoting_args_p
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|newtype
argument_list|)
argument_list|)
operator|&&
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|oldtype
argument_list|)
argument_list|)
operator|==
name|char_type_node
operator|)
operator|||
operator|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|newtype
argument_list|)
argument_list|)
operator|==
name|char_type_node
operator|&&
name|TYPE_ARG_TYPES
argument_list|(
name|newtype
argument_list|)
operator|==
literal|0
operator|&&
name|self_promoting_args_p
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|oldtype
argument_list|)
argument_list|)
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|oldtype
argument_list|)
argument_list|)
argument_list|)
operator|==
name|void_type_node
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|pedantic
condition|)
name|pedwarn_with_decl
argument_list|(
name|newdecl
argument_list|,
literal|"conflicting types for `%s'"
argument_list|)
expr_stmt|;
comment|/* Make sure we keep void * as ret type, not char *.  */
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|oldtype
argument_list|)
argument_list|)
argument_list|)
operator|==
name|void_type_node
condition|)
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|newtype
operator|=
name|oldtype
expr_stmt|;
comment|/* Set DECL_IN_SYSTEM_HEADER, so that if we see another declaration 	 we will come back here again.  */
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|newdecl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|types_match
comment|/* Permit char *foo (int, ...); followed by char *foo (); 	      if not pedantic.  */
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|!
name|pedantic
comment|/* Return types must still match.  */
operator|&&
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|oldtype
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|newtype
argument_list|)
argument_list|)
operator|&&
name|TYPE_ARG_TYPES
argument_list|(
name|newtype
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|error_with_decl
argument_list|(
name|newdecl
argument_list|,
literal|"conflicting types for `%s'"
argument_list|)
expr_stmt|;
comment|/* Check for function type mismatch 	 involving an empty arglist vs a nonempty one.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|oldtype
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|newtype
argument_list|)
argument_list|)
operator|&&
operator|(
operator|(
name|TYPE_ARG_TYPES
argument_list|(
name|oldtype
argument_list|)
operator|==
literal|0
operator|&&
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|TYPE_ARG_TYPES
argument_list|(
name|newtype
argument_list|)
operator|==
literal|0
operator|&&
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
comment|/* Classify the problem further.  */
name|tree
name|t
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|oldtype
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|==
literal|0
condition|)
name|t
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|newtype
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|tree
name|type
init|=
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|==
literal|0
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|!=
name|void_type_node
condition|)
block|{
name|error
argument_list|(
literal|"a parameter list with an ellipsis can't match an empty parameter name list declaration"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|c_type_promotes_to
argument_list|(
name|type
argument_list|)
operator|!=
name|type
condition|)
block|{
name|error
argument_list|(
literal|"an argument type that has a default promotion can't match an empty parameter name list declaration"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|error_with_decl
argument_list|(
name|olddecl
argument_list|,
literal|"previous declaration of `%s'"
argument_list|)
expr_stmt|;
comment|/* This is safer because the initializer might contain references 	 to variables that were declared between olddecl and newdecl. This 	 will make the initializer invalid for olddecl in case it gets 	 assigned to olddecl below.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
comment|/* TLS cannot follow non-TLS declaration.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
operator|!
name|DECL_THREAD_LOCAL
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|DECL_THREAD_LOCAL
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
name|error_with_decl
argument_list|(
name|newdecl
argument_list|,
literal|"thread-local declaration of `%s' follows non thread-local declaration"
argument_list|)
expr_stmt|;
name|error_with_decl
argument_list|(
name|olddecl
argument_list|,
literal|"previous declaration of `%s'"
argument_list|)
expr_stmt|;
block|}
comment|/* non-TLS declaration cannot follow TLS declaration.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_THREAD_LOCAL
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|!
name|DECL_THREAD_LOCAL
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
name|error_with_decl
argument_list|(
name|newdecl
argument_list|,
literal|"non thread-local declaration of `%s' follows thread-local declaration"
argument_list|)
expr_stmt|;
name|error_with_decl
argument_list|(
name|olddecl
argument_list|,
literal|"previous declaration of `%s'"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|errmsg
operator|=
name|redeclaration_error_message
argument_list|(
name|newdecl
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|errmsg
condition|)
block|{
switch|switch
condition|(
name|errmsg
condition|)
block|{
case|case
literal|1
case|:
name|error_with_decl
argument_list|(
name|newdecl
argument_list|,
literal|"redefinition of `%s'"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|error_with_decl
argument_list|(
name|newdecl
argument_list|,
literal|"redeclaration of `%s'"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|error_with_decl
argument_list|(
name|newdecl
argument_list|,
literal|"conflicting declarations of `%s'"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|error_with_decl
argument_list|(
name|olddecl
argument_list|,
operator|(
operator|(
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|current_binding_level
operator|==
name|global_binding_level
operator|)
condition|?
literal|"`%s' previously defined here"
else|:
literal|"`%s' previously declared here"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
operator|(
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|olddecl
argument_list|)
operator|||
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|newdecl
argument_list|)
operator|)
condition|)
block|{
name|warning_with_decl
argument_list|(
name|newdecl
argument_list|,
literal|"redefinition of `%s'"
argument_list|)
expr_stmt|;
name|warning_with_decl
argument_list|(
name|olddecl
argument_list|,
operator|(
operator|(
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|current_binding_level
operator|==
name|global_binding_level
operator|)
condition|?
literal|"`%s' previously defined here"
else|:
literal|"`%s' previously declared here"
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
operator|!=
literal|0
operator|&&
name|TYPE_ARG_TYPES
argument_list|(
name|oldtype
argument_list|)
operator|==
literal|0
operator|&&
name|TYPE_ARG_TYPES
argument_list|(
name|newtype
argument_list|)
operator|!=
literal|0
operator|&&
name|TYPE_ACTUAL_ARG_TYPES
argument_list|(
name|oldtype
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|tree
name|type
decl_stmt|,
name|parm
decl_stmt|;
name|int
name|nargs
decl_stmt|;
comment|/* Prototype decl follows defn w/o prototype.  */
for|for
control|(
name|parm
operator|=
name|TYPE_ACTUAL_ARG_TYPES
argument_list|(
name|oldtype
argument_list|)
operator|,
name|type
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|newtype
argument_list|)
operator|,
name|nargs
operator|=
literal|1
init|;
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
operator|,
name|type
operator|=
name|TREE_CHAIN
argument_list|(
name|type
argument_list|)
operator|,
name|nargs
operator|++
control|)
block|{
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
name|void_type_node
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|void_type_node
condition|)
block|{
name|warning_with_decl
argument_list|(
name|newdecl
argument_list|,
literal|"prototype for `%s' follows"
argument_list|)
expr_stmt|;
name|warning_with_decl
argument_list|(
name|olddecl
argument_list|,
literal|"non-prototype definition here"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
name|void_type_node
operator|||
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|void_type_node
condition|)
block|{
name|error_with_decl
argument_list|(
name|newdecl
argument_list|,
literal|"prototype for `%s' follows and number of arguments doesn't match"
argument_list|)
expr_stmt|;
name|error_with_decl
argument_list|(
name|olddecl
argument_list|,
literal|"non-prototype definition here"
argument_list|)
expr_stmt|;
name|errmsg
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* Type for passing arg must be consistent 		 with that declared for the arg.  */
if|if
condition|(
operator|!
name|comptypes
argument_list|(
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
name|error_with_decl
argument_list|(
name|newdecl
argument_list|,
literal|"prototype for `%s' follows and argument %d doesn't match"
argument_list|,
name|nargs
argument_list|)
expr_stmt|;
name|error_with_decl
argument_list|(
name|olddecl
argument_list|,
literal|"non-prototype definition here"
argument_list|)
expr_stmt|;
name|errmsg
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* Warn about mismatches in various flags.  */
else|else
block|{
comment|/* Warn if function is now inline 	     but was previously declared not inline and has been called.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|!
name|DECL_DECLARED_INLINE_P
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|DECL_DECLARED_INLINE_P
argument_list|(
name|newdecl
argument_list|)
operator|&&
name|TREE_USED
argument_list|(
name|olddecl
argument_list|)
condition|)
name|warning_with_decl
argument_list|(
name|newdecl
argument_list|,
literal|"`%s' declared inline after being called"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|!
name|DECL_DECLARED_INLINE_P
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|DECL_DECLARED_INLINE_P
argument_list|(
name|newdecl
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
operator|!=
literal|0
condition|)
name|warning_with_decl
argument_list|(
name|newdecl
argument_list|,
literal|"`%s' declared inline after its definition"
argument_list|)
expr_stmt|;
comment|/* If pedantic, warn when static declaration follows a non-static 	     declaration.  Otherwise, do so only for functions.  */
if|if
condition|(
operator|(
name|pedantic
operator|||
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|)
operator|&&
name|TREE_PUBLIC
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|!
name|TREE_PUBLIC
argument_list|(
name|newdecl
argument_list|)
condition|)
name|warning_with_decl
argument_list|(
name|newdecl
argument_list|,
literal|"static declaration for `%s' follows non-static"
argument_list|)
expr_stmt|;
comment|/* If warn_traditional, warn when a non-static function 	     declaration follows a static one.  */
if|if
condition|(
name|warn_traditional
operator|&&
operator|!
name|in_system_header
operator|&&
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|!
name|TREE_PUBLIC
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|TREE_PUBLIC
argument_list|(
name|newdecl
argument_list|)
condition|)
name|warning_with_decl
argument_list|(
name|newdecl
argument_list|,
literal|"non-static declaration for `%s' follows static"
argument_list|)
expr_stmt|;
comment|/* Warn when const declaration follows a non-const 	     declaration, but not for functions.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|&&
operator|!
name|TREE_READONLY
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|TREE_READONLY
argument_list|(
name|newdecl
argument_list|)
condition|)
name|warning_with_decl
argument_list|(
name|newdecl
argument_list|,
literal|"const declaration for `%s' follows non-const"
argument_list|)
expr_stmt|;
comment|/* These bits are logically part of the type, for variables. 	     But not for functions 	     (where qualifiers are not valid ANSI anyway).  */
elseif|else
if|if
condition|(
name|pedantic
operator|&&
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|&&
operator|(
name|TREE_READONLY
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|TREE_READONLY
argument_list|(
name|olddecl
argument_list|)
operator|||
name|TREE_THIS_VOLATILE
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|TREE_THIS_VOLATILE
argument_list|(
name|olddecl
argument_list|)
operator|)
condition|)
name|pedwarn_with_decl
argument_list|(
name|newdecl
argument_list|,
literal|"type qualifiers for `%s' conflict with previous decl"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Optionally warn about more than one declaration for the same name.  */
if|if
condition|(
name|errmsg
operator|==
literal|0
operator|&&
name|warn_redundant_decls
operator|&&
name|DECL_SOURCE_LINE
argument_list|(
name|olddecl
argument_list|)
operator|!=
literal|0
comment|/* Don't warn about a function declaration 	 followed by a definition.  */
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|!=
literal|0
operator|&&
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
operator|==
literal|0
operator|)
comment|/* Don't warn about extern decl followed by (tentative) definition.  */
operator|&&
operator|!
operator|(
name|DECL_EXTERNAL
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|newdecl
argument_list|)
operator|)
condition|)
block|{
name|warning_with_decl
argument_list|(
name|newdecl
argument_list|,
literal|"redundant redeclaration of `%s' in same scope"
argument_list|)
expr_stmt|;
name|warning_with_decl
argument_list|(
name|olddecl
argument_list|,
literal|"previous declaration of `%s'"
argument_list|)
expr_stmt|;
block|}
comment|/* Copy all the DECL_... slots specified in the new decl      except for any that we copy here from the old type.       Past this point, we don't change OLDTYPE and NEWTYPE      even if we change the types of NEWDECL and OLDDECL.  */
if|if
condition|(
name|types_match
condition|)
block|{
comment|/* When copying info to olddecl, we store into write_olddecl 	 instead.  This allows us to avoid modifying olddecl when 	 different_binding_level is true.  */
name|tree
name|write_olddecl
init|=
name|different_binding_level
condition|?
name|newdecl
else|:
name|olddecl
decl_stmt|;
comment|/* Merge the data types specified in the two decls.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|||
operator|!
name|DECL_BUILT_IN
argument_list|(
name|olddecl
argument_list|)
condition|)
block|{
if|if
condition|(
name|different_binding_level
condition|)
block|{
if|if
condition|(
name|TYPE_ARG_TYPES
argument_list|(
name|oldtype
argument_list|)
operator|!=
literal|0
operator|&&
name|TYPE_ARG_TYPES
argument_list|(
name|newtype
argument_list|)
operator|==
literal|0
condition|)
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|common_type
argument_list|(
name|newtype
argument_list|,
name|oldtype
argument_list|)
expr_stmt|;
else|else
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|build_type_attribute_variant
argument_list|(
name|newtype
argument_list|,
name|merge_attributes
argument_list|(
name|TYPE_ATTRIBUTES
argument_list|(
name|newtype
argument_list|)
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|oldtype
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
operator|=
name|common_type
argument_list|(
name|newtype
argument_list|,
name|oldtype
argument_list|)
expr_stmt|;
block|}
comment|/* Lay the type out, unless already done.  */
if|if
condition|(
name|oldtype
operator|!=
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|error_mark_node
condition|)
name|layout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|TYPE_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|CONST_DECL
condition|)
name|layout_decl
argument_list|(
name|newdecl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Since the type is OLDDECL's, make OLDDECL's size go with.  */
name|DECL_SIZE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_SIZE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_SIZE_UNIT
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_SIZE_UNIT
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_MODE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_MODE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
if|if
condition|(
name|DECL_ALIGN
argument_list|(
name|olddecl
argument_list|)
operator|>
name|DECL_ALIGN
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
name|DECL_ALIGN
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_ALIGN
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_USER_ALIGN
argument_list|(
name|newdecl
argument_list|)
operator||=
name|DECL_ALIGN
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Keep the old rtl since we can safely use it.  */
name|COPY_DECL_RTL
argument_list|(
name|olddecl
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
comment|/* Merge the type qualifiers.  */
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|newdecl
argument_list|)
condition|)
name|TREE_READONLY
argument_list|(
name|write_olddecl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
name|TREE_THIS_VOLATILE
argument_list|(
name|write_olddecl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|VAR_DECL
comment|/* If an automatic variable is re-declared in the same 		 function scope, but the old declaration was not 		 volatile, make_var_volatile() would crash because the 		 variable would have been assigned to a pseudo, not a 		 MEM.  Since this duplicate declaration is invalid 		 anyway, we just skip the call.  */
operator|&&
name|errmsg
operator|==
literal|0
condition|)
name|make_var_volatile
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
block|}
comment|/* Keep source location of definition rather than declaration.  */
comment|/* When called with different_binding_level set, keep the old 	 information so that meaningful diagnostics can be given.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|==
literal|0
operator|&&
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
operator|!=
literal|0
operator|&&
operator|!
name|different_binding_level
condition|)
block|{
name|DECL_SOURCE_LINE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_SOURCE_LINE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_SOURCE_FILE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_SOURCE_FILE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
block|}
comment|/* Merge the unused-warning information.  */
if|if
condition|(
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|olddecl
argument_list|)
condition|)
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|newdecl
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|newdecl
argument_list|)
condition|)
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|write_olddecl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Merge the initialization information.  */
comment|/* When called with different_binding_level set, don't copy over 	 DECL_INITIAL, so that we don't accidentally change function 	 declarations into function definitions.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|different_binding_level
condition|)
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
comment|/* Merge the section attribute.          We want to issue an error if the sections conflict but that must be 	 done later in decl_attributes since we are called before attributes 	 are assigned.  */
if|if
condition|(
name|DECL_SECTION_NAME
argument_list|(
name|newdecl
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|DECL_SECTION_NAME
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_SECTION_NAME
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
comment|/* Copy the assembler name. 	 Currently, it can only be defined in the prototype.  */
name|COPY_DECL_ASSEMBLER_NAME
argument_list|(
name|olddecl
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|DECL_STATIC_CONSTRUCTOR
argument_list|(
name|newdecl
argument_list|)
operator||=
name|DECL_STATIC_CONSTRUCTOR
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_STATIC_DESTRUCTOR
argument_list|(
name|newdecl
argument_list|)
operator||=
name|DECL_STATIC_DESTRUCTOR
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_NO_LIMIT_STACK
argument_list|(
name|newdecl
argument_list|)
operator||=
name|DECL_NO_LIMIT_STACK
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT
argument_list|(
name|newdecl
argument_list|)
operator||=
name|DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If cannot merge, then use the new type and qualifiers,      and don't preserve the old rtl.  */
elseif|else
if|if
condition|(
operator|!
name|different_binding_level
condition|)
block|{
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|olddecl
argument_list|)
operator|=
name|TREE_READONLY
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|olddecl
argument_list|)
operator|=
name|TREE_THIS_VOLATILE
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|olddecl
argument_list|)
operator|=
name|TREE_SIDE_EFFECTS
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
block|}
comment|/* Merge the storage class information.  */
name|merge_weak
argument_list|(
name|newdecl
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
comment|/* For functions, static overrides non-static.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|TREE_PUBLIC
argument_list|(
name|newdecl
argument_list|)
operator|&=
name|TREE_PUBLIC
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
comment|/* This is since we don't automatically 	 copy the attributes of NEWDECL into OLDDECL.  */
comment|/* No need to worry about different_binding_level here because 	 then TREE_PUBLIC (newdecl) was true.  */
name|TREE_PUBLIC
argument_list|(
name|olddecl
argument_list|)
operator|=
name|TREE_PUBLIC
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
comment|/* If this clears `static', clear it in the identifier too.  */
if|if
condition|(
operator|!
name|TREE_PUBLIC
argument_list|(
name|olddecl
argument_list|)
condition|)
name|TREE_PUBLIC
argument_list|(
name|DECL_NAME
argument_list|(
name|olddecl
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|different_binding_level
condition|)
block|{
comment|/* Don't mess with these flags on local externs; they remain 	     external even if there's a declaration at file scope which 	     isn't.  */
name|TREE_STATIC
argument_list|(
name|newdecl
argument_list|)
operator|=
name|TREE_STATIC
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_EXTERNAL
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
block|}
comment|/* An extern decl does not override previous storage class.  */
name|TREE_PUBLIC
argument_list|(
name|newdecl
argument_list|)
operator|=
name|TREE_PUBLIC
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_EXTERNAL
argument_list|(
name|newdecl
argument_list|)
condition|)
name|DECL_CONTEXT
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_CONTEXT
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TREE_STATIC
argument_list|(
name|olddecl
argument_list|)
operator|=
name|TREE_STATIC
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|olddecl
argument_list|)
operator|=
name|TREE_PUBLIC
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
comment|/* If we're redefining a function previously defined as extern 	 inline, make sure we emit debug info for the inline before we 	 throw it away, in case it was inlined into a function that hasn't 	 been written out yet.  */
if|if
condition|(
name|new_is_definition
operator|&&
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_USED
argument_list|(
name|olddecl
argument_list|)
condition|)
call|(
modifier|*
name|debug_hooks
operator|->
name|outlining_inline_function
call|)
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
comment|/* The new defn must not be inline.  */
name|DECL_INLINE
argument_list|(
name|newdecl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_UNINLINABLE
argument_list|(
name|newdecl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* If either decl says `inline', this fn is inline, 	     unless its definition was passed already.  */
if|if
condition|(
name|DECL_DECLARED_INLINE_P
argument_list|(
name|newdecl
argument_list|)
operator|||
name|DECL_DECLARED_INLINE_P
argument_list|(
name|olddecl
argument_list|)
condition|)
name|DECL_DECLARED_INLINE_P
argument_list|(
name|newdecl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_UNINLINABLE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_UNINLINABLE
argument_list|(
name|olddecl
argument_list|)
operator|=
operator|(
name|DECL_UNINLINABLE
argument_list|(
name|newdecl
argument_list|)
operator|||
name|DECL_UNINLINABLE
argument_list|(
name|olddecl
argument_list|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|DECL_BUILT_IN
argument_list|(
name|olddecl
argument_list|)
condition|)
block|{
comment|/* Get rid of any built-in function if new arg types don't match it 	     or if we have a function definition.  */
if|if
condition|(
operator|!
name|types_match
operator|||
name|new_is_definition
condition|)
block|{
if|if
condition|(
operator|!
name|different_binding_level
condition|)
block|{
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
name|DECL_BUILT_IN_CLASS
argument_list|(
name|olddecl
argument_list|)
operator|=
name|NOT_BUILT_IN
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* If redeclaring a builtin function, and not a definition, 		 it stays built in.  */
name|DECL_BUILT_IN_CLASS
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_BUILT_IN_CLASS
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_FUNCTION_CODE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_FUNCTION_CODE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Also preserve various other info from the definition.  */
if|if
condition|(
operator|!
name|new_is_definition
condition|)
block|{
name|DECL_RESULT
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_RESULT
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
comment|/* When called with different_binding_level set, don't copy over 	     DECL_INITIAL, so that we don't accidentally change function 	     declarations into function definitions.  */
if|if
condition|(
operator|!
name|different_binding_level
condition|)
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_SAVED_INSNS
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_SAVED_INSNS
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_SAVED_TREE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_SAVED_TREE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_NUM_STMTS
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_NUM_STMTS
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_ARGUMENTS
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
comment|/* Set DECL_INLINE on the declaration if we've got a body 	     from which to instantiate.  */
if|if
condition|(
name|DECL_INLINE
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|!
name|DECL_UNINLINABLE
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
name|DECL_INLINE
argument_list|(
name|newdecl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|newdecl
argument_list|)
operator|=
operator|(
name|different_binding_level
condition|?
name|DECL_ORIGIN
argument_list|(
name|olddecl
argument_list|)
else|:
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|olddecl
argument_list|)
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* If a previous declaration said inline, mark the 	     definition as inlinable.  */
if|if
condition|(
name|DECL_DECLARED_INLINE_P
argument_list|(
name|newdecl
argument_list|)
operator|&&
operator|!
name|DECL_UNINLINABLE
argument_list|(
name|newdecl
argument_list|)
condition|)
name|DECL_INLINE
argument_list|(
name|newdecl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|different_binding_level
condition|)
return|return
literal|0
return|;
comment|/* Copy most of the decl-specific fields of NEWDECL into OLDDECL.      But preserve OLDDECL's DECL_UID.  */
block|{
name|unsigned
name|olddecl_uid
init|=
name|DECL_UID
argument_list|(
name|olddecl
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|olddecl
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tree_common
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|newdecl
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tree_common
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tree_decl
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|tree_common
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_UID
argument_list|(
name|olddecl
argument_list|)
operator|=
name|olddecl_uid
expr_stmt|;
block|}
comment|/* NEWDECL contains the merged attribute lists.      Update OLDDECL to be the same.  */
name|DECL_ATTRIBUTES
argument_list|(
name|olddecl
argument_list|)
operator|=
name|DECL_ATTRIBUTES
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
comment|/* If OLDDECL had its DECL_RTL instantiated, re-invoke make_decl_rtl      so that encode_section_info has a chance to look at the new decl      flags and attributes.  */
if|if
condition|(
name|DECL_RTL_SET_P
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_STATIC
argument_list|(
name|olddecl
argument_list|)
operator|)
operator|)
condition|)
name|make_decl_rtl
argument_list|(
name|olddecl
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Check whether decl-node X shadows an existing declaration.    OLDLOCAL is the old IDENTIFIER_LOCAL_VALUE of the DECL_NAME of X,    which might be a NULL_TREE.  */
end_comment

begin_function
specifier|static
name|void
name|warn_if_shadowing
parameter_list|(
name|x
parameter_list|,
name|oldlocal
parameter_list|)
name|tree
name|x
decl_stmt|,
name|oldlocal
decl_stmt|;
block|{
name|tree
name|name
decl_stmt|;
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|x
argument_list|)
condition|)
return|return;
name|name
operator|=
name|DECL_NAME
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* Warn if shadowing an argument at the top level of the body.  */
if|if
condition|(
name|oldlocal
operator|!=
literal|0
comment|/* This warning doesn't apply to the parms of a nested fcn.  */
operator|&&
operator|!
name|current_binding_level
operator|->
name|parm_flag
comment|/* Check that this is one level down from the parms.  */
operator|&&
name|current_binding_level
operator|->
name|level_chain
operator|->
name|parm_flag
comment|/* Check that the decl being shadowed 	 comes from the parm level, one level up.  */
operator|&&
name|chain_member
argument_list|(
name|oldlocal
argument_list|,
name|current_binding_level
operator|->
name|level_chain
operator|->
name|names
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|oldlocal
argument_list|)
operator|==
name|PARM_DECL
condition|)
name|pedwarn
argument_list|(
literal|"declaration of `%s' shadows a parameter"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|pedwarn
argument_list|(
literal|"declaration of `%s' shadows a symbol from the parameter list"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Maybe warn if shadowing something else.  */
elseif|else
if|if
condition|(
name|warn_shadow
comment|/* No shadow warnings for internally generated vars.  */
operator|&&
name|DECL_SOURCE_LINE
argument_list|(
name|x
argument_list|)
operator|!=
literal|0
comment|/* No shadow warnings for vars made for inlining.  */
operator|&&
operator|!
name|DECL_FROM_INLINE
argument_list|(
name|x
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PARM_DECL
operator|&&
name|current_binding_level
operator|->
name|level_chain
operator|->
name|parm_flag
condition|)
comment|/* Don't warn about the parm names in function declarator 	   within a function declarator. 	   It would be nice to avoid warning in any function 	   declarator in a declaration, as opposed to a definition, 	   but there is no way to tell it's not a definition.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|oldlocal
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|oldlocal
argument_list|)
operator|==
name|PARM_DECL
condition|)
name|shadow_warning
argument_list|(
literal|"a parameter"
argument_list|,
name|name
argument_list|,
name|oldlocal
argument_list|)
expr_stmt|;
else|else
name|shadow_warning
argument_list|(
literal|"a previous local"
argument_list|,
name|name
argument_list|,
name|oldlocal
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
operator|!=
literal|0
operator|&&
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
operator|!=
name|error_mark_node
condition|)
name|shadow_warning
argument_list|(
literal|"a global declaration"
argument_list|,
name|name
argument_list|,
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Record a decl-node X as belonging to the current lexical scope.    Check for errors (such as an incompatible declaration for the same    name already seen in the same scope).     Returns either X or an old decl for the same name.    If an old decl is returned, it may have been smashed    to agree with what X says.  */
end_comment

begin_function
name|tree
name|pushdecl
parameter_list|(
name|x
parameter_list|)
name|tree
name|x
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
name|tree
name|name
init|=
name|DECL_NAME
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|struct
name|binding_level
modifier|*
name|b
init|=
name|current_binding_level
decl_stmt|;
comment|/* Functions need the lang_decl data.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|!
name|DECL_LANG_SPECIFIC
argument_list|(
name|x
argument_list|)
condition|)
name|DECL_LANG_SPECIFIC
argument_list|(
name|x
argument_list|)
operator|=
operator|(
expr|struct
name|lang_decl
operator|*
operator|)
name|ggc_alloc_cleared
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|lang_decl
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|x
argument_list|)
operator|=
name|current_function_decl
expr_stmt|;
comment|/* A local extern declaration for a function doesn't constitute nesting.      A local auto declaration does, since it's a forward decl      for a nested function coming later.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|VAR_DECL
operator|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|==
literal|0
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|x
argument_list|)
condition|)
name|DECL_CONTEXT
argument_list|(
name|x
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|name
condition|)
block|{
name|int
name|different_binding_level
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|warn_nested_externs
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|x
argument_list|)
operator|&&
name|b
operator|!=
name|global_binding_level
operator|&&
name|x
operator|!=
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|name
argument_list|)
comment|/* No error messages for __FUNCTION__ and __PRETTY_FUNCTION__.  */
operator|&&
operator|!
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|x
argument_list|)
condition|)
name|warning
argument_list|(
literal|"nested extern declaration of `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|lookup_name_current_level
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|x
argument_list|)
operator|&&
name|TREE_PUBLIC
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|t
operator|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* Type decls at global scope don't conflict with externs declared 	     inside lexical blocks.  */
if|if
condition|(
operator|!
name|t
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_DECL
condition|)
comment|/* If there's no visible global declaration, try for an                invisible one.  */
name|t
operator|=
name|IDENTIFIER_LIMBO_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|different_binding_level
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|!=
literal|0
operator|&&
name|t
operator|==
name|error_mark_node
condition|)
comment|/* error_mark_node is 0 for a while during initialization!  */
block|{
name|t
operator|=
literal|0
expr_stmt|;
name|error_with_decl
argument_list|(
name|x
argument_list|,
literal|"`%s' used prior to declaration"
argument_list|)
expr_stmt|;
block|}
comment|/* If this decl is `static' and an implicit decl was seen previously, 	 warn.  */
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|name
argument_list|)
comment|/* Don't test for DECL_EXTERNAL, because grokdeclarator 	     sets this for all functions.  */
operator|&&
operator|!
name|TREE_PUBLIC
argument_list|(
name|x
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|b
operator|==
name|global_binding_level
operator|)
comment|/* We used to warn also for explicit extern followed by static, 	     but sometimes you need to do it that way.  */
operator|&&
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|name
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|pedwarn
argument_list|(
literal|"`%s' was declared implicitly `extern' and later `static'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|pedwarn_with_file_and_line
argument_list|(
name|DECL_SOURCE_FILE
argument_list|(
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|name
argument_list|)
argument_list|)
argument_list|,
name|DECL_SOURCE_LINE
argument_list|(
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|name
argument_list|)
argument_list|)
argument_list|,
literal|"previous declaration of `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|name
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|!=
literal|0
operator|&&
name|duplicate_decls
argument_list|(
name|x
argument_list|,
name|t
argument_list|,
name|different_binding_level
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|PARM_DECL
condition|)
block|{
comment|/* Don't allow more than one "real" duplicate 		 of a forward parm decl.  */
name|TREE_ASM_WRITTEN
argument_list|(
name|t
argument_list|)
operator|=
name|TREE_ASM_WRITTEN
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
return|return
name|t
return|;
block|}
comment|/* If we are processing a typedef statement, generate a whole new 	 ..._TYPE node (which will be just a variant of the existing 	 ..._TYPE node with identical properties) and then install the 	 TYPE_DECL node generated to represent the typedef name as the 	 TYPE_NAME of this brand new (duplicate) ..._TYPE node.  	 The whole point here is to end up with a situation where each 	 and every ..._TYPE node the compiler creates will be uniquely 	 associated with AT MOST one node representing a typedef name. 	 This way, even though the compiler substitutes corresponding 	 ..._TYPE nodes for TYPE_DECL (i.e. "typedef name") nodes very 	 early on, later parts of the compiler can always do the reverse 	 translation and get back the corresponding typedef name.  For 	 example, given:  		typedef struct S MY_TYPE; 		MY_TYPE object;  	 Later parts of the compiler might only know that `object' was of 	 type `struct S' if it were not for code just below.  With this 	 code however, later parts of the compiler see something like:  		struct S' == struct S 		typedef struct S' MY_TYPE; 		struct S' object;  	 And they can then deduce (from the node for type struct S') that 	 the original object declaration was:  		MY_TYPE object;  	 Being able to do this is important for proper support of protoize, 	 and also for generating precise symbolic debugging information 	 which takes full account of the programmer's (typedef) vocabulary.           Obviously, we don't want to generate a duplicate ..._TYPE node if 	 the TYPE_DECL node that we are now processing really represents a 	 standard built-in type.           Since all standard types are effectively declared at line zero          in the source file, we can easily check to see if we are working          on a standard type by checking the current value of lineno.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
if|if
condition|(
name|DECL_SOURCE_LINE
argument_list|(
name|x
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|TYPE_NAME
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|=
name|x
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
operator|!=
name|error_mark_node
operator|&&
name|DECL_ORIGINAL_TYPE
argument_list|(
name|x
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|tree
name|tt
init|=
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|DECL_ORIGINAL_TYPE
argument_list|(
name|x
argument_list|)
operator|=
name|tt
expr_stmt|;
name|tt
operator|=
name|build_type_copy
argument_list|(
name|tt
argument_list|)
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|tt
argument_list|)
operator|=
name|x
expr_stmt|;
name|TREE_USED
argument_list|(
name|tt
argument_list|)
operator|=
name|TREE_USED
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
operator|=
name|tt
expr_stmt|;
block|}
block|}
comment|/* Multiple external decls of the same identifier ought to match. 	 We get warnings about inline functions where they are defined. 	 Avoid duplicate warnings where they are used.  */
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_INLINE
argument_list|(
name|x
argument_list|)
operator|)
condition|)
block|{
name|tree
name|decl
decl_stmt|;
if|if
condition|(
name|IDENTIFIER_LIMBO_VALUE
argument_list|(
name|name
argument_list|)
operator|!=
literal|0
condition|)
comment|/* Decls in limbo are always extern, so no need to check that.  */
name|decl
operator|=
name|IDENTIFIER_LIMBO_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
else|else
name|decl
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|decl
operator|&&
operator|!
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
comment|/* If old decl is built-in, we already warned if we should.  */
operator|&&
operator|!
name|DECL_BUILT_IN
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|pedwarn_with_decl
argument_list|(
name|x
argument_list|,
literal|"type mismatch with previous external decl"
argument_list|)
expr_stmt|;
name|pedwarn_with_decl
argument_list|(
name|decl
argument_list|,
literal|"previous external decl of `%s'"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If a function has had an implicit declaration, and then is defined, 	 make sure they are compatible.  */
if|if
condition|(
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|name
argument_list|)
operator|!=
literal|0
operator|&&
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|!
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|name
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|warning_with_decl
argument_list|(
name|x
argument_list|,
literal|"type mismatch with previous implicit declaration"
argument_list|)
expr_stmt|;
name|warning_with_decl
argument_list|(
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"previous implicit declaration of `%s'"
argument_list|)
expr_stmt|;
block|}
comment|/* This name is new in its binding level. 	 Install the new declaration and return it.  */
if|if
condition|(
name|b
operator|==
name|global_binding_level
condition|)
block|{
comment|/* Install a global value.  */
comment|/* If the first global decl has external linkage, 	     warn if we later see static one.  */
if|if
condition|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_PUBLIC
argument_list|(
name|x
argument_list|)
condition|)
name|TREE_PUBLIC
argument_list|(
name|name
argument_list|)
operator|=
literal|1
expr_stmt|;
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
operator|=
name|x
expr_stmt|;
comment|/* We no longer care about any previous block level declarations.  */
name|IDENTIFIER_LIMBO_VALUE
argument_list|(
name|name
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Don't forget if the function was used via an implicit decl.  */
if|if
condition|(
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|name
argument_list|)
operator|&&
name|TREE_USED
argument_list|(
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|name
argument_list|)
argument_list|)
condition|)
name|TREE_USED
argument_list|(
name|x
argument_list|)
operator|=
literal|1
operator|,
name|TREE_USED
argument_list|(
name|name
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Don't forget if its address was taken in that way.  */
if|if
condition|(
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|name
argument_list|)
operator|&&
name|TREE_ADDRESSABLE
argument_list|(
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|name
argument_list|)
argument_list|)
condition|)
name|TREE_ADDRESSABLE
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Warn about mismatches against previous implicit decl.  */
if|if
condition|(
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|name
argument_list|)
operator|!=
literal|0
comment|/* If this real decl matches the implicit, don't complain.  */
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|==
name|integer_type_node
operator|)
operator|)
condition|)
name|pedwarn
argument_list|(
literal|"`%s' was previously implicitly declared to return `int'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If this decl is `static' and an `extern' was seen previously, 	     that is erroneous.  */
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|name
argument_list|)
operator|&&
operator|!
name|TREE_PUBLIC
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|x
argument_list|)
condition|)
block|{
comment|/* Okay to redeclare an ANSI built-in as static.  */
if|if
condition|(
name|t
operator|!=
literal|0
operator|&&
name|DECL_BUILT_IN
argument_list|(
name|t
argument_list|)
condition|)
empty_stmt|;
comment|/* Okay to declare a non-ANSI built-in as anything.  */
elseif|else
if|if
condition|(
name|t
operator|!=
literal|0
operator|&&
name|DECL_BUILT_IN_NONANSI
argument_list|(
name|t
argument_list|)
condition|)
empty_stmt|;
comment|/* Okay to have global type decl after an earlier extern 		 declaration inside a lexical block.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TYPE_DECL
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|TREE_THIS_VOLATILE
argument_list|(
name|name
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"`%s' was declared implicitly `extern' and later `static'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|pedwarn
argument_list|(
literal|"`%s' was declared `extern' and later `static'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Here to install a non-global value.  */
name|tree
name|oldlocal
init|=
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|tree
name|oldglobal
init|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|name
argument_list|)
operator|=
name|x
expr_stmt|;
comment|/* If this is an extern function declaration, see if we 	     have a global definition or declaration for the function.  */
if|if
condition|(
name|oldlocal
operator|==
literal|0
operator|&&
name|oldglobal
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|oldglobal
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|DECL_DECLARED_INLINE_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
comment|/* We have one.  Their types must agree.  */
if|if
condition|(
operator|!
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
argument_list|)
argument_list|)
condition|)
name|pedwarn_with_decl
argument_list|(
name|x
argument_list|,
literal|"extern declaration of `%s' doesn't match global one"
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Inner extern decl is inline if global one is. 		     Copy enough to really inline it.  */
if|if
condition|(
name|DECL_DECLARED_INLINE_P
argument_list|(
name|oldglobal
argument_list|)
condition|)
block|{
name|DECL_DECLARED_INLINE_P
argument_list|(
name|x
argument_list|)
operator|=
name|DECL_DECLARED_INLINE_P
argument_list|(
name|oldglobal
argument_list|)
expr_stmt|;
name|DECL_INLINE
argument_list|(
name|x
argument_list|)
operator|=
name|DECL_INLINE
argument_list|(
name|oldglobal
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|=
operator|(
name|current_function_decl
operator|==
name|oldglobal
condition|?
literal|0
else|:
name|DECL_INITIAL
argument_list|(
name|oldglobal
argument_list|)
operator|)
expr_stmt|;
name|DECL_SAVED_INSNS
argument_list|(
name|x
argument_list|)
operator|=
name|DECL_SAVED_INSNS
argument_list|(
name|oldglobal
argument_list|)
expr_stmt|;
name|DECL_NUM_STMTS
argument_list|(
name|x
argument_list|)
operator|=
name|DECL_NUM_STMTS
argument_list|(
name|oldglobal
argument_list|)
expr_stmt|;
name|DECL_ARGUMENTS
argument_list|(
name|x
argument_list|)
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|oldglobal
argument_list|)
expr_stmt|;
name|DECL_RESULT
argument_list|(
name|x
argument_list|)
operator|=
name|DECL_RESULT
argument_list|(
name|oldglobal
argument_list|)
expr_stmt|;
name|TREE_ASM_WRITTEN
argument_list|(
name|x
argument_list|)
operator|=
name|TREE_ASM_WRITTEN
argument_list|(
name|oldglobal
argument_list|)
expr_stmt|;
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|x
argument_list|)
operator|=
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|oldglobal
argument_list|)
expr_stmt|;
block|}
comment|/* Inner extern decl is built-in if global one is.  */
if|if
condition|(
name|DECL_BUILT_IN
argument_list|(
name|oldglobal
argument_list|)
condition|)
block|{
name|DECL_BUILT_IN_CLASS
argument_list|(
name|x
argument_list|)
operator|=
name|DECL_BUILT_IN_CLASS
argument_list|(
name|oldglobal
argument_list|)
expr_stmt|;
name|DECL_FUNCTION_CODE
argument_list|(
name|x
argument_list|)
operator|=
name|DECL_FUNCTION_CODE
argument_list|(
name|oldglobal
argument_list|)
expr_stmt|;
block|}
comment|/* Keep the arg types from a file-scope fcn defn.  */
if|if
condition|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|oldglobal
argument_list|)
argument_list|)
operator|!=
literal|0
operator|&&
name|DECL_INITIAL
argument_list|(
name|oldglobal
argument_list|)
operator|&&
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|oldglobal
argument_list|)
expr_stmt|;
block|}
block|}
if|#
directive|if
literal|0
comment|/* This case is probably sometimes the right thing to do.  */
comment|/* If we have a local external declaration, 	     then any file-scope declaration should not 	     have been static.  */
block|if (oldlocal == 0&& oldglobal != 0&& !TREE_PUBLIC (oldglobal)&& DECL_EXTERNAL (x)&& TREE_PUBLIC (x)) 	    warning ("`%s' locally external but globally static", 		     IDENTIFIER_POINTER (name));
endif|#
directive|endif
comment|/* If we have a local external declaration, 	     and no file-scope declaration has yet been seen, 	     then if we later have a file-scope decl it must not be static.  */
if|if
condition|(
name|oldlocal
operator|==
literal|0
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|x
argument_list|)
operator|&&
name|TREE_PUBLIC
argument_list|(
name|x
argument_list|)
condition|)
block|{
if|if
condition|(
name|oldglobal
operator|==
literal|0
condition|)
name|TREE_PUBLIC
argument_list|(
name|name
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Save this decl, so that we can do type checking against 		 other decls after it falls out of scope.  		 Only save it once.  This prevents temporary decls created in 		 expand_inline_function from being used here, since this 		 will have been set when the inline function was parsed. 		 It also helps give slightly better warnings.  */
if|if
condition|(
name|IDENTIFIER_LIMBO_VALUE
argument_list|(
name|name
argument_list|)
operator|==
literal|0
condition|)
name|IDENTIFIER_LIMBO_VALUE
argument_list|(
name|name
argument_list|)
operator|=
name|x
expr_stmt|;
block|}
name|warn_if_shadowing
argument_list|(
name|x
argument_list|,
name|oldlocal
argument_list|)
expr_stmt|;
comment|/* If storing a local value, there may already be one (inherited). 	     If so, record it for restoration when this binding level ends.  */
if|if
condition|(
name|oldlocal
operator|!=
literal|0
condition|)
name|b
operator|->
name|shadowed
operator|=
name|tree_cons
argument_list|(
name|name
argument_list|,
name|oldlocal
argument_list|,
name|b
operator|->
name|shadowed
argument_list|)
expr_stmt|;
block|}
comment|/* Keep list of variables in this level with incomplete type. 	 If the input is erroneous, we can have error_mark in the type 	 slot (e.g. "f(void a, ...)") - that doesn't count as an 	 incomplete type.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
operator|!=
name|error_mark_node
operator|&&
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|element
init|=
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
decl_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|element
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|element
operator|=
name|TREE_TYPE
argument_list|(
name|element
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|element
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|element
argument_list|)
operator|==
name|UNION_TYPE
condition|)
name|b
operator|->
name|incomplete_list
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|x
argument_list|,
name|b
operator|->
name|incomplete_list
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Put decls on list in reverse order.      We will reverse them later if necessary.  */
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
operator|=
name|b
operator|->
name|names
expr_stmt|;
name|b
operator|->
name|names
operator|=
name|x
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Like pushdecl, only it places X in GLOBAL_BINDING_LEVEL, if appropriate.  */
end_comment

begin_function
name|tree
name|pushdecl_top_level
parameter_list|(
name|x
parameter_list|)
name|tree
name|x
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
name|struct
name|binding_level
modifier|*
name|b
init|=
name|current_binding_level
decl_stmt|;
name|current_binding_level
operator|=
name|global_binding_level
expr_stmt|;
name|t
operator|=
name|pushdecl
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|current_binding_level
operator|=
name|b
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate an implicit declaration for identifier FUNCTIONID    as a function of type int ().  Print a warning if appropriate.  */
end_comment

begin_function
name|tree
name|implicitly_declare
parameter_list|(
name|functionid
parameter_list|)
name|tree
name|functionid
decl_stmt|;
block|{
name|tree
name|decl
decl_stmt|;
name|int
name|traditional_warning
init|=
literal|0
decl_stmt|;
comment|/* Only one "implicit declaration" warning per identifier.  */
name|int
name|implicit_warning
decl_stmt|;
comment|/* We used to reuse an old implicit decl here,      but this loses with inline functions because it can clobber      the saved decl chains.  */
if|#
directive|if
literal|0
block|if (IDENTIFIER_IMPLICIT_DECL (functionid) != 0)     decl = IDENTIFIER_IMPLICIT_DECL (functionid);   else
endif|#
directive|endif
name|decl
operator|=
name|build_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|functionid
argument_list|,
name|default_function_type
argument_list|)
expr_stmt|;
comment|/* Warn of implicit decl following explicit local extern decl.      This is probably a program designed for traditional C.  */
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|functionid
argument_list|)
operator|&&
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|functionid
argument_list|)
operator|==
literal|0
condition|)
name|traditional_warning
operator|=
literal|1
expr_stmt|;
comment|/* Warn once of an implicit declaration.  */
name|implicit_warning
operator|=
operator|(
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|functionid
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Record that we have an implicit decl and this is it.  */
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|functionid
argument_list|)
operator|=
name|decl
expr_stmt|;
comment|/* ANSI standard says implicit declarations are in the innermost block.      So we record the decl in the standard fashion.  */
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* This is a no-op in c-lang.c or something real in objc-act.c.  */
if|if
condition|(
name|flag_objc
condition|)
name|objc_check_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|rest_of_decl_compilation
argument_list|(
name|decl
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|implicit_warning
condition|)
name|implicit_decl_warning
argument_list|(
name|functionid
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|warn_traditional
operator|&&
name|traditional_warning
condition|)
name|warning
argument_list|(
literal|"function `%s' was previously declared within a block"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|functionid
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Write a record describing this implicit function declaration to the      prototypes file (if requested).  */
name|gen_aux_info_record
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Possibly apply some default attributes to this implicit declaration.  */
name|decl_attributes
argument_list|(
operator|&
name|decl
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_function
name|void
name|implicit_decl_warning
parameter_list|(
name|id
parameter_list|)
name|tree
name|id
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|mesg_implicit_function_declaration
operator|==
literal|2
condition|)
name|error
argument_list|(
literal|"implicit declaration of function `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|mesg_implicit_function_declaration
operator|==
literal|1
condition|)
name|warning
argument_list|(
literal|"implicit declaration of function `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return zero if the declaration NEWDECL is valid    when the declaration OLDDECL (assumed to be for the same name)    has already been seen.    Otherwise return 1 if NEWDECL is a redefinition, 2 if it is a redeclaration,    and 3 if it is a conflicting declaration.  */
end_comment

begin_function
specifier|static
name|int
name|redeclaration_error_message
parameter_list|(
name|newdecl
parameter_list|,
name|olddecl
parameter_list|)
name|tree
name|newdecl
decl_stmt|,
name|olddecl
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
comment|/* Do not complain about type redeclarations where at least one 	 declaration was in a system header.  */
if|if
condition|(
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|olddecl
argument_list|)
operator|||
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|newdecl
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
comment|/* Declarations of functions can insist on internal linkage 	 but they can't be inconsistent with internal linkage, 	 so there can be no error on that account. 	 However defining the same name twice is no good.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
operator|!=
literal|0
operator|&&
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|!=
literal|0
comment|/* However, defining once as extern inline and a second 	     time in another way is ok.  */
operator|&&
operator|!
operator|(
name|DECL_DECLARED_INLINE_P
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|!
operator|(
name|DECL_DECLARED_INLINE_P
argument_list|(
name|newdecl
argument_list|)
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|newdecl
argument_list|)
operator|)
operator|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|newdecl
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* Objects declared at top level:  */
comment|/* If at least one is a reference, it's ok.  */
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|newdecl
argument_list|)
operator|||
name|DECL_EXTERNAL
argument_list|(
name|olddecl
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Reject two definitions.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
operator|!=
literal|0
operator|&&
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
comment|/* Now we have two tentative defs, or one tentative and one real def.  */
comment|/* Insist that the linkage match.  */
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|olddecl
argument_list|)
operator|!=
name|TREE_PUBLIC
argument_list|(
name|newdecl
argument_list|)
condition|)
return|return
literal|3
return|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|current_binding_level
operator|->
name|parm_flag
operator|&&
name|TREE_ASM_WRITTEN
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|newdecl
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
block|{
comment|/* Newdecl has block scope.  If olddecl has block scope also, then 	 reject two definitions, and reject a definition together with an 	 external reference.  Otherwise, it is OK, because newdecl must 	 be an extern reference to olddecl.  */
if|if
condition|(
operator|!
operator|(
name|DECL_EXTERNAL
argument_list|(
name|newdecl
argument_list|)
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|olddecl
argument_list|)
operator|)
operator|&&
name|DECL_CONTEXT
argument_list|(
name|newdecl
argument_list|)
operator|==
name|DECL_CONTEXT
argument_list|(
name|olddecl
argument_list|)
condition|)
return|return
literal|2
return|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Get the LABEL_DECL corresponding to identifier ID as a label.    Create one if none exists so far for the current function.    This function is called for both label definitions and label references.  */
end_comment

begin_function
name|tree
name|lookup_label
parameter_list|(
name|id
parameter_list|)
name|tree
name|id
decl_stmt|;
block|{
name|tree
name|decl
init|=
name|IDENTIFIER_LABEL_VALUE
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|current_function_decl
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"label %s referenced outside of any function"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Use a label already defined or ref'd with this name.  */
if|if
condition|(
name|decl
operator|!=
literal|0
condition|)
block|{
comment|/* But not if it is inherited and wasn't declared to be inheritable.  */
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|!=
name|current_function_decl
operator|&&
operator|!
name|C_DECLARED_LABEL_FLAG
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|shadow_label
argument_list|(
name|id
argument_list|)
return|;
return|return
name|decl
return|;
block|}
name|decl
operator|=
name|build_decl
argument_list|(
name|LABEL_DECL
argument_list|,
name|id
argument_list|,
name|void_type_node
argument_list|)
expr_stmt|;
comment|/* A label not explicitly declared must be local to where it's ref'd.  */
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|current_function_decl
expr_stmt|;
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
operator|=
name|VOIDmode
expr_stmt|;
comment|/* Say where one reference is to the label,      for the sake of the error if it is not defined.  */
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
operator|=
name|lineno
expr_stmt|;
name|DECL_SOURCE_FILE
argument_list|(
name|decl
argument_list|)
operator|=
name|input_filename
expr_stmt|;
name|IDENTIFIER_LABEL_VALUE
argument_list|(
name|id
argument_list|)
operator|=
name|decl
expr_stmt|;
name|named_labels
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|decl
argument_list|,
name|named_labels
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Make a label named NAME in the current function,    shadowing silently any that may be inherited from containing functions    or containing scopes.     Note that valid use, if the label being shadowed    comes from another scope in the same function,    requires calling declare_nonlocal_label right away.  */
end_comment

begin_function
name|tree
name|shadow_label
parameter_list|(
name|name
parameter_list|)
name|tree
name|name
decl_stmt|;
block|{
name|tree
name|decl
init|=
name|IDENTIFIER_LABEL_VALUE
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|decl
operator|!=
literal|0
condition|)
block|{
name|tree
name|dup
decl_stmt|;
comment|/* Check to make sure that the label hasn't already been declared 	 at this label scope */
for|for
control|(
name|dup
operator|=
name|named_labels
init|;
name|dup
condition|;
name|dup
operator|=
name|TREE_CHAIN
argument_list|(
name|dup
argument_list|)
control|)
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|dup
argument_list|)
operator|==
name|decl
condition|)
block|{
name|error
argument_list|(
literal|"duplicate label declaration `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|error_with_decl
argument_list|(
name|TREE_VALUE
argument_list|(
name|dup
argument_list|)
argument_list|,
literal|"this is a previous declaration"
argument_list|)
expr_stmt|;
comment|/* Just use the previous declaration.  */
return|return
name|lookup_label
argument_list|(
name|name
argument_list|)
return|;
block|}
name|shadowed_labels
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|decl
argument_list|,
name|shadowed_labels
argument_list|)
expr_stmt|;
name|IDENTIFIER_LABEL_VALUE
argument_list|(
name|name
argument_list|)
operator|=
name|decl
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|lookup_label
argument_list|(
name|name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Define a label, specifying the location in the source file.    Return the LABEL_DECL node for the label, if the definition is valid.    Otherwise return 0.  */
end_comment

begin_function
name|tree
name|define_label
parameter_list|(
name|filename
parameter_list|,
name|line
parameter_list|,
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|line
decl_stmt|;
name|tree
name|name
decl_stmt|;
block|{
name|tree
name|decl
init|=
name|lookup_label
argument_list|(
name|name
argument_list|)
decl_stmt|;
comment|/* If label with this name is known from an outer context, shadow it.  */
if|if
condition|(
name|decl
operator|!=
literal|0
operator|&&
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|!=
name|current_function_decl
condition|)
block|{
name|shadowed_labels
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|decl
argument_list|,
name|shadowed_labels
argument_list|)
expr_stmt|;
name|IDENTIFIER_LABEL_VALUE
argument_list|(
name|name
argument_list|)
operator|=
literal|0
expr_stmt|;
name|decl
operator|=
name|lookup_label
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|warn_traditional
operator|&&
operator|!
name|in_system_header
operator|&&
name|lookup_name
argument_list|(
name|name
argument_list|)
condition|)
name|warning_with_file_and_line
argument_list|(
name|filename
argument_list|,
name|line
argument_list|,
literal|"traditional C lacks a separate namespace for labels, identifier `%s' conflicts"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error_with_file_and_line
argument_list|(
name|filename
argument_list|,
name|line
argument_list|,
literal|"duplicate label `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
comment|/* Mark label as having been defined.  */
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
comment|/* Say where in the source.  */
name|DECL_SOURCE_FILE
argument_list|(
name|decl
argument_list|)
operator|=
name|filename
expr_stmt|;
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
operator|=
name|line
expr_stmt|;
return|return
name|decl
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the list of declarations of the current level.    Note that this list is in reverse order unless/until    you nreverse it; and when you do nreverse it, you must    store the result back using `storedecls' or you will lose.  */
end_comment

begin_function
name|tree
name|getdecls
parameter_list|()
block|{
return|return
name|current_binding_level
operator|->
name|names
return|;
block|}
end_function

begin_comment
comment|/* Return the list of type-tags (for structs, etc) of the current level.  */
end_comment

begin_function
name|tree
name|gettags
parameter_list|()
block|{
return|return
name|current_binding_level
operator|->
name|tags
return|;
block|}
end_function

begin_comment
comment|/* Store the list of declarations of the current level.    This is done for the parameter declarations of a function being defined,    after they are modified in the light of any missing parameters.  */
end_comment

begin_function
specifier|static
name|void
name|storedecls
parameter_list|(
name|decls
parameter_list|)
name|tree
name|decls
decl_stmt|;
block|{
name|current_binding_level
operator|->
name|names
operator|=
name|decls
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Similarly, store the list of tags of the current level.  */
end_comment

begin_function
specifier|static
name|void
name|storetags
parameter_list|(
name|tags
parameter_list|)
name|tree
name|tags
decl_stmt|;
block|{
name|current_binding_level
operator|->
name|tags
operator|=
name|tags
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given NAME, an IDENTIFIER_NODE,    return the structure (or union or enum) definition for that name.    Searches binding levels from BINDING_LEVEL up to the global level.    If THISLEVEL_ONLY is nonzero, searches only the specified context    (but skips any tag-transparent contexts to find one that is    meaningful for tags).    CODE says which kind of type the caller wants;    it is RECORD_TYPE or UNION_TYPE or ENUMERAL_TYPE.    If the wrong kind of type is found, an error is reported.  */
end_comment

begin_function
specifier|static
name|tree
name|lookup_tag
parameter_list|(
name|code
parameter_list|,
name|name
parameter_list|,
name|binding_level
parameter_list|,
name|thislevel_only
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|struct
name|binding_level
modifier|*
name|binding_level
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|int
name|thislevel_only
decl_stmt|;
block|{
name|struct
name|binding_level
modifier|*
name|level
decl_stmt|;
name|int
name|thislevel
init|=
literal|1
decl_stmt|;
for|for
control|(
name|level
operator|=
name|binding_level
init|;
name|level
condition|;
name|level
operator|=
name|level
operator|->
name|level_chain
control|)
block|{
name|tree
name|tail
decl_stmt|;
for|for
control|(
name|tail
operator|=
name|level
operator|->
name|tags
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
operator|==
name|name
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
operator|!=
name|code
condition|)
block|{
comment|/* Definition isn't the kind we were looking for.  */
name|pending_invalid_xref
operator|=
name|name
expr_stmt|;
name|pending_invalid_xref_file
operator|=
name|input_filename
expr_stmt|;
name|pending_invalid_xref_line
operator|=
name|lineno
expr_stmt|;
comment|/* If in the same binding level as a declaration as a tag 		     of a different type, this must not be allowed to 		     shadow that tag, so give the error immediately. 		     (For example, "struct foo; union foo;" is invalid.)  */
if|if
condition|(
name|thislevel
condition|)
name|pending_xref_error
argument_list|()
expr_stmt|;
block|}
return|return
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
return|;
block|}
block|}
if|if
condition|(
operator|!
name|level
operator|->
name|tag_transparent
condition|)
block|{
if|if
condition|(
name|thislevel_only
condition|)
return|return
name|NULL_TREE
return|;
name|thislevel
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Print an error message now    for a recent invalid struct, union or enum cross reference.    We don't print them immediately because they are not invalid    when used in the `struct foo;' construct for shadowing.  */
end_comment

begin_function
name|void
name|pending_xref_error
parameter_list|()
block|{
if|if
condition|(
name|pending_invalid_xref
operator|!=
literal|0
condition|)
name|error_with_file_and_line
argument_list|(
name|pending_invalid_xref_file
argument_list|,
name|pending_invalid_xref_line
argument_list|,
literal|"`%s' defined as wrong kind of tag"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|pending_invalid_xref
argument_list|)
argument_list|)
expr_stmt|;
name|pending_invalid_xref
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a type, find the tag that was defined for it and return the tag name.    Otherwise return 0.  */
end_comment

begin_function
specifier|static
name|tree
name|lookup_tag_reverse
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|struct
name|binding_level
modifier|*
name|level
decl_stmt|;
for|for
control|(
name|level
operator|=
name|current_binding_level
init|;
name|level
condition|;
name|level
operator|=
name|level
operator|->
name|level_chain
control|)
block|{
name|tree
name|tail
decl_stmt|;
for|for
control|(
name|tail
operator|=
name|level
operator|->
name|tags
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
operator|==
name|type
condition|)
return|return
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
return|;
block|}
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Look up NAME in the current binding level and its superiors    in the namespace of variables, functions and typedefs.    Return a ..._DECL node of some kind representing its definition,    or return 0 if it is undefined.  */
end_comment

begin_function
name|tree
name|lookup_name
parameter_list|(
name|name
parameter_list|)
name|tree
name|name
decl_stmt|;
block|{
name|tree
name|val
decl_stmt|;
if|if
condition|(
name|current_binding_level
operator|!=
name|global_binding_level
operator|&&
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|name
argument_list|)
condition|)
name|val
operator|=
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
else|else
name|val
operator|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Similar to `lookup_name' but look only at current binding level.  */
end_comment

begin_function
name|tree
name|lookup_name_current_level
parameter_list|(
name|name
parameter_list|)
name|tree
name|name
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
condition|)
return|return
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
return|;
if|if
condition|(
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
for|for
control|(
name|t
operator|=
name|current_binding_level
operator|->
name|names
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
operator|==
name|name
condition|)
break|break;
return|return
name|t
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create the predefined scalar types of C,    and some nodes representing standard constants (0, 1, (void *) 0).    Initialize the global binding level.    Make definitions for built-in primitive functions.  */
end_comment

begin_function
name|void
name|c_init_decl_processing
parameter_list|()
block|{
name|tree
name|endlink
decl_stmt|;
name|tree
name|ptr_ftype_void
decl_stmt|,
name|ptr_ftype_ptr
decl_stmt|;
comment|/* Adds some ggc roots, and reserved words for c-parse.in.  */
name|c_parse_init
argument_list|()
expr_stmt|;
name|current_function_decl
operator|=
name|NULL
expr_stmt|;
name|named_labels
operator|=
name|NULL
expr_stmt|;
name|current_binding_level
operator|=
name|NULL_BINDING_LEVEL
expr_stmt|;
name|free_binding_level
operator|=
name|NULL_BINDING_LEVEL
expr_stmt|;
comment|/* Make the binding_level structure for global names.  */
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|global_binding_level
operator|=
name|current_binding_level
expr_stmt|;
name|build_common_tree_nodes
argument_list|(
name|flag_signed_char
argument_list|)
expr_stmt|;
name|c_common_nodes_and_builtins
argument_list|()
expr_stmt|;
name|boolean_type_node
operator|=
name|integer_type_node
expr_stmt|;
name|boolean_true_node
operator|=
name|integer_one_node
expr_stmt|;
name|boolean_false_node
operator|=
name|integer_zero_node
expr_stmt|;
name|c_bool_type_node
operator|=
name|make_unsigned_type
argument_list|(
name|BOOL_TYPE_SIZE
argument_list|)
expr_stmt|;
name|TREE_SET_CODE
argument_list|(
name|c_bool_type_node
argument_list|,
name|BOOLEAN_TYPE
argument_list|)
expr_stmt|;
name|TYPE_MAX_VALUE
argument_list|(
name|c_bool_type_node
argument_list|)
operator|=
name|build_int_2
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|c_bool_type_node
argument_list|)
argument_list|)
operator|=
name|c_bool_type_node
expr_stmt|;
name|TYPE_PRECISION
argument_list|(
name|c_bool_type_node
argument_list|)
operator|=
literal|1
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"_Bool"
argument_list|)
argument_list|,
name|c_bool_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|c_bool_false_node
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|c_bool_false_node
argument_list|)
operator|=
name|c_bool_type_node
expr_stmt|;
name|c_bool_true_node
operator|=
name|build_int_2
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|c_bool_true_node
argument_list|)
operator|=
name|c_bool_type_node
expr_stmt|;
name|endlink
operator|=
name|void_list_node
expr_stmt|;
name|ptr_ftype_void
operator|=
name|build_function_type
argument_list|(
name|ptr_type_node
argument_list|,
name|endlink
argument_list|)
expr_stmt|;
name|ptr_ftype_ptr
operator|=
name|build_function_type
argument_list|(
name|ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
expr_stmt|;
name|pedantic_lvalues
operator|=
name|pedantic
expr_stmt|;
name|make_fname_decl
operator|=
name|c_make_fname_decl
expr_stmt|;
name|start_fname_decls
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create the VAR_DECL for __FUNCTION__ etc. ID is the name to give the    decl, NAME is the initialization string and TYPE_DEP indicates whether    NAME depended on the type of the function.  As we don't yet implement    delayed emission of static data, we mark the decl as emitted    so it is not placed in the output.  Anything using it must therefore pull    out the STRING_CST initializer directly.  This does mean that these names    are string merging candidates, which is wrong for C99's __func__.  FIXME.  */
end_comment

begin_function
specifier|static
name|tree
name|c_make_fname_decl
parameter_list|(
name|id
parameter_list|,
name|type_dep
parameter_list|)
name|tree
name|id
decl_stmt|;
name|int
name|type_dep
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|fname_as_string
argument_list|(
name|type_dep
argument_list|)
decl_stmt|;
name|tree
name|decl
decl_stmt|,
name|type
decl_stmt|,
name|init
decl_stmt|;
name|size_t
name|length
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|type
operator|=
name|build_array_type
argument_list|(
name|build_qualified_type
argument_list|(
name|char_type_node
argument_list|,
name|TYPE_QUAL_CONST
argument_list|)
argument_list|,
name|build_index_type
argument_list|(
name|size_int
argument_list|(
name|length
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|id
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* We don't push the decl, so have to set its context here.  */
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|current_function_decl
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|init
operator|=
name|build_string
argument_list|(
name|length
operator|+
literal|1
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
operator|=
name|type
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|init
expr_stmt|;
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|finish_decl
argument_list|(
name|decl
argument_list|,
name|init
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Return a definition for a builtin function named NAME and whose data type    is TYPE.  TYPE should be a function type with argument types.    FUNCTION_CODE tells later passes how to compile calls to this function.    See tree.h for its possible values.     If LIBRARY_NAME is nonzero, use that for DECL_ASSEMBLER_NAME,    the name to be called if we can't opencode the function.  If    ATTRS is nonzero, use that for the function's attribute list.  */
end_comment

begin_function
name|tree
name|builtin_function
parameter_list|(
name|name
parameter_list|,
name|type
parameter_list|,
name|function_code
parameter_list|,
name|class
parameter_list|,
name|library_name
parameter_list|,
name|attrs
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|int
name|function_code
decl_stmt|;
name|enum
name|built_in_class
name|class
decl_stmt|;
specifier|const
name|char
modifier|*
name|library_name
decl_stmt|;
name|tree
name|attrs
decl_stmt|;
block|{
name|tree
name|decl
init|=
name|build_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|get_identifier
argument_list|(
name|name
argument_list|)
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|library_name
condition|)
name|SET_DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|,
name|get_identifier
argument_list|(
name|library_name
argument_list|)
argument_list|)
expr_stmt|;
name|make_decl_rtl
argument_list|(
name|decl
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_BUILT_IN_CLASS
argument_list|(
name|decl
argument_list|)
operator|=
name|class
expr_stmt|;
name|DECL_FUNCTION_CODE
argument_list|(
name|decl
argument_list|)
operator|=
name|function_code
expr_stmt|;
comment|/* Warn if a function in the namespace for users      is used without an occasion to consider it declared.  */
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|!=
literal|'_'
operator|||
name|name
index|[
literal|1
index|]
operator|!=
literal|'_'
condition|)
name|C_DECL_ANTICIPATED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Possibly apply some default attributes to this built-in function.  */
if|if
condition|(
name|attrs
condition|)
name|decl_attributes
argument_list|(
operator|&
name|decl
argument_list|,
name|attrs
argument_list|,
name|ATTR_FLAG_BUILT_IN
argument_list|)
expr_stmt|;
else|else
name|decl_attributes
argument_list|(
operator|&
name|decl
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Apply default attributes to a function, if a system function with default    attributes.  */
end_comment

begin_function
name|void
name|c_insert_default_attributes
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
name|c_common_insert_default_attributes
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Called when a declaration is seen that contains no names to declare.    If its type is a reference to a structure, union or enum inherited    from a containing scope, shadow that tag name for the current scope    with a forward reference.    If its type defines a new named structure or union    or defines an enum, it is valid but we need not do anything here.    Otherwise, it is an error.  */
end_comment

begin_function
name|void
name|shadow_tag
parameter_list|(
name|declspecs
parameter_list|)
name|tree
name|declspecs
decl_stmt|;
block|{
name|shadow_tag_warned
argument_list|(
name|declspecs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|shadow_tag_warned
parameter_list|(
name|declspecs
parameter_list|,
name|warned
parameter_list|)
name|tree
name|declspecs
decl_stmt|;
name|int
name|warned
decl_stmt|;
comment|/* 1 => we have done a pedwarn.  2 => we have done a warning, but 	no pedwarn.  */
block|{
name|int
name|found_tag
init|=
literal|0
decl_stmt|;
name|tree
name|link
decl_stmt|;
name|tree
name|specs
decl_stmt|,
name|attrs
decl_stmt|;
name|pending_invalid_xref
operator|=
literal|0
expr_stmt|;
comment|/* Remove the attributes from declspecs, since they will confuse the      following code.  */
name|split_specs_attrs
argument_list|(
name|declspecs
argument_list|,
operator|&
name|specs
argument_list|,
operator|&
name|attrs
argument_list|)
expr_stmt|;
for|for
control|(
name|link
operator|=
name|specs
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
block|{
name|tree
name|value
init|=
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|RECORD_TYPE
operator|||
name|code
operator|==
name|UNION_TYPE
operator|||
name|code
operator|==
name|ENUMERAL_TYPE
condition|)
comment|/* Used to test also that TYPE_SIZE (value) != 0. 	   That caused warning for `struct foo;' at top level in the file.  */
block|{
name|tree
name|name
init|=
name|lookup_tag_reverse
argument_list|(
name|value
argument_list|)
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|found_tag
operator|++
expr_stmt|;
if|if
condition|(
name|name
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|warned
operator|!=
literal|1
operator|&&
name|code
operator|!=
name|ENUMERAL_TYPE
condition|)
comment|/* Empty unnamed enum OK */
block|{
name|pedwarn
argument_list|(
literal|"unnamed struct/union that defines no instances"
argument_list|)
expr_stmt|;
name|warned
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|t
operator|=
name|lookup_tag
argument_list|(
name|code
argument_list|,
name|name
argument_list|,
name|current_binding_level
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
literal|0
condition|)
block|{
name|t
operator|=
name|make_node
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|pushtag
argument_list|(
name|name
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|warned
operator|&&
operator|!
name|in_system_header
condition|)
block|{
name|warning
argument_list|(
literal|"useless keyword or type name in empty declaration"
argument_list|)
expr_stmt|;
name|warned
operator|=
literal|2
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|found_tag
operator|>
literal|1
condition|)
name|error
argument_list|(
literal|"two types specified in one empty declaration"
argument_list|)
expr_stmt|;
if|if
condition|(
name|warned
operator|!=
literal|1
condition|)
block|{
if|if
condition|(
name|found_tag
operator|==
literal|0
condition|)
name|pedwarn
argument_list|(
literal|"empty declaration"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Construct an array declarator.  EXPR is the expression inside [], or    NULL_TREE.  QUALS are the type qualifiers inside the [] (to be applied    to the pointer to which a parameter array is converted).  STATIC_P is    nonzero if "static" is inside the [], zero otherwise.  VLA_UNSPEC_P    is nonzero is the array is [*], a VLA of unspecified length which is    nevertheless a complete type (not currently implemented by GCC),    zero otherwise.  The declarator is constructed as an ARRAY_REF    (to be decoded by grokdeclarator), whose operand 0 is what's on the    left of the [] (filled by in set_array_declarator_type) and operand 1    is the expression inside; whose TREE_TYPE is the type qualifiers and    which has TREE_STATIC set if "static" is used.  */
end_comment

begin_function
name|tree
name|build_array_declarator
parameter_list|(
name|expr
parameter_list|,
name|quals
parameter_list|,
name|static_p
parameter_list|,
name|vla_unspec_p
parameter_list|)
name|tree
name|expr
decl_stmt|;
name|tree
name|quals
decl_stmt|;
name|int
name|static_p
decl_stmt|;
name|int
name|vla_unspec_p
decl_stmt|;
block|{
name|tree
name|decl
decl_stmt|;
name|decl
operator|=
name|build_nt
argument_list|(
name|ARRAY_REF
argument_list|,
name|NULL_TREE
argument_list|,
name|expr
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|quals
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
operator|(
name|static_p
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|flag_isoc99
condition|)
block|{
if|if
condition|(
name|static_p
operator|||
name|quals
operator|!=
name|NULL_TREE
condition|)
name|pedwarn
argument_list|(
literal|"ISO C90 does not support `static' or type qualifiers in parameter array declarators"
argument_list|)
expr_stmt|;
if|if
condition|(
name|vla_unspec_p
condition|)
name|pedwarn
argument_list|(
literal|"ISO C90 does not support `[*]' array declarators"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vla_unspec_p
condition|)
name|warning
argument_list|(
literal|"GCC does not yet properly implement `[*]' array declarators"
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Set the type of an array declarator.  DECL is the declarator, as    constructed by build_array_declarator; TYPE is what appears on the left    of the [] and goes in operand 0.  ABSTRACT_P is nonzero if it is an    abstract declarator, zero otherwise; this is used to reject static and    type qualifiers in abstract declarators, where they are not in the    C99 grammar.  */
end_comment

begin_function
name|tree
name|set_array_declarator_type
parameter_list|(
name|decl
parameter_list|,
name|type
parameter_list|,
name|abstract_p
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|int
name|abstract_p
decl_stmt|;
block|{
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|abstract_p
operator|&&
operator|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL_TREE
operator|||
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
name|error
argument_list|(
literal|"static or type qualifiers in abstract declarator"
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Decode a "typename", such as "int **", returning a ..._TYPE node.  */
end_comment

begin_function
name|tree
name|groktypename
parameter_list|(
name|typename
parameter_list|)
name|tree
name|typename
decl_stmt|;
block|{
name|tree
name|specs
decl_stmt|,
name|attrs
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|typename
argument_list|)
operator|!=
name|TREE_LIST
condition|)
return|return
name|typename
return|;
name|split_specs_attrs
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|typename
argument_list|)
argument_list|,
operator|&
name|specs
argument_list|,
operator|&
name|attrs
argument_list|)
expr_stmt|;
name|typename
operator|=
name|grokdeclarator
argument_list|(
name|TREE_VALUE
argument_list|(
name|typename
argument_list|)
argument_list|,
name|specs
argument_list|,
name|TYPENAME
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Apply attributes.  */
name|decl_attributes
argument_list|(
operator|&
name|typename
argument_list|,
name|attrs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|typename
return|;
block|}
end_function

begin_comment
comment|/* Return a PARM_DECL node for a given pair of specs and declarator.  */
end_comment

begin_function
name|tree
name|groktypename_in_parm_context
parameter_list|(
name|typename
parameter_list|)
name|tree
name|typename
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|typename
argument_list|)
operator|!=
name|TREE_LIST
condition|)
return|return
name|typename
return|;
return|return
name|grokdeclarator
argument_list|(
name|TREE_VALUE
argument_list|(
name|typename
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|typename
argument_list|)
argument_list|,
name|PARM
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Decode a declarator in an ordinary declaration or data definition.    This is called as soon as the type information and variable name    have been parsed, before parsing the initializer if any.    Here we create the ..._DECL node, fill in its type,    and put it on the list of decls for the current context.    The ..._DECL node is returned as the value.     Exception: for arrays where the length is not specified,    the type is left null, to be filled in by `finish_decl'.     Function definitions do not come here; they go to start_function    instead.  However, external and forward declarations of functions    do go through here.  Structure field declarations are done by    grokfield and not through here.  */
end_comment

begin_function
name|tree
name|start_decl
parameter_list|(
name|declarator
parameter_list|,
name|declspecs
parameter_list|,
name|initialized
parameter_list|,
name|attributes
parameter_list|)
name|tree
name|declarator
decl_stmt|,
name|declspecs
decl_stmt|;
name|int
name|initialized
decl_stmt|;
name|tree
name|attributes
decl_stmt|;
block|{
name|tree
name|decl
decl_stmt|;
name|tree
name|tem
decl_stmt|;
comment|/* An object declared as __attribute__((deprecated)) suppresses      warnings of uses of other deprecated items.  */
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"deprecated"
argument_list|,
name|attributes
argument_list|)
condition|)
name|deprecated_state
operator|=
name|DEPRECATED_SUPPRESS
expr_stmt|;
name|decl
operator|=
name|grokdeclarator
argument_list|(
name|declarator
argument_list|,
name|declspecs
argument_list|,
name|NORMAL
argument_list|,
name|initialized
argument_list|)
expr_stmt|;
name|deprecated_state
operator|=
name|DEPRECATED_NORMAL
expr_stmt|;
if|if
condition|(
name|warn_main
operator|>
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|&&
name|MAIN_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|warning_with_decl
argument_list|(
name|decl
argument_list|,
literal|"`%s' is usually a function"
argument_list|)
expr_stmt|;
if|if
condition|(
name|initialized
condition|)
comment|/* Is it valid for this decl to have an initializer at all?        If not, set INITIALIZED to zero, which will indirectly        tell `finish_decl' to ignore the initializer once it is parsed.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
case|case
name|TYPE_DECL
case|:
name|error
argument_list|(
literal|"typedef `%s' is initialized (use __typeof__ instead)"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|initialized
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|FUNCTION_DECL
case|:
name|error
argument_list|(
literal|"function `%s' is initialized like a variable"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|initialized
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|PARM_DECL
case|:
comment|/* DECL_INITIAL in a PARM_DECL is really DECL_ARG_TYPE.  */
name|error
argument_list|(
literal|"parameter `%s' is initialized"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|initialized
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
comment|/* Don't allow initializations for incomplete types 	   except for arrays which might be completed by the initialization.  */
comment|/* This can happen if the array size is an undefined macro.  We already 	   gave a warning, so we don't need another one.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|==
name|error_mark_node
condition|)
name|initialized
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|COMPLETE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
comment|/* A complete type is ok if size is fixed.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|C_DECL_VARIABLE_SIZE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"variable-sized object may not be initialized"
argument_list|)
expr_stmt|;
name|initialized
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|ARRAY_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"variable `%s' has initializer but incomplete type"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|initialized
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"elements of array `%s' have incomplete type"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|initialized
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|initialized
condition|)
block|{
if|#
directive|if
literal|0
comment|/* Seems redundant with grokdeclarator.  */
block|if (current_binding_level != global_binding_level&& DECL_EXTERNAL (decl)&& TREE_CODE (decl) != FUNCTION_DECL) 	warning ("declaration of `%s' has `extern' and is initialized", 		 IDENTIFIER_POINTER (DECL_NAME (decl)));
endif|#
directive|endif
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
condition|)
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Tell `pushdecl' this is an initialized decl 	 even though we don't yet have the initializer expression. 	 Also tell `finish_decl' it may store the real initializer.  */
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
comment|/* If this is a function declaration, write a record describing it to the      prototypes file (if requested).  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|gen_aux_info_record
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* ANSI specifies that a tentative definition which is not merged with      a non-tentative definition behaves exactly like a definition with an      initializer equal to zero.  (Section 3.7.2)       -fno-common gives strict ANSI behavior, though this tends to break      a large body of code that grew up without this rule.       Thread-local variables are never common, since there's no entrenched      body of code to break, and it allows more efficient variable references      in the presense of dynamic linking.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
operator|!
name|initialized
operator|&&
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_THREAD_LOCAL
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|flag_no_common
condition|)
name|DECL_COMMON
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Set attributes here so if duplicate decl, will have proper attributes.  */
name|decl_attributes
argument_list|(
operator|&
name|decl
argument_list|,
name|attributes
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If #pragma weak was used, mark the decl weak now.  */
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
condition|)
name|maybe_apply_pragma_weak
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_DECLARED_INLINE_P
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_UNINLINABLE
argument_list|(
name|decl
argument_list|)
operator|&&
name|lookup_attribute
argument_list|(
literal|"noinline"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|warning_with_decl
argument_list|(
name|decl
argument_list|,
literal|"inline function `%s' given attribute noinline"
argument_list|)
expr_stmt|;
comment|/* Add this decl to the current binding level.      TEM may equal DECL or it may be a previous decl of the same name.  */
name|tem
operator|=
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* For a local variable, define the RTL now.  */
if|if
condition|(
name|current_binding_level
operator|!=
name|global_binding_level
comment|/* But not if this is a duplicate decl 	 and we preserved the rtl from the previous one 	 (which may or may not happen).  */
operator|&&
operator|!
name|DECL_RTL_SET_P
argument_list|(
name|tem
argument_list|)
operator|&&
operator|!
name|DECL_CONTEXT
argument_list|(
name|tem
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
operator|!=
name|error_mark_node
operator|&&
name|COMPLETE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|)
condition|)
name|expand_decl
argument_list|(
name|tem
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|DECL_INITIAL
argument_list|(
name|tem
argument_list|)
operator|!=
literal|0
condition|)
name|expand_decl
argument_list|(
name|tem
argument_list|)
expr_stmt|;
block|}
return|return
name|tem
return|;
block|}
end_function

begin_comment
comment|/* Finish processing of a declaration;    install its initial value.    If the length of an array type is not known before,    it must be determined now, from the initial value, or it is an error.  */
end_comment

begin_function
name|void
name|finish_decl
parameter_list|(
name|decl
parameter_list|,
name|init
parameter_list|,
name|asmspec_tree
parameter_list|)
name|tree
name|decl
decl_stmt|,
name|init
decl_stmt|;
name|tree
name|asmspec_tree
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|int
name|was_incomplete
init|=
operator|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|asmspec
init|=
literal|0
decl_stmt|;
comment|/* If a name was specified, get the string.  */
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
condition|)
name|asmspec_tree
operator|=
name|maybe_apply_renaming_pragma
argument_list|(
name|decl
argument_list|,
name|asmspec_tree
argument_list|)
expr_stmt|;
if|if
condition|(
name|asmspec_tree
condition|)
name|asmspec
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|asmspec_tree
argument_list|)
expr_stmt|;
comment|/* If `start_decl' didn't like having an initialization, ignore it now.  */
if|if
condition|(
name|init
operator|!=
literal|0
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
name|init
operator|=
literal|0
expr_stmt|;
comment|/* Don't crash if parm is initialized.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|PARM_DECL
condition|)
name|init
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|init
condition|)
name|store_init_value
argument_list|(
name|decl
argument_list|,
name|init
argument_list|)
expr_stmt|;
comment|/* Deduce size of array from initialization, if not already known */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
block|{
name|int
name|do_default
init|=
operator|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
comment|/* Even if pedantic, an external linkage array 	      may have incomplete type at first.  */
condition|?
name|pedantic
operator|&&
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
else|:
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|)
decl_stmt|;
name|int
name|failure
init|=
name|complete_array_type
argument_list|(
name|type
argument_list|,
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|,
name|do_default
argument_list|)
decl_stmt|;
comment|/* Get the completed type made by complete_array_type.  */
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|failure
operator|==
literal|1
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"initializer fails to determine size of `%s'"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|failure
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|do_default
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"array size missing in `%s'"
argument_list|)
expr_stmt|;
comment|/* If a `static' var's size isn't known, 	     make it extern as well as static, so it does not get 	     allocated. 	     If it is not `static', then do not mark extern; 	     finish_incomplete_decl will give it a default size 	     and it will get allocated.  */
elseif|else
if|if
condition|(
operator|!
name|pedantic
operator|&&
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* TYPE_MAX_VALUE is always one less than the number of elements 	 in the array, because we start counting at zero.  Therefore, 	 warn only if the value is less than zero.  */
elseif|else
if|if
condition|(
name|pedantic
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
operator|&&
name|tree_int_cst_sgn
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"zero or negative size array `%s'"
argument_list|)
expr_stmt|;
name|layout_decl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
if|if
condition|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|!=
name|error_mark_node
operator|&&
name|COMPLETE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|layout_decl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
comment|/* Don't give an error if we already gave one earlier.  */
operator|&&
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|!=
name|error_mark_node
operator|&&
operator|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
condition|?
comment|/* A static variable with an incomplete type 		   is an error if it is initialized. 		   Also if it is not file scope. 		   Otherwise, let it through, but if it is not `extern' 		   then it may cause an error message later.  */
operator|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|||
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|)
else|:
comment|/* An automatic variable with an incomplete type 		   is an error.  */
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
block|{
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"storage size of `%s' isn't known"
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|||
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|)
operator|&&
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
name|constant_expression_warning
argument_list|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"storage size of `%s' isn't constant"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_USED
argument_list|(
name|type
argument_list|)
condition|)
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If this is a function and an assembler name is specified, it isn't      builtin any more.  Also reset DECL_RTL so we can give it its new      name.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|asmspec
condition|)
block|{
name|DECL_BUILT_IN_CLASS
argument_list|(
name|decl
argument_list|)
operator|=
name|NOT_BUILT_IN
expr_stmt|;
name|SET_DECL_RTL
argument_list|(
name|decl
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|SET_DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|,
name|get_identifier
argument_list|(
name|asmspec
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Output the assembler code and/or RTL code for variables and functions,      unless the type is an undefined structure or union.      If not, it will get done when the type is completed.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
comment|/* This is a no-op in c-lang.c or something real in objc-act.c.  */
if|if
condition|(
name|flag_objc
condition|)
name|objc_check_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
operator|||
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|error_mark_node
condition|)
comment|/* Don't output anything 	       when a tentative file-scope definition is seen. 	       But at end of compilation, do output code for them.  */
name|DECL_DEFER_OUTPUT
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|rest_of_decl_compilation
argument_list|(
name|decl
argument_list|,
name|asmspec
argument_list|,
operator|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|||
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This is a local variable.  If there is an ASMSPEC, the 	     user has requested that we handle it specially.  */
if|if
condition|(
name|asmspec
condition|)
block|{
comment|/* In conjunction with an ASMSPEC, the `register' 		 keyword indicates that we should place the variable 		 in a particular register.  */
if|if
condition|(
name|DECL_REGISTER
argument_list|(
name|decl
argument_list|)
condition|)
name|DECL_C_HARD_REGISTER
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* If this is not a static variable, issue a warning. 		 It doesn't make any sense to give an ASMSPEC for an 		 ordinary, non-register local variable.  Historically, 		 GCC has accepted -- but ignored -- the ASMSPEC in 		 this case.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
operator|!
name|DECL_REGISTER
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
condition|)
name|warning_with_decl
argument_list|(
name|decl
argument_list|,
literal|"ignoring asm-specifier for non-static local variable `%s'"
argument_list|)
expr_stmt|;
else|else
name|SET_DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|,
name|get_identifier
argument_list|(
name|asmspec
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
name|add_decl_stmt
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Recompute the RTL of a local array now 	     if it used to be an incomplete type.  */
if|if
condition|(
name|was_incomplete
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* If we used it already as memory, it must stay in memory.  */
name|TREE_ADDRESSABLE
argument_list|(
name|decl
argument_list|)
operator|=
name|TREE_USED
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* If it's still incomplete now, no init will save it.  */
if|if
condition|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
comment|/* This is a no-op in c-lang.c or something real in objc-act.c.  */
if|if
condition|(
name|flag_objc
condition|)
name|objc_check_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|rest_of_decl_compilation
argument_list|(
name|decl
argument_list|,
name|NULL
argument_list|,
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* At the end of a declaration, throw away any variable type sizes      of types defined inside that declaration.  There is no use      computing them in the following function definition.  */
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
condition|)
name|get_pending_sizes
argument_list|()
expr_stmt|;
comment|/* Install a cleanup (aka destructor) if one was given.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|tree
name|attr
init|=
name|lookup_attribute
argument_list|(
literal|"cleanup"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|attr
condition|)
block|{
specifier|static
name|bool
name|eh_initialized_p
decl_stmt|;
name|tree
name|cleanup_id
init|=
name|TREE_VALUE
argument_list|(
name|TREE_VALUE
argument_list|(
name|attr
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|cleanup_decl
init|=
name|lookup_name
argument_list|(
name|cleanup_id
argument_list|)
decl_stmt|;
name|tree
name|cleanup
decl_stmt|;
comment|/* Build "cleanup(&decl)" for the destructor.  */
name|cleanup
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cleanup
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|cleanup
argument_list|)
expr_stmt|;
name|cleanup
operator|=
name|build_function_call
argument_list|(
name|cleanup_decl
argument_list|,
name|cleanup
argument_list|)
expr_stmt|;
comment|/* Don't warn about decl unused; the cleanup uses it.  */
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Initialize EH, if we've been told to do so.  */
if|if
condition|(
name|flag_exceptions
operator|&&
operator|!
name|eh_initialized_p
condition|)
block|{
name|eh_initialized_p
operator|=
name|true
expr_stmt|;
name|eh_personality_libfunc
operator|=
name|init_one_libfunc
argument_list|(
name|USING_SJLJ_EXCEPTIONS
condition|?
literal|"__gcc_personality_sj0"
else|:
literal|"__gcc_personality_v0"
argument_list|)
expr_stmt|;
name|using_eh_for_cleanups
argument_list|()
expr_stmt|;
block|}
name|add_stmt
argument_list|(
name|build_stmt
argument_list|(
name|CLEANUP_STMT
argument_list|,
name|decl
argument_list|,
name|cleanup
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Given a parsed parameter declaration,    decode it into a PARM_DECL and push that on the current binding level.    Also, for the sake of forward parm decls,    record the given order of parms in `parm_order'.  */
end_comment

begin_function
name|void
name|push_parm_decl
parameter_list|(
name|parm
parameter_list|)
name|tree
name|parm
decl_stmt|;
block|{
name|tree
name|decl
decl_stmt|;
name|int
name|old_immediate_size_expand
init|=
name|immediate_size_expand
decl_stmt|;
comment|/* Don't try computing parm sizes now -- wait till fn is called.  */
name|immediate_size_expand
operator|=
literal|0
expr_stmt|;
name|decl
operator|=
name|grokdeclarator
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
argument_list|)
argument_list|,
name|PARM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|decl_attributes
argument_list|(
operator|&
name|decl
argument_list|,
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (DECL_NAME (decl))     {       tree olddecl;       olddecl = lookup_name (DECL_NAME (decl));       if (pedantic&& olddecl != 0&& TREE_CODE (olddecl) == TYPE_DECL) 	pedwarn_with_decl (decl, 			   "ISO C forbids parameter `%s' shadowing typedef");     }
endif|#
directive|endif
name|decl
operator|=
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|immediate_size_expand
operator|=
name|old_immediate_size_expand
expr_stmt|;
name|current_binding_level
operator|->
name|parm_order
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|decl
argument_list|,
name|current_binding_level
operator|->
name|parm_order
argument_list|)
expr_stmt|;
comment|/* Add this decl to the current binding level.  */
name|finish_decl
argument_list|(
name|decl
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clear the given order of parms in `parm_order'.    Used at start of parm list,    and also at semicolon terminating forward decls.  */
end_comment

begin_function
name|void
name|clear_parm_order
parameter_list|()
block|{
name|current_binding_level
operator|->
name|parm_order
operator|=
name|NULL_TREE
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Build a COMPOUND_LITERAL_EXPR.  TYPE is the type given in the compound    literal, which may be an incomplete array type completed by the    initializer; INIT is a CONSTRUCTOR that initializes the compound    literal.  */
end_comment

begin_function
name|tree
name|build_compound_literal
parameter_list|(
name|type
parameter_list|,
name|init
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
name|init
decl_stmt|;
block|{
comment|/* We do not use start_decl here because we have a type, not a declarator;      and do not use finish_decl because the decl should be stored inside      the COMPOUND_LITERAL_EXPR rather than added elsewhere as a DECL_STMT.  */
name|tree
name|decl
init|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|tree
name|complit
decl_stmt|;
name|tree
name|stmt
decl_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
operator|(
name|current_binding_level
operator|==
name|global_binding_level
operator|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|current_function_decl
expr_stmt|;
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|type
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|=
name|TREE_READONLY
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|store_init_value
argument_list|(
name|decl
argument_list|,
name|init
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|int
name|failure
init|=
name|complete_array_type
argument_list|(
name|type
argument_list|,
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|failure
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
operator|||
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
name|stmt
operator|=
name|build_stmt
argument_list|(
name|DECL_STMT
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|complit
operator|=
name|build1
argument_list|(
name|COMPOUND_LITERAL_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|complit
argument_list|)
operator|=
literal|1
expr_stmt|;
name|layout_decl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* This decl needs a name for the assembler output.  We also need 	 a unique suffix to be added to the name.  */
name|char
modifier|*
name|name
decl_stmt|;
specifier|extern
name|int
name|var_labelno
decl_stmt|;
name|ASM_FORMAT_PRIVATE_NAME
argument_list|(
name|name
argument_list|,
literal|"__compound_literal"
argument_list|,
name|var_labelno
argument_list|)
expr_stmt|;
name|var_labelno
operator|++
expr_stmt|;
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|=
name|get_identifier
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|DECL_DEFER_OUTPUT
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_COMDAT
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|rest_of_decl_compilation
argument_list|(
name|decl
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|complit
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make TYPE a complete type based on INITIAL_VALUE.    Return 0 if successful, 1 if INITIAL_VALUE can't be deciphered,    2 if there was no information (in which case assume 1 if DO_DEFAULT).  */
end_comment

begin_function
name|int
name|complete_array_type
parameter_list|(
name|type
parameter_list|,
name|initial_value
parameter_list|,
name|do_default
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
name|initial_value
decl_stmt|;
name|int
name|do_default
decl_stmt|;
block|{
name|tree
name|maxindex
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|value
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|initial_value
condition|)
block|{
comment|/* Note MAXINDEX  is really the maximum index, 	 one less than the size.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|initial_value
argument_list|)
operator|==
name|STRING_CST
condition|)
block|{
name|int
name|eltsize
init|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|initial_value
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|maxindex
operator|=
name|build_int_2
argument_list|(
operator|(
name|TREE_STRING_LENGTH
argument_list|(
name|initial_value
argument_list|)
operator|/
name|eltsize
operator|)
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|initial_value
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
block|{
name|tree
name|elts
init|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|initial_value
argument_list|)
decl_stmt|;
name|maxindex
operator|=
name|build_int_2
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|elts
condition|;
name|elts
operator|=
name|TREE_CHAIN
argument_list|(
name|elts
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|elts
argument_list|)
condition|)
name|maxindex
operator|=
name|TREE_PURPOSE
argument_list|(
name|elts
argument_list|)
expr_stmt|;
else|else
name|maxindex
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|maxindex
argument_list|,
name|integer_one_node
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|maxindex
operator|=
name|copy_node
argument_list|(
name|maxindex
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Make an error message unless that happened already.  */
if|if
condition|(
name|initial_value
operator|!=
name|error_mark_node
condition|)
name|value
operator|=
literal|1
expr_stmt|;
comment|/* Prevent further error messages.  */
name|maxindex
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|maxindex
condition|)
block|{
if|if
condition|(
name|do_default
condition|)
name|maxindex
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|value
operator|=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|maxindex
condition|)
block|{
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
operator|=
name|build_index_type
argument_list|(
name|maxindex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TREE_TYPE
argument_list|(
name|maxindex
argument_list|)
condition|)
name|TREE_TYPE
argument_list|(
name|maxindex
argument_list|)
operator|=
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
comment|/* Lay out the type now that we can get the real answer.  */
name|layout_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Determine whether TYPE is a structure with a flexible array member,    or a union containing such a structure (possibly recursively).  */
end_comment

begin_function
specifier|static
name|bool
name|flexible_array_type_p
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|x
decl_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|RECORD_TYPE
case|:
name|x
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|NULL_TREE
condition|)
return|return
name|false
return|;
while|while
condition|(
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|TYPE_MAX_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
case|case
name|UNION_TYPE
case|:
for|for
control|(
name|x
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|x
operator|!=
name|NULL_TREE
condition|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
control|)
block|{
if|if
condition|(
name|flexible_array_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
default|default:
return|return
name|false
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given declspecs and a declarator,    determine the name and type of the object declared    and construct a ..._DECL node for it.    (In one case we can return a ..._TYPE node instead.     For invalid input we sometimes return 0.)     DECLSPECS is a chain of tree_list nodes whose value fields     are the storage classes and type specifiers.     DECL_CONTEXT says which syntactic context this declaration is in:      NORMAL for most contexts.  Make a VAR_DECL or FUNCTION_DECL or TYPE_DECL.      FUNCDEF for a function definition.  Like NORMAL but a few different       error messages in each case.  Return value may be zero meaning       this definition is too screwy to try to parse.      PARM for a parameter declaration (either within a function prototype       or before a function body).  Make a PARM_DECL, or return void_type_node.      TYPENAME if for a typename (in a cast or sizeof).       Don't make a DECL node; just return the ..._TYPE node.      FIELD for a struct or union field; make a FIELD_DECL.      BITFIELD for a field with specified width.    INITIALIZED is 1 if the decl has an initializer.     In the TYPENAME case, DECLARATOR is really an absolute declarator.    It may also be so in the PARM case, for a prototype where the    argument type is specified but not the name.     This function is where the complicated C meanings of `static'    and `extern' are interpreted.  */
end_comment

begin_function
specifier|static
name|tree
name|grokdeclarator
parameter_list|(
name|declarator
parameter_list|,
name|declspecs
parameter_list|,
name|decl_context
parameter_list|,
name|initialized
parameter_list|)
name|tree
name|declspecs
decl_stmt|;
name|tree
name|declarator
decl_stmt|;
name|enum
name|decl_context
name|decl_context
decl_stmt|;
name|int
name|initialized
decl_stmt|;
block|{
name|int
name|specbits
init|=
literal|0
decl_stmt|;
name|tree
name|spec
decl_stmt|;
name|tree
name|type
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|longlong
init|=
literal|0
decl_stmt|;
name|int
name|constp
decl_stmt|;
name|int
name|restrictp
decl_stmt|;
name|int
name|volatilep
decl_stmt|;
name|int
name|type_quals
init|=
name|TYPE_UNQUALIFIED
decl_stmt|;
name|int
name|inlinep
decl_stmt|;
name|int
name|explicit_int
init|=
literal|0
decl_stmt|;
name|int
name|explicit_char
init|=
literal|0
decl_stmt|;
name|int
name|defaulted_int
init|=
literal|0
decl_stmt|;
name|tree
name|typedef_decl
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|tree
name|typedef_type
init|=
literal|0
decl_stmt|;
name|int
name|funcdef_flag
init|=
literal|0
decl_stmt|;
name|enum
name|tree_code
name|innermost_code
init|=
name|ERROR_MARK
decl_stmt|;
name|int
name|bitfield
init|=
literal|0
decl_stmt|;
name|int
name|size_varies
init|=
literal|0
decl_stmt|;
name|tree
name|decl_attr
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|array_ptr_quals
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|array_parm_static
init|=
literal|0
decl_stmt|;
name|tree
name|returned_attrs
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|decl_context
operator|==
name|BITFIELD
condition|)
name|bitfield
operator|=
literal|1
operator|,
name|decl_context
operator|=
name|FIELD
expr_stmt|;
if|if
condition|(
name|decl_context
operator|==
name|FUNCDEF
condition|)
name|funcdef_flag
operator|=
literal|1
operator|,
name|decl_context
operator|=
name|NORMAL
expr_stmt|;
comment|/* Look inside a declarator for the name being declared      and get it as a string, for an error message.  */
block|{
name|tree
name|decl
init|=
name|declarator
decl_stmt|;
name|name
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|decl
condition|)
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
case|case
name|ARRAY_REF
case|:
case|case
name|INDIRECT_REF
case|:
case|case
name|CALL_EXPR
case|:
name|innermost_code
operator|=
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|decl
operator|=
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|TREE_LIST
case|:
name|decl
operator|=
name|TREE_VALUE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
break|break;
case|case
name|IDENTIFIER_NODE
case|:
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|decl
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|name
operator|==
literal|0
condition|)
name|name
operator|=
literal|"type name"
expr_stmt|;
block|}
comment|/* A function definition's declarator must have the form of      a function declarator.  */
if|if
condition|(
name|funcdef_flag
operator|&&
name|innermost_code
operator|!=
name|CALL_EXPR
condition|)
return|return
literal|0
return|;
comment|/* Anything declared one level down from the top level      must be one of the parameters of a function      (because the body is at least two levels down).  */
comment|/* If this looks like a function definition, make it one,      even if it occurs where parms are expected.      Then store_parm_decls will reject it and not use it as a parm.  */
if|if
condition|(
name|decl_context
operator|==
name|NORMAL
operator|&&
operator|!
name|funcdef_flag
operator|&&
name|current_binding_level
operator|->
name|parm_flag
condition|)
name|decl_context
operator|=
name|PARM
expr_stmt|;
comment|/* Look through the decl specs and record which ones appear.      Some typespecs are defined as built-in typenames.      Others, the ones that are modifiers of other types,      are represented by bits in SPECBITS: set the bits for      the modifiers that appear.  Storage class keywords are also in SPECBITS.       If there is a typedef name or a type, store the type in TYPE.      This includes builtin typedefs such as `int'.       Set EXPLICIT_INT or EXPLICIT_CHAR if the type is `int' or `char'      and did not come from a user typedef.       Set LONGLONG if `long' is mentioned twice.  */
for|for
control|(
name|spec
operator|=
name|declspecs
init|;
name|spec
condition|;
name|spec
operator|=
name|TREE_CHAIN
argument_list|(
name|spec
argument_list|)
control|)
block|{
name|tree
name|id
init|=
name|TREE_VALUE
argument_list|(
name|spec
argument_list|)
decl_stmt|;
comment|/* If the entire declaration is itself tagged as deprecated then          suppress reports of deprecated items.  */
if|if
condition|(
name|id
operator|&&
name|TREE_DEPRECATED
argument_list|(
name|id
argument_list|)
condition|)
block|{
if|if
condition|(
name|deprecated_state
operator|!=
name|DEPRECATED_SUPPRESS
condition|)
name|warn_deprecated_use
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|id
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_INT
index|]
condition|)
name|explicit_int
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|id
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CHAR
index|]
condition|)
name|explicit_char
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|id
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|&&
name|C_IS_RESERVED_WORD
argument_list|(
name|id
argument_list|)
condition|)
block|{
name|enum
name|rid
name|i
init|=
name|C_RID_CODE
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|i
operator|<=
operator|(
name|int
operator|)
name|RID_LAST_MODIFIER
condition|)
block|{
if|if
condition|(
name|i
operator|==
name|RID_LONG
operator|&&
operator|(
name|specbits
operator|&
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_LONG
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|longlong
condition|)
name|error
argument_list|(
literal|"`long long long' is too long for GCC"
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|flag_isoc99
operator|&&
operator|!
name|in_system_header
operator|&&
name|warn_long_long
condition|)
name|pedwarn
argument_list|(
literal|"ISO C90 does not support `long long'"
argument_list|)
expr_stmt|;
name|longlong
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|specbits
operator|&
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|i
operator|)
condition|)
block|{
if|if
condition|(
name|i
operator|==
name|RID_CONST
operator|||
name|i
operator|==
name|RID_VOLATILE
operator|||
name|i
operator|==
name|RID_RESTRICT
condition|)
block|{
if|if
condition|(
operator|!
name|flag_isoc99
condition|)
name|pedwarn
argument_list|(
literal|"duplicate `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"duplicate `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Diagnose "__thread extern".  Recall that this list 		 is in the reverse order seen in the text.  */
if|if
condition|(
name|i
operator|==
name|RID_THREAD
operator|&&
operator|(
name|specbits
operator|&
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_EXTERN
operator||
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_STATIC
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_EXTERN
condition|)
name|error
argument_list|(
literal|"`__thread' before `extern'"
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"`__thread' before `static'"
argument_list|)
expr_stmt|;
block|}
name|specbits
operator||=
literal|1
operator|<<
operator|(
name|int
operator|)
name|i
expr_stmt|;
goto|goto
name|found
goto|;
block|}
block|}
if|if
condition|(
name|type
condition|)
name|error
argument_list|(
literal|"two or more data types in declaration of `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Actual typedefs come to us as TYPE_DECL nodes.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|id
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|id
argument_list|)
operator|==
name|error_mark_node
condition|)
empty_stmt|;
comment|/* Allow the type to default to int to avoid cascading errors.  */
else|else
block|{
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|decl_attr
operator|=
name|DECL_ATTRIBUTES
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|typedef_decl
operator|=
name|id
expr_stmt|;
block|}
block|}
comment|/* Built-in types come as identifiers.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|id
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
name|tree
name|t
init|=
name|lookup_name
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|==
name|error_mark_node
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|t
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
name|error
argument_list|(
literal|"`%s' fails to be a typedef or built in type"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|typedef_decl
operator|=
name|t
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|id
argument_list|)
operator|!=
name|ERROR_MARK
condition|)
name|type
operator|=
name|id
expr_stmt|;
name|found
label|:
empty_stmt|;
block|}
name|typedef_type
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|type
condition|)
name|size_varies
operator|=
name|C_TYPE_VARIABLE_SIZE
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* No type at all: default to `int', and set DEFAULTED_INT      because it was not a user-defined typedef.  */
if|if
condition|(
name|type
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
operator|!
operator|(
name|specbits
operator|&
operator|(
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_LONG
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_SHORT
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_SIGNED
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_UNSIGNED
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_COMPLEX
operator|)
operator|)
operator|)
operator|)
comment|/* Don't warn about typedef foo = bar.  */
operator|&&
operator|!
operator|(
name|specbits
operator|&
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_TYPEDEF
operator|)
operator|&&
name|initialized
operator|)
operator|&&
operator|!
name|in_system_header
condition|)
block|{
comment|/* Issue a warning if this is an ISO C 99 program or if -Wreturn-type 	     and this is a function, or if -Wimplicit; prefer the former 	     warning since it is more explicit.  */
if|if
condition|(
operator|(
name|warn_implicit_int
operator|||
name|warn_return_type
operator|||
name|flag_isoc99
operator|)
operator|&&
name|funcdef_flag
condition|)
name|warn_about_return_type
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|warn_implicit_int
operator|||
name|flag_isoc99
condition|)
name|pedwarn_c99
argument_list|(
literal|"type defaults to `int' in declaration of `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|defaulted_int
operator|=
literal|1
expr_stmt|;
name|type
operator|=
name|integer_type_node
expr_stmt|;
block|}
comment|/* Now process the modifiers that were specified      and check for invalid combinations.  */
comment|/* Long double is a special combination.  */
if|if
condition|(
operator|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_LONG
operator|)
operator|&&
operator|!
name|longlong
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|double_type_node
condition|)
block|{
name|specbits
operator|&=
operator|~
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_LONG
operator|)
expr_stmt|;
name|type
operator|=
name|long_double_type_node
expr_stmt|;
block|}
comment|/* Check all other uses of type modifiers.  */
if|if
condition|(
name|specbits
operator|&
operator|(
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_LONG
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_SHORT
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_UNSIGNED
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_SIGNED
operator|)
operator|)
condition|)
block|{
name|int
name|ok
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_LONG
operator|)
operator|&&
operator|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_SHORT
operator|)
condition|)
name|error
argument_list|(
literal|"both long and short specified for `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_LONG
operator|)
operator|||
operator|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_SHORT
operator|)
operator|)
operator|&&
name|explicit_char
condition|)
name|error
argument_list|(
literal|"long or short specified with char for `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_LONG
operator|)
operator|||
operator|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_SHORT
operator|)
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REAL_TYPE
condition|)
block|{
specifier|static
name|int
name|already
init|=
literal|0
decl_stmt|;
name|error
argument_list|(
literal|"long or short specified with floating type for `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|already
operator|&&
operator|!
name|pedantic
condition|)
block|{
name|error
argument_list|(
literal|"the only valid combination is `long double'"
argument_list|)
expr_stmt|;
name|already
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_SIGNED
operator|)
operator|&&
operator|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_UNSIGNED
operator|)
condition|)
name|error
argument_list|(
literal|"both signed and unsigned specified for `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|INTEGER_TYPE
condition|)
name|error
argument_list|(
literal|"long, short, signed or unsigned invalid for `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
block|{
name|ok
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|explicit_int
operator|&&
operator|!
name|defaulted_int
operator|&&
operator|!
name|explicit_char
condition|)
block|{
name|error
argument_list|(
literal|"long, short, signed or unsigned used invalidly for `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|ok
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Discard the type modifiers if they are invalid.  */
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|specbits
operator|&=
operator|~
operator|(
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_LONG
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_SHORT
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_UNSIGNED
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_SIGNED
operator|)
operator|)
expr_stmt|;
name|longlong
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|specbits
operator|&
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_COMPLEX
operator|)
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|INTEGER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|REAL_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"complex invalid for `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|specbits
operator|&=
operator|~
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_COMPLEX
operator|)
expr_stmt|;
block|}
comment|/* Decide whether an integer type is signed or not.      Optionally treat bitfields as signed by default.  */
if|if
condition|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_UNSIGNED
operator|||
operator|(
name|bitfield
operator|&&
operator|!
name|flag_signed_bitfields
operator|&&
operator|(
name|explicit_int
operator|||
name|defaulted_int
operator|||
name|explicit_char
comment|/* A typedef for plain `int' without `signed' 		 can be controlled just like plain `int'.  */
operator|||
operator|!
operator|(
name|typedef_decl
operator|!=
literal|0
operator|&&
name|C_TYPEDEF_EXPLICITLY_SIGNED
argument_list|(
name|typedef_decl
argument_list|)
operator|)
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|ENUMERAL_TYPE
operator|&&
operator|!
operator|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_SIGNED
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|longlong
condition|)
name|type
operator|=
name|long_long_unsigned_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_LONG
condition|)
name|type
operator|=
name|long_unsigned_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_SHORT
condition|)
name|type
operator|=
name|short_unsigned_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|char_type_node
condition|)
name|type
operator|=
name|unsigned_char_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|typedef_decl
condition|)
name|type
operator|=
name|c_common_unsigned_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
else|else
name|type
operator|=
name|unsigned_type_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_SIGNED
operator|)
operator|&&
name|type
operator|==
name|char_type_node
condition|)
name|type
operator|=
name|signed_char_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|longlong
condition|)
name|type
operator|=
name|long_long_integer_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_LONG
condition|)
name|type
operator|=
name|long_integer_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_SHORT
condition|)
name|type
operator|=
name|short_integer_type_node
expr_stmt|;
if|if
condition|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_COMPLEX
condition|)
block|{
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|flag_isoc99
condition|)
name|pedwarn
argument_list|(
literal|"ISO C90 does not support complex types"
argument_list|)
expr_stmt|;
comment|/* If we just have "complex", it is equivalent to 	 "complex double", but if any modifiers at all are specified it is 	 the complex form of TYPE.  E.g, "complex short" is 	 "complex short int".  */
if|if
condition|(
name|defaulted_int
operator|&&
operator|!
name|longlong
operator|&&
operator|!
operator|(
name|specbits
operator|&
operator|(
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_LONG
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_SHORT
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_SIGNED
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_UNSIGNED
operator|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ISO C does not support plain `complex' meaning `double complex'"
argument_list|)
expr_stmt|;
name|type
operator|=
name|complex_double_type_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|integer_type_node
condition|)
block|{
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ISO C does not support complex integer types"
argument_list|)
expr_stmt|;
name|type
operator|=
name|complex_integer_type_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|float_type_node
condition|)
name|type
operator|=
name|complex_float_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|double_type_node
condition|)
name|type
operator|=
name|complex_double_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|long_double_type_node
condition|)
name|type
operator|=
name|complex_long_double_type_node
expr_stmt|;
else|else
block|{
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ISO C does not support complex integer types"
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_complex_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Figure out the type qualifiers for the declaration.  There are      two ways a declaration can become qualified.  One is something      like `const int i' where the `const' is explicit.  Another is      something like `typedef const int CI; CI i' where the type of the      declaration contains the `const'.  */
name|constp
operator|=
operator|!
operator|!
operator|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_CONST
operator|)
operator|+
name|TYPE_READONLY
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|restrictp
operator|=
operator|!
operator|!
operator|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_RESTRICT
operator|)
operator|+
name|TYPE_RESTRICT
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|volatilep
operator|=
operator|!
operator|!
operator|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_VOLATILE
operator|)
operator|+
name|TYPE_VOLATILE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|inlinep
operator|=
operator|!
operator|!
operator|(
name|specbits
operator|&
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_INLINE
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|constp
operator|>
literal|1
operator|&&
operator|!
name|flag_isoc99
condition|)
name|pedwarn
argument_list|(
literal|"duplicate `const'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|restrictp
operator|>
literal|1
operator|&&
operator|!
name|flag_isoc99
condition|)
name|pedwarn
argument_list|(
literal|"duplicate `restrict'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|volatilep
operator|>
literal|1
operator|&&
operator|!
name|flag_isoc99
condition|)
name|pedwarn
argument_list|(
literal|"duplicate `volatile'"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flag_gen_aux_info
operator|&&
operator|(
name|TYPE_QUALS
argument_list|(
name|type
argument_list|)
operator|)
condition|)
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|type_quals
operator|=
operator|(
operator|(
name|constp
condition|?
name|TYPE_QUAL_CONST
else|:
literal|0
operator|)
operator||
operator|(
name|restrictp
condition|?
name|TYPE_QUAL_RESTRICT
else|:
literal|0
operator|)
operator||
operator|(
name|volatilep
condition|?
name|TYPE_QUAL_VOLATILE
else|:
literal|0
operator|)
operator|)
expr_stmt|;
comment|/* Warn if two storage classes are given. Default to `auto'.  */
block|{
name|int
name|nclasses
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_AUTO
condition|)
name|nclasses
operator|++
expr_stmt|;
if|if
condition|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_STATIC
condition|)
name|nclasses
operator|++
expr_stmt|;
if|if
condition|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_EXTERN
condition|)
name|nclasses
operator|++
expr_stmt|;
if|if
condition|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_REGISTER
condition|)
name|nclasses
operator|++
expr_stmt|;
if|if
condition|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_TYPEDEF
condition|)
name|nclasses
operator|++
expr_stmt|;
comment|/* "static __thread" and "extern __thread" are allowed.  */
if|if
condition|(
operator|(
name|specbits
operator|&
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_THREAD
operator||
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_STATIC
operator||
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_EXTERN
operator|)
operator|)
operator|==
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_THREAD
operator|)
condition|)
name|nclasses
operator|++
expr_stmt|;
comment|/* Warn about storage classes that are invalid for certain        kinds of declarations (parameters, typenames, etc.).  */
if|if
condition|(
name|nclasses
operator|>
literal|1
condition|)
name|error
argument_list|(
literal|"multiple storage classes in declaration of `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|funcdef_flag
operator|&&
operator|(
name|specbits
operator|&
operator|(
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_REGISTER
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_AUTO
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_TYPEDEF
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_THREAD
operator|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_AUTO
operator|&&
operator|(
name|pedantic
operator|||
name|current_binding_level
operator|==
name|global_binding_level
operator|)
condition|)
name|pedwarn
argument_list|(
literal|"function definition declared `auto'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_REGISTER
condition|)
name|error
argument_list|(
literal|"function definition declared `register'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_TYPEDEF
condition|)
name|error
argument_list|(
literal|"function definition declared `typedef'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_THREAD
condition|)
name|error
argument_list|(
literal|"function definition declared `__thread'"
argument_list|)
expr_stmt|;
name|specbits
operator|&=
operator|~
operator|(
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_TYPEDEF
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_REGISTER
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_AUTO
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_THREAD
operator|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|decl_context
operator|!=
name|NORMAL
operator|&&
name|nclasses
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|decl_context
operator|==
name|PARM
operator|&&
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_REGISTER
condition|)
empty_stmt|;
else|else
block|{
switch|switch
condition|(
name|decl_context
condition|)
block|{
case|case
name|FIELD
case|:
name|error
argument_list|(
literal|"storage class specified for structure field `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARM
case|:
name|error
argument_list|(
literal|"storage class specified for parameter `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"storage class specified for typename"
argument_list|)
expr_stmt|;
break|break;
block|}
name|specbits
operator|&=
operator|~
operator|(
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_TYPEDEF
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_REGISTER
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_AUTO
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_STATIC
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_EXTERN
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_THREAD
operator|)
operator|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_EXTERN
operator|&&
name|initialized
operator|&&
operator|!
name|funcdef_flag
condition|)
block|{
comment|/* `extern' with initialization is invalid if not at top level.  */
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
condition|)
name|warning
argument_list|(
literal|"`%s' initialized and declared `extern'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"`%s' has both `extern' and initializer"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
condition|)
block|{
if|if
condition|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_AUTO
condition|)
name|error
argument_list|(
literal|"top-level declaration of `%s' specifies `auto'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_EXTERN
operator|&&
name|funcdef_flag
condition|)
name|error
argument_list|(
literal|"nested function `%s' declared `extern'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|specbits
operator|&
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_THREAD
operator||
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_EXTERN
operator||
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_STATIC
operator|)
operator|)
operator|==
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_THREAD
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"function-scope `%s' implicitly auto and declared `__thread'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|specbits
operator|&=
operator|~
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_THREAD
operator|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Now figure out the structure of the declarator proper.      Descend through it, creating more complex types, until we reach      the declared identifier (or NULL_TREE, in an absolute declarator).  */
while|while
condition|(
name|declarator
operator|&&
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|!=
name|IDENTIFIER_NODE
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
block|{
name|declarator
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Each level of DECLARATOR is either an ARRAY_REF (for ...[..]), 	 an INDIRECT_REF (for *...), 	 a CALL_EXPR (for ...(...)), 	 a TREE_LIST (for nested attributes), 	 an identifier (for the name being declared) 	 or a null pointer (for the place in an absolute declarator 	 where the name was omitted). 	 For the last two cases, we have just exited the loop.  	 At this point, TYPE is the type of elements of an array, 	 or for a function to return, or for a pointer to point to. 	 After this sequence of ifs, TYPE is the type of the 	 array or function or pointer, and DECLARATOR has had its 	 outermost layer removed.  */
if|if
condition|(
name|array_ptr_quals
operator|!=
name|NULL_TREE
operator|||
name|array_parm_static
condition|)
block|{
comment|/* Only the innermost declarator (making a parameter be of 	     array type which is converted to pointer type) 	     may have static or type qualifiers.  */
name|error
argument_list|(
literal|"static or type qualifiers in non-parameter array declarator"
argument_list|)
expr_stmt|;
name|array_ptr_quals
operator|=
name|NULL_TREE
expr_stmt|;
name|array_parm_static
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|TREE_LIST
condition|)
block|{
comment|/* We encode a declarator with embedded attributes using 	     a TREE_LIST.  */
name|tree
name|attrs
init|=
name|TREE_PURPOSE
argument_list|(
name|declarator
argument_list|)
decl_stmt|;
name|tree
name|inner_decl
decl_stmt|;
name|int
name|attr_flags
init|=
literal|0
decl_stmt|;
name|declarator
operator|=
name|TREE_VALUE
argument_list|(
name|declarator
argument_list|)
expr_stmt|;
name|inner_decl
operator|=
name|declarator
expr_stmt|;
while|while
condition|(
name|inner_decl
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|inner_decl
argument_list|)
operator|==
name|TREE_LIST
condition|)
name|inner_decl
operator|=
name|TREE_VALUE
argument_list|(
name|inner_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|inner_decl
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|inner_decl
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|attr_flags
operator||=
operator|(
name|int
operator|)
name|ATTR_FLAG_DECL_NEXT
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|inner_decl
argument_list|)
operator|==
name|CALL_EXPR
condition|)
name|attr_flags
operator||=
operator|(
name|int
operator|)
name|ATTR_FLAG_FUNCTION_NEXT
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|inner_decl
argument_list|)
operator|==
name|ARRAY_REF
condition|)
name|attr_flags
operator||=
operator|(
name|int
operator|)
name|ATTR_FLAG_ARRAY_NEXT
expr_stmt|;
name|returned_attrs
operator|=
name|decl_attributes
argument_list|(
operator|&
name|type
argument_list|,
name|chainon
argument_list|(
name|returned_attrs
argument_list|,
name|attrs
argument_list|)
argument_list|,
name|attr_flags
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|ARRAY_REF
condition|)
block|{
name|tree
name|itype
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|size
init|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* The index is a signed object `sizetype' bits wide.  */
name|tree
name|index_type
init|=
name|c_common_signed_type
argument_list|(
name|sizetype
argument_list|)
decl_stmt|;
name|array_ptr_quals
operator|=
name|TREE_TYPE
argument_list|(
name|declarator
argument_list|)
expr_stmt|;
name|array_parm_static
operator|=
name|TREE_STATIC
argument_list|(
name|declarator
argument_list|)
expr_stmt|;
name|declarator
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Check for some types that there cannot be arrays of.  */
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"declaration of `%s' as array of voids"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|type
operator|=
name|error_mark_node
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"declaration of `%s' as array of functions"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|type
operator|=
name|error_mark_node
expr_stmt|;
block|}
if|if
condition|(
name|pedantic
operator|&&
name|flexible_array_type_p
argument_list|(
name|type
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"invalid use of structure with flexible array member"
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
name|error_mark_node
condition|)
name|type
operator|=
name|error_mark_node
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
continue|continue;
comment|/* If size was specified, set ITYPE to a range-type for that size. 	     Otherwise, ITYPE remains null.  finish_decl may figure it out 	     from an initial value.  */
if|if
condition|(
name|size
condition|)
block|{
comment|/* Strip NON_LVALUE_EXPRs since we aren't using as an lvalue.  */
name|STRIP_TYPE_NOPS
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|size
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"size of array `%s' has non-integer type"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|size
operator|=
name|integer_one_node
expr_stmt|;
block|}
if|if
condition|(
name|pedantic
operator|&&
name|integer_zerop
argument_list|(
name|size
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"ISO C forbids zero-size array `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|constant_expression_warning
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree_int_cst_sgn
argument_list|(
name|size
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"size of array `%s' is negative"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|size
operator|=
name|integer_one_node
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Make sure the array size remains visibly nonconstant 		     even if it is (eg) a const variable with known value.  */
name|size_varies
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|flag_isoc99
operator|&&
name|pedantic
condition|)
block|{
if|if
condition|(
name|TREE_CONSTANT
argument_list|(
name|size
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"ISO C90 forbids array `%s' whose size can't be evaluated"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|pedwarn
argument_list|(
literal|"ISO C90 forbids variable-size array `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|integer_zerop
argument_list|(
name|size
argument_list|)
condition|)
block|{
comment|/* A zero-length array cannot be represented with an 		     unsigned index type, which is what we'll get with 		     build_index_type.  Create an open-ended range instead.  */
name|itype
operator|=
name|build_range_type
argument_list|(
name|sizetype
argument_list|,
name|size
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Compute the maximum valid index, that is, size - 1. 		     Do the calculation in index_type, so that if it is 		     a variable the computations will be done in the 		     proper mode.  */
name|itype
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|index_type
argument_list|,
name|convert
argument_list|(
name|index_type
argument_list|,
name|size
argument_list|)
argument_list|,
name|convert
argument_list|(
name|index_type
argument_list|,
name|size_one_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If that overflowed, the array is too big. 		     ??? While a size of INT_MAX+1 technically shouldn't 		     cause an overflow (because we subtract 1), the overflow 		     is recorded during the conversion to index_type, before 		     the subtraction.  Handling this case seems like an 		     unnecessary complication.  */
if|if
condition|(
name|TREE_OVERFLOW
argument_list|(
name|itype
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"size of array `%s' is too large"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|type
operator|=
name|error_mark_node
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|size_varies
condition|)
block|{
comment|/* We must be able to distinguish the 			 SAVE_EXPR_CONTEXT for the variably-sized type 			 so that we can set it correctly in 			 set_save_expr_context.  The convention is 			 that all SAVE_EXPRs that need to be reset 			 have NULL_TREE for their SAVE_EXPR_CONTEXT.  */
name|tree
name|cfd
init|=
name|current_function_decl
decl_stmt|;
if|if
condition|(
name|decl_context
operator|==
name|PARM
condition|)
name|current_function_decl
operator|=
name|NULL_TREE
expr_stmt|;
name|itype
operator|=
name|variable_size
argument_list|(
name|itype
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl_context
operator|==
name|PARM
condition|)
name|current_function_decl
operator|=
name|cfd
expr_stmt|;
block|}
name|itype
operator|=
name|build_index_type
argument_list|(
name|itype
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|decl_context
operator|==
name|FIELD
condition|)
block|{
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|flag_isoc99
operator|&&
operator|!
name|in_system_header
condition|)
name|pedwarn
argument_list|(
literal|"ISO C90 does not support flexible array members"
argument_list|)
expr_stmt|;
comment|/* ISO C99 Flexible array members are effectively identical 		 to GCC's zero-length array extension.  */
name|itype
operator|=
name|build_range_type
argument_list|(
name|sizetype
argument_list|,
name|size_zero_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
comment|/* If pedantic, complain about arrays of incomplete types.  */
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"array type has incomplete element type"
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* We shouldn't have a function type here at all! 	     Functions aren't allowed as array elements.  */
block|if (pedantic&& TREE_CODE (type) == FUNCTION_TYPE&& (constp || volatilep)) 	    pedwarn ("ISO C forbids const or volatile function types");
endif|#
directive|endif
comment|/* Build the array type itself, then merge any constancy or 	     volatility into the target type.  We must do it in this order 	     to ensure that the TYPE_MAIN_VARIANT field of the array type 	     is set correctly.  */
name|type
operator|=
name|build_array_type
argument_list|(
name|type
argument_list|,
name|itype
argument_list|)
expr_stmt|;
if|if
condition|(
name|type_quals
condition|)
name|type
operator|=
name|c_build_qualified_type
argument_list|(
name|type
argument_list|,
name|type_quals
argument_list|)
expr_stmt|;
if|if
condition|(
name|size_varies
condition|)
name|C_TYPE_VARIABLE_SIZE
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* The GCC extension for zero-length arrays differs from 	     ISO flexible array members in that sizeof yields zero.  */
if|if
condition|(
name|size
operator|&&
name|integer_zerop
argument_list|(
name|size
argument_list|)
condition|)
block|{
name|layout_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|=
name|bitsize_zero_node
expr_stmt|;
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
operator|=
name|size_zero_node
expr_stmt|;
block|}
if|if
condition|(
name|decl_context
operator|!=
name|PARM
operator|&&
operator|(
name|array_ptr_quals
operator|!=
name|NULL_TREE
operator|||
name|array_parm_static
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"static or type qualifiers in non-parameter array declarator"
argument_list|)
expr_stmt|;
name|array_ptr_quals
operator|=
name|NULL_TREE
expr_stmt|;
name|array_parm_static
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|CALL_EXPR
condition|)
block|{
name|tree
name|arg_types
decl_stmt|;
comment|/* Declaring a function type. 	     Make sure we have a valid type for the function to return.  */
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
continue|continue;
name|size_varies
operator|=
literal|0
expr_stmt|;
comment|/* Warn about some types functions can't return.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"`%s' declared as function returning a function"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|type
operator|=
name|integer_type_node
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"`%s' declared as function returning an array"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|type
operator|=
name|integer_type_node
expr_stmt|;
block|}
comment|/* Construct the function type and go to the next 	     inner layer of declarator.  */
name|arg_types
operator|=
name|grokparms
argument_list|(
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|1
argument_list|)
argument_list|,
name|funcdef_flag
comment|/* Say it's a definition 				    only for the CALL_EXPR 				    closest to the identifier.  */
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
argument_list|)
expr_stmt|;
comment|/* Type qualifiers before the return type of the function 	     qualify the return type, not the function type.  */
if|if
condition|(
name|type_quals
condition|)
block|{
comment|/* Type qualifiers on a function return type are normally 		 permitted by the standard but have no effect, so give a 		 warning at -W.  Qualifiers on a void return type have 		 meaning as a GNU extension, and are banned on function 		 definitions in ISO C.  FIXME: strictly we shouldn't 		 pedwarn for qualified void return types except on function 		 definitions, but not doing so could lead to the undesirable 		 state of a "volatile void" function return type not being 		 warned about, and a use of the function being compiled 		 with GNU semantics, with no diagnostics under -pedantic.  */
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|pedantic
operator|&&
operator|!
name|in_system_header
condition|)
name|pedwarn
argument_list|(
literal|"ISO C forbids qualified void function return type"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|extra_warnings
operator|&&
operator|!
operator|(
name|VOID_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|type_quals
operator|==
name|TYPE_QUAL_VOLATILE
operator|)
condition|)
name|warning
argument_list|(
literal|"type qualifiers ignored on function return type"
argument_list|)
expr_stmt|;
name|type
operator|=
name|c_build_qualified_type
argument_list|(
name|type
argument_list|,
name|type_quals
argument_list|)
expr_stmt|;
block|}
name|type_quals
operator|=
name|TYPE_UNQUALIFIED
expr_stmt|;
name|type
operator|=
name|build_function_type
argument_list|(
name|type
argument_list|,
name|arg_types
argument_list|)
expr_stmt|;
name|declarator
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Set the TYPE_CONTEXTs for each tagged type which is local to 	     the formal parameter list of this FUNCTION_TYPE to point to 	     the FUNCTION_TYPE node itself.  */
block|{
name|tree
name|link
decl_stmt|;
for|for
control|(
name|link
operator|=
name|last_function_parm_tags
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
name|TYPE_CONTEXT
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
operator|=
name|type
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
block|{
comment|/* Merge any constancy or volatility into the target type 	     for the pointer.  */
if|if
condition|(
name|pedantic
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|&&
name|type_quals
condition|)
name|pedwarn
argument_list|(
literal|"ISO C forbids qualified function types"
argument_list|)
expr_stmt|;
if|if
condition|(
name|type_quals
condition|)
name|type
operator|=
name|c_build_qualified_type
argument_list|(
name|type
argument_list|,
name|type_quals
argument_list|)
expr_stmt|;
name|type_quals
operator|=
name|TYPE_UNQUALIFIED
expr_stmt|;
name|size_varies
operator|=
literal|0
expr_stmt|;
name|type
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Process a list of type modifier keywords 	     (such as const or volatile) that were given inside the `*'.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|declarator
argument_list|)
condition|)
block|{
name|tree
name|typemodlist
decl_stmt|;
name|int
name|erred
init|=
literal|0
decl_stmt|;
name|constp
operator|=
literal|0
expr_stmt|;
name|volatilep
operator|=
literal|0
expr_stmt|;
name|restrictp
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|typemodlist
operator|=
name|TREE_TYPE
argument_list|(
name|declarator
argument_list|)
init|;
name|typemodlist
condition|;
name|typemodlist
operator|=
name|TREE_CHAIN
argument_list|(
name|typemodlist
argument_list|)
control|)
block|{
name|tree
name|qualifier
init|=
name|TREE_VALUE
argument_list|(
name|typemodlist
argument_list|)
decl_stmt|;
if|if
condition|(
name|C_IS_RESERVED_WORD
argument_list|(
name|qualifier
argument_list|)
condition|)
block|{
if|if
condition|(
name|C_RID_CODE
argument_list|(
name|qualifier
argument_list|)
operator|==
name|RID_CONST
condition|)
name|constp
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|C_RID_CODE
argument_list|(
name|qualifier
argument_list|)
operator|==
name|RID_VOLATILE
condition|)
name|volatilep
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|C_RID_CODE
argument_list|(
name|qualifier
argument_list|)
operator|==
name|RID_RESTRICT
condition|)
name|restrictp
operator|++
expr_stmt|;
else|else
name|erred
operator|++
expr_stmt|;
block|}
else|else
name|erred
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|erred
condition|)
name|error
argument_list|(
literal|"invalid type modifier within pointer declarator"
argument_list|)
expr_stmt|;
if|if
condition|(
name|constp
operator|>
literal|1
operator|&&
operator|!
name|flag_isoc99
condition|)
name|pedwarn
argument_list|(
literal|"duplicate `const'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|volatilep
operator|>
literal|1
operator|&&
operator|!
name|flag_isoc99
condition|)
name|pedwarn
argument_list|(
literal|"duplicate `volatile'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|restrictp
operator|>
literal|1
operator|&&
operator|!
name|flag_isoc99
condition|)
name|pedwarn
argument_list|(
literal|"duplicate `restrict'"
argument_list|)
expr_stmt|;
name|type_quals
operator|=
operator|(
operator|(
name|constp
condition|?
name|TYPE_QUAL_CONST
else|:
literal|0
operator|)
operator||
operator|(
name|restrictp
condition|?
name|TYPE_QUAL_RESTRICT
else|:
literal|0
operator|)
operator||
operator|(
name|volatilep
condition|?
name|TYPE_QUAL_VOLATILE
else|:
literal|0
operator|)
operator|)
expr_stmt|;
block|}
name|declarator
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Now TYPE has the actual type.  */
comment|/* Did array size calculations overflow?  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_OVERFLOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"size of array `%s' is too large"
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* If we proceed with the array type as it is, we'll eventually 	 crash in tree_low_cst().  */
name|type
operator|=
name|error_mark_node
expr_stmt|;
block|}
comment|/* If this is declaring a typedef name, return a TYPE_DECL.  */
if|if
condition|(
name|specbits
operator|&
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_TYPEDEF
operator|)
condition|)
block|{
name|tree
name|decl
decl_stmt|;
comment|/* Note that the grammar rejects storage classes 	 in typenames, fields or parameters */
if|if
condition|(
name|pedantic
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|&&
name|type_quals
condition|)
name|pedwarn
argument_list|(
literal|"ISO C forbids qualified function types"
argument_list|)
expr_stmt|;
if|if
condition|(
name|type_quals
condition|)
name|type
operator|=
name|c_build_qualified_type
argument_list|(
name|type
argument_list|,
name|type_quals
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|declarator
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|specbits
operator|&
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_SIGNED
operator|)
operator|)
operator|||
operator|(
name|typedef_decl
operator|&&
name|C_TYPEDEF_EXPLICITLY_SIGNED
argument_list|(
name|typedef_decl
argument_list|)
operator|)
condition|)
name|C_TYPEDEF_EXPLICITLY_SIGNED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|decl_attributes
argument_list|(
operator|&
name|decl
argument_list|,
name|returned_attrs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
comment|/* Detect the case of an array type of unspecified size      which came, as such, direct from a typedef name.      We must copy the type, so that each identifier gets      a distinct type, so that each identifier's size can be      controlled separately by its own initializer.  */
if|if
condition|(
name|type
operator|!=
literal|0
operator|&&
name|typedef_type
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
operator|==
literal|0
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|typedef_type
argument_list|)
condition|)
block|{
name|type
operator|=
name|build_array_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|size_varies
condition|)
name|C_TYPE_VARIABLE_SIZE
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If this is a type name (such as, in a cast or sizeof),      compute the type and return it now.  */
if|if
condition|(
name|decl_context
operator|==
name|TYPENAME
condition|)
block|{
comment|/* Note that the grammar rejects storage classes 	 in typenames, fields or parameters */
if|if
condition|(
name|pedantic
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|&&
name|type_quals
condition|)
name|pedwarn
argument_list|(
literal|"ISO C forbids const or volatile function types"
argument_list|)
expr_stmt|;
if|if
condition|(
name|type_quals
condition|)
name|type
operator|=
name|c_build_qualified_type
argument_list|(
name|type
argument_list|,
name|type_quals
argument_list|)
expr_stmt|;
name|decl_attributes
argument_list|(
operator|&
name|type
argument_list|,
name|returned_attrs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
comment|/* Aside from typedefs and type names (handle above),      `void' at top level (not within pointer)      is allowed only in public variables.      We don't complain about parms either, but that is because      a better error message can be made later.  */
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|decl_context
operator|!=
name|PARM
operator|&&
operator|!
operator|(
operator|(
name|decl_context
operator|!=
name|FIELD
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|FUNCTION_TYPE
operator|)
operator|&&
operator|(
operator|(
name|specbits
operator|&
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_EXTERN
operator|)
operator|)
operator|||
operator|(
name|current_binding_level
operator|==
name|global_binding_level
operator|&&
operator|!
operator|(
name|specbits
operator|&
operator|(
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_STATIC
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_REGISTER
operator|)
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"variable or field `%s' declared void"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|type
operator|=
name|integer_type_node
expr_stmt|;
block|}
comment|/* Now create the decl, which may be a VAR_DECL, a PARM_DECL      or a FUNCTION_DECL, depending on DECL_CONTEXT and TYPE.  */
block|{
name|tree
name|decl
decl_stmt|;
if|if
condition|(
name|decl_context
operator|==
name|PARM
condition|)
block|{
name|tree
name|type_as_written
decl_stmt|;
name|tree
name|promoted_type
decl_stmt|;
comment|/* A parameter declared as an array of T is really a pointer to T. 	   One declared as a function is really a pointer to a function.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
comment|/* Transfer const-ness of array into that of type pointed to.  */
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type_quals
condition|)
name|type
operator|=
name|c_build_qualified_type
argument_list|(
name|type
argument_list|,
name|type_quals
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|type_quals
operator|=
name|TYPE_UNQUALIFIED
expr_stmt|;
if|if
condition|(
name|array_ptr_quals
condition|)
block|{
name|tree
name|new_ptr_quals
decl_stmt|,
name|new_ptr_attrs
decl_stmt|;
name|int
name|erred
init|=
literal|0
decl_stmt|;
name|split_specs_attrs
argument_list|(
name|array_ptr_quals
argument_list|,
operator|&
name|new_ptr_quals
argument_list|,
operator|&
name|new_ptr_attrs
argument_list|)
expr_stmt|;
comment|/* We don't yet implement attributes in this context.  */
if|if
condition|(
name|new_ptr_attrs
operator|!=
name|NULL_TREE
condition|)
name|warning
argument_list|(
literal|"attributes in parameter array declarator ignored"
argument_list|)
expr_stmt|;
name|constp
operator|=
literal|0
expr_stmt|;
name|volatilep
operator|=
literal|0
expr_stmt|;
name|restrictp
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|new_ptr_quals
condition|;
name|new_ptr_quals
operator|=
name|TREE_CHAIN
argument_list|(
name|new_ptr_quals
argument_list|)
control|)
block|{
name|tree
name|qualifier
init|=
name|TREE_VALUE
argument_list|(
name|new_ptr_quals
argument_list|)
decl_stmt|;
if|if
condition|(
name|C_IS_RESERVED_WORD
argument_list|(
name|qualifier
argument_list|)
condition|)
block|{
if|if
condition|(
name|C_RID_CODE
argument_list|(
name|qualifier
argument_list|)
operator|==
name|RID_CONST
condition|)
name|constp
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|C_RID_CODE
argument_list|(
name|qualifier
argument_list|)
operator|==
name|RID_VOLATILE
condition|)
name|volatilep
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|C_RID_CODE
argument_list|(
name|qualifier
argument_list|)
operator|==
name|RID_RESTRICT
condition|)
name|restrictp
operator|++
expr_stmt|;
else|else
name|erred
operator|++
expr_stmt|;
block|}
else|else
name|erred
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|erred
condition|)
name|error
argument_list|(
literal|"invalid type modifier within array declarator"
argument_list|)
expr_stmt|;
name|type_quals
operator|=
operator|(
operator|(
name|constp
condition|?
name|TYPE_QUAL_CONST
else|:
literal|0
operator|)
operator||
operator|(
name|restrictp
condition|?
name|TYPE_QUAL_RESTRICT
else|:
literal|0
operator|)
operator||
operator|(
name|volatilep
condition|?
name|TYPE_QUAL_VOLATILE
else|:
literal|0
operator|)
operator|)
expr_stmt|;
block|}
name|size_varies
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
if|if
condition|(
name|pedantic
operator|&&
name|type_quals
condition|)
name|pedwarn
argument_list|(
literal|"ISO C forbids qualified function types"
argument_list|)
expr_stmt|;
if|if
condition|(
name|type_quals
condition|)
name|type
operator|=
name|c_build_qualified_type
argument_list|(
name|type
argument_list|,
name|type_quals
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|type_quals
operator|=
name|TYPE_UNQUALIFIED
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type_quals
condition|)
name|type
operator|=
name|c_build_qualified_type
argument_list|(
name|type
argument_list|,
name|type_quals
argument_list|)
expr_stmt|;
name|type_as_written
operator|=
name|type
expr_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|PARM_DECL
argument_list|,
name|declarator
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|size_varies
condition|)
name|C_DECL_VARIABLE_SIZE
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Compute the type actually passed in the parmlist, 	   for the case where there is no prototype. 	   (For example, shorts and chars are passed as ints.) 	   When there is a prototype, this is overridden later.  */
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
name|promoted_type
operator|=
name|type
expr_stmt|;
else|else
name|promoted_type
operator|=
name|c_type_promotes_to
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|DECL_ARG_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|promoted_type
expr_stmt|;
name|DECL_ARG_TYPE_AS_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|=
name|type_as_written
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|decl_context
operator|==
name|FIELD
condition|)
block|{
comment|/* Structure field.  It may not be a function.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"field `%s' declared as a function"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|ERROR_MARK
operator|&&
operator|!
name|COMPLETE_OR_UNBOUND_ARRAY_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"field `%s' has incomplete type"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|type
operator|=
name|error_mark_node
expr_stmt|;
block|}
comment|/* Move type qualifiers down to element of an array.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|type_quals
condition|)
block|{
name|type
operator|=
name|build_array_type
argument_list|(
name|c_build_qualified_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|type_quals
argument_list|)
argument_list|,
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Leave the field const or volatile as well.  */
block|type_quals = TYPE_UNQUALIFIED;
endif|#
directive|endif
block|}
name|decl
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|declarator
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|DECL_NONADDRESSABLE_P
argument_list|(
name|decl
argument_list|)
operator|=
name|bitfield
expr_stmt|;
if|if
condition|(
name|size_varies
condition|)
name|C_DECL_VARIABLE_SIZE
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
comment|/* Every function declaration is "external" 	   except for those which are inside a function body 	   in which `auto' is used. 	   That is a case not specified by ANSI C, 	   and we use it for forward declarations for nested functions.  */
name|int
name|extern_ref
init|=
operator|(
operator|!
operator|(
name|specbits
operator|&
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_AUTO
operator|)
operator|)
operator|||
name|current_binding_level
operator|==
name|global_binding_level
operator|)
decl_stmt|;
if|if
condition|(
name|specbits
operator|&
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_AUTO
operator|)
operator|&&
operator|(
name|pedantic
operator|||
name|current_binding_level
operator|==
name|global_binding_level
operator|)
condition|)
name|pedwarn
argument_list|(
literal|"invalid storage class for function `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|specbits
operator|&
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_REGISTER
operator|)
condition|)
name|error
argument_list|(
literal|"invalid storage class for function `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|specbits
operator|&
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_THREAD
operator|)
condition|)
name|error
argument_list|(
literal|"invalid storage class for function `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Function declaration not at top level. 	   Storage classes other than `extern' are not allowed 	   and `extern' makes no difference.  */
if|if
condition|(
name|current_binding_level
operator|!=
name|global_binding_level
operator|&&
operator|(
name|specbits
operator|&
operator|(
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_STATIC
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_INLINE
operator|)
operator|)
operator|)
operator|&&
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"invalid storage class for function `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|declarator
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_decl_attribute_variant
argument_list|(
name|decl
argument_list|,
name|decl_attr
argument_list|)
expr_stmt|;
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
operator|=
operator|(
expr|struct
name|lang_decl
operator|*
operator|)
name|ggc_alloc_cleared
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|lang_decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pedantic
operator|&&
name|type_quals
operator|&&
operator|!
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|decl
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"ISO C forbids qualified function types"
argument_list|)
expr_stmt|;
comment|/* GNU C interprets a `volatile void' return type to indicate 	   that the function does not return.  */
if|if
condition|(
operator|(
name|type_quals
operator|&
name|TYPE_QUAL_VOLATILE
operator|)
operator|&&
operator|!
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
condition|)
name|warning
argument_list|(
literal|"`noreturn' function returns non-void value"
argument_list|)
expr_stmt|;
if|if
condition|(
name|extern_ref
condition|)
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Record absence of global scope for `static' or `auto'.  */
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
operator|!
operator|(
name|specbits
operator|&
operator|(
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_STATIC
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_AUTO
operator|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|defaulted_int
condition|)
name|C_FUNCTION_IMPLICIT_INT
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Record presence of `inline', if it is reasonable.  */
if|if
condition|(
name|MAIN_NAME_P
argument_list|(
name|declarator
argument_list|)
condition|)
block|{
if|if
condition|(
name|inlinep
condition|)
name|warning
argument_list|(
literal|"cannot inline function `main'"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|inlinep
condition|)
block|{
comment|/* Assume that otherwise the function can be inlined.  */
name|DECL_DECLARED_INLINE_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Do not mark bare declarations as DECL_INLINE.  Doing so 	       in the presence of multiple declarations can result in 	       the abstract origin pointing between the declarations, 	       which will confuse dwarf2out.  */
if|if
condition|(
name|initialized
condition|)
block|{
name|DECL_INLINE
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|specbits
operator|&
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_EXTERN
operator|)
condition|)
name|current_extern_inline
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* If -finline-functions, assume it can be inlined.  This does 	   two things: let the function be deferred until it is actually 	   needed, and let dwarf2 know that the function is inlinable.  */
elseif|else
if|if
condition|(
name|flag_inline_trees
operator|==
literal|2
operator|&&
name|initialized
condition|)
block|{
if|if
condition|(
operator|!
name|DECL_INLINE
argument_list|(
name|decl
argument_list|)
condition|)
name|DID_INLINE_FUNC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_INLINE
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_DECLARED_INLINE_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* It's a variable.  */
comment|/* An uninitialized decl with `extern' is a reference.  */
name|int
name|extern_ref
init|=
operator|!
name|initialized
operator|&&
operator|(
name|specbits
operator|&
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_EXTERN
operator|)
operator|)
decl_stmt|;
comment|/* Move type qualifiers down to element of an array.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|type_quals
condition|)
block|{
name|int
name|saved_align
init|=
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|type
operator|=
name|build_array_type
argument_list|(
name|c_build_qualified_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|type_quals
argument_list|)
argument_list|,
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|=
name|saved_align
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Leave the variable const or volatile as well.  */
block|type_quals = TYPE_UNQUALIFIED;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|type_quals
condition|)
name|type
operator|=
name|c_build_qualified_type
argument_list|(
name|type
argument_list|,
name|type_quals
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|declarator
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|size_varies
condition|)
name|C_DECL_VARIABLE_SIZE
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|inlinep
condition|)
name|pedwarn_with_decl
argument_list|(
name|decl
argument_list|,
literal|"variable `%s' declared `inline'"
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
name|extern_ref
expr_stmt|;
comment|/* At top level, the presence of a `static' or `register' storage 	   class specifier, or the absence of all storage class specifiers 	   makes this declaration a definition (perhaps tentative).  Also, 	   the absence of both `static' and `register' makes it public.  */
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
condition|)
block|{
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
operator|!
operator|(
name|specbits
operator|&
operator|(
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_STATIC
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_REGISTER
operator|)
operator|)
operator|)
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
operator|!
name|extern_ref
expr_stmt|;
block|}
comment|/* Not at top level, only `static' makes a static definition.  */
else|else
block|{
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
operator|(
name|specbits
operator|&
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_STATIC
operator|)
operator|)
operator|!=
literal|0
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
name|extern_ref
expr_stmt|;
block|}
if|if
condition|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_THREAD
condition|)
block|{
if|if
condition|(
name|targetm
operator|.
name|have_tls
condition|)
name|DECL_THREAD_LOCAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
comment|/* A mere warning is sure to result in improper semantics 		 at runtime.  Don't bother to allow this to compile.  */
name|error
argument_list|(
literal|"thread-local storage not supported for this target"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Record `register' declaration for warnings on&        and in case doing stupid register allocation.  */
if|if
condition|(
name|specbits
operator|&
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_REGISTER
operator|)
condition|)
name|DECL_REGISTER
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Record constancy and volatility.  */
name|c_apply_type_quals_to_decl
argument_list|(
name|type_quals
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* If a type has volatile components, it should be stored in memory.        Otherwise, the fact that those components are volatile        will be ignored, and would even crash the compiler.  */
if|if
condition|(
name|C_TYPE_FIELDS_VOLATILE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|c_mark_addressable
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|decl_attributes
argument_list|(
operator|&
name|decl
argument_list|,
name|returned_attrs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Decode the parameter-list info for a function type or function definition.    The argument is the value returned by `get_parm_info' (or made in parse.y    if there is an identifier list instead of a parameter decl list).    These two functions are separate because when a function returns    or receives functions then each is called multiple times but the order    of calls is different.  The last call to `grokparms' is always the one    that contains the formal parameter names of a function definition.     Store in `last_function_parms' a chain of the decls of parms.    Also store in `last_function_parm_tags' a chain of the struct, union,    and enum tags declared among the parms.     Return a list of arg types to use in the FUNCTION_TYPE for this function.     FUNCDEF_FLAG is nonzero for a function definition, 0 for    a mere declaration.  A nonempty identifier-list gets an error message    when FUNCDEF_FLAG is zero.  */
end_comment

begin_function
specifier|static
name|tree
name|grokparms
parameter_list|(
name|parms_info
parameter_list|,
name|funcdef_flag
parameter_list|)
name|tree
name|parms_info
decl_stmt|;
name|int
name|funcdef_flag
decl_stmt|;
block|{
name|tree
name|first_parm
init|=
name|TREE_CHAIN
argument_list|(
name|parms_info
argument_list|)
decl_stmt|;
name|last_function_parms
operator|=
name|TREE_PURPOSE
argument_list|(
name|parms_info
argument_list|)
expr_stmt|;
name|last_function_parm_tags
operator|=
name|TREE_VALUE
argument_list|(
name|parms_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|warn_strict_prototypes
operator|&&
name|first_parm
operator|==
literal|0
operator|&&
operator|!
name|funcdef_flag
operator|&&
operator|!
name|in_system_header
condition|)
name|warning
argument_list|(
literal|"function declaration isn't a prototype"
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_parm
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|first_parm
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
if|if
condition|(
operator|!
name|funcdef_flag
condition|)
name|pedwarn
argument_list|(
literal|"parameter names (without types) in function declaration"
argument_list|)
expr_stmt|;
name|last_function_parms
operator|=
name|first_parm
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|tree
name|parm
decl_stmt|;
name|tree
name|typelt
decl_stmt|;
comment|/* We no longer test FUNCDEF_FLAG. 	 If the arg types are incomplete in a declaration, 	 they must include undefined tags. 	 These tags can never be defined in the scope of the declaration, 	 so the types can never be completed, 	 and no call can be compiled successfully.  */
if|#
directive|if
literal|0
comment|/* In a fcn definition, arg types must be complete.  */
block|if (funcdef_flag)
endif|#
directive|endif
for|for
control|(
name|parm
operator|=
name|last_function_parms
operator|,
name|typelt
operator|=
name|first_parm
init|;
name|parm
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
control|)
comment|/* Skip over any enumeration constants declared here.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|PARM_DECL
condition|)
block|{
comment|/* Barf if the parameter itself has an incomplete type.  */
name|tree
name|type
init|=
name|TREE_VALUE
argument_list|(
name|typelt
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
continue|continue;
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|funcdef_flag
operator|&&
name|DECL_NAME
argument_list|(
name|parm
argument_list|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|"parameter `%s' has incomplete type"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|parm
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"parameter has incomplete type"
argument_list|)
expr_stmt|;
if|if
condition|(
name|funcdef_flag
condition|)
block|{
name|TREE_VALUE
argument_list|(
name|typelt
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
block|}
if|#
directive|if
literal|0
comment|/* This has been replaced by parm_tags_warning, which 		 uses a more accurate criterion for what to warn 		 about.  */
block|else 		{
comment|/* Now warn if is a pointer to an incomplete type.  */
block|while (TREE_CODE (type) == POINTER_TYPE 			 || TREE_CODE (type) == REFERENCE_TYPE) 		    type = TREE_TYPE (type); 		  type = TYPE_MAIN_VARIANT (type); 		  if (!COMPLETE_TYPE_P (type)) 		    { 		      if (DECL_NAME (parm) != 0) 			warning ("parameter `%s' points to incomplete type", 				 IDENTIFIER_POINTER (DECL_NAME (parm))); 		      else 			warning ("parameter points to incomplete type"); 		    } 		}
endif|#
directive|endif
name|typelt
operator|=
name|TREE_CHAIN
argument_list|(
name|typelt
argument_list|)
expr_stmt|;
block|}
return|return
name|first_parm
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return a tree_list node with info on a parameter list just parsed.    The TREE_PURPOSE is a chain of decls of those parms.    The TREE_VALUE is a list of structure, union and enum tags defined.    The TREE_CHAIN is a list of argument types to go in the FUNCTION_TYPE.    This tree_list node is later fed to `grokparms'.     VOID_AT_END nonzero means append `void' to the end of the type-list.    Zero means the parmlist ended with an ellipsis so don't append `void'.  */
end_comment

begin_function
name|tree
name|get_parm_info
parameter_list|(
name|void_at_end
parameter_list|)
name|int
name|void_at_end
decl_stmt|;
block|{
name|tree
name|decl
decl_stmt|,
name|t
decl_stmt|;
name|tree
name|types
init|=
literal|0
decl_stmt|;
name|int
name|erred
init|=
literal|0
decl_stmt|;
name|tree
name|tags
init|=
name|gettags
argument_list|()
decl_stmt|;
name|tree
name|parms
init|=
name|getdecls
argument_list|()
decl_stmt|;
name|tree
name|new_parms
init|=
literal|0
decl_stmt|;
name|tree
name|order
init|=
name|current_binding_level
operator|->
name|parm_order
decl_stmt|;
comment|/* Just `void' (and no ellipsis) is special.  There are really no parms.      But if the `void' is qualified (by `const' or `volatile') or has a      storage class specifier (`register'), then the behavior is undefined;      by not counting it as the special case of `void' we will cause an      error later.  Typedefs for `void' are OK (see DR#157).  */
if|if
condition|(
name|void_at_end
operator|&&
name|parms
operator|!=
literal|0
operator|&&
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
operator|==
literal|0
operator|&&
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|&&
operator|!
name|TREE_THIS_VOLATILE
argument_list|(
name|parms
argument_list|)
operator|&&
operator|!
name|TREE_READONLY
argument_list|(
name|parms
argument_list|)
operator|&&
operator|!
name|DECL_REGISTER
argument_list|(
name|parms
argument_list|)
operator|&&
name|DECL_NAME
argument_list|(
name|parms
argument_list|)
operator|==
literal|0
condition|)
block|{
name|parms
operator|=
name|NULL_TREE
expr_stmt|;
name|storedecls
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|void_type_node
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
return|;
block|}
comment|/* Extract enumerator values and other non-parms declared with the parms.      Likewise any forward parm decls that didn't have real parm decls.  */
for|for
control|(
name|decl
operator|=
name|parms
init|;
name|decl
condition|;
control|)
block|{
name|tree
name|next
init|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|PARM_DECL
condition|)
block|{
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
operator|=
name|new_parms
expr_stmt|;
name|new_parms
operator|=
name|decl
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"parameter `%s' has just a forward declaration"
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
operator|=
name|new_parms
expr_stmt|;
name|new_parms
operator|=
name|decl
expr_stmt|;
block|}
name|decl
operator|=
name|next
expr_stmt|;
block|}
comment|/* Put the parm decls back in the order they were in in the parm list.  */
for|for
control|(
name|t
operator|=
name|order
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
condition|)
name|TREE_CHAIN
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|TREE_CHAIN
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
name|new_parms
operator|=
name|chainon
argument_list|(
name|order
condition|?
name|nreverse
argument_list|(
name|TREE_VALUE
argument_list|(
name|order
argument_list|)
argument_list|)
else|:
literal|0
argument_list|,
name|new_parms
argument_list|)
expr_stmt|;
comment|/* Store the parmlist in the binding level since the old one      is no longer a valid list.  (We have changed the chain pointers.)  */
name|storedecls
argument_list|(
name|new_parms
argument_list|)
expr_stmt|;
for|for
control|(
name|decl
operator|=
name|new_parms
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
comment|/* There may also be declarations for enumerators if an enumeration        type is declared among the parms.  Ignore them here.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|PARM_DECL
condition|)
block|{
comment|/* Since there is a prototype, 	   args are passed in their declared types.  */
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|DECL_ARG_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|PROMOTE_PROTOTYPES
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
condition|)
name|DECL_ARG_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
name|types
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|types
argument_list|)
expr_stmt|;
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|TREE_VALUE
argument_list|(
name|types
argument_list|)
argument_list|)
operator|&&
operator|!
name|erred
operator|&&
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"`void' in parameter list must be the entire list"
argument_list|)
expr_stmt|;
name|erred
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|void_at_end
condition|)
return|return
name|tree_cons
argument_list|(
name|new_parms
argument_list|,
name|tags
argument_list|,
name|nreverse
argument_list|(
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|void_type_node
argument_list|,
name|types
argument_list|)
argument_list|)
argument_list|)
return|;
return|return
name|tree_cons
argument_list|(
name|new_parms
argument_list|,
name|tags
argument_list|,
name|nreverse
argument_list|(
name|types
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* At end of parameter list, warn about any struct, union or enum tags    defined within.  Do so because these types cannot ever become complete.  */
end_comment

begin_function
name|void
name|parmlist_tags_warning
parameter_list|()
block|{
name|tree
name|elt
decl_stmt|;
specifier|static
name|int
name|already
decl_stmt|;
for|for
control|(
name|elt
operator|=
name|current_binding_level
operator|->
name|tags
init|;
name|elt
condition|;
name|elt
operator|=
name|TREE_CHAIN
argument_list|(
name|elt
argument_list|)
control|)
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|elt
argument_list|)
argument_list|)
decl_stmt|;
comment|/* An anonymous union parm type is meaningful as a GNU extension. 	 So don't warn for that.  */
if|if
condition|(
name|code
operator|==
name|UNION_TYPE
operator|&&
name|TREE_PURPOSE
argument_list|(
name|elt
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|pedantic
condition|)
continue|continue;
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|elt
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|RECORD_TYPE
condition|)
name|warning
argument_list|(
literal|"`struct %s' declared inside parameter list"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|elt
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|UNION_TYPE
condition|)
name|warning
argument_list|(
literal|"`union %s' declared inside parameter list"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|elt
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"`enum %s' declared inside parameter list"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|elt
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* For translation these need to be separate warnings */
if|if
condition|(
name|code
operator|==
name|RECORD_TYPE
condition|)
name|warning
argument_list|(
literal|"anonymous struct declared inside parameter list"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|UNION_TYPE
condition|)
name|warning
argument_list|(
literal|"anonymous union declared inside parameter list"
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"anonymous enum declared inside parameter list"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|already
condition|)
block|{
name|warning
argument_list|(
literal|"its scope is only this definition or declaration, which is probably not what you want"
argument_list|)
expr_stmt|;
name|already
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Get the struct, enum or union (CODE says which) with tag NAME.    Define the tag as a forward-reference if it is not defined.  */
end_comment

begin_function
name|tree
name|xref_tag
parameter_list|(
name|code
parameter_list|,
name|name
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|name
decl_stmt|;
block|{
comment|/* If a cross reference is requested, look up the type      already defined for this tag and return it.  */
name|tree
name|ref
init|=
name|lookup_tag
argument_list|(
name|code
argument_list|,
name|name
argument_list|,
name|current_binding_level
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* If this is the right type of tag, return what we found.      (This reference will be shadowed by shadow_tag later if appropriate.)      If this is the wrong type of tag, do not return it.  If it was the      wrong type in the same binding level, we will have had an error      message already; if in a different binding level and declaring      a name, pending_xref_error will give an error message; but if in a      different binding level and not declaring a name, this tag should      shadow the previous declaration of a different type of tag, and      this would not work properly if we return the reference found.      (For example, with "struct foo" in an outer scope, "union foo;"      must shadow that tag with a new one of union type.)  */
if|if
condition|(
name|ref
operator|&&
name|TREE_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|code
condition|)
return|return
name|ref
return|;
comment|/* If no such tag is yet defined, create a forward-reference node      and record it as the "definition".      When a real declaration of this type is found,      the forward-reference will be altered into a real type.  */
name|ref
operator|=
name|make_node
argument_list|(
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|ENUMERAL_TYPE
condition|)
block|{
comment|/* Give the type a default layout like unsigned int 	 to avoid crashing if it does not get defined.  */
name|TYPE_MODE
argument_list|(
name|ref
argument_list|)
operator|=
name|TYPE_MODE
argument_list|(
name|unsigned_type_node
argument_list|)
expr_stmt|;
name|TYPE_ALIGN
argument_list|(
name|ref
argument_list|)
operator|=
name|TYPE_ALIGN
argument_list|(
name|unsigned_type_node
argument_list|)
expr_stmt|;
name|TYPE_USER_ALIGN
argument_list|(
name|ref
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_UNSIGNED
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_PRECISION
argument_list|(
name|ref
argument_list|)
operator|=
name|TYPE_PRECISION
argument_list|(
name|unsigned_type_node
argument_list|)
expr_stmt|;
name|TYPE_MIN_VALUE
argument_list|(
name|ref
argument_list|)
operator|=
name|TYPE_MIN_VALUE
argument_list|(
name|unsigned_type_node
argument_list|)
expr_stmt|;
name|TYPE_MAX_VALUE
argument_list|(
name|ref
argument_list|)
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|unsigned_type_node
argument_list|)
expr_stmt|;
block|}
name|pushtag
argument_list|(
name|name
argument_list|,
name|ref
argument_list|)
expr_stmt|;
return|return
name|ref
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make sure that the tag NAME is defined *in the current binding level*    at least as a forward reference.    CODE says which kind of tag NAME ought to be.  */
end_comment

begin_function
name|tree
name|start_struct
parameter_list|(
name|code
parameter_list|,
name|name
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|name
decl_stmt|;
block|{
comment|/* If there is already a tag defined at this binding level      (as a forward reference), just return it.  */
name|tree
name|ref
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|name
operator|!=
literal|0
condition|)
name|ref
operator|=
name|lookup_tag
argument_list|(
name|code
argument_list|,
name|name
argument_list|,
name|current_binding_level
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ref
operator|&&
name|TREE_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|code
condition|)
block|{
if|if
condition|(
name|TYPE_FIELDS
argument_list|(
name|ref
argument_list|)
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|UNION_TYPE
condition|)
name|error
argument_list|(
literal|"redefinition of `union %s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"redefinition of `struct %s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Otherwise create a forward-reference just so the tag is in scope.  */
name|ref
operator|=
name|make_node
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|pushtag
argument_list|(
name|name
argument_list|,
name|ref
argument_list|)
expr_stmt|;
block|}
name|C_TYPE_BEING_DEFINED
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_PACKED
argument_list|(
name|ref
argument_list|)
operator|=
name|flag_pack_struct
expr_stmt|;
return|return
name|ref
return|;
block|}
end_function

begin_comment
comment|/* Process the specs, declarator (NULL if omitted) and width (NULL if omitted)    of a structure component, returning a FIELD_DECL node.    WIDTH is non-NULL for bit fields only, and is an INTEGER_CST node.     This is done during the parsing of the struct declaration.    The FIELD_DECL nodes are chained together and the lot of them    are ultimately passed to `build_struct' to make the RECORD_TYPE node.  */
end_comment

begin_function
name|tree
name|grokfield
parameter_list|(
name|filename
parameter_list|,
name|line
parameter_list|,
name|declarator
parameter_list|,
name|declspecs
parameter_list|,
name|width
parameter_list|)
specifier|const
name|char
modifier|*
name|filename
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|line
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|tree
name|declarator
decl_stmt|,
name|declspecs
decl_stmt|,
name|width
decl_stmt|;
block|{
name|tree
name|value
decl_stmt|;
if|if
condition|(
name|declarator
operator|==
name|NULL_TREE
operator|&&
name|width
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* This is an unnamed decl.  	 If we have something of the form "union { list } ;" then this 	 is the anonymous union extension.  Similarly for struct.  	 If this is something of the form "struct foo;", then 	   If MS extensions are enabled, this is handled as an 	     anonymous struct. 	   Otherwise this is a forward declaration of a structure tag.  	 If this is something of the form "foo;" and foo is a TYPE_DECL, then 	   If MS extensions are enabled and foo names a structure, then 	     again this is an anonymous struct. 	   Otherwise this is an error.  	 Oh what a horrid tangled web we weave.  I wonder if MS consiously 	 took this from Plan 9 or if it was an accident of implementation 	 that took root before someone noticed the bug...  */
name|tree
name|type
init|=
name|TREE_VALUE
argument_list|(
name|declspecs
argument_list|)
decl_stmt|;
if|if
condition|(
name|flag_ms_extensions
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
if|if
condition|(
name|flag_ms_extensions
condition|)
empty_stmt|;
comment|/* ok */
elseif|else
if|if
condition|(
name|flag_iso
condition|)
goto|goto
name|warn_unnamed_field
goto|;
elseif|else
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|==
name|NULL
condition|)
empty_stmt|;
comment|/* ok */
else|else
goto|goto
name|warn_unnamed_field
goto|;
block|}
else|else
block|{
name|warn_unnamed_field
label|:
name|warning
argument_list|(
literal|"declaration does not declare anything"
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
block|}
name|value
operator|=
name|grokdeclarator
argument_list|(
name|declarator
argument_list|,
name|declspecs
argument_list|,
name|width
condition|?
name|BITFIELD
else|:
name|FIELD
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|value
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|value
argument_list|)
operator|=
name|width
expr_stmt|;
if|if
condition|(
name|flag_objc
condition|)
name|objc_check_decl
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Fill in the fields of a RECORD_TYPE or UNION_TYPE node, T.    FIELDLIST is a chain of FIELD_DECL nodes for the fields.    ATTRIBUTES are attributes to be applied to the structure.  */
end_comment

begin_function
name|tree
name|finish_struct
parameter_list|(
name|t
parameter_list|,
name|fieldlist
parameter_list|,
name|attributes
parameter_list|)
name|tree
name|t
decl_stmt|;
name|tree
name|fieldlist
decl_stmt|;
name|tree
name|attributes
decl_stmt|;
block|{
name|tree
name|x
decl_stmt|;
name|int
name|toplevel
init|=
name|global_binding_level
operator|==
name|current_binding_level
decl_stmt|;
name|int
name|saw_named_field
decl_stmt|;
comment|/* If this type was previously laid out as a forward reference,      make sure we lay it out again.  */
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
name|decl_attributes
argument_list|(
operator|&
name|t
argument_list|,
name|attributes
argument_list|,
operator|(
name|int
operator|)
name|ATTR_FLAG_TYPE_IN_PLACE
argument_list|)
expr_stmt|;
comment|/* Nameless union parm types are useful as GCC extension.  */
if|if
condition|(
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|UNION_TYPE
operator|&&
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|!
name|pedantic
condition|)
comment|/* Otherwise, warn about any struct or union def. in parmlist.  */
if|if
condition|(
name|in_parm_level_p
argument_list|()
condition|)
block|{
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"%s defined inside parms"
argument_list|,
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|UNION_TYPE
condition|?
name|_
argument_list|(
literal|"union"
argument_list|)
else|:
name|_
argument_list|(
literal|"structure"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"%s defined inside parms"
argument_list|,
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|UNION_TYPE
condition|?
name|_
argument_list|(
literal|"union"
argument_list|)
else|:
name|_
argument_list|(
literal|"structure"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pedantic
condition|)
block|{
for|for
control|(
name|x
operator|=
name|fieldlist
init|;
name|x
condition|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
control|)
if|if
condition|(
name|DECL_NAME
argument_list|(
name|x
argument_list|)
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
name|pedwarn
argument_list|(
literal|"%s has no %s"
argument_list|,
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|UNION_TYPE
condition|?
name|_
argument_list|(
literal|"union"
argument_list|)
else|:
name|_
argument_list|(
literal|"struct"
argument_list|)
argument_list|,
name|fieldlist
condition|?
name|_
argument_list|(
literal|"named members"
argument_list|)
else|:
name|_
argument_list|(
literal|"members"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Install struct as DECL_CONTEXT of each field decl.      Also process specified field sizes,m which is found in the DECL_INITIAL.      Store 0 there, except for ": 0" fields (so we can find them      and delete them, below).  */
name|saw_named_field
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|x
operator|=
name|fieldlist
init|;
name|x
condition|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
control|)
block|{
name|DECL_CONTEXT
argument_list|(
name|x
argument_list|)
operator|=
name|t
expr_stmt|;
name|DECL_PACKED
argument_list|(
name|x
argument_list|)
operator||=
name|TYPE_PACKED
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* If any field is const, the structure type is pseudo-const.  */
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|x
argument_list|)
condition|)
name|C_TYPE_FIELDS_READONLY
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
block|{
comment|/* A field that is pseudo-const makes the structure likewise.  */
name|tree
name|t1
init|=
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
decl_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|t1
operator|=
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|UNION_TYPE
operator|)
operator|&&
name|C_TYPE_FIELDS_READONLY
argument_list|(
name|t1
argument_list|)
condition|)
name|C_TYPE_FIELDS_READONLY
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Any field that is volatile means variables of this type must be 	 treated in some ways as volatile.  */
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|x
argument_list|)
condition|)
name|C_TYPE_FIELDS_VOLATILE
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Any field of nominal variable size implies structure is too.  */
if|if
condition|(
name|C_DECL_VARIABLE_SIZE
argument_list|(
name|x
argument_list|)
condition|)
name|C_TYPE_VARIABLE_SIZE
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Detect invalid nested redefinition.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
operator|==
name|t
condition|)
name|error
argument_list|(
literal|"nested redefinition of `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Detect invalid bit-field size.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
condition|)
name|STRIP_NOPS
argument_list|(
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
name|constant_expression_warning
argument_list|(
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|error_with_decl
argument_list|(
name|x
argument_list|,
literal|"bit-field `%s' width not an integer constant"
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* Detect invalid bit-field type.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|INTEGER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|BOOLEAN_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|ENUMERAL_TYPE
condition|)
block|{
name|error_with_decl
argument_list|(
name|x
argument_list|,
literal|"bit-field `%s' has invalid type"
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|&&
name|pedantic
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|integer_type_node
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|unsigned_type_node
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|c_bool_type_node
comment|/* Accept an enum that's equivalent to int or unsigned int.  */
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|)
operator|)
condition|)
name|pedwarn_with_decl
argument_list|(
name|x
argument_list|,
literal|"bit-field `%s' type invalid in ISO C"
argument_list|)
expr_stmt|;
comment|/* Detect and ignore out of range field width and process valid 	 field widths.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|int
name|max_width
init|=
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|c_bool_type_node
condition|?
name|CHAR_TYPE_SIZE
else|:
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|tree_int_cst_sgn
argument_list|(
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|error_with_decl
argument_list|(
name|x
argument_list|,
literal|"negative width in bit-field `%s'"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
literal|0
operator|<
name|compare_tree_int
argument_list|(
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
argument_list|,
name|max_width
argument_list|)
condition|)
name|pedwarn_with_decl
argument_list|(
name|x
argument_list|,
literal|"width of `%s' exceeds its type"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|integer_zerop
argument_list|(
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
argument_list|)
operator|&&
name|DECL_NAME
argument_list|(
name|x
argument_list|)
operator|!=
literal|0
condition|)
name|error_with_decl
argument_list|(
name|x
argument_list|,
literal|"zero width for bit-field `%s'"
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* The test above has assured us that TREE_INT_CST_HIGH is 0.  */
name|unsigned
name|HOST_WIDE_INT
name|width
init|=
name|tree_low_cst
argument_list|(
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|&&
operator|(
name|width
operator|<
name|min_precision
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|||
operator|(
name|width
operator|<
name|min_precision
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
name|warning_with_decl
argument_list|(
name|x
argument_list|,
literal|"`%s' is narrower than values of its type"
argument_list|)
expr_stmt|;
name|DECL_SIZE
argument_list|(
name|x
argument_list|)
operator|=
name|bitsize_int
argument_list|(
name|width
argument_list|)
expr_stmt|;
name|DECL_BIT_FIELD
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
name|SET_DECL_C_BIT_FIELD
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|width
operator|==
literal|0
operator|&&
operator|!
call|(
modifier|*
name|targetm
operator|.
name|ms_bitfield_layout_p
call|)
argument_list|(
name|t
argument_list|)
condition|)
block|{
comment|/* field size 0 => force desired amount of alignment.  */
ifdef|#
directive|ifdef
name|EMPTY_FIELD_BOUNDARY
name|DECL_ALIGN
argument_list|(
name|x
argument_list|)
operator|=
name|MAX
argument_list|(
name|DECL_ALIGN
argument_list|(
name|x
argument_list|)
argument_list|,
name|EMPTY_FIELD_BOUNDARY
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PCC_BITFIELD_TYPE_MATTERS
if|if
condition|(
name|PCC_BITFIELD_TYPE_MATTERS
condition|)
block|{
name|DECL_ALIGN
argument_list|(
name|x
argument_list|)
operator|=
name|MAX
argument_list|(
name|DECL_ALIGN
argument_list|(
name|x
argument_list|)
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_USER_ALIGN
argument_list|(
name|x
argument_list|)
operator||=
name|TYPE_USER_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
block|}
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Detect flexible array member in an invalid context.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|TYPE_MAX_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|UNION_TYPE
condition|)
name|error_with_decl
argument_list|(
name|x
argument_list|,
literal|"flexible array member in union"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|error_with_decl
argument_list|(
name|x
argument_list|,
literal|"flexible array member not at end of struct"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|saw_named_field
condition|)
name|error_with_decl
argument_list|(
name|x
argument_list|,
literal|"flexible array member in otherwise empty struct"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pedantic
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|flexible_array_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|pedwarn_with_decl
argument_list|(
name|x
argument_list|,
literal|"invalid use of structure with flexible array member"
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|x
argument_list|)
condition|)
name|saw_named_field
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Delete all duplicate fields from the fieldlist */
for|for
control|(
name|x
operator|=
name|fieldlist
init|;
name|x
operator|&&
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
condition|;
control|)
comment|/* Anonymous fields aren't duplicates.  */
if|if
condition|(
name|DECL_NAME
argument_list|(
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|y
init|=
name|fieldlist
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|y
argument_list|)
operator|==
name|DECL_NAME
argument_list|(
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
break|break;
if|if
condition|(
name|y
operator|==
name|x
condition|)
break|break;
name|y
operator|=
name|TREE_CHAIN
argument_list|(
name|y
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DECL_NAME
argument_list|(
name|y
argument_list|)
operator|==
name|DECL_NAME
argument_list|(
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
block|{
name|error_with_decl
argument_list|(
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
argument_list|,
literal|"duplicate member `%s'"
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
comment|/* Now we have the nearly final fieldlist.  Record it,      then lay out the structure or union (including the fields).  */
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
operator|=
name|fieldlist
expr_stmt|;
name|layout_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Delete all zero-width bit-fields from the fieldlist */
block|{
name|tree
modifier|*
name|fieldlistp
init|=
operator|&
name|fieldlist
decl_stmt|;
while|while
condition|(
operator|*
name|fieldlistp
condition|)
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|fieldlistp
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
operator|*
name|fieldlistp
argument_list|)
condition|)
operator|*
name|fieldlistp
operator|=
name|TREE_CHAIN
argument_list|(
operator|*
name|fieldlistp
argument_list|)
expr_stmt|;
else|else
name|fieldlistp
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|fieldlistp
argument_list|)
expr_stmt|;
block|}
comment|/* Now we have the truly final field list.      Store it in this type and in the variants.  */
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
operator|=
name|fieldlist
expr_stmt|;
for|for
control|(
name|x
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
init|;
name|x
condition|;
name|x
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|x
argument_list|)
control|)
block|{
name|TYPE_FIELDS
argument_list|(
name|x
argument_list|)
operator|=
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_LANG_SPECIFIC
argument_list|(
name|x
argument_list|)
operator|=
name|TYPE_LANG_SPECIFIC
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_ALIGN
argument_list|(
name|x
argument_list|)
operator|=
name|TYPE_ALIGN
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_USER_ALIGN
argument_list|(
name|x
argument_list|)
operator|=
name|TYPE_USER_ALIGN
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
comment|/* If this was supposed to be a transparent union, but we can't      make it one, warn and turn off the flag.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|UNION_TYPE
operator|&&
name|TYPE_TRANSPARENT_UNION
argument_list|(
name|t
argument_list|)
operator|&&
name|TYPE_MODE
argument_list|(
name|t
argument_list|)
operator|!=
name|DECL_MODE
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
block|{
name|TYPE_TRANSPARENT_UNION
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
name|warning
argument_list|(
literal|"union cannot be made transparent"
argument_list|)
expr_stmt|;
block|}
comment|/* If this structure or union completes the type of any previous      variable declaration, lay it out and output its rtl.  */
if|if
condition|(
name|current_binding_level
operator|->
name|incomplete_list
operator|!=
name|NULL_TREE
condition|)
block|{
name|tree
name|prev
init|=
name|NULL_TREE
decl_stmt|;
for|for
control|(
name|x
operator|=
name|current_binding_level
operator|->
name|incomplete_list
init|;
name|x
condition|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
control|)
block|{
name|tree
name|decl
init|=
name|TREE_VALUE
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
block|{
name|layout_decl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* This is a no-op in c-lang.c or something real in objc-act.c.  */
if|if
condition|(
name|flag_objc
condition|)
name|objc_check_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|rest_of_decl_compilation
argument_list|(
name|decl
argument_list|,
name|NULL
argument_list|,
name|toplevel
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|toplevel
condition|)
name|expand_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Unlink X from the incomplete list.  */
if|if
condition|(
name|prev
condition|)
name|TREE_CHAIN
argument_list|(
name|prev
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
expr_stmt|;
else|else
name|current_binding_level
operator|->
name|incomplete_list
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|tree
name|element
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|element
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|element
operator|=
name|TREE_TYPE
argument_list|(
name|element
argument_list|)
expr_stmt|;
if|if
condition|(
name|element
operator|==
name|t
condition|)
block|{
name|layout_array_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
block|{
name|layout_decl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_objc
condition|)
name|objc_check_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|rest_of_decl_compilation
argument_list|(
name|decl
argument_list|,
name|NULL
argument_list|,
name|toplevel
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|toplevel
condition|)
name|expand_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
comment|/* Unlink X from the incomplete list.  */
if|if
condition|(
name|prev
condition|)
name|TREE_CHAIN
argument_list|(
name|prev
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
expr_stmt|;
else|else
name|current_binding_level
operator|->
name|incomplete_list
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Finish debugging output for this type.  */
name|rest_of_type_compilation
argument_list|(
name|t
argument_list|,
name|toplevel
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Lay out the type T, and its element type, and so on.  */
end_comment

begin_function
specifier|static
name|void
name|layout_array_type
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|layout_array_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|layout_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Begin compiling the definition of an enumeration type.    NAME is its name (or null if anonymous).    Returns the type object, as yet incomplete.    Also records info about it so that build_enumerator    may be used to declare the individual values as they are read.  */
end_comment

begin_function
name|tree
name|start_enum
parameter_list|(
name|name
parameter_list|)
name|tree
name|name
decl_stmt|;
block|{
name|tree
name|enumtype
init|=
literal|0
decl_stmt|;
comment|/* If this is the real definition for a previous forward reference,      fill in the contents in the same object that used to be the      forward reference.  */
if|if
condition|(
name|name
operator|!=
literal|0
condition|)
name|enumtype
operator|=
name|lookup_tag
argument_list|(
name|ENUMERAL_TYPE
argument_list|,
name|name
argument_list|,
name|current_binding_level
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|enumtype
operator|==
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|enumtype
argument_list|)
operator|!=
name|ENUMERAL_TYPE
condition|)
block|{
name|enumtype
operator|=
name|make_node
argument_list|(
name|ENUMERAL_TYPE
argument_list|)
expr_stmt|;
name|pushtag
argument_list|(
name|name
argument_list|,
name|enumtype
argument_list|)
expr_stmt|;
block|}
name|C_TYPE_BEING_DEFINED
argument_list|(
name|enumtype
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TYPE_VALUES
argument_list|(
name|enumtype
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* This enum is a named one that has been declared already.  */
name|error
argument_list|(
literal|"redeclaration of `enum %s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Completely replace its old definition. 	 The old enumerators remain defined, however.  */
name|TYPE_VALUES
argument_list|(
name|enumtype
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
name|enum_next_value
operator|=
name|integer_zero_node
expr_stmt|;
name|enum_overflow
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flag_short_enums
condition|)
name|TYPE_PACKED
argument_list|(
name|enumtype
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|enumtype
return|;
block|}
end_function

begin_comment
comment|/* After processing and defining all the values of an enumeration type,    install their decls in the enumeration type and finish it off.    ENUMTYPE is the type object, VALUES a list of decl-value pairs,    and ATTRIBUTES are the specified attributes.    Returns ENUMTYPE.  */
end_comment

begin_function
name|tree
name|finish_enum
parameter_list|(
name|enumtype
parameter_list|,
name|values
parameter_list|,
name|attributes
parameter_list|)
name|tree
name|enumtype
decl_stmt|;
name|tree
name|values
decl_stmt|;
name|tree
name|attributes
decl_stmt|;
block|{
name|tree
name|pair
decl_stmt|,
name|tem
decl_stmt|;
name|tree
name|minnode
init|=
literal|0
decl_stmt|,
name|maxnode
init|=
literal|0
decl_stmt|,
name|enum_value_type
decl_stmt|;
name|int
name|precision
decl_stmt|,
name|unsign
decl_stmt|;
name|int
name|toplevel
init|=
operator|(
name|global_binding_level
operator|==
name|current_binding_level
operator|)
decl_stmt|;
if|if
condition|(
name|in_parm_level_p
argument_list|()
condition|)
name|warning
argument_list|(
literal|"enum defined inside parms"
argument_list|)
expr_stmt|;
name|decl_attributes
argument_list|(
operator|&
name|enumtype
argument_list|,
name|attributes
argument_list|,
operator|(
name|int
operator|)
name|ATTR_FLAG_TYPE_IN_PLACE
argument_list|)
expr_stmt|;
comment|/* Calculate the maximum value of any enumerator in this type.  */
if|if
condition|(
name|values
operator|==
name|error_mark_node
condition|)
name|minnode
operator|=
name|maxnode
operator|=
name|integer_zero_node
expr_stmt|;
else|else
block|{
name|minnode
operator|=
name|maxnode
operator|=
name|TREE_VALUE
argument_list|(
name|values
argument_list|)
expr_stmt|;
for|for
control|(
name|pair
operator|=
name|TREE_CHAIN
argument_list|(
name|values
argument_list|)
init|;
name|pair
condition|;
name|pair
operator|=
name|TREE_CHAIN
argument_list|(
name|pair
argument_list|)
control|)
block|{
name|tree
name|value
init|=
name|TREE_VALUE
argument_list|(
name|pair
argument_list|)
decl_stmt|;
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|maxnode
argument_list|,
name|value
argument_list|)
condition|)
name|maxnode
operator|=
name|value
expr_stmt|;
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|value
argument_list|,
name|minnode
argument_list|)
condition|)
name|minnode
operator|=
name|value
expr_stmt|;
block|}
block|}
comment|/* Construct the final type of this enumeration.  It is the same      as one of the integral types - the narrowest one that fits, except      that normally we only go as narrow as int - and signed iff any of      the values are negative.  */
name|unsign
operator|=
operator|(
name|tree_int_cst_sgn
argument_list|(
name|minnode
argument_list|)
operator|>=
literal|0
operator|)
expr_stmt|;
name|precision
operator|=
name|MAX
argument_list|(
name|min_precision
argument_list|(
name|minnode
argument_list|,
name|unsign
argument_list|)
argument_list|,
name|min_precision
argument_list|(
name|maxnode
argument_list|,
name|unsign
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_PACKED
argument_list|(
name|enumtype
argument_list|)
operator|||
name|precision
operator|>
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
condition|)
block|{
name|tree
name|narrowest
init|=
name|c_common_type_for_size
argument_list|(
name|precision
argument_list|,
name|unsign
argument_list|)
decl_stmt|;
if|if
condition|(
name|narrowest
operator|==
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"enumeration values exceed range of largest integer"
argument_list|)
expr_stmt|;
name|narrowest
operator|=
name|long_long_integer_type_node
expr_stmt|;
block|}
name|precision
operator|=
name|TYPE_PRECISION
argument_list|(
name|narrowest
argument_list|)
expr_stmt|;
block|}
else|else
name|precision
operator|=
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|precision
operator|==
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
condition|)
name|enum_value_type
operator|=
name|c_common_type_for_size
argument_list|(
name|precision
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|enum_value_type
operator|=
name|enumtype
expr_stmt|;
name|TYPE_MIN_VALUE
argument_list|(
name|enumtype
argument_list|)
operator|=
name|minnode
expr_stmt|;
name|TYPE_MAX_VALUE
argument_list|(
name|enumtype
argument_list|)
operator|=
name|maxnode
expr_stmt|;
name|TYPE_PRECISION
argument_list|(
name|enumtype
argument_list|)
operator|=
name|precision
expr_stmt|;
name|TREE_UNSIGNED
argument_list|(
name|enumtype
argument_list|)
operator|=
name|unsign
expr_stmt|;
name|TYPE_SIZE
argument_list|(
name|enumtype
argument_list|)
operator|=
literal|0
expr_stmt|;
name|layout_type
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|values
operator|!=
name|error_mark_node
condition|)
block|{
comment|/* Change the type of the enumerators to be the enum type.  We 	 need to do this irrespective of the size of the enum, for 	 proper type checking.  Replace the DECL_INITIALs of the 	 enumerators, and the value slots of the list, with copies 	 that have the enum type; they cannot be modified in place 	 because they may be shared (e.g.  integer_zero_node) Finally, 	 change the purpose slots to point to the names of the decls.  */
for|for
control|(
name|pair
operator|=
name|values
init|;
name|pair
condition|;
name|pair
operator|=
name|TREE_CHAIN
argument_list|(
name|pair
argument_list|)
control|)
block|{
name|tree
name|enu
init|=
name|TREE_PURPOSE
argument_list|(
name|pair
argument_list|)
decl_stmt|;
name|TREE_TYPE
argument_list|(
name|enu
argument_list|)
operator|=
name|enumtype
expr_stmt|;
name|DECL_SIZE
argument_list|(
name|enu
argument_list|)
operator|=
name|TYPE_SIZE
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
name|DECL_SIZE_UNIT
argument_list|(
name|enu
argument_list|)
operator|=
name|TYPE_SIZE_UNIT
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
name|DECL_ALIGN
argument_list|(
name|enu
argument_list|)
operator|=
name|TYPE_ALIGN
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
name|DECL_USER_ALIGN
argument_list|(
name|enu
argument_list|)
operator|=
name|TYPE_USER_ALIGN
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
name|DECL_MODE
argument_list|(
name|enu
argument_list|)
operator|=
name|TYPE_MODE
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
comment|/* The ISO C Standard mandates enumerators to have type int, 	     even though the underlying type of an enum type is 	     unspecified.  Here we convert any enumerators that fit in 	     an int to type int, to avoid promotions to unsigned types 	     when comparing integers with enumerators that fit in the 	     int range.  When -pedantic is given, build_enumerator() 	     would have already taken care of those that don't fit.  */
if|if
condition|(
name|int_fits_type_p
argument_list|(
name|DECL_INITIAL
argument_list|(
name|enu
argument_list|)
argument_list|,
name|enum_value_type
argument_list|)
condition|)
name|DECL_INITIAL
argument_list|(
name|enu
argument_list|)
operator|=
name|convert
argument_list|(
name|enum_value_type
argument_list|,
name|DECL_INITIAL
argument_list|(
name|enu
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|DECL_INITIAL
argument_list|(
name|enu
argument_list|)
operator|=
name|convert
argument_list|(
name|enumtype
argument_list|,
name|DECL_INITIAL
argument_list|(
name|enu
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_PURPOSE
argument_list|(
name|pair
argument_list|)
operator|=
name|DECL_NAME
argument_list|(
name|enu
argument_list|)
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|pair
argument_list|)
operator|=
name|DECL_INITIAL
argument_list|(
name|enu
argument_list|)
expr_stmt|;
block|}
name|TYPE_VALUES
argument_list|(
name|enumtype
argument_list|)
operator|=
name|values
expr_stmt|;
block|}
comment|/* Fix up all variant types of this enum type.  */
for|for
control|(
name|tem
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|enumtype
argument_list|)
init|;
name|tem
condition|;
name|tem
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|tem
argument_list|)
control|)
block|{
if|if
condition|(
name|tem
operator|==
name|enumtype
condition|)
continue|continue;
name|TYPE_VALUES
argument_list|(
name|tem
argument_list|)
operator|=
name|TYPE_VALUES
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
name|TYPE_MIN_VALUE
argument_list|(
name|tem
argument_list|)
operator|=
name|TYPE_MIN_VALUE
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
name|TYPE_MAX_VALUE
argument_list|(
name|tem
argument_list|)
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
name|TYPE_SIZE
argument_list|(
name|tem
argument_list|)
operator|=
name|TYPE_SIZE
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
name|TYPE_SIZE_UNIT
argument_list|(
name|tem
argument_list|)
operator|=
name|TYPE_SIZE_UNIT
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
name|TYPE_MODE
argument_list|(
name|tem
argument_list|)
operator|=
name|TYPE_MODE
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
name|TYPE_PRECISION
argument_list|(
name|tem
argument_list|)
operator|=
name|TYPE_PRECISION
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
name|TYPE_ALIGN
argument_list|(
name|tem
argument_list|)
operator|=
name|TYPE_ALIGN
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
name|TYPE_USER_ALIGN
argument_list|(
name|tem
argument_list|)
operator|=
name|TYPE_USER_ALIGN
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
name|TREE_UNSIGNED
argument_list|(
name|tem
argument_list|)
operator|=
name|TREE_UNSIGNED
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
block|}
comment|/* Finish debugging output for this type.  */
name|rest_of_type_compilation
argument_list|(
name|enumtype
argument_list|,
name|toplevel
argument_list|)
expr_stmt|;
return|return
name|enumtype
return|;
block|}
end_function

begin_comment
comment|/* Build and install a CONST_DECL for one value of the    current enumeration type (one that was begun with start_enum).    Return a tree-list containing the CONST_DECL and its value.    Assignment of sequential values by default is handled here.  */
end_comment

begin_function
name|tree
name|build_enumerator
parameter_list|(
name|name
parameter_list|,
name|value
parameter_list|)
name|tree
name|name
decl_stmt|,
name|value
decl_stmt|;
block|{
name|tree
name|decl
decl_stmt|,
name|type
decl_stmt|;
comment|/* Validate and default VALUE.  */
comment|/* Remove no-op casts from the value.  */
if|if
condition|(
name|value
condition|)
name|STRIP_TYPE_NOPS
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|value
operator|=
name|default_conversion
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|constant_expression_warning
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"enumerator value for `%s' not integer constant"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|value
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Default based on previous value.  */
comment|/* It should no longer be possible to have NON_LVALUE_EXPR      in the default.  */
if|if
condition|(
name|value
operator|==
literal|0
condition|)
block|{
name|value
operator|=
name|enum_next_value
expr_stmt|;
if|if
condition|(
name|enum_overflow
condition|)
name|error
argument_list|(
literal|"overflow in enumeration values"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|int_fits_type_p
argument_list|(
name|value
argument_list|,
name|integer_type_node
argument_list|)
condition|)
block|{
name|pedwarn
argument_list|(
literal|"ISO C restricts enumerator values to range of `int'"
argument_list|)
expr_stmt|;
name|value
operator|=
name|convert
argument_list|(
name|integer_type_node
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
comment|/* Set basis for default for next value.  */
name|enum_next_value
operator|=
name|build_binary_op
argument_list|(
name|PLUS_EXPR
argument_list|,
name|value
argument_list|,
name|integer_one_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|enum_overflow
operator|=
name|tree_int_cst_lt
argument_list|(
name|enum_next_value
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|/* Now create a declaration for the enum value name.  */
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|type
operator|=
name|c_common_type_for_size
argument_list|(
name|MAX
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
argument_list|)
argument_list|,
operator|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|>=
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|CONST_DECL
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|convert
argument_list|(
name|type
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
return|return
name|tree_cons
argument_list|(
name|decl
argument_list|,
name|value
argument_list|,
name|NULL_TREE
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create the FUNCTION_DECL for a function definition.    DECLSPECS, DECLARATOR and ATTRIBUTES are the parts of    the declaration; they describe the function's name and the type it returns,    but twisted together in a fashion that parallels the syntax of C.     This function creates a binding context for the function body    as well as setting up the FUNCTION_DECL in current_function_decl.     Returns 1 on success.  If the DECLARATOR is not suitable for a function    (it defines a datum instead), we return 0, which tells    yyparse to report a parse error.  */
end_comment

begin_function
name|int
name|start_function
parameter_list|(
name|declspecs
parameter_list|,
name|declarator
parameter_list|,
name|attributes
parameter_list|)
name|tree
name|declarator
decl_stmt|,
name|declspecs
decl_stmt|,
name|attributes
decl_stmt|;
block|{
name|tree
name|decl1
decl_stmt|,
name|old_decl
decl_stmt|;
name|tree
name|restype
decl_stmt|;
name|int
name|old_immediate_size_expand
init|=
name|immediate_size_expand
decl_stmt|;
name|current_function_returns_value
operator|=
literal|0
expr_stmt|;
comment|/* Assume, until we see it does.  */
name|current_function_returns_null
operator|=
literal|0
expr_stmt|;
name|current_function_returns_abnormally
operator|=
literal|0
expr_stmt|;
name|warn_about_return_type
operator|=
literal|0
expr_stmt|;
name|current_extern_inline
operator|=
literal|0
expr_stmt|;
name|named_labels
operator|=
literal|0
expr_stmt|;
name|shadowed_labels
operator|=
literal|0
expr_stmt|;
comment|/* Don't expand any sizes in the return type of the function.  */
name|immediate_size_expand
operator|=
literal|0
expr_stmt|;
name|decl1
operator|=
name|grokdeclarator
argument_list|(
name|declarator
argument_list|,
name|declspecs
argument_list|,
name|FUNCDEF
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* If the declarator is not suitable for a function definition,      cause a syntax error.  */
if|if
condition|(
name|decl1
operator|==
literal|0
condition|)
block|{
name|immediate_size_expand
operator|=
name|old_immediate_size_expand
expr_stmt|;
return|return
literal|0
return|;
block|}
name|decl_attributes
argument_list|(
operator|&
name|decl1
argument_list|,
name|attributes
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If #pragma weak was used, mark the decl weak now.  */
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
condition|)
name|maybe_apply_pragma_weak
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_DECLARED_INLINE_P
argument_list|(
name|decl1
argument_list|)
operator|&&
name|DECL_UNINLINABLE
argument_list|(
name|decl1
argument_list|)
operator|&&
name|lookup_attribute
argument_list|(
literal|"noinline"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|decl1
argument_list|)
argument_list|)
condition|)
name|warning_with_decl
argument_list|(
name|decl1
argument_list|,
literal|"inline function `%s' given attribute noinline"
argument_list|)
expr_stmt|;
name|announce_function
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|COMPLETE_OR_VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"return type is an incomplete type"
argument_list|)
expr_stmt|;
comment|/* Make it return void instead.  */
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
operator|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|warn_about_return_type
condition|)
name|pedwarn_c99
argument_list|(
literal|"return type defaults to `int'"
argument_list|)
expr_stmt|;
comment|/* Save the parm names or decls from this function's declarator      where store_parm_decls will find them.  */
name|current_function_parms
operator|=
name|last_function_parms
expr_stmt|;
name|current_function_parm_tags
operator|=
name|last_function_parm_tags
expr_stmt|;
comment|/* Make the init_value nonzero so pushdecl knows this is not tentative.      error_mark_node is replaced below (in poplevel) with the BLOCK.  */
name|DECL_INITIAL
argument_list|(
name|decl1
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
comment|/* If this definition isn't a prototype and we had a prototype declaration      before, copy the arg type info from that prototype.      But not if what we had before was a builtin function.  */
name|old_decl
operator|=
name|lookup_name_current_level
argument_list|(
name|DECL_NAME
argument_list|(
name|decl1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_decl
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|old_decl
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|&&
operator|!
name|DECL_BUILT_IN
argument_list|(
name|old_decl
argument_list|)
operator|&&
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
argument_list|)
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|old_decl
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|&&
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|old_decl
argument_list|)
expr_stmt|;
name|current_function_prototype_file
operator|=
name|DECL_SOURCE_FILE
argument_list|(
name|old_decl
argument_list|)
expr_stmt|;
name|current_function_prototype_line
operator|=
name|DECL_SOURCE_LINE
argument_list|(
name|old_decl
argument_list|)
expr_stmt|;
block|}
comment|/* If there is no explicit declaration, look for any out-of-scope implicit      declarations.  */
if|if
condition|(
name|old_decl
operator|==
literal|0
condition|)
name|old_decl
operator|=
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|DECL_NAME
argument_list|(
name|decl1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Optionally warn of old-fashioned def with no previous prototype.  */
if|if
condition|(
name|warn_strict_prototypes
operator|&&
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
operator|!
operator|(
name|old_decl
operator|!=
literal|0
operator|&&
operator|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|old_decl
argument_list|)
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|DECL_BUILT_IN
argument_list|(
name|old_decl
argument_list|)
operator|&&
operator|!
name|C_DECL_ANTICIPATED
argument_list|(
name|old_decl
argument_list|)
operator|)
operator|)
operator|)
condition|)
name|warning
argument_list|(
literal|"function declaration isn't a prototype"
argument_list|)
expr_stmt|;
comment|/* Optionally warn of any global def with no previous prototype.  */
elseif|else
if|if
condition|(
name|warn_missing_prototypes
operator|&&
name|TREE_PUBLIC
argument_list|(
name|decl1
argument_list|)
operator|&&
operator|!
operator|(
name|old_decl
operator|!=
literal|0
operator|&&
operator|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|old_decl
argument_list|)
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|DECL_BUILT_IN
argument_list|(
name|old_decl
argument_list|)
operator|&&
operator|!
name|C_DECL_ANTICIPATED
argument_list|(
name|old_decl
argument_list|)
operator|)
operator|)
operator|)
operator|&&
operator|!
name|MAIN_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|decl1
argument_list|)
argument_list|)
condition|)
name|warning_with_decl
argument_list|(
name|decl1
argument_list|,
literal|"no previous prototype for `%s'"
argument_list|)
expr_stmt|;
comment|/* Optionally warn of any def with no previous prototype      if the function has already been used.  */
elseif|else
if|if
condition|(
name|warn_missing_prototypes
operator|&&
name|old_decl
operator|!=
literal|0
operator|&&
name|TREE_USED
argument_list|(
name|old_decl
argument_list|)
operator|&&
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|old_decl
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|warning_with_decl
argument_list|(
name|decl1
argument_list|,
literal|"`%s' was used with no prototype before its definition"
argument_list|)
expr_stmt|;
comment|/* Optionally warn of any global def with no previous declaration.  */
elseif|else
if|if
condition|(
name|warn_missing_declarations
operator|&&
name|TREE_PUBLIC
argument_list|(
name|decl1
argument_list|)
operator|&&
name|old_decl
operator|==
literal|0
operator|&&
operator|!
name|MAIN_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|decl1
argument_list|)
argument_list|)
condition|)
name|warning_with_decl
argument_list|(
name|decl1
argument_list|,
literal|"no previous declaration for `%s'"
argument_list|)
expr_stmt|;
comment|/* Optionally warn of any def with no previous declaration      if the function has already been used.  */
elseif|else
if|if
condition|(
name|warn_missing_declarations
operator|&&
name|old_decl
operator|!=
literal|0
operator|&&
name|TREE_USED
argument_list|(
name|old_decl
argument_list|)
operator|&&
name|old_decl
operator|==
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|DECL_NAME
argument_list|(
name|decl1
argument_list|)
argument_list|)
condition|)
name|warning_with_decl
argument_list|(
name|decl1
argument_list|,
literal|"`%s' was used with no declaration before its definition"
argument_list|)
expr_stmt|;
comment|/* This is a definition, not a reference.      So normally clear DECL_EXTERNAL.      However, `extern inline' acts like a declaration      except for defining how to inline.  So set DECL_EXTERNAL in that case.  */
name|DECL_EXTERNAL
argument_list|(
name|decl1
argument_list|)
operator|=
name|current_extern_inline
expr_stmt|;
comment|/* This function exists in static storage.      (This does not mean `static' in the C sense!)  */
name|TREE_STATIC
argument_list|(
name|decl1
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* A nested function is not global.  */
if|if
condition|(
name|current_function_decl
operator|!=
literal|0
condition|)
name|TREE_PUBLIC
argument_list|(
name|decl1
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Warn for unlikely, improbable, or stupid declarations of `main'.  */
if|if
condition|(
name|warn_main
operator|>
literal|0
operator|&&
name|MAIN_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|decl1
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|args
decl_stmt|;
name|int
name|argct
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|integer_type_node
condition|)
name|pedwarn_with_decl
argument_list|(
name|decl1
argument_list|,
literal|"return type of `%s' is not `int'"
argument_list|)
expr_stmt|;
for|for
control|(
name|args
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
argument_list|)
init|;
name|args
condition|;
name|args
operator|=
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
control|)
block|{
name|tree
name|type
init|=
name|args
condition|?
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|void_type_node
condition|)
break|break;
operator|++
name|argct
expr_stmt|;
switch|switch
condition|(
name|argct
condition|)
block|{
case|case
literal|1
case|:
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|!=
name|integer_type_node
condition|)
name|pedwarn_with_decl
argument_list|(
name|decl1
argument_list|,
literal|"first argument of `%s' should be `int'"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|POINTER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
operator|||
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|char_type_node
operator|)
condition|)
name|pedwarn_with_decl
argument_list|(
name|decl1
argument_list|,
literal|"second argument of `%s' should be `char **'"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|POINTER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
operator|||
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|char_type_node
operator|)
condition|)
name|pedwarn_with_decl
argument_list|(
name|decl1
argument_list|,
literal|"third argument of `%s' should probably be `char **'"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* It is intentional that this message does not mention the third 	 argument because it's only mentioned in an appendix of the 	 standard.  */
if|if
condition|(
name|argct
operator|>
literal|0
operator|&&
operator|(
name|argct
operator|<
literal|2
operator|||
name|argct
operator|>
literal|3
operator|)
condition|)
name|pedwarn_with_decl
argument_list|(
name|decl1
argument_list|,
literal|"`%s' takes only zero or two arguments"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl1
argument_list|)
condition|)
name|pedwarn_with_decl
argument_list|(
name|decl1
argument_list|,
literal|"`%s' is normally a non-static function"
argument_list|)
expr_stmt|;
block|}
comment|/* Record the decl so that the function name is defined.      If we already have a decl for this name, and it is a FUNCTION_DECL,      use the old decl.  */
name|current_function_decl
operator|=
name|pushdecl
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|declare_parm_level
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|current_binding_level
operator|->
name|subblocks_tag_transparent
operator|=
literal|1
expr_stmt|;
name|make_decl_rtl
argument_list|(
name|current_function_decl
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|restype
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Promote the value to int before returning it.  */
if|if
condition|(
name|c_promoting_integer_type_p
argument_list|(
name|restype
argument_list|)
condition|)
block|{
comment|/* It retains unsignedness if not really getting wider.  */
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|restype
argument_list|)
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|restype
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|)
condition|)
name|restype
operator|=
name|unsigned_type_node
expr_stmt|;
else|else
name|restype
operator|=
name|integer_type_node
expr_stmt|;
block|}
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
operator|=
name|build_decl
argument_list|(
name|RESULT_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|restype
argument_list|)
expr_stmt|;
comment|/* If this fcn was already referenced via a block-scope `extern' decl      (or an implicit decl), propagate certain information about the usage.  */
if|if
condition|(
name|TREE_ADDRESSABLE
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
condition|)
name|TREE_ADDRESSABLE
argument_list|(
name|current_function_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|immediate_size_expand
operator|=
name|old_immediate_size_expand
expr_stmt|;
name|start_fname_decls
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Store the parameter declarations into the current function declaration.    This is called after parsing the parameter declarations, before    digesting the body of the function.     For an old-style definition, modify the function's type    to specify at least the number of arguments.  */
end_comment

begin_function
name|void
name|store_parm_decls
parameter_list|()
block|{
name|tree
name|fndecl
init|=
name|current_function_decl
decl_stmt|;
name|tree
name|parm
decl_stmt|;
comment|/* This is either a chain of PARM_DECLs (if a prototype was used)      or a list of IDENTIFIER_NODEs (for an old-fashioned C definition).  */
name|tree
name|specparms
init|=
name|current_function_parms
decl_stmt|;
comment|/* This is a list of types declared among parms in a prototype.  */
name|tree
name|parmtags
init|=
name|current_function_parm_tags
decl_stmt|;
comment|/* This is a chain of PARM_DECLs from old-style parm declarations.  */
name|tree
name|parmdecls
init|=
name|getdecls
argument_list|()
decl_stmt|;
comment|/* This is a chain of any other decls that came in among the parm      declarations.  If a parm is declared with  enum {foo, bar} x;      then CONST_DECLs for foo and bar are put here.  */
name|tree
name|nonparms
init|=
literal|0
decl_stmt|;
comment|/* The function containing FNDECL, if any.  */
name|tree
name|context
init|=
name|decl_function_context
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
comment|/* Nonzero if this definition is written with a prototype.  */
name|int
name|prototype
init|=
literal|0
decl_stmt|;
name|int
name|saved_warn_shadow
init|=
name|warn_shadow
decl_stmt|;
comment|/* Don't re-emit shadow warnings.  */
name|warn_shadow
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|specparms
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|specparms
argument_list|)
operator|!=
name|TREE_LIST
condition|)
block|{
comment|/* This case is when the function was defined with an ANSI prototype. 	 The parms already have decls, so we need not do anything here 	 except record them as in effect 	 and complain if any redundant old-style parm decls were written.  */
name|tree
name|next
decl_stmt|;
name|tree
name|others
init|=
literal|0
decl_stmt|;
name|prototype
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|parmdecls
operator|!=
literal|0
condition|)
block|{
name|tree
name|decl
decl_stmt|,
name|link
decl_stmt|;
name|error_with_decl
argument_list|(
name|fndecl
argument_list|,
literal|"parm types given both in parmlist and separately"
argument_list|)
expr_stmt|;
comment|/* Get rid of the erroneous decls; don't keep them on 	     the list of parms, since they might not be PARM_DECLs.  */
for|for
control|(
name|decl
operator|=
name|current_binding_level
operator|->
name|names
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
if|if
condition|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
condition|)
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|link
operator|=
name|current_binding_level
operator|->
name|shadowed
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
expr_stmt|;
name|current_binding_level
operator|->
name|names
operator|=
literal|0
expr_stmt|;
name|current_binding_level
operator|->
name|shadowed
operator|=
literal|0
expr_stmt|;
block|}
name|specparms
operator|=
name|nreverse
argument_list|(
name|specparms
argument_list|)
expr_stmt|;
for|for
control|(
name|parm
operator|=
name|specparms
init|;
name|parm
condition|;
name|parm
operator|=
name|next
control|)
block|{
name|next
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|PARM_DECL
condition|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|parm
argument_list|)
operator|==
literal|0
condition|)
name|error_with_decl
argument_list|(
name|parm
argument_list|,
literal|"parameter name omitted"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|!=
name|ERROR_MARK
operator|&&
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
condition|)
block|{
name|error_with_decl
argument_list|(
name|parm
argument_list|,
literal|"parameter `%s' declared void"
argument_list|)
expr_stmt|;
comment|/* Change the type to error_mark_node so this parameter 		     will be ignored by assign_parms.  */
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
name|pushdecl
argument_list|(
name|parm
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* If we find an enum constant or a type tag, 		 put it aside for the moment.  */
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
operator|=
literal|0
expr_stmt|;
name|others
operator|=
name|chainon
argument_list|(
name|others
argument_list|,
name|parm
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Get the decls in their original chain order 	 and record in the function.  */
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
operator|=
name|getdecls
argument_list|()
expr_stmt|;
if|#
directive|if
literal|0
comment|/* If this function takes a variable number of arguments, 	 add a phony parameter to the end of the parm list, 	 to represent the position of the first unnamed argument.  */
block|if (TREE_VALUE (tree_last (TYPE_ARG_TYPES (TREE_TYPE (fndecl)))) 	  != void_type_node) 	{ 	  tree dummy = build_decl (PARM_DECL, NULL_TREE, void_type_node);
comment|/* Let's hope the address of the unnamed parm 	     won't depend on its type.  */
block|TREE_TYPE (dummy) = integer_type_node; 	  DECL_ARG_TYPE (dummy) = integer_type_node; 	  DECL_ARGUMENTS (fndecl) = chainon (DECL_ARGUMENTS (fndecl), dummy); 	}
endif|#
directive|endif
comment|/* Now pushdecl the enum constants.  */
for|for
control|(
name|parm
operator|=
name|others
init|;
name|parm
condition|;
name|parm
operator|=
name|next
control|)
block|{
name|next
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|parm
argument_list|)
operator|==
literal|0
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
name|void_type_node
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|!=
name|PARM_DECL
condition|)
name|pushdecl
argument_list|(
name|parm
argument_list|)
expr_stmt|;
block|}
name|storetags
argument_list|(
name|chainon
argument_list|(
name|parmtags
argument_list|,
name|gettags
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* SPECPARMS is an identifier list--a chain of TREE_LIST nodes 	 each with a parm name as the TREE_VALUE.  	 PARMDECLS is a chain of declarations for parameters. 	 Warning! It can also contain CONST_DECLs which are not parameters 	 but are names of enumerators of any enum types 	 declared among the parameters.  	 First match each formal parameter name with its declaration. 	 Associate decls with the names and store the decls 	 into the TREE_PURPOSE slots.  */
comment|/* We use DECL_WEAK as a flag to show which parameters have been 	 seen already since it is not used on PARM_DECL or CONST_DECL.  */
for|for
control|(
name|parm
operator|=
name|parmdecls
init|;
name|parm
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
control|)
name|DECL_WEAK
argument_list|(
name|parm
argument_list|)
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|parm
operator|=
name|specparms
init|;
name|parm
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
control|)
block|{
name|tree
name|tail
decl_stmt|,
name|found
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error_with_decl
argument_list|(
name|fndecl
argument_list|,
literal|"parameter name missing from parameter list"
argument_list|)
expr_stmt|;
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
comment|/* See if any of the parmdecls specifies this parm by name. 	     Ignore any enumerator decls.  */
for|for
control|(
name|tail
operator|=
name|parmdecls
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
control|)
if|if
condition|(
name|DECL_NAME
argument_list|(
name|tail
argument_list|)
operator|==
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|tail
argument_list|)
operator|==
name|PARM_DECL
condition|)
block|{
name|found
operator|=
name|tail
expr_stmt|;
break|break;
block|}
comment|/* If declaration already marked, we have a duplicate name. 	     Complain, and don't use this decl twice.  */
if|if
condition|(
name|found
operator|&&
name|DECL_WEAK
argument_list|(
name|found
argument_list|)
condition|)
block|{
name|error_with_decl
argument_list|(
name|found
argument_list|,
literal|"multiple parameters named `%s'"
argument_list|)
expr_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If the declaration says "void", complain and ignore it.  */
if|if
condition|(
name|found
operator|&&
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|found
argument_list|)
argument_list|)
condition|)
block|{
name|error_with_decl
argument_list|(
name|found
argument_list|,
literal|"parameter `%s' declared void"
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|found
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
name|DECL_ARG_TYPE
argument_list|(
name|found
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
name|layout_decl
argument_list|(
name|found
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* If no declaration found, default to int.  */
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|found
operator|=
name|build_decl
argument_list|(
name|PARM_DECL
argument_list|,
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|integer_type_node
argument_list|)
expr_stmt|;
name|DECL_ARG_TYPE
argument_list|(
name|found
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|found
argument_list|)
expr_stmt|;
name|DECL_SOURCE_LINE
argument_list|(
name|found
argument_list|)
operator|=
name|DECL_SOURCE_LINE
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|DECL_SOURCE_FILE
argument_list|(
name|found
argument_list|)
operator|=
name|DECL_SOURCE_FILE
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_isoc99
condition|)
name|pedwarn_with_decl
argument_list|(
name|found
argument_list|,
literal|"type of `%s' defaults to `int'"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|extra_warnings
condition|)
name|warning_with_decl
argument_list|(
name|found
argument_list|,
literal|"type of `%s' defaults to `int'"
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|found
argument_list|)
expr_stmt|;
block|}
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
operator|=
name|found
expr_stmt|;
comment|/* Mark this decl as "already found".  */
name|DECL_WEAK
argument_list|(
name|found
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Put anything which is on the parmdecls chain and which is 	 not a PARM_DECL onto the list NONPARMS.  (The types of 	 non-parm things which might appear on the list include 	 enumerators and NULL-named TYPE_DECL nodes.) Complain about 	 any actual PARM_DECLs not matched with any names.  */
name|nonparms
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|parm
operator|=
name|parmdecls
init|;
name|parm
condition|;
control|)
block|{
name|tree
name|next
init|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
decl_stmt|;
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|!=
name|PARM_DECL
condition|)
name|nonparms
operator|=
name|chainon
argument_list|(
name|nonparms
argument_list|,
name|parm
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Complain about args with incomplete types.  */
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
condition|)
block|{
name|error_with_decl
argument_list|(
name|parm
argument_list|,
literal|"parameter `%s' has incomplete type"
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|DECL_WEAK
argument_list|(
name|parm
argument_list|)
condition|)
block|{
name|error_with_decl
argument_list|(
name|parm
argument_list|,
literal|"declaration for parameter `%s' but no such parameter"
argument_list|)
expr_stmt|;
comment|/* Pretend the parameter was not missing. 		     This gets us to a standard state and minimizes 		     further error messages.  */
name|specparms
operator|=
name|chainon
argument_list|(
name|specparms
argument_list|,
name|tree_cons
argument_list|(
name|parm
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|parm
operator|=
name|next
expr_stmt|;
block|}
comment|/* Chain the declarations together in the order of the list of          names.  Store that chain in the function decl, replacing the          list of names.  */
name|parm
operator|=
name|specparms
expr_stmt|;
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
operator|=
literal|0
expr_stmt|;
block|{
name|tree
name|last
decl_stmt|;
for|for
control|(
name|last
operator|=
literal|0
init|;
name|parm
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
control|)
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
condition|)
block|{
if|if
condition|(
name|last
operator|==
literal|0
condition|)
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
operator|=
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
expr_stmt|;
else|else
name|TREE_CHAIN
argument_list|(
name|last
argument_list|)
operator|=
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|last
operator|=
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|last
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* If there was a previous prototype, 	 set the DECL_ARG_TYPE of each argument according to 	 the type previously specified, and report any mismatches.  */
if|if
condition|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|type
decl_stmt|;
for|for
control|(
name|parm
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
operator|,
name|type
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
init|;
name|parm
operator|||
operator|(
name|type
operator|&&
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|void_type_node
operator|)
operator|)
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
operator|,
name|type
operator|=
name|TREE_CHAIN
argument_list|(
name|type
argument_list|)
control|)
block|{
if|if
condition|(
name|parm
operator|==
literal|0
operator|||
name|type
operator|==
literal|0
operator|||
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|void_type_node
condition|)
block|{
name|error
argument_list|(
literal|"number of arguments doesn't match prototype"
argument_list|)
expr_stmt|;
name|error_with_file_and_line
argument_list|(
name|current_function_prototype_file
argument_list|,
name|current_function_prototype_line
argument_list|,
literal|"prototype declaration"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Type for passing arg must be consistent with that 		 declared for the arg.  ISO C says we take the unqualified 		 type for parameters declared with qualified type.  */
if|if
condition|(
operator|!
name|comptypes
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|DECL_ARG_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Adjust argument to match prototype.  E.g. a previous 			 `int foo(float);' prototype causes 			 `int foo(x) float x; {...}' to be treated like 			 `int foo(float x) {...}'.  This is particularly 			 useful for argument types like uid_t.  */
name|DECL_ARG_TYPE
argument_list|(
name|parm
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
expr_stmt|;
if|if
condition|(
name|PROMOTE_PROTOTYPES
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|&&
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
condition|)
name|DECL_ARG_TYPE
argument_list|(
name|parm
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
if|if
condition|(
name|pedantic
condition|)
block|{
name|pedwarn
argument_list|(
literal|"promoted argument `%s' doesn't match prototype"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|parm
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|warning_with_file_and_line
argument_list|(
name|current_function_prototype_file
argument_list|,
name|current_function_prototype_line
argument_list|,
literal|"prototype declaration"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|error
argument_list|(
literal|"argument `%s' doesn't match prototype"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|parm
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|error_with_file_and_line
argument_list|(
name|current_function_prototype_file
argument_list|,
name|current_function_prototype_line
argument_list|,
literal|"prototype declaration"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|TYPE_ACTUAL_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Otherwise, create a prototype that would match.  */
else|else
block|{
name|tree
name|actual
init|=
literal|0
decl_stmt|,
name|last
init|=
literal|0
decl_stmt|,
name|type
decl_stmt|;
for|for
control|(
name|parm
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
init|;
name|parm
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
control|)
block|{
name|type
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|DECL_ARG_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|last
condition|)
name|TREE_CHAIN
argument_list|(
name|last
argument_list|)
operator|=
name|type
expr_stmt|;
else|else
name|actual
operator|=
name|type
expr_stmt|;
name|last
operator|=
name|type
expr_stmt|;
block|}
name|type
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|void_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|last
condition|)
name|TREE_CHAIN
argument_list|(
name|last
argument_list|)
operator|=
name|type
expr_stmt|;
else|else
name|actual
operator|=
name|type
expr_stmt|;
comment|/* We are going to assign a new value for the TYPE_ACTUAL_ARG_TYPES 	     of the type of this function, but we need to avoid having this 	     affect the types of other similarly-typed functions, so we must 	     first force the generation of an identical (but separate) type 	     node for the relevant function type.  The new node we create 	     will be a variant of the main variant of the original function 	     type.  */
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
operator|=
name|build_type_copy
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_ACTUAL_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|=
name|actual
expr_stmt|;
block|}
comment|/* Now store the final chain of decls for the arguments 	 as the decl-chain of the current lexical scope. 	 Put the enumerators in as well, at the front so that 	 DECL_ARGUMENTS is not modified.  */
name|storedecls
argument_list|(
name|chainon
argument_list|(
name|nonparms
argument_list|,
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Make sure the binding level for the top of the function body      gets a BLOCK if there are any in the function.      Otherwise, the dbx output is wrong.  */
name|keep_next_if_subblocks
operator|=
literal|1
expr_stmt|;
comment|/* ??? This might be an improvement,      but needs to be thought about some more.  */
if|#
directive|if
literal|0
block|keep_next_level_flag = 1;
endif|#
directive|endif
comment|/* Write a record describing this function definition to the prototypes      file (if requested).  */
name|gen_aux_info_record
argument_list|(
name|fndecl
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|prototype
argument_list|)
expr_stmt|;
comment|/* Initialize the RTL code for the function.  */
name|init_function_start
argument_list|(
name|fndecl
argument_list|,
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
comment|/* Begin the statement tree for this function.  */
name|begin_stmt_tree
argument_list|(
operator|&
name|DECL_SAVED_TREE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If this is a nested function, save away the sizes of any      variable-size types so that we can expand them when generating      RTL.  */
if|if
condition|(
name|context
condition|)
block|{
name|tree
name|t
decl_stmt|;
name|DECL_LANG_SPECIFIC
argument_list|(
name|fndecl
argument_list|)
operator|->
name|pending_sizes
operator|=
name|nreverse
argument_list|(
name|get_pending_sizes
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|DECL_LANG_SPECIFIC
argument_list|(
name|fndecl
argument_list|)
operator|->
name|pending_sizes
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
name|SAVE_EXPR_CONTEXT
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
name|context
expr_stmt|;
block|}
comment|/* This function is being processed in whole-function mode.  */
name|cfun
operator|->
name|x_whole_function_mode_p
operator|=
literal|1
expr_stmt|;
comment|/* Even though we're inside a function body, we still don't want to      call expand_expr to calculate the size of a variable-sized array.      We haven't necessarily assigned RTL to all variables yet, so it's      not safe to try to expand expressions involving them.  */
name|immediate_size_expand
operator|=
literal|0
expr_stmt|;
name|cfun
operator|->
name|x_dont_save_pending_sizes_p
operator|=
literal|1
expr_stmt|;
name|warn_shadow
operator|=
name|saved_warn_shadow
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Finish up a function declaration and compile that function    all the way to assembler language output.  The free the storage    for the function definition.     This is called after parsing the body of the function definition.     NESTED is nonzero if the function being finished is nested in another.    CAN_DEFER_P is nonzero if the function may be deferred.  */
end_comment

begin_function
name|void
name|finish_function
parameter_list|(
name|nested
parameter_list|,
name|can_defer_p
parameter_list|)
name|int
name|nested
decl_stmt|;
name|int
name|can_defer_p
decl_stmt|;
block|{
name|tree
name|fndecl
init|=
name|current_function_decl
decl_stmt|;
if|#
directive|if
literal|0
comment|/* This caused&foo to be of type ptr-to-const-function which then      got a warning when stored in a ptr-to-function variable.  */
block|TREE_READONLY (fndecl) = 1;
endif|#
directive|endif
name|poplevel
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|BLOCK_SUPERCONTEXT
argument_list|(
name|DECL_INITIAL
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|=
name|fndecl
expr_stmt|;
comment|/* Must mark the RESULT_DECL as being in this function.  */
name|DECL_CONTEXT
argument_list|(
name|DECL_RESULT
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|=
name|fndecl
expr_stmt|;
if|if
condition|(
name|MAIN_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|&&
name|flag_hosted
condition|)
block|{
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|integer_type_node
condition|)
block|{
comment|/* If warn_main is 1 (-Wmain) or 2 (-Wall), we have already warned. 	     If warn_main is -1 (-Wno-main) we don't want to be warned.  */
if|if
condition|(
operator|!
name|warn_main
condition|)
name|pedwarn_with_decl
argument_list|(
name|fndecl
argument_list|,
literal|"return type of `%s' is not `int'"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|DEFAULT_MAIN_RETURN
comment|/* Make it so that `main' always returns success by default.  */
name|DEFAULT_MAIN_RETURN
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|flag_isoc99
condition|)
name|c_expand_return
argument_list|(
name|integer_zero_node
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
name|finish_fname_decls
argument_list|()
expr_stmt|;
comment|/* Tie off the statement tree for this function.  */
name|finish_stmt_tree
argument_list|(
operator|&
name|DECL_SAVED_TREE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Complain if there's just no return statement.  */
if|if
condition|(
name|warn_return_type
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|VOID_TYPE
operator|&&
operator|!
name|current_function_returns_value
operator|&&
operator|!
name|current_function_returns_null
comment|/* Don't complain if we abort.  */
operator|&&
operator|!
name|current_function_returns_abnormally
comment|/* Don't warn for main().  */
operator|&&
operator|!
name|MAIN_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
comment|/* Or if they didn't actually specify a return type.  */
operator|&&
operator|!
name|C_FUNCTION_IMPLICIT_INT
argument_list|(
name|fndecl
argument_list|)
comment|/* Normally, with -Wreturn-type, flow will complain.  Unless we're an 	 inline function, as we might never be compiled separately.  */
operator|&&
name|DECL_INLINE
argument_list|(
name|fndecl
argument_list|)
condition|)
name|warning
argument_list|(
literal|"no return statement in function returning non-void"
argument_list|)
expr_stmt|;
comment|/* Clear out memory we no longer need.  */
name|free_after_parsing
argument_list|(
name|cfun
argument_list|)
expr_stmt|;
comment|/* Since we never call rest_of_compilation, we never clear      CFUN.  Do so explicitly.  */
name|free_after_compilation
argument_list|(
name|cfun
argument_list|)
expr_stmt|;
name|cfun
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|nested
condition|)
block|{
comment|/* Generate RTL for the body of this function.  */
name|c_expand_body
argument_list|(
name|fndecl
argument_list|,
name|nested
argument_list|,
name|can_defer_p
argument_list|)
expr_stmt|;
comment|/* Let the error reporting routines know that we're outside a 	 function.  For a nested function, this value is used in 	 c_pop_function_context and then reset via pop_function_context.  */
name|current_function_decl
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Generate the RTL for a deferred function FNDECL.  */
end_comment

begin_function
name|void
name|c_expand_deferred_function
parameter_list|(
name|fndecl
parameter_list|)
name|tree
name|fndecl
decl_stmt|;
block|{
comment|/* DECL_INLINE or DECL_RESULT might got cleared after the inline      function was deferred, e.g. in duplicate_decls.  */
if|if
condition|(
name|DECL_INLINE
argument_list|(
name|fndecl
argument_list|)
operator|&&
name|DECL_RESULT
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
name|c_expand_body
argument_list|(
name|fndecl
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|current_function_decl
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Called to move the SAVE_EXPRs for parameter declarations in a    nested function into the nested function.  DATA is really the    nested FUNCTION_DECL.  */
end_comment

begin_function
specifier|static
name|tree
name|set_save_expr_context
parameter_list|(
name|tp
parameter_list|,
name|walk_subtrees
parameter_list|,
name|data
parameter_list|)
name|tree
modifier|*
name|tp
decl_stmt|;
name|int
modifier|*
name|walk_subtrees
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|tp
argument_list|)
operator|==
name|SAVE_EXPR
operator|&&
operator|!
name|SAVE_EXPR_CONTEXT
argument_list|(
operator|*
name|tp
argument_list|)
condition|)
name|SAVE_EXPR_CONTEXT
argument_list|(
operator|*
name|tp
argument_list|)
operator|=
operator|(
name|tree
operator|)
name|data
expr_stmt|;
comment|/* Do not walk back into the SAVE_EXPR_CONTEXT; that will cause      circularity.  */
elseif|else
if|if
condition|(
name|DECL_P
argument_list|(
operator|*
name|tp
argument_list|)
condition|)
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Generate the RTL for the body of FNDECL.  If NESTED_P is nonzero,    then we are already in the process of generating RTL for another    function.  If can_defer_p is zero, we won't attempt to defer the    generation of RTL.  */
end_comment

begin_function
specifier|static
name|void
name|c_expand_body
parameter_list|(
name|fndecl
parameter_list|,
name|nested_p
parameter_list|,
name|can_defer_p
parameter_list|)
name|tree
name|fndecl
decl_stmt|;
name|int
name|nested_p
decl_stmt|,
name|can_defer_p
decl_stmt|;
block|{
name|int
name|uninlinable
init|=
literal|1
decl_stmt|;
name|int
name|saved_lineno
decl_stmt|;
specifier|const
name|char
modifier|*
name|saved_input_filename
decl_stmt|;
comment|/* There's no reason to do any of the work here if we're only doing      semantic analysis; this code just generates RTL.  */
if|if
condition|(
name|flag_syntax_only
condition|)
return|return;
name|saved_lineno
operator|=
name|lineno
expr_stmt|;
name|saved_input_filename
operator|=
name|input_filename
expr_stmt|;
name|lineno
operator|=
name|DECL_SOURCE_LINE
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|input_filename
operator|=
name|DECL_SOURCE_FILE
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_inline_trees
condition|)
block|{
comment|/* First, cache whether the current function is inlinable.  Some          predicates depend on cfun and current_function_decl to          function completely.  */
name|timevar_push
argument_list|(
name|TV_INTEGRATION
argument_list|)
expr_stmt|;
name|uninlinable
operator|=
operator|!
name|tree_inlinable_function_p
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|uninlinable
operator|&&
name|can_defer_p
comment|/* Save function tree for inlining.  Should return 0 if the              language does not support function deferring or the              function could not be deferred.  */
operator|&&
name|defer_fn
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
comment|/* Let the back-end know that this function exists.  */
call|(
modifier|*
name|debug_hooks
operator|->
name|deferred_inline_function
call|)
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_INTEGRATION
argument_list|)
expr_stmt|;
name|lineno
operator|=
name|saved_lineno
expr_stmt|;
name|input_filename
operator|=
name|saved_input_filename
expr_stmt|;
return|return;
block|}
comment|/* Then, inline any functions called in it.  */
name|optimize_inline_calls
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_INTEGRATION
argument_list|)
expr_stmt|;
block|}
name|timevar_push
argument_list|(
name|TV_EXPAND
argument_list|)
expr_stmt|;
if|if
condition|(
name|nested_p
condition|)
block|{
comment|/* Make sure that we will evaluate variable-sized types involved 	 in our function's type.  */
name|expand_pending_sizes
argument_list|(
name|DECL_LANG_SPECIFIC
argument_list|(
name|fndecl
argument_list|)
operator|->
name|pending_sizes
argument_list|)
expr_stmt|;
comment|/* Squirrel away our current state.  */
name|push_function_context
argument_list|()
expr_stmt|;
block|}
comment|/* Initialize the RTL code for the function.  */
name|current_function_decl
operator|=
name|fndecl
expr_stmt|;
name|init_function_start
argument_list|(
name|fndecl
argument_list|,
name|input_filename
argument_list|,
name|DECL_SOURCE_LINE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This function is being processed in whole-function mode.  */
name|cfun
operator|->
name|x_whole_function_mode_p
operator|=
literal|1
expr_stmt|;
comment|/* Even though we're inside a function body, we still don't want to      call expand_expr to calculate the size of a variable-sized array.      We haven't necessarily assigned RTL to all variables yet, so it's      not safe to try to expand expressions involving them.  */
name|immediate_size_expand
operator|=
literal|0
expr_stmt|;
name|cfun
operator|->
name|x_dont_save_pending_sizes_p
operator|=
literal|1
expr_stmt|;
comment|/* Set up parameters and prepare for return, for the function.  */
name|expand_function_start
argument_list|(
name|fndecl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If the function has a variably modified type, there may be      SAVE_EXPRs in the parameter types.  Their context must be set to      refer to this function; they cannot be expanded in the containing      function.  */
if|if
condition|(
name|decl_function_context
argument_list|(
name|fndecl
argument_list|)
operator|&&
name|variably_modified_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
condition|)
name|walk_tree
argument_list|(
operator|&
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|,
name|set_save_expr_context
argument_list|,
name|fndecl
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* If this function is `main', emit a call to `__main'      to run global initializers, etc.  */
if|if
condition|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
operator|&&
name|MAIN_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|&&
name|DECL_CONTEXT
argument_list|(
name|fndecl
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|expand_main_function
argument_list|()
expr_stmt|;
comment|/* Generate the RTL for this function.  */
name|expand_stmt
argument_list|(
name|DECL_SAVED_TREE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Keep the function body if it's needed for inlining or dumping.  */
if|if
condition|(
name|uninlinable
operator|&&
operator|!
name|dump_enabled_p
argument_list|(
name|TDI_all
argument_list|)
condition|)
block|{
comment|/* Allow the body of the function to be garbage collected.  */
name|DECL_SAVED_TREE
argument_list|(
name|fndecl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
comment|/* We hard-wired immediate_size_expand to zero above.      expand_function_end will decrement this variable.  So, we set the      variable to one here, so that after the decrement it will remain      zero.  */
name|immediate_size_expand
operator|=
literal|1
expr_stmt|;
comment|/* Allow language dialects to perform special processing.  */
if|if
condition|(
name|lang_expand_function_end
condition|)
call|(
modifier|*
name|lang_expand_function_end
call|)
argument_list|()
expr_stmt|;
comment|/* Generate rtl for function exit.  */
name|expand_function_end
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If this is a nested function, protect the local variables in the stack      above us from being collected while we're compiling this function.  */
if|if
condition|(
name|nested_p
condition|)
name|ggc_push_context
argument_list|()
expr_stmt|;
comment|/* Run the optimizers and output the assembler code for this function.  */
name|rest_of_compilation
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
comment|/* Undo the GC context switch.  */
if|if
condition|(
name|nested_p
condition|)
name|ggc_pop_context
argument_list|()
expr_stmt|;
comment|/* With just -W, complain only if function returns both with      and without a value.  */
if|if
condition|(
name|extra_warnings
operator|&&
name|current_function_returns_value
operator|&&
name|current_function_returns_null
condition|)
name|warning
argument_list|(
literal|"this function may return with or without a value"
argument_list|)
expr_stmt|;
comment|/* If requested, warn about function definitions where the function will      return a value (usually of some struct or union type) which itself will      take up a lot of stack space.  */
if|if
condition|(
name|warn_larger_than
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|fndecl
argument_list|)
operator|&&
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
name|tree
name|ret_type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret_type
operator|&&
name|TYPE_SIZE_UNIT
argument_list|(
name|ret_type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_SIZE_UNIT
argument_list|(
name|ret_type
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
literal|0
operator|<
name|compare_tree_int
argument_list|(
name|TYPE_SIZE_UNIT
argument_list|(
name|ret_type
argument_list|)
argument_list|,
name|larger_than_size
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|size_as_int
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE_UNIT
argument_list|(
name|ret_type
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|compare_tree_int
argument_list|(
name|TYPE_SIZE_UNIT
argument_list|(
name|ret_type
argument_list|)
argument_list|,
name|size_as_int
argument_list|)
operator|==
literal|0
condition|)
name|warning_with_decl
argument_list|(
name|fndecl
argument_list|,
literal|"size of return value of `%s' is %u bytes"
argument_list|,
name|size_as_int
argument_list|)
expr_stmt|;
else|else
name|warning_with_decl
argument_list|(
name|fndecl
argument_list|,
literal|"size of return value of `%s' is larger than %d bytes"
argument_list|,
name|larger_than_size
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|DECL_SAVED_INSNS
argument_list|(
name|fndecl
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|nested_p
operator|&&
operator|!
name|flag_inline_trees
condition|)
block|{
comment|/* Stop pointing to the local nodes about to be freed. 	 But DECL_INITIAL must remain nonzero so we know this 	 was an actual function definition. 	 For a nested function, this is done in c_pop_function_context. 	 If rest_of_compilation set this to 0, leave it 0.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|fndecl
argument_list|)
operator|!=
literal|0
condition|)
name|DECL_INITIAL
argument_list|(
name|fndecl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|DECL_STATIC_CONSTRUCTOR
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
if|if
condition|(
name|targetm
operator|.
name|have_ctors_dtors
condition|)
call|(
modifier|*
name|targetm
operator|.
name|asm_out
operator|.
name|constructor
call|)
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|fndecl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|DEFAULT_INIT_PRIORITY
argument_list|)
expr_stmt|;
else|else
name|static_ctors
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|fndecl
argument_list|,
name|static_ctors
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DECL_STATIC_DESTRUCTOR
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
if|if
condition|(
name|targetm
operator|.
name|have_ctors_dtors
condition|)
call|(
modifier|*
name|targetm
operator|.
name|asm_out
operator|.
name|destructor
call|)
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|fndecl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|DEFAULT_INIT_PRIORITY
argument_list|)
expr_stmt|;
else|else
name|static_dtors
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|fndecl
argument_list|,
name|static_dtors
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nested_p
condition|)
comment|/* Return to the enclosing function.  */
name|pop_function_context
argument_list|()
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_EXPAND
argument_list|)
expr_stmt|;
name|lineno
operator|=
name|saved_lineno
expr_stmt|;
name|input_filename
operator|=
name|saved_input_filename
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Check the declarations given in a for-loop for satisfying the C99    constraints.  */
end_comment

begin_function
name|void
name|check_for_loop_decls
parameter_list|()
block|{
name|tree
name|t
decl_stmt|;
if|if
condition|(
operator|!
name|flag_isoc99
condition|)
block|{
comment|/* If we get here, declarations have been used in a for loop without 	 the C99 for loop scope.  This doesn't make much sense, so don't 	 allow it.  */
name|error
argument_list|(
literal|"`for' loop initial declaration used outside C99 mode"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* C99 subclause 6.8.5 paragraph 3:         [#3]  The  declaration  part  of  a for statement shall only        declare identifiers for objects having storage class auto or        register.       It isn't clear whether, in this sentence, "identifiers" binds to      "shall only declare" or to "objects" - that is, whether all identifiers      declared must be identifiers for objects, or whether the restriction      only applies to those that are.  (A question on this in comp.std.c      in November 2000 received no answer.)  We implement the strictest      interpretation, to avoid creating an extension which later causes      problems.  */
for|for
control|(
name|t
operator|=
name|gettags
argument_list|()
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|RECORD_TYPE
condition|)
name|error
argument_list|(
literal|"`struct %s' declared in `for' loop initial declaration"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|UNION_TYPE
condition|)
name|error
argument_list|(
literal|"`union %s' declared in `for' loop initial declaration"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"`enum %s' declared in `for' loop initial declaration"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|t
operator|=
name|getdecls
argument_list|()
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|VAR_DECL
operator|&&
name|DECL_NAME
argument_list|(
name|t
argument_list|)
condition|)
name|error_with_decl
argument_list|(
name|t
argument_list|,
literal|"declaration of non-variable `%s' in `for' loop initial declaration"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|t
argument_list|)
condition|)
name|error_with_decl
argument_list|(
name|t
argument_list|,
literal|"declaration of static variable `%s' in `for' loop initial declaration"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|t
argument_list|)
condition|)
name|error_with_decl
argument_list|(
name|t
argument_list|,
literal|"declaration of `extern' variable `%s' in `for' loop initial declaration"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Save and restore the variables in this file and elsewhere    that keep track of the progress of compilation of the current function.    Used for nested functions.  */
end_comment

begin_decl_stmt
name|struct
name|language_function
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
name|struct
name|c_language_function
name|base
decl_stmt|;
name|tree
name|named_labels
decl_stmt|;
name|tree
name|shadowed_labels
decl_stmt|;
name|int
name|returns_value
decl_stmt|;
name|int
name|returns_null
decl_stmt|;
name|int
name|returns_abnormally
decl_stmt|;
name|int
name|warn_about_return_type
decl_stmt|;
name|int
name|extern_inline
decl_stmt|;
name|struct
name|binding_level
modifier|*
name|binding_level
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* Save and reinitialize the variables    used during compilation of a C function.  */
end_comment

begin_function
name|void
name|c_push_function_context
parameter_list|(
name|f
parameter_list|)
name|struct
name|function
modifier|*
name|f
decl_stmt|;
block|{
name|struct
name|language_function
modifier|*
name|p
decl_stmt|;
name|p
operator|=
operator|(
operator|(
expr|struct
name|language_function
operator|*
operator|)
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|language_function
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|f
operator|->
name|language
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|base
operator|.
name|x_stmt_tree
operator|=
name|c_stmt_tree
expr_stmt|;
name|p
operator|->
name|base
operator|.
name|x_scope_stmt_stack
operator|=
name|c_scope_stmt_stack
expr_stmt|;
name|p
operator|->
name|named_labels
operator|=
name|named_labels
expr_stmt|;
name|p
operator|->
name|shadowed_labels
operator|=
name|shadowed_labels
expr_stmt|;
name|p
operator|->
name|returns_value
operator|=
name|current_function_returns_value
expr_stmt|;
name|p
operator|->
name|returns_null
operator|=
name|current_function_returns_null
expr_stmt|;
name|p
operator|->
name|returns_abnormally
operator|=
name|current_function_returns_abnormally
expr_stmt|;
name|p
operator|->
name|warn_about_return_type
operator|=
name|warn_about_return_type
expr_stmt|;
name|p
operator|->
name|extern_inline
operator|=
name|current_extern_inline
expr_stmt|;
name|p
operator|->
name|binding_level
operator|=
name|current_binding_level
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Restore the variables used during compilation of a C function.  */
end_comment

begin_function
name|void
name|c_pop_function_context
parameter_list|(
name|f
parameter_list|)
name|struct
name|function
modifier|*
name|f
decl_stmt|;
block|{
name|struct
name|language_function
modifier|*
name|p
init|=
name|f
operator|->
name|language
decl_stmt|;
name|tree
name|link
decl_stmt|;
comment|/* Bring back all the labels that were shadowed.  */
for|for
control|(
name|link
operator|=
name|shadowed_labels
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
if|if
condition|(
name|DECL_NAME
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|IDENTIFIER_LABEL_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_SAVED_INSNS
argument_list|(
name|current_function_decl
argument_list|)
operator|==
literal|0
operator|&&
name|DECL_SAVED_TREE
argument_list|(
name|current_function_decl
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* Stop pointing to the local nodes about to be freed.  */
comment|/* But DECL_INITIAL must remain nonzero so we know this 	 was an actual function definition.  */
name|DECL_INITIAL
argument_list|(
name|current_function_decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|DECL_ARGUMENTS
argument_list|(
name|current_function_decl
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
name|c_stmt_tree
operator|=
name|p
operator|->
name|base
operator|.
name|x_stmt_tree
expr_stmt|;
name|c_scope_stmt_stack
operator|=
name|p
operator|->
name|base
operator|.
name|x_scope_stmt_stack
expr_stmt|;
name|named_labels
operator|=
name|p
operator|->
name|named_labels
expr_stmt|;
name|shadowed_labels
operator|=
name|p
operator|->
name|shadowed_labels
expr_stmt|;
name|current_function_returns_value
operator|=
name|p
operator|->
name|returns_value
expr_stmt|;
name|current_function_returns_null
operator|=
name|p
operator|->
name|returns_null
expr_stmt|;
name|current_function_returns_abnormally
operator|=
name|p
operator|->
name|returns_abnormally
expr_stmt|;
name|warn_about_return_type
operator|=
name|p
operator|->
name|warn_about_return_type
expr_stmt|;
name|current_extern_inline
operator|=
name|p
operator|->
name|extern_inline
expr_stmt|;
name|current_binding_level
operator|=
name|p
operator|->
name|binding_level
expr_stmt|;
name|f
operator|->
name|language
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy the DECL_LANG_SPECIFIC data associated with DECL.  */
end_comment

begin_function
name|void
name|c_dup_lang_specific_decl
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|struct
name|lang_decl
modifier|*
name|ld
decl_stmt|;
if|if
condition|(
operator|!
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
name|ld
operator|=
operator|(
expr|struct
name|lang_decl
operator|*
operator|)
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|lang_decl
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ld
argument_list|,
operator|(
name|char
operator|*
operator|)
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lang_decl
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
operator|=
name|ld
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The functions below are required for functionality of doing    function at once processing in the C front end. Currently these    functions are not called from anywhere in the C front end, but as    these changes continue, that will change.  */
end_comment

begin_comment
comment|/* Returns nonzero if the current statement is a full expression,    i.e. temporaries created during that statement should be destroyed    at the end of the statement.  */
end_comment

begin_function
name|int
name|stmts_are_full_exprs_p
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns the stmt_tree (if any) to which statements are currently    being added.  If there is no active statement-tree, NULL is    returned.  */
end_comment

begin_function
name|stmt_tree
name|current_stmt_tree
parameter_list|()
block|{
return|return
operator|&
name|c_stmt_tree
return|;
block|}
end_function

begin_comment
comment|/* Returns the stack of SCOPE_STMTs for the current function.  */
end_comment

begin_function
name|tree
modifier|*
name|current_scope_stmt_stack
parameter_list|()
block|{
return|return
operator|&
name|c_scope_stmt_stack
return|;
block|}
end_function

begin_comment
comment|/* Nonzero if TYPE is an anonymous union or struct type.  Always 0 in    C.  */
end_comment

begin_function
name|int
name|anon_aggr_type_p
parameter_list|(
name|node
parameter_list|)
name|tree
name|node
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Dummy function in place of callback used by C++.  */
end_comment

begin_function
name|void
name|extract_interface_info
parameter_list|()
block|{ }
end_function

begin_comment
comment|/* Return a new COMPOUND_STMT, after adding it to the current    statement tree.  */
end_comment

begin_function
name|tree
name|c_begin_compound_stmt
parameter_list|()
block|{
name|tree
name|stmt
decl_stmt|;
comment|/* Create the COMPOUND_STMT.  */
name|stmt
operator|=
name|add_stmt
argument_list|(
name|build_stmt
argument_list|(
name|COMPOUND_STMT
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|stmt
return|;
block|}
end_function

begin_comment
comment|/* Expand T (a DECL_STMT) if it declares an entity not handled by the    common code.  */
end_comment

begin_function
name|void
name|c_expand_decl_stmt
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|tree
name|decl
init|=
name|DECL_STMT_DECL
argument_list|(
name|t
argument_list|)
decl_stmt|;
comment|/* Expand nested functions.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|==
name|current_function_decl
operator|&&
name|DECL_SAVED_TREE
argument_list|(
name|decl
argument_list|)
condition|)
name|c_expand_body
argument_list|(
name|decl
argument_list|,
comment|/*nested_p=*/
literal|1
argument_list|,
comment|/*can_defer_p=*/
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the IDENTIFIER_GLOBAL_VALUE of T, for use in common code, since    the definition of IDENTIFIER_GLOBAL_VALUE is different for C and C++.  */
end_comment

begin_function
name|tree
name|identifier_global_value
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
return|return
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Record a builtin type for C.  If NAME is non-NULL, it is the name used;    otherwise the name is found in ridpointers from RID_INDEX.  */
end_comment

begin_function
name|void
name|record_builtin_type
parameter_list|(
name|rid_index
parameter_list|,
name|name
parameter_list|,
name|type
parameter_list|)
name|enum
name|rid
name|rid_index
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|id
decl_stmt|;
if|if
condition|(
name|name
operator|==
literal|0
condition|)
name|id
operator|=
name|ridpointers
index|[
operator|(
name|int
operator|)
name|rid_index
index|]
expr_stmt|;
else|else
name|id
operator|=
name|get_identifier
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|id
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Build the void_list_node (void_type_node having been created).  */
end_comment

begin_function
name|tree
name|build_void_list_node
parameter_list|()
block|{
name|tree
name|t
init|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|void_type_node
argument_list|)
decl_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Return something to represent absolute declarators containing a *.    TARGET is the absolute declarator that the * contains.    TYPE_QUALS_ATTRS is a list of modifiers such as const or volatile    to apply to the pointer type, represented as identifiers, possible mixed    with attributes.     We return an INDIRECT_REF whose "contents" are TARGET (inside a TREE_LIST,    if attributes are present) and whose type is the modifier list.  */
end_comment

begin_function
name|tree
name|make_pointer_declarator
parameter_list|(
name|type_quals_attrs
parameter_list|,
name|target
parameter_list|)
name|tree
name|type_quals_attrs
decl_stmt|,
name|target
decl_stmt|;
block|{
name|tree
name|quals
decl_stmt|,
name|attrs
decl_stmt|;
name|tree
name|itarget
init|=
name|target
decl_stmt|;
name|split_specs_attrs
argument_list|(
name|type_quals_attrs
argument_list|,
operator|&
name|quals
argument_list|,
operator|&
name|attrs
argument_list|)
expr_stmt|;
if|if
condition|(
name|attrs
operator|!=
name|NULL_TREE
condition|)
name|itarget
operator|=
name|tree_cons
argument_list|(
name|attrs
argument_list|,
name|target
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|quals
argument_list|,
name|itarget
argument_list|)
return|;
block|}
end_function

begin_include
include|#
directive|include
file|"gt-c-decl.h"
end_include

end_unit

