begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Process declarations and variables for C compiler.    Copyright (C) 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,    2001, 2002, 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/* Merged C99 inline changes from gcc trunk 122565 2007-03-05 */
end_comment

begin_comment
comment|/* Fixed problems with compiling inline-25.c and inline-26.c */
end_comment

begin_comment
comment|/* XXX still fails inline-29.c, inline-31.c, and inline-32.c */
end_comment

begin_comment
comment|/* Process declarations and symbol lookup for C front end.    Also constructs types; the standard scalar types at initialization,    and structure, union, array and enum types when they are declared.  */
end_comment

begin_comment
comment|/* ??? not all decl nodes are given the most useful possible    line numbers.  For example, the CONST_DECLs for enum values.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"input.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"intl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"tree-inline.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"c-tree.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"cpplib.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"debug.h"
end_include

begin_include
include|#
directive|include
file|"opts.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"c-common.h"
end_include

begin_include
include|#
directive|include
file|"c-pragma.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"tree-mudflap.h"
end_include

begin_include
include|#
directive|include
file|"tree-gimple.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"tree-dump.h"
end_include

begin_include
include|#
directive|include
file|"cgraph.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_include
include|#
directive|include
file|"libfuncs.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"langhooks-def.h"
end_include

begin_include
include|#
directive|include
file|"pointer-set.h"
end_include

begin_comment
comment|/* In grokdeclarator, distinguish syntactic contexts of declarators.  */
end_comment

begin_enum
enum|enum
name|decl_context
block|{
name|NORMAL
block|,
comment|/* Ordinary declaration */
name|FUNCDEF
block|,
comment|/* Function definition */
name|PARM
block|,
comment|/* Declaration of parm before function body */
name|FIELD
block|,
comment|/* Declaration inside struct or union */
name|TYPENAME
block|}
enum|;
end_enum

begin_comment
comment|/* Typename (inside cast or sizeof)  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Nonzero if we have seen an invalid cross reference    to a struct, union, or enum, but not yet printed the message.  */
end_comment

begin_decl_stmt
name|tree
name|pending_invalid_xref
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* File and line to appear in the eventual error message.  */
end_comment

begin_decl_stmt
name|location_t
name|pending_invalid_xref_location
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True means we've initialized exception handling.  */
end_comment

begin_decl_stmt
name|bool
name|c_eh_initialized_p
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* While defining an enum type, this is 1 plus the last enumerator    constant value.  Note that will do not have to save this or `enum_overflow'    around nested function definition since such a definition could only    occur in an enum value expression and we don't use these variables in    that case.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|enum_next_value
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means that there was overflow computing enum_next_value.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|enum_overflow
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The file and line that the prototype came from if this is an    old-style definition; used for diagnostics in    store_parm_decls_oldstyle.  */
end_comment

begin_decl_stmt
specifier|static
name|location_t
name|current_function_prototype_locus
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether this prototype was built-in.  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|current_function_prototype_built_in
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The argument type information of this prototype.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|current_function_prototype_arg_types
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The argument information structure for the function currently being    defined.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|c_arg_info
modifier|*
name|current_function_arg_info
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The obstack on which parser and related data structures, which are    not live beyond their top-level declaration or definition, are    allocated.  */
end_comment

begin_decl_stmt
name|struct
name|obstack
name|parser_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The current statement tree.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
expr|struct
name|stmt_tree_s
name|c_stmt_tree
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* State saving variables.  */
end_comment

begin_decl_stmt
name|tree
name|c_break_label
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|c_cont_label
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Linked list of TRANSLATION_UNIT_DECLS for the translation units    included in this invocation.  Note that the current translation    unit is not included in this list.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|all_translation_units
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* A list of decls to be made automatically visible in each file scope.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|visible_builtins
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Set to 0 at beginning of a function definition, set to 1 if    a return statement that specifies a return value is seen.  */
end_comment

begin_decl_stmt
name|int
name|current_function_returns_value
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to 0 at beginning of a function definition, set to 1 if    a return statement with no argument is seen.  */
end_comment

begin_decl_stmt
name|int
name|current_function_returns_null
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to 0 at beginning of a function definition, set to 1 if    a call to a noreturn function is seen.  */
end_comment

begin_decl_stmt
name|int
name|current_function_returns_abnormally
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to nonzero by `grokdeclarator' for a function    whose return type is defaulted, if warnings for this are desired.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|warn_about_return_type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero when the current toplevel function contains a declaration    of a nested function which is never defined.  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|undef_nested_function
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True means global_bindings_p should return false even if the scope stack    says we are in file scope.  */
end_comment

begin_decl_stmt
name|bool
name|c_override_global_bindings_to_false
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Each c_binding structure describes one binding of an identifier to    a decl.  All the decls in a scope - irrespective of namespace - are    chained together by the ->prev field, which (as the name implies)    runs in reverse order.  All the decls in a given namespace bound to    a given identifier are chained by the ->shadowed field, which runs    from inner to outer scopes.     The ->decl field usually points to a DECL node, but there are two    exceptions.  In the namespace of type tags, the bound entity is a    RECORD_TYPE, UNION_TYPE, or ENUMERAL_TYPE node.  If an undeclared    identifier is encountered, it is bound to error_mark_node to    suppress further errors about that identifier in the current    function.     The ->type field stores the type of the declaration in this scope;    if NULL, the type is the type of the ->decl field.  This is only of    relevance for objects with external or internal linkage which may    be redeclared in inner scopes, forming composite types that only    persist for the duration of those scopes.  In the external scope,    this stores the composite of all the types declared for this    object, visible or not.  The ->inner_comp field (used only at file    scope) stores whether an incomplete array type at file scope was    completed at an inner scope to an array size other than 1.     The depth field is copied from the scope structure that holds this    decl.  It is used to preserve the proper ordering of the ->shadowed    field (see bind()) and also for a handful of special-case checks.    Finally, the invisible bit is true for a decl which should be    ignored for purposes of normal name lookup, and the nested bit is    true for a decl that's been bound a second time in an inner scope;    in all such cases, the binding in the outer scope will have its    invisible bit true.  */
end_comment

begin_decl_stmt
name|struct
name|c_binding
name|GTY
argument_list|(
operator|(
name|chain_next
argument_list|(
literal|"%h.prev"
argument_list|)
operator|)
argument_list|)
block|{
name|tree
name|decl
decl_stmt|;
comment|/* the decl bound */
name|tree
name|type
decl_stmt|;
comment|/* the type in this scope */
name|tree
name|id
decl_stmt|;
comment|/* the identifier it's bound to */
name|struct
name|c_binding
modifier|*
name|prev
decl_stmt|;
comment|/* the previous decl in this scope */
name|struct
name|c_binding
modifier|*
name|shadowed
decl_stmt|;
comment|/* the innermost decl shadowed by this one */
name|unsigned
name|int
name|depth
range|:
literal|28
decl_stmt|;
comment|/* depth of this scope */
name|BOOL_BITFIELD
name|invisible
range|:
literal|1
decl_stmt|;
comment|/* normal lookup should ignore this binding */
name|BOOL_BITFIELD
name|nested
range|:
literal|1
decl_stmt|;
comment|/* do not set DECL_CONTEXT when popping */
name|BOOL_BITFIELD
name|inner_comp
range|:
literal|1
decl_stmt|;
comment|/* incomplete array completed in inner scope */
comment|/* one free bit */
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_define
define|#
directive|define
name|B_IN_SCOPE
parameter_list|(
name|b1
parameter_list|,
name|b2
parameter_list|)
value|((b1)->depth == (b2)->depth)
end_define

begin_define
define|#
directive|define
name|B_IN_CURRENT_SCOPE
parameter_list|(
name|b
parameter_list|)
value|((b)->depth == current_scope->depth)
end_define

begin_define
define|#
directive|define
name|B_IN_FILE_SCOPE
parameter_list|(
name|b
parameter_list|)
value|((b)->depth == 1
comment|/*file_scope->depth*/
value|)
end_define

begin_define
define|#
directive|define
name|B_IN_EXTERNAL_SCOPE
parameter_list|(
name|b
parameter_list|)
value|((b)->depth == 0
comment|/*external_scope->depth*/
value|)
end_define

begin_define
define|#
directive|define
name|I_SYMBOL_BINDING
parameter_list|(
name|node
parameter_list|)
define|\
value|(((struct lang_identifier *) IDENTIFIER_NODE_CHECK(node))->symbol_binding)
end_define

begin_define
define|#
directive|define
name|I_SYMBOL_DECL
parameter_list|(
name|node
parameter_list|)
define|\
value|(I_SYMBOL_BINDING(node) ? I_SYMBOL_BINDING(node)->decl : 0)
end_define

begin_define
define|#
directive|define
name|I_TAG_BINDING
parameter_list|(
name|node
parameter_list|)
define|\
value|(((struct lang_identifier *) IDENTIFIER_NODE_CHECK(node))->tag_binding)
end_define

begin_define
define|#
directive|define
name|I_TAG_DECL
parameter_list|(
name|node
parameter_list|)
define|\
value|(I_TAG_BINDING(node) ? I_TAG_BINDING(node)->decl : 0)
end_define

begin_define
define|#
directive|define
name|I_LABEL_BINDING
parameter_list|(
name|node
parameter_list|)
define|\
value|(((struct lang_identifier *) IDENTIFIER_NODE_CHECK(node))->label_binding)
end_define

begin_define
define|#
directive|define
name|I_LABEL_DECL
parameter_list|(
name|node
parameter_list|)
define|\
value|(I_LABEL_BINDING(node) ? I_LABEL_BINDING(node)->decl : 0)
end_define

begin_comment
comment|/* Each C symbol points to three linked lists of c_binding structures.    These describe the values of the identifier in the three different    namespaces defined by the language.  */
end_comment

begin_decl_stmt
name|struct
name|lang_identifier
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
name|struct
name|c_common_identifier
name|common_id
decl_stmt|;
name|struct
name|c_binding
modifier|*
name|symbol_binding
decl_stmt|;
comment|/* vars, funcs, constants, typedefs */
name|struct
name|c_binding
modifier|*
name|tag_binding
decl_stmt|;
comment|/* struct/union/enum tags */
name|struct
name|c_binding
modifier|*
name|label_binding
decl_stmt|;
comment|/* labels */
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* Validate c-lang.c's assumptions.  */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|C_SIZEOF_STRUCT_LANG_IDENTIFIER_isnt_accurate
index|[
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|lang_identifier
argument_list|)
operator|==
name|C_SIZEOF_STRUCT_LANG_IDENTIFIER
operator|)
condition|?
literal|1
else|:
operator|-
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The resulting tree type.  */
end_comment

begin_decl_stmt
name|union
name|lang_tree_node
name|GTY
argument_list|(
operator|(
name|desc
argument_list|(
literal|"TREE_CODE (&%h.generic) == IDENTIFIER_NODE"
argument_list|)
operator|,
name|chain_next
argument_list|(
literal|"TREE_CODE (&%h.generic) == INTEGER_TYPE ? (union lang_tree_node *) TYPE_NEXT_VARIANT (&%h.generic) : (union lang_tree_node *) TREE_CHAIN (&%h.generic)"
argument_list|)
operator|)
argument_list|)
block|{
name|union
name|tree_node
name|GTY
argument_list|(
operator|(
name|tag
argument_list|(
literal|"0"
argument_list|)
operator|,
name|desc
argument_list|(
literal|"tree_node_structure (&%h)"
argument_list|)
operator|)
argument_list|)
name|generic
decl_stmt|;
name|struct
name|lang_identifier
name|GTY
argument_list|(
operator|(
name|tag
argument_list|(
literal|"1"
argument_list|)
operator|)
argument_list|)
name|identifier
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* Each c_scope structure describes the complete contents of one    scope.  Four scopes are distinguished specially: the innermost or    current scope, the innermost function scope, the file scope (always    the second to outermost) and the outermost or external scope.     Most declarations are recorded in the current scope.     All normal label declarations are recorded in the innermost    function scope, as are bindings of undeclared identifiers to    error_mark_node.  (GCC permits nested functions as an extension,    hence the 'innermost' qualifier.)  Explicitly declared labels    (using the __label__ extension) appear in the current scope.     Being in the file scope (current_scope == file_scope) causes    special behavior in several places below.  Also, under some    conditions the Objective-C front end records declarations in the    file scope even though that isn't the current scope.     All declarations with external linkage are recorded in the external    scope, even if they aren't visible there; this models the fact that    such declarations are visible to the entire program, and (with a    bit of cleverness, see pushdecl) allows diagnosis of some violations    of C99 6.2.2p7 and 6.2.7p2:       If, within the same translation unit, the same identifier appears      with both internal and external linkage, the behavior is      undefined.       All declarations that refer to the same object or function shall      have compatible type; otherwise, the behavior is undefined.     Initially only the built-in declarations, which describe compiler    intrinsic functions plus a subset of the standard library, are in    this scope.     The order of the blocks list matters, and it is frequently appended    to.  To avoid having to walk all the way to the end of the list on    each insertion, or reverse the list later, we maintain a pointer to    the last list entry.  (FIXME: It should be feasible to use a reversed    list here.)     The bindings list is strictly in reverse order of declarations;    pop_scope relies on this.  */
end_comment

begin_decl_stmt
name|struct
name|c_scope
name|GTY
argument_list|(
operator|(
name|chain_next
argument_list|(
literal|"%h.outer"
argument_list|)
operator|)
argument_list|)
block|{
comment|/* The scope containing this one.  */
name|struct
name|c_scope
modifier|*
name|outer
decl_stmt|;
comment|/* The next outermost function scope.  */
name|struct
name|c_scope
modifier|*
name|outer_function
decl_stmt|;
comment|/* All bindings in this scope.  */
name|struct
name|c_binding
modifier|*
name|bindings
decl_stmt|;
comment|/* For each scope (except the global one), a chain of BLOCK nodes      for all the scopes that were entered and exited one level down.  */
name|tree
name|blocks
decl_stmt|;
name|tree
name|blocks_last
decl_stmt|;
comment|/* The depth of this scope.  Used to keep the ->shadowed chain of      bindings sorted innermost to outermost.  */
name|unsigned
name|int
name|depth
range|:
literal|28
decl_stmt|;
comment|/* True if we are currently filling this scope with parameter      declarations.  */
name|BOOL_BITFIELD
name|parm_flag
range|:
literal|1
decl_stmt|;
comment|/* True if we saw [*] in this scope.  Used to give an error messages      if these appears in a function definition.  */
name|BOOL_BITFIELD
name|had_vla_unspec
range|:
literal|1
decl_stmt|;
comment|/* True if we already complained about forward parameter decls      in this scope.  This prevents double warnings on      foo (int a; int b; ...)  */
name|BOOL_BITFIELD
name|warned_forward_parm_decls
range|:
literal|1
decl_stmt|;
comment|/* True if this is the outermost block scope of a function body.      This scope contains the parameters, the local variables declared      in the outermost block, and all the labels (except those in      nested functions, or declared at block scope with __label__).  */
name|BOOL_BITFIELD
name|function_body
range|:
literal|1
decl_stmt|;
comment|/* True means make a BLOCK for this scope no matter what.  */
name|BOOL_BITFIELD
name|keep
range|:
literal|1
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* The scope currently in effect.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
expr|struct
name|c_scope
operator|*
name|current_scope
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* The innermost function scope.  Ordinary (not explicitly declared)    labels, bindings to error_mark_node, and the lazily-created    bindings of __func__ and its friends get this scope.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
expr|struct
name|c_scope
operator|*
name|current_function_scope
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* The C file scope.  This is reset for each input translation unit.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
expr|struct
name|c_scope
operator|*
name|file_scope
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* The outermost scope.  This is used for all declarations with    external linkage, and only these, hence the name.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
expr|struct
name|c_scope
operator|*
name|external_scope
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* A chain of c_scope structures awaiting reuse.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|(deletable)
argument_list|)
expr|struct
name|c_scope
operator|*
name|scope_freelist
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* A chain of c_binding structures awaiting reuse.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|(deletable)
argument_list|)
expr|struct
name|c_binding
operator|*
name|binding_freelist
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Append VAR to LIST in scope SCOPE.  */
end_comment

begin_define
define|#
directive|define
name|SCOPE_LIST_APPEND
parameter_list|(
name|scope
parameter_list|,
name|list
parameter_list|,
name|decl
parameter_list|)
value|do {	\   struct c_scope *s_ = (scope);				\   tree d_ = (decl);					\   if (s_->list##_last)					\     TREE_CHAIN (s_->list##_last) = d_;			\   else							\     s_->list = d_;					\   s_->list##_last = d_;					\ } while (0)
end_define

begin_comment
comment|/* Concatenate FROM in scope FSCOPE onto TO in scope TSCOPE.  */
end_comment

begin_define
define|#
directive|define
name|SCOPE_LIST_CONCAT
parameter_list|(
name|tscope
parameter_list|,
name|to
parameter_list|,
name|fscope
parameter_list|,
name|from
parameter_list|)
value|do {	\   struct c_scope *t_ = (tscope);				\   struct c_scope *f_ = (fscope);				\   if (t_->to##_last)						\     TREE_CHAIN (t_->to##_last) = f_->from;			\   else								\     t_->to = f_->from;						\   t_->to##_last = f_->from##_last;				\ } while (0)
end_define

begin_comment
comment|/* True means unconditionally make a BLOCK for the next scope pushed.  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|keep_next_level_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True means the next call to push_scope will be the outermost scope    of a function body, so do not push a new scope, merely cease    expecting parameter decls.  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|next_is_function_body
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Functions called automatically at the beginning and end of execution.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|static_ctors
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|static_dtors
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Forward declarations.  */
end_comment

begin_function_decl
specifier|static
name|tree
name|lookup_name_in_scope
parameter_list|(
name|tree
parameter_list|,
name|struct
name|c_scope
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|c_make_fname_decl
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|grokdeclarator
parameter_list|(
specifier|const
name|struct
name|c_declarator
modifier|*
parameter_list|,
name|struct
name|c_declspecs
modifier|*
parameter_list|,
name|enum
name|decl_context
parameter_list|,
name|bool
parameter_list|,
name|tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|grokparms
parameter_list|(
name|struct
name|c_arg_info
modifier|*
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|layout_array_type
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* T is a statement.  Add it to the statement-tree.  This is the    C/ObjC version--C++ has a slightly different version of this    function.  */
end_comment

begin_function
name|tree
name|add_stmt
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|EXPR_P
argument_list|(
name|t
argument_list|)
operator|&&
name|code
operator|!=
name|LABEL_EXPR
condition|)
block|{
if|if
condition|(
operator|!
name|EXPR_HAS_LOCATION
argument_list|(
name|t
argument_list|)
condition|)
name|SET_EXPR_LOCATION
argument_list|(
name|t
argument_list|,
name|input_location
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|==
name|LABEL_EXPR
operator|||
name|code
operator|==
name|CASE_LABEL_EXPR
condition|)
name|STATEMENT_LIST_HAS_LABEL
argument_list|(
name|cur_stmt_list
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Add T to the statement-tree.  Non-side-effect statements need to be      recorded during statement expressions.  */
name|append_to_statement_list_force
argument_list|(
name|t
argument_list|,
operator|&
name|cur_stmt_list
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* States indicating how grokdeclarator() should handle declspecs marked    with __attribute__((deprecated)).  An object declared as    __attribute__((deprecated)) suppresses warnings of uses of other    deprecated items.  */
end_comment

begin_comment
comment|/* APPLE LOCAL begin "unavailable" attribute (radar 2809697) */
end_comment

begin_comment
comment|/* Also add an __attribute__((unavailable)).  An object declared as    __attribute__((unavailable)) suppresses any reports of being    declared with unavailable or deprecated items.  */
end_comment

begin_comment
comment|/* APPLE LOCAL end "unavailable" attribute (radar 2809697) */
end_comment

begin_enum
enum|enum
name|deprecated_states
block|{
name|DEPRECATED_NORMAL
block|,
name|DEPRECATED_SUPPRESS
comment|/* APPLE LOCAL "unavailable" attribute (radar 2809697) */
block|,
name|DEPRECATED_UNAVAILABLE_SUPPRESS
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
name|enum
name|deprecated_states
name|deprecated_state
init|=
name|DEPRECATED_NORMAL
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|c_print_identifier
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|tree
name|node
parameter_list|,
name|int
name|indent
parameter_list|)
block|{
name|print_node
argument_list|(
name|file
argument_list|,
literal|"symbol"
argument_list|,
name|I_SYMBOL_DECL
argument_list|(
name|node
argument_list|)
argument_list|,
name|indent
operator|+
literal|4
argument_list|)
expr_stmt|;
name|print_node
argument_list|(
name|file
argument_list|,
literal|"tag"
argument_list|,
name|I_TAG_DECL
argument_list|(
name|node
argument_list|)
argument_list|,
name|indent
operator|+
literal|4
argument_list|)
expr_stmt|;
name|print_node
argument_list|(
name|file
argument_list|,
literal|"label"
argument_list|,
name|I_LABEL_DECL
argument_list|(
name|node
argument_list|)
argument_list|,
name|indent
operator|+
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|C_IS_RESERVED_WORD
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|tree
name|rid
init|=
name|ridpointers
index|[
name|C_RID_CODE
argument_list|(
name|node
argument_list|)
index|]
decl_stmt|;
name|indent_to
argument_list|(
name|file
argument_list|,
name|indent
operator|+
literal|4
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"rid %p \"%s\""
argument_list|,
operator|(
name|void
operator|*
operator|)
name|rid
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|rid
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Establish a binding between NAME, an IDENTIFIER_NODE, and DECL,    which may be any of several kinds of DECL or TYPE or error_mark_node,    in the scope SCOPE.  */
end_comment

begin_function
specifier|static
name|void
name|bind
parameter_list|(
name|tree
name|name
parameter_list|,
name|tree
name|decl
parameter_list|,
name|struct
name|c_scope
modifier|*
name|scope
parameter_list|,
name|bool
name|invisible
parameter_list|,
name|bool
name|nested
parameter_list|)
block|{
name|struct
name|c_binding
modifier|*
name|b
decl_stmt|,
modifier|*
modifier|*
name|here
decl_stmt|;
if|if
condition|(
name|binding_freelist
condition|)
block|{
name|b
operator|=
name|binding_freelist
expr_stmt|;
name|binding_freelist
operator|=
name|b
operator|->
name|prev
expr_stmt|;
block|}
else|else
name|b
operator|=
name|GGC_NEW
argument_list|(
expr|struct
name|c_binding
argument_list|)
expr_stmt|;
name|b
operator|->
name|shadowed
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|decl
operator|=
name|decl
expr_stmt|;
name|b
operator|->
name|id
operator|=
name|name
expr_stmt|;
name|b
operator|->
name|depth
operator|=
name|scope
operator|->
name|depth
expr_stmt|;
name|b
operator|->
name|invisible
operator|=
name|invisible
expr_stmt|;
name|b
operator|->
name|nested
operator|=
name|nested
expr_stmt|;
name|b
operator|->
name|inner_comp
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|type
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|prev
operator|=
name|scope
operator|->
name|bindings
expr_stmt|;
name|scope
operator|->
name|bindings
operator|=
name|b
expr_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
return|return;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
case|case
name|LABEL_DECL
case|:
name|here
operator|=
operator|&
name|I_LABEL_BINDING
argument_list|(
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENUMERAL_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|RECORD_TYPE
case|:
name|here
operator|=
operator|&
name|I_TAG_BINDING
argument_list|(
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|VAR_DECL
case|:
case|case
name|FUNCTION_DECL
case|:
case|case
name|TYPE_DECL
case|:
case|case
name|CONST_DECL
case|:
case|case
name|PARM_DECL
case|:
case|case
name|ERROR_MARK
case|:
name|here
operator|=
operator|&
name|I_SYMBOL_BINDING
argument_list|(
name|name
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
comment|/* Locate the appropriate place in the chain of shadowed decls      to insert this binding.  Normally, scope == current_scope and      this does nothing.  */
while|while
condition|(
operator|*
name|here
operator|&&
operator|(
operator|*
name|here
operator|)
operator|->
name|depth
operator|>
name|scope
operator|->
name|depth
condition|)
name|here
operator|=
operator|&
operator|(
operator|*
name|here
operator|)
operator|->
name|shadowed
expr_stmt|;
name|b
operator|->
name|shadowed
operator|=
operator|*
name|here
expr_stmt|;
operator|*
name|here
operator|=
name|b
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clear the binding structure B, stick it on the binding_freelist,    and return the former value of b->prev.  This is used by pop_scope    and get_parm_info to iterate destructively over all the bindings    from a given scope.  */
end_comment

begin_function
specifier|static
name|struct
name|c_binding
modifier|*
name|free_binding_and_advance
parameter_list|(
name|struct
name|c_binding
modifier|*
name|b
parameter_list|)
block|{
name|struct
name|c_binding
modifier|*
name|prev
init|=
name|b
operator|->
name|prev
decl_stmt|;
name|memset
argument_list|(
name|b
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|c_binding
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|->
name|prev
operator|=
name|binding_freelist
expr_stmt|;
name|binding_freelist
operator|=
name|b
expr_stmt|;
return|return
name|prev
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Hook called at end of compilation to assume 1 elt    for a file-scope tentative array defn that wasn't complete before.  */
end_comment

begin_function
name|void
name|c_finish_incomplete_decl
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|!=
name|error_mark_node
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"array %q+D assumed to have one element"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|complete_array_type
argument_list|(
operator|&
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|layout_decl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The Objective-C front-end often needs to determine the current scope.  */
end_comment

begin_function
name|void
modifier|*
name|objc_get_current_scope
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|current_scope
return|;
block|}
end_function

begin_comment
comment|/* The following function is used only by Objective-C.  It needs to live here    because it accesses the innards of c_scope.  */
end_comment

begin_function
name|void
name|objc_mark_locals_volatile
parameter_list|(
name|void
modifier|*
name|enclosing_blk
parameter_list|)
block|{
name|struct
name|c_scope
modifier|*
name|scope
decl_stmt|;
name|struct
name|c_binding
modifier|*
name|b
decl_stmt|;
for|for
control|(
name|scope
operator|=
name|current_scope
init|;
name|scope
operator|&&
name|scope
operator|!=
name|enclosing_blk
condition|;
name|scope
operator|=
name|scope
operator|->
name|outer
control|)
block|{
for|for
control|(
name|b
operator|=
name|scope
operator|->
name|bindings
init|;
name|b
condition|;
name|b
operator|=
name|b
operator|->
name|prev
control|)
name|objc_volatilize_decl
argument_list|(
name|b
operator|->
name|decl
argument_list|)
expr_stmt|;
comment|/* Do not climb up past the current function.  */
if|if
condition|(
name|scope
operator|->
name|function_body
condition|)
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Nonzero if we are currently in file scope.  */
end_comment

begin_function
name|int
name|global_bindings_p
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|current_scope
operator|==
name|file_scope
operator|&&
operator|!
name|c_override_global_bindings_to_false
return|;
block|}
end_function

begin_function
name|void
name|keep_next_level
parameter_list|(
name|void
parameter_list|)
block|{
name|keep_next_level_flag
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Identify this scope as currently being filled with parameters.  */
end_comment

begin_function
name|void
name|declare_parm_level
parameter_list|(
name|void
parameter_list|)
block|{
name|current_scope
operator|->
name|parm_flag
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_function
name|void
name|push_scope
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|next_is_function_body
condition|)
block|{
comment|/* This is the transition from the parameters to the top level 	 of the function body.  These are the same scope 	 (C99 6.2.1p4,6) so we do not push another scope structure. 	 next_is_function_body is set only by store_parm_decls, which 	 in turn is called when and only when we are about to 	 encounter the opening curly brace for the function body.  	 The outermost block of a function always gets a BLOCK node, 	 because the debugging output routines expect that each 	 function has at least one BLOCK.  */
name|current_scope
operator|->
name|parm_flag
operator|=
name|false
expr_stmt|;
name|current_scope
operator|->
name|function_body
operator|=
name|true
expr_stmt|;
name|current_scope
operator|->
name|keep
operator|=
name|true
expr_stmt|;
name|current_scope
operator|->
name|outer_function
operator|=
name|current_function_scope
expr_stmt|;
name|current_function_scope
operator|=
name|current_scope
expr_stmt|;
name|keep_next_level_flag
operator|=
name|false
expr_stmt|;
name|next_is_function_body
operator|=
name|false
expr_stmt|;
block|}
else|else
block|{
name|struct
name|c_scope
modifier|*
name|scope
decl_stmt|;
if|if
condition|(
name|scope_freelist
condition|)
block|{
name|scope
operator|=
name|scope_freelist
expr_stmt|;
name|scope_freelist
operator|=
name|scope
operator|->
name|outer
expr_stmt|;
block|}
else|else
name|scope
operator|=
name|GGC_CNEW
argument_list|(
expr|struct
name|c_scope
argument_list|)
expr_stmt|;
name|scope
operator|->
name|keep
operator|=
name|keep_next_level_flag
expr_stmt|;
name|scope
operator|->
name|outer
operator|=
name|current_scope
expr_stmt|;
name|scope
operator|->
name|depth
operator|=
name|current_scope
condition|?
operator|(
name|current_scope
operator|->
name|depth
operator|+
literal|1
operator|)
else|:
literal|0
expr_stmt|;
comment|/* Check for scope depth overflow.  Unlikely (2^28 == 268,435,456) but 	 possible.  */
if|if
condition|(
name|current_scope
operator|&&
name|scope
operator|->
name|depth
operator|==
literal|0
condition|)
block|{
name|scope
operator|->
name|depth
operator|--
expr_stmt|;
name|sorry
argument_list|(
literal|"GCC supports only %u nested scopes"
argument_list|,
name|scope
operator|->
name|depth
argument_list|)
expr_stmt|;
block|}
name|current_scope
operator|=
name|scope
expr_stmt|;
name|keep_next_level_flag
operator|=
name|false
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Set the TYPE_CONTEXT of all of TYPE's variants to CONTEXT.  */
end_comment

begin_function
specifier|static
name|void
name|set_type_context
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|context
parameter_list|)
block|{
for|for
control|(
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
init|;
name|type
condition|;
name|type
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|type
argument_list|)
control|)
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
operator|=
name|context
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Exit a scope.  Restore the state of the identifier-decl mappings    that were in effect when this scope was entered.  Return a BLOCK    node containing all the DECLs in this scope that are of interest    to debug info generation.  */
end_comment

begin_function
name|tree
name|pop_scope
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|c_scope
modifier|*
name|scope
init|=
name|current_scope
decl_stmt|;
name|tree
name|block
decl_stmt|,
name|context
decl_stmt|,
name|p
decl_stmt|;
name|struct
name|c_binding
modifier|*
name|b
decl_stmt|;
name|bool
name|functionbody
init|=
name|scope
operator|->
name|function_body
decl_stmt|;
name|bool
name|keep
init|=
name|functionbody
operator|||
name|scope
operator|->
name|keep
operator|||
name|scope
operator|->
name|bindings
decl_stmt|;
name|c_end_vm_scope
argument_list|(
name|scope
operator|->
name|depth
argument_list|)
expr_stmt|;
comment|/* If appropriate, create a BLOCK to record the decls for the life      of this function.  */
name|block
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|keep
condition|)
block|{
name|block
operator|=
name|make_node
argument_list|(
name|BLOCK
argument_list|)
expr_stmt|;
name|BLOCK_SUBBLOCKS
argument_list|(
name|block
argument_list|)
operator|=
name|scope
operator|->
name|blocks
expr_stmt|;
name|TREE_USED
argument_list|(
name|block
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* In each subblock, record that this is its superior.  */
for|for
control|(
name|p
operator|=
name|scope
operator|->
name|blocks
init|;
name|p
condition|;
name|p
operator|=
name|TREE_CHAIN
argument_list|(
name|p
argument_list|)
control|)
name|BLOCK_SUPERCONTEXT
argument_list|(
name|p
argument_list|)
operator|=
name|block
expr_stmt|;
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
comment|/* The TYPE_CONTEXTs for all of the tagged types belonging to this      scope must be set so that they point to the appropriate      construct, i.e.  either to the current FUNCTION_DECL node, or      else to the BLOCK node we just constructed.       Note that for tagged types whose scope is just the formal      parameter list for some function type specification, we can't      properly set their TYPE_CONTEXTs here, because we don't have a      pointer to the appropriate FUNCTION_TYPE node readily available      to us.  For those cases, the TYPE_CONTEXTs of the relevant tagged      type nodes get set in `grokdeclarator' as soon as we have created      the FUNCTION_TYPE node which will represent the "scope" for these      "parameter list local" tagged types.  */
if|if
condition|(
name|scope
operator|->
name|function_body
condition|)
name|context
operator|=
name|current_function_decl
expr_stmt|;
elseif|else
if|if
condition|(
name|scope
operator|==
name|file_scope
condition|)
block|{
name|tree
name|file_decl
init|=
name|build_decl
argument_list|(
name|TRANSLATION_UNIT_DECL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|TREE_CHAIN
argument_list|(
name|file_decl
argument_list|)
operator|=
name|all_translation_units
expr_stmt|;
name|all_translation_units
operator|=
name|file_decl
expr_stmt|;
name|context
operator|=
name|file_decl
expr_stmt|;
block|}
else|else
name|context
operator|=
name|block
expr_stmt|;
comment|/* Clear all bindings in this scope.  */
for|for
control|(
name|b
operator|=
name|scope
operator|->
name|bindings
init|;
name|b
condition|;
name|b
operator|=
name|free_binding_and_advance
argument_list|(
name|b
argument_list|)
control|)
block|{
name|p
operator|=
name|b
operator|->
name|decl
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|p
argument_list|)
condition|)
block|{
case|case
name|LABEL_DECL
case|:
comment|/* Warnings for unused labels, errors for undefined labels.  */
if|if
condition|(
name|TREE_USED
argument_list|(
name|p
argument_list|)
operator|&&
operator|!
name|DECL_INITIAL
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"label %q+D used but not defined"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|p
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|TREE_USED
argument_list|(
name|p
argument_list|)
operator|&&
name|warn_unused_label
condition|)
block|{
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|p
argument_list|)
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"label %q+D defined but not used"
argument_list|,
name|p
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|0
argument_list|,
literal|"label %q+D declared but not defined"
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* Labels go in BLOCK_VARS.  */
name|TREE_CHAIN
argument_list|(
name|p
argument_list|)
operator|=
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
expr_stmt|;
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
operator|=
name|p
expr_stmt|;
name|gcc_assert
argument_list|(
name|I_LABEL_BINDING
argument_list|(
name|b
operator|->
name|id
argument_list|)
operator|==
name|b
argument_list|)
expr_stmt|;
name|I_LABEL_BINDING
argument_list|(
name|b
operator|->
name|id
argument_list|)
operator|=
name|b
operator|->
name|shadowed
expr_stmt|;
break|break;
case|case
name|ENUMERAL_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|RECORD_TYPE
case|:
name|set_type_context
argument_list|(
name|p
argument_list|,
name|context
argument_list|)
expr_stmt|;
comment|/* Types may not have tag-names, in which case the type 	     appears in the bindings list with b->id NULL.  */
if|if
condition|(
name|b
operator|->
name|id
condition|)
block|{
name|gcc_assert
argument_list|(
name|I_TAG_BINDING
argument_list|(
name|b
operator|->
name|id
argument_list|)
operator|==
name|b
argument_list|)
expr_stmt|;
name|I_TAG_BINDING
argument_list|(
name|b
operator|->
name|id
argument_list|)
operator|=
name|b
operator|->
name|shadowed
expr_stmt|;
block|}
break|break;
case|case
name|FUNCTION_DECL
case|:
comment|/* Propagate TREE_ADDRESSABLE from nested functions to their 	     containing functions.  */
if|if
condition|(
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|p
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|p
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_ADDRESSABLE
argument_list|(
name|p
argument_list|)
operator|&&
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|p
argument_list|)
operator|!=
literal|0
operator|&&
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|p
argument_list|)
operator|!=
name|p
condition|)
name|TREE_ADDRESSABLE
argument_list|(
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|p
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_EXTERNAL
argument_list|(
name|p
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|p
argument_list|)
operator|==
literal|0
operator|&&
name|scope
operator|!=
name|file_scope
operator|&&
name|scope
operator|!=
name|external_scope
condition|)
block|{
name|error
argument_list|(
literal|"nested function %q+D declared but never defined"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|undef_nested_function
operator|=
name|true
expr_stmt|;
block|}
comment|/* C99 6.7.4p6: "a function with external linkage... declared 	     with an inline function specifier ... shall also be defined in the 	     same translation unit."  */
elseif|else
if|if
condition|(
name|DECL_DECLARED_INLINE_P
argument_list|(
name|p
argument_list|)
operator|&&
name|TREE_PUBLIC
argument_list|(
name|p
argument_list|)
operator|&&
operator|!
name|DECL_INITIAL
argument_list|(
name|p
argument_list|)
operator|&&
operator|!
name|flag_gnu89_inline
condition|)
name|pedwarn
argument_list|(
literal|"inline function %q+D declared but never defined"
argument_list|,
name|p
argument_list|)
expr_stmt|;
goto|goto
name|common_symbol
goto|;
case|case
name|VAR_DECL
case|:
comment|/* Warnings for unused variables.  */
if|if
condition|(
operator|!
name|TREE_USED
argument_list|(
name|p
argument_list|)
operator|&&
operator|!
name|TREE_NO_WARNING
argument_list|(
name|p
argument_list|)
operator|&&
operator|!
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|p
argument_list|)
operator|&&
name|DECL_NAME
argument_list|(
name|p
argument_list|)
operator|&&
operator|!
name|DECL_ARTIFICIAL
argument_list|(
name|p
argument_list|)
operator|&&
name|scope
operator|!=
name|file_scope
operator|&&
name|scope
operator|!=
name|external_scope
condition|)
name|warning
argument_list|(
name|OPT_Wunused_variable
argument_list|,
literal|"unused variable %q+D"
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|inner_comp
condition|)
block|{
name|error
argument_list|(
literal|"type of array %q+D completed incompatibly with"
literal|" implicit initialization"
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* Fall through.  */
case|case
name|TYPE_DECL
case|:
case|case
name|CONST_DECL
case|:
name|common_symbol
label|:
comment|/* All of these go in BLOCK_VARS, but only if this is the 	     binding in the home scope.  */
if|if
condition|(
operator|!
name|b
operator|->
name|nested
condition|)
block|{
name|TREE_CHAIN
argument_list|(
name|p
argument_list|)
operator|=
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
expr_stmt|;
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
operator|=
name|p
expr_stmt|;
block|}
comment|/* If this is the file scope, and we are processing more 	     than one translation unit in this compilation, set 	     DECL_CONTEXT of each decl to the TRANSLATION_UNIT_DECL. 	     This makes same_translation_unit_p work, and causes 	     static declarations to be given disambiguating suffixes.  */
if|if
condition|(
name|scope
operator|==
name|file_scope
operator|&&
name|num_in_fnames
operator|>
literal|1
condition|)
block|{
name|DECL_CONTEXT
argument_list|(
name|p
argument_list|)
operator|=
name|context
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|set_type_context
argument_list|(
name|TREE_TYPE
argument_list|(
name|p
argument_list|)
argument_list|,
name|context
argument_list|)
expr_stmt|;
block|}
comment|/* Fall through.  */
comment|/* Parameters go in DECL_ARGUMENTS, not BLOCK_VARS, and have 	     already been put there by store_parm_decls.  Unused- 	     parameter warnings are handled by function.c. 	     error_mark_node obviously does not go in BLOCK_VARS and 	     does not get unused-variable warnings.  */
case|case
name|PARM_DECL
case|:
case|case
name|ERROR_MARK
case|:
comment|/* It is possible for a decl not to have a name.  We get 	     here with b->id NULL in this case.  */
if|if
condition|(
name|b
operator|->
name|id
condition|)
block|{
name|gcc_assert
argument_list|(
name|I_SYMBOL_BINDING
argument_list|(
name|b
operator|->
name|id
argument_list|)
operator|==
name|b
argument_list|)
expr_stmt|;
name|I_SYMBOL_BINDING
argument_list|(
name|b
operator|->
name|id
argument_list|)
operator|=
name|b
operator|->
name|shadowed
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|shadowed
operator|&&
name|b
operator|->
name|shadowed
operator|->
name|type
condition|)
name|TREE_TYPE
argument_list|(
name|b
operator|->
name|shadowed
operator|->
name|decl
argument_list|)
operator|=
name|b
operator|->
name|shadowed
operator|->
name|type
expr_stmt|;
block|}
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Dispose of the block that we just made inside some higher level.  */
if|if
condition|(
operator|(
name|scope
operator|->
name|function_body
operator|||
name|scope
operator|==
name|file_scope
operator|)
operator|&&
name|context
condition|)
block|{
name|DECL_INITIAL
argument_list|(
name|context
argument_list|)
operator|=
name|block
expr_stmt|;
name|BLOCK_SUPERCONTEXT
argument_list|(
name|block
argument_list|)
operator|=
name|context
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scope
operator|->
name|outer
condition|)
block|{
if|if
condition|(
name|block
condition|)
name|SCOPE_LIST_APPEND
argument_list|(
name|scope
operator|->
name|outer
argument_list|,
name|blocks
argument_list|,
name|block
argument_list|)
expr_stmt|;
comment|/* If we did not make a block for the scope just exited, any 	 blocks made for inner scopes must be carried forward so they 	 will later become subblocks of something else.  */
elseif|else
if|if
condition|(
name|scope
operator|->
name|blocks
condition|)
name|SCOPE_LIST_CONCAT
argument_list|(
name|scope
operator|->
name|outer
argument_list|,
name|blocks
argument_list|,
name|scope
argument_list|,
name|blocks
argument_list|)
expr_stmt|;
block|}
comment|/* Pop the current scope, and free the structure for reuse.  */
name|current_scope
operator|=
name|scope
operator|->
name|outer
expr_stmt|;
if|if
condition|(
name|scope
operator|->
name|function_body
condition|)
name|current_function_scope
operator|=
name|scope
operator|->
name|outer_function
expr_stmt|;
name|memset
argument_list|(
name|scope
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|c_scope
argument_list|)
argument_list|)
expr_stmt|;
name|scope
operator|->
name|outer
operator|=
name|scope_freelist
expr_stmt|;
name|scope_freelist
operator|=
name|scope
expr_stmt|;
return|return
name|block
return|;
block|}
end_function

begin_function
name|void
name|push_file_scope
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|;
if|if
condition|(
name|file_scope
condition|)
return|return;
name|push_scope
argument_list|()
expr_stmt|;
name|file_scope
operator|=
name|current_scope
expr_stmt|;
name|start_fname_decls
argument_list|()
expr_stmt|;
for|for
control|(
name|decl
operator|=
name|visible_builtins
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
name|bind
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
name|decl
argument_list|,
name|file_scope
argument_list|,
comment|/*invisible=*/
name|false
argument_list|,
comment|/*nested=*/
name|true
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pop_file_scope
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* In case there were missing closebraces, get us back to the global      binding level.  */
while|while
condition|(
name|current_scope
operator|!=
name|file_scope
condition|)
name|pop_scope
argument_list|()
expr_stmt|;
comment|/* __FUNCTION__ is defined at file scope ("").  This      call may not be necessary as my tests indicate it      still works without it.  */
name|finish_fname_decls
argument_list|()
expr_stmt|;
comment|/* This is the point to write out a PCH if we're doing that.      In that case we do not want to do anything else.  */
if|if
condition|(
name|pch_file
condition|)
block|{
name|c_common_write_pch
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* Pop off the file scope and close this translation unit.  */
name|pop_scope
argument_list|()
expr_stmt|;
name|file_scope
operator|=
literal|0
expr_stmt|;
name|maybe_apply_pending_pragma_weaks
argument_list|()
expr_stmt|;
name|cgraph_finalize_compilation_unit
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Insert BLOCK at the end of the list of subblocks of the current    scope.  This is used when a BIND_EXPR is expanded, to handle the    BLOCK node inside the BIND_EXPR.  */
end_comment

begin_function
name|void
name|insert_block
parameter_list|(
name|tree
name|block
parameter_list|)
block|{
name|TREE_USED
argument_list|(
name|block
argument_list|)
operator|=
literal|1
expr_stmt|;
name|SCOPE_LIST_APPEND
argument_list|(
name|current_scope
argument_list|,
name|blocks
argument_list|,
name|block
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Push a definition or a declaration of struct, union or enum tag "name".    "type" should be the type node.    We assume that the tag "name" is not already defined.     Note that the definition may really be just a forward reference.    In that case, the TYPE_SIZE will be zero.  */
end_comment

begin_function
specifier|static
name|void
name|pushtag
parameter_list|(
name|tree
name|name
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
comment|/* Record the identifier as the type's name if it has none.  */
if|if
condition|(
name|name
operator|&&
operator|!
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
condition|)
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|=
name|name
expr_stmt|;
name|bind
argument_list|(
name|name
argument_list|,
name|type
argument_list|,
name|current_scope
argument_list|,
comment|/*invisible=*/
name|false
argument_list|,
comment|/*nested=*/
name|false
argument_list|)
expr_stmt|;
comment|/* Create a fake NULL-named TYPE_DECL node whose TREE_TYPE will be the      tagged type we just added to the current scope.  This fake      NULL-named TYPE_DECL node helps dwarfout.c to know when it needs      to output a representation of a tagged type, and it also gives      us a convenient place to record the "scope start" address for the      tagged type.  */
name|TYPE_STUB_DECL
argument_list|(
name|type
argument_list|)
operator|=
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* An approximation for now, so we can tell this is a function-scope tag.      This will be updated in pop_scope.  */
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
operator|=
name|DECL_CONTEXT
argument_list|(
name|TYPE_STUB_DECL
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutine of compare_decls.  Allow harmless mismatches in return    and argument types provided that the type modes match.  This function    return a unified type given a suitable match, and 0 otherwise.  */
end_comment

begin_function
specifier|static
name|tree
name|match_builtin_function_types
parameter_list|(
name|tree
name|newtype
parameter_list|,
name|tree
name|oldtype
parameter_list|)
block|{
name|tree
name|newrettype
decl_stmt|,
name|oldrettype
decl_stmt|;
name|tree
name|newargs
decl_stmt|,
name|oldargs
decl_stmt|;
name|tree
name|trytype
decl_stmt|,
name|tryargs
decl_stmt|;
comment|/* Accept the return type of the new declaration if same modes.  */
name|oldrettype
operator|=
name|TREE_TYPE
argument_list|(
name|oldtype
argument_list|)
expr_stmt|;
name|newrettype
operator|=
name|TREE_TYPE
argument_list|(
name|newtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|oldrettype
argument_list|)
operator|!=
name|TYPE_MODE
argument_list|(
name|newrettype
argument_list|)
condition|)
return|return
literal|0
return|;
name|oldargs
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|oldtype
argument_list|)
expr_stmt|;
name|newargs
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|newtype
argument_list|)
expr_stmt|;
name|tryargs
operator|=
name|newargs
expr_stmt|;
while|while
condition|(
name|oldargs
operator|||
name|newargs
condition|)
block|{
if|if
condition|(
operator|!
name|oldargs
operator|||
operator|!
name|newargs
operator|||
operator|!
name|TREE_VALUE
argument_list|(
name|oldargs
argument_list|)
operator|||
operator|!
name|TREE_VALUE
argument_list|(
name|newargs
argument_list|)
operator|||
name|TYPE_MODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|oldargs
argument_list|)
argument_list|)
operator|!=
name|TYPE_MODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|newargs
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|oldargs
operator|=
name|TREE_CHAIN
argument_list|(
name|oldargs
argument_list|)
expr_stmt|;
name|newargs
operator|=
name|TREE_CHAIN
argument_list|(
name|newargs
argument_list|)
expr_stmt|;
block|}
name|trytype
operator|=
name|build_function_type
argument_list|(
name|newrettype
argument_list|,
name|tryargs
argument_list|)
expr_stmt|;
return|return
name|build_type_attribute_variant
argument_list|(
name|trytype
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|oldtype
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of diagnose_mismatched_decls.  Check for function type    mismatch involving an empty arglist vs a nonempty one and give clearer    diagnostics.  */
end_comment

begin_function
specifier|static
name|void
name|diagnose_arglist_conflict
parameter_list|(
name|tree
name|newdecl
parameter_list|,
name|tree
name|olddecl
parameter_list|,
name|tree
name|newtype
parameter_list|,
name|tree
name|oldtype
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|||
operator|!
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|oldtype
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|newtype
argument_list|)
argument_list|)
operator|||
operator|!
operator|(
operator|(
name|TYPE_ARG_TYPES
argument_list|(
name|oldtype
argument_list|)
operator|==
literal|0
operator|&&
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|TYPE_ARG_TYPES
argument_list|(
name|newtype
argument_list|)
operator|==
literal|0
operator|&&
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
return|return;
name|t
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|oldtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
literal|0
condition|)
name|t
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|newtype
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|tree
name|type
init|=
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|==
literal|0
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|!=
name|void_type_node
condition|)
block|{
name|inform
argument_list|(
literal|"a parameter list with an ellipsis can%'t match "
literal|"an empty parameter name list declaration"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|c_type_promotes_to
argument_list|(
name|type
argument_list|)
operator|!=
name|type
condition|)
block|{
name|inform
argument_list|(
literal|"an argument type that has a default promotion can%'t match "
literal|"an empty parameter name list declaration"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Another subroutine of diagnose_mismatched_decls.  OLDDECL is an    old-style function definition, NEWDECL is a prototype declaration.    Diagnose inconsistencies in the argument list.  Returns TRUE if    the prototype is compatible, FALSE if not.  */
end_comment

begin_function
specifier|static
name|bool
name|validate_proto_after_old_defn
parameter_list|(
name|tree
name|newdecl
parameter_list|,
name|tree
name|newtype
parameter_list|,
name|tree
name|oldtype
parameter_list|)
block|{
name|tree
name|newargs
decl_stmt|,
name|oldargs
decl_stmt|;
name|int
name|i
decl_stmt|;
define|#
directive|define
name|END_OF_ARGLIST
parameter_list|(
name|t
parameter_list|)
value|((t) == void_type_node)
name|oldargs
operator|=
name|TYPE_ACTUAL_ARG_TYPES
argument_list|(
name|oldtype
argument_list|)
expr_stmt|;
name|newargs
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|newtype
argument_list|)
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|tree
name|oldargtype
init|=
name|TREE_VALUE
argument_list|(
name|oldargs
argument_list|)
decl_stmt|;
name|tree
name|newargtype
init|=
name|TREE_VALUE
argument_list|(
name|newargs
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldargtype
operator|==
name|error_mark_node
operator|||
name|newargtype
operator|==
name|error_mark_node
condition|)
return|return
name|false
return|;
name|oldargtype
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|oldargtype
argument_list|)
expr_stmt|;
name|newargtype
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|newargtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|END_OF_ARGLIST
argument_list|(
name|oldargtype
argument_list|)
operator|&&
name|END_OF_ARGLIST
argument_list|(
name|newargtype
argument_list|)
condition|)
break|break;
comment|/* Reaching the end of just one list means the two decls don't 	 agree on the number of arguments.  */
if|if
condition|(
name|END_OF_ARGLIST
argument_list|(
name|oldargtype
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"prototype for %q+D declares more arguments "
literal|"than previous old-style definition"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
elseif|else
if|if
condition|(
name|END_OF_ARGLIST
argument_list|(
name|newargtype
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"prototype for %q+D declares fewer arguments "
literal|"than previous old-style definition"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* Type for passing arg must be consistent with that declared 	 for the arg.  */
elseif|else
if|if
condition|(
operator|!
name|comptypes
argument_list|(
name|oldargtype
argument_list|,
name|newargtype
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"prototype for %q+D declares argument %d"
literal|" with incompatible type"
argument_list|,
name|newdecl
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|oldargs
operator|=
name|TREE_CHAIN
argument_list|(
name|oldargs
argument_list|)
expr_stmt|;
name|newargs
operator|=
name|TREE_CHAIN
argument_list|(
name|newargs
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
comment|/* If we get here, no errors were found, but do issue a warning      for this poor-style construct.  */
name|warning
argument_list|(
literal|0
argument_list|,
literal|"prototype for %q+D follows non-prototype definition"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
return|return
name|true
return|;
undef|#
directive|undef
name|END_OF_ARGLIST
block|}
end_function

begin_comment
comment|/* Subroutine of diagnose_mismatched_decls.  Report the location of DECL,    first in a pair of mismatched declarations, using the diagnostic    function DIAG.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|locate_old_decl
argument_list|(
name|tree
name|decl
argument_list|,
name|void
argument_list|(
argument|*diag
argument_list|)
operator|(
specifier|const
name|char
operator|*
operator|,
operator|...
operator|)
name|ATTRIBUTE_GCC_CDIAG
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
argument_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_BUILT_IN
argument_list|(
name|decl
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
condition|)
name|diag
argument_list|(
name|G_
argument_list|(
literal|"previous definition of %q+D was here"
argument_list|)
argument_list|,
name|decl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|C_DECL_IMPLICIT
argument_list|(
name|decl
argument_list|)
condition|)
name|diag
argument_list|(
name|G_
argument_list|(
literal|"previous implicit declaration of %q+D was here"
argument_list|)
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|else
name|diag
argument_list|(
name|G_
argument_list|(
literal|"previous declaration of %q+D was here"
argument_list|)
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Subroutine of duplicate_decls.  Compare NEWDECL to OLDDECL.    Returns true if the caller should proceed to merge the two, false    if OLDDECL should simply be discarded.  As a side effect, issues    all necessary diagnostics for invalid or poor-style combinations.    If it returns true, writes the types of NEWDECL and OLDDECL to    *NEWTYPEP and *OLDTYPEP - these may have been adjusted from    TREE_TYPE (NEWDECL, OLDDECL) respectively.  */
end_comment

begin_function
specifier|static
name|bool
name|diagnose_mismatched_decls
parameter_list|(
name|tree
name|newdecl
parameter_list|,
name|tree
name|olddecl
parameter_list|,
name|tree
modifier|*
name|newtypep
parameter_list|,
name|tree
modifier|*
name|oldtypep
parameter_list|)
block|{
name|tree
name|newtype
decl_stmt|,
name|oldtype
decl_stmt|;
name|bool
name|pedwarned
init|=
name|false
decl_stmt|;
name|bool
name|warned
init|=
name|false
decl_stmt|;
name|bool
name|retval
init|=
name|true
decl_stmt|;
define|#
directive|define
name|DECL_EXTERN_INLINE
parameter_list|(
name|DECL
parameter_list|)
value|(DECL_DECLARED_INLINE_P (DECL)  \&& DECL_EXTERNAL (DECL))
comment|/* If we have error_mark_node for either decl or type, just discard      the previous decl - we're in an error cascade already.  */
if|if
condition|(
name|olddecl
operator|==
name|error_mark_node
operator|||
name|newdecl
operator|==
name|error_mark_node
condition|)
return|return
name|false
return|;
operator|*
name|oldtypep
operator|=
name|oldtype
operator|=
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
operator|*
name|newtypep
operator|=
name|newtype
operator|=
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldtype
operator|==
name|error_mark_node
operator|||
name|newtype
operator|==
name|error_mark_node
condition|)
return|return
name|false
return|;
comment|/* Two different categories of symbol altogether.  This is an error      unless OLDDECL is a builtin.  OLDDECL will be discarded in any case.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_BUILT_IN
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|!
name|C_DECL_DECLARED_BUILTIN
argument_list|(
name|olddecl
argument_list|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"%q+D redeclared as different kind of symbol"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|locate_old_decl
argument_list|(
name|olddecl
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|newdecl
argument_list|)
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"built-in function %q+D declared as non-function"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
name|OPT_Wshadow
argument_list|,
literal|"declaration of %q+D shadows "
literal|"a built-in function"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* Enumerators have no linkage, so may only be declared once in a      given scope.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|CONST_DECL
condition|)
block|{
name|error
argument_list|(
literal|"redeclaration of enumerator %q+D"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|locate_old_decl
argument_list|(
name|olddecl
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|comptypes
argument_list|(
name|oldtype
argument_list|,
name|newtype
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_BUILT_IN
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|!
name|C_DECL_DECLARED_BUILTIN
argument_list|(
name|olddecl
argument_list|)
condition|)
block|{
comment|/* Accept harmless mismatch in function types. 	     This is for the ffs and fprintf builtins.  */
name|tree
name|trytype
init|=
name|match_builtin_function_types
argument_list|(
name|newtype
argument_list|,
name|oldtype
argument_list|)
decl_stmt|;
if|if
condition|(
name|trytype
operator|&&
name|comptypes
argument_list|(
name|newtype
argument_list|,
name|trytype
argument_list|)
condition|)
operator|*
name|oldtypep
operator|=
name|oldtype
operator|=
name|trytype
expr_stmt|;
else|else
block|{
comment|/* If types don't match for a built-in, throw away the 		 built-in.  No point in calling locate_old_decl here, it 		 won't print anything.  */
name|warning
argument_list|(
literal|0
argument_list|,
literal|"conflicting types for built-in function %q+D"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_IS_BUILTIN
argument_list|(
name|olddecl
argument_list|)
condition|)
block|{
comment|/* A conflicting function declaration for a predeclared 	     function that isn't actually built in.  Objective C uses 	     these.  The new declaration silently overrides everything 	     but the volatility (i.e. noreturn) indication.  See also 	     below.  FIXME: Make Objective C use normal builtins.  */
name|TREE_THIS_VOLATILE
argument_list|(
name|newdecl
argument_list|)
operator||=
name|TREE_THIS_VOLATILE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* Permit void foo (...) to match int foo (...) if the latter is 	 the definition and implicit int was used.  See 	 c-torture/compile/920625-2.c.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|oldtype
argument_list|)
argument_list|)
operator|==
name|void_type_node
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|newtype
argument_list|)
argument_list|)
operator|==
name|integer_type_node
operator|&&
name|C_FUNCTION_IMPLICIT_INT
argument_list|(
name|newdecl
argument_list|)
operator|&&
operator|!
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
condition|)
block|{
name|pedwarn
argument_list|(
literal|"conflicting types for %q+D"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
comment|/* Make sure we keep void as the return type.  */
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
operator|=
operator|*
name|newtypep
operator|=
name|newtype
operator|=
name|oldtype
expr_stmt|;
name|C_FUNCTION_IMPLICIT_INT
argument_list|(
name|newdecl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|pedwarned
operator|=
name|true
expr_stmt|;
block|}
comment|/* Permit void foo (...) to match an earlier call to foo (...) with 	 no declared type (thus, implicitly int).  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|newtype
argument_list|)
argument_list|)
operator|==
name|void_type_node
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|oldtype
argument_list|)
argument_list|)
operator|==
name|integer_type_node
operator|&&
name|C_DECL_IMPLICIT
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|!
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
condition|)
block|{
name|pedwarn
argument_list|(
literal|"conflicting types for %q+D"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
comment|/* Make sure we keep void as the return type.  */
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
operator|=
operator|*
name|oldtypep
operator|=
name|oldtype
operator|=
name|newtype
expr_stmt|;
name|pedwarned
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|TYPE_QUALS
argument_list|(
name|newtype
argument_list|)
operator|!=
name|TYPE_QUALS
argument_list|(
name|oldtype
argument_list|)
condition|)
name|error
argument_list|(
literal|"conflicting type qualifiers for %q+D"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"conflicting types for %q+D"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|diagnose_arglist_conflict
argument_list|(
name|newdecl
argument_list|,
name|olddecl
argument_list|,
name|newtype
argument_list|,
name|oldtype
argument_list|)
expr_stmt|;
name|locate_old_decl
argument_list|(
name|olddecl
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
comment|/* Redeclaration of a type is a constraint violation (6.7.2.3p1),      but silently ignore the redeclaration if either is in a system      header.  (Conflicting redeclarations were handled above.)  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
if|if
condition|(
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|newdecl
argument_list|)
operator|||
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|olddecl
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* Allow OLDDECL to continue in use.  */
name|error
argument_list|(
literal|"redefinition of typedef %q+D"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|locate_old_decl
argument_list|(
name|olddecl
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* Function declarations can either be 'static' or 'extern' (no      qualifier is equivalent to 'extern' - C99 6.2.2p5) and therefore      can never conflict with each other on account of linkage      (6.2.2p4).  Multiple definitions are not allowed (6.9p3,5) but      gnu89 mode permits two definitions if one is 'extern inline' and      one is not.  The non- extern-inline definition supersedes the      extern-inline definition.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
comment|/* If you declare a built-in function name as static, or 	 define the built-in with an old-style definition (so we 	 can't validate the argument list) the built-in definition is 	 overridden, but optionally warn this was a bad choice of name.  */
if|if
condition|(
name|DECL_BUILT_IN
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|!
name|C_DECL_DECLARED_BUILTIN
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|(
operator|!
name|TREE_PUBLIC
argument_list|(
name|newdecl
argument_list|)
operator|||
operator|(
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|&&
operator|!
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
block|{
name|warning
argument_list|(
name|OPT_Wshadow
argument_list|,
literal|"declaration of %q+D shadows "
literal|"a built-in function"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
comment|/* Discard the old built-in function.  */
return|return
name|false
return|;
block|}
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
condition|)
block|{
comment|/* If both decls are in the same TU and the new declaration 		 isn't overriding an extern inline reject the new decl. 		 In c99, no overriding is allowed in the same translation 		 unit.  */
if|if
condition|(
operator|(
operator|!
name|DECL_EXTERN_INLINE
argument_list|(
name|olddecl
argument_list|)
operator|||
name|DECL_EXTERN_INLINE
argument_list|(
name|newdecl
argument_list|)
operator|||
operator|(
operator|!
name|flag_gnu89_inline
operator|&&
operator|(
operator|!
name|DECL_DECLARED_INLINE_P
argument_list|(
name|olddecl
argument_list|)
operator|||
operator|!
name|lookup_attribute
argument_list|(
literal|"gnu_inline"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|olddecl
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|DECL_DECLARED_INLINE_P
argument_list|(
name|newdecl
argument_list|)
operator|||
operator|!
name|lookup_attribute
argument_list|(
literal|"gnu_inline"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|newdecl
argument_list|)
argument_list|)
operator|)
operator|)
operator|)
operator|&&
name|same_translation_unit_p
argument_list|(
name|newdecl
argument_list|,
name|olddecl
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"redefinition of %q+D"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|locate_old_decl
argument_list|(
name|olddecl
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
block|}
comment|/* If we have a prototype after an old-style function definition, 	 the argument types must be checked specially.  */
elseif|else
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|!
name|TYPE_ARG_TYPES
argument_list|(
name|oldtype
argument_list|)
operator|&&
name|TYPE_ARG_TYPES
argument_list|(
name|newtype
argument_list|)
operator|&&
name|TYPE_ACTUAL_ARG_TYPES
argument_list|(
name|oldtype
argument_list|)
operator|&&
operator|!
name|validate_proto_after_old_defn
argument_list|(
name|newdecl
argument_list|,
name|newtype
argument_list|,
name|oldtype
argument_list|)
condition|)
block|{
name|locate_old_decl
argument_list|(
name|olddecl
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* A non-static declaration (even an "extern") followed by a 	 static declaration is undefined behavior per C99 6.2.2p3-5,7. 	 The same is true for a static forward declaration at block 	 scope followed by a non-static declaration/definition at file 	 scope.  Static followed by non-static at the same scope is 	 not undefined behavior, and is the most convenient way to get 	 some effects (see e.g.  what unwind-dw2-fde-glibc.c does to 	 the definition of _Unwind_Find_FDE in unwind-dw2-fde.c), but 	 we do diagnose it if -Wtraditional.  */
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|!
name|TREE_PUBLIC
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
comment|/* Two exceptions to the rule.  If olddecl is an extern 	     inline, or a predeclared function that isn't actually 	     built in, newdecl silently overrides olddecl.  The latter 	     occur only in Objective C; see also above.  (FIXME: Make 	     Objective C use normal builtins.)  */
if|if
condition|(
operator|!
name|DECL_IS_BUILTIN
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|!
name|DECL_EXTERN_INLINE
argument_list|(
name|olddecl
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"static declaration of %q+D follows "
literal|"non-static declaration"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|locate_old_decl
argument_list|(
name|olddecl
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|newdecl
argument_list|)
operator|&&
operator|!
name|TREE_PUBLIC
argument_list|(
name|olddecl
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|olddecl
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"non-static declaration of %q+D follows "
literal|"static declaration"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|locate_old_decl
argument_list|(
name|olddecl
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
elseif|else
if|if
condition|(
name|warn_traditional
condition|)
block|{
name|warning
argument_list|(
name|OPT_Wtraditional
argument_list|,
literal|"non-static declaration of %q+D "
literal|"follows static declaration"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|warned
operator|=
name|true
expr_stmt|;
block|}
block|}
comment|/* Make sure gnu_inline attribute is either not present, or 	 present on all inline decls.  */
if|if
condition|(
name|DECL_DECLARED_INLINE_P
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|DECL_DECLARED_INLINE_P
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
name|bool
name|newa
init|=
name|lookup_attribute
argument_list|(
literal|"gnu_inline"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|newdecl
argument_list|)
argument_list|)
operator|!=
name|NULL
decl_stmt|;
name|bool
name|olda
init|=
name|lookup_attribute
argument_list|(
literal|"gnu_inline"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|olddecl
argument_list|)
argument_list|)
operator|!=
name|NULL
decl_stmt|;
if|if
condition|(
name|newa
operator|!=
name|olda
condition|)
block|{
name|error
argument_list|(
literal|"%<gnu_inline%> attribute present on %q+D"
argument_list|,
name|newa
condition|?
name|newdecl
else|:
name|olddecl
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"%Jbut not here"
argument_list|,
name|newa
condition|?
name|olddecl
else|:
name|newdecl
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
comment|/* Only variables can be thread-local, and all declarations must 	 agree on this property.  */
if|if
condition|(
name|C_DECL_THREADPRIVATE_P
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|!
name|DECL_THREAD_LOCAL_P
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
comment|/* Nothing to check.  Since OLDDECL is marked threadprivate 	     and NEWDECL does not have a thread-local attribute, we 	     will merge the threadprivate attribute into NEWDECL.  */
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_THREAD_LOCAL_P
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|DECL_THREAD_LOCAL_P
argument_list|(
name|olddecl
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_THREAD_LOCAL_P
argument_list|(
name|newdecl
argument_list|)
condition|)
name|error
argument_list|(
literal|"thread-local declaration of %q+D follows "
literal|"non-thread-local declaration"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"non-thread-local declaration of %q+D follows "
literal|"thread-local declaration"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|locate_old_decl
argument_list|(
name|olddecl
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* Multiple initialized definitions are not allowed (6.9p3,5).  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"redefinition of %q+D"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|locate_old_decl
argument_list|(
name|olddecl
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* Objects declared at file scope: if the first declaration had 	 external linkage (even if it was an external reference) the 	 second must have external linkage as well, or the behavior is 	 undefined.  If the first declaration had internal linkage, then 	 the second must too, or else be an external reference (in which 	 case the composite declaration still has internal linkage). 	 As for function declarations, we warn about the static-then- 	 extern case only for -Wtraditional.  See generally 6.2.2p3-5,7.  */
if|if
condition|(
name|DECL_FILE_SCOPE_P
argument_list|(
name|newdecl
argument_list|)
operator|&&
name|TREE_PUBLIC
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|TREE_PUBLIC
argument_list|(
name|olddecl
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|DECL_FILE_SCOPE_P
argument_list|(
name|olddecl
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"extern declaration of %q+D follows "
literal|"declaration with no linkage"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|locate_old_decl
argument_list|(
name|olddecl
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
elseif|else
if|if
condition|(
name|warn_traditional
condition|)
block|{
name|warning
argument_list|(
name|OPT_Wtraditional
argument_list|,
literal|"non-static declaration of %q+D "
literal|"follows static declaration"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|warned
operator|=
name|true
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|newdecl
argument_list|)
condition|)
name|error
argument_list|(
literal|"non-static declaration of %q+D follows "
literal|"static declaration"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"static declaration of %q+D follows "
literal|"non-static declaration"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|locate_old_decl
argument_list|(
name|olddecl
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
comment|/* Two objects with the same name declared at the same block 	 scope must both be external references (6.7p3).  */
elseif|else
if|if
condition|(
operator|!
name|DECL_FILE_SCOPE_P
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
comment|/* Extern with initializer at block scope, which will 		 already have received an error.  */
block|}
elseif|else
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|olddecl
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"declaration of %q+D with no linkage follows "
literal|"extern declaration"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|locate_old_decl
argument_list|(
name|olddecl
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"redeclaration of %q+D with no linkage"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|locate_old_decl
argument_list|(
name|olddecl
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
block|}
comment|/* warnings */
comment|/* All decls must agree on a visibility.  */
if|if
condition|(
name|CODE_CONTAINS_STRUCT
argument_list|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
argument_list|,
name|TS_DECL_WITH_VIS
argument_list|)
operator|&&
name|DECL_VISIBILITY_SPECIFIED
argument_list|(
name|newdecl
argument_list|)
operator|&&
name|DECL_VISIBILITY_SPECIFIED
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|DECL_VISIBILITY
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|DECL_VISIBILITY
argument_list|(
name|olddecl
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"redeclaration of %q+D with different visibility "
literal|"(old visibility preserved)"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|warned
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
comment|/* Diagnose inline __attribute__ ((noinline)) which is silly.  */
if|if
condition|(
name|DECL_DECLARED_INLINE_P
argument_list|(
name|newdecl
argument_list|)
operator|&&
name|lookup_attribute
argument_list|(
literal|"noinline"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|olddecl
argument_list|)
argument_list|)
condition|)
block|{
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"inline declaration of %qD follows "
literal|"declaration with attribute noinline"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|warned
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_DECLARED_INLINE_P
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|lookup_attribute
argument_list|(
literal|"noinline"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|newdecl
argument_list|)
argument_list|)
condition|)
block|{
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"declaration of %q+D with attribute "
literal|"noinline follows inline declaration "
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|warned
operator|=
name|true
expr_stmt|;
block|}
comment|/* Inline declaration after use or definition. 	 ??? Should we still warn about this now we have unit-at-a-time 	 mode and can get it right? 	 Definitely don't complain if the decls are in different translation 	 units. 	 C99 permits this, so don't warn in that case.  (The function 	 may not be inlined everywhere in function-at-a-time mode, but 	 we still shouldn't warn.)  */
if|if
condition|(
name|DECL_DECLARED_INLINE_P
argument_list|(
name|newdecl
argument_list|)
operator|&&
operator|!
name|DECL_DECLARED_INLINE_P
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|same_translation_unit_p
argument_list|(
name|olddecl
argument_list|,
name|newdecl
argument_list|)
operator|&&
name|flag_gnu89_inline
condition|)
block|{
if|if
condition|(
name|TREE_USED
argument_list|(
name|olddecl
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"%q+D declared inline after being called"
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
name|warned
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"%q+D declared inline after its definition"
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
name|warned
operator|=
name|true
expr_stmt|;
block|}
block|}
block|}
else|else
comment|/* PARM_DECL, VAR_DECL */
block|{
comment|/* Redeclaration of a parameter is a constraint violation (this is 	 not explicitly stated, but follows from C99 6.7p3 [no more than 	 one declaration of the same identifier with no linkage in the 	 same scope, except type tags] and 6.2.2p6 [parameters have no 	 linkage]).  We must check for a forward parameter declaration, 	 indicated by TREE_ASM_WRITTEN on the old declaration - this is 	 an extension, the mandatory diagnostic for which is handled by 	 mark_forward_parm_decls.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|PARM_DECL
operator|&&
operator|(
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|olddecl
argument_list|)
operator|||
name|TREE_ASM_WRITTEN
argument_list|(
name|newdecl
argument_list|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"redefinition of parameter %q+D"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|locate_old_decl
argument_list|(
name|olddecl
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
comment|/* Optional warning for completely redundant decls.  */
if|if
condition|(
operator|!
name|warned
operator|&&
operator|!
name|pedwarned
operator|&&
name|warn_redundant_decls
comment|/* Don't warn about a function declaration followed by a 	 definition.  */
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|&&
operator|!
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
operator|)
comment|/* Don't warn about redundant redeclarations of builtins.  */
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|!
name|DECL_BUILT_IN
argument_list|(
name|newdecl
argument_list|)
operator|&&
name|DECL_BUILT_IN
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|!
name|C_DECL_DECLARED_BUILTIN
argument_list|(
name|olddecl
argument_list|)
operator|)
comment|/* Don't warn about an extern followed by a definition.  */
operator|&&
operator|!
operator|(
name|DECL_EXTERNAL
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|newdecl
argument_list|)
operator|)
comment|/* Don't warn about forward parameter decls.  */
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|PARM_DECL
operator|&&
name|TREE_ASM_WRITTEN
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|newdecl
argument_list|)
operator|)
comment|/* Don't warn about a variable definition following a declaration.  */
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|&&
operator|!
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
operator|)
condition|)
block|{
name|warning
argument_list|(
name|OPT_Wredundant_decls
argument_list|,
literal|"redundant redeclaration of %q+D"
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
name|warned
operator|=
name|true
expr_stmt|;
block|}
comment|/* Report location of previous decl/defn in a consistent manner.  */
if|if
condition|(
name|warned
operator|||
name|pedwarned
condition|)
name|locate_old_decl
argument_list|(
name|olddecl
argument_list|,
name|pedwarned
condition|?
name|pedwarn
else|:
name|warning0
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|DECL_EXTERN_INLINE
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of duplicate_decls.  NEWDECL has been found to be    consistent with OLDDECL, but carries new information.  Merge the    new information into OLDDECL.  This function issues no    diagnostics.  */
end_comment

begin_function
specifier|static
name|void
name|merge_decls
parameter_list|(
name|tree
name|newdecl
parameter_list|,
name|tree
name|olddecl
parameter_list|,
name|tree
name|newtype
parameter_list|,
name|tree
name|oldtype
parameter_list|)
block|{
name|bool
name|new_is_definition
init|=
operator|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|!=
literal|0
operator|)
decl_stmt|;
name|bool
name|new_is_prototype
init|=
operator|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
operator|!=
literal|0
operator|)
decl_stmt|;
name|bool
name|old_is_prototype
init|=
operator|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
operator|!=
literal|0
operator|)
decl_stmt|;
name|bool
name|extern_changed
init|=
name|false
decl_stmt|;
comment|/* For real parm decl following a forward decl, rechain the old decl      in its new location and clear TREE_ASM_WRITTEN (it's not a      forward decl anymore).  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|PARM_DECL
operator|&&
name|TREE_ASM_WRITTEN
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
name|struct
name|c_binding
modifier|*
name|b
decl_stmt|,
modifier|*
modifier|*
name|here
decl_stmt|;
for|for
control|(
name|here
operator|=
operator|&
name|current_scope
operator|->
name|bindings
init|;
operator|*
name|here
condition|;
name|here
operator|=
operator|&
operator|(
operator|*
name|here
operator|)
operator|->
name|prev
control|)
if|if
condition|(
operator|(
operator|*
name|here
operator|)
operator|->
name|decl
operator|==
name|olddecl
condition|)
goto|goto
name|found
goto|;
name|gcc_unreachable
argument_list|()
expr_stmt|;
name|found
label|:
name|b
operator|=
operator|*
name|here
expr_stmt|;
operator|*
name|here
operator|=
name|b
operator|->
name|prev
expr_stmt|;
name|b
operator|->
name|prev
operator|=
name|current_scope
operator|->
name|bindings
expr_stmt|;
name|current_scope
operator|->
name|bindings
operator|=
name|b
expr_stmt|;
name|TREE_ASM_WRITTEN
argument_list|(
name|olddecl
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
name|DECL_ATTRIBUTES
argument_list|(
name|newdecl
argument_list|)
operator|=
name|targetm
operator|.
name|merge_decl_attributes
argument_list|(
name|olddecl
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
comment|/* Merge the data types specified in the two decls.  */
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
operator|=
name|composite_type
argument_list|(
name|newtype
argument_list|,
name|oldtype
argument_list|)
expr_stmt|;
comment|/* Lay the type out, unless already done.  */
if|if
condition|(
operator|!
name|comptypes
argument_list|(
name|oldtype
argument_list|,
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|error_mark_node
condition|)
name|layout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|TYPE_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|CONST_DECL
condition|)
name|layout_decl
argument_list|(
name|newdecl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Since the type is OLDDECL's, make OLDDECL's size go with.  */
name|DECL_SIZE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_SIZE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_SIZE_UNIT
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_SIZE_UNIT
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_MODE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_MODE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_ALIGN
argument_list|(
name|olddecl
argument_list|)
operator|>
name|DECL_ALIGN
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
name|DECL_ALIGN
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_ALIGN
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_USER_ALIGN
argument_list|(
name|newdecl
argument_list|)
operator||=
name|DECL_ALIGN
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Merge the type qualifiers.  */
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|newdecl
argument_list|)
condition|)
name|TREE_READONLY
argument_list|(
name|olddecl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|newdecl
argument_list|)
condition|)
name|TREE_THIS_VOLATILE
argument_list|(
name|olddecl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Merge deprecatedness.  */
if|if
condition|(
name|TREE_DEPRECATED
argument_list|(
name|newdecl
argument_list|)
condition|)
name|TREE_DEPRECATED
argument_list|(
name|olddecl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* APPLE LOCAL begin "unavailable" attribute (radar 2809697) */
comment|/* Merge unavailableness.  */
if|if
condition|(
name|TREE_UNAVAILABLE
argument_list|(
name|newdecl
argument_list|)
condition|)
name|TREE_UNAVAILABLE
argument_list|(
name|olddecl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* APPLE LOCAL end "unavailable" attribute (radar 2809697) */
comment|/* Keep source location of definition rather than declaration and of      prototype rather than non-prototype unless that prototype is      built-in.  */
if|if
condition|(
operator|(
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|==
literal|0
operator|&&
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|old_is_prototype
operator|&&
operator|!
name|new_is_prototype
operator|&&
operator|!
name|C_DECL_BUILTIN_PROTOTYPE
argument_list|(
name|olddecl
argument_list|)
operator|)
condition|)
name|DECL_SOURCE_LOCATION
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_SOURCE_LOCATION
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
comment|/* Merge the initialization information.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|==
literal|0
condition|)
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
comment|/* Merge the threadprivate attribute.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|C_DECL_THREADPRIVATE_P
argument_list|(
name|olddecl
argument_list|)
condition|)
block|{
name|DECL_TLS_MODEL
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_TLS_MODEL
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|C_DECL_THREADPRIVATE_P
argument_list|(
name|newdecl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|CODE_CONTAINS_STRUCT
argument_list|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
argument_list|,
name|TS_DECL_WITH_VIS
argument_list|)
condition|)
block|{
comment|/* Merge the unused-warning information.  */
if|if
condition|(
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|olddecl
argument_list|)
condition|)
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|newdecl
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|newdecl
argument_list|)
condition|)
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|olddecl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Merge the section attribute. 	 We want to issue an error if the sections conflict but that 	 must be done later in decl_attributes since we are called 	 before attributes are assigned.  */
if|if
condition|(
name|DECL_SECTION_NAME
argument_list|(
name|newdecl
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|DECL_SECTION_NAME
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_SECTION_NAME
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
comment|/* Copy the assembler name. 	 Currently, it can only be defined in the prototype.  */
name|COPY_DECL_ASSEMBLER_NAME
argument_list|(
name|olddecl
argument_list|,
name|newdecl
argument_list|)
expr_stmt|;
comment|/* Use visibility of whichever declaration had it specified */
if|if
condition|(
name|DECL_VISIBILITY_SPECIFIED
argument_list|(
name|olddecl
argument_list|)
condition|)
block|{
name|DECL_VISIBILITY
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_VISIBILITY
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_VISIBILITY_SPECIFIED
argument_list|(
name|newdecl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|DECL_STATIC_CONSTRUCTOR
argument_list|(
name|newdecl
argument_list|)
operator||=
name|DECL_STATIC_CONSTRUCTOR
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_STATIC_DESTRUCTOR
argument_list|(
name|newdecl
argument_list|)
operator||=
name|DECL_STATIC_DESTRUCTOR
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_NO_LIMIT_STACK
argument_list|(
name|newdecl
argument_list|)
operator||=
name|DECL_NO_LIMIT_STACK
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT
argument_list|(
name|newdecl
argument_list|)
operator||=
name|DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|newdecl
argument_list|)
operator||=
name|TREE_THIS_VOLATILE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|newdecl
argument_list|)
operator||=
name|TREE_READONLY
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_IS_MALLOC
argument_list|(
name|newdecl
argument_list|)
operator||=
name|DECL_IS_MALLOC
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_IS_PURE
argument_list|(
name|newdecl
argument_list|)
operator||=
name|DECL_IS_PURE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_IS_NOVOPS
argument_list|(
name|newdecl
argument_list|)
operator||=
name|DECL_IS_NOVOPS
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
block|}
comment|/* Merge the storage class information.  */
name|merge_weak
argument_list|(
name|newdecl
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
comment|/* For functions, static overrides non-static.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|TREE_PUBLIC
argument_list|(
name|newdecl
argument_list|)
operator|&=
name|TREE_PUBLIC
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
comment|/* This is since we don't automatically 	     copy the attributes of NEWDECL into OLDDECL.  */
name|TREE_PUBLIC
argument_list|(
name|olddecl
argument_list|)
operator|=
name|TREE_PUBLIC
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
comment|/* If this clears `static', clear it in the identifier too.  */
if|if
condition|(
operator|!
name|TREE_PUBLIC
argument_list|(
name|olddecl
argument_list|)
condition|)
name|TREE_PUBLIC
argument_list|(
name|DECL_NAME
argument_list|(
name|olddecl
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* In c99, 'extern' declaration before (or after) 'inline' means this      function is not DECL_EXTERNAL, unless 'gnu_inline' attribute      is present.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|!
name|flag_gnu89_inline
operator|&&
operator|(
name|DECL_DECLARED_INLINE_P
argument_list|(
name|newdecl
argument_list|)
operator|||
name|DECL_DECLARED_INLINE_P
argument_list|(
name|olddecl
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|DECL_DECLARED_INLINE_P
argument_list|(
name|newdecl
argument_list|)
operator|||
operator|!
name|DECL_DECLARED_INLINE_P
argument_list|(
name|olddecl
argument_list|)
operator|||
operator|!
name|DECL_EXTERNAL
argument_list|(
name|olddecl
argument_list|)
operator|)
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|newdecl
argument_list|)
operator|&&
operator|!
name|lookup_attribute
argument_list|(
literal|"gnu_inline"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|newdecl
argument_list|)
argument_list|)
condition|)
name|DECL_EXTERNAL
argument_list|(
name|newdecl
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
name|TREE_STATIC
argument_list|(
name|newdecl
argument_list|)
operator|=
name|TREE_STATIC
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_EXTERNAL
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
comment|/* An extern decl does not override previous storage class.  */
name|TREE_PUBLIC
argument_list|(
name|newdecl
argument_list|)
operator|=
name|TREE_PUBLIC
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_EXTERNAL
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
name|DECL_CONTEXT
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_CONTEXT
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_COMMON
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_COMMON
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|TREE_STATIC
argument_list|(
name|olddecl
argument_list|)
operator|=
name|TREE_STATIC
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|olddecl
argument_list|)
operator|=
name|TREE_PUBLIC
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
comment|/* If we're redefining a function previously defined as extern 	 inline, make sure we emit debug info for the inline before we 	 throw it away, in case it was inlined into a function that 	 hasn't been written out yet.  */
if|if
condition|(
name|new_is_definition
operator|&&
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_USED
argument_list|(
name|olddecl
argument_list|)
comment|/* In unit-at-a-time mode we never inline re-defined extern 		 inline functions.  */
operator|&&
operator|!
name|flag_unit_at_a_time
operator|&&
name|cgraph_function_possibly_inlined_p
argument_list|(
name|olddecl
argument_list|)
condition|)
call|(
modifier|*
name|debug_hooks
operator|->
name|outlining_inline_function
call|)
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
comment|/* The new defn must not be inline.  */
name|DECL_INLINE
argument_list|(
name|newdecl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_UNINLINABLE
argument_list|(
name|newdecl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* If either decl says `inline', this fn is inline, unless 	     its definition was passed already.  */
if|if
condition|(
name|DECL_DECLARED_INLINE_P
argument_list|(
name|newdecl
argument_list|)
operator|||
name|DECL_DECLARED_INLINE_P
argument_list|(
name|olddecl
argument_list|)
condition|)
name|DECL_DECLARED_INLINE_P
argument_list|(
name|newdecl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_UNINLINABLE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_UNINLINABLE
argument_list|(
name|olddecl
argument_list|)
operator|=
operator|(
name|DECL_UNINLINABLE
argument_list|(
name|newdecl
argument_list|)
operator|||
name|DECL_UNINLINABLE
argument_list|(
name|olddecl
argument_list|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|DECL_BUILT_IN
argument_list|(
name|olddecl
argument_list|)
condition|)
block|{
comment|/* If redeclaring a builtin function, it stays built in. 	     But it gets tagged as having been declared.  */
name|DECL_BUILT_IN_CLASS
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_BUILT_IN_CLASS
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_FUNCTION_CODE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_FUNCTION_CODE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|C_DECL_DECLARED_BUILTIN
argument_list|(
name|newdecl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|new_is_prototype
condition|)
name|C_DECL_BUILTIN_PROTOTYPE
argument_list|(
name|newdecl
argument_list|)
operator|=
literal|0
expr_stmt|;
else|else
name|C_DECL_BUILTIN_PROTOTYPE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|C_DECL_BUILTIN_PROTOTYPE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
block|}
comment|/* Also preserve various other info from the definition.  */
if|if
condition|(
operator|!
name|new_is_definition
condition|)
block|{
name|DECL_RESULT
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_RESULT
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_STRUCT_FUNCTION
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_STRUCT_FUNCTION
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_SAVED_TREE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_SAVED_TREE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_ARGUMENTS
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
comment|/* Set DECL_INLINE on the declaration if we've got a body 	     from which to instantiate.  */
if|if
condition|(
name|DECL_INLINE
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|!
name|DECL_UNINLINABLE
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
name|DECL_INLINE
argument_list|(
name|newdecl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* If a previous declaration said inline, mark the 	     definition as inlinable.  */
if|if
condition|(
name|DECL_DECLARED_INLINE_P
argument_list|(
name|newdecl
argument_list|)
operator|&&
operator|!
name|DECL_UNINLINABLE
argument_list|(
name|newdecl
argument_list|)
condition|)
name|DECL_INLINE
argument_list|(
name|newdecl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|extern_changed
operator|=
name|DECL_EXTERNAL
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
comment|/* Copy most of the decl-specific fields of NEWDECL into OLDDECL.      But preserve OLDDECL's DECL_UID and DECL_CONTEXT.  */
block|{
name|unsigned
name|olddecl_uid
init|=
name|DECL_UID
argument_list|(
name|olddecl
argument_list|)
decl_stmt|;
name|tree
name|olddecl_context
init|=
name|DECL_CONTEXT
argument_list|(
name|olddecl
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|olddecl
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tree_common
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|newdecl
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tree_common
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tree_decl_common
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|tree_common
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
condition|)
block|{
case|case
name|FIELD_DECL
case|:
case|case
name|VAR_DECL
case|:
case|case
name|PARM_DECL
case|:
case|case
name|LABEL_DECL
case|:
case|case
name|RESULT_DECL
case|:
case|case
name|CONST_DECL
case|:
case|case
name|TYPE_DECL
case|:
case|case
name|FUNCTION_DECL
case|:
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|olddecl
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tree_decl_common
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|newdecl
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tree_decl_common
argument_list|)
argument_list|,
name|tree_code_size
argument_list|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|tree_decl_common
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|olddecl
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tree_decl_common
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|newdecl
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tree_decl_common
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tree_decl_non_common
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|tree_decl_common
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|DECL_UID
argument_list|(
name|olddecl
argument_list|)
operator|=
name|olddecl_uid
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|olddecl
argument_list|)
operator|=
name|olddecl_context
expr_stmt|;
block|}
comment|/* If OLDDECL had its DECL_RTL instantiated, re-invoke make_decl_rtl      so that encode_section_info has a chance to look at the new decl      flags and attributes.  */
if|if
condition|(
name|DECL_RTL_SET_P
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_STATIC
argument_list|(
name|olddecl
argument_list|)
operator|)
operator|)
condition|)
name|make_decl_rtl
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
comment|/* If we changed a function from DECL_EXTERNAL to !DECL_EXTERNAL,      and the definition is coming from the old version, cgraph needs      to be called again.  */
if|if
condition|(
name|extern_changed
operator|&&
operator|!
name|new_is_definition
operator|&&
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
condition|)
name|cgraph_finalize_function
argument_list|(
name|olddecl
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle when a new declaration NEWDECL has the same name as an old    one OLDDECL in the same binding contour.  Prints an error message    if appropriate.     If safely possible, alter OLDDECL to look like NEWDECL, and return    true.  Otherwise, return false.  */
end_comment

begin_function
specifier|static
name|bool
name|duplicate_decls
parameter_list|(
name|tree
name|newdecl
parameter_list|,
name|tree
name|olddecl
parameter_list|)
block|{
name|tree
name|newtype
init|=
name|NULL
decl_stmt|,
name|oldtype
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|diagnose_mismatched_decls
argument_list|(
name|newdecl
argument_list|,
name|olddecl
argument_list|,
operator|&
name|newtype
argument_list|,
operator|&
name|oldtype
argument_list|)
condition|)
block|{
comment|/* Avoid `unused variable' and other warnings warnings for OLDDECL.  */
name|TREE_NO_WARNING
argument_list|(
name|olddecl
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|false
return|;
block|}
name|merge_decls
argument_list|(
name|newdecl
argument_list|,
name|olddecl
argument_list|,
name|newtype
argument_list|,
name|oldtype
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Check whether decl-node NEW_DECL shadows an existing declaration.  */
end_comment

begin_function
specifier|static
name|void
name|warn_if_shadowing
parameter_list|(
name|tree
name|new_decl
parameter_list|)
block|{
name|struct
name|c_binding
modifier|*
name|b
decl_stmt|;
comment|/* Shadow warnings wanted?  */
if|if
condition|(
operator|!
name|warn_shadow
comment|/* No shadow warnings for internally generated vars.  */
operator|||
name|DECL_IS_BUILTIN
argument_list|(
name|new_decl
argument_list|)
comment|/* No shadow warnings for vars made for inlining.  */
operator|||
name|DECL_FROM_INLINE
argument_list|(
name|new_decl
argument_list|)
condition|)
return|return;
comment|/* Is anything being shadowed?  Invisible decls do not count.  */
for|for
control|(
name|b
operator|=
name|I_SYMBOL_BINDING
argument_list|(
name|DECL_NAME
argument_list|(
name|new_decl
argument_list|)
argument_list|)
init|;
name|b
condition|;
name|b
operator|=
name|b
operator|->
name|shadowed
control|)
if|if
condition|(
name|b
operator|->
name|decl
operator|&&
name|b
operator|->
name|decl
operator|!=
name|new_decl
operator|&&
operator|!
name|b
operator|->
name|invisible
condition|)
block|{
name|tree
name|old_decl
init|=
name|b
operator|->
name|decl
decl_stmt|;
if|if
condition|(
name|old_decl
operator|==
name|error_mark_node
condition|)
block|{
name|warning
argument_list|(
name|OPT_Wshadow
argument_list|,
literal|"declaration of %q+D shadows previous "
literal|"non-variable"
argument_list|,
name|new_decl
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|old_decl
argument_list|)
operator|==
name|PARM_DECL
condition|)
name|warning
argument_list|(
name|OPT_Wshadow
argument_list|,
literal|"declaration of %q+D shadows a parameter"
argument_list|,
name|new_decl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_FILE_SCOPE_P
argument_list|(
name|old_decl
argument_list|)
condition|)
name|warning
argument_list|(
name|OPT_Wshadow
argument_list|,
literal|"declaration of %q+D shadows a global "
literal|"declaration"
argument_list|,
name|new_decl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|old_decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_BUILT_IN
argument_list|(
name|old_decl
argument_list|)
condition|)
block|{
name|warning
argument_list|(
name|OPT_Wshadow
argument_list|,
literal|"declaration of %q+D shadows "
literal|"a built-in function"
argument_list|,
name|new_decl
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
name|warning
argument_list|(
name|OPT_Wshadow
argument_list|,
literal|"declaration of %q+D shadows a previous local"
argument_list|,
name|new_decl
argument_list|)
expr_stmt|;
name|warning
argument_list|(
name|OPT_Wshadow
argument_list|,
literal|"%Jshadowed declaration is here"
argument_list|,
name|old_decl
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Subroutine of pushdecl.     X is a TYPE_DECL for a typedef statement.  Create a brand new    ..._TYPE node (which will be just a variant of the existing    ..._TYPE node with identical properties) and then install X    as the TYPE_NAME of this brand new (duplicate) ..._TYPE node.     The whole point here is to end up with a situation where each    and every ..._TYPE node the compiler creates will be uniquely    associated with AT MOST one node representing a typedef name.    This way, even though the compiler substitutes corresponding    ..._TYPE nodes for TYPE_DECL (i.e. "typedef name") nodes very    early on, later parts of the compiler can always do the reverse    translation and get back the corresponding typedef name.  For    example, given:  	typedef struct S MY_TYPE; 	MY_TYPE object;     Later parts of the compiler might only know that `object' was of    type `struct S' if it were not for code just below.  With this    code however, later parts of the compiler see something like:  	struct S' == struct S 	typedef struct S' MY_TYPE; 	struct S' object;      And they can then deduce (from the node for type struct S') that     the original object declaration was:  		MY_TYPE object;      Being able to do this is important for proper support of protoize,     and also for generating precise symbolic debugging information     which takes full account of the programmer's (typedef) vocabulary.      Obviously, we don't want to generate a duplicate ..._TYPE node if     the TYPE_DECL node that we are now processing really represents a     standard built-in type.      Since all standard types are effectively declared at line zero     in the source file, we can easily check to see if we are working     on a standard type by checking the current value of lineno.  */
end_comment

begin_function
specifier|static
name|void
name|clone_underlying_type
parameter_list|(
name|tree
name|x
parameter_list|)
block|{
if|if
condition|(
name|DECL_IS_BUILTIN
argument_list|(
name|x
argument_list|)
condition|)
block|{
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|TYPE_NAME
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|=
name|x
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
operator|!=
name|error_mark_node
operator|&&
name|DECL_ORIGINAL_TYPE
argument_list|(
name|x
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|tree
name|tt
init|=
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|DECL_ORIGINAL_TYPE
argument_list|(
name|x
argument_list|)
operator|=
name|tt
expr_stmt|;
name|tt
operator|=
name|build_variant_type_copy
argument_list|(
name|tt
argument_list|)
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|tt
argument_list|)
operator|=
name|x
expr_stmt|;
name|TREE_USED
argument_list|(
name|tt
argument_list|)
operator|=
name|TREE_USED
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
operator|=
name|tt
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Record a decl-node X as belonging to the current lexical scope.    Check for errors (such as an incompatible declaration for the same    name already seen in the same scope).     Returns either X or an old decl for the same name.    If an old decl is returned, it may have been smashed    to agree with what X says.  */
end_comment

begin_function
name|tree
name|pushdecl
parameter_list|(
name|tree
name|x
parameter_list|)
block|{
name|tree
name|name
init|=
name|DECL_NAME
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|struct
name|c_scope
modifier|*
name|scope
init|=
name|current_scope
decl_stmt|;
name|struct
name|c_binding
modifier|*
name|b
decl_stmt|;
name|bool
name|nested
init|=
name|false
decl_stmt|;
comment|/* Functions need the lang_decl data.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|!
name|DECL_LANG_SPECIFIC
argument_list|(
name|x
argument_list|)
condition|)
name|DECL_LANG_SPECIFIC
argument_list|(
name|x
argument_list|)
operator|=
name|GGC_CNEW
argument_list|(
expr|struct
name|lang_decl
argument_list|)
expr_stmt|;
comment|/* Must set DECL_CONTEXT for everything not at file scope or      DECL_FILE_SCOPE_P won't work.  Local externs don't count      unless they have initializers (which generate code).  */
if|if
condition|(
name|current_function_decl
operator|&&
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|VAR_DECL
operator|)
operator|||
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|||
operator|!
name|DECL_EXTERNAL
argument_list|(
name|x
argument_list|)
operator|)
condition|)
name|DECL_CONTEXT
argument_list|(
name|x
argument_list|)
operator|=
name|current_function_decl
expr_stmt|;
comment|/* If this is of variably modified type, prevent jumping into its      scope.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TYPE_DECL
operator|)
operator|&&
name|variably_modified_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
condition|)
name|c_begin_vm_scope
argument_list|(
name|scope
operator|->
name|depth
argument_list|)
expr_stmt|;
comment|/* Anonymous decls are just inserted in the scope.  */
if|if
condition|(
operator|!
name|name
condition|)
block|{
name|bind
argument_list|(
name|name
argument_list|,
name|x
argument_list|,
name|scope
argument_list|,
comment|/*invisible=*/
name|false
argument_list|,
comment|/*nested=*/
name|false
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
comment|/* First, see if there is another declaration with the same name in      the current scope.  If there is, duplicate_decls may do all the      work for us.  If duplicate_decls returns false, that indicates      two incompatible decls in the same scope; we are to silently      replace the old one (duplicate_decls has issued all appropriate      diagnostics).  In particular, we should not consider possible      duplicates in the external scope, or shadowing.  */
name|b
operator|=
name|I_SYMBOL_BINDING
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|&&
name|B_IN_SCOPE
argument_list|(
name|b
argument_list|,
name|scope
argument_list|)
condition|)
block|{
name|struct
name|c_binding
modifier|*
name|b_ext
decl_stmt|,
modifier|*
name|b_use
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|tree
name|visdecl
init|=
name|b
operator|->
name|decl
decl_stmt|;
name|tree
name|vistype
init|=
name|TREE_TYPE
argument_list|(
name|visdecl
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|COMPLETE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|b
operator|->
name|inner_comp
operator|=
name|false
expr_stmt|;
name|b_use
operator|=
name|b
expr_stmt|;
name|b_ext
operator|=
name|b
expr_stmt|;
comment|/* If this is an external linkage declaration, we should check 	 for compatibility with the type in the external scope before 	 setting the type at this scope based on the visible 	 information only.  */
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|x
argument_list|)
operator|&&
name|TREE_PUBLIC
argument_list|(
name|visdecl
argument_list|)
condition|)
block|{
while|while
condition|(
name|b_ext
operator|&&
operator|!
name|B_IN_EXTERNAL_SCOPE
argument_list|(
name|b_ext
argument_list|)
condition|)
name|b_ext
operator|=
name|b_ext
operator|->
name|shadowed
expr_stmt|;
if|if
condition|(
name|b_ext
condition|)
block|{
name|b_use
operator|=
name|b_ext
expr_stmt|;
if|if
condition|(
name|b_use
operator|->
name|type
condition|)
name|TREE_TYPE
argument_list|(
name|b_use
operator|->
name|decl
argument_list|)
operator|=
name|b_use
operator|->
name|type
expr_stmt|;
block|}
block|}
if|if
condition|(
name|duplicate_decls
argument_list|(
name|x
argument_list|,
name|b_use
operator|->
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|b_use
operator|!=
name|b
condition|)
block|{
comment|/* Save the updated type in the external scope and 		 restore the proper type for this scope.  */
name|tree
name|thistype
decl_stmt|;
if|if
condition|(
name|comptypes
argument_list|(
name|vistype
argument_list|,
name|type
argument_list|)
condition|)
name|thistype
operator|=
name|composite_type
argument_list|(
name|vistype
argument_list|,
name|type
argument_list|)
expr_stmt|;
else|else
name|thistype
operator|=
name|TREE_TYPE
argument_list|(
name|b_use
operator|->
name|decl
argument_list|)
expr_stmt|;
name|b_use
operator|->
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|b_use
operator|->
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|b_use
operator|->
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_BUILT_IN
argument_list|(
name|b_use
operator|->
name|decl
argument_list|)
condition|)
name|thistype
operator|=
name|build_type_attribute_variant
argument_list|(
name|thistype
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|b_use
operator|->
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|b_use
operator|->
name|decl
argument_list|)
operator|=
name|thistype
expr_stmt|;
block|}
return|return
name|b_use
operator|->
name|decl
return|;
block|}
else|else
goto|goto
name|skip_external_and_shadow_checks
goto|;
block|}
comment|/* All declarations with external linkage, and all external      references, go in the external scope, no matter what scope is      current.  However, the binding in that scope is ignored for      purposes of normal name lookup.  A separate binding structure is      created in the requested scope; this governs the normal      visibility of the symbol.       The binding in the externals scope is used exclusively for      detecting duplicate declarations of the same object, no matter      what scope they are in; this is what we do here.  (C99 6.2.7p2:      All declarations that refer to the same object or function shall      have compatible type; otherwise, the behavior is undefined.)  */
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|x
argument_list|)
operator|||
name|scope
operator|==
name|file_scope
condition|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|tree
name|vistype
init|=
literal|0
decl_stmt|;
name|tree
name|visdecl
init|=
literal|0
decl_stmt|;
name|bool
name|type_saved
init|=
name|false
decl_stmt|;
if|if
condition|(
name|b
operator|&&
operator|!
name|B_IN_EXTERNAL_SCOPE
argument_list|(
name|b
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|b
operator|->
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|TREE_CODE
argument_list|(
name|b
operator|->
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|)
operator|&&
name|DECL_FILE_SCOPE_P
argument_list|(
name|b
operator|->
name|decl
argument_list|)
condition|)
block|{
name|visdecl
operator|=
name|b
operator|->
name|decl
expr_stmt|;
name|vistype
operator|=
name|TREE_TYPE
argument_list|(
name|visdecl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|scope
operator|!=
name|file_scope
operator|&&
operator|!
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|x
argument_list|)
condition|)
name|warning
argument_list|(
name|OPT_Wnested_externs
argument_list|,
literal|"nested extern declaration of %qD"
argument_list|,
name|x
argument_list|)
expr_stmt|;
while|while
condition|(
name|b
operator|&&
operator|!
name|B_IN_EXTERNAL_SCOPE
argument_list|(
name|b
argument_list|)
condition|)
block|{
comment|/* If this decl might be modified, save its type.  This is 	     done here rather than when the decl is first bound 	     because the type may change after first binding, through 	     being completed or through attributes being added.  If we 	     encounter multiple such decls, only the first should have 	     its type saved; the others will already have had their 	     proper types saved and the types will not have changed as 	     their scopes will not have been re-entered.  */
if|if
condition|(
name|DECL_P
argument_list|(
name|b
operator|->
name|decl
argument_list|)
operator|&&
name|DECL_FILE_SCOPE_P
argument_list|(
name|b
operator|->
name|decl
argument_list|)
operator|&&
operator|!
name|type_saved
condition|)
block|{
name|b
operator|->
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|b
operator|->
name|decl
argument_list|)
expr_stmt|;
name|type_saved
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|B_IN_FILE_SCOPE
argument_list|(
name|b
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|b
operator|->
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_STATIC
argument_list|(
name|b
operator|->
name|decl
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|b
operator|->
name|decl
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
operator|!
name|TYPE_DOMAIN
argument_list|(
name|TREE_TYPE
argument_list|(
name|b
operator|->
name|decl
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_MAX_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
operator|!
name|integer_zerop
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Array type completed in inner scope, which should be 		 diagnosed if the completion does not have size 1 and 		 it does not get completed in the file scope.  */
name|b
operator|->
name|inner_comp
operator|=
name|true
expr_stmt|;
block|}
name|b
operator|=
name|b
operator|->
name|shadowed
expr_stmt|;
block|}
comment|/* If a matching external declaration has been found, set its 	 type to the composite of all the types of that declaration. 	 After the consistency checks, it will be reset to the 	 composite of the visible types only.  */
if|if
condition|(
name|b
operator|&&
operator|(
name|TREE_PUBLIC
argument_list|(
name|x
argument_list|)
operator|||
name|same_translation_unit_p
argument_list|(
name|x
argument_list|,
name|b
operator|->
name|decl
argument_list|)
operator|)
operator|&&
name|b
operator|->
name|type
condition|)
name|TREE_TYPE
argument_list|(
name|b
operator|->
name|decl
argument_list|)
operator|=
name|b
operator|->
name|type
expr_stmt|;
comment|/* The point of the same_translation_unit_p check here is, 	 we want to detect a duplicate decl for a construct like 	 foo() { extern bar(); } ... static bar();  but not if 	 they are in different translation units.  In any case, 	 the static does not go in the externals scope.  */
if|if
condition|(
name|b
operator|&&
operator|(
name|TREE_PUBLIC
argument_list|(
name|x
argument_list|)
operator|||
name|same_translation_unit_p
argument_list|(
name|x
argument_list|,
name|b
operator|->
name|decl
argument_list|)
operator|)
operator|&&
name|duplicate_decls
argument_list|(
name|x
argument_list|,
name|b
operator|->
name|decl
argument_list|)
condition|)
block|{
name|tree
name|thistype
decl_stmt|;
if|if
condition|(
name|vistype
condition|)
block|{
if|if
condition|(
name|comptypes
argument_list|(
name|vistype
argument_list|,
name|type
argument_list|)
condition|)
name|thistype
operator|=
name|composite_type
argument_list|(
name|vistype
argument_list|,
name|type
argument_list|)
expr_stmt|;
else|else
name|thistype
operator|=
name|TREE_TYPE
argument_list|(
name|b
operator|->
name|decl
argument_list|)
expr_stmt|;
block|}
else|else
name|thistype
operator|=
name|type
expr_stmt|;
name|b
operator|->
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|b
operator|->
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|b
operator|->
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_BUILT_IN
argument_list|(
name|b
operator|->
name|decl
argument_list|)
condition|)
name|thistype
operator|=
name|build_type_attribute_variant
argument_list|(
name|thistype
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|b
operator|->
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|b
operator|->
name|decl
argument_list|)
operator|=
name|thistype
expr_stmt|;
name|bind
argument_list|(
name|name
argument_list|,
name|b
operator|->
name|decl
argument_list|,
name|scope
argument_list|,
comment|/*invisible=*/
name|false
argument_list|,
comment|/*nested=*/
name|true
argument_list|)
expr_stmt|;
return|return
name|b
operator|->
name|decl
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|x
argument_list|)
condition|)
block|{
if|if
condition|(
name|visdecl
operator|&&
operator|!
name|b
operator|&&
name|duplicate_decls
argument_list|(
name|x
argument_list|,
name|visdecl
argument_list|)
condition|)
block|{
comment|/* An external declaration at block scope referring to a 		 visible entity with internal linkage.  The composite 		 type will already be correct for this scope, so we 		 just need to fall through to make the declaration in 		 this scope.  */
name|nested
operator|=
name|true
expr_stmt|;
name|x
operator|=
name|visdecl
expr_stmt|;
block|}
else|else
block|{
name|bind
argument_list|(
name|name
argument_list|,
name|x
argument_list|,
name|external_scope
argument_list|,
comment|/*invisible=*/
name|true
argument_list|,
comment|/*nested=*/
name|false
argument_list|)
expr_stmt|;
name|nested
operator|=
name|true
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|PARM_DECL
condition|)
name|warn_if_shadowing
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|skip_external_and_shadow_checks
label|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|clone_underlying_type
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|bind
argument_list|(
name|name
argument_list|,
name|x
argument_list|,
name|scope
argument_list|,
comment|/*invisible=*/
name|false
argument_list|,
name|nested
argument_list|)
expr_stmt|;
comment|/* If x's type is incomplete because it's based on a      structure or union which has not yet been fully declared,      attach it to that structure or union type, so we can go      back and complete the variable declaration later, if the      structure or union gets fully declared.       If the input is erroneous, we can have error_mark in the type      slot (e.g. "f(void a, ...)") - that doesn't count as an      incomplete type.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
operator|!=
name|error_mark_node
operator|&&
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|element
init|=
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
decl_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|element
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|element
operator|=
name|TREE_TYPE
argument_list|(
name|element
argument_list|)
expr_stmt|;
name|element
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|element
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|element
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|element
argument_list|)
operator|==
name|UNION_TYPE
operator|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|TYPE_DECL
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|)
operator|&&
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|element
argument_list|)
condition|)
name|C_TYPE_INCOMPLETE_VARS
argument_list|(
name|element
argument_list|)
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|x
argument_list|,
name|C_TYPE_INCOMPLETE_VARS
argument_list|(
name|element
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Record X as belonging to file scope.    This is used only internally by the Objective-C front end,    and is limited to its needs.  duplicate_decls is not called;    if there is any preexisting decl for this identifier, it is an ICE.  */
end_comment

begin_function
name|tree
name|pushdecl_top_level
parameter_list|(
name|tree
name|x
parameter_list|)
block|{
name|tree
name|name
decl_stmt|;
name|bool
name|nested
init|=
name|false
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DECL
argument_list|)
expr_stmt|;
name|name
operator|=
name|DECL_NAME
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DECL
operator|||
operator|!
name|I_SYMBOL_BINDING
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|bind
argument_list|(
name|name
argument_list|,
name|x
argument_list|,
name|external_scope
argument_list|,
comment|/*invisible=*/
name|true
argument_list|,
comment|/*nested=*/
name|false
argument_list|)
expr_stmt|;
name|nested
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|file_scope
condition|)
name|bind
argument_list|(
name|name
argument_list|,
name|x
argument_list|,
name|file_scope
argument_list|,
comment|/*invisible=*/
name|false
argument_list|,
name|nested
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|implicit_decl_warning
parameter_list|(
name|tree
name|id
parameter_list|,
name|tree
name|olddecl
parameter_list|)
block|{
name|void
function_decl|(
modifier|*
name|diag
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
function_decl|ATTRIBUTE_GCC_CDIAG
parameter_list|(
function_decl|1
operator|,
function_decl|2
block|)
function|;
end_function

begin_switch
switch|switch
condition|(
name|mesg_implicit_function_declaration
condition|)
block|{
case|case
literal|0
case|:
return|return;
case|case
literal|1
case|:
name|diag
operator|=
name|warning0
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|diag
operator|=
name|error
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
end_switch

begin_expr_stmt
name|diag
argument_list|(
name|G_
argument_list|(
literal|"implicit declaration of function %qE"
argument_list|)
argument_list|,
name|id
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|olddecl
condition|)
name|locate_old_decl
argument_list|(
name|olddecl
argument_list|,
name|diag
argument_list|)
expr_stmt|;
end_if

begin_comment
unit|}
comment|/* Generate an implicit declaration for identifier FUNCTIONID as a    function of type int ().  */
end_comment

begin_macro
unit|tree
name|implicitly_declare
argument_list|(
argument|tree functionid
argument_list|)
end_macro

begin_block
block|{
name|struct
name|c_binding
modifier|*
name|b
decl_stmt|;
name|tree
name|decl
init|=
literal|0
decl_stmt|;
name|tree
name|asmspec_tree
decl_stmt|;
for|for
control|(
name|b
operator|=
name|I_SYMBOL_BINDING
argument_list|(
name|functionid
argument_list|)
init|;
name|b
condition|;
name|b
operator|=
name|b
operator|->
name|shadowed
control|)
block|{
if|if
condition|(
name|B_IN_SCOPE
argument_list|(
name|b
argument_list|,
name|external_scope
argument_list|)
condition|)
block|{
name|decl
operator|=
name|b
operator|->
name|decl
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|decl
condition|)
block|{
if|if
condition|(
name|decl
operator|==
name|error_mark_node
condition|)
return|return
name|decl
return|;
comment|/* FIXME: Objective-C has weird not-really-builtin functions 	 which are supposed to be visible automatically.  They wind up 	 in the external scope because they're pushed before the file 	 scope gets created.  Catch this here and rebind them into the 	 file scope.  */
if|if
condition|(
operator|!
name|DECL_BUILT_IN
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_IS_BUILTIN
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|bind
argument_list|(
name|functionid
argument_list|,
name|decl
argument_list|,
name|file_scope
argument_list|,
comment|/*invisible=*/
name|false
argument_list|,
comment|/*nested=*/
name|true
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
else|else
block|{
name|tree
name|newtype
init|=
name|default_function_type
decl_stmt|;
if|if
condition|(
name|b
operator|->
name|type
condition|)
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|b
operator|->
name|type
expr_stmt|;
comment|/* Implicit declaration of a function already declared 	     (somehow) in a different scope, or as a built-in. 	     If this is the first time this has happened, warn; 	     then recycle the old declaration but with the new type.  */
if|if
condition|(
operator|!
name|C_DECL_IMPLICIT
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|implicit_decl_warning
argument_list|(
name|functionid
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|C_DECL_IMPLICIT
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|DECL_BUILT_IN
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|newtype
operator|=
name|build_type_attribute_variant
argument_list|(
name|newtype
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|comptypes
argument_list|(
name|newtype
argument_list|,
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"incompatible implicit declaration of built-in"
literal|" function %qD"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|newtype
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|comptypes
argument_list|(
name|newtype
argument_list|,
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"incompatible implicit declaration of function %qD"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|locate_old_decl
argument_list|(
name|decl
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
block|}
name|b
operator|->
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|newtype
expr_stmt|;
name|bind
argument_list|(
name|functionid
argument_list|,
name|decl
argument_list|,
name|current_scope
argument_list|,
comment|/*invisible=*/
name|false
argument_list|,
comment|/*nested=*/
name|true
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
block|}
comment|/* Not seen before.  */
name|decl
operator|=
name|build_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|functionid
argument_list|,
name|default_function_type
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|C_DECL_IMPLICIT
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|implicit_decl_warning
argument_list|(
name|functionid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|asmspec_tree
operator|=
name|maybe_apply_renaming_pragma
argument_list|(
name|decl
argument_list|,
comment|/*asmname=*/
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|asmspec_tree
condition|)
name|set_user_assembler_name
argument_list|(
name|decl
argument_list|,
name|TREE_STRING_POINTER
argument_list|(
name|asmspec_tree
argument_list|)
argument_list|)
expr_stmt|;
comment|/* C89 says implicit declarations are in the innermost block.      So we record the decl in the standard fashion.  */
name|decl
operator|=
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* No need to call objc_check_decl here - it's a function type.  */
name|rest_of_decl_compilation
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Write a record describing this implicit function declaration      to the prototypes file (if requested).  */
name|gen_aux_info_record
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Possibly apply some default attributes to this implicit declaration.  */
name|decl_attributes
argument_list|(
operator|&
name|decl
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_block

begin_comment
comment|/* Issue an error message for a reference to an undeclared variable    ID, including a reference to a builtin outside of function-call    context.  Establish a binding of the identifier to error_mark_node    in an appropriate scope, which will suppress further errors for the    same identifier.  The error message should be given location LOC.  */
end_comment

begin_function
name|void
name|undeclared_variable
parameter_list|(
name|tree
name|id
parameter_list|,
name|location_t
name|loc
parameter_list|)
block|{
specifier|static
name|bool
name|already
init|=
name|false
decl_stmt|;
name|struct
name|c_scope
modifier|*
name|scope
decl_stmt|;
if|if
condition|(
name|current_function_decl
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"%H%qE undeclared here (not in a function)"
argument_list|,
operator|&
name|loc
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|scope
operator|=
name|current_scope
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"%H%qE undeclared (first use in this function)"
argument_list|,
operator|&
name|loc
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|already
condition|)
block|{
name|error
argument_list|(
literal|"%H(Each undeclared identifier is reported only once"
argument_list|,
operator|&
name|loc
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"%Hfor each function it appears in.)"
argument_list|,
operator|&
name|loc
argument_list|)
expr_stmt|;
name|already
operator|=
name|true
expr_stmt|;
block|}
comment|/* If we are parsing old-style parameter decls, current_function_decl 	 will be nonnull but current_function_scope will be null.  */
name|scope
operator|=
name|current_function_scope
condition|?
name|current_function_scope
else|:
name|current_scope
expr_stmt|;
block|}
name|bind
argument_list|(
name|id
argument_list|,
name|error_mark_node
argument_list|,
name|scope
argument_list|,
comment|/*invisible=*/
name|false
argument_list|,
comment|/*nested=*/
name|false
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutine of lookup_label, declare_label, define_label: construct a    LABEL_DECL with all the proper frills.  */
end_comment

begin_function
specifier|static
name|tree
name|make_label
parameter_list|(
name|tree
name|name
parameter_list|,
name|location_t
name|location
parameter_list|)
block|{
name|tree
name|label
init|=
name|build_decl
argument_list|(
name|LABEL_DECL
argument_list|,
name|name
argument_list|,
name|void_type_node
argument_list|)
decl_stmt|;
name|DECL_CONTEXT
argument_list|(
name|label
argument_list|)
operator|=
name|current_function_decl
expr_stmt|;
name|DECL_MODE
argument_list|(
name|label
argument_list|)
operator|=
name|VOIDmode
expr_stmt|;
name|DECL_SOURCE_LOCATION
argument_list|(
name|label
argument_list|)
operator|=
name|location
expr_stmt|;
return|return
name|label
return|;
block|}
end_function

begin_comment
comment|/* Get the LABEL_DECL corresponding to identifier NAME as a label.    Create one if none exists so far for the current function.    This is called when a label is used in a goto expression or    has its address taken.  */
end_comment

begin_function
name|tree
name|lookup_label
parameter_list|(
name|tree
name|name
parameter_list|)
block|{
name|tree
name|label
decl_stmt|;
if|if
condition|(
name|current_function_decl
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"label %qE referenced outside of any function"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Use a label already defined or ref'd with this name, but not if      it is inherited from a containing function and wasn't declared      using __label__.  */
name|label
operator|=
name|I_LABEL_DECL
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|label
operator|&&
operator|(
name|DECL_CONTEXT
argument_list|(
name|label
argument_list|)
operator|==
name|current_function_decl
operator|||
name|C_DECLARED_LABEL_FLAG
argument_list|(
name|label
argument_list|)
operator|)
condition|)
block|{
comment|/* If the label has only been declared, update its apparent 	 location to point here, for better diagnostics if it 	 turns out not to have been defined.  */
if|if
condition|(
operator|!
name|TREE_USED
argument_list|(
name|label
argument_list|)
condition|)
name|DECL_SOURCE_LOCATION
argument_list|(
name|label
argument_list|)
operator|=
name|input_location
expr_stmt|;
return|return
name|label
return|;
block|}
comment|/* No label binding for that identifier; make one.  */
name|label
operator|=
name|make_label
argument_list|(
name|name
argument_list|,
name|input_location
argument_list|)
expr_stmt|;
comment|/* Ordinary labels go in the current function scope.  */
name|bind
argument_list|(
name|name
argument_list|,
name|label
argument_list|,
name|current_function_scope
argument_list|,
comment|/*invisible=*/
name|false
argument_list|,
comment|/*nested=*/
name|false
argument_list|)
expr_stmt|;
return|return
name|label
return|;
block|}
end_function

begin_comment
comment|/* Make a label named NAME in the current function, shadowing silently    any that may be inherited from containing functions or containing    scopes.  This is called for __label__ declarations.  */
end_comment

begin_function
name|tree
name|declare_label
parameter_list|(
name|tree
name|name
parameter_list|)
block|{
name|struct
name|c_binding
modifier|*
name|b
init|=
name|I_LABEL_BINDING
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|tree
name|label
decl_stmt|;
comment|/* Check to make sure that the label hasn't already been declared      at this scope */
if|if
condition|(
name|b
operator|&&
name|B_IN_CURRENT_SCOPE
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"duplicate label declaration %qE"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|locate_old_decl
argument_list|(
name|b
operator|->
name|decl
argument_list|,
name|error
argument_list|)
expr_stmt|;
comment|/* Just use the previous declaration.  */
return|return
name|b
operator|->
name|decl
return|;
block|}
name|label
operator|=
name|make_label
argument_list|(
name|name
argument_list|,
name|input_location
argument_list|)
expr_stmt|;
name|C_DECLARED_LABEL_FLAG
argument_list|(
name|label
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Declared labels go in the current scope.  */
name|bind
argument_list|(
name|name
argument_list|,
name|label
argument_list|,
name|current_scope
argument_list|,
comment|/*invisible=*/
name|false
argument_list|,
comment|/*nested=*/
name|false
argument_list|)
expr_stmt|;
return|return
name|label
return|;
block|}
end_function

begin_comment
comment|/* Define a label, specifying the location in the source file.    Return the LABEL_DECL node for the label, if the definition is valid.    Otherwise return 0.  */
end_comment

begin_function
name|tree
name|define_label
parameter_list|(
name|location_t
name|location
parameter_list|,
name|tree
name|name
parameter_list|)
block|{
comment|/* Find any preexisting label with this name.  It is an error      if that label has already been defined in this function, or      if there is a containing function with a declared label with      the same name.  */
name|tree
name|label
init|=
name|I_LABEL_DECL
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|struct
name|c_label_list
modifier|*
name|nlist_se
decl_stmt|,
modifier|*
name|nlist_vm
decl_stmt|;
if|if
condition|(
name|label
operator|&&
operator|(
operator|(
name|DECL_CONTEXT
argument_list|(
name|label
argument_list|)
operator|==
name|current_function_decl
operator|&&
name|DECL_INITIAL
argument_list|(
name|label
argument_list|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|DECL_CONTEXT
argument_list|(
name|label
argument_list|)
operator|!=
name|current_function_decl
operator|&&
name|C_DECLARED_LABEL_FLAG
argument_list|(
name|label
argument_list|)
operator|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"%Hduplicate label %qD"
argument_list|,
operator|&
name|location
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|locate_old_decl
argument_list|(
name|label
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|label
operator|&&
name|DECL_CONTEXT
argument_list|(
name|label
argument_list|)
operator|==
name|current_function_decl
condition|)
block|{
comment|/* The label has been used or declared already in this function, 	 but not defined.  Update its location to point to this 	 definition.  */
if|if
condition|(
name|C_DECL_UNDEFINABLE_STMT_EXPR
argument_list|(
name|label
argument_list|)
condition|)
name|error
argument_list|(
literal|"%Jjump into statement expression"
argument_list|,
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
name|C_DECL_UNDEFINABLE_VM
argument_list|(
name|label
argument_list|)
condition|)
name|error
argument_list|(
literal|"%Jjump into scope of identifier with variably modified type"
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|DECL_SOURCE_LOCATION
argument_list|(
name|label
argument_list|)
operator|=
name|location
expr_stmt|;
block|}
else|else
block|{
comment|/* No label binding for that identifier; make one.  */
name|label
operator|=
name|make_label
argument_list|(
name|name
argument_list|,
name|location
argument_list|)
expr_stmt|;
comment|/* Ordinary labels go in the current function scope.  */
name|bind
argument_list|(
name|name
argument_list|,
name|label
argument_list|,
name|current_function_scope
argument_list|,
comment|/*invisible=*/
name|false
argument_list|,
comment|/*nested=*/
name|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|in_system_header
operator|&&
name|lookup_name
argument_list|(
name|name
argument_list|)
condition|)
name|warning
argument_list|(
name|OPT_Wtraditional
argument_list|,
literal|"%Htraditional C lacks a separate namespace "
literal|"for labels, identifier %qE conflicts"
argument_list|,
operator|&
name|location
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|nlist_se
operator|=
name|XOBNEW
argument_list|(
operator|&
name|parser_obstack
argument_list|,
expr|struct
name|c_label_list
argument_list|)
expr_stmt|;
name|nlist_se
operator|->
name|next
operator|=
name|label_context_stack_se
operator|->
name|labels_def
expr_stmt|;
name|nlist_se
operator|->
name|label
operator|=
name|label
expr_stmt|;
name|label_context_stack_se
operator|->
name|labels_def
operator|=
name|nlist_se
expr_stmt|;
name|nlist_vm
operator|=
name|XOBNEW
argument_list|(
operator|&
name|parser_obstack
argument_list|,
expr|struct
name|c_label_list
argument_list|)
expr_stmt|;
name|nlist_vm
operator|->
name|next
operator|=
name|label_context_stack_vm
operator|->
name|labels_def
expr_stmt|;
name|nlist_vm
operator|->
name|label
operator|=
name|label
expr_stmt|;
name|label_context_stack_vm
operator|->
name|labels_def
operator|=
name|nlist_vm
expr_stmt|;
comment|/* Mark label as having been defined.  */
name|DECL_INITIAL
argument_list|(
name|label
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
return|return
name|label
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given NAME, an IDENTIFIER_NODE,    return the structure (or union or enum) definition for that name.    If THISLEVEL_ONLY is nonzero, searches only the current_scope.    CODE says which kind of type the caller wants;    it is RECORD_TYPE or UNION_TYPE or ENUMERAL_TYPE.    If the wrong kind of type is found, an error is reported.  */
end_comment

begin_function
specifier|static
name|tree
name|lookup_tag
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|name
parameter_list|,
name|int
name|thislevel_only
parameter_list|)
block|{
name|struct
name|c_binding
modifier|*
name|b
init|=
name|I_TAG_BINDING
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|int
name|thislevel
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|b
operator|||
operator|!
name|b
operator|->
name|decl
condition|)
return|return
literal|0
return|;
comment|/* We only care about whether it's in this level if      thislevel_only was set or it might be a type clash.  */
if|if
condition|(
name|thislevel_only
operator|||
name|TREE_CODE
argument_list|(
name|b
operator|->
name|decl
argument_list|)
operator|!=
name|code
condition|)
block|{
comment|/* For our purposes, a tag in the external scope is the same as 	 a tag in the file scope.  (Primarily relevant to Objective-C 	 and its builtin structure tags, which get pushed before the 	 file scope is created.)  */
if|if
condition|(
name|B_IN_CURRENT_SCOPE
argument_list|(
name|b
argument_list|)
operator|||
operator|(
name|current_scope
operator|==
name|file_scope
operator|&&
name|B_IN_EXTERNAL_SCOPE
argument_list|(
name|b
argument_list|)
operator|)
condition|)
name|thislevel
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|thislevel_only
operator|&&
operator|!
name|thislevel
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|b
operator|->
name|decl
argument_list|)
operator|!=
name|code
condition|)
block|{
comment|/* Definition isn't the kind we were looking for.  */
name|pending_invalid_xref
operator|=
name|name
expr_stmt|;
name|pending_invalid_xref_location
operator|=
name|input_location
expr_stmt|;
comment|/* If in the same binding level as a declaration as a tag 	 of a different type, this must not be allowed to 	 shadow that tag, so give the error immediately. 	 (For example, "struct foo; union foo;" is invalid.)  */
if|if
condition|(
name|thislevel
condition|)
name|pending_xref_error
argument_list|()
expr_stmt|;
block|}
return|return
name|b
operator|->
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Print an error message now    for a recent invalid struct, union or enum cross reference.    We don't print them immediately because they are not invalid    when used in the `struct foo;' construct for shadowing.  */
end_comment

begin_function
name|void
name|pending_xref_error
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|pending_invalid_xref
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|"%H%qE defined as wrong kind of tag"
argument_list|,
operator|&
name|pending_invalid_xref_location
argument_list|,
name|pending_invalid_xref
argument_list|)
expr_stmt|;
name|pending_invalid_xref
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Look up NAME in the current scope and its superiors    in the namespace of variables, functions and typedefs.    Return a ..._DECL node of some kind representing its definition,    or return 0 if it is undefined.  */
end_comment

begin_function
name|tree
name|lookup_name
parameter_list|(
name|tree
name|name
parameter_list|)
block|{
name|struct
name|c_binding
modifier|*
name|b
init|=
name|I_SYMBOL_BINDING
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|b
operator|&&
operator|!
name|b
operator|->
name|invisible
condition|)
return|return
name|b
operator|->
name|decl
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Similar to `lookup_name' but look only at the indicated scope.  */
end_comment

begin_function
specifier|static
name|tree
name|lookup_name_in_scope
parameter_list|(
name|tree
name|name
parameter_list|,
name|struct
name|c_scope
modifier|*
name|scope
parameter_list|)
block|{
name|struct
name|c_binding
modifier|*
name|b
decl_stmt|;
for|for
control|(
name|b
operator|=
name|I_SYMBOL_BINDING
argument_list|(
name|name
argument_list|)
init|;
name|b
condition|;
name|b
operator|=
name|b
operator|->
name|shadowed
control|)
if|if
condition|(
name|B_IN_SCOPE
argument_list|(
name|b
argument_list|,
name|scope
argument_list|)
condition|)
return|return
name|b
operator|->
name|decl
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create the predefined scalar types of C,    and some nodes representing standard constants (0, 1, (void *) 0).    Initialize the global scope.    Make definitions for built-in primitive functions.  */
end_comment

begin_function
name|void
name|c_init_decl_processing
parameter_list|(
name|void
parameter_list|)
block|{
name|location_t
name|save_loc
init|=
name|input_location
decl_stmt|;
comment|/* Initialize reserved words for parser.  */
name|c_parse_init
argument_list|()
expr_stmt|;
name|current_function_decl
operator|=
literal|0
expr_stmt|;
name|gcc_obstack_init
argument_list|(
operator|&
name|parser_obstack
argument_list|)
expr_stmt|;
comment|/* Make the externals scope.  */
name|push_scope
argument_list|()
expr_stmt|;
name|external_scope
operator|=
name|current_scope
expr_stmt|;
comment|/* Declarations from c_common_nodes_and_builtins must not be associated      with this input file, lest we get differences between using and not      using preprocessed headers.  */
ifdef|#
directive|ifdef
name|USE_MAPPED_LOCATION
name|input_location
operator|=
name|BUILTINS_LOCATION
expr_stmt|;
else|#
directive|else
name|input_location
operator|.
name|file
operator|=
literal|"<built-in>"
expr_stmt|;
name|input_location
operator|.
name|line
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|build_common_tree_nodes
argument_list|(
name|flag_signed_char
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|c_common_nodes_and_builtins
argument_list|()
expr_stmt|;
comment|/* In C, comparisons and TRUTH_* expressions have type int.  */
name|truthvalue_type_node
operator|=
name|integer_type_node
expr_stmt|;
name|truthvalue_true_node
operator|=
name|integer_one_node
expr_stmt|;
name|truthvalue_false_node
operator|=
name|integer_zero_node
expr_stmt|;
comment|/* Even in C99, which has a real boolean type.  */
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"_Bool"
argument_list|)
argument_list|,
name|boolean_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|input_location
operator|=
name|save_loc
expr_stmt|;
name|pedantic_lvalues
operator|=
name|true
expr_stmt|;
name|make_fname_decl
operator|=
name|c_make_fname_decl
expr_stmt|;
name|start_fname_decls
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create the VAR_DECL for __FUNCTION__ etc. ID is the name to give the    decl, NAME is the initialization string and TYPE_DEP indicates whether    NAME depended on the type of the function.  As we don't yet implement    delayed emission of static data, we mark the decl as emitted    so it is not placed in the output.  Anything using it must therefore pull    out the STRING_CST initializer directly.  FIXME.  */
end_comment

begin_function
specifier|static
name|tree
name|c_make_fname_decl
parameter_list|(
name|tree
name|id
parameter_list|,
name|int
name|type_dep
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|fname_as_string
argument_list|(
name|type_dep
argument_list|)
decl_stmt|;
name|tree
name|decl
decl_stmt|,
name|type
decl_stmt|,
name|init
decl_stmt|;
name|size_t
name|length
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|type
operator|=
name|build_array_type
argument_list|(
name|char_type_node
argument_list|,
name|build_index_type
argument_list|(
name|size_int
argument_list|(
name|length
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|c_build_qualified_type
argument_list|(
name|type
argument_list|,
name|TYPE_QUAL_CONST
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|id
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|init
operator|=
name|build_string
argument_list|(
name|length
operator|+
literal|1
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|name
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
operator|=
name|type
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|init
expr_stmt|;
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|current_function_decl
comment|/* For invalid programs like this:                   void foo()          const char* p = __FUNCTION__;          	 the __FUNCTION__ is believed to appear in K&R style function 	 parameter declarator.  In that case we still don't have 	 function_scope.  */
operator|&&
operator|(
operator|!
name|errorcount
operator|||
name|current_function_scope
operator|)
condition|)
block|{
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|current_function_decl
expr_stmt|;
name|bind
argument_list|(
name|id
argument_list|,
name|decl
argument_list|,
name|current_function_scope
argument_list|,
comment|/*invisible=*/
name|false
argument_list|,
comment|/*nested=*/
name|false
argument_list|)
expr_stmt|;
block|}
name|finish_decl
argument_list|(
name|decl
argument_list|,
name|init
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Return a definition for a builtin function named NAME and whose data type    is TYPE.  TYPE should be a function type with argument types.    FUNCTION_CODE tells later passes how to compile calls to this function.    See tree.h for its possible values.     If LIBRARY_NAME is nonzero, use that for DECL_ASSEMBLER_NAME,    the name to be called if we can't opencode the function.  If    ATTRS is nonzero, use that for the function's attribute list.  */
end_comment

begin_function
name|tree
name|builtin_function
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|tree
name|type
parameter_list|,
name|int
name|function_code
parameter_list|,
name|enum
name|built_in_class
name|cl
parameter_list|,
specifier|const
name|char
modifier|*
name|library_name
parameter_list|,
name|tree
name|attrs
parameter_list|)
block|{
name|tree
name|id
init|=
name|get_identifier
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|tree
name|decl
init|=
name|build_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|id
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
operator|=
name|GGC_CNEW
argument_list|(
expr|struct
name|lang_decl
argument_list|)
expr_stmt|;
name|DECL_BUILT_IN_CLASS
argument_list|(
name|decl
argument_list|)
operator|=
name|cl
expr_stmt|;
name|DECL_FUNCTION_CODE
argument_list|(
name|decl
argument_list|)
operator|=
name|function_code
expr_stmt|;
name|C_DECL_BUILTIN_PROTOTYPE
argument_list|(
name|decl
argument_list|)
operator|=
operator|(
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|library_name
condition|)
name|SET_DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|,
name|get_identifier
argument_list|(
name|library_name
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Should never be called on a symbol with a preexisting meaning.  */
name|gcc_assert
argument_list|(
operator|!
name|I_SYMBOL_BINDING
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
name|bind
argument_list|(
name|id
argument_list|,
name|decl
argument_list|,
name|external_scope
argument_list|,
comment|/*invisible=*/
name|true
argument_list|,
comment|/*nested=*/
name|false
argument_list|)
expr_stmt|;
comment|/* Builtins in the implementation namespace are made visible without      needing to be explicitly declared.  See push_file_scope.  */
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
operator|(
name|name
index|[
literal|1
index|]
operator|==
literal|'_'
operator|||
name|ISUPPER
argument_list|(
name|name
index|[
literal|1
index|]
argument_list|)
operator|)
condition|)
block|{
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
operator|=
name|visible_builtins
expr_stmt|;
name|visible_builtins
operator|=
name|decl
expr_stmt|;
block|}
comment|/* Possibly apply some default attributes to this built-in function.  */
if|if
condition|(
name|attrs
condition|)
name|decl_attributes
argument_list|(
operator|&
name|decl
argument_list|,
name|attrs
argument_list|,
name|ATTR_FLAG_BUILT_IN
argument_list|)
expr_stmt|;
else|else
name|decl_attributes
argument_list|(
operator|&
name|decl
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Called when a declaration is seen that contains no names to declare.    If its type is a reference to a structure, union or enum inherited    from a containing scope, shadow that tag name for the current scope    with a forward reference.    If its type defines a new named structure or union    or defines an enum, it is valid but we need not do anything here.    Otherwise, it is an error.  */
end_comment

begin_function
name|void
name|shadow_tag
parameter_list|(
specifier|const
name|struct
name|c_declspecs
modifier|*
name|declspecs
parameter_list|)
block|{
name|shadow_tag_warned
argument_list|(
name|declspecs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* WARNED is 1 if we have done a pedwarn, 2 if we have done a warning,    but no pedwarn.  */
end_comment

begin_function
name|void
name|shadow_tag_warned
parameter_list|(
specifier|const
name|struct
name|c_declspecs
modifier|*
name|declspecs
parameter_list|,
name|int
name|warned
parameter_list|)
block|{
name|bool
name|found_tag
init|=
name|false
decl_stmt|;
if|if
condition|(
name|declspecs
operator|->
name|type
operator|&&
operator|!
name|declspecs
operator|->
name|default_int_p
operator|&&
operator|!
name|declspecs
operator|->
name|typedef_p
condition|)
block|{
name|tree
name|value
init|=
name|declspecs
operator|->
name|type
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|RECORD_TYPE
operator|||
name|code
operator|==
name|UNION_TYPE
operator|||
name|code
operator|==
name|ENUMERAL_TYPE
condition|)
comment|/* Used to test also that TYPE_SIZE (value) != 0. 	   That caused warning for `struct foo;' at top level in the file.  */
block|{
name|tree
name|name
init|=
name|TYPE_NAME
argument_list|(
name|value
argument_list|)
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|found_tag
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|name
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|warned
operator|!=
literal|1
operator|&&
name|code
operator|!=
name|ENUMERAL_TYPE
condition|)
comment|/* Empty unnamed enum OK */
block|{
name|pedwarn
argument_list|(
literal|"unnamed struct/union that defines no instances"
argument_list|)
expr_stmt|;
name|warned
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|declspecs
operator|->
name|tag_defined_p
operator|&&
name|declspecs
operator|->
name|storage_class
operator|!=
name|csc_none
condition|)
block|{
if|if
condition|(
name|warned
operator|!=
literal|1
condition|)
name|pedwarn
argument_list|(
literal|"empty declaration with storage class specifier "
literal|"does not redeclare tag"
argument_list|)
expr_stmt|;
name|warned
operator|=
literal|1
expr_stmt|;
name|pending_xref_error
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|declspecs
operator|->
name|tag_defined_p
operator|&&
operator|(
name|declspecs
operator|->
name|const_p
operator|||
name|declspecs
operator|->
name|volatile_p
operator|||
name|declspecs
operator|->
name|restrict_p
operator|)
condition|)
block|{
if|if
condition|(
name|warned
operator|!=
literal|1
condition|)
name|pedwarn
argument_list|(
literal|"empty declaration with type qualifier "
literal|"does not redeclare tag"
argument_list|)
expr_stmt|;
name|warned
operator|=
literal|1
expr_stmt|;
name|pending_xref_error
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|pending_invalid_xref
operator|=
literal|0
expr_stmt|;
name|t
operator|=
name|lookup_tag
argument_list|(
name|code
argument_list|,
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
literal|0
condition|)
block|{
name|t
operator|=
name|make_node
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|pushtag
argument_list|(
name|name
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|warned
operator|!=
literal|1
operator|&&
operator|!
name|in_system_header
condition|)
block|{
name|pedwarn
argument_list|(
literal|"useless type name in empty declaration"
argument_list|)
expr_stmt|;
name|warned
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|warned
operator|!=
literal|1
operator|&&
operator|!
name|in_system_header
operator|&&
name|declspecs
operator|->
name|typedef_p
condition|)
block|{
name|pedwarn
argument_list|(
literal|"useless type name in empty declaration"
argument_list|)
expr_stmt|;
name|warned
operator|=
literal|1
expr_stmt|;
block|}
name|pending_invalid_xref
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|declspecs
operator|->
name|inline_p
condition|)
block|{
name|error
argument_list|(
literal|"%<inline%> in empty declaration"
argument_list|)
expr_stmt|;
name|warned
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|current_scope
operator|==
name|file_scope
operator|&&
name|declspecs
operator|->
name|storage_class
operator|==
name|csc_auto
condition|)
block|{
name|error
argument_list|(
literal|"%<auto%> in file-scope empty declaration"
argument_list|)
expr_stmt|;
name|warned
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|current_scope
operator|==
name|file_scope
operator|&&
name|declspecs
operator|->
name|storage_class
operator|==
name|csc_register
condition|)
block|{
name|error
argument_list|(
literal|"%<register%> in file-scope empty declaration"
argument_list|)
expr_stmt|;
name|warned
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|warned
operator|&&
operator|!
name|in_system_header
operator|&&
name|declspecs
operator|->
name|storage_class
operator|!=
name|csc_none
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"useless storage class specifier in empty declaration"
argument_list|)
expr_stmt|;
name|warned
operator|=
literal|2
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|warned
operator|&&
operator|!
name|in_system_header
operator|&&
name|declspecs
operator|->
name|thread_p
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"useless %<__thread%> in empty declaration"
argument_list|)
expr_stmt|;
name|warned
operator|=
literal|2
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|warned
operator|&&
operator|!
name|in_system_header
operator|&&
operator|(
name|declspecs
operator|->
name|const_p
operator|||
name|declspecs
operator|->
name|volatile_p
operator|||
name|declspecs
operator|->
name|restrict_p
operator|)
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"useless type qualifier in empty declaration"
argument_list|)
expr_stmt|;
name|warned
operator|=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|warned
operator|!=
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|found_tag
condition|)
name|pedwarn
argument_list|(
literal|"empty declaration"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the qualifiers from SPECS as a bitwise OR of TYPE_QUAL_*    bits.  SPECS represents declaration specifiers that the grammar    only permits to contain type qualifiers and attributes.  */
end_comment

begin_function
name|int
name|quals_from_declspecs
parameter_list|(
specifier|const
name|struct
name|c_declspecs
modifier|*
name|specs
parameter_list|)
block|{
name|int
name|quals
init|=
operator|(
operator|(
name|specs
operator|->
name|const_p
condition|?
name|TYPE_QUAL_CONST
else|:
literal|0
operator|)
operator||
operator|(
name|specs
operator|->
name|volatile_p
condition|?
name|TYPE_QUAL_VOLATILE
else|:
literal|0
operator|)
operator||
operator|(
name|specs
operator|->
name|restrict_p
condition|?
name|TYPE_QUAL_RESTRICT
else|:
literal|0
operator|)
operator|)
decl_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|specs
operator|->
name|type
operator|&&
operator|!
name|specs
operator|->
name|decl_attr
operator|&&
name|specs
operator|->
name|typespec_word
operator|==
name|cts_none
operator|&&
name|specs
operator|->
name|storage_class
operator|==
name|csc_none
operator|&&
operator|!
name|specs
operator|->
name|typedef_p
operator|&&
operator|!
name|specs
operator|->
name|explicit_signed_p
operator|&&
operator|!
name|specs
operator|->
name|deprecated_p
operator|&&
operator|!
name|specs
operator|->
name|long_p
operator|&&
operator|!
name|specs
operator|->
name|long_long_p
operator|&&
operator|!
name|specs
operator|->
name|short_p
operator|&&
operator|!
name|specs
operator|->
name|signed_p
operator|&&
operator|!
name|specs
operator|->
name|unsigned_p
operator|&&
operator|!
name|specs
operator|->
name|complex_p
operator|&&
operator|!
name|specs
operator|->
name|inline_p
operator|&&
operator|!
name|specs
operator|->
name|thread_p
argument_list|)
expr_stmt|;
return|return
name|quals
return|;
block|}
end_function

begin_comment
comment|/* Construct an array declarator.  EXPR is the expression inside [],    or NULL_TREE.  QUALS are the type qualifiers inside the [] (to be    applied to the pointer to which a parameter array is converted).    STATIC_P is true if "static" is inside the [], false otherwise.    VLA_UNSPEC_P is true if the array is [*], a VLA of unspecified    length which is nevertheless a complete type, false otherwise.  The    field for the contained declarator is left to be filled in by    set_array_declarator_inner.  */
end_comment

begin_function
name|struct
name|c_declarator
modifier|*
name|build_array_declarator
parameter_list|(
name|tree
name|expr
parameter_list|,
name|struct
name|c_declspecs
modifier|*
name|quals
parameter_list|,
name|bool
name|static_p
parameter_list|,
name|bool
name|vla_unspec_p
parameter_list|)
block|{
name|struct
name|c_declarator
modifier|*
name|declarator
init|=
name|XOBNEW
argument_list|(
operator|&
name|parser_obstack
argument_list|,
expr|struct
name|c_declarator
argument_list|)
decl_stmt|;
name|declarator
operator|->
name|kind
operator|=
name|cdk_array
expr_stmt|;
name|declarator
operator|->
name|declarator
operator|=
literal|0
expr_stmt|;
name|declarator
operator|->
name|u
operator|.
name|array
operator|.
name|dimen
operator|=
name|expr
expr_stmt|;
if|if
condition|(
name|quals
condition|)
block|{
name|declarator
operator|->
name|u
operator|.
name|array
operator|.
name|attrs
operator|=
name|quals
operator|->
name|attrs
expr_stmt|;
name|declarator
operator|->
name|u
operator|.
name|array
operator|.
name|quals
operator|=
name|quals_from_declspecs
argument_list|(
name|quals
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|declarator
operator|->
name|u
operator|.
name|array
operator|.
name|attrs
operator|=
name|NULL_TREE
expr_stmt|;
name|declarator
operator|->
name|u
operator|.
name|array
operator|.
name|quals
operator|=
literal|0
expr_stmt|;
block|}
name|declarator
operator|->
name|u
operator|.
name|array
operator|.
name|static_p
operator|=
name|static_p
expr_stmt|;
name|declarator
operator|->
name|u
operator|.
name|array
operator|.
name|vla_unspec_p
operator|=
name|vla_unspec_p
expr_stmt|;
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|flag_isoc99
condition|)
block|{
if|if
condition|(
name|static_p
operator|||
name|quals
operator|!=
name|NULL
condition|)
name|pedwarn
argument_list|(
literal|"ISO C90 does not support %<static%> or type "
literal|"qualifiers in parameter array declarators"
argument_list|)
expr_stmt|;
if|if
condition|(
name|vla_unspec_p
condition|)
name|pedwarn
argument_list|(
literal|"ISO C90 does not support %<[*]%> array declarators"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vla_unspec_p
condition|)
block|{
if|if
condition|(
operator|!
name|current_scope
operator|->
name|parm_flag
condition|)
block|{
comment|/* C99 6.7.5.2p4 */
name|error
argument_list|(
literal|"%<[*]%> not allowed in other than function prototype scope"
argument_list|)
expr_stmt|;
name|declarator
operator|->
name|u
operator|.
name|array
operator|.
name|vla_unspec_p
operator|=
name|false
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|current_scope
operator|->
name|had_vla_unspec
operator|=
name|true
expr_stmt|;
block|}
return|return
name|declarator
return|;
block|}
end_function

begin_comment
comment|/* Set the contained declarator of an array declarator.  DECL is the    declarator, as constructed by build_array_declarator; INNER is what    appears on the left of the [].  ABSTRACT_P is true if it is an    abstract declarator, false otherwise; this is used to reject static    and type qualifiers in abstract declarators, where they are not in    the C99 grammar (subject to possible change in DR#289).  */
end_comment

begin_function
name|struct
name|c_declarator
modifier|*
name|set_array_declarator_inner
parameter_list|(
name|struct
name|c_declarator
modifier|*
name|decl
parameter_list|,
name|struct
name|c_declarator
modifier|*
name|inner
parameter_list|,
name|bool
name|abstract_p
parameter_list|)
block|{
name|decl
operator|->
name|declarator
operator|=
name|inner
expr_stmt|;
if|if
condition|(
name|abstract_p
operator|&&
operator|(
name|decl
operator|->
name|u
operator|.
name|array
operator|.
name|quals
operator|!=
name|TYPE_UNQUALIFIED
operator|||
name|decl
operator|->
name|u
operator|.
name|array
operator|.
name|attrs
operator|!=
name|NULL_TREE
operator|||
name|decl
operator|->
name|u
operator|.
name|array
operator|.
name|static_p
operator|)
condition|)
name|error
argument_list|(
literal|"static or type qualifiers in abstract declarator"
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* INIT is a constructor that forms DECL's initializer.  If the final    element initializes a flexible array field, add the size of that    initializer to DECL's size.  */
end_comment

begin_function
specifier|static
name|void
name|add_flexible_array_elts_to_size
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|init
parameter_list|)
block|{
name|tree
name|elt
decl_stmt|,
name|type
decl_stmt|;
if|if
condition|(
name|VEC_empty
argument_list|(
name|constructor_elt
argument_list|,
name|CONSTRUCTOR_ELTS
argument_list|(
name|init
argument_list|)
argument_list|)
condition|)
return|return;
name|elt
operator|=
name|VEC_last
argument_list|(
name|constructor_elt
argument_list|,
name|CONSTRUCTOR_ELTS
argument_list|(
name|init
argument_list|)
argument_list|)
operator|->
name|value
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|elt
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|TYPE_MAX_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|complete_array_type
argument_list|(
operator|&
name|type
argument_list|,
name|elt
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_SIZE_UNIT
argument_list|(
name|decl
argument_list|)
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|DECL_SIZE_UNIT
argument_list|(
name|decl
argument_list|)
argument_list|,
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Decode a "typename", such as "int **", returning a ..._TYPE node.  */
end_comment

begin_function
name|tree
name|groktypename
parameter_list|(
name|struct
name|c_type_name
modifier|*
name|type_name
parameter_list|)
block|{
name|tree
name|type
decl_stmt|;
name|tree
name|attrs
init|=
name|type_name
operator|->
name|specs
operator|->
name|attrs
decl_stmt|;
name|type_name
operator|->
name|specs
operator|->
name|attrs
operator|=
name|NULL_TREE
expr_stmt|;
name|type
operator|=
name|grokdeclarator
argument_list|(
name|type_name
operator|->
name|declarator
argument_list|,
name|type_name
operator|->
name|specs
argument_list|,
name|TYPENAME
argument_list|,
name|false
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Apply attributes.  */
name|decl_attributes
argument_list|(
operator|&
name|type
argument_list|,
name|attrs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Decode a declarator in an ordinary declaration or data definition.    This is called as soon as the type information and variable name    have been parsed, before parsing the initializer if any.    Here we create the ..._DECL node, fill in its type,    and put it on the list of decls for the current context.    The ..._DECL node is returned as the value.     Exception: for arrays where the length is not specified,    the type is left null, to be filled in by `finish_decl'.     Function definitions do not come here; they go to start_function    instead.  However, external and forward declarations of functions    do go through here.  Structure field declarations are done by    grokfield and not through here.  */
end_comment

begin_function
name|tree
name|start_decl
parameter_list|(
name|struct
name|c_declarator
modifier|*
name|declarator
parameter_list|,
name|struct
name|c_declspecs
modifier|*
name|declspecs
parameter_list|,
name|bool
name|initialized
parameter_list|,
name|tree
name|attributes
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|;
name|tree
name|tem
decl_stmt|;
comment|/* An object declared as __attribute__((deprecated)) suppresses      warnings of uses of other deprecated items.  */
comment|/* APPLE LOCAL begin "unavailable" attribute (radar 2809697) */
comment|/* An object declared as __attribute__((unavailable)) suppresses      any reports of being declared with unavailable or deprecated      items.  An object declared as __attribute__((deprecated))      suppresses warnings of uses of other deprecated items.  */
ifdef|#
directive|ifdef
name|A_LESS_INEFFICENT_WAY
comment|/* which I really don't want to do!  */
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"deprecated"
argument_list|,
name|attributes
argument_list|)
condition|)
name|deprecated_state
operator|=
name|DEPRECATED_SUPPRESS
expr_stmt|;
elseif|else
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"unavailable"
argument_list|,
name|attributes
argument_list|)
condition|)
name|deprecated_state
operator|=
name|DEPRECATED_UNAVAILABLE_SUPPRESS
expr_stmt|;
else|#
directive|else
comment|/* a more efficient way doing what lookup_attribute would do */
name|tree
name|a
decl_stmt|;
for|for
control|(
name|a
operator|=
name|attributes
init|;
name|a
condition|;
name|a
operator|=
name|TREE_CHAIN
argument_list|(
name|a
argument_list|)
control|)
block|{
name|tree
name|name
init|=
name|TREE_PURPOSE
argument_list|(
name|a
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
if|if
condition|(
name|is_attribute_p
argument_list|(
literal|"deprecated"
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|deprecated_state
operator|=
name|DEPRECATED_SUPPRESS
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|is_attribute_p
argument_list|(
literal|"unavailable"
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|deprecated_state
operator|=
name|DEPRECATED_UNAVAILABLE_SUPPRESS
expr_stmt|;
break|break;
block|}
block|}
endif|#
directive|endif
comment|/* APPLE LOCAL end "unavailable" attribute (radar 2809697) */
name|decl
operator|=
name|grokdeclarator
argument_list|(
name|declarator
argument_list|,
name|declspecs
argument_list|,
name|NORMAL
argument_list|,
name|initialized
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|decl
condition|)
return|return
literal|0
return|;
name|deprecated_state
operator|=
name|DEPRECATED_NORMAL
expr_stmt|;
if|if
condition|(
name|warn_main
operator|>
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|&&
name|MAIN_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|warning
argument_list|(
name|OPT_Wmain
argument_list|,
literal|"%q+D is usually a function"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|initialized
condition|)
comment|/* Is it valid for this decl to have an initializer at all?        If not, set INITIALIZED to zero, which will indirectly        tell 'finish_decl' to ignore the initializer once it is parsed.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
case|case
name|TYPE_DECL
case|:
name|error
argument_list|(
literal|"typedef %qD is initialized (use __typeof__ instead)"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|initialized
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|FUNCTION_DECL
case|:
name|error
argument_list|(
literal|"function %qD is initialized like a variable"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|initialized
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|PARM_DECL
case|:
comment|/* DECL_INITIAL in a PARM_DECL is really DECL_ARG_TYPE.  */
name|error
argument_list|(
literal|"parameter %qD is initialized"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|initialized
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
comment|/* Don't allow initializations for incomplete types except for 	   arrays which might be completed by the initialization.  */
comment|/* This can happen if the array size is an undefined macro. 	   We already gave a warning, so we don't need another one.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|==
name|error_mark_node
condition|)
name|initialized
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|COMPLETE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
comment|/* A complete type is ok if size is fixed.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|C_DECL_VARIABLE_SIZE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"variable-sized object may not be initialized"
argument_list|)
expr_stmt|;
name|initialized
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|ARRAY_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"variable %qD has initializer but incomplete type"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|initialized
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|C_DECL_VARIABLE_SIZE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* Although C99 is unclear about whether incomplete arrays 	       of VLAs themselves count as VLAs, it does not make 	       sense to permit them to be initialized given that 	       ordinary VLAs may not be initialized.  */
name|error
argument_list|(
literal|"variable-sized object may not be initialized"
argument_list|)
expr_stmt|;
name|initialized
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|initialized
condition|)
block|{
if|if
condition|(
name|current_scope
operator|==
name|file_scope
condition|)
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Tell 'pushdecl' this is an initialized decl 	 even though we don't yet have the initializer expression. 	 Also tell 'finish_decl' it may store the real initializer.  */
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
comment|/* If this is a function declaration, write a record describing it to the      prototypes file (if requested).  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|gen_aux_info_record
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* ANSI specifies that a tentative definition which is not merged with      a non-tentative definition behaves exactly like a definition with an      initializer equal to zero.  (Section 3.7.2)       -fno-common gives strict ANSI behavior, though this tends to break      a large body of code that grew up without this rule.       Thread-local variables are never common, since there's no entrenched      body of code to break, and it allows more efficient variable references      in the presence of dynamic linking.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
operator|!
name|initialized
operator|&&
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_THREAD_LOCAL_P
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|flag_no_common
condition|)
name|DECL_COMMON
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Set attributes here so if duplicate decl, will have proper attributes.  */
name|decl_attributes
argument_list|(
operator|&
name|decl
argument_list|,
name|attributes
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Handle gnu_inline attribute.  */
if|if
condition|(
name|declspecs
operator|->
name|inline_p
operator|&&
operator|!
name|flag_gnu89_inline
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|lookup_attribute
argument_list|(
literal|"gnu_inline"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|declspecs
operator|->
name|storage_class
operator|==
name|csc_auto
operator|&&
name|current_scope
operator|!=
name|file_scope
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|declspecs
operator|->
name|storage_class
operator|!=
name|csc_static
condition|)
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|targetm
operator|.
name|calls
operator|.
name|promote_prototypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
name|struct
name|c_declarator
modifier|*
name|ce
init|=
name|declarator
decl_stmt|;
if|if
condition|(
name|ce
operator|->
name|kind
operator|==
name|cdk_pointer
condition|)
name|ce
operator|=
name|declarator
operator|->
name|declarator
expr_stmt|;
if|if
condition|(
name|ce
operator|->
name|kind
operator|==
name|cdk_function
condition|)
block|{
name|tree
name|args
init|=
name|ce
operator|->
name|u
operator|.
name|arg_info
operator|->
name|parms
decl_stmt|;
for|for
control|(
init|;
name|args
condition|;
name|args
operator|=
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
control|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|args
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
condition|)
name|DECL_ARG_TYPE
argument_list|(
name|args
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_DECLARED_INLINE_P
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_UNINLINABLE
argument_list|(
name|decl
argument_list|)
operator|&&
name|lookup_attribute
argument_list|(
literal|"noinline"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"inline function %q+D given attribute noinline"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* C99 6.7.4p3: An inline definition of a function with external      linkage shall not contain a definition of a modifiable object      with static storage duration...  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|current_scope
operator|!=
name|file_scope
operator|&&
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_DECLARED_INLINE_P
argument_list|(
name|current_function_decl
argument_list|)
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|current_function_decl
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"%q+D is static but declared in inline function %qD "
literal|"which is not static"
argument_list|,
name|decl
argument_list|,
name|current_function_decl
argument_list|)
expr_stmt|;
comment|/* Add this decl to the current scope.      TEM may equal DECL or it may be a previous decl of the same name.  */
name|tem
operator|=
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|initialized
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|tem
argument_list|)
condition|)
block|{
name|DECL_EXTERNAL
argument_list|(
name|tem
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|tem
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|tem
return|;
block|}
end_function

begin_comment
comment|/* Initialize EH if not initialized yet and exceptions are enabled.  */
end_comment

begin_function
name|void
name|c_maybe_initialize_eh
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|flag_exceptions
operator|||
name|c_eh_initialized_p
condition|)
return|return;
name|c_eh_initialized_p
operator|=
name|true
expr_stmt|;
name|eh_personality_libfunc
operator|=
name|init_one_libfunc
argument_list|(
name|USING_SJLJ_EXCEPTIONS
condition|?
literal|"__gcc_personality_sj0"
else|:
literal|"__gcc_personality_v0"
argument_list|)
expr_stmt|;
name|default_init_unwind_resume_libfunc
argument_list|()
expr_stmt|;
name|using_eh_for_cleanups
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish processing of a declaration;    install its initial value.    If the length of an array type is not known before,    it must be determined now, from the initial value, or it is an error.  */
end_comment

begin_function
name|void
name|finish_decl
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|init
parameter_list|,
name|tree
name|asmspec_tree
parameter_list|)
block|{
name|tree
name|type
decl_stmt|;
name|int
name|was_incomplete
init|=
operator|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|asmspec
init|=
literal|0
decl_stmt|;
comment|/* If a name was specified, get the string.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|)
operator|&&
name|DECL_FILE_SCOPE_P
argument_list|(
name|decl
argument_list|)
condition|)
name|asmspec_tree
operator|=
name|maybe_apply_renaming_pragma
argument_list|(
name|decl
argument_list|,
name|asmspec_tree
argument_list|)
expr_stmt|;
if|if
condition|(
name|asmspec_tree
condition|)
name|asmspec
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|asmspec_tree
argument_list|)
expr_stmt|;
comment|/* If `start_decl' didn't like having an initialization, ignore it now.  */
if|if
condition|(
name|init
operator|!=
literal|0
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
name|init
operator|=
literal|0
expr_stmt|;
comment|/* Don't crash if parm is initialized.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|PARM_DECL
condition|)
name|init
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|init
condition|)
name|store_init_value
argument_list|(
name|decl
argument_list|,
name|init
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_dialect_objc
argument_list|()
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FIELD_DECL
operator|)
condition|)
name|objc_check_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Deduce size of array from initialization, if not already known.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
block|{
name|bool
name|do_default
init|=
operator|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
comment|/* Even if pedantic, an external linkage array 	      may have incomplete type at first.  */
condition|?
name|pedantic
operator|&&
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
else|:
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|)
decl_stmt|;
name|int
name|failure
init|=
name|complete_array_type
argument_list|(
operator|&
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|,
name|do_default
argument_list|)
decl_stmt|;
comment|/* Get the completed type made by complete_array_type.  */
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|failure
condition|)
block|{
case|case
literal|1
case|:
name|error
argument_list|(
literal|"initializer fails to determine size of %q+D"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
if|if
condition|(
name|do_default
condition|)
name|error
argument_list|(
literal|"array size missing in %q+D"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* If a `static' var's size isn't known, 	     make it extern as well as static, so it does not get 	     allocated. 	     If it is not `static', then do not mark extern; 	     finish_incomplete_decl will give it a default size 	     and it will get allocated.  */
elseif|else
if|if
condition|(
operator|!
name|pedantic
operator|&&
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|error
argument_list|(
literal|"zero or negative size array %q+D"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
comment|/* For global variables, update the copy of the type that 	     exists in the binding.  */
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|struct
name|c_binding
modifier|*
name|b_ext
init|=
name|I_SYMBOL_BINDING
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
name|b_ext
operator|&&
operator|!
name|B_IN_EXTERNAL_SCOPE
argument_list|(
name|b_ext
argument_list|)
condition|)
name|b_ext
operator|=
name|b_ext
operator|->
name|shadowed
expr_stmt|;
if|if
condition|(
name|b_ext
condition|)
block|{
if|if
condition|(
name|b_ext
operator|->
name|type
condition|)
name|b_ext
operator|->
name|type
operator|=
name|composite_type
argument_list|(
name|b_ext
operator|->
name|type
argument_list|,
name|type
argument_list|)
expr_stmt|;
else|else
name|b_ext
operator|->
name|type
operator|=
name|type
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
condition|)
name|TREE_TYPE
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
name|type
expr_stmt|;
name|layout_decl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
if|if
condition|(
name|init
operator|&&
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
name|add_flexible_array_elts_to_size
argument_list|(
name|decl
argument_list|,
name|init
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|!=
name|error_mark_node
operator|&&
name|COMPLETE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|layout_decl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
comment|/* Don't give an error if we already gave one earlier.  */
operator|&&
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|!=
name|error_mark_node
operator|&&
operator|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
comment|/* A static variable with an incomplete type 		 is an error if it is initialized. 		 Also if it is not file scope. 		 Otherwise, let it through, but if it is not `extern' 		 then it may cause an error message later.  */
condition|?
operator|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|||
operator|!
name|DECL_FILE_SCOPE_P
argument_list|(
name|decl
argument_list|)
operator|)
comment|/* An automatic variable with an incomplete type 		 is an error.  */
else|:
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"storage size of %q+D isn%'t known"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|||
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|)
operator|&&
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
name|constant_expression_warning
argument_list|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"storage size of %q+D isn%'t constant"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_USED
argument_list|(
name|type
argument_list|)
condition|)
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If this is a function and an assembler name is specified, reset DECL_RTL      so we can give it its new name.  Also, update built_in_decls if it      was a normal built-in.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|asmspec
condition|)
block|{
if|if
condition|(
name|DECL_BUILT_IN_CLASS
argument_list|(
name|decl
argument_list|)
operator|==
name|BUILT_IN_NORMAL
condition|)
name|set_builtin_user_assembler_name
argument_list|(
name|decl
argument_list|,
name|asmspec
argument_list|)
expr_stmt|;
name|set_user_assembler_name
argument_list|(
name|decl
argument_list|,
name|asmspec
argument_list|)
expr_stmt|;
block|}
comment|/* If #pragma weak was used, mark the decl weak now.  */
name|maybe_apply_pragma_weak
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Output the assembler code and/or RTL code for variables and functions,      unless the type is an undefined structure or union.      If not, it will get done when the type is completed.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
comment|/* Determine the ELF visibility.  */
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
name|c_determine_visibility
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* This is a no-op in c-lang.c or something real in objc-act.c.  */
if|if
condition|(
name|c_dialect_objc
argument_list|()
condition|)
name|objc_check_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|asmspec
condition|)
block|{
comment|/* If this is not a static variable, issue a warning. 	     It doesn't make any sense to give an ASMSPEC for an 	     ordinary, non-register local variable.  Historically, 	     GCC has accepted -- but ignored -- the ASMSPEC in 	     this case.  */
if|if
condition|(
operator|!
name|DECL_FILE_SCOPE_P
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
operator|!
name|C_DECL_REGISTER
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"ignoring asm-specifier for non-static local "
literal|"variable %q+D"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|else
name|set_user_assembler_name
argument_list|(
name|decl
argument_list|,
name|asmspec
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DECL_FILE_SCOPE_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
operator|||
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|error_mark_node
condition|)
comment|/* Don't output anything 	       when a tentative file-scope definition is seen. 	       But at end of compilation, do output code for them.  */
name|DECL_DEFER_OUTPUT
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|rest_of_decl_compilation
argument_list|(
name|decl
argument_list|,
name|true
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* In conjunction with an ASMSPEC, the `register' 	     keyword indicates that we should place the variable 	     in a particular register.  */
if|if
condition|(
name|asmspec
operator|&&
name|C_DECL_REGISTER
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|DECL_HARD_REGISTER
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* This cannot be done for a structure with volatile 		 fields, on which DECL_REGISTER will have been 		 reset.  */
if|if
condition|(
operator|!
name|DECL_REGISTER
argument_list|(
name|decl
argument_list|)
condition|)
name|error
argument_list|(
literal|"cannot put object with volatile field into register"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
block|{
comment|/* If we're building a variable sized type, and we might be 		 reachable other than via the top of the current binding 		 level, then create a new BIND_EXPR so that we deallocate 		 the object at the right time.  */
comment|/* Note that DECL_SIZE can be null due to errors.  */
if|if
condition|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_CONSTANT
argument_list|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|&&
name|STATEMENT_LIST_HAS_LABEL
argument_list|(
name|cur_stmt_list
argument_list|)
condition|)
block|{
name|tree
name|bind
decl_stmt|;
name|bind
operator|=
name|build3
argument_list|(
name|BIND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|bind
argument_list|)
operator|=
literal|1
expr_stmt|;
name|add_stmt
argument_list|(
name|bind
argument_list|)
expr_stmt|;
name|BIND_EXPR_BODY
argument_list|(
name|bind
argument_list|)
operator|=
name|push_stmt_list
argument_list|()
expr_stmt|;
block|}
name|add_stmt
argument_list|(
name|build_stmt
argument_list|(
name|DECL_EXPR
argument_list|,
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|DECL_FILE_SCOPE_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* Recompute the RTL of a local array now 	     if it used to be an incomplete type.  */
if|if
condition|(
name|was_incomplete
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* If we used it already as memory, it must stay in memory.  */
name|TREE_ADDRESSABLE
argument_list|(
name|decl
argument_list|)
operator|=
name|TREE_USED
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* If it's still incomplete now, no init will save it.  */
if|if
condition|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
comment|/* If this was marked 'used', be sure it will be output.  */
if|if
condition|(
operator|!
name|flag_unit_at_a_time
operator|&&
name|lookup_attribute
argument_list|(
literal|"used"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|mark_decl_referenced
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
if|if
condition|(
operator|!
name|DECL_FILE_SCOPE_P
argument_list|(
name|decl
argument_list|)
operator|&&
name|variably_modified_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
condition|)
name|add_stmt
argument_list|(
name|build_stmt
argument_list|(
name|DECL_EXPR
argument_list|,
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|rest_of_decl_compilation
argument_list|(
name|decl
argument_list|,
name|DECL_FILE_SCOPE_P
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* At the end of a declaration, throw away any variable type sizes      of types defined inside that declaration.  There is no use      computing them in the following function definition.  */
if|if
condition|(
name|current_scope
operator|==
name|file_scope
condition|)
name|get_pending_sizes
argument_list|()
expr_stmt|;
comment|/* Install a cleanup (aka destructor) if one was given.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|tree
name|attr
init|=
name|lookup_attribute
argument_list|(
literal|"cleanup"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|attr
condition|)
block|{
name|tree
name|cleanup_id
init|=
name|TREE_VALUE
argument_list|(
name|TREE_VALUE
argument_list|(
name|attr
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|cleanup_decl
init|=
name|lookup_name
argument_list|(
name|cleanup_id
argument_list|)
decl_stmt|;
name|tree
name|cleanup
decl_stmt|;
comment|/* Build "cleanup(&decl)" for the destructor.  */
name|cleanup
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cleanup
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|cleanup
argument_list|)
expr_stmt|;
name|cleanup
operator|=
name|build_function_call
argument_list|(
name|cleanup_decl
argument_list|,
name|cleanup
argument_list|)
expr_stmt|;
comment|/* Don't warn about decl unused; the cleanup uses it.  */
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_USED
argument_list|(
name|cleanup_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Initialize EH, if we've been told to do so.  */
name|c_maybe_initialize_eh
argument_list|()
expr_stmt|;
name|push_cleanup
argument_list|(
name|decl
argument_list|,
name|cleanup
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Given a parsed parameter declaration, decode it into a PARM_DECL.  */
end_comment

begin_function
name|tree
name|grokparm
parameter_list|(
specifier|const
name|struct
name|c_parm
modifier|*
name|parm
parameter_list|)
block|{
name|tree
name|decl
init|=
name|grokdeclarator
argument_list|(
name|parm
operator|->
name|declarator
argument_list|,
name|parm
operator|->
name|specs
argument_list|,
name|PARM
argument_list|,
name|false
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|decl_attributes
argument_list|(
operator|&
name|decl
argument_list|,
name|parm
operator|->
name|attrs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Given a parsed parameter declaration, decode it into a PARM_DECL    and push that on the current scope.  */
end_comment

begin_function
name|void
name|push_parm_decl
parameter_list|(
specifier|const
name|struct
name|c_parm
modifier|*
name|parm
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|;
name|decl
operator|=
name|grokdeclarator
argument_list|(
name|parm
operator|->
name|declarator
argument_list|,
name|parm
operator|->
name|specs
argument_list|,
name|PARM
argument_list|,
name|false
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|decl_attributes
argument_list|(
operator|&
name|decl
argument_list|,
name|parm
operator|->
name|attrs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|decl
operator|=
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|decl
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Mark all the parameter declarations to date as forward decls.    Also diagnose use of this extension.  */
end_comment

begin_function
name|void
name|mark_forward_parm_decls
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|c_binding
modifier|*
name|b
decl_stmt|;
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|current_scope
operator|->
name|warned_forward_parm_decls
condition|)
block|{
name|pedwarn
argument_list|(
literal|"ISO C forbids forward parameter declarations"
argument_list|)
expr_stmt|;
name|current_scope
operator|->
name|warned_forward_parm_decls
operator|=
name|true
expr_stmt|;
block|}
for|for
control|(
name|b
operator|=
name|current_scope
operator|->
name|bindings
init|;
name|b
condition|;
name|b
operator|=
name|b
operator|->
name|prev
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|b
operator|->
name|decl
argument_list|)
operator|==
name|PARM_DECL
condition|)
name|TREE_ASM_WRITTEN
argument_list|(
name|b
operator|->
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Build a COMPOUND_LITERAL_EXPR.  TYPE is the type given in the compound    literal, which may be an incomplete array type completed by the    initializer; INIT is a CONSTRUCTOR that initializes the compound    literal.  */
end_comment

begin_function
name|tree
name|build_compound_literal
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|init
parameter_list|)
block|{
comment|/* We do not use start_decl here because we have a type, not a declarator;      and do not use finish_decl because the decl should be stored inside      the COMPOUND_LITERAL_EXPR rather than added elsewhere as a DECL_EXPR.  */
name|tree
name|decl
decl_stmt|;
name|tree
name|complit
decl_stmt|;
name|tree
name|stmt
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|decl
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
operator|(
name|current_scope
operator|==
name|file_scope
operator|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|current_function_decl
expr_stmt|;
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|type
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|=
name|TYPE_READONLY
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|store_init_value
argument_list|(
name|decl
argument_list|,
name|init
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|int
name|failure
init|=
name|complete_array_type
argument_list|(
operator|&
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|,
name|true
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|failure
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
name|type
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
name|error_mark_node
operator|||
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
name|stmt
operator|=
name|build_stmt
argument_list|(
name|DECL_EXPR
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|complit
operator|=
name|build1
argument_list|(
name|COMPOUND_LITERAL_EXPR
argument_list|,
name|type
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|complit
argument_list|)
operator|=
literal|1
expr_stmt|;
name|layout_decl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* This decl needs a name for the assembler output.  */
name|set_compound_literal_name
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_DEFER_OUTPUT
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_COMDAT
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_IGNORED_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|rest_of_decl_compilation
argument_list|(
name|decl
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|complit
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Determine whether TYPE is a structure with a flexible array member,    or a union containing such a structure (possibly recursively).  */
end_comment

begin_function
specifier|static
name|bool
name|flexible_array_type_p
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|tree
name|x
decl_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|RECORD_TYPE
case|:
name|x
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|NULL_TREE
condition|)
return|return
name|false
return|;
while|while
condition|(
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|TYPE_MAX_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
case|case
name|UNION_TYPE
case|:
for|for
control|(
name|x
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|x
operator|!=
name|NULL_TREE
condition|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
control|)
block|{
if|if
condition|(
name|flexible_array_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
default|default:
return|return
name|false
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Performs sanity checks on the TYPE and WIDTH of the bit-field NAME,    replacing with appropriate values if they are invalid.  */
end_comment

begin_function
specifier|static
name|void
name|check_bitfield_type_and_width
parameter_list|(
name|tree
modifier|*
name|type
parameter_list|,
name|tree
modifier|*
name|width
parameter_list|,
specifier|const
name|char
modifier|*
name|orig_name
parameter_list|)
block|{
name|tree
name|type_mv
decl_stmt|;
name|unsigned
name|int
name|max_width
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|w
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|orig_name
condition|?
name|orig_name
else|:
name|_
argument_list|(
literal|"<anonymous>"
argument_list|)
decl_stmt|;
comment|/* Detect and ignore out of range field width and process valid      field widths.  */
if|if
condition|(
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
operator|*
name|width
argument_list|)
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
operator|*
name|width
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
name|error
argument_list|(
literal|"bit-field %qs width not an integer constant"
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|width
operator|=
name|integer_one_node
expr_stmt|;
block|}
else|else
block|{
name|constant_expression_warning
argument_list|(
operator|*
name|width
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree_int_cst_sgn
argument_list|(
operator|*
name|width
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"negative width in bit-field %qs"
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|width
operator|=
name|integer_one_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|integer_zerop
argument_list|(
operator|*
name|width
argument_list|)
operator|&&
name|orig_name
condition|)
block|{
name|error
argument_list|(
literal|"zero width for bit-field %qs"
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|width
operator|=
name|integer_one_node
expr_stmt|;
block|}
block|}
comment|/* Detect invalid bit-field type.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|type
argument_list|)
operator|!=
name|INTEGER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
operator|*
name|type
argument_list|)
operator|!=
name|BOOLEAN_TYPE
operator|&&
name|TREE_CODE
argument_list|(
operator|*
name|type
argument_list|)
operator|!=
name|ENUMERAL_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"bit-field %qs has invalid type"
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|type
operator|=
name|unsigned_type_node
expr_stmt|;
block|}
name|type_mv
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
operator|*
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|in_system_header
operator|&&
name|type_mv
operator|!=
name|integer_type_node
operator|&&
name|type_mv
operator|!=
name|unsigned_type_node
operator|&&
name|type_mv
operator|!=
name|boolean_type_node
condition|)
name|pedwarn
argument_list|(
literal|"type of bit-field %qs is a GCC extension"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|type_mv
operator|==
name|boolean_type_node
condition|)
name|max_width
operator|=
name|CHAR_TYPE_SIZE
expr_stmt|;
else|else
name|max_width
operator|=
name|TYPE_PRECISION
argument_list|(
operator|*
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|<
name|compare_tree_int
argument_list|(
operator|*
name|width
argument_list|,
name|max_width
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"width of %qs exceeds its type"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|w
operator|=
name|max_width
expr_stmt|;
operator|*
name|width
operator|=
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|w
argument_list|)
expr_stmt|;
block|}
else|else
name|w
operator|=
name|tree_low_cst
argument_list|(
operator|*
name|width
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
block|{
name|struct
name|lang_type
modifier|*
name|lt
init|=
name|TYPE_LANG_SPECIFIC
argument_list|(
operator|*
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|lt
operator|||
name|w
operator|<
name|min_precision
argument_list|(
name|lt
operator|->
name|enum_min
argument_list|,
name|TYPE_UNSIGNED
argument_list|(
operator|*
name|type
argument_list|)
argument_list|)
operator|||
name|w
operator|<
name|min_precision
argument_list|(
name|lt
operator|->
name|enum_max
argument_list|,
name|TYPE_UNSIGNED
argument_list|(
operator|*
name|type
argument_list|)
argument_list|)
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"%qs is narrower than values of its type"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print warning about variable length array if necessary.  */
end_comment

begin_function
specifier|static
name|void
name|warn_variable_length_array
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|tree
name|size
parameter_list|)
block|{
name|int
name|ped
init|=
operator|!
name|flag_isoc99
operator|&&
name|pedantic
operator|&&
name|warn_vla
operator|!=
literal|0
decl_stmt|;
name|int
name|const_size
init|=
name|TREE_CONSTANT
argument_list|(
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|ped
condition|)
block|{
if|if
condition|(
name|const_size
condition|)
block|{
if|if
condition|(
name|name
condition|)
name|pedwarn
argument_list|(
literal|"ISO C90 forbids array %qs whose size "
literal|"can%'t be evaluated"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|pedwarn
argument_list|(
literal|"ISO C90 forbids array whose size "
literal|"can%'t be evaluated"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|name
condition|)
name|pedwarn
argument_list|(
literal|"ISO C90 forbids variable length array %qs"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|pedwarn
argument_list|(
literal|"ISO C90 forbids variable length array"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|warn_vla
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|const_size
condition|)
block|{
if|if
condition|(
name|name
condition|)
name|warning
argument_list|(
name|OPT_Wvla
argument_list|,
literal|"the size of array %qs can"
literal|"%'t be evaluated"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
name|OPT_Wvla
argument_list|,
literal|"the size of array can %'t be evaluated"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|name
condition|)
name|warning
argument_list|(
name|OPT_Wvla
argument_list|,
literal|"variable length array %qs is used"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
name|OPT_Wvla
argument_list|,
literal|"variable length array is used"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Given declspecs and a declarator,    determine the name and type of the object declared    and construct a ..._DECL node for it.    (In one case we can return a ..._TYPE node instead.     For invalid input we sometimes return 0.)     DECLSPECS is a c_declspecs structure for the declaration specifiers.     DECL_CONTEXT says which syntactic context this declaration is in:      NORMAL for most contexts.  Make a VAR_DECL or FUNCTION_DECL or TYPE_DECL.      FUNCDEF for a function definition.  Like NORMAL but a few different       error messages in each case.  Return value may be zero meaning       this definition is too screwy to try to parse.      PARM for a parameter declaration (either within a function prototype       or before a function body).  Make a PARM_DECL, or return void_type_node.      TYPENAME if for a typename (in a cast or sizeof).       Don't make a DECL node; just return the ..._TYPE node.      FIELD for a struct or union field; make a FIELD_DECL.    INITIALIZED is true if the decl has an initializer.    WIDTH is non-NULL for bit-fields, and is a pointer to an INTEGER_CST node    representing the width of the bit-field.     In the TYPENAME case, DECLARATOR is really an absolute declarator.    It may also be so in the PARM case, for a prototype where the    argument type is specified but not the name.     This function is where the complicated C meanings of `static'    and `extern' are interpreted.  */
end_comment

begin_function
specifier|static
name|tree
name|grokdeclarator
parameter_list|(
specifier|const
name|struct
name|c_declarator
modifier|*
name|declarator
parameter_list|,
name|struct
name|c_declspecs
modifier|*
name|declspecs
parameter_list|,
name|enum
name|decl_context
name|decl_context
parameter_list|,
name|bool
name|initialized
parameter_list|,
name|tree
modifier|*
name|width
parameter_list|)
block|{
name|tree
name|type
init|=
name|declspecs
operator|->
name|type
decl_stmt|;
name|bool
name|threadp
init|=
name|declspecs
operator|->
name|thread_p
decl_stmt|;
name|enum
name|c_storage_class
name|storage_class
init|=
name|declspecs
operator|->
name|storage_class
decl_stmt|;
name|int
name|constp
decl_stmt|;
name|int
name|restrictp
decl_stmt|;
name|int
name|volatilep
decl_stmt|;
name|int
name|type_quals
init|=
name|TYPE_UNQUALIFIED
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|orig_name
decl_stmt|;
name|tree
name|typedef_type
init|=
literal|0
decl_stmt|;
name|bool
name|funcdef_flag
init|=
name|false
decl_stmt|;
name|bool
name|funcdef_syntax
init|=
name|false
decl_stmt|;
name|int
name|size_varies
init|=
literal|0
decl_stmt|;
name|tree
name|decl_attr
init|=
name|declspecs
operator|->
name|decl_attr
decl_stmt|;
name|int
name|array_ptr_quals
init|=
name|TYPE_UNQUALIFIED
decl_stmt|;
name|tree
name|array_ptr_attrs
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|array_parm_static
init|=
literal|0
decl_stmt|;
name|bool
name|array_parm_vla_unspec_p
init|=
name|false
decl_stmt|;
name|tree
name|returned_attrs
init|=
name|NULL_TREE
decl_stmt|;
name|bool
name|bitfield
init|=
name|width
operator|!=
name|NULL
decl_stmt|;
name|tree
name|element_type
decl_stmt|;
name|struct
name|c_arg_info
modifier|*
name|arg_info
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|decl_context
operator|==
name|FUNCDEF
condition|)
name|funcdef_flag
operator|=
name|true
operator|,
name|decl_context
operator|=
name|NORMAL
expr_stmt|;
comment|/* Look inside a declarator for the name being declared      and get it as a string, for an error message.  */
block|{
specifier|const
name|struct
name|c_declarator
modifier|*
name|decl
init|=
name|declarator
decl_stmt|;
name|name
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|decl
condition|)
switch|switch
condition|(
name|decl
operator|->
name|kind
condition|)
block|{
case|case
name|cdk_function
case|:
case|case
name|cdk_array
case|:
case|case
name|cdk_pointer
case|:
name|funcdef_syntax
operator|=
operator|(
name|decl
operator|->
name|kind
operator|==
name|cdk_function
operator|)
expr_stmt|;
name|decl
operator|=
name|decl
operator|->
name|declarator
expr_stmt|;
break|break;
case|case
name|cdk_attrs
case|:
name|decl
operator|=
name|decl
operator|->
name|declarator
expr_stmt|;
break|break;
case|case
name|cdk_id
case|:
if|if
condition|(
name|decl
operator|->
name|u
operator|.
name|id
condition|)
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|decl
operator|->
name|u
operator|.
name|id
argument_list|)
expr_stmt|;
name|decl
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|orig_name
operator|=
name|name
expr_stmt|;
if|if
condition|(
name|name
operator|==
literal|0
condition|)
name|name
operator|=
literal|"type name"
expr_stmt|;
block|}
comment|/* A function definition's declarator must have the form of      a function declarator.  */
if|if
condition|(
name|funcdef_flag
operator|&&
operator|!
name|funcdef_syntax
condition|)
return|return
literal|0
return|;
comment|/* If this looks like a function definition, make it one,      even if it occurs where parms are expected.      Then store_parm_decls will reject it and not use it as a parm.  */
comment|/* APPLE LOCAL begin "unavailable" attribute (radar 2809697) */
if|if
condition|(
name|declspecs
operator|->
name|unavailable_p
condition|)
name|error_unavailable_use
argument_list|(
name|declspecs
operator|->
name|type
argument_list|)
expr_stmt|;
elseif|else
comment|/* APPLE LOCAL end "unavailable" attribute (radar 2809697) */
if|if
condition|(
name|decl_context
operator|==
name|NORMAL
operator|&&
operator|!
name|funcdef_flag
operator|&&
name|current_scope
operator|->
name|parm_flag
condition|)
name|decl_context
operator|=
name|PARM
expr_stmt|;
if|if
condition|(
name|declspecs
operator|->
name|deprecated_p
operator|&&
name|deprecated_state
operator|!=
name|DEPRECATED_SUPPRESS
condition|)
name|warn_deprecated_use
argument_list|(
name|declspecs
operator|->
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|decl_context
operator|==
name|NORMAL
operator|||
name|decl_context
operator|==
name|FIELD
operator|)
operator|&&
name|current_scope
operator|==
name|file_scope
operator|&&
name|variably_modified_type_p
argument_list|(
name|type
argument_list|,
name|NULL_TREE
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"variably modified %qs at file scope"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|type
operator|=
name|integer_type_node
expr_stmt|;
block|}
name|typedef_type
operator|=
name|type
expr_stmt|;
name|size_varies
operator|=
name|C_TYPE_VARIABLE_SIZE
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Diagnose defaulting to "int".  */
if|if
condition|(
name|declspecs
operator|->
name|default_int_p
operator|&&
operator|!
name|in_system_header
condition|)
block|{
comment|/* Issue a warning if this is an ISO C 99 program or if 	 -Wreturn-type and this is a function, or if -Wimplicit; 	 prefer the former warning since it is more explicit.  */
if|if
condition|(
operator|(
name|warn_implicit_int
operator|||
name|warn_return_type
operator|||
name|flag_isoc99
operator|)
operator|&&
name|funcdef_flag
condition|)
name|warn_about_return_type
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|warn_implicit_int
operator|||
name|flag_isoc99
condition|)
name|pedwarn_c99
argument_list|(
literal|"type defaults to %<int%> in declaration of %qs"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* Adjust the type if a bit-field is being declared,      -funsigned-bitfields applied and the type is not explicitly      "signed".  */
if|if
condition|(
name|bitfield
operator|&&
operator|!
name|flag_signed_bitfields
operator|&&
operator|!
name|declspecs
operator|->
name|explicit_signed_p
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
condition|)
name|type
operator|=
name|c_common_unsigned_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Figure out the type qualifiers for the declaration.  There are      two ways a declaration can become qualified.  One is something      like `const int i' where the `const' is explicit.  Another is      something like `typedef const int CI; CI i' where the type of the      declaration contains the `const'.  A third possibility is that      there is a type qualifier on the element type of a typedefed      array type, in which case we should extract that qualifier so      that c_apply_type_quals_to_decls receives the full list of      qualifiers to work with (C90 is not entirely clear about whether      duplicate qualifiers should be diagnosed in this case, but it      seems most appropriate to do so).  */
name|element_type
operator|=
name|strip_array_types
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|constp
operator|=
name|declspecs
operator|->
name|const_p
operator|+
name|TYPE_READONLY
argument_list|(
name|element_type
argument_list|)
expr_stmt|;
name|restrictp
operator|=
name|declspecs
operator|->
name|restrict_p
operator|+
name|TYPE_RESTRICT
argument_list|(
name|element_type
argument_list|)
expr_stmt|;
name|volatilep
operator|=
name|declspecs
operator|->
name|volatile_p
operator|+
name|TYPE_VOLATILE
argument_list|(
name|element_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|flag_isoc99
condition|)
block|{
if|if
condition|(
name|constp
operator|>
literal|1
condition|)
name|pedwarn
argument_list|(
literal|"duplicate %<const%>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|restrictp
operator|>
literal|1
condition|)
name|pedwarn
argument_list|(
literal|"duplicate %<restrict%>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|volatilep
operator|>
literal|1
condition|)
name|pedwarn
argument_list|(
literal|"duplicate %<volatile%>"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|flag_gen_aux_info
operator|&&
operator|(
name|TYPE_QUALS
argument_list|(
name|element_type
argument_list|)
operator|)
condition|)
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|type_quals
operator|=
operator|(
operator|(
name|constp
condition|?
name|TYPE_QUAL_CONST
else|:
literal|0
operator|)
operator||
operator|(
name|restrictp
condition|?
name|TYPE_QUAL_RESTRICT
else|:
literal|0
operator|)
operator||
operator|(
name|volatilep
condition|?
name|TYPE_QUAL_VOLATILE
else|:
literal|0
operator|)
operator|)
expr_stmt|;
comment|/* Warn about storage classes that are invalid for certain      kinds of declarations (parameters, typenames, etc.).  */
if|if
condition|(
name|funcdef_flag
operator|&&
operator|(
name|threadp
operator|||
name|storage_class
operator|==
name|csc_auto
operator|||
name|storage_class
operator|==
name|csc_register
operator|||
name|storage_class
operator|==
name|csc_typedef
operator|)
condition|)
block|{
if|if
condition|(
name|storage_class
operator|==
name|csc_auto
operator|&&
operator|(
name|pedantic
operator|||
name|current_scope
operator|==
name|file_scope
operator|)
condition|)
name|pedwarn
argument_list|(
literal|"function definition declared %<auto%>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|storage_class
operator|==
name|csc_register
condition|)
name|error
argument_list|(
literal|"function definition declared %<register%>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|storage_class
operator|==
name|csc_typedef
condition|)
name|error
argument_list|(
literal|"function definition declared %<typedef%>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|threadp
condition|)
name|error
argument_list|(
literal|"function definition declared %<__thread%>"
argument_list|)
expr_stmt|;
name|threadp
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|storage_class
operator|==
name|csc_auto
operator|||
name|storage_class
operator|==
name|csc_register
operator|||
name|storage_class
operator|==
name|csc_typedef
condition|)
name|storage_class
operator|=
name|csc_none
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|decl_context
operator|!=
name|NORMAL
operator|&&
operator|(
name|storage_class
operator|!=
name|csc_none
operator|||
name|threadp
operator|)
condition|)
block|{
if|if
condition|(
name|decl_context
operator|==
name|PARM
operator|&&
name|storage_class
operator|==
name|csc_register
condition|)
empty_stmt|;
else|else
block|{
switch|switch
condition|(
name|decl_context
condition|)
block|{
case|case
name|FIELD
case|:
name|error
argument_list|(
literal|"storage class specified for structure field %qs"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARM
case|:
name|error
argument_list|(
literal|"storage class specified for parameter %qs"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"storage class specified for typename"
argument_list|)
expr_stmt|;
break|break;
block|}
name|storage_class
operator|=
name|csc_none
expr_stmt|;
name|threadp
operator|=
name|false
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|storage_class
operator|==
name|csc_extern
operator|&&
name|initialized
operator|&&
operator|!
name|funcdef_flag
condition|)
block|{
comment|/* 'extern' with initialization is invalid if not at file scope.  */
if|if
condition|(
name|current_scope
operator|==
name|file_scope
condition|)
block|{
comment|/* It is fine to have 'extern const' when compiling at C               and C++ intersection.  */
if|if
condition|(
operator|!
operator|(
name|warn_cxx_compat
operator|&&
name|constp
operator|)
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"%qs initialized and declared %<extern%>"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"%qs has both %<extern%> and initializer"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|current_scope
operator|==
name|file_scope
condition|)
block|{
if|if
condition|(
name|storage_class
operator|==
name|csc_auto
condition|)
name|error
argument_list|(
literal|"file-scope declaration of %qs specifies %<auto%>"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|pedantic
operator|&&
name|storage_class
operator|==
name|csc_register
condition|)
name|pedwarn
argument_list|(
literal|"file-scope declaration of %qs specifies %<register%>"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|storage_class
operator|==
name|csc_extern
operator|&&
name|funcdef_flag
condition|)
name|error
argument_list|(
literal|"nested function %qs declared %<extern%>"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|threadp
operator|&&
name|storage_class
operator|==
name|csc_none
condition|)
block|{
name|error
argument_list|(
literal|"function-scope %qs implicitly auto and declared "
literal|"%<__thread%>"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|threadp
operator|=
name|false
expr_stmt|;
block|}
block|}
comment|/* Now figure out the structure of the declarator proper.      Descend through it, creating more complex types, until we reach      the declared identifier (or NULL_TREE, in an absolute declarator).      At each stage we maintain an unqualified version of the type      together with any qualifiers that should be applied to it with      c_build_qualified_type; this way, array types including      multidimensional array types are first built up in unqualified      form and then the qualified form is created with      TYPE_MAIN_VARIANT pointing to the unqualified form.  */
while|while
condition|(
name|declarator
operator|&&
name|declarator
operator|->
name|kind
operator|!=
name|cdk_id
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
block|{
name|declarator
operator|=
name|declarator
operator|->
name|declarator
expr_stmt|;
continue|continue;
block|}
comment|/* Each level of DECLARATOR is either a cdk_array (for ...[..]), 	 a cdk_pointer (for *...), 	 a cdk_function (for ...(...)), 	 a cdk_attrs (for nested attributes), 	 or a cdk_id (for the name being declared 	 or the place in an absolute declarator 	 where the name was omitted). 	 For the last case, we have just exited the loop.  	 At this point, TYPE is the type of elements of an array, 	 or for a function to return, or for a pointer to point to. 	 After this sequence of ifs, TYPE is the type of the 	 array or function or pointer, and DECLARATOR has had its 	 outermost layer removed.  */
if|if
condition|(
name|array_ptr_quals
operator|!=
name|TYPE_UNQUALIFIED
operator|||
name|array_ptr_attrs
operator|!=
name|NULL_TREE
operator|||
name|array_parm_static
condition|)
block|{
comment|/* Only the innermost declarator (making a parameter be of 	     array type which is converted to pointer type) 	     may have static or type qualifiers.  */
name|error
argument_list|(
literal|"static or type qualifiers in non-parameter array declarator"
argument_list|)
expr_stmt|;
name|array_ptr_quals
operator|=
name|TYPE_UNQUALIFIED
expr_stmt|;
name|array_ptr_attrs
operator|=
name|NULL_TREE
expr_stmt|;
name|array_parm_static
operator|=
literal|0
expr_stmt|;
block|}
switch|switch
condition|(
name|declarator
operator|->
name|kind
condition|)
block|{
case|case
name|cdk_attrs
case|:
block|{
comment|/* A declarator with embedded attributes.  */
name|tree
name|attrs
init|=
name|declarator
operator|->
name|u
operator|.
name|attrs
decl_stmt|;
specifier|const
name|struct
name|c_declarator
modifier|*
name|inner_decl
decl_stmt|;
name|int
name|attr_flags
init|=
literal|0
decl_stmt|;
name|declarator
operator|=
name|declarator
operator|->
name|declarator
expr_stmt|;
name|inner_decl
operator|=
name|declarator
expr_stmt|;
while|while
condition|(
name|inner_decl
operator|->
name|kind
operator|==
name|cdk_attrs
condition|)
name|inner_decl
operator|=
name|inner_decl
operator|->
name|declarator
expr_stmt|;
if|if
condition|(
name|inner_decl
operator|->
name|kind
operator|==
name|cdk_id
condition|)
name|attr_flags
operator||=
operator|(
name|int
operator|)
name|ATTR_FLAG_DECL_NEXT
expr_stmt|;
elseif|else
if|if
condition|(
name|inner_decl
operator|->
name|kind
operator|==
name|cdk_function
condition|)
name|attr_flags
operator||=
operator|(
name|int
operator|)
name|ATTR_FLAG_FUNCTION_NEXT
expr_stmt|;
elseif|else
if|if
condition|(
name|inner_decl
operator|->
name|kind
operator|==
name|cdk_array
condition|)
name|attr_flags
operator||=
operator|(
name|int
operator|)
name|ATTR_FLAG_ARRAY_NEXT
expr_stmt|;
name|returned_attrs
operator|=
name|decl_attributes
argument_list|(
operator|&
name|type
argument_list|,
name|chainon
argument_list|(
name|returned_attrs
argument_list|,
name|attrs
argument_list|)
argument_list|,
name|attr_flags
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|cdk_array
case|:
block|{
name|tree
name|itype
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|size
init|=
name|declarator
operator|->
name|u
operator|.
name|array
operator|.
name|dimen
decl_stmt|;
comment|/* The index is a signed object `sizetype' bits wide.  */
name|tree
name|index_type
init|=
name|c_common_signed_type
argument_list|(
name|sizetype
argument_list|)
decl_stmt|;
name|array_ptr_quals
operator|=
name|declarator
operator|->
name|u
operator|.
name|array
operator|.
name|quals
expr_stmt|;
name|array_ptr_attrs
operator|=
name|declarator
operator|->
name|u
operator|.
name|array
operator|.
name|attrs
expr_stmt|;
name|array_parm_static
operator|=
name|declarator
operator|->
name|u
operator|.
name|array
operator|.
name|static_p
expr_stmt|;
name|array_parm_vla_unspec_p
operator|=
name|declarator
operator|->
name|u
operator|.
name|array
operator|.
name|vla_unspec_p
expr_stmt|;
name|declarator
operator|=
name|declarator
operator|->
name|declarator
expr_stmt|;
comment|/* Check for some types that there cannot be arrays of.  */
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"declaration of %qs as array of voids"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|type
operator|=
name|error_mark_node
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"declaration of %qs as array of functions"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|type
operator|=
name|error_mark_node
expr_stmt|;
block|}
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|in_system_header
operator|&&
name|flexible_array_type_p
argument_list|(
name|type
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"invalid use of structure with flexible array member"
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
name|error_mark_node
condition|)
name|type
operator|=
name|error_mark_node
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
continue|continue;
comment|/* If size was specified, set ITYPE to a range-type for 	       that size.  Otherwise, ITYPE remains null.  finish_decl 	       may figure it out from an initial value.  */
if|if
condition|(
name|size
condition|)
block|{
comment|/* Strip NON_LVALUE_EXPRs since we aren't using as an 		   lvalue.  */
name|STRIP_TYPE_NOPS
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|size
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"size of array %qs has non-integer type"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|size
operator|=
name|integer_one_node
expr_stmt|;
block|}
if|if
condition|(
name|pedantic
operator|&&
name|integer_zerop
argument_list|(
name|size
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"ISO C forbids zero-size array %qs"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|constant_expression_warning
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree_int_cst_sgn
argument_list|(
name|size
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"size of array %qs is negative"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|size
operator|=
name|integer_one_node
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|decl_context
operator|==
name|NORMAL
operator|||
name|decl_context
operator|==
name|FIELD
operator|)
operator|&&
name|current_scope
operator|==
name|file_scope
condition|)
block|{
name|error
argument_list|(
literal|"variably modified %qs at file scope"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|size
operator|=
name|integer_one_node
expr_stmt|;
block|}
else|else
block|{
comment|/* Make sure the array size remains visibly 		       nonconstant even if it is (eg) a const variable 		       with known value.  */
name|size_varies
operator|=
literal|1
expr_stmt|;
name|warn_variable_length_array
argument_list|(
name|orig_name
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|warn_variable_decl
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"variable-sized array %qs"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|integer_zerop
argument_list|(
name|size
argument_list|)
condition|)
block|{
comment|/* A zero-length array cannot be represented with 		       an unsigned index type, which is what we'll 		       get with build_index_type.  Create an 		       open-ended range instead.  */
name|itype
operator|=
name|build_range_type
argument_list|(
name|sizetype
argument_list|,
name|size
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Arrange for the SAVE_EXPR on the inside of the 		       MINUS_EXPR, which allows the -1 to get folded 		       with the +1 that happens when building TYPE_SIZE.  */
if|if
condition|(
name|size_varies
condition|)
name|size
operator|=
name|variable_size
argument_list|(
name|size
argument_list|)
expr_stmt|;
comment|/* Compute the maximum valid index, that is, size 		       - 1.  Do the calculation in index_type, so that 		       if it is a variable the computations will be 		       done in the proper mode.  */
name|itype
operator|=
name|fold_build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|index_type
argument_list|,
name|convert
argument_list|(
name|index_type
argument_list|,
name|size
argument_list|)
argument_list|,
name|convert
argument_list|(
name|index_type
argument_list|,
name|size_one_node
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If that overflowed, the array is too big.  ??? 		       While a size of INT_MAX+1 technically shouldn't 		       cause an overflow (because we subtract 1), the 		       overflow is recorded during the conversion to 		       index_type, before the subtraction.  Handling 		       this case seems like an unnecessary 		       complication.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|itype
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_OVERFLOW
argument_list|(
name|itype
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"size of array %qs is too large"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|type
operator|=
name|error_mark_node
expr_stmt|;
continue|continue;
block|}
name|itype
operator|=
name|build_index_type
argument_list|(
name|itype
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|decl_context
operator|==
name|FIELD
condition|)
block|{
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|flag_isoc99
operator|&&
operator|!
name|in_system_header
condition|)
name|pedwarn
argument_list|(
literal|"ISO C90 does not support flexible array members"
argument_list|)
expr_stmt|;
comment|/* ISO C99 Flexible array members are effectively 		   identical to GCC's zero-length array extension.  */
name|itype
operator|=
name|build_range_type
argument_list|(
name|sizetype
argument_list|,
name|size_zero_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|decl_context
operator|==
name|PARM
condition|)
block|{
if|if
condition|(
name|array_parm_vla_unspec_p
condition|)
block|{
if|if
condition|(
operator|!
name|orig_name
condition|)
block|{
comment|/* C99 6.7.5.2p4 */
name|error
argument_list|(
literal|"%<[*]%> not allowed in other than a declaration"
argument_list|)
expr_stmt|;
block|}
name|itype
operator|=
name|build_range_type
argument_list|(
name|sizetype
argument_list|,
name|size_zero_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|size_varies
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|decl_context
operator|==
name|TYPENAME
condition|)
block|{
if|if
condition|(
name|array_parm_vla_unspec_p
condition|)
block|{
comment|/* The error is printed elsewhere.  We use this to 		       avoid messing up with incomplete array types of 		       the same type, that would otherwise be modified 		       below.  */
name|itype
operator|=
name|build_range_type
argument_list|(
name|sizetype
argument_list|,
name|size_zero_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Complain about arrays of incomplete types.  */
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"array type has incomplete element type"
argument_list|)
expr_stmt|;
name|type
operator|=
name|error_mark_node
expr_stmt|;
block|}
else|else
comment|/* When itype is NULL, a shared incomplete array type is 	       returned for all array of a given type.  Elsewhere we 	       make sure we don't complete that type before copying 	       it, but here we want to make sure we don't ever 	       modify the shared type, so we gcc_assert (itype) 	       below.  */
name|type
operator|=
name|build_array_type
argument_list|(
name|type
argument_list|,
name|itype
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|error_mark_node
condition|)
block|{
if|if
condition|(
name|size_varies
condition|)
block|{
comment|/* It is ok to modify type here even if itype is 		       NULL: if size_varies, we're in a 		       multi-dimensional array and the inner type has 		       variable size, so the enclosing shared array type 		       must too.  */
if|if
condition|(
name|size
operator|&&
name|TREE_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|INTEGER_CST
condition|)
name|type
operator|=
name|build_distinct_type_copy
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|C_TYPE_VARIABLE_SIZE
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* The GCC extension for zero-length arrays differs from 		   ISO flexible array members in that sizeof yields 		   zero.  */
if|if
condition|(
name|size
operator|&&
name|integer_zerop
argument_list|(
name|size
argument_list|)
condition|)
block|{
name|gcc_assert
argument_list|(
name|itype
argument_list|)
expr_stmt|;
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|=
name|bitsize_zero_node
expr_stmt|;
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
operator|=
name|size_zero_node
expr_stmt|;
block|}
if|if
condition|(
name|array_parm_vla_unspec_p
condition|)
block|{
name|gcc_assert
argument_list|(
name|itype
argument_list|)
expr_stmt|;
comment|/* The type is complete.  C99 6.7.5.2p4  */
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|=
name|bitsize_zero_node
expr_stmt|;
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
operator|=
name|size_zero_node
expr_stmt|;
block|}
block|}
if|if
condition|(
name|decl_context
operator|!=
name|PARM
operator|&&
operator|(
name|array_ptr_quals
operator|!=
name|TYPE_UNQUALIFIED
operator|||
name|array_ptr_attrs
operator|!=
name|NULL_TREE
operator|||
name|array_parm_static
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"static or type qualifiers in non-parameter array declarator"
argument_list|)
expr_stmt|;
name|array_ptr_quals
operator|=
name|TYPE_UNQUALIFIED
expr_stmt|;
name|array_ptr_attrs
operator|=
name|NULL_TREE
expr_stmt|;
name|array_parm_static
operator|=
literal|0
expr_stmt|;
block|}
break|break;
block|}
case|case
name|cdk_function
case|:
block|{
comment|/* Say it's a definition only for the declarator closest 	       to the identifier, apart possibly from some 	       attributes.  */
name|bool
name|really_funcdef
init|=
name|false
decl_stmt|;
name|tree
name|arg_types
decl_stmt|;
if|if
condition|(
name|funcdef_flag
condition|)
block|{
specifier|const
name|struct
name|c_declarator
modifier|*
name|t
init|=
name|declarator
operator|->
name|declarator
decl_stmt|;
while|while
condition|(
name|t
operator|->
name|kind
operator|==
name|cdk_attrs
condition|)
name|t
operator|=
name|t
operator|->
name|declarator
expr_stmt|;
name|really_funcdef
operator|=
operator|(
name|t
operator|->
name|kind
operator|==
name|cdk_id
operator|)
expr_stmt|;
block|}
comment|/* Declaring a function type.  Make sure we have a valid 	       type for the function to return.  */
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
continue|continue;
name|size_varies
operator|=
literal|0
expr_stmt|;
comment|/* Warn about some types functions can't return.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"%qs declared as function returning a function"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|type
operator|=
name|integer_type_node
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"%qs declared as function returning an array"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|type
operator|=
name|integer_type_node
expr_stmt|;
block|}
comment|/* Construct the function type and go to the next 	       inner layer of declarator.  */
name|arg_info
operator|=
name|declarator
operator|->
name|u
operator|.
name|arg_info
expr_stmt|;
name|arg_types
operator|=
name|grokparms
argument_list|(
name|arg_info
argument_list|,
name|really_funcdef
argument_list|)
expr_stmt|;
if|if
condition|(
name|really_funcdef
condition|)
name|put_pending_sizes
argument_list|(
name|arg_info
operator|->
name|pending_sizes
argument_list|)
expr_stmt|;
comment|/* Type qualifiers before the return type of the function 	       qualify the return type, not the function type.  */
if|if
condition|(
name|type_quals
condition|)
block|{
comment|/* Type qualifiers on a function return type are 		   normally permitted by the standard but have no 		   effect, so give a warning at -Wreturn-type. 		   Qualifiers on a void return type are banned on 		   function definitions in ISO C; GCC used to used 		   them for noreturn functions.  */
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|really_funcdef
condition|)
name|pedwarn
argument_list|(
literal|"function definition has qualified void return type"
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
name|OPT_Wreturn_type
argument_list|,
literal|"type qualifiers ignored on function return type"
argument_list|)
expr_stmt|;
name|type
operator|=
name|c_build_qualified_type
argument_list|(
name|type
argument_list|,
name|type_quals
argument_list|)
expr_stmt|;
block|}
name|type_quals
operator|=
name|TYPE_UNQUALIFIED
expr_stmt|;
name|type
operator|=
name|build_function_type
argument_list|(
name|type
argument_list|,
name|arg_types
argument_list|)
expr_stmt|;
name|declarator
operator|=
name|declarator
operator|->
name|declarator
expr_stmt|;
comment|/* Set the TYPE_CONTEXTs for each tagged type which is local to 	       the formal parameter list of this FUNCTION_TYPE to point to 	       the FUNCTION_TYPE node itself.  */
block|{
name|tree
name|link
decl_stmt|;
for|for
control|(
name|link
operator|=
name|arg_info
operator|->
name|tags
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
name|TYPE_CONTEXT
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
operator|=
name|type
expr_stmt|;
block|}
break|break;
block|}
case|case
name|cdk_pointer
case|:
block|{
comment|/* Merge any constancy or volatility into the target type 	       for the pointer.  */
if|if
condition|(
name|pedantic
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|&&
name|type_quals
condition|)
name|pedwarn
argument_list|(
literal|"ISO C forbids qualified function types"
argument_list|)
expr_stmt|;
if|if
condition|(
name|type_quals
condition|)
name|type
operator|=
name|c_build_qualified_type
argument_list|(
name|type
argument_list|,
name|type_quals
argument_list|)
expr_stmt|;
name|size_varies
operator|=
literal|0
expr_stmt|;
comment|/* When the pointed-to type involves components of variable size, 	       care must be taken to ensure that the size evaluation code is 	       emitted early enough to dominate all the possible later uses 	       and late enough for the variables on which it depends to have 	       been assigned.  	       This is expected to happen automatically when the pointed-to 	       type has a name/declaration of it's own, but special attention 	       is required if the type is anonymous.  	       We handle the NORMAL and FIELD contexts here by attaching an 	       artificial TYPE_DECL to such pointed-to type.  This forces the 	       sizes evaluation at a safe point and ensures it is not deferred 	       until e.g. within a deeper conditional context.  	       We expect nothing to be needed here for PARM or TYPENAME. 	       Pushing a TYPE_DECL at this point for TYPENAME would actually 	       be incorrect, as we might be in the middle of an expression 	       with side effects on the pointed-to type size "arguments" prior 	       to the pointer declaration point and the fake TYPE_DECL in the 	       enclosing context would force the size evaluation prior to the 	       side effects.  */
if|if
condition|(
operator|!
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|&&
operator|(
name|decl_context
operator|==
name|NORMAL
operator|||
name|decl_context
operator|==
name|FIELD
operator|)
operator|&&
name|variably_modified_type_p
argument_list|(
name|type
argument_list|,
name|NULL_TREE
argument_list|)
condition|)
block|{
name|tree
name|decl
init|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|decl
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|=
name|decl
expr_stmt|;
block|}
name|type
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Process type qualifiers (such as const or volatile) 	       that were given inside the `*'.  */
name|type_quals
operator|=
name|declarator
operator|->
name|u
operator|.
name|pointer_quals
expr_stmt|;
name|declarator
operator|=
name|declarator
operator|->
name|declarator
expr_stmt|;
break|break;
block|}
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Now TYPE has the actual type, apart from any qualifiers in      TYPE_QUALS.  */
comment|/* Check the type and width of a bit-field.  */
if|if
condition|(
name|bitfield
condition|)
name|check_bitfield_type_and_width
argument_list|(
operator|&
name|type
argument_list|,
name|width
argument_list|,
name|orig_name
argument_list|)
expr_stmt|;
comment|/* Did array size calculations overflow?  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_OVERFLOW
argument_list|(
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"size of array %qs is too large"
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* If we proceed with the array type as it is, we'll eventually 	 crash in tree_low_cst().  */
name|type
operator|=
name|error_mark_node
expr_stmt|;
block|}
comment|/* If this is declaring a typedef name, return a TYPE_DECL.  */
if|if
condition|(
name|storage_class
operator|==
name|csc_typedef
condition|)
block|{
name|tree
name|decl
decl_stmt|;
if|if
condition|(
name|pedantic
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|&&
name|type_quals
condition|)
name|pedwarn
argument_list|(
literal|"ISO C forbids qualified function types"
argument_list|)
expr_stmt|;
if|if
condition|(
name|type_quals
condition|)
name|type
operator|=
name|c_build_qualified_type
argument_list|(
name|type
argument_list|,
name|type_quals
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|declarator
operator|->
name|u
operator|.
name|id
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|declspecs
operator|->
name|explicit_signed_p
condition|)
name|C_TYPEDEF_EXPLICITLY_SIGNED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|decl_attributes
argument_list|(
operator|&
name|decl
argument_list|,
name|returned_attrs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|declspecs
operator|->
name|inline_p
condition|)
name|pedwarn
argument_list|(
literal|"typedef %q+D declared %<inline%>"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
comment|/* If this is a type name (such as, in a cast or sizeof),      compute the type and return it now.  */
if|if
condition|(
name|decl_context
operator|==
name|TYPENAME
condition|)
block|{
comment|/* Note that the grammar rejects storage classes in typenames 	 and fields.  */
name|gcc_assert
argument_list|(
name|storage_class
operator|==
name|csc_none
operator|&&
operator|!
name|threadp
operator|&&
operator|!
name|declspecs
operator|->
name|inline_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|pedantic
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|&&
name|type_quals
condition|)
name|pedwarn
argument_list|(
literal|"ISO C forbids const or volatile function types"
argument_list|)
expr_stmt|;
if|if
condition|(
name|type_quals
condition|)
name|type
operator|=
name|c_build_qualified_type
argument_list|(
name|type
argument_list|,
name|type_quals
argument_list|)
expr_stmt|;
name|decl_attributes
argument_list|(
operator|&
name|type
argument_list|,
name|returned_attrs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
if|if
condition|(
name|pedantic
operator|&&
name|decl_context
operator|==
name|FIELD
operator|&&
name|variably_modified_type_p
argument_list|(
name|type
argument_list|,
name|NULL_TREE
argument_list|)
condition|)
block|{
comment|/* C99 6.7.2.1p8 */
name|pedwarn
argument_list|(
literal|"a member of a structure or union cannot have a variably modified type"
argument_list|)
expr_stmt|;
block|}
comment|/* Aside from typedefs and type names (handle above),      `void' at top level (not within pointer)      is allowed only in public variables.      We don't complain about parms either, but that is because      a better error message can be made later.  */
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|decl_context
operator|!=
name|PARM
operator|&&
operator|!
operator|(
operator|(
name|decl_context
operator|!=
name|FIELD
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|FUNCTION_TYPE
operator|)
operator|&&
operator|(
name|storage_class
operator|==
name|csc_extern
operator|||
operator|(
name|current_scope
operator|==
name|file_scope
operator|&&
operator|!
operator|(
name|storage_class
operator|==
name|csc_static
operator|||
name|storage_class
operator|==
name|csc_register
operator|)
operator|)
operator|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"variable or field %qs declared void"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|type
operator|=
name|integer_type_node
expr_stmt|;
block|}
comment|/* Now create the decl, which may be a VAR_DECL, a PARM_DECL      or a FUNCTION_DECL, depending on DECL_CONTEXT and TYPE.  */
block|{
name|tree
name|decl
decl_stmt|;
if|if
condition|(
name|decl_context
operator|==
name|PARM
condition|)
block|{
name|tree
name|type_as_written
decl_stmt|;
name|tree
name|promoted_type
decl_stmt|;
comment|/* A parameter declared as an array of T is really a pointer to T. 	   One declared as a function is really a pointer to a function.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
comment|/* Transfer const-ness of array into that of type pointed to.  */
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type_quals
condition|)
name|type
operator|=
name|c_build_qualified_type
argument_list|(
name|type
argument_list|,
name|type_quals
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|type_quals
operator|=
name|array_ptr_quals
expr_stmt|;
comment|/* We don't yet implement attributes in this context.  */
if|if
condition|(
name|array_ptr_attrs
operator|!=
name|NULL_TREE
condition|)
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"attributes in parameter array declarator ignored"
argument_list|)
expr_stmt|;
name|size_varies
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
if|if
condition|(
name|pedantic
operator|&&
name|type_quals
condition|)
name|pedwarn
argument_list|(
literal|"ISO C forbids qualified function types"
argument_list|)
expr_stmt|;
if|if
condition|(
name|type_quals
condition|)
name|type
operator|=
name|c_build_qualified_type
argument_list|(
name|type
argument_list|,
name|type_quals
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|type_quals
operator|=
name|TYPE_UNQUALIFIED
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type_quals
condition|)
name|type
operator|=
name|c_build_qualified_type
argument_list|(
name|type
argument_list|,
name|type_quals
argument_list|)
expr_stmt|;
name|type_as_written
operator|=
name|type
expr_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|PARM_DECL
argument_list|,
name|declarator
operator|->
name|u
operator|.
name|id
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|size_varies
condition|)
name|C_DECL_VARIABLE_SIZE
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Compute the type actually passed in the parmlist, 	   for the case where there is no prototype. 	   (For example, shorts and chars are passed as ints.) 	   When there is a prototype, this is overridden later.  */
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
name|promoted_type
operator|=
name|type
expr_stmt|;
else|else
name|promoted_type
operator|=
name|c_type_promotes_to
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|DECL_ARG_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|promoted_type
expr_stmt|;
if|if
condition|(
name|declspecs
operator|->
name|inline_p
condition|)
name|pedwarn
argument_list|(
literal|"parameter %q+D declared %<inline%>"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|decl_context
operator|==
name|FIELD
condition|)
block|{
comment|/* Note that the grammar rejects storage classes in typenames 	   and fields.  */
name|gcc_assert
argument_list|(
name|storage_class
operator|==
name|csc_none
operator|&&
operator|!
name|threadp
operator|&&
operator|!
name|declspecs
operator|->
name|inline_p
argument_list|)
expr_stmt|;
comment|/* Structure field.  It may not be a function.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"field %qs declared as a function"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|ERROR_MARK
operator|&&
operator|!
name|COMPLETE_OR_UNBOUND_ARRAY_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"field %qs has incomplete type"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|type
operator|=
name|error_mark_node
expr_stmt|;
block|}
name|type
operator|=
name|c_build_qualified_type
argument_list|(
name|type
argument_list|,
name|type_quals
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|declarator
operator|->
name|u
operator|.
name|id
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|DECL_NONADDRESSABLE_P
argument_list|(
name|decl
argument_list|)
operator|=
name|bitfield
expr_stmt|;
if|if
condition|(
name|size_varies
condition|)
name|C_DECL_VARIABLE_SIZE
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
if|if
condition|(
name|storage_class
operator|==
name|csc_register
operator|||
name|threadp
condition|)
block|{
name|error
argument_list|(
literal|"invalid storage class for function %qs"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|current_scope
operator|!=
name|file_scope
condition|)
block|{
comment|/* Function declaration not at file scope.  Storage 	       classes other than `extern' are not allowed, C99 	       6.7.1p5, and `extern' makes no difference.  However, 	       GCC allows 'auto', perhaps with 'inline', to support 	       nested functions.  */
if|if
condition|(
name|storage_class
operator|==
name|csc_auto
condition|)
block|{
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"invalid storage class for function %qs"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|storage_class
operator|==
name|csc_static
condition|)
block|{
name|error
argument_list|(
literal|"invalid storage class for function %qs"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|funcdef_flag
condition|)
name|storage_class
operator|=
name|declspecs
operator|->
name|storage_class
operator|=
name|csc_none
expr_stmt|;
else|else
return|return
literal|0
return|;
block|}
block|}
name|decl
operator|=
name|build_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|declarator
operator|->
name|u
operator|.
name|id
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_decl_attribute_variant
argument_list|(
name|decl
argument_list|,
name|decl_attr
argument_list|)
expr_stmt|;
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
operator|=
name|GGC_CNEW
argument_list|(
expr|struct
name|lang_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|pedantic
operator|&&
name|type_quals
operator|&&
operator|!
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|decl
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"ISO C forbids qualified function types"
argument_list|)
expr_stmt|;
comment|/* GNU C interprets a volatile-qualified function type to indicate 	   that the function does not return.  */
if|if
condition|(
operator|(
name|type_quals
operator|&
name|TYPE_QUAL_VOLATILE
operator|)
operator|&&
operator|!
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"%<noreturn%> function returns non-void value"
argument_list|)
expr_stmt|;
comment|/* Every function declaration is an external reference 	   (DECL_EXTERNAL) except for those which are not at file 	   scope and are explicitly declared "auto".  This is 	   forbidden by standard C (C99 6.7.1p5) and is interpreted by 	   GCC to signify a forward declaration of a nested function.  */
if|if
condition|(
name|storage_class
operator|==
name|csc_auto
operator|&&
name|current_scope
operator|!=
name|file_scope
condition|)
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* In C99, a function which is declared 'inline' with 'extern' 	   is not an external reference (which is confusing).  It 	   means that the later definition of the function must be output 	   in this file, C99 6.7.4p6.  In GNU C89, a function declared 	   'extern inline' is an external reference.  */
elseif|else
if|if
condition|(
name|declspecs
operator|->
name|inline_p
operator|&&
name|storage_class
operator|!=
name|csc_static
condition|)
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
operator|(
operator|(
name|storage_class
operator|==
name|csc_extern
operator|)
operator|==
name|flag_gnu89_inline
operator|)
expr_stmt|;
else|else
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
operator|!
name|initialized
expr_stmt|;
comment|/* Record absence of global scope for `static' or `auto'.  */
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
operator|!
operator|(
name|storage_class
operator|==
name|csc_static
operator|||
name|storage_class
operator|==
name|csc_auto
operator|)
expr_stmt|;
comment|/* For a function definition, record the argument information 	   block where store_parm_decls will look for it.  */
if|if
condition|(
name|funcdef_flag
condition|)
name|current_function_arg_info
operator|=
name|arg_info
expr_stmt|;
if|if
condition|(
name|declspecs
operator|->
name|default_int_p
condition|)
name|C_FUNCTION_IMPLICIT_INT
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Record presence of `inline', if it is reasonable.  */
if|if
condition|(
name|flag_hosted
operator|&&
name|MAIN_NAME_P
argument_list|(
name|declarator
operator|->
name|u
operator|.
name|id
argument_list|)
condition|)
block|{
if|if
condition|(
name|declspecs
operator|->
name|inline_p
condition|)
name|pedwarn
argument_list|(
literal|"cannot inline function %<main%>"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|declspecs
operator|->
name|inline_p
condition|)
block|{
comment|/* Record that the function is declared `inline'.  */
name|DECL_DECLARED_INLINE_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Do not mark bare declarations as DECL_INLINE.  Doing so 	       in the presence of multiple declarations can result in 	       the abstract origin pointing between the declarations, 	       which will confuse dwarf2out.  */
if|if
condition|(
name|initialized
condition|)
name|DECL_INLINE
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If -finline-functions, assume it can be inlined.  This does 	   two things: let the function be deferred until it is actually 	   needed, and let dwarf2 know that the function is inlinable.  */
elseif|else
if|if
condition|(
name|flag_inline_trees
operator|==
literal|2
operator|&&
name|initialized
condition|)
name|DECL_INLINE
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* It's a variable.  */
comment|/* An uninitialized decl with `extern' is a reference.  */
name|int
name|extern_ref
init|=
operator|!
name|initialized
operator|&&
name|storage_class
operator|==
name|csc_extern
decl_stmt|;
name|type
operator|=
name|c_build_qualified_type
argument_list|(
name|type
argument_list|,
name|type_quals
argument_list|)
expr_stmt|;
comment|/* C99 6.2.2p7: It is invalid (compile-time undefined 	   behavior) to create an 'extern' declaration for a 	   variable if there is a global declaration that is 	   'static' and the global declaration is not visible. 	   (If the static declaration _is_ currently visible, 	   the 'extern' declaration is taken to refer to that decl.) */
if|if
condition|(
name|extern_ref
operator|&&
name|current_scope
operator|!=
name|file_scope
condition|)
block|{
name|tree
name|global_decl
init|=
name|identifier_global_value
argument_list|(
name|declarator
operator|->
name|u
operator|.
name|id
argument_list|)
decl_stmt|;
name|tree
name|visible_decl
init|=
name|lookup_name
argument_list|(
name|declarator
operator|->
name|u
operator|.
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|global_decl
operator|&&
name|global_decl
operator|!=
name|visible_decl
operator|&&
name|TREE_CODE
argument_list|(
name|global_decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
operator|!
name|TREE_PUBLIC
argument_list|(
name|global_decl
argument_list|)
condition|)
name|error
argument_list|(
literal|"variable previously declared %<static%> redeclared "
literal|"%<extern%>"
argument_list|)
expr_stmt|;
block|}
name|decl
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|declarator
operator|->
name|u
operator|.
name|id
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|DECL_SOURCE_LOCATION
argument_list|(
name|decl
argument_list|)
operator|=
name|declarator
operator|->
name|id_loc
expr_stmt|;
if|if
condition|(
name|size_varies
condition|)
name|C_DECL_VARIABLE_SIZE
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|declspecs
operator|->
name|inline_p
condition|)
name|pedwarn
argument_list|(
literal|"variable %q+D declared %<inline%>"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* At file scope, an initialized extern declaration may follow 	   a static declaration.  In that case, DECL_EXTERNAL will be 	   reset later in start_decl.  */
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
operator|(
name|storage_class
operator|==
name|csc_extern
operator|)
expr_stmt|;
comment|/* At file scope, the presence of a `static' or `register' storage 	   class specifier, or the absence of all storage class specifiers 	   makes this declaration a definition (perhaps tentative).  Also, 	   the absence of `static' makes it public.  */
if|if
condition|(
name|current_scope
operator|==
name|file_scope
condition|)
block|{
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
name|storage_class
operator|!=
name|csc_static
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
operator|!
name|extern_ref
expr_stmt|;
block|}
comment|/* Not at file scope, only `static' makes a static definition.  */
else|else
block|{
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
operator|(
name|storage_class
operator|==
name|csc_static
operator|)
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
name|extern_ref
expr_stmt|;
block|}
if|if
condition|(
name|threadp
condition|)
block|{
if|if
condition|(
name|targetm
operator|.
name|have_tls
condition|)
name|DECL_TLS_MODEL
argument_list|(
name|decl
argument_list|)
operator|=
name|decl_default_tls_model
argument_list|(
name|decl
argument_list|)
expr_stmt|;
else|else
comment|/* A mere warning is sure to result in improper semantics 		 at runtime.  Don't bother to allow this to compile.  */
name|error
argument_list|(
literal|"thread-local storage not supported for this target"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|storage_class
operator|==
name|csc_extern
operator|&&
name|variably_modified_type_p
argument_list|(
name|type
argument_list|,
name|NULL_TREE
argument_list|)
condition|)
block|{
comment|/* C99 6.7.5.2p2 */
name|error
argument_list|(
literal|"object with variably modified type must have no linkage"
argument_list|)
expr_stmt|;
block|}
comment|/* Record `register' declaration for warnings on&        and in case doing stupid register allocation.  */
if|if
condition|(
name|storage_class
operator|==
name|csc_register
condition|)
block|{
name|C_DECL_REGISTER
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_REGISTER
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Record constancy and volatility.  */
name|c_apply_type_quals_to_decl
argument_list|(
name|type_quals
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* If a type has volatile components, it should be stored in memory.        Otherwise, the fact that those components are volatile        will be ignored, and would even crash the compiler.        Of course, this only makes sense on  VAR,PARM, and RESULT decl's.   */
if|if
condition|(
name|C_TYPE_FIELDS_VOLATILE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|PARM_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|RESULT_DECL
operator|)
condition|)
block|{
comment|/* It is not an error for a structure with volatile fields to 	   be declared register, but reset DECL_REGISTER since it 	   cannot actually go in a register.  */
name|int
name|was_reg
init|=
name|C_DECL_REGISTER
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|C_DECL_REGISTER
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_REGISTER
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|c_mark_addressable
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|C_DECL_REGISTER
argument_list|(
name|decl
argument_list|)
operator|=
name|was_reg
expr_stmt|;
block|}
comment|/* This is the earliest point at which we might know the assembler      name of a variable.  Thus, if it's known before this, die horribly.  */
name|gcc_assert
argument_list|(
operator|!
name|DECL_ASSEMBLER_NAME_SET_P
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|decl_attributes
argument_list|(
operator|&
name|decl
argument_list|,
name|returned_attrs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Decode the parameter-list info for a function type or function definition.    The argument is the value returned by `get_parm_info' (or made in c-parse.c    if there is an identifier list instead of a parameter decl list).    These two functions are separate because when a function returns    or receives functions then each is called multiple times but the order    of calls is different.  The last call to `grokparms' is always the one    that contains the formal parameter names of a function definition.     Return a list of arg types to use in the FUNCTION_TYPE for this function.     FUNCDEF_FLAG is true for a function definition, false for    a mere declaration.  A nonempty identifier-list gets an error message    when FUNCDEF_FLAG is false.  */
end_comment

begin_function
specifier|static
name|tree
name|grokparms
parameter_list|(
name|struct
name|c_arg_info
modifier|*
name|arg_info
parameter_list|,
name|bool
name|funcdef_flag
parameter_list|)
block|{
name|tree
name|arg_types
init|=
name|arg_info
operator|->
name|types
decl_stmt|;
if|if
condition|(
name|funcdef_flag
operator|&&
name|arg_info
operator|->
name|had_vla_unspec
condition|)
block|{
comment|/* A function definition isn't function prototype scope C99 6.2.1p4.  */
comment|/* C99 6.7.5.2p4 */
name|error
argument_list|(
literal|"%<[*]%> not allowed in other than function prototype scope"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|arg_types
operator|==
literal|0
operator|&&
operator|!
name|funcdef_flag
operator|&&
operator|!
name|in_system_header
condition|)
name|warning
argument_list|(
name|OPT_Wstrict_prototypes
argument_list|,
literal|"function declaration isn%'t a prototype"
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg_types
operator|==
name|error_mark_node
condition|)
return|return
literal|0
return|;
comment|/* don't set TYPE_ARG_TYPES in this case */
elseif|else
if|if
condition|(
name|arg_types
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arg_types
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
if|if
condition|(
operator|!
name|funcdef_flag
condition|)
name|pedwarn
argument_list|(
literal|"parameter names (without types) in function declaration"
argument_list|)
expr_stmt|;
name|arg_info
operator|->
name|parms
operator|=
name|arg_info
operator|->
name|types
expr_stmt|;
name|arg_info
operator|->
name|types
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|tree
name|parm
decl_stmt|,
name|type
decl_stmt|,
name|typelt
decl_stmt|;
name|unsigned
name|int
name|parmno
decl_stmt|;
comment|/* If there is a parameter of incomplete type in a definition, 	 this is an error.  In a declaration this is valid, and a 	 struct or union type may be completed later, before any calls 	 or definition of the function.  In the case where the tag was 	 first declared within the parameter list, a warning has 	 already been given.  If a parameter has void type, then 	 however the function cannot be defined or called, so 	 warn.  */
for|for
control|(
name|parm
operator|=
name|arg_info
operator|->
name|parms
operator|,
name|typelt
operator|=
name|arg_types
operator|,
name|parmno
operator|=
literal|1
init|;
name|parm
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
operator|,
name|typelt
operator|=
name|TREE_CHAIN
argument_list|(
name|typelt
argument_list|)
operator|,
name|parmno
operator|++
control|)
block|{
name|type
operator|=
name|TREE_VALUE
argument_list|(
name|typelt
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
continue|continue;
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|funcdef_flag
condition|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|parm
argument_list|)
condition|)
name|error
argument_list|(
literal|"parameter %u (%q+D) has incomplete type"
argument_list|,
name|parmno
argument_list|,
name|parm
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"%Jparameter %u has incomplete type"
argument_list|,
name|parm
argument_list|,
name|parmno
argument_list|)
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|typelt
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|parm
argument_list|)
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"parameter %u (%q+D) has void type"
argument_list|,
name|parmno
argument_list|,
name|parm
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|0
argument_list|,
literal|"%Jparameter %u has void type"
argument_list|,
name|parm
argument_list|,
name|parmno
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|DECL_NAME
argument_list|(
name|parm
argument_list|)
operator|&&
name|TREE_USED
argument_list|(
name|parm
argument_list|)
condition|)
name|warn_if_shadowing
argument_list|(
name|parm
argument_list|)
expr_stmt|;
block|}
return|return
name|arg_types
return|;
block|}
block|}
end_function

begin_comment
comment|/* Take apart the current scope and return a c_arg_info structure with    info on a parameter list just parsed.     This structure is later fed to 'grokparms' and 'store_parm_decls'.     ELLIPSIS being true means the argument list ended in '...' so don't    append a sentinel (void_list_node) to the end of the type-list.  */
end_comment

begin_function
name|struct
name|c_arg_info
modifier|*
name|get_parm_info
parameter_list|(
name|bool
name|ellipsis
parameter_list|)
block|{
name|struct
name|c_binding
modifier|*
name|b
init|=
name|current_scope
operator|->
name|bindings
decl_stmt|;
name|struct
name|c_arg_info
modifier|*
name|arg_info
init|=
name|XOBNEW
argument_list|(
operator|&
name|parser_obstack
argument_list|,
expr|struct
name|c_arg_info
argument_list|)
decl_stmt|;
name|tree
name|parms
init|=
literal|0
decl_stmt|;
name|tree
name|tags
init|=
literal|0
decl_stmt|;
name|tree
name|types
init|=
literal|0
decl_stmt|;
name|tree
name|others
init|=
literal|0
decl_stmt|;
specifier|static
name|bool
name|explained_incomplete_types
init|=
name|false
decl_stmt|;
name|bool
name|gave_void_only_once_err
init|=
name|false
decl_stmt|;
name|arg_info
operator|->
name|parms
operator|=
literal|0
expr_stmt|;
name|arg_info
operator|->
name|tags
operator|=
literal|0
expr_stmt|;
name|arg_info
operator|->
name|types
operator|=
literal|0
expr_stmt|;
name|arg_info
operator|->
name|others
operator|=
literal|0
expr_stmt|;
name|arg_info
operator|->
name|pending_sizes
operator|=
literal|0
expr_stmt|;
name|arg_info
operator|->
name|had_vla_unspec
operator|=
name|current_scope
operator|->
name|had_vla_unspec
expr_stmt|;
comment|/* The bindings in this scope must not get put into a block.      We will take care of deleting the binding nodes.  */
name|current_scope
operator|->
name|bindings
operator|=
literal|0
expr_stmt|;
comment|/* This function is only called if there was *something* on the      parameter list.  */
name|gcc_assert
argument_list|(
name|b
argument_list|)
expr_stmt|;
comment|/* A parameter list consisting solely of 'void' indicates that the      function takes no arguments.  But if the 'void' is qualified      (by 'const' or 'volatile'), or has a storage class specifier      ('register'), then the behavior is undefined; issue an error.      Typedefs for 'void' are OK (see DR#157).  */
if|if
condition|(
name|b
operator|->
name|prev
operator|==
literal|0
comment|/* one binding */
operator|&&
name|TREE_CODE
argument_list|(
name|b
operator|->
name|decl
argument_list|)
operator|==
name|PARM_DECL
comment|/* which is a parameter */
operator|&&
operator|!
name|DECL_NAME
argument_list|(
name|b
operator|->
name|decl
argument_list|)
comment|/* anonymous */
operator|&&
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|b
operator|->
name|decl
argument_list|)
argument_list|)
condition|)
comment|/* of void type */
block|{
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|b
operator|->
name|decl
argument_list|)
operator|||
name|TREE_READONLY
argument_list|(
name|b
operator|->
name|decl
argument_list|)
operator|||
name|C_DECL_REGISTER
argument_list|(
name|b
operator|->
name|decl
argument_list|)
condition|)
name|error
argument_list|(
literal|"%<void%> as only parameter may not be qualified"
argument_list|)
expr_stmt|;
comment|/* There cannot be an ellipsis.  */
if|if
condition|(
name|ellipsis
condition|)
name|error
argument_list|(
literal|"%<void%> must be the only parameter"
argument_list|)
expr_stmt|;
name|arg_info
operator|->
name|types
operator|=
name|void_list_node
expr_stmt|;
return|return
name|arg_info
return|;
block|}
if|if
condition|(
operator|!
name|ellipsis
condition|)
name|types
operator|=
name|void_list_node
expr_stmt|;
comment|/* Break up the bindings list into parms, tags, types, and others;      apply sanity checks; purge the name-to-decl bindings.  */
while|while
condition|(
name|b
condition|)
block|{
name|tree
name|decl
init|=
name|b
operator|->
name|decl
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|keyword
decl_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
case|case
name|PARM_DECL
case|:
if|if
condition|(
name|b
operator|->
name|id
condition|)
block|{
name|gcc_assert
argument_list|(
name|I_SYMBOL_BINDING
argument_list|(
name|b
operator|->
name|id
argument_list|)
operator|==
name|b
argument_list|)
expr_stmt|;
name|I_SYMBOL_BINDING
argument_list|(
name|b
operator|->
name|id
argument_list|)
operator|=
name|b
operator|->
name|shadowed
expr_stmt|;
block|}
comment|/* Check for forward decls that never got their actual decl.  */
if|if
condition|(
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
condition|)
name|error
argument_list|(
literal|"parameter %q+D has just a forward declaration"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* Check for (..., void, ...) and issue an error.  */
elseif|else
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|gave_void_only_once_err
condition|)
block|{
name|error
argument_list|(
literal|"%<void%> must be the only parameter"
argument_list|)
expr_stmt|;
name|gave_void_only_once_err
operator|=
name|true
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Valid parameter, add it to the list.  */
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
operator|=
name|parms
expr_stmt|;
name|parms
operator|=
name|decl
expr_stmt|;
comment|/* Since there is a prototype, args are passed in their 		 declared types.  The back end may override this later.  */
name|DECL_ARG_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|type
expr_stmt|;
name|types
operator|=
name|tree_cons
argument_list|(
literal|0
argument_list|,
name|type
argument_list|,
name|types
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ENUMERAL_TYPE
case|:
name|keyword
operator|=
literal|"enum"
expr_stmt|;
goto|goto
name|tag
goto|;
case|case
name|UNION_TYPE
case|:
name|keyword
operator|=
literal|"union"
expr_stmt|;
goto|goto
name|tag
goto|;
case|case
name|RECORD_TYPE
case|:
name|keyword
operator|=
literal|"struct"
expr_stmt|;
goto|goto
name|tag
goto|;
name|tag
label|:
comment|/* Types may not have tag-names, in which case the type 	     appears in the bindings list with b->id NULL.  */
if|if
condition|(
name|b
operator|->
name|id
condition|)
block|{
name|gcc_assert
argument_list|(
name|I_TAG_BINDING
argument_list|(
name|b
operator|->
name|id
argument_list|)
operator|==
name|b
argument_list|)
expr_stmt|;
name|I_TAG_BINDING
argument_list|(
name|b
operator|->
name|id
argument_list|)
operator|=
name|b
operator|->
name|shadowed
expr_stmt|;
block|}
comment|/* Warn about any struct, union or enum tags defined in a 	     parameter list.  The scope of such types is limited to 	     the parameter list, which is rarely if ever desirable 	     (it's impossible to call such a function with type- 	     correct arguments).  An anonymous union parm type is 	     meaningful as a GNU extension, so don't warn for that.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|UNION_TYPE
operator|||
name|b
operator|->
name|id
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|b
operator|->
name|id
condition|)
comment|/* The %s will be one of 'struct', 'union', or 'enum'.  */
name|warning
argument_list|(
literal|0
argument_list|,
literal|"%<%s %E%> declared inside parameter list"
argument_list|,
name|keyword
argument_list|,
name|b
operator|->
name|id
argument_list|)
expr_stmt|;
else|else
comment|/* The %s will be one of 'struct', 'union', or 'enum'.  */
name|warning
argument_list|(
literal|0
argument_list|,
literal|"anonymous %s declared inside parameter list"
argument_list|,
name|keyword
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|explained_incomplete_types
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"its scope is only this definition or declaration,"
literal|" which is probably not what you want"
argument_list|)
expr_stmt|;
name|explained_incomplete_types
operator|=
name|true
expr_stmt|;
block|}
block|}
name|tags
operator|=
name|tree_cons
argument_list|(
name|b
operator|->
name|id
argument_list|,
name|decl
argument_list|,
name|tags
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST_DECL
case|:
case|case
name|TYPE_DECL
case|:
case|case
name|FUNCTION_DECL
case|:
comment|/* CONST_DECLs appear here when we have an embedded enum, 	     and TYPE_DECLs appear here when we have an embedded struct 	     or union.  No warnings for this - we already warned about the 	     type itself.  FUNCTION_DECLs appear when there is an implicit 	     function declaration in the parameter list.  */
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
operator|=
name|others
expr_stmt|;
name|others
operator|=
name|decl
expr_stmt|;
comment|/* fall through */
case|case
name|ERROR_MARK
case|:
comment|/* error_mark_node appears here when we have an undeclared 	     variable.  Just throw it away.  */
if|if
condition|(
name|b
operator|->
name|id
condition|)
block|{
name|gcc_assert
argument_list|(
name|I_SYMBOL_BINDING
argument_list|(
name|b
operator|->
name|id
argument_list|)
operator|==
name|b
argument_list|)
expr_stmt|;
name|I_SYMBOL_BINDING
argument_list|(
name|b
operator|->
name|id
argument_list|)
operator|=
name|b
operator|->
name|shadowed
expr_stmt|;
block|}
break|break;
comment|/* Other things that might be encountered.  */
case|case
name|LABEL_DECL
case|:
case|case
name|VAR_DECL
case|:
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|b
operator|=
name|free_binding_and_advance
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
name|arg_info
operator|->
name|parms
operator|=
name|parms
expr_stmt|;
name|arg_info
operator|->
name|tags
operator|=
name|tags
expr_stmt|;
name|arg_info
operator|->
name|types
operator|=
name|types
expr_stmt|;
name|arg_info
operator|->
name|others
operator|=
name|others
expr_stmt|;
name|arg_info
operator|->
name|pending_sizes
operator|=
name|get_pending_sizes
argument_list|()
expr_stmt|;
return|return
name|arg_info
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Get the struct, enum or union (CODE says which) with tag NAME.    Define the tag as a forward-reference if it is not defined.    Return a c_typespec structure for the type specifier.  */
end_comment

begin_function
name|struct
name|c_typespec
name|parser_xref_tag
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|name
parameter_list|)
block|{
name|struct
name|c_typespec
name|ret
decl_stmt|;
comment|/* If a cross reference is requested, look up the type      already defined for this tag and return it.  */
name|tree
name|ref
init|=
name|lookup_tag
argument_list|(
name|code
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* If this is the right type of tag, return what we found.      (This reference will be shadowed by shadow_tag later if appropriate.)      If this is the wrong type of tag, do not return it.  If it was the      wrong type in the same scope, we will have had an error      message already; if in a different scope and declaring      a name, pending_xref_error will give an error message; but if in a      different scope and not declaring a name, this tag should      shadow the previous declaration of a different type of tag, and      this would not work properly if we return the reference found.      (For example, with "struct foo" in an outer scope, "union foo;"      must shadow that tag with a new one of union type.)  */
name|ret
operator|.
name|kind
operator|=
operator|(
name|ref
condition|?
name|ctsk_tagref
else|:
name|ctsk_tagfirstref
operator|)
expr_stmt|;
if|if
condition|(
name|ref
operator|&&
name|TREE_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|code
condition|)
block|{
name|ret
operator|.
name|spec
operator|=
name|ref
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|/* If no such tag is yet defined, create a forward-reference node      and record it as the "definition".      When a real declaration of this type is found,      the forward-reference will be altered into a real type.  */
name|ref
operator|=
name|make_node
argument_list|(
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|ENUMERAL_TYPE
condition|)
block|{
comment|/* Give the type a default layout like unsigned int 	 to avoid crashing if it does not get defined.  */
name|TYPE_MODE
argument_list|(
name|ref
argument_list|)
operator|=
name|TYPE_MODE
argument_list|(
name|unsigned_type_node
argument_list|)
expr_stmt|;
name|TYPE_ALIGN
argument_list|(
name|ref
argument_list|)
operator|=
name|TYPE_ALIGN
argument_list|(
name|unsigned_type_node
argument_list|)
expr_stmt|;
name|TYPE_USER_ALIGN
argument_list|(
name|ref
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_UNSIGNED
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_PRECISION
argument_list|(
name|ref
argument_list|)
operator|=
name|TYPE_PRECISION
argument_list|(
name|unsigned_type_node
argument_list|)
expr_stmt|;
name|TYPE_MIN_VALUE
argument_list|(
name|ref
argument_list|)
operator|=
name|TYPE_MIN_VALUE
argument_list|(
name|unsigned_type_node
argument_list|)
expr_stmt|;
name|TYPE_MAX_VALUE
argument_list|(
name|ref
argument_list|)
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|unsigned_type_node
argument_list|)
expr_stmt|;
block|}
name|pushtag
argument_list|(
name|name
argument_list|,
name|ref
argument_list|)
expr_stmt|;
name|ret
operator|.
name|spec
operator|=
name|ref
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Get the struct, enum or union (CODE says which) with tag NAME.    Define the tag as a forward-reference if it is not defined.    Return a tree for the type.  */
end_comment

begin_function
name|tree
name|xref_tag
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|name
parameter_list|)
block|{
return|return
name|parser_xref_tag
argument_list|(
name|code
argument_list|,
name|name
argument_list|)
operator|.
name|spec
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make sure that the tag NAME is defined *in the current scope*    at least as a forward reference.    CODE says which kind of tag NAME ought to be.  */
end_comment

begin_function
name|tree
name|start_struct
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|name
parameter_list|)
block|{
comment|/* If there is already a tag defined at this scope      (as a forward reference), just return it.  */
name|tree
name|ref
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|name
operator|!=
literal|0
condition|)
name|ref
operator|=
name|lookup_tag
argument_list|(
name|code
argument_list|,
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ref
operator|&&
name|TREE_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|code
condition|)
block|{
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|ref
argument_list|)
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|UNION_TYPE
condition|)
name|error
argument_list|(
literal|"redefinition of %<union %E%>"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"redefinition of %<struct %E%>"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|C_TYPE_BEING_DEFINED
argument_list|(
name|ref
argument_list|)
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|UNION_TYPE
condition|)
name|error
argument_list|(
literal|"nested redefinition of %<union %E%>"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"nested redefinition of %<struct %E%>"
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Don't create structures that contain themselves.  */
name|ref
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
comment|/* Otherwise create a forward-reference just so the tag is in scope.  */
if|if
condition|(
name|ref
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|ref
argument_list|)
operator|!=
name|code
condition|)
block|{
name|ref
operator|=
name|make_node
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|pushtag
argument_list|(
name|name
argument_list|,
name|ref
argument_list|)
expr_stmt|;
block|}
name|C_TYPE_BEING_DEFINED
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_PACKED
argument_list|(
name|ref
argument_list|)
operator|=
name|flag_pack_struct
expr_stmt|;
return|return
name|ref
return|;
block|}
end_function

begin_comment
comment|/* Process the specs, declarator and width (NULL if omitted)    of a structure component, returning a FIELD_DECL node.    WIDTH is non-NULL for bit-fields only, and is an INTEGER_CST node.     This is done during the parsing of the struct declaration.    The FIELD_DECL nodes are chained together and the lot of them    are ultimately passed to `build_struct' to make the RECORD_TYPE node.  */
end_comment

begin_function
name|tree
name|grokfield
parameter_list|(
name|struct
name|c_declarator
modifier|*
name|declarator
parameter_list|,
name|struct
name|c_declspecs
modifier|*
name|declspecs
parameter_list|,
name|tree
name|width
parameter_list|)
block|{
name|tree
name|value
decl_stmt|;
if|if
condition|(
name|declarator
operator|->
name|kind
operator|==
name|cdk_id
operator|&&
name|declarator
operator|->
name|u
operator|.
name|id
operator|==
name|NULL_TREE
operator|&&
name|width
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* This is an unnamed decl.  	 If we have something of the form "union { list } ;" then this 	 is the anonymous union extension.  Similarly for struct.  	 If this is something of the form "struct foo;", then 	   If MS extensions are enabled, this is handled as an 	     anonymous struct. 	   Otherwise this is a forward declaration of a structure tag.  	 If this is something of the form "foo;" and foo is a TYPE_DECL, then 	   If MS extensions are enabled and foo names a structure, then 	     again this is an anonymous struct. 	   Otherwise this is an error.  	 Oh what a horrid tangled web we weave.  I wonder if MS consciously 	 took this from Plan 9 or if it was an accident of implementation 	 that took root before someone noticed the bug...  */
name|tree
name|type
init|=
name|declspecs
operator|->
name|type
decl_stmt|;
name|bool
name|type_ok
init|=
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
operator|)
decl_stmt|;
name|bool
name|ok
init|=
name|false
decl_stmt|;
if|if
condition|(
name|type_ok
operator|&&
operator|(
name|flag_ms_extensions
operator|||
operator|!
name|declspecs
operator|->
name|typedef_p
operator|)
condition|)
block|{
if|if
condition|(
name|flag_ms_extensions
condition|)
name|ok
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
name|flag_iso
condition|)
name|ok
operator|=
name|false
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|==
name|NULL
condition|)
name|ok
operator|=
name|true
expr_stmt|;
else|else
name|ok
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|pedwarn
argument_list|(
literal|"declaration does not declare anything"
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ISO C doesn%'t support unnamed structs/unions"
argument_list|)
expr_stmt|;
block|}
name|value
operator|=
name|grokdeclarator
argument_list|(
name|declarator
argument_list|,
name|declspecs
argument_list|,
name|FIELD
argument_list|,
name|false
argument_list|,
name|width
condition|?
operator|&
name|width
else|:
name|NULL
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|value
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|value
argument_list|)
operator|=
name|width
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate an error for any duplicate field names in FIELDLIST.  Munge    the list such that this does not present a problem later.  */
end_comment

begin_function
specifier|static
name|void
name|detect_field_duplicates
parameter_list|(
name|tree
name|fieldlist
parameter_list|)
block|{
name|tree
name|x
decl_stmt|,
name|y
decl_stmt|;
name|int
name|timeout
init|=
literal|10
decl_stmt|;
comment|/* First, see if there are more than "a few" fields.      This is trivially true if there are zero or one fields.  */
if|if
condition|(
operator|!
name|fieldlist
condition|)
return|return;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|fieldlist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|x
condition|)
return|return;
do|do
block|{
name|timeout
operator|--
expr_stmt|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|timeout
operator|>
literal|0
operator|&&
name|x
condition|)
do|;
comment|/* If there were "few" fields, avoid the overhead of allocating      a hash table.  Instead just do the nested traversal thing.  */
if|if
condition|(
name|timeout
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|fieldlist
argument_list|)
init|;
name|x
condition|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
control|)
if|if
condition|(
name|DECL_NAME
argument_list|(
name|x
argument_list|)
condition|)
block|{
for|for
control|(
name|y
operator|=
name|fieldlist
init|;
name|y
operator|!=
name|x
condition|;
name|y
operator|=
name|TREE_CHAIN
argument_list|(
name|y
argument_list|)
control|)
if|if
condition|(
name|DECL_NAME
argument_list|(
name|y
argument_list|)
operator|==
name|DECL_NAME
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"duplicate member %q+D"
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|DECL_NAME
argument_list|(
name|x
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|htab_t
name|htab
init|=
name|htab_create
argument_list|(
literal|37
argument_list|,
name|htab_hash_pointer
argument_list|,
name|htab_eq_pointer
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
for|for
control|(
name|x
operator|=
name|fieldlist
init|;
name|x
condition|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
control|)
if|if
condition|(
operator|(
name|y
operator|=
name|DECL_NAME
argument_list|(
name|x
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|slot
operator|=
name|htab_find_slot
argument_list|(
name|htab
argument_list|,
name|y
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|slot
condition|)
block|{
name|error
argument_list|(
literal|"duplicate member %q+D"
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|DECL_NAME
argument_list|(
name|x
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
operator|*
name|slot
operator|=
name|y
expr_stmt|;
block|}
name|htab_delete
argument_list|(
name|htab
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Fill in the fields of a RECORD_TYPE or UNION_TYPE node, T.    FIELDLIST is a chain of FIELD_DECL nodes for the fields.    ATTRIBUTES are attributes to be applied to the structure.  */
end_comment

begin_function
name|tree
name|finish_struct
parameter_list|(
name|tree
name|t
parameter_list|,
name|tree
name|fieldlist
parameter_list|,
name|tree
name|attributes
parameter_list|)
block|{
name|tree
name|x
decl_stmt|;
name|bool
name|toplevel
init|=
name|file_scope
operator|==
name|current_scope
decl_stmt|;
name|int
name|saw_named_field
decl_stmt|;
comment|/* If this type was previously laid out as a forward reference,      make sure we lay it out again.  */
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
name|decl_attributes
argument_list|(
operator|&
name|t
argument_list|,
name|attributes
argument_list|,
operator|(
name|int
operator|)
name|ATTR_FLAG_TYPE_IN_PLACE
argument_list|)
expr_stmt|;
if|if
condition|(
name|pedantic
condition|)
block|{
for|for
control|(
name|x
operator|=
name|fieldlist
init|;
name|x
condition|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
control|)
if|if
condition|(
name|DECL_NAME
argument_list|(
name|x
argument_list|)
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
if|if
condition|(
name|fieldlist
condition|)
name|pedwarn
argument_list|(
literal|"union has no named members"
argument_list|)
expr_stmt|;
else|else
name|pedwarn
argument_list|(
literal|"union has no members"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|fieldlist
condition|)
name|pedwarn
argument_list|(
literal|"struct has no named members"
argument_list|)
expr_stmt|;
else|else
name|pedwarn
argument_list|(
literal|"struct has no members"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Install struct as DECL_CONTEXT of each field decl.      Also process specified field sizes, found in the DECL_INITIAL,      storing 0 there after the type has been changed to precision equal      to its width, rather than the precision of the specified standard      type.  (Correct layout requires the original type to have been preserved      until now.)  */
name|saw_named_field
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|x
operator|=
name|fieldlist
init|;
name|x
condition|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
operator|==
name|error_mark_node
condition|)
continue|continue;
name|DECL_CONTEXT
argument_list|(
name|x
argument_list|)
operator|=
name|t
expr_stmt|;
if|if
condition|(
name|TYPE_PACKED
argument_list|(
name|t
argument_list|)
operator|&&
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|>
name|BITS_PER_UNIT
condition|)
name|DECL_PACKED
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* If any field is const, the structure type is pseudo-const.  */
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|x
argument_list|)
condition|)
name|C_TYPE_FIELDS_READONLY
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
block|{
comment|/* A field that is pseudo-const makes the structure likewise.  */
name|tree
name|t1
init|=
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
decl_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|t1
operator|=
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|UNION_TYPE
operator|)
operator|&&
name|C_TYPE_FIELDS_READONLY
argument_list|(
name|t1
argument_list|)
condition|)
name|C_TYPE_FIELDS_READONLY
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Any field that is volatile means variables of this type must be 	 treated in some ways as volatile.  */
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|x
argument_list|)
condition|)
name|C_TYPE_FIELDS_VOLATILE
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Any field of nominal variable size implies structure is too.  */
if|if
condition|(
name|C_DECL_VARIABLE_SIZE
argument_list|(
name|x
argument_list|)
condition|)
name|C_TYPE_VARIABLE_SIZE
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|width
init|=
name|tree_low_cst
argument_list|(
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|DECL_SIZE
argument_list|(
name|x
argument_list|)
operator|=
name|bitsize_int
argument_list|(
name|width
argument_list|)
expr_stmt|;
name|DECL_BIT_FIELD
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
name|SET_DECL_C_BIT_FIELD
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
comment|/* Detect flexible array member in an invalid context.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|TYPE_MAX_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"%Jflexible array member in union"
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"%Jflexible array member not at end of struct"
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|saw_named_field
condition|)
block|{
name|error
argument_list|(
literal|"%Jflexible array member in otherwise empty struct"
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|in_system_header
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|flexible_array_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"%Jinvalid use of structure with flexible array member"
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|x
argument_list|)
condition|)
name|saw_named_field
operator|=
literal|1
expr_stmt|;
block|}
name|detect_field_duplicates
argument_list|(
name|fieldlist
argument_list|)
expr_stmt|;
comment|/* Now we have the nearly final fieldlist.  Record it,      then lay out the structure or union (including the fields).  */
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
operator|=
name|fieldlist
expr_stmt|;
name|layout_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Give bit-fields their proper types.  */
block|{
name|tree
modifier|*
name|fieldlistp
init|=
operator|&
name|fieldlist
decl_stmt|;
while|while
condition|(
operator|*
name|fieldlistp
condition|)
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|fieldlistp
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
operator|*
name|fieldlistp
argument_list|)
operator|&&
name|TREE_TYPE
argument_list|(
operator|*
name|fieldlistp
argument_list|)
operator|!=
name|error_mark_node
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|width
init|=
name|tree_low_cst
argument_list|(
name|DECL_INITIAL
argument_list|(
operator|*
name|fieldlistp
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
operator|*
name|fieldlistp
argument_list|)
decl_stmt|;
if|if
condition|(
name|width
operator|!=
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|TREE_TYPE
argument_list|(
operator|*
name|fieldlistp
argument_list|)
operator|=
name|c_build_bitfield_integer_type
argument_list|(
name|width
argument_list|,
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_MODE
argument_list|(
operator|*
name|fieldlistp
argument_list|)
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
operator|*
name|fieldlistp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|DECL_INITIAL
argument_list|(
operator|*
name|fieldlistp
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|fieldlistp
operator|=
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|fieldlistp
argument_list|)
expr_stmt|;
block|}
comment|/* Now we have the truly final field list.      Store it in this type and in the variants.  */
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
operator|=
name|fieldlist
expr_stmt|;
comment|/* If there are lots of fields, sort so we can look through them fast.      We arbitrarily consider 16 or more elts to be "a lot".  */
block|{
name|int
name|len
init|=
literal|0
decl_stmt|;
for|for
control|(
name|x
operator|=
name|fieldlist
init|;
name|x
condition|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
control|)
block|{
if|if
condition|(
name|len
operator|>
literal|15
operator|||
name|DECL_NAME
argument_list|(
name|x
argument_list|)
operator|==
name|NULL
condition|)
break|break;
name|len
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|>
literal|15
condition|)
block|{
name|tree
modifier|*
name|field_array
decl_stmt|;
name|struct
name|lang_type
modifier|*
name|space
decl_stmt|;
name|struct
name|sorted_fields_type
modifier|*
name|space2
decl_stmt|;
name|len
operator|+=
name|list_length
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* Use the same allocation policy here that make_node uses, to 	  ensure that this lives as long as the rest of the struct decl. 	  All decls in an inline function need to be saved.  */
name|space
operator|=
name|GGC_CNEW
argument_list|(
expr|struct
name|lang_type
argument_list|)
expr_stmt|;
name|space2
operator|=
name|GGC_NEWVAR
argument_list|(
expr|struct
name|sorted_fields_type
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sorted_fields_type
argument_list|)
operator|+
name|len
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
name|space
operator|->
name|s
operator|=
name|space2
expr_stmt|;
name|field_array
operator|=
operator|&
name|space2
operator|->
name|elts
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|x
operator|=
name|fieldlist
init|;
name|x
condition|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
control|)
block|{
name|field_array
index|[
name|len
operator|++
index|]
operator|=
name|x
expr_stmt|;
comment|/* If there is anonymous struct or union, break out of the loop.  */
if|if
condition|(
name|DECL_NAME
argument_list|(
name|x
argument_list|)
operator|==
name|NULL
condition|)
break|break;
block|}
comment|/* Found no anonymous struct/union.  Add the TYPE_LANG_SPECIFIC.  */
if|if
condition|(
name|x
operator|==
name|NULL
condition|)
block|{
name|TYPE_LANG_SPECIFIC
argument_list|(
name|t
argument_list|)
operator|=
name|space
expr_stmt|;
name|TYPE_LANG_SPECIFIC
argument_list|(
name|t
argument_list|)
operator|->
name|s
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|field_array
operator|=
name|TYPE_LANG_SPECIFIC
argument_list|(
name|t
argument_list|)
operator|->
name|s
operator|->
name|elts
expr_stmt|;
name|qsort
argument_list|(
name|field_array
argument_list|,
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|,
name|field_decl_cmp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|x
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
init|;
name|x
condition|;
name|x
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|x
argument_list|)
control|)
block|{
name|TYPE_FIELDS
argument_list|(
name|x
argument_list|)
operator|=
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_LANG_SPECIFIC
argument_list|(
name|x
argument_list|)
operator|=
name|TYPE_LANG_SPECIFIC
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|C_TYPE_FIELDS_READONLY
argument_list|(
name|x
argument_list|)
operator|=
name|C_TYPE_FIELDS_READONLY
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|C_TYPE_FIELDS_VOLATILE
argument_list|(
name|x
argument_list|)
operator|=
name|C_TYPE_FIELDS_VOLATILE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|C_TYPE_VARIABLE_SIZE
argument_list|(
name|x
argument_list|)
operator|=
name|C_TYPE_VARIABLE_SIZE
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
comment|/* If this was supposed to be a transparent union, but we can't      make it one, warn and turn off the flag.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|UNION_TYPE
operator|&&
name|TYPE_TRANSPARENT_UNION
argument_list|(
name|t
argument_list|)
operator|&&
operator|(
operator|!
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
operator|||
name|TYPE_MODE
argument_list|(
name|t
argument_list|)
operator|!=
name|DECL_MODE
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|TYPE_TRANSPARENT_UNION
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
name|warning
argument_list|(
literal|0
argument_list|,
literal|"union cannot be made transparent"
argument_list|)
expr_stmt|;
block|}
comment|/* If this structure or union completes the type of any previous      variable declaration, lay it out and output its rtl.  */
for|for
control|(
name|x
operator|=
name|C_TYPE_INCOMPLETE_VARS
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
argument_list|)
init|;
name|x
condition|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
control|)
block|{
name|tree
name|decl
init|=
name|TREE_VALUE
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|layout_array_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
block|{
name|layout_decl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_dialect_objc
argument_list|()
condition|)
name|objc_check_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|rest_of_decl_compilation
argument_list|(
name|decl
argument_list|,
name|toplevel
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|toplevel
condition|)
name|expand_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
name|C_TYPE_INCOMPLETE_VARS
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Finish debugging output for this type.  */
name|rest_of_type_compilation
argument_list|(
name|t
argument_list|,
name|toplevel
argument_list|)
expr_stmt|;
comment|/* If we're inside a function proper, i.e. not file-scope and not still      parsing parameters, then arrange for the size of a variable sized type      to be bound now.  */
if|if
condition|(
name|cur_stmt_list
operator|&&
name|variably_modified_type_p
argument_list|(
name|t
argument_list|,
name|NULL_TREE
argument_list|)
condition|)
name|add_stmt
argument_list|(
name|build_stmt
argument_list|(
name|DECL_EXPR
argument_list|,
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|NULL
argument_list|,
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Lay out the type T, and its element type, and so on.  */
end_comment

begin_function
specifier|static
name|void
name|layout_array_type
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|layout_array_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|layout_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Begin compiling the definition of an enumeration type.    NAME is its name (or null if anonymous).    Returns the type object, as yet incomplete.    Also records info about it so that build_enumerator    may be used to declare the individual values as they are read.  */
end_comment

begin_function
name|tree
name|start_enum
parameter_list|(
name|tree
name|name
parameter_list|)
block|{
name|tree
name|enumtype
init|=
literal|0
decl_stmt|;
comment|/* If this is the real definition for a previous forward reference,      fill in the contents in the same object that used to be the      forward reference.  */
if|if
condition|(
name|name
operator|!=
literal|0
condition|)
name|enumtype
operator|=
name|lookup_tag
argument_list|(
name|ENUMERAL_TYPE
argument_list|,
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|enumtype
operator|==
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|enumtype
argument_list|)
operator|!=
name|ENUMERAL_TYPE
condition|)
block|{
name|enumtype
operator|=
name|make_node
argument_list|(
name|ENUMERAL_TYPE
argument_list|)
expr_stmt|;
name|pushtag
argument_list|(
name|name
argument_list|,
name|enumtype
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|C_TYPE_BEING_DEFINED
argument_list|(
name|enumtype
argument_list|)
condition|)
name|error
argument_list|(
literal|"nested redefinition of %<enum %E%>"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|C_TYPE_BEING_DEFINED
argument_list|(
name|enumtype
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TYPE_VALUES
argument_list|(
name|enumtype
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* This enum is a named one that has been declared already.  */
name|error
argument_list|(
literal|"redeclaration of %<enum %E%>"
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Completely replace its old definition. 	 The old enumerators remain defined, however.  */
name|TYPE_VALUES
argument_list|(
name|enumtype
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
name|enum_next_value
operator|=
name|integer_zero_node
expr_stmt|;
name|enum_overflow
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flag_short_enums
condition|)
name|TYPE_PACKED
argument_list|(
name|enumtype
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|enumtype
return|;
block|}
end_function

begin_comment
comment|/* After processing and defining all the values of an enumeration type,    install their decls in the enumeration type and finish it off.    ENUMTYPE is the type object, VALUES a list of decl-value pairs,    and ATTRIBUTES are the specified attributes.    Returns ENUMTYPE.  */
end_comment

begin_function
name|tree
name|finish_enum
parameter_list|(
name|tree
name|enumtype
parameter_list|,
name|tree
name|values
parameter_list|,
name|tree
name|attributes
parameter_list|)
block|{
name|tree
name|pair
decl_stmt|,
name|tem
decl_stmt|;
name|tree
name|minnode
init|=
literal|0
decl_stmt|,
name|maxnode
init|=
literal|0
decl_stmt|;
name|int
name|precision
decl_stmt|,
name|unsign
decl_stmt|;
name|bool
name|toplevel
init|=
operator|(
name|file_scope
operator|==
name|current_scope
operator|)
decl_stmt|;
name|struct
name|lang_type
modifier|*
name|lt
decl_stmt|;
name|decl_attributes
argument_list|(
operator|&
name|enumtype
argument_list|,
name|attributes
argument_list|,
operator|(
name|int
operator|)
name|ATTR_FLAG_TYPE_IN_PLACE
argument_list|)
expr_stmt|;
comment|/* Calculate the maximum value of any enumerator in this type.  */
if|if
condition|(
name|values
operator|==
name|error_mark_node
condition|)
name|minnode
operator|=
name|maxnode
operator|=
name|integer_zero_node
expr_stmt|;
else|else
block|{
name|minnode
operator|=
name|maxnode
operator|=
name|TREE_VALUE
argument_list|(
name|values
argument_list|)
expr_stmt|;
for|for
control|(
name|pair
operator|=
name|TREE_CHAIN
argument_list|(
name|values
argument_list|)
init|;
name|pair
condition|;
name|pair
operator|=
name|TREE_CHAIN
argument_list|(
name|pair
argument_list|)
control|)
block|{
name|tree
name|value
init|=
name|TREE_VALUE
argument_list|(
name|pair
argument_list|)
decl_stmt|;
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|maxnode
argument_list|,
name|value
argument_list|)
condition|)
name|maxnode
operator|=
name|value
expr_stmt|;
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|value
argument_list|,
name|minnode
argument_list|)
condition|)
name|minnode
operator|=
name|value
expr_stmt|;
block|}
block|}
comment|/* Construct the final type of this enumeration.  It is the same      as one of the integral types - the narrowest one that fits, except      that normally we only go as narrow as int - and signed iff any of      the values are negative.  */
name|unsign
operator|=
operator|(
name|tree_int_cst_sgn
argument_list|(
name|minnode
argument_list|)
operator|>=
literal|0
operator|)
expr_stmt|;
name|precision
operator|=
name|MAX
argument_list|(
name|min_precision
argument_list|(
name|minnode
argument_list|,
name|unsign
argument_list|)
argument_list|,
name|min_precision
argument_list|(
name|maxnode
argument_list|,
name|unsign
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_PACKED
argument_list|(
name|enumtype
argument_list|)
operator|||
name|precision
operator|>
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
condition|)
block|{
name|tem
operator|=
name|c_common_type_for_size
argument_list|(
name|precision
argument_list|,
name|unsign
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|==
name|NULL
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"enumeration values exceed range of largest integer"
argument_list|)
expr_stmt|;
name|tem
operator|=
name|long_long_integer_type_node
expr_stmt|;
block|}
block|}
else|else
name|tem
operator|=
name|unsign
condition|?
name|unsigned_type_node
else|:
name|integer_type_node
expr_stmt|;
name|TYPE_MIN_VALUE
argument_list|(
name|enumtype
argument_list|)
operator|=
name|TYPE_MIN_VALUE
argument_list|(
name|tem
argument_list|)
expr_stmt|;
name|TYPE_MAX_VALUE
argument_list|(
name|enumtype
argument_list|)
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|tem
argument_list|)
expr_stmt|;
name|TYPE_UNSIGNED
argument_list|(
name|enumtype
argument_list|)
operator|=
name|TYPE_UNSIGNED
argument_list|(
name|tem
argument_list|)
expr_stmt|;
name|TYPE_SIZE
argument_list|(
name|enumtype
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* If the precision of the type was specific with an attribute and it      was too small, give an error.  Otherwise, use it.  */
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|enumtype
argument_list|)
condition|)
block|{
if|if
condition|(
name|precision
operator|>
name|TYPE_PRECISION
argument_list|(
name|enumtype
argument_list|)
condition|)
name|error
argument_list|(
literal|"specified mode too small for enumeral values"
argument_list|)
expr_stmt|;
block|}
else|else
name|TYPE_PRECISION
argument_list|(
name|enumtype
argument_list|)
operator|=
name|TYPE_PRECISION
argument_list|(
name|tem
argument_list|)
expr_stmt|;
name|layout_type
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|values
operator|!=
name|error_mark_node
condition|)
block|{
comment|/* Change the type of the enumerators to be the enum type.  We 	 need to do this irrespective of the size of the enum, for 	 proper type checking.  Replace the DECL_INITIALs of the 	 enumerators, and the value slots of the list, with copies 	 that have the enum type; they cannot be modified in place 	 because they may be shared (e.g.  integer_zero_node) Finally, 	 change the purpose slots to point to the names of the decls.  */
for|for
control|(
name|pair
operator|=
name|values
init|;
name|pair
condition|;
name|pair
operator|=
name|TREE_CHAIN
argument_list|(
name|pair
argument_list|)
control|)
block|{
name|tree
name|enu
init|=
name|TREE_PURPOSE
argument_list|(
name|pair
argument_list|)
decl_stmt|;
name|tree
name|ini
init|=
name|DECL_INITIAL
argument_list|(
name|enu
argument_list|)
decl_stmt|;
name|TREE_TYPE
argument_list|(
name|enu
argument_list|)
operator|=
name|enumtype
expr_stmt|;
comment|/* The ISO C Standard mandates enumerators to have type int, 	     even though the underlying type of an enum type is 	     unspecified.  Here we convert any enumerators that fit in 	     an int to type int, to avoid promotions to unsigned types 	     when comparing integers with enumerators that fit in the 	     int range.  When -pedantic is given, build_enumerator() 	     would have already taken care of those that don't fit.  */
if|if
condition|(
name|int_fits_type_p
argument_list|(
name|ini
argument_list|,
name|integer_type_node
argument_list|)
condition|)
name|tem
operator|=
name|integer_type_node
expr_stmt|;
else|else
name|tem
operator|=
name|enumtype
expr_stmt|;
name|ini
operator|=
name|convert
argument_list|(
name|tem
argument_list|,
name|ini
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|enu
argument_list|)
operator|=
name|ini
expr_stmt|;
name|TREE_PURPOSE
argument_list|(
name|pair
argument_list|)
operator|=
name|DECL_NAME
argument_list|(
name|enu
argument_list|)
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|pair
argument_list|)
operator|=
name|ini
expr_stmt|;
block|}
name|TYPE_VALUES
argument_list|(
name|enumtype
argument_list|)
operator|=
name|values
expr_stmt|;
block|}
comment|/* Record the min/max values so that we can warn about bit-field      enumerations that are too small for the values.  */
name|lt
operator|=
name|GGC_CNEW
argument_list|(
expr|struct
name|lang_type
argument_list|)
expr_stmt|;
name|lt
operator|->
name|enum_min
operator|=
name|minnode
expr_stmt|;
name|lt
operator|->
name|enum_max
operator|=
name|maxnode
expr_stmt|;
name|TYPE_LANG_SPECIFIC
argument_list|(
name|enumtype
argument_list|)
operator|=
name|lt
expr_stmt|;
comment|/* Fix up all variant types of this enum type.  */
for|for
control|(
name|tem
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|enumtype
argument_list|)
init|;
name|tem
condition|;
name|tem
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|tem
argument_list|)
control|)
block|{
if|if
condition|(
name|tem
operator|==
name|enumtype
condition|)
continue|continue;
name|TYPE_VALUES
argument_list|(
name|tem
argument_list|)
operator|=
name|TYPE_VALUES
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
name|TYPE_MIN_VALUE
argument_list|(
name|tem
argument_list|)
operator|=
name|TYPE_MIN_VALUE
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
name|TYPE_MAX_VALUE
argument_list|(
name|tem
argument_list|)
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
name|TYPE_SIZE
argument_list|(
name|tem
argument_list|)
operator|=
name|TYPE_SIZE
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
name|TYPE_SIZE_UNIT
argument_list|(
name|tem
argument_list|)
operator|=
name|TYPE_SIZE_UNIT
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
name|TYPE_MODE
argument_list|(
name|tem
argument_list|)
operator|=
name|TYPE_MODE
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
name|TYPE_PRECISION
argument_list|(
name|tem
argument_list|)
operator|=
name|TYPE_PRECISION
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
name|TYPE_ALIGN
argument_list|(
name|tem
argument_list|)
operator|=
name|TYPE_ALIGN
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
name|TYPE_USER_ALIGN
argument_list|(
name|tem
argument_list|)
operator|=
name|TYPE_USER_ALIGN
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
name|TYPE_UNSIGNED
argument_list|(
name|tem
argument_list|)
operator|=
name|TYPE_UNSIGNED
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
name|TYPE_LANG_SPECIFIC
argument_list|(
name|tem
argument_list|)
operator|=
name|TYPE_LANG_SPECIFIC
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
block|}
comment|/* Finish debugging output for this type.  */
name|rest_of_type_compilation
argument_list|(
name|enumtype
argument_list|,
name|toplevel
argument_list|)
expr_stmt|;
return|return
name|enumtype
return|;
block|}
end_function

begin_comment
comment|/* Build and install a CONST_DECL for one value of the    current enumeration type (one that was begun with start_enum).    Return a tree-list containing the CONST_DECL and its value.    Assignment of sequential values by default is handled here.  */
end_comment

begin_function
name|tree
name|build_enumerator
parameter_list|(
name|tree
name|name
parameter_list|,
name|tree
name|value
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|,
name|type
decl_stmt|;
comment|/* Validate and default VALUE.  */
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
block|{
comment|/* Don't issue more errors for error_mark_node (i.e. an 	 undeclared identifier) - just ignore the value expression.  */
if|if
condition|(
name|value
operator|==
name|error_mark_node
condition|)
name|value
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
name|error
argument_list|(
literal|"enumerator value for %qE is not an integer constant"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|value
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|value
operator|=
name|default_conversion
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|constant_expression_warning
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Default based on previous value.  */
comment|/* It should no longer be possible to have NON_LVALUE_EXPR      in the default.  */
if|if
condition|(
name|value
operator|==
literal|0
condition|)
block|{
name|value
operator|=
name|enum_next_value
expr_stmt|;
if|if
condition|(
name|enum_overflow
condition|)
name|error
argument_list|(
literal|"overflow in enumeration values"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|int_fits_type_p
argument_list|(
name|value
argument_list|,
name|integer_type_node
argument_list|)
condition|)
block|{
name|pedwarn
argument_list|(
literal|"ISO C restricts enumerator values to range of %<int%>"
argument_list|)
expr_stmt|;
comment|/* XXX This causes -pedantic to change the meaning of the program. 	 Remove?  -zw 2004-03-15  */
name|value
operator|=
name|convert
argument_list|(
name|integer_type_node
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
comment|/* Set basis for default for next value.  */
name|enum_next_value
operator|=
name|build_binary_op
argument_list|(
name|PLUS_EXPR
argument_list|,
name|value
argument_list|,
name|integer_one_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|enum_overflow
operator|=
name|tree_int_cst_lt
argument_list|(
name|enum_next_value
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|/* Now create a declaration for the enum value name.  */
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|type
operator|=
name|c_common_type_for_size
argument_list|(
name|MAX
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
argument_list|)
argument_list|,
operator|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|>=
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|&&
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|CONST_DECL
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|convert
argument_list|(
name|type
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
return|return
name|tree_cons
argument_list|(
name|decl
argument_list|,
name|value
argument_list|,
name|NULL_TREE
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create the FUNCTION_DECL for a function definition.    DECLSPECS, DECLARATOR and ATTRIBUTES are the parts of    the declaration; they describe the function's name and the type it returns,    but twisted together in a fashion that parallels the syntax of C.     This function creates a binding context for the function body    as well as setting up the FUNCTION_DECL in current_function_decl.     Returns 1 on success.  If the DECLARATOR is not suitable for a function    (it defines a datum instead), we return 0, which tells    yyparse to report a parse error.  */
end_comment

begin_function
name|int
name|start_function
parameter_list|(
name|struct
name|c_declspecs
modifier|*
name|declspecs
parameter_list|,
name|struct
name|c_declarator
modifier|*
name|declarator
parameter_list|,
name|tree
name|attributes
parameter_list|)
block|{
name|tree
name|decl1
decl_stmt|,
name|old_decl
decl_stmt|;
name|tree
name|restype
decl_stmt|,
name|resdecl
decl_stmt|;
name|struct
name|c_label_context_se
modifier|*
name|nstack_se
decl_stmt|;
name|struct
name|c_label_context_vm
modifier|*
name|nstack_vm
decl_stmt|;
name|current_function_returns_value
operator|=
literal|0
expr_stmt|;
comment|/* Assume, until we see it does.  */
name|current_function_returns_null
operator|=
literal|0
expr_stmt|;
name|current_function_returns_abnormally
operator|=
literal|0
expr_stmt|;
name|warn_about_return_type
operator|=
literal|0
expr_stmt|;
name|c_switch_stack
operator|=
name|NULL
expr_stmt|;
name|nstack_se
operator|=
name|XOBNEW
argument_list|(
operator|&
name|parser_obstack
argument_list|,
expr|struct
name|c_label_context_se
argument_list|)
expr_stmt|;
name|nstack_se
operator|->
name|labels_def
operator|=
name|NULL
expr_stmt|;
name|nstack_se
operator|->
name|labels_used
operator|=
name|NULL
expr_stmt|;
name|nstack_se
operator|->
name|next
operator|=
name|label_context_stack_se
expr_stmt|;
name|label_context_stack_se
operator|=
name|nstack_se
expr_stmt|;
name|nstack_vm
operator|=
name|XOBNEW
argument_list|(
operator|&
name|parser_obstack
argument_list|,
expr|struct
name|c_label_context_vm
argument_list|)
expr_stmt|;
name|nstack_vm
operator|->
name|labels_def
operator|=
name|NULL
expr_stmt|;
name|nstack_vm
operator|->
name|labels_used
operator|=
name|NULL
expr_stmt|;
name|nstack_vm
operator|->
name|scope
operator|=
literal|0
expr_stmt|;
name|nstack_vm
operator|->
name|next
operator|=
name|label_context_stack_vm
expr_stmt|;
name|label_context_stack_vm
operator|=
name|nstack_vm
expr_stmt|;
comment|/* Indicate no valid break/continue context by setting these variables      to some non-null, non-label value.  We'll notice and emit the proper      error message in c_finish_bc_stmt.  */
name|c_break_label
operator|=
name|c_cont_label
operator|=
name|size_zero_node
expr_stmt|;
name|decl1
operator|=
name|grokdeclarator
argument_list|(
name|declarator
argument_list|,
name|declspecs
argument_list|,
name|FUNCDEF
argument_list|,
name|true
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* If the declarator is not suitable for a function definition,      cause a syntax error.  */
if|if
condition|(
name|decl1
operator|==
literal|0
condition|)
block|{
name|label_context_stack_se
operator|=
name|label_context_stack_se
operator|->
name|next
expr_stmt|;
name|label_context_stack_vm
operator|=
name|label_context_stack_vm
operator|->
name|next
expr_stmt|;
return|return
literal|0
return|;
block|}
name|decl_attributes
argument_list|(
operator|&
name|decl1
argument_list|,
name|attributes
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_DECLARED_INLINE_P
argument_list|(
name|decl1
argument_list|)
operator|&&
name|DECL_UNINLINABLE
argument_list|(
name|decl1
argument_list|)
operator|&&
name|lookup_attribute
argument_list|(
literal|"noinline"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|decl1
argument_list|)
argument_list|)
condition|)
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"inline function %q+D given attribute noinline"
argument_list|,
name|decl1
argument_list|)
expr_stmt|;
comment|/* Handle gnu_inline attribute.  */
if|if
condition|(
name|declspecs
operator|->
name|inline_p
operator|&&
operator|!
name|flag_gnu89_inline
operator|&&
name|TREE_CODE
argument_list|(
name|decl1
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|lookup_attribute
argument_list|(
literal|"gnu_inline"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|decl1
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|declspecs
operator|->
name|storage_class
operator|!=
name|csc_static
condition|)
name|DECL_EXTERNAL
argument_list|(
name|decl1
argument_list|)
operator|=
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
block|}
name|announce_function
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|COMPLETE_OR_VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"return type is an incomplete type"
argument_list|)
expr_stmt|;
comment|/* Make it return void instead.  */
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
operator|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|warn_about_return_type
condition|)
name|pedwarn_c99
argument_list|(
literal|"return type defaults to %<int%>"
argument_list|)
expr_stmt|;
comment|/* Make the init_value nonzero so pushdecl knows this is not tentative.      error_mark_node is replaced below (in pop_scope) with the BLOCK.  */
name|DECL_INITIAL
argument_list|(
name|decl1
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
comment|/* If this definition isn't a prototype and we had a prototype declaration      before, copy the arg type info from that prototype.  */
name|old_decl
operator|=
name|lookup_name_in_scope
argument_list|(
name|DECL_NAME
argument_list|(
name|decl1
argument_list|)
argument_list|,
name|current_scope
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_decl
operator|&&
name|TREE_CODE
argument_list|(
name|old_decl
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
name|old_decl
operator|=
literal|0
expr_stmt|;
name|current_function_prototype_locus
operator|=
name|UNKNOWN_LOCATION
expr_stmt|;
name|current_function_prototype_built_in
operator|=
name|false
expr_stmt|;
name|current_function_prototype_arg_types
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|old_decl
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|old_decl
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|&&
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|old_decl
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
operator|=
name|composite_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|old_decl
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
argument_list|)
expr_stmt|;
name|current_function_prototype_locus
operator|=
name|DECL_SOURCE_LOCATION
argument_list|(
name|old_decl
argument_list|)
expr_stmt|;
name|current_function_prototype_built_in
operator|=
name|C_DECL_BUILTIN_PROTOTYPE
argument_list|(
name|old_decl
argument_list|)
expr_stmt|;
name|current_function_prototype_arg_types
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl1
argument_list|)
condition|)
block|{
comment|/* If there is an external prototype declaration of this 	     function, record its location but do not copy information 	     to this decl.  This may be an invisible declaration 	     (built-in or in a scope which has finished) or simply 	     have more refined argument types than any declaration 	     found above.  */
name|struct
name|c_binding
modifier|*
name|b
decl_stmt|;
for|for
control|(
name|b
operator|=
name|I_SYMBOL_BINDING
argument_list|(
name|DECL_NAME
argument_list|(
name|decl1
argument_list|)
argument_list|)
init|;
name|b
condition|;
name|b
operator|=
name|b
operator|->
name|shadowed
control|)
if|if
condition|(
name|B_IN_SCOPE
argument_list|(
name|b
argument_list|,
name|external_scope
argument_list|)
condition|)
break|break;
if|if
condition|(
name|b
condition|)
block|{
name|tree
name|ext_decl
decl_stmt|,
name|ext_type
decl_stmt|;
name|ext_decl
operator|=
name|b
operator|->
name|decl
expr_stmt|;
name|ext_type
operator|=
name|b
operator|->
name|type
condition|?
name|b
operator|->
name|type
else|:
name|TREE_TYPE
argument_list|(
name|ext_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ext_type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|&&
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|ext_type
argument_list|)
argument_list|)
condition|)
block|{
name|current_function_prototype_locus
operator|=
name|DECL_SOURCE_LOCATION
argument_list|(
name|ext_decl
argument_list|)
expr_stmt|;
name|current_function_prototype_built_in
operator|=
name|C_DECL_BUILTIN_PROTOTYPE
argument_list|(
name|ext_decl
argument_list|)
expr_stmt|;
name|current_function_prototype_arg_types
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|ext_type
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Optionally warn of old-fashioned def with no previous prototype.  */
if|if
condition|(
name|warn_strict_prototypes
operator|&&
name|old_decl
operator|!=
name|error_mark_node
operator|&&
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
name|C_DECL_ISNT_PROTOTYPE
argument_list|(
name|old_decl
argument_list|)
condition|)
name|warning
argument_list|(
name|OPT_Wstrict_prototypes
argument_list|,
literal|"function declaration isn%'t a prototype"
argument_list|)
expr_stmt|;
comment|/* Optionally warn of any global def with no previous prototype.  */
elseif|else
if|if
condition|(
name|warn_missing_prototypes
operator|&&
name|old_decl
operator|!=
name|error_mark_node
operator|&&
name|TREE_PUBLIC
argument_list|(
name|decl1
argument_list|)
operator|&&
operator|!
name|MAIN_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|decl1
argument_list|)
argument_list|)
operator|&&
name|C_DECL_ISNT_PROTOTYPE
argument_list|(
name|old_decl
argument_list|)
condition|)
name|warning
argument_list|(
name|OPT_Wmissing_prototypes
argument_list|,
literal|"no previous prototype for %q+D"
argument_list|,
name|decl1
argument_list|)
expr_stmt|;
comment|/* Optionally warn of any def with no previous prototype      if the function has already been used.  */
elseif|else
if|if
condition|(
name|warn_missing_prototypes
operator|&&
name|old_decl
operator|!=
literal|0
operator|&&
name|old_decl
operator|!=
name|error_mark_node
operator|&&
name|TREE_USED
argument_list|(
name|old_decl
argument_list|)
operator|&&
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|old_decl
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|warning
argument_list|(
name|OPT_Wmissing_prototypes
argument_list|,
literal|"%q+D was used with no prototype before its definition"
argument_list|,
name|decl1
argument_list|)
expr_stmt|;
comment|/* Optionally warn of any global def with no previous declaration.  */
elseif|else
if|if
condition|(
name|warn_missing_declarations
operator|&&
name|TREE_PUBLIC
argument_list|(
name|decl1
argument_list|)
operator|&&
name|old_decl
operator|==
literal|0
operator|&&
operator|!
name|MAIN_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|decl1
argument_list|)
argument_list|)
condition|)
name|warning
argument_list|(
name|OPT_Wmissing_declarations
argument_list|,
literal|"no previous declaration for %q+D"
argument_list|,
name|decl1
argument_list|)
expr_stmt|;
comment|/* Optionally warn of any def with no previous declaration      if the function has already been used.  */
elseif|else
if|if
condition|(
name|warn_missing_declarations
operator|&&
name|old_decl
operator|!=
literal|0
operator|&&
name|old_decl
operator|!=
name|error_mark_node
operator|&&
name|TREE_USED
argument_list|(
name|old_decl
argument_list|)
operator|&&
name|C_DECL_IMPLICIT
argument_list|(
name|old_decl
argument_list|)
condition|)
name|warning
argument_list|(
name|OPT_Wmissing_declarations
argument_list|,
literal|"%q+D was used with no declaration before its definition"
argument_list|,
name|decl1
argument_list|)
expr_stmt|;
comment|/* This function exists in static storage.      (This does not mean `static' in the C sense!)  */
name|TREE_STATIC
argument_list|(
name|decl1
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* A nested function is not global.  */
if|if
condition|(
name|current_function_decl
operator|!=
literal|0
condition|)
name|TREE_PUBLIC
argument_list|(
name|decl1
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* This is the earliest point at which we might know the assembler      name of the function.  Thus, if it's set before this, die horribly.  */
name|gcc_assert
argument_list|(
operator|!
name|DECL_ASSEMBLER_NAME_SET_P
argument_list|(
name|decl1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If #pragma weak was used, mark the decl weak now.  */
if|if
condition|(
name|current_scope
operator|==
name|file_scope
condition|)
name|maybe_apply_pragma_weak
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
comment|/* Warn for unlikely, improbable, or stupid declarations of `main'.  */
if|if
condition|(
name|warn_main
operator|>
literal|0
operator|&&
name|MAIN_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|decl1
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|args
decl_stmt|;
name|int
name|argct
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|integer_type_node
condition|)
name|pedwarn
argument_list|(
literal|"return type of %q+D is not %<int%>"
argument_list|,
name|decl1
argument_list|)
expr_stmt|;
for|for
control|(
name|args
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
argument_list|)
init|;
name|args
condition|;
name|args
operator|=
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
control|)
block|{
name|tree
name|type
init|=
name|args
condition|?
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|void_type_node
condition|)
break|break;
operator|++
name|argct
expr_stmt|;
switch|switch
condition|(
name|argct
condition|)
block|{
case|case
literal|1
case|:
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|!=
name|integer_type_node
condition|)
name|pedwarn
argument_list|(
literal|"first argument of %q+D should be %<int%>"
argument_list|,
name|decl1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|POINTER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
operator|||
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|char_type_node
operator|)
condition|)
name|pedwarn
argument_list|(
literal|"second argument of %q+D should be %<char **%>"
argument_list|,
name|decl1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|POINTER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
operator|||
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|char_type_node
operator|)
condition|)
name|pedwarn
argument_list|(
literal|"third argument of %q+D should probably be "
literal|"%<char **%>"
argument_list|,
name|decl1
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* It is intentional that this message does not mention the third 	 argument because it's only mentioned in an appendix of the 	 standard.  */
if|if
condition|(
name|argct
operator|>
literal|0
operator|&&
operator|(
name|argct
operator|<
literal|2
operator|||
name|argct
operator|>
literal|3
operator|)
condition|)
name|pedwarn
argument_list|(
literal|"%q+D takes only zero or two arguments"
argument_list|,
name|decl1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl1
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"%q+D is normally a non-static function"
argument_list|,
name|decl1
argument_list|)
expr_stmt|;
block|}
comment|/* Record the decl so that the function name is defined.      If we already have a decl for this name, and it is a FUNCTION_DECL,      use the old decl.  */
name|current_function_decl
operator|=
name|pushdecl
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
name|push_scope
argument_list|()
expr_stmt|;
name|declare_parm_level
argument_list|()
expr_stmt|;
name|restype
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Promote the value to int before returning it.  */
if|if
condition|(
name|c_promoting_integer_type_p
argument_list|(
name|restype
argument_list|)
condition|)
block|{
comment|/* It retains unsignedness if not really getting wider.  */
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|restype
argument_list|)
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|restype
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|)
condition|)
name|restype
operator|=
name|unsigned_type_node
expr_stmt|;
else|else
name|restype
operator|=
name|integer_type_node
expr_stmt|;
block|}
name|resdecl
operator|=
name|build_decl
argument_list|(
name|RESULT_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|restype
argument_list|)
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|resdecl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_IGNORED_P
argument_list|(
name|resdecl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
operator|=
name|resdecl
expr_stmt|;
name|start_fname_decls
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutine of store_parm_decls which handles new-style function    definitions (prototype format). The parms already have decls, so we    need only record them as in effect and complain if any redundant    old-style parm decls were written.  */
end_comment

begin_function
specifier|static
name|void
name|store_parm_decls_newstyle
parameter_list|(
name|tree
name|fndecl
parameter_list|,
specifier|const
name|struct
name|c_arg_info
modifier|*
name|arg_info
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|;
if|if
condition|(
name|current_scope
operator|->
name|bindings
condition|)
block|{
name|error
argument_list|(
literal|"%Jold-style parameter declarations in prototyped "
literal|"function definition"
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
comment|/* Get rid of the old-style declarations.  */
name|pop_scope
argument_list|()
expr_stmt|;
name|push_scope
argument_list|()
expr_stmt|;
block|}
comment|/* Don't issue this warning for nested functions, and don't issue this      warning if we got here because ARG_INFO_TYPES was error_mark_node      (this happens when a function definition has just an ellipsis in      its parameter list).  */
elseif|else
if|if
condition|(
operator|!
name|in_system_header
operator|&&
operator|!
name|current_function_scope
operator|&&
name|arg_info
operator|->
name|types
operator|!=
name|error_mark_node
condition|)
name|warning
argument_list|(
name|OPT_Wtraditional
argument_list|,
literal|"%Jtraditional C rejects ISO C style function definitions"
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
comment|/* Now make all the parameter declarations visible in the function body.      We can bypass most of the grunt work of pushdecl.  */
for|for
control|(
name|decl
operator|=
name|arg_info
operator|->
name|parms
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
block|{
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|current_function_decl
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|bind
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
name|decl
argument_list|,
name|current_scope
argument_list|,
comment|/*invisible=*/
name|false
argument_list|,
comment|/*nested=*/
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TREE_USED
argument_list|(
name|decl
argument_list|)
condition|)
name|warn_if_shadowing
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"%Jparameter name omitted"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
comment|/* Record the parameter list in the function declaration.  */
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
operator|=
name|arg_info
operator|->
name|parms
expr_stmt|;
comment|/* Now make all the ancillary declarations visible, likewise.  */
for|for
control|(
name|decl
operator|=
name|arg_info
operator|->
name|others
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
block|{
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|current_function_decl
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
condition|)
name|bind
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
name|decl
argument_list|,
name|current_scope
argument_list|,
comment|/*invisible=*/
name|false
argument_list|,
comment|/*nested=*/
name|false
argument_list|)
expr_stmt|;
block|}
comment|/* And all the tag declarations.  */
for|for
control|(
name|decl
operator|=
name|arg_info
operator|->
name|tags
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|decl
argument_list|)
condition|)
name|bind
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|current_scope
argument_list|,
comment|/*invisible=*/
name|false
argument_list|,
comment|/*nested=*/
name|false
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Subroutine of store_parm_decls which handles old-style function    definitions (separate parameter list and declarations).  */
end_comment

begin_function
specifier|static
name|void
name|store_parm_decls_oldstyle
parameter_list|(
name|tree
name|fndecl
parameter_list|,
specifier|const
name|struct
name|c_arg_info
modifier|*
name|arg_info
parameter_list|)
block|{
name|struct
name|c_binding
modifier|*
name|b
decl_stmt|;
name|tree
name|parm
decl_stmt|,
name|decl
decl_stmt|,
name|last
decl_stmt|;
name|tree
name|parmids
init|=
name|arg_info
operator|->
name|parms
decl_stmt|;
name|struct
name|pointer_set_t
modifier|*
name|seen_args
init|=
name|pointer_set_create
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|in_system_header
condition|)
name|warning
argument_list|(
name|OPT_Wold_style_definition
argument_list|,
literal|"%Jold-style function definition"
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
comment|/* Match each formal parameter name with its declaration.  Save each      decl in the appropriate TREE_PURPOSE slot of the parmids chain.  */
for|for
control|(
name|parm
operator|=
name|parmids
init|;
name|parm
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"%Jparameter name missing from parameter list"
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|b
operator|=
name|I_SYMBOL_BINDING
argument_list|(
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|&&
name|B_IN_CURRENT_SCOPE
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|decl
operator|=
name|b
operator|->
name|decl
expr_stmt|;
comment|/* If we got something other than a PARM_DECL it is an error.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|PARM_DECL
condition|)
name|error
argument_list|(
literal|"%q+D declared as a non-parameter"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* If the declaration is already marked, we have a duplicate 	     name.  Complain and ignore the duplicate.  */
elseif|else
if|if
condition|(
name|pointer_set_contains
argument_list|(
name|seen_args
argument_list|,
name|decl
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"multiple parameters named %q+D"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
comment|/* If the declaration says "void", complain and turn it into 	     an int.  */
elseif|else
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"parameter %q+D declared with void type"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
name|DECL_ARG_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
name|layout_decl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|warn_if_shadowing
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
comment|/* If no declaration found, default to int.  */
else|else
block|{
name|decl
operator|=
name|build_decl
argument_list|(
name|PARM_DECL
argument_list|,
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|integer_type_node
argument_list|)
expr_stmt|;
name|DECL_ARG_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_SOURCE_LOCATION
argument_list|(
name|decl
argument_list|)
operator|=
name|DECL_SOURCE_LOCATION
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|warn_if_shadowing
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_isoc99
condition|)
name|pedwarn
argument_list|(
literal|"type of %q+D defaults to %<int%>"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|extra_warnings
condition|)
name|warning
argument_list|(
name|OPT_Wextra
argument_list|,
literal|"type of %q+D defaults to %<int%>"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
operator|=
name|decl
expr_stmt|;
name|pointer_set_insert
argument_list|(
name|seen_args
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
comment|/* Now examine the parms chain for incomplete declarations      and declarations with no corresponding names.  */
for|for
control|(
name|b
operator|=
name|current_scope
operator|->
name|bindings
init|;
name|b
condition|;
name|b
operator|=
name|b
operator|->
name|prev
control|)
block|{
name|parm
operator|=
name|b
operator|->
name|decl
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|!=
name|PARM_DECL
condition|)
continue|continue;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
operator|!=
name|error_mark_node
operator|&&
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"parameter %q+D has incomplete type"
argument_list|,
name|parm
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|pointer_set_contains
argument_list|(
name|seen_args
argument_list|,
name|parm
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"declaration for parameter %q+D but no such parameter"
argument_list|,
name|parm
argument_list|)
expr_stmt|;
comment|/* Pretend the parameter was not missing. 	     This gets us to a standard state and minimizes 	     further error messages.  */
name|parmids
operator|=
name|chainon
argument_list|(
name|parmids
argument_list|,
name|tree_cons
argument_list|(
name|parm
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Chain the declarations together in the order of the list of      names.  Store that chain in the function decl, replacing the      list of names.  Update the current scope to match.  */
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|parm
operator|=
name|parmids
init|;
name|parm
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
control|)
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
condition|)
break|break;
if|if
condition|(
name|parm
operator|&&
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
condition|)
block|{
name|last
operator|=
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
operator|=
name|last
expr_stmt|;
for|for
control|(
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
init|;
name|parm
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
control|)
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
condition|)
block|{
name|TREE_CHAIN
argument_list|(
name|last
argument_list|)
operator|=
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|last
operator|=
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
expr_stmt|;
block|}
name|TREE_CHAIN
argument_list|(
name|last
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
name|pointer_set_destroy
argument_list|(
name|seen_args
argument_list|)
expr_stmt|;
comment|/* If there was a previous prototype,      set the DECL_ARG_TYPE of each argument according to      the type previously specified, and report any mismatches.  */
if|if
condition|(
name|current_function_prototype_arg_types
condition|)
block|{
name|tree
name|type
decl_stmt|;
for|for
control|(
name|parm
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
operator|,
name|type
operator|=
name|current_function_prototype_arg_types
init|;
name|parm
operator|||
operator|(
name|type
operator|&&
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|void_type_node
operator|)
operator|)
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
operator|,
name|type
operator|=
name|TREE_CHAIN
argument_list|(
name|type
argument_list|)
control|)
block|{
if|if
condition|(
name|parm
operator|==
literal|0
operator|||
name|type
operator|==
literal|0
operator|||
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|void_type_node
condition|)
block|{
if|if
condition|(
name|current_function_prototype_built_in
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"number of arguments doesn%'t match "
literal|"built-in prototype"
argument_list|)
expr_stmt|;
else|else
block|{
name|error
argument_list|(
literal|"number of arguments doesn%'t match prototype"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"%Hprototype declaration"
argument_list|,
operator|&
name|current_function_prototype_locus
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
comment|/* Type for passing arg must be consistent with that 	     declared for the arg.  ISO C says we take the unqualified 	     type for parameters declared with qualified type.  */
if|if
condition|(
operator|!
name|comptypes
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|DECL_ARG_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Adjust argument to match prototype.  E.g. a previous 		     `int foo(float);' prototype causes 		     `int foo(x) float x; {...}' to be treated like 		     `int foo(float x) {...}'.  This is particularly 		     useful for argument types like uid_t.  */
name|DECL_ARG_TYPE
argument_list|(
name|parm
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetm
operator|.
name|calls
operator|.
name|promote_prototypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|&&
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
condition|)
name|DECL_ARG_TYPE
argument_list|(
name|parm
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
if|if
condition|(
name|pedantic
condition|)
block|{
comment|/* ??? Is it possible to get here with a 			 built-in prototype or will it always have 			 been diagnosed as conflicting with an 			 old-style definition and discarded?  */
if|if
condition|(
name|current_function_prototype_built_in
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"promoted argument %qD "
literal|"doesn%'t match built-in prototype"
argument_list|,
name|parm
argument_list|)
expr_stmt|;
else|else
block|{
name|pedwarn
argument_list|(
literal|"promoted argument %qD "
literal|"doesn%'t match prototype"
argument_list|,
name|parm
argument_list|)
expr_stmt|;
name|pedwarn
argument_list|(
literal|"%Hprototype declaration"
argument_list|,
operator|&
name|current_function_prototype_locus
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|current_function_prototype_built_in
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"argument %qD doesn%'t match "
literal|"built-in prototype"
argument_list|,
name|parm
argument_list|)
expr_stmt|;
else|else
block|{
name|error
argument_list|(
literal|"argument %qD doesn%'t match prototype"
argument_list|,
name|parm
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"%Hprototype declaration"
argument_list|,
operator|&
name|current_function_prototype_locus
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|TYPE_ACTUAL_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Otherwise, create a prototype that would match.  */
else|else
block|{
name|tree
name|actual
init|=
literal|0
decl_stmt|,
name|last
init|=
literal|0
decl_stmt|,
name|type
decl_stmt|;
for|for
control|(
name|parm
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
init|;
name|parm
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
control|)
block|{
name|type
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|DECL_ARG_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|last
condition|)
name|TREE_CHAIN
argument_list|(
name|last
argument_list|)
operator|=
name|type
expr_stmt|;
else|else
name|actual
operator|=
name|type
expr_stmt|;
name|last
operator|=
name|type
expr_stmt|;
block|}
name|type
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|void_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|last
condition|)
name|TREE_CHAIN
argument_list|(
name|last
argument_list|)
operator|=
name|type
expr_stmt|;
else|else
name|actual
operator|=
name|type
expr_stmt|;
comment|/* We are going to assign a new value for the TYPE_ACTUAL_ARG_TYPES 	 of the type of this function, but we need to avoid having this 	 affect the types of other similarly-typed functions, so we must 	 first force the generation of an identical (but separate) type 	 node for the relevant function type.  The new node we create 	 will be a variant of the main variant of the original function 	 type.  */
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
operator|=
name|build_variant_type_copy
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_ACTUAL_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|=
name|actual
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Store parameter declarations passed in ARG_INFO into the current    function declaration.  */
end_comment

begin_function
name|void
name|store_parm_decls_from
parameter_list|(
name|struct
name|c_arg_info
modifier|*
name|arg_info
parameter_list|)
block|{
name|current_function_arg_info
operator|=
name|arg_info
expr_stmt|;
name|store_parm_decls
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Store the parameter declarations into the current function declaration.    This is called after parsing the parameter declarations, before    digesting the body of the function.     For an old-style definition, construct a prototype out of the old-style    parameter declarations and inject it into the function's type.  */
end_comment

begin_function
name|void
name|store_parm_decls
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|fndecl
init|=
name|current_function_decl
decl_stmt|;
name|bool
name|proto
decl_stmt|;
comment|/* The argument information block for FNDECL.  */
name|struct
name|c_arg_info
modifier|*
name|arg_info
init|=
name|current_function_arg_info
decl_stmt|;
name|current_function_arg_info
operator|=
literal|0
expr_stmt|;
comment|/* True if this definition is written with a prototype.  Note:      despite C99 6.7.5.3p14, we can *not* treat an empty argument      list in a function definition as equivalent to (void) -- an      empty argument list specifies the function has no parameters,      but only (void) sets up a prototype for future calls.  */
name|proto
operator|=
name|arg_info
operator|->
name|types
operator|!=
literal|0
expr_stmt|;
if|if
condition|(
name|proto
condition|)
name|store_parm_decls_newstyle
argument_list|(
name|fndecl
argument_list|,
name|arg_info
argument_list|)
expr_stmt|;
else|else
name|store_parm_decls_oldstyle
argument_list|(
name|fndecl
argument_list|,
name|arg_info
argument_list|)
expr_stmt|;
comment|/* The next call to push_scope will be a function body.  */
name|next_is_function_body
operator|=
name|true
expr_stmt|;
comment|/* Write a record describing this function definition to the prototypes      file (if requested).  */
name|gen_aux_info_record
argument_list|(
name|fndecl
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|proto
argument_list|)
expr_stmt|;
comment|/* Initialize the RTL code for the function.  */
name|allocate_struct_function
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
comment|/* Begin the statement tree for this function.  */
name|DECL_SAVED_TREE
argument_list|(
name|fndecl
argument_list|)
operator|=
name|push_stmt_list
argument_list|()
expr_stmt|;
comment|/* ??? Insert the contents of the pending sizes list into the function      to be evaluated.  The only reason left to have this is 	void foo(int n, int array[n++])      because we throw away the array type in favor of a pointer type, and      thus won't naturally see the SAVE_EXPR containing the increment.  All      other pending sizes would be handled by gimplify_parameters.  */
block|{
name|tree
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
name|nreverse
argument_list|(
name|get_pending_sizes
argument_list|()
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
name|add_stmt
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Even though we're inside a function body, we still don't want to      call expand_expr to calculate the size of a variable-sized array.      We haven't necessarily assigned RTL to all variables yet, so it's      not safe to try to expand expressions involving them.  */
name|cfun
operator|->
name|x_dont_save_pending_sizes_p
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit diagnostics that require gimple input for detection.  Operate on    FNDECL and all its nested functions.  */
end_comment

begin_function
specifier|static
name|void
name|c_gimple_diagnostics_recursively
parameter_list|(
name|tree
name|fndecl
parameter_list|)
block|{
name|struct
name|cgraph_node
modifier|*
name|cgn
decl_stmt|;
comment|/* Handle attribute((warn_unused_result)).  Relies on gimple input.  */
name|c_warn_unused_result
argument_list|(
operator|&
name|DECL_SAVED_TREE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Notice when OpenMP structured block constraints are violated.  */
if|if
condition|(
name|flag_openmp
condition|)
name|diagnose_omp_structured_block_errors
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
comment|/* Finalize all nested functions now.  */
name|cgn
operator|=
name|cgraph_node
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
for|for
control|(
name|cgn
operator|=
name|cgn
operator|->
name|nested
init|;
name|cgn
condition|;
name|cgn
operator|=
name|cgn
operator|->
name|next_nested
control|)
name|c_gimple_diagnostics_recursively
argument_list|(
name|cgn
operator|->
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish up a function declaration and compile that function    all the way to assembler language output.  The free the storage    for the function definition.     This is called after parsing the body of the function definition.  */
end_comment

begin_function
name|void
name|finish_function
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|fndecl
init|=
name|current_function_decl
decl_stmt|;
name|label_context_stack_se
operator|=
name|label_context_stack_se
operator|->
name|next
expr_stmt|;
name|label_context_stack_vm
operator|=
name|label_context_stack_vm
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fndecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|targetm
operator|.
name|calls
operator|.
name|promote_prototypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|args
init|=
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|args
condition|;
name|args
operator|=
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
control|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|args
argument_list|)
decl_stmt|;
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
condition|)
name|DECL_ARG_TYPE
argument_list|(
name|args
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
block|}
block|}
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|fndecl
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|fndecl
argument_list|)
operator|!=
name|error_mark_node
condition|)
name|BLOCK_SUPERCONTEXT
argument_list|(
name|DECL_INITIAL
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|=
name|fndecl
expr_stmt|;
comment|/* Must mark the RESULT_DECL as being in this function.  */
if|if
condition|(
name|DECL_RESULT
argument_list|(
name|fndecl
argument_list|)
operator|&&
name|DECL_RESULT
argument_list|(
name|fndecl
argument_list|)
operator|!=
name|error_mark_node
condition|)
name|DECL_CONTEXT
argument_list|(
name|DECL_RESULT
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|=
name|fndecl
expr_stmt|;
if|if
condition|(
name|MAIN_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|&&
name|flag_hosted
condition|)
block|{
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|integer_type_node
condition|)
block|{
comment|/* If warn_main is 1 (-Wmain) or 2 (-Wall), we have already warned. 	     If warn_main is -1 (-Wno-main) we don't want to be warned.  */
if|if
condition|(
operator|!
name|warn_main
condition|)
name|pedwarn
argument_list|(
literal|"return type of %q+D is not %<int%>"
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|flag_isoc99
condition|)
block|{
name|tree
name|stmt
init|=
name|c_finish_return
argument_list|(
name|integer_zero_node
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_MAPPED_LOCATION
comment|/* Hack.  We don't want the middle-end to warn that this return 		 is unreachable, so we mark its location as special.  Using 		 UNKNOWN_LOCATION has the problem that it gets clobbered in 		 annotate_one_with_locus.  A cleaner solution might be to 		 ensure ! should_carry_locus_p (stmt), but that needs a flag. 	      */
name|SET_EXPR_LOCATION
argument_list|(
name|stmt
argument_list|,
name|BUILTINS_LOCATION
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Hack.  We don't want the middle-end to warn that this 		 return is unreachable, so put the statement on the 		 special line 0.  */
name|annotate_with_file_line
argument_list|(
name|stmt
argument_list|,
name|input_filename
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
comment|/* Tie off the statement tree for this function.  */
name|DECL_SAVED_TREE
argument_list|(
name|fndecl
argument_list|)
operator|=
name|pop_stmt_list
argument_list|(
name|DECL_SAVED_TREE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
name|finish_fname_decls
argument_list|()
expr_stmt|;
comment|/* Complain if there's just no return statement.  */
if|if
condition|(
name|warn_return_type
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|VOID_TYPE
operator|&&
operator|!
name|current_function_returns_value
operator|&&
operator|!
name|current_function_returns_null
comment|/* Don't complain if we are no-return.  */
operator|&&
operator|!
name|current_function_returns_abnormally
comment|/* Don't warn for main().  */
operator|&&
operator|!
name|MAIN_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
comment|/* Or if they didn't actually specify a return type.  */
operator|&&
operator|!
name|C_FUNCTION_IMPLICIT_INT
argument_list|(
name|fndecl
argument_list|)
comment|/* Normally, with -Wreturn-type, flow will complain.  Unless we're an 	 inline function, as we might never be compiled separately.  */
operator|&&
name|DECL_INLINE
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
name|warning
argument_list|(
name|OPT_Wreturn_type
argument_list|,
literal|"no return statement in function returning non-void"
argument_list|)
expr_stmt|;
name|TREE_NO_WARNING
argument_list|(
name|fndecl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* With just -Wextra, complain only if function returns both with      and without a value.  */
if|if
condition|(
name|extra_warnings
operator|&&
name|current_function_returns_value
operator|&&
name|current_function_returns_null
condition|)
name|warning
argument_list|(
name|OPT_Wextra
argument_list|,
literal|"this function may return with or without a value"
argument_list|)
expr_stmt|;
comment|/* Store the end of the function, so that we get good line number      info for the epilogue.  */
name|cfun
operator|->
name|function_end_locus
operator|=
name|input_location
expr_stmt|;
comment|/* If we don't have ctors/dtors sections, and this is a static      constructor or destructor, it must be recorded now.  */
if|if
condition|(
name|DECL_STATIC_CONSTRUCTOR
argument_list|(
name|fndecl
argument_list|)
operator|&&
operator|!
name|targetm
operator|.
name|have_ctors_dtors
condition|)
name|static_ctors
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|fndecl
argument_list|,
name|static_ctors
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_STATIC_DESTRUCTOR
argument_list|(
name|fndecl
argument_list|)
operator|&&
operator|!
name|targetm
operator|.
name|have_ctors_dtors
condition|)
name|static_dtors
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|fndecl
argument_list|,
name|static_dtors
argument_list|)
expr_stmt|;
comment|/* Finalize the ELF visibility for the function.  */
name|c_determine_visibility
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
comment|/* Genericize before inlining.  Delay genericizing nested functions      until their parent function is genericized.  Since finalizing      requires GENERIC, delay that as well.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|fndecl
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|fndecl
argument_list|)
operator|!=
name|error_mark_node
operator|&&
operator|!
name|undef_nested_function
condition|)
block|{
if|if
condition|(
operator|!
name|decl_function_context
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
name|c_genericize
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|c_gimple_diagnostics_recursively
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
comment|/* ??? Objc emits functions after finalizing the compilation unit. 	     This should be cleaned up later and this conditional removed.  */
if|if
condition|(
name|cgraph_global_info_ready
condition|)
block|{
name|c_expand_body
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
return|return;
block|}
name|cgraph_finalize_function
argument_list|(
name|fndecl
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Register this function with cgraph just far enough to get it 	    added to our parent's nested function list.  Handy, since the 	    C front end doesn't have such a list.  */
operator|(
name|void
operator|)
name|cgraph_node
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|decl_function_context
argument_list|(
name|fndecl
argument_list|)
condition|)
name|undef_nested_function
operator|=
name|false
expr_stmt|;
comment|/* We're leaving the context of this function, so zap cfun.      It's still in DECL_STRUCT_FUNCTION, and we'll restore it in      tree_rest_of_compilation.  */
name|cfun
operator|=
name|NULL
expr_stmt|;
name|current_function_decl
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate the RTL for the body of FNDECL.  */
end_comment

begin_function
name|void
name|c_expand_body
parameter_list|(
name|tree
name|fndecl
parameter_list|)
block|{
if|if
condition|(
operator|!
name|DECL_INITIAL
argument_list|(
name|fndecl
argument_list|)
operator|||
name|DECL_INITIAL
argument_list|(
name|fndecl
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return;
name|tree_rest_of_compilation
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_STATIC_CONSTRUCTOR
argument_list|(
name|fndecl
argument_list|)
operator|&&
name|targetm
operator|.
name|have_ctors_dtors
condition|)
name|targetm
operator|.
name|asm_out
operator|.
name|constructor
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|fndecl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|DEFAULT_INIT_PRIORITY
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_STATIC_DESTRUCTOR
argument_list|(
name|fndecl
argument_list|)
operator|&&
name|targetm
operator|.
name|have_ctors_dtors
condition|)
name|targetm
operator|.
name|asm_out
operator|.
name|destructor
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|fndecl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|DEFAULT_INIT_PRIORITY
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Check the declarations given in a for-loop for satisfying the C99    constraints.  If exactly one such decl is found, return it.  */
end_comment

begin_function
name|tree
name|check_for_loop_decls
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|c_binding
modifier|*
name|b
decl_stmt|;
name|tree
name|one_decl
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|n_decls
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|flag_isoc99
condition|)
block|{
comment|/* If we get here, declarations have been used in a for loop without 	 the C99 for loop scope.  This doesn't make much sense, so don't 	 allow it.  */
name|error
argument_list|(
literal|"%<for%> loop initial declaration used outside C99 mode"
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
comment|/* C99 subclause 6.8.5 paragraph 3:         [#3]  The  declaration  part  of  a for statement shall only        declare identifiers for objects having storage class auto or        register.       It isn't clear whether, in this sentence, "identifiers" binds to      "shall only declare" or to "objects" - that is, whether all identifiers      declared must be identifiers for objects, or whether the restriction      only applies to those that are.  (A question on this in comp.std.c      in November 2000 received no answer.)  We implement the strictest      interpretation, to avoid creating an extension which later causes      problems.  */
for|for
control|(
name|b
operator|=
name|current_scope
operator|->
name|bindings
init|;
name|b
condition|;
name|b
operator|=
name|b
operator|->
name|prev
control|)
block|{
name|tree
name|id
init|=
name|b
operator|->
name|id
decl_stmt|;
name|tree
name|decl
init|=
name|b
operator|->
name|decl
decl_stmt|;
if|if
condition|(
operator|!
name|id
condition|)
continue|continue;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
case|case
name|VAR_DECL
case|:
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
condition|)
name|error
argument_list|(
literal|"declaration of static variable %q+D in %<for%> loop "
literal|"initial declaration"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
name|error
argument_list|(
literal|"declaration of %<extern%> variable %q+D in %<for%> loop "
literal|"initial declaration"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
break|break;
case|case
name|RECORD_TYPE
case|:
name|error
argument_list|(
literal|"%<struct %E%> declared in %<for%> loop initial declaration"
argument_list|,
name|id
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNION_TYPE
case|:
name|error
argument_list|(
literal|"%<union %E%> declared in %<for%> loop initial declaration"
argument_list|,
name|id
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENUMERAL_TYPE
case|:
name|error
argument_list|(
literal|"%<enum %E%> declared in %<for%> loop initial declaration"
argument_list|,
name|id
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"declaration of non-variable %q+D in %<for%> loop "
literal|"initial declaration"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
name|n_decls
operator|++
expr_stmt|;
name|one_decl
operator|=
name|decl
expr_stmt|;
block|}
return|return
name|n_decls
operator|==
literal|1
condition|?
name|one_decl
else|:
name|NULL_TREE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Save and reinitialize the variables    used during compilation of a C function.  */
end_comment

begin_function
name|void
name|c_push_function_context
parameter_list|(
name|struct
name|function
modifier|*
name|f
parameter_list|)
block|{
name|struct
name|language_function
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|GGC_NEW
argument_list|(
expr|struct
name|language_function
argument_list|)
expr_stmt|;
name|f
operator|->
name|language
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|base
operator|.
name|x_stmt_tree
operator|=
name|c_stmt_tree
expr_stmt|;
name|p
operator|->
name|x_break_label
operator|=
name|c_break_label
expr_stmt|;
name|p
operator|->
name|x_cont_label
operator|=
name|c_cont_label
expr_stmt|;
name|p
operator|->
name|x_switch_stack
operator|=
name|c_switch_stack
expr_stmt|;
name|p
operator|->
name|arg_info
operator|=
name|current_function_arg_info
expr_stmt|;
name|p
operator|->
name|returns_value
operator|=
name|current_function_returns_value
expr_stmt|;
name|p
operator|->
name|returns_null
operator|=
name|current_function_returns_null
expr_stmt|;
name|p
operator|->
name|returns_abnormally
operator|=
name|current_function_returns_abnormally
expr_stmt|;
name|p
operator|->
name|warn_about_return_type
operator|=
name|warn_about_return_type
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Restore the variables used during compilation of a C function.  */
end_comment

begin_function
name|void
name|c_pop_function_context
parameter_list|(
name|struct
name|function
modifier|*
name|f
parameter_list|)
block|{
name|struct
name|language_function
modifier|*
name|p
init|=
name|f
operator|->
name|language
decl_stmt|;
if|if
condition|(
name|DECL_STRUCT_FUNCTION
argument_list|(
name|current_function_decl
argument_list|)
operator|==
literal|0
operator|&&
name|DECL_SAVED_TREE
argument_list|(
name|current_function_decl
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
comment|/* Stop pointing to the local nodes about to be freed.  */
comment|/* But DECL_INITIAL must remain nonzero so we know this 	 was an actual function definition.  */
name|DECL_INITIAL
argument_list|(
name|current_function_decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|DECL_ARGUMENTS
argument_list|(
name|current_function_decl
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
name|c_stmt_tree
operator|=
name|p
operator|->
name|base
operator|.
name|x_stmt_tree
expr_stmt|;
name|c_break_label
operator|=
name|p
operator|->
name|x_break_label
expr_stmt|;
name|c_cont_label
operator|=
name|p
operator|->
name|x_cont_label
expr_stmt|;
name|c_switch_stack
operator|=
name|p
operator|->
name|x_switch_stack
expr_stmt|;
name|current_function_arg_info
operator|=
name|p
operator|->
name|arg_info
expr_stmt|;
name|current_function_returns_value
operator|=
name|p
operator|->
name|returns_value
expr_stmt|;
name|current_function_returns_null
operator|=
name|p
operator|->
name|returns_null
expr_stmt|;
name|current_function_returns_abnormally
operator|=
name|p
operator|->
name|returns_abnormally
expr_stmt|;
name|warn_about_return_type
operator|=
name|p
operator|->
name|warn_about_return_type
expr_stmt|;
name|f
operator|->
name|language
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy the DECL_LANG_SPECIFIC data associated with DECL.  */
end_comment

begin_function
name|void
name|c_dup_lang_specific_decl
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|struct
name|lang_decl
modifier|*
name|ld
decl_stmt|;
if|if
condition|(
operator|!
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
name|ld
operator|=
name|GGC_NEW
argument_list|(
expr|struct
name|lang_decl
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ld
argument_list|,
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lang_decl
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_LANG_SPECIFIC
argument_list|(
name|decl
argument_list|)
operator|=
name|ld
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The functions below are required for functionality of doing    function at once processing in the C front end. Currently these    functions are not called from anywhere in the C front end, but as    these changes continue, that will change.  */
end_comment

begin_comment
comment|/* Returns the stmt_tree (if any) to which statements are currently    being added.  If there is no active statement-tree, NULL is    returned.  */
end_comment

begin_function
name|stmt_tree
name|current_stmt_tree
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|&
name|c_stmt_tree
return|;
block|}
end_function

begin_comment
comment|/* Nonzero if TYPE is an anonymous union or struct type.  Always 0 in    C.  */
end_comment

begin_function
name|int
name|anon_aggr_type_p
parameter_list|(
name|tree
name|ARG_UNUSED
parameter_list|(
name|node
parameter_list|)
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the global value of T as a symbol.  */
end_comment

begin_function
name|tree
name|identifier_global_value
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|struct
name|c_binding
modifier|*
name|b
decl_stmt|;
for|for
control|(
name|b
operator|=
name|I_SYMBOL_BINDING
argument_list|(
name|t
argument_list|)
init|;
name|b
condition|;
name|b
operator|=
name|b
operator|->
name|shadowed
control|)
if|if
condition|(
name|B_IN_FILE_SCOPE
argument_list|(
name|b
argument_list|)
operator|||
name|B_IN_EXTERNAL_SCOPE
argument_list|(
name|b
argument_list|)
condition|)
return|return
name|b
operator|->
name|decl
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Record a builtin type for C.  If NAME is non-NULL, it is the name used;    otherwise the name is found in ridpointers from RID_INDEX.  */
end_comment

begin_function
name|void
name|record_builtin_type
parameter_list|(
name|enum
name|rid
name|rid_index
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|tree
name|id
decl_stmt|,
name|decl
decl_stmt|;
if|if
condition|(
name|name
operator|==
literal|0
condition|)
name|id
operator|=
name|ridpointers
index|[
operator|(
name|int
operator|)
name|rid_index
index|]
expr_stmt|;
else|else
name|id
operator|=
name|get_identifier
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|id
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_hooks
operator|->
name|type_decl
condition|)
name|debug_hooks
operator|->
name|type_decl
argument_list|(
name|decl
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Build the void_list_node (void_type_node having been created).  */
end_comment

begin_function
name|tree
name|build_void_list_node
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|t
init|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|void_type_node
argument_list|)
decl_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Return a c_parm structure with the given SPECS, ATTRS and DECLARATOR.  */
end_comment

begin_function
name|struct
name|c_parm
modifier|*
name|build_c_parm
parameter_list|(
name|struct
name|c_declspecs
modifier|*
name|specs
parameter_list|,
name|tree
name|attrs
parameter_list|,
name|struct
name|c_declarator
modifier|*
name|declarator
parameter_list|)
block|{
name|struct
name|c_parm
modifier|*
name|ret
init|=
name|XOBNEW
argument_list|(
operator|&
name|parser_obstack
argument_list|,
expr|struct
name|c_parm
argument_list|)
decl_stmt|;
name|ret
operator|->
name|specs
operator|=
name|specs
expr_stmt|;
name|ret
operator|->
name|attrs
operator|=
name|attrs
expr_stmt|;
name|ret
operator|->
name|declarator
operator|=
name|declarator
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Return a declarator with nested attributes.  TARGET is the inner    declarator to which these attributes apply.  ATTRS are the    attributes.  */
end_comment

begin_function
name|struct
name|c_declarator
modifier|*
name|build_attrs_declarator
parameter_list|(
name|tree
name|attrs
parameter_list|,
name|struct
name|c_declarator
modifier|*
name|target
parameter_list|)
block|{
name|struct
name|c_declarator
modifier|*
name|ret
init|=
name|XOBNEW
argument_list|(
operator|&
name|parser_obstack
argument_list|,
expr|struct
name|c_declarator
argument_list|)
decl_stmt|;
name|ret
operator|->
name|kind
operator|=
name|cdk_attrs
expr_stmt|;
name|ret
operator|->
name|declarator
operator|=
name|target
expr_stmt|;
name|ret
operator|->
name|u
operator|.
name|attrs
operator|=
name|attrs
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Return a declarator for a function with arguments specified by ARGS    and return type specified by TARGET.  */
end_comment

begin_function
name|struct
name|c_declarator
modifier|*
name|build_function_declarator
parameter_list|(
name|struct
name|c_arg_info
modifier|*
name|args
parameter_list|,
name|struct
name|c_declarator
modifier|*
name|target
parameter_list|)
block|{
name|struct
name|c_declarator
modifier|*
name|ret
init|=
name|XOBNEW
argument_list|(
operator|&
name|parser_obstack
argument_list|,
expr|struct
name|c_declarator
argument_list|)
decl_stmt|;
name|ret
operator|->
name|kind
operator|=
name|cdk_function
expr_stmt|;
name|ret
operator|->
name|declarator
operator|=
name|target
expr_stmt|;
name|ret
operator|->
name|u
operator|.
name|arg_info
operator|=
name|args
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Return a declarator for the identifier IDENT (which may be    NULL_TREE for an abstract declarator).  */
end_comment

begin_function
name|struct
name|c_declarator
modifier|*
name|build_id_declarator
parameter_list|(
name|tree
name|ident
parameter_list|)
block|{
name|struct
name|c_declarator
modifier|*
name|ret
init|=
name|XOBNEW
argument_list|(
operator|&
name|parser_obstack
argument_list|,
expr|struct
name|c_declarator
argument_list|)
decl_stmt|;
name|ret
operator|->
name|kind
operator|=
name|cdk_id
expr_stmt|;
name|ret
operator|->
name|declarator
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|u
operator|.
name|id
operator|=
name|ident
expr_stmt|;
comment|/* Default value - may get reset to a more precise location. */
name|ret
operator|->
name|id_loc
operator|=
name|input_location
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Return something to represent absolute declarators containing a *.    TARGET is the absolute declarator that the * contains.    TYPE_QUALS_ATTRS is a structure for type qualifiers and attributes    to apply to the pointer type.  */
end_comment

begin_function
name|struct
name|c_declarator
modifier|*
name|make_pointer_declarator
parameter_list|(
name|struct
name|c_declspecs
modifier|*
name|type_quals_attrs
parameter_list|,
name|struct
name|c_declarator
modifier|*
name|target
parameter_list|)
block|{
name|tree
name|attrs
decl_stmt|;
name|int
name|quals
init|=
literal|0
decl_stmt|;
name|struct
name|c_declarator
modifier|*
name|itarget
init|=
name|target
decl_stmt|;
name|struct
name|c_declarator
modifier|*
name|ret
init|=
name|XOBNEW
argument_list|(
operator|&
name|parser_obstack
argument_list|,
expr|struct
name|c_declarator
argument_list|)
decl_stmt|;
if|if
condition|(
name|type_quals_attrs
condition|)
block|{
name|attrs
operator|=
name|type_quals_attrs
operator|->
name|attrs
expr_stmt|;
name|quals
operator|=
name|quals_from_declspecs
argument_list|(
name|type_quals_attrs
argument_list|)
expr_stmt|;
if|if
condition|(
name|attrs
operator|!=
name|NULL_TREE
condition|)
name|itarget
operator|=
name|build_attrs_declarator
argument_list|(
name|attrs
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
name|ret
operator|->
name|kind
operator|=
name|cdk_pointer
expr_stmt|;
name|ret
operator|->
name|declarator
operator|=
name|itarget
expr_stmt|;
name|ret
operator|->
name|u
operator|.
name|pointer_quals
operator|=
name|quals
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Return a pointer to a structure for an empty list of declaration    specifiers.  */
end_comment

begin_function
name|struct
name|c_declspecs
modifier|*
name|build_null_declspecs
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|c_declspecs
modifier|*
name|ret
init|=
name|XOBNEW
argument_list|(
operator|&
name|parser_obstack
argument_list|,
expr|struct
name|c_declspecs
argument_list|)
decl_stmt|;
name|ret
operator|->
name|type
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|decl_attr
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|attrs
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|typespec_word
operator|=
name|cts_none
expr_stmt|;
name|ret
operator|->
name|storage_class
operator|=
name|csc_none
expr_stmt|;
name|ret
operator|->
name|declspecs_seen_p
operator|=
name|false
expr_stmt|;
name|ret
operator|->
name|type_seen_p
operator|=
name|false
expr_stmt|;
name|ret
operator|->
name|non_sc_seen_p
operator|=
name|false
expr_stmt|;
name|ret
operator|->
name|typedef_p
operator|=
name|false
expr_stmt|;
name|ret
operator|->
name|tag_defined_p
operator|=
name|false
expr_stmt|;
name|ret
operator|->
name|explicit_signed_p
operator|=
name|false
expr_stmt|;
name|ret
operator|->
name|deprecated_p
operator|=
name|false
expr_stmt|;
comment|/* APPLE LOCAL "unavailable" attribute (radar 2809697) */
name|ret
operator|->
name|unavailable_p
operator|=
name|false
expr_stmt|;
name|ret
operator|->
name|default_int_p
operator|=
name|false
expr_stmt|;
name|ret
operator|->
name|long_p
operator|=
name|false
expr_stmt|;
name|ret
operator|->
name|long_long_p
operator|=
name|false
expr_stmt|;
name|ret
operator|->
name|short_p
operator|=
name|false
expr_stmt|;
name|ret
operator|->
name|signed_p
operator|=
name|false
expr_stmt|;
name|ret
operator|->
name|unsigned_p
operator|=
name|false
expr_stmt|;
name|ret
operator|->
name|complex_p
operator|=
name|false
expr_stmt|;
name|ret
operator|->
name|inline_p
operator|=
name|false
expr_stmt|;
name|ret
operator|->
name|thread_p
operator|=
name|false
expr_stmt|;
name|ret
operator|->
name|const_p
operator|=
name|false
expr_stmt|;
name|ret
operator|->
name|volatile_p
operator|=
name|false
expr_stmt|;
name|ret
operator|->
name|restrict_p
operator|=
name|false
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Add the type qualifier QUAL to the declaration specifiers SPECS,    returning SPECS.  */
end_comment

begin_function
name|struct
name|c_declspecs
modifier|*
name|declspecs_add_qual
parameter_list|(
name|struct
name|c_declspecs
modifier|*
name|specs
parameter_list|,
name|tree
name|qual
parameter_list|)
block|{
name|enum
name|rid
name|i
decl_stmt|;
name|bool
name|dupe
init|=
name|false
decl_stmt|;
name|specs
operator|->
name|non_sc_seen_p
operator|=
name|true
expr_stmt|;
name|specs
operator|->
name|declspecs_seen_p
operator|=
name|true
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|qual
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|&&
name|C_IS_RESERVED_WORD
argument_list|(
name|qual
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|C_RID_CODE
argument_list|(
name|qual
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|i
condition|)
block|{
case|case
name|RID_CONST
case|:
name|dupe
operator|=
name|specs
operator|->
name|const_p
expr_stmt|;
name|specs
operator|->
name|const_p
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|RID_VOLATILE
case|:
name|dupe
operator|=
name|specs
operator|->
name|volatile_p
expr_stmt|;
name|specs
operator|->
name|volatile_p
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|RID_RESTRICT
case|:
name|dupe
operator|=
name|specs
operator|->
name|restrict_p
expr_stmt|;
name|specs
operator|->
name|restrict_p
operator|=
name|true
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|dupe
operator|&&
name|pedantic
operator|&&
operator|!
name|flag_isoc99
condition|)
name|pedwarn
argument_list|(
literal|"duplicate %qE"
argument_list|,
name|qual
argument_list|)
expr_stmt|;
return|return
name|specs
return|;
block|}
end_function

begin_comment
comment|/* Add the type specifier TYPE to the declaration specifiers SPECS,    returning SPECS.  */
end_comment

begin_function
name|struct
name|c_declspecs
modifier|*
name|declspecs_add_type
parameter_list|(
name|struct
name|c_declspecs
modifier|*
name|specs
parameter_list|,
name|struct
name|c_typespec
name|spec
parameter_list|)
block|{
name|tree
name|type
init|=
name|spec
operator|.
name|spec
decl_stmt|;
name|specs
operator|->
name|non_sc_seen_p
operator|=
name|true
expr_stmt|;
name|specs
operator|->
name|declspecs_seen_p
operator|=
name|true
expr_stmt|;
name|specs
operator|->
name|type_seen_p
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|TREE_DEPRECATED
argument_list|(
name|type
argument_list|)
condition|)
name|specs
operator|->
name|deprecated_p
operator|=
name|true
expr_stmt|;
comment|/* APPLE LOCAL begin "unavailable" attribute (radar 2809697) */
if|if
condition|(
name|TREE_UNAVAILABLE
argument_list|(
name|type
argument_list|)
condition|)
name|specs
operator|->
name|unavailable_p
operator|=
name|true
expr_stmt|;
comment|/* APPLE LOCAL end "unavailable" attribute (radar 2809697) */
comment|/* Handle type specifier keywords.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|&&
name|C_IS_RESERVED_WORD
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|enum
name|rid
name|i
init|=
name|C_RID_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|specs
operator|->
name|type
condition|)
block|{
name|error
argument_list|(
literal|"two or more data types in declaration specifiers"
argument_list|)
expr_stmt|;
return|return
name|specs
return|;
block|}
if|if
condition|(
operator|(
name|int
operator|)
name|i
operator|<=
operator|(
name|int
operator|)
name|RID_LAST_MODIFIER
condition|)
block|{
comment|/* "long", "short", "signed", "unsigned" or "_Complex".  */
name|bool
name|dupe
init|=
name|false
decl_stmt|;
switch|switch
condition|(
name|i
condition|)
block|{
case|case
name|RID_LONG
case|:
if|if
condition|(
name|specs
operator|->
name|long_long_p
condition|)
block|{
name|error
argument_list|(
literal|"%<long long long%> is too long for GCC"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|specs
operator|->
name|long_p
condition|)
block|{
if|if
condition|(
name|specs
operator|->
name|typespec_word
operator|==
name|cts_double
condition|)
block|{
name|error
argument_list|(
literal|"both %<long long%> and %<double%> in "
literal|"declaration specifiers"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|flag_isoc99
operator|&&
operator|!
name|in_system_header
operator|&&
name|warn_long_long
condition|)
name|pedwarn
argument_list|(
literal|"ISO C90 does not support %<long long%>"
argument_list|)
expr_stmt|;
name|specs
operator|->
name|long_long_p
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|specs
operator|->
name|short_p
condition|)
name|error
argument_list|(
literal|"both %<long%> and %<short%> in "
literal|"declaration specifiers"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|specs
operator|->
name|typespec_word
operator|==
name|cts_void
condition|)
name|error
argument_list|(
literal|"both %<long%> and %<void%> in "
literal|"declaration specifiers"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|specs
operator|->
name|typespec_word
operator|==
name|cts_bool
condition|)
name|error
argument_list|(
literal|"both %<long%> and %<_Bool%> in "
literal|"declaration specifiers"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|specs
operator|->
name|typespec_word
operator|==
name|cts_char
condition|)
name|error
argument_list|(
literal|"both %<long%> and %<char%> in "
literal|"declaration specifiers"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|specs
operator|->
name|typespec_word
operator|==
name|cts_float
condition|)
name|error
argument_list|(
literal|"both %<long%> and %<float%> in "
literal|"declaration specifiers"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|specs
operator|->
name|typespec_word
operator|==
name|cts_dfloat32
condition|)
name|error
argument_list|(
literal|"both %<long%> and %<_Decimal32%> in "
literal|"declaration specifiers"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|specs
operator|->
name|typespec_word
operator|==
name|cts_dfloat64
condition|)
name|error
argument_list|(
literal|"both %<long%> and %<_Decimal64%> in "
literal|"declaration specifiers"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|specs
operator|->
name|typespec_word
operator|==
name|cts_dfloat128
condition|)
name|error
argument_list|(
literal|"both %<long%> and %<_Decimal128%> in "
literal|"declaration specifiers"
argument_list|)
expr_stmt|;
else|else
name|specs
operator|->
name|long_p
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|RID_SHORT
case|:
name|dupe
operator|=
name|specs
operator|->
name|short_p
expr_stmt|;
if|if
condition|(
name|specs
operator|->
name|long_p
condition|)
name|error
argument_list|(
literal|"both %<long%> and %<short%> in "
literal|"declaration specifiers"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|specs
operator|->
name|typespec_word
operator|==
name|cts_void
condition|)
name|error
argument_list|(
literal|"both %<short%> and %<void%> in "
literal|"declaration specifiers"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|specs
operator|->
name|typespec_word
operator|==
name|cts_bool
condition|)
name|error
argument_list|(
literal|"both %<short%> and %<_Bool%> in "
literal|"declaration specifiers"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|specs
operator|->
name|typespec_word
operator|==
name|cts_char
condition|)
name|error
argument_list|(
literal|"both %<short%> and %<char%> in "
literal|"declaration specifiers"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|specs
operator|->
name|typespec_word
operator|==
name|cts_float
condition|)
name|error
argument_list|(
literal|"both %<short%> and %<float%> in "
literal|"declaration specifiers"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|specs
operator|->
name|typespec_word
operator|==
name|cts_double
condition|)
name|error
argument_list|(
literal|"both %<short%> and %<double%> in "
literal|"declaration specifiers"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|specs
operator|->
name|typespec_word
operator|==
name|cts_dfloat32
condition|)
name|error
argument_list|(
literal|"both %<short%> and %<_Decimal32%> in "
literal|"declaration specifiers"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|specs
operator|->
name|typespec_word
operator|==
name|cts_dfloat64
condition|)
name|error
argument_list|(
literal|"both %<short%> and %<_Decimal64%> in "
literal|"declaration specifiers"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|specs
operator|->
name|typespec_word
operator|==
name|cts_dfloat128
condition|)
name|error
argument_list|(
literal|"both %<short%> and %<_Decimal128%> in "
literal|"declaration specifiers"
argument_list|)
expr_stmt|;
else|else
name|specs
operator|->
name|short_p
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|RID_SIGNED
case|:
name|dupe
operator|=
name|specs
operator|->
name|signed_p
expr_stmt|;
if|if
condition|(
name|specs
operator|->
name|unsigned_p
condition|)
name|error
argument_list|(
literal|"both %<signed%> and %<unsigned%> in "
literal|"declaration specifiers"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|specs
operator|->
name|typespec_word
operator|==
name|cts_void
condition|)
name|error
argument_list|(
literal|"both %<signed%> and %<void%> in "
literal|"declaration specifiers"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|specs
operator|->
name|typespec_word
operator|==
name|cts_bool
condition|)
name|error
argument_list|(
literal|"both %<signed%> and %<_Bool%> in "
literal|"declaration specifiers"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|specs
operator|->
name|typespec_word
operator|==
name|cts_float
condition|)
name|error
argument_list|(
literal|"both %<signed%> and %<float%> in "
literal|"declaration specifiers"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|specs
operator|->
name|typespec_word
operator|==
name|cts_double
condition|)
name|error
argument_list|(
literal|"both %<signed%> and %<double%> in "
literal|"declaration specifiers"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|specs
operator|->
name|typespec_word
operator|==
name|cts_dfloat32
condition|)
name|error
argument_list|(
literal|"both %<signed%> and %<_Decimal32%> in "
literal|"declaration specifiers"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|specs
operator|->
name|typespec_word
operator|==
name|cts_dfloat64
condition|)
name|error
argument_list|(
literal|"both %<signed%> and %<_Decimal64%> in "
literal|"declaration specifiers"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|specs
operator|->
name|typespec_word
operator|==
name|cts_dfloat128
condition|)
name|error
argument_list|(
literal|"both %<signed%> and %<_Decimal128%> in "
literal|"declaration specifiers"
argument_list|)
expr_stmt|;
else|else
name|specs
operator|->
name|signed_p
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|RID_UNSIGNED
case|:
name|dupe
operator|=
name|specs
operator|->
name|unsigned_p
expr_stmt|;
if|if
condition|(
name|specs
operator|->
name|signed_p
condition|)
name|error
argument_list|(
literal|"both %<signed%> and %<unsigned%> in "
literal|"declaration specifiers"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|specs
operator|->
name|typespec_word
operator|==
name|cts_void
condition|)
name|error
argument_list|(
literal|"both %<unsigned%> and %<void%> in "
literal|"declaration specifiers"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|specs
operator|->
name|typespec_word
operator|==
name|cts_bool
condition|)
name|error
argument_list|(
literal|"both %<unsigned%> and %<_Bool%> in "
literal|"declaration specifiers"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|specs
operator|->
name|typespec_word
operator|==
name|cts_float
condition|)
name|error
argument_list|(
literal|"both %<unsigned%> and %<float%> in "
literal|"declaration specifiers"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|specs
operator|->
name|typespec_word
operator|==
name|cts_double
condition|)
name|error
argument_list|(
literal|"both %<unsigned%> and %<double%> in "
literal|"declaration specifiers"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|specs
operator|->
name|typespec_word
operator|==
name|cts_dfloat32
condition|)
name|error
argument_list|(
literal|"both %<unsigned%> and %<_Decimal32%> in "
literal|"declaration specifiers"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|specs
operator|->
name|typespec_word
operator|==
name|cts_dfloat64
condition|)
name|error
argument_list|(
literal|"both %<unsigned%> and %<_Decimal64%> in "
literal|"declaration specifiers"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|specs
operator|->
name|typespec_word
operator|==
name|cts_dfloat128
condition|)
name|error
argument_list|(
literal|"both %<unsigned%> and %<_Decimal128%> in "
literal|"declaration specifiers"
argument_list|)
expr_stmt|;
else|else
name|specs
operator|->
name|unsigned_p
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|RID_COMPLEX
case|:
name|dupe
operator|=
name|specs
operator|->
name|complex_p
expr_stmt|;
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|flag_isoc99
operator|&&
operator|!
name|in_system_header
condition|)
name|pedwarn
argument_list|(
literal|"ISO C90 does not support complex types"
argument_list|)
expr_stmt|;
if|if
condition|(
name|specs
operator|->
name|typespec_word
operator|==
name|cts_void
condition|)
name|error
argument_list|(
literal|"both %<complex%> and %<void%> in "
literal|"declaration specifiers"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|specs
operator|->
name|typespec_word
operator|==
name|cts_bool
condition|)
name|error
argument_list|(
literal|"both %<complex%> and %<_Bool%> in "
literal|"declaration specifiers"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|specs
operator|->
name|typespec_word
operator|==
name|cts_dfloat32
condition|)
name|error
argument_list|(
literal|"both %<complex%> and %<_Decimal32%> in "
literal|"declaration specifiers"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|specs
operator|->
name|typespec_word
operator|==
name|cts_dfloat64
condition|)
name|error
argument_list|(
literal|"both %<complex%> and %<_Decimal64%> in "
literal|"declaration specifiers"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|specs
operator|->
name|typespec_word
operator|==
name|cts_dfloat128
condition|)
name|error
argument_list|(
literal|"both %<complex%> and %<_Decimal128%> in "
literal|"declaration specifiers"
argument_list|)
expr_stmt|;
else|else
name|specs
operator|->
name|complex_p
operator|=
name|true
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|dupe
condition|)
name|error
argument_list|(
literal|"duplicate %qE"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|specs
return|;
block|}
else|else
block|{
comment|/* "void", "_Bool", "char", "int", "float" or "double".  */
if|if
condition|(
name|specs
operator|->
name|typespec_word
operator|!=
name|cts_none
condition|)
block|{
name|error
argument_list|(
literal|"two or more data types in declaration specifiers"
argument_list|)
expr_stmt|;
return|return
name|specs
return|;
block|}
switch|switch
condition|(
name|i
condition|)
block|{
case|case
name|RID_VOID
case|:
if|if
condition|(
name|specs
operator|->
name|long_p
condition|)
name|error
argument_list|(
literal|"both %<long%> and %<void%> in "
literal|"declaration specifiers"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|specs
operator|->
name|short_p
condition|)
name|error
argument_list|(
literal|"both %<short%> and %<void%> in "
literal|"declaration specifiers"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|specs
operator|->
name|signed_p
condition|)
name|error
argument_list|(
literal|"both %<signed%> and %<void%> in "
literal|"declaration specifiers"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|specs
operator|->
name|unsigned_p
condition|)
name|error
argument_list|(
literal|"both %<unsigned%> and %<void%> in "
literal|"declaration specifiers"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|specs
operator|->
name|complex_p
condition|)
name|error
argument_list|(
literal|"both %<complex%> and %<void%> in "
literal|"declaration specifiers"
argument_list|)
expr_stmt|;
else|else
name|specs
operator|->
name|typespec_word
operator|=
name|cts_void
expr_stmt|;
return|return
name|specs
return|;
case|case
name|RID_BOOL
case|:
if|if
condition|(
name|specs
operator|->
name|long_p
condition|)
name|error
argument_list|(
literal|"both %<long%> and %<_Bool%> in "
literal|"declaration specifiers"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|specs
operator|->
name|short_p
condition|)
name|error
argument_list|(
literal|"both %<short%> and %<_Bool%> in "
literal|"declaration specifiers"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|specs
operator|->
name|signed_p
condition|)
name|error
argument_list|(
literal|"both %<signed%> and %<_Bool%> in "
literal|"declaration specifiers"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|specs
operator|->
name|unsigned_p
condition|)
name|error
argument_list|(
literal|"both %<unsigned%> and %<_Bool%> in "
literal|"declaration specifiers"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|specs
operator|->
name|complex_p
condition|)
name|error
argument_list|(
literal|"both %<complex%> and %<_Bool%> in "
literal|"declaration specifiers"
argument_list|)
expr_stmt|;
else|else
name|specs
operator|->
name|typespec_word
operator|=
name|cts_bool
expr_stmt|;
return|return
name|specs
return|;
case|case
name|RID_CHAR
case|:
if|if
condition|(
name|specs
operator|->
name|long_p
condition|)
name|error
argument_list|(
literal|"both %<long%> and %<char%> in "
literal|"declaration specifiers"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|specs
operator|->
name|short_p
condition|)
name|error
argument_list|(
literal|"both %<short%> and %<char%> in "
literal|"declaration specifiers"
argument_list|)
expr_stmt|;
else|else
name|specs
operator|->
name|typespec_word
operator|=
name|cts_char
expr_stmt|;
return|return
name|specs
return|;
case|case
name|RID_INT
case|:
name|specs
operator|->
name|typespec_word
operator|=
name|cts_int
expr_stmt|;
return|return
name|specs
return|;
case|case
name|RID_FLOAT
case|:
if|if
condition|(
name|specs
operator|->
name|long_p
condition|)
name|error
argument_list|(
literal|"both %<long%> and %<float%> in "
literal|"declaration specifiers"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|specs
operator|->
name|short_p
condition|)
name|error
argument_list|(
literal|"both %<short%> and %<float%> in "
literal|"declaration specifiers"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|specs
operator|->
name|signed_p
condition|)
name|error
argument_list|(
literal|"both %<signed%> and %<float%> in "
literal|"declaration specifiers"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|specs
operator|->
name|unsigned_p
condition|)
name|error
argument_list|(
literal|"both %<unsigned%> and %<float%> in "
literal|"declaration specifiers"
argument_list|)
expr_stmt|;
else|else
name|specs
operator|->
name|typespec_word
operator|=
name|cts_float
expr_stmt|;
return|return
name|specs
return|;
case|case
name|RID_DOUBLE
case|:
if|if
condition|(
name|specs
operator|->
name|long_long_p
condition|)
name|error
argument_list|(
literal|"both %<long long%> and %<double%> in "
literal|"declaration specifiers"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|specs
operator|->
name|short_p
condition|)
name|error
argument_list|(
literal|"both %<short%> and %<double%> in "
literal|"declaration specifiers"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|specs
operator|->
name|signed_p
condition|)
name|error
argument_list|(
literal|"both %<signed%> and %<double%> in "
literal|"declaration specifiers"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|specs
operator|->
name|unsigned_p
condition|)
name|error
argument_list|(
literal|"both %<unsigned%> and %<double%> in "
literal|"declaration specifiers"
argument_list|)
expr_stmt|;
else|else
name|specs
operator|->
name|typespec_word
operator|=
name|cts_double
expr_stmt|;
return|return
name|specs
return|;
case|case
name|RID_DFLOAT32
case|:
case|case
name|RID_DFLOAT64
case|:
case|case
name|RID_DFLOAT128
case|:
block|{
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
if|if
condition|(
name|i
operator|==
name|RID_DFLOAT32
condition|)
name|str
operator|=
literal|"_Decimal32"
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
name|RID_DFLOAT64
condition|)
name|str
operator|=
literal|"_Decimal64"
expr_stmt|;
else|else
name|str
operator|=
literal|"_Decimal128"
expr_stmt|;
if|if
condition|(
name|specs
operator|->
name|long_long_p
condition|)
name|error
argument_list|(
literal|"both %<long long%> and %<%s%> in "
literal|"declaration specifiers"
argument_list|,
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|specs
operator|->
name|long_p
condition|)
name|error
argument_list|(
literal|"both %<long%> and %<%s%> in "
literal|"declaration specifiers"
argument_list|,
name|str
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|specs
operator|->
name|short_p
condition|)
name|error
argument_list|(
literal|"both %<short%> and %<%s%> in "
literal|"declaration specifiers"
argument_list|,
name|str
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|specs
operator|->
name|signed_p
condition|)
name|error
argument_list|(
literal|"both %<signed%> and %<%s%> in "
literal|"declaration specifiers"
argument_list|,
name|str
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|specs
operator|->
name|unsigned_p
condition|)
name|error
argument_list|(
literal|"both %<unsigned%> and %<%s%> in "
literal|"declaration specifiers"
argument_list|,
name|str
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|specs
operator|->
name|complex_p
condition|)
name|error
argument_list|(
literal|"both %<complex%> and %<%s%> in "
literal|"declaration specifiers"
argument_list|,
name|str
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
name|RID_DFLOAT32
condition|)
name|specs
operator|->
name|typespec_word
operator|=
name|cts_dfloat32
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
name|RID_DFLOAT64
condition|)
name|specs
operator|->
name|typespec_word
operator|=
name|cts_dfloat64
expr_stmt|;
else|else
name|specs
operator|->
name|typespec_word
operator|=
name|cts_dfloat128
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|targetm
operator|.
name|decimal_float_supported_p
argument_list|()
condition|)
name|error
argument_list|(
literal|"decimal floating point not supported for this target"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ISO C does not support decimal floating point"
argument_list|)
expr_stmt|;
return|return
name|specs
return|;
default|default:
comment|/* ObjC reserved word "id", handled below.  */
break|break;
block|}
block|}
block|}
comment|/* Now we have a typedef (a TYPE_DECL node), an identifier (some      form of ObjC type, cases such as "int" and "long" being handled      above), a TYPE (struct, union, enum and typeof specifiers) or an      ERROR_MARK.  In none of these cases may there have previously      been any type specifiers.  */
if|if
condition|(
name|specs
operator|->
name|type
operator|||
name|specs
operator|->
name|typespec_word
operator|!=
name|cts_none
operator|||
name|specs
operator|->
name|long_p
operator|||
name|specs
operator|->
name|short_p
operator|||
name|specs
operator|->
name|signed_p
operator|||
name|specs
operator|->
name|unsigned_p
operator|||
name|specs
operator|->
name|complex_p
condition|)
name|error
argument_list|(
literal|"two or more data types in declaration specifiers"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
operator|==
name|error_mark_node
condition|)
empty_stmt|;
comment|/* Allow the type to default to int to avoid cascading errors.  */
else|else
block|{
name|specs
operator|->
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|specs
operator|->
name|decl_attr
operator|=
name|DECL_ATTRIBUTES
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|specs
operator|->
name|typedef_p
operator|=
name|true
expr_stmt|;
name|specs
operator|->
name|explicit_signed_p
operator|=
name|C_TYPEDEF_EXPLICITLY_SIGNED
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
name|tree
name|t
init|=
name|lookup_name
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|t
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
name|error
argument_list|(
literal|"%qE fails to be a typedef or built in type"
argument_list|,
name|type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|==
name|error_mark_node
condition|)
empty_stmt|;
else|else
name|specs
operator|->
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|ERROR_MARK
condition|)
block|{
if|if
condition|(
name|spec
operator|.
name|kind
operator|==
name|ctsk_tagdef
operator|||
name|spec
operator|.
name|kind
operator|==
name|ctsk_tagfirstref
condition|)
name|specs
operator|->
name|tag_defined_p
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|spec
operator|.
name|kind
operator|==
name|ctsk_typeof
condition|)
name|specs
operator|->
name|typedef_p
operator|=
name|true
expr_stmt|;
name|specs
operator|->
name|type
operator|=
name|type
expr_stmt|;
block|}
return|return
name|specs
return|;
block|}
end_function

begin_comment
comment|/* Add the storage class specifier or function specifier SCSPEC to the    declaration specifiers SPECS, returning SPECS.  */
end_comment

begin_function
name|struct
name|c_declspecs
modifier|*
name|declspecs_add_scspec
parameter_list|(
name|struct
name|c_declspecs
modifier|*
name|specs
parameter_list|,
name|tree
name|scspec
parameter_list|)
block|{
name|enum
name|rid
name|i
decl_stmt|;
name|enum
name|c_storage_class
name|n
init|=
name|csc_none
decl_stmt|;
name|bool
name|dupe
init|=
name|false
decl_stmt|;
name|specs
operator|->
name|declspecs_seen_p
operator|=
name|true
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|scspec
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|&&
name|C_IS_RESERVED_WORD
argument_list|(
name|scspec
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|C_RID_CODE
argument_list|(
name|scspec
argument_list|)
expr_stmt|;
if|if
condition|(
name|extra_warnings
operator|&&
name|specs
operator|->
name|non_sc_seen_p
condition|)
name|warning
argument_list|(
name|OPT_Wextra
argument_list|,
literal|"%qE is not at beginning of declaration"
argument_list|,
name|scspec
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|i
condition|)
block|{
case|case
name|RID_INLINE
case|:
comment|/* C99 permits duplicate inline.  Although of doubtful utility, 	 it seems simplest to permit it in gnu89 mode as well, as 	 there is also little utility in maintaining this as a 	 difference between gnu89 and C99 inline.  */
name|dupe
operator|=
name|false
expr_stmt|;
name|specs
operator|->
name|inline_p
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|RID_THREAD
case|:
name|dupe
operator|=
name|specs
operator|->
name|thread_p
expr_stmt|;
if|if
condition|(
name|specs
operator|->
name|storage_class
operator|==
name|csc_auto
condition|)
name|error
argument_list|(
literal|"%<__thread%> used with %<auto%>"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|specs
operator|->
name|storage_class
operator|==
name|csc_register
condition|)
name|error
argument_list|(
literal|"%<__thread%> used with %<register%>"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|specs
operator|->
name|storage_class
operator|==
name|csc_typedef
condition|)
name|error
argument_list|(
literal|"%<__thread%> used with %<typedef%>"
argument_list|)
expr_stmt|;
else|else
name|specs
operator|->
name|thread_p
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|RID_AUTO
case|:
name|n
operator|=
name|csc_auto
expr_stmt|;
break|break;
case|case
name|RID_EXTERN
case|:
name|n
operator|=
name|csc_extern
expr_stmt|;
comment|/* Diagnose "__thread extern".  */
if|if
condition|(
name|specs
operator|->
name|thread_p
condition|)
name|error
argument_list|(
literal|"%<__thread%> before %<extern%>"
argument_list|)
expr_stmt|;
break|break;
case|case
name|RID_REGISTER
case|:
name|n
operator|=
name|csc_register
expr_stmt|;
break|break;
case|case
name|RID_STATIC
case|:
name|n
operator|=
name|csc_static
expr_stmt|;
comment|/* Diagnose "__thread static".  */
if|if
condition|(
name|specs
operator|->
name|thread_p
condition|)
name|error
argument_list|(
literal|"%<__thread%> before %<static%>"
argument_list|)
expr_stmt|;
break|break;
case|case
name|RID_TYPEDEF
case|:
name|n
operator|=
name|csc_typedef
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|!=
name|csc_none
operator|&&
name|n
operator|==
name|specs
operator|->
name|storage_class
condition|)
name|dupe
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|dupe
condition|)
name|error
argument_list|(
literal|"duplicate %qE"
argument_list|,
name|scspec
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|csc_none
condition|)
block|{
if|if
condition|(
name|specs
operator|->
name|storage_class
operator|!=
name|csc_none
operator|&&
name|n
operator|!=
name|specs
operator|->
name|storage_class
condition|)
block|{
name|error
argument_list|(
literal|"multiple storage classes in declaration specifiers"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|specs
operator|->
name|storage_class
operator|=
name|n
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|csc_extern
operator|&&
name|n
operator|!=
name|csc_static
operator|&&
name|specs
operator|->
name|thread_p
condition|)
block|{
name|error
argument_list|(
literal|"%<__thread%> used with %qE"
argument_list|,
name|scspec
argument_list|)
expr_stmt|;
name|specs
operator|->
name|thread_p
operator|=
name|false
expr_stmt|;
block|}
block|}
block|}
return|return
name|specs
return|;
block|}
end_function

begin_comment
comment|/* Add the attributes ATTRS to the declaration specifiers SPECS,    returning SPECS.  */
end_comment

begin_function
name|struct
name|c_declspecs
modifier|*
name|declspecs_add_attrs
parameter_list|(
name|struct
name|c_declspecs
modifier|*
name|specs
parameter_list|,
name|tree
name|attrs
parameter_list|)
block|{
name|specs
operator|->
name|attrs
operator|=
name|chainon
argument_list|(
name|attrs
argument_list|,
name|specs
operator|->
name|attrs
argument_list|)
expr_stmt|;
name|specs
operator|->
name|declspecs_seen_p
operator|=
name|true
expr_stmt|;
return|return
name|specs
return|;
block|}
end_function

begin_comment
comment|/* Combine "long", "short", "signed", "unsigned" and "_Complex" type    specifiers with any other type specifier to determine the resulting    type.  This is where ISO C checks on complex types are made, since    "_Complex long" is a prefix of the valid ISO C type "_Complex long    double".  */
end_comment

begin_function
name|struct
name|c_declspecs
modifier|*
name|finish_declspecs
parameter_list|(
name|struct
name|c_declspecs
modifier|*
name|specs
parameter_list|)
block|{
comment|/* If a type was specified as a whole, we have no modifiers and are      done.  */
if|if
condition|(
name|specs
operator|->
name|type
operator|!=
name|NULL_TREE
condition|)
block|{
name|gcc_assert
argument_list|(
operator|!
name|specs
operator|->
name|long_p
operator|&&
operator|!
name|specs
operator|->
name|long_long_p
operator|&&
operator|!
name|specs
operator|->
name|short_p
operator|&&
operator|!
name|specs
operator|->
name|signed_p
operator|&&
operator|!
name|specs
operator|->
name|unsigned_p
operator|&&
operator|!
name|specs
operator|->
name|complex_p
argument_list|)
expr_stmt|;
return|return
name|specs
return|;
block|}
comment|/* If none of "void", "_Bool", "char", "int", "float" or "double"      has been specified, treat it as "int" unless "_Complex" is      present and there are no other specifiers.  If we just have      "_Complex", it is equivalent to "_Complex double", but e.g.      "_Complex short" is equivalent to "_Complex short int".  */
if|if
condition|(
name|specs
operator|->
name|typespec_word
operator|==
name|cts_none
condition|)
block|{
if|if
condition|(
name|specs
operator|->
name|long_p
operator|||
name|specs
operator|->
name|short_p
operator|||
name|specs
operator|->
name|signed_p
operator|||
name|specs
operator|->
name|unsigned_p
condition|)
block|{
name|specs
operator|->
name|typespec_word
operator|=
name|cts_int
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|specs
operator|->
name|complex_p
condition|)
block|{
name|specs
operator|->
name|typespec_word
operator|=
name|cts_double
expr_stmt|;
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ISO C does not support plain %<complex%> meaning "
literal|"%<double complex%>"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|specs
operator|->
name|typespec_word
operator|=
name|cts_int
expr_stmt|;
name|specs
operator|->
name|default_int_p
operator|=
name|true
expr_stmt|;
comment|/* We don't diagnose this here because grokdeclarator will 	     give more specific diagnostics according to whether it is 	     a function definition.  */
block|}
block|}
comment|/* If "signed" was specified, record this to distinguish "int" and      "signed int" in the case of a bit-field with      -funsigned-bitfields.  */
name|specs
operator|->
name|explicit_signed_p
operator|=
name|specs
operator|->
name|signed_p
expr_stmt|;
comment|/* Now compute the actual type.  */
switch|switch
condition|(
name|specs
operator|->
name|typespec_word
condition|)
block|{
case|case
name|cts_void
case|:
name|gcc_assert
argument_list|(
operator|!
name|specs
operator|->
name|long_p
operator|&&
operator|!
name|specs
operator|->
name|short_p
operator|&&
operator|!
name|specs
operator|->
name|signed_p
operator|&&
operator|!
name|specs
operator|->
name|unsigned_p
operator|&&
operator|!
name|specs
operator|->
name|complex_p
argument_list|)
expr_stmt|;
name|specs
operator|->
name|type
operator|=
name|void_type_node
expr_stmt|;
break|break;
case|case
name|cts_bool
case|:
name|gcc_assert
argument_list|(
operator|!
name|specs
operator|->
name|long_p
operator|&&
operator|!
name|specs
operator|->
name|short_p
operator|&&
operator|!
name|specs
operator|->
name|signed_p
operator|&&
operator|!
name|specs
operator|->
name|unsigned_p
operator|&&
operator|!
name|specs
operator|->
name|complex_p
argument_list|)
expr_stmt|;
name|specs
operator|->
name|type
operator|=
name|boolean_type_node
expr_stmt|;
break|break;
case|case
name|cts_char
case|:
name|gcc_assert
argument_list|(
operator|!
name|specs
operator|->
name|long_p
operator|&&
operator|!
name|specs
operator|->
name|short_p
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
operator|(
name|specs
operator|->
name|signed_p
operator|&&
name|specs
operator|->
name|unsigned_p
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|specs
operator|->
name|signed_p
condition|)
name|specs
operator|->
name|type
operator|=
name|signed_char_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|specs
operator|->
name|unsigned_p
condition|)
name|specs
operator|->
name|type
operator|=
name|unsigned_char_type_node
expr_stmt|;
else|else
name|specs
operator|->
name|type
operator|=
name|char_type_node
expr_stmt|;
if|if
condition|(
name|specs
operator|->
name|complex_p
condition|)
block|{
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ISO C does not support complex integer types"
argument_list|)
expr_stmt|;
name|specs
operator|->
name|type
operator|=
name|build_complex_type
argument_list|(
name|specs
operator|->
name|type
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|cts_int
case|:
name|gcc_assert
argument_list|(
operator|!
operator|(
name|specs
operator|->
name|long_p
operator|&&
name|specs
operator|->
name|short_p
operator|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
operator|(
name|specs
operator|->
name|signed_p
operator|&&
name|specs
operator|->
name|unsigned_p
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|specs
operator|->
name|long_long_p
condition|)
name|specs
operator|->
name|type
operator|=
operator|(
name|specs
operator|->
name|unsigned_p
condition|?
name|long_long_unsigned_type_node
else|:
name|long_long_integer_type_node
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|specs
operator|->
name|long_p
condition|)
name|specs
operator|->
name|type
operator|=
operator|(
name|specs
operator|->
name|unsigned_p
condition|?
name|long_unsigned_type_node
else|:
name|long_integer_type_node
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|specs
operator|->
name|short_p
condition|)
name|specs
operator|->
name|type
operator|=
operator|(
name|specs
operator|->
name|unsigned_p
condition|?
name|short_unsigned_type_node
else|:
name|short_integer_type_node
operator|)
expr_stmt|;
else|else
name|specs
operator|->
name|type
operator|=
operator|(
name|specs
operator|->
name|unsigned_p
condition|?
name|unsigned_type_node
else|:
name|integer_type_node
operator|)
expr_stmt|;
if|if
condition|(
name|specs
operator|->
name|complex_p
condition|)
block|{
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ISO C does not support complex integer types"
argument_list|)
expr_stmt|;
name|specs
operator|->
name|type
operator|=
name|build_complex_type
argument_list|(
name|specs
operator|->
name|type
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|cts_float
case|:
name|gcc_assert
argument_list|(
operator|!
name|specs
operator|->
name|long_p
operator|&&
operator|!
name|specs
operator|->
name|short_p
operator|&&
operator|!
name|specs
operator|->
name|signed_p
operator|&&
operator|!
name|specs
operator|->
name|unsigned_p
argument_list|)
expr_stmt|;
name|specs
operator|->
name|type
operator|=
operator|(
name|specs
operator|->
name|complex_p
condition|?
name|complex_float_type_node
else|:
name|float_type_node
operator|)
expr_stmt|;
break|break;
case|case
name|cts_double
case|:
name|gcc_assert
argument_list|(
operator|!
name|specs
operator|->
name|long_long_p
operator|&&
operator|!
name|specs
operator|->
name|short_p
operator|&&
operator|!
name|specs
operator|->
name|signed_p
operator|&&
operator|!
name|specs
operator|->
name|unsigned_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|specs
operator|->
name|long_p
condition|)
block|{
name|specs
operator|->
name|type
operator|=
operator|(
name|specs
operator|->
name|complex_p
condition|?
name|complex_long_double_type_node
else|:
name|long_double_type_node
operator|)
expr_stmt|;
block|}
else|else
block|{
name|specs
operator|->
name|type
operator|=
operator|(
name|specs
operator|->
name|complex_p
condition|?
name|complex_double_type_node
else|:
name|double_type_node
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|cts_dfloat32
case|:
case|case
name|cts_dfloat64
case|:
case|case
name|cts_dfloat128
case|:
name|gcc_assert
argument_list|(
operator|!
name|specs
operator|->
name|long_p
operator|&&
operator|!
name|specs
operator|->
name|long_long_p
operator|&&
operator|!
name|specs
operator|->
name|short_p
operator|&&
operator|!
name|specs
operator|->
name|signed_p
operator|&&
operator|!
name|specs
operator|->
name|unsigned_p
operator|&&
operator|!
name|specs
operator|->
name|complex_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|specs
operator|->
name|typespec_word
operator|==
name|cts_dfloat32
condition|)
name|specs
operator|->
name|type
operator|=
name|dfloat32_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|specs
operator|->
name|typespec_word
operator|==
name|cts_dfloat64
condition|)
name|specs
operator|->
name|type
operator|=
name|dfloat64_type_node
expr_stmt|;
else|else
name|specs
operator|->
name|type
operator|=
name|dfloat128_type_node
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
return|return
name|specs
return|;
block|}
end_function

begin_comment
comment|/* Synthesize a function which calls all the global ctors or global    dtors in this file.  This is only used for targets which do not    support .ctors/.dtors sections.  FIXME: Migrate into cgraph.  */
end_comment

begin_function
specifier|static
name|void
name|build_cdtor
parameter_list|(
name|int
name|method_type
parameter_list|,
name|tree
name|cdtors
parameter_list|)
block|{
name|tree
name|body
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|cdtors
condition|)
return|return;
for|for
control|(
init|;
name|cdtors
condition|;
name|cdtors
operator|=
name|TREE_CHAIN
argument_list|(
name|cdtors
argument_list|)
control|)
name|append_to_statement_list
argument_list|(
name|build_function_call
argument_list|(
name|TREE_VALUE
argument_list|(
name|cdtors
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|body
argument_list|)
expr_stmt|;
name|cgraph_build_static_cdtor
argument_list|(
name|method_type
argument_list|,
name|body
argument_list|,
name|DEFAULT_INIT_PRIORITY
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A subroutine of c_write_global_declarations.  Perform final processing    on one file scope's declarations (or the external scope's declarations),    GLOBALS.  */
end_comment

begin_function
specifier|static
name|void
name|c_write_global_declarations_1
parameter_list|(
name|tree
name|globals
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|;
name|bool
name|reconsider
decl_stmt|;
comment|/* Process the decls in the order they were written.  */
for|for
control|(
name|decl
operator|=
name|globals
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
block|{
comment|/* Check for used but undefined static functions using the C 	 standard's definition of "used", and set TREE_NO_WARNING so 	 that check_global_declarations doesn't repeat the check.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|C_DECL_USED
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|pedwarn
argument_list|(
literal|"%q+F used but never defined"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|TREE_NO_WARNING
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|wrapup_global_declaration_1
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
do|do
block|{
name|reconsider
operator|=
name|false
expr_stmt|;
for|for
control|(
name|decl
operator|=
name|globals
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
name|reconsider
operator||=
name|wrapup_global_declaration_2
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|reconsider
condition|)
do|;
for|for
control|(
name|decl
operator|=
name|globals
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
name|check_global_declaration_1
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A subroutine of c_write_global_declarations Emit debug information for each    of the declarations in GLOBALS.  */
end_comment

begin_function
specifier|static
name|void
name|c_write_global_declarations_2
parameter_list|(
name|tree
name|globals
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|;
for|for
control|(
name|decl
operator|=
name|globals
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
name|debug_hooks
operator|->
name|global_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Preserve the external declarations scope across a garbage collect.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|ext_block
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|c_write_global_declarations
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
comment|/* We don't want to do this if generating a PCH.  */
if|if
condition|(
name|pch_file
condition|)
return|return;
comment|/* Don't waste time on further processing if -fsyntax-only or we've      encountered errors.  */
if|if
condition|(
name|flag_syntax_only
operator|||
name|errorcount
operator|||
name|sorrycount
operator|||
name|cpp_errors
argument_list|(
name|parse_in
argument_list|)
condition|)
return|return;
comment|/* Close the external scope.  */
name|ext_block
operator|=
name|pop_scope
argument_list|()
expr_stmt|;
name|external_scope
operator|=
literal|0
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|current_scope
argument_list|)
expr_stmt|;
if|if
condition|(
name|ext_block
condition|)
block|{
name|tree
name|tmp
init|=
name|BLOCK_VARS
argument_list|(
name|ext_block
argument_list|)
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|FILE
modifier|*
name|stream
init|=
name|dump_begin
argument_list|(
name|TDI_tu
argument_list|,
operator|&
name|flags
argument_list|)
decl_stmt|;
if|if
condition|(
name|stream
operator|&&
name|tmp
condition|)
block|{
name|dump_node
argument_list|(
name|tmp
argument_list|,
name|flags
operator|&
operator|~
name|TDF_SLIM
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|dump_end
argument_list|(
name|TDI_tu
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Process all file scopes in this compilation, and the external_scope,      through wrapup_global_declarations and check_global_declarations.  */
for|for
control|(
name|t
operator|=
name|all_translation_units
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
name|c_write_global_declarations_1
argument_list|(
name|BLOCK_VARS
argument_list|(
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|c_write_global_declarations_1
argument_list|(
name|BLOCK_VARS
argument_list|(
name|ext_block
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Generate functions to call static constructors and destructors      for targets that do not support .ctors/.dtors sections.  These      functions have magic names which are detected by collect2.  */
name|build_cdtor
argument_list|(
literal|'I'
argument_list|,
name|static_ctors
argument_list|)
expr_stmt|;
name|static_ctors
operator|=
literal|0
expr_stmt|;
name|build_cdtor
argument_list|(
literal|'D'
argument_list|,
name|static_dtors
argument_list|)
expr_stmt|;
name|static_dtors
operator|=
literal|0
expr_stmt|;
comment|/* We're done parsing; proceed to optimize and emit assembly.      FIXME: shouldn't be the front end's responsibility to call this.  */
name|cgraph_optimize
argument_list|()
expr_stmt|;
comment|/* After cgraph has had a chance to emit everything that's going to      be emitted, output debug information for globals.  */
if|if
condition|(
name|errorcount
operator|==
literal|0
operator|&&
name|sorrycount
operator|==
literal|0
condition|)
block|{
name|timevar_push
argument_list|(
name|TV_SYMOUT
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|all_translation_units
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
name|c_write_global_declarations_2
argument_list|(
name|BLOCK_VARS
argument_list|(
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|c_write_global_declarations_2
argument_list|(
name|BLOCK_VARS
argument_list|(
name|ext_block
argument_list|)
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_SYMOUT
argument_list|)
expr_stmt|;
block|}
name|ext_block
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_include
include|#
directive|include
file|"gt-c-decl.h"
end_include

end_unit

