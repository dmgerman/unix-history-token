begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Subroutines for manipulating rtx's in semantically interesting ways.    Copyright (C) 1987, 1991, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"optabs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_decl_stmt
specifier|static
name|rtx
name|break_out_memory_refs
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|emit_stack_probe
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Truncate and perhaps sign-extend C as appropriate for MODE.  */
end_comment

begin_function
name|HOST_WIDE_INT
name|trunc_int_for_mode
parameter_list|(
name|c
parameter_list|,
name|mode
parameter_list|)
name|HOST_WIDE_INT
name|c
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|int
name|width
init|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
comment|/* Canonicalize BImode to 0 and STORE_FLAG_VALUE.  */
if|if
condition|(
name|mode
operator|==
name|BImode
condition|)
return|return
name|c
operator|&
literal|1
condition|?
name|STORE_FLAG_VALUE
else|:
literal|0
return|;
comment|/* Sign-extend for the requested mode.  */
if|if
condition|(
name|width
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|HOST_WIDE_INT
name|sign
init|=
literal|1
decl_stmt|;
name|sign
operator|<<=
name|width
operator|-
literal|1
expr_stmt|;
name|c
operator|&=
operator|(
name|sign
operator|<<
literal|1
operator|)
operator|-
literal|1
expr_stmt|;
name|c
operator|^=
name|sign
expr_stmt|;
name|c
operator|-=
name|sign
expr_stmt|;
block|}
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/* Return an rtx for the sum of X and the integer C.     This function should be used via the `plus_constant' macro.  */
end_comment

begin_function
name|rtx
name|plus_constant_wide
parameter_list|(
name|x
parameter_list|,
name|c
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|HOST_WIDE_INT
name|c
decl_stmt|;
block|{
name|RTX_CODE
name|code
decl_stmt|;
name|rtx
name|y
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
name|int
name|all_constant
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
return|return
name|x
return|;
name|restart
label|:
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|y
operator|=
name|x
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONST_INT
case|:
return|return
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|+
name|c
argument_list|)
return|;
case|case
name|CONST_DOUBLE
case|:
block|{
name|unsigned
name|HOST_WIDE_INT
name|l1
init|=
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|h1
init|=
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|l2
init|=
name|c
decl_stmt|;
name|HOST_WIDE_INT
name|h2
init|=
name|c
operator|<
literal|0
condition|?
operator|~
literal|0
else|:
literal|0
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|lv
decl_stmt|;
name|HOST_WIDE_INT
name|hv
decl_stmt|;
name|add_double
argument_list|(
name|l1
argument_list|,
name|h1
argument_list|,
name|l2
argument_list|,
name|h2
argument_list|,
operator|&
name|lv
argument_list|,
operator|&
name|hv
argument_list|)
expr_stmt|;
return|return
name|immed_double_const
argument_list|(
name|lv
argument_list|,
name|hv
argument_list|,
name|VOIDmode
argument_list|)
return|;
block|}
case|case
name|MEM
case|:
comment|/* If this is a reference to the constant pool, try replacing it with 	 a reference to a new constant.  If the resulting address isn't 	 valid, don't return it because we have no way to validize it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|tem
operator|=
name|force_const_mem
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|plus_constant
argument_list|(
name|get_pool_constant
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|c
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|memory_address_p
argument_list|(
name|GET_MODE
argument_list|(
name|tem
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|tem
return|;
block|}
break|break;
case|case
name|CONST
case|:
comment|/* If adding to something entirely constant, set a flag 	 so that we can add a CONST around the result.  */
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|all_constant
operator|=
literal|1
expr_stmt|;
goto|goto
name|restart
goto|;
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
name|all_constant
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|PLUS
case|:
comment|/* The interesting case is adding the integer to a sum. 	 Look for constant term in the sum and combine 	 with C.  For an integer constant term, we make a combined 	 integer.  For a constant term that is not an explicit integer, 	 we cannot really combine, but group them together anyway.    	 Restart or use a recursive call in case the remaining operand is 	 something that we handle specially, such as a SYMBOL_REF.  	 We may not immediately return from the recursive call here, lest 	 all_constant gets lost.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|c
operator|+=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|VOIDmode
condition|)
name|c
operator|=
name|trunc_int_for_mode
argument_list|(
name|c
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|x
operator|=
name|gen_rtx_PLUS
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|find_constant_term_loc
argument_list|(
operator|&
name|y
argument_list|)
condition|)
block|{
comment|/* We need to be careful since X may be shared and we can't 	     modify it in place.  */
name|rtx
name|copy
init|=
name|copy_rtx
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|rtx
modifier|*
name|const_loc
init|=
name|find_constant_term_loc
argument_list|(
operator|&
name|copy
argument_list|)
decl_stmt|;
operator|*
name|const_loc
operator|=
name|plus_constant
argument_list|(
operator|*
name|const_loc
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|x
operator|=
name|copy
expr_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|c
operator|!=
literal|0
condition|)
name|x
operator|=
name|gen_rtx_PLUS
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
name|GEN_INT
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LABEL_REF
condition|)
return|return
name|x
return|;
elseif|else
if|if
condition|(
name|all_constant
condition|)
return|return
name|gen_rtx_CONST
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
return|;
else|else
return|return
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If X is a sum, return a new sum like X but lacking any constant terms.    Add all the removed constant terms into *CONSTPTR.    X itself is not altered.  The result != X if and only if    it is not isomorphic to X.  */
end_comment

begin_function
name|rtx
name|eliminate_constant_term
parameter_list|(
name|x
parameter_list|,
name|constptr
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
modifier|*
name|constptr
decl_stmt|;
block|{
name|rtx
name|x0
decl_stmt|,
name|x1
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|PLUS
condition|)
return|return
name|x
return|;
comment|/* First handle constants appearing at this level explicitly.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
literal|0
operator|!=
operator|(
name|tem
operator|=
name|simplify_binary_operation
argument_list|(
name|PLUS
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
operator|*
name|constptr
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
operator|*
name|constptr
operator|=
name|tem
expr_stmt|;
return|return
name|eliminate_constant_term
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|constptr
argument_list|)
return|;
block|}
name|tem
operator|=
name|const0_rtx
expr_stmt|;
name|x0
operator|=
name|eliminate_constant_term
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|tem
argument_list|)
expr_stmt|;
name|x1
operator|=
name|eliminate_constant_term
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
operator|&
name|tem
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|x1
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|||
name|x0
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|)
operator|&&
literal|0
operator|!=
operator|(
name|tem
operator|=
name|simplify_binary_operation
argument_list|(
name|PLUS
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
operator|*
name|constptr
argument_list|,
name|tem
argument_list|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
operator|*
name|constptr
operator|=
name|tem
expr_stmt|;
return|return
name|gen_rtx_PLUS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|x0
argument_list|,
name|x1
argument_list|)
return|;
block|}
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Returns the insn that next references REG after INSN, or 0    if REG is clobbered before next referenced or we cannot find    an insn that references REG in a straight-line piece of code.  */
end_comment

begin_function
name|rtx
name|find_next_ref
parameter_list|(
name|reg
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|reg
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|next
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
init|;
name|insn
condition|;
name|insn
operator|=
name|next
control|)
block|{
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
continue|continue;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|BARRIER
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
if|if
condition|(
name|reg_set_p
argument_list|(
name|reg
argument_list|,
name|insn
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|reg
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
return|return
name|insn
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
if|if
condition|(
name|any_uncondjump_p
argument_list|(
name|insn
argument_list|)
condition|)
name|next
operator|=
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
expr_stmt|;
else|else
return|return
literal|0
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|&&
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|call_used_regs
index|[
name|REGNO
argument_list|(
name|reg
argument_list|)
index|]
condition|)
return|return
literal|0
return|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return an rtx for the size in bytes of the value of EXP.  */
end_comment

begin_function
name|rtx
name|expr_size
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
name|tree
name|size
decl_stmt|;
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
literal|'d'
operator|&&
name|DECL_SIZE_UNIT
argument_list|(
name|exp
argument_list|)
operator|!=
literal|0
condition|)
name|size
operator|=
name|DECL_SIZE_UNIT
argument_list|(
name|exp
argument_list|)
expr_stmt|;
else|else
name|size
operator|=
name|size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|size
argument_list|)
operator|!=
name|INTEGER_CST
operator|&&
name|contains_placeholder_p
argument_list|(
name|size
argument_list|)
condition|)
name|size
operator|=
name|build
argument_list|(
name|WITH_RECORD_EXPR
argument_list|,
name|sizetype
argument_list|,
name|size
argument_list|,
name|exp
argument_list|)
expr_stmt|;
return|return
name|expand_expr
argument_list|(
name|size
argument_list|,
name|NULL_RTX
argument_list|,
name|TYPE_MODE
argument_list|(
name|sizetype
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a copy of X in which all memory references    and all constants that involve symbol refs    have been replaced with new temporary registers.    Also emit code to load the memory locations and constants    into those registers.     If X contains no such constants or memory references,    X itself (not a copy) is returned.     If a constant is found in the address that is not a legitimate constant    in an insn, it is left alone in the hope that it might be valid in the    address.     X may contain no arithmetic except addition, subtraction and multiplication.    Values returned by expand_expr with 1 for sum_ok fit this constraint.  */
end_comment

begin_function
specifier|static
name|rtx
name|break_out_memory_refs
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
operator|||
operator|(
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
operator|&&
name|CONSTANT_ADDRESS_P
argument_list|(
name|x
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|VOIDmode
operator|)
condition|)
name|x
operator|=
name|force_reg
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|x
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MINUS
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MULT
condition|)
block|{
name|rtx
name|op0
init|=
name|break_out_memory_refs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|break_out_memory_refs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|op0
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|||
name|op1
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|)
name|x
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
block|}
return|return
name|x
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|POINTERS_EXTEND_UNSIGNED
end_ifdef

begin_comment
comment|/* Given X, a memory address in ptr_mode, convert it to an address    in Pmode, or vice versa (TO_MODE says which way).  We take advantage of    the fact that pointers are not allowed to overflow by commuting arithmetic    operations over conversions so that address arithmetic insns can be    used.  */
end_comment

begin_function
name|rtx
name|convert_memory_address
parameter_list|(
name|to_mode
parameter_list|,
name|x
parameter_list|)
name|enum
name|machine_mode
name|to_mode
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
name|enum
name|machine_mode
name|from_mode
init|=
name|to_mode
operator|==
name|ptr_mode
condition|?
name|Pmode
else|:
name|ptr_mode
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
comment|/* Here we handle some special cases.  If none of them apply, fall through      to the default case.  */
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
return|return
name|x
return|;
case|case
name|SUBREG
case|:
if|if
condition|(
name|POINTERS_EXTEND_UNSIGNED
operator|>=
literal|0
operator|&&
operator|(
name|SUBREG_PROMOTED_VAR_P
argument_list|(
name|x
argument_list|)
operator|||
name|REG_POINTER
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
operator|&&
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|to_mode
condition|)
return|return
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
return|;
break|break;
case|case
name|LABEL_REF
case|:
if|if
condition|(
name|POINTERS_EXTEND_UNSIGNED
operator|>=
literal|0
condition|)
block|{
name|temp
operator|=
name|gen_rtx_LABEL_REF
argument_list|(
name|to_mode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|LABEL_REF_NONLOCAL_P
argument_list|(
name|temp
argument_list|)
operator|=
name|LABEL_REF_NONLOCAL_P
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
break|break;
case|case
name|SYMBOL_REF
case|:
if|if
condition|(
name|POINTERS_EXTEND_UNSIGNED
operator|>=
literal|0
condition|)
block|{
name|temp
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|to_mode
argument_list|,
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|SYMBOL_REF_FLAG
argument_list|(
name|temp
argument_list|)
operator|=
name|SYMBOL_REF_FLAG
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|temp
argument_list|)
operator|=
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|STRING_POOL_ADDRESS_P
argument_list|(
name|temp
argument_list|)
operator|=
name|STRING_POOL_ADDRESS_P
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
break|break;
case|case
name|CONST
case|:
if|if
condition|(
name|POINTERS_EXTEND_UNSIGNED
operator|>=
literal|0
condition|)
return|return
name|gen_rtx_CONST
argument_list|(
name|to_mode
argument_list|,
name|convert_memory_address
argument_list|(
name|to_mode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
break|break;
case|case
name|PLUS
case|:
case|case
name|MULT
case|:
comment|/* For addition the second operand is a small constant, we can safely 	 permute the conversion and addition operation.  We can always safely 	 permute them if we are making the address narrower.  In addition, 	 always permute the operations if this is a constant.  */
if|if
condition|(
name|POINTERS_EXTEND_UNSIGNED
operator|>=
literal|0
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|to_mode
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|from_mode
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|+
literal|20000
operator|<
literal|40000
operator|||
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|)
operator|)
condition|)
return|return
name|gen_rtx_fmt_ee
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|to_mode
argument_list|,
name|convert_memory_address
argument_list|(
name|to_mode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|convert_memory_address
argument_list|(
name|to_mode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
break|break;
default|default:
break|break;
block|}
return|return
name|convert_modes
argument_list|(
name|to_mode
argument_list|,
name|from_mode
argument_list|,
name|x
argument_list|,
name|POINTERS_EXTEND_UNSIGNED
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Given a memory address or facsimile X, construct a new address,    currently equivalent, that is stable: future stores won't change it.     X must be composed of constants, register and memory references    combined with addition, subtraction and multiplication:    in other words, just what you can get from expand_expr if sum_ok is 1.     Works by making copies of all regs and memory locations used    by X and combining them the same way X does.    You could also stabilize the reference to this address    by copying the address to a register with copy_to_reg;    but then you wouldn't get indexed addressing in the reference.  */
end_comment

begin_function
name|rtx
name|copy_all_regs
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|!=
name|FRAME_POINTER_REGNUM
if|#
directive|if
name|HARD_FRAME_POINTER_REGNUM
operator|!=
name|FRAME_POINTER_REGNUM
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|!=
name|HARD_FRAME_POINTER_REGNUM
endif|#
directive|endif
condition|)
name|x
operator|=
name|copy_to_reg
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
name|x
operator|=
name|copy_to_reg
argument_list|(
name|x
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MINUS
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MULT
condition|)
block|{
name|rtx
name|op0
init|=
name|copy_all_regs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|copy_all_regs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|op0
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|||
name|op1
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|)
name|x
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
block|}
return|return
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return something equivalent to X but valid as a memory address    for something of mode MODE.  When X is not itself valid, this    works by copying X or subexpressions of it into registers.  */
end_comment

begin_function
name|rtx
name|memory_address
parameter_list|(
name|mode
parameter_list|,
name|x
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
name|rtx
name|oldx
init|=
name|x
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|ADDRESSOF
condition|)
return|return
name|x
return|;
ifdef|#
directive|ifdef
name|POINTERS_EXTEND_UNSIGNED
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|Pmode
condition|)
name|x
operator|=
name|convert_memory_address
argument_list|(
name|Pmode
argument_list|,
name|x
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* By passing constant addresses thru registers      we get a chance to cse them.  */
if|if
condition|(
operator|!
name|cse_not_expected
operator|&&
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
operator|&&
name|CONSTANT_ADDRESS_P
argument_list|(
name|x
argument_list|)
condition|)
name|x
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* Accept a QUEUED that refers to a REG      even though that isn't a valid address.      On attempting to put this in an insn we will call protect_from_queue      which will turn it into a REG, which is valid.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|QUEUED
operator|&&
name|GET_CODE
argument_list|(
name|QUEUED_VAR
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
empty_stmt|;
comment|/* We get better cse by rejecting indirect addressing at this stage.      Let the combiner create indirect addresses where appropriate.      For now, generate the code so that the subexpressions useful to share      are visible.  But not if cse won't be done!  */
else|else
block|{
if|if
condition|(
operator|!
name|cse_not_expected
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
condition|)
name|x
operator|=
name|break_out_memory_refs
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* At this point, any valid address is accepted.  */
name|GO_IF_LEGITIMATE_ADDRESS
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
name|win
argument_list|)
expr_stmt|;
comment|/* If it was valid before but breaking out memory refs invalidated it, 	 use it the old way.  */
if|if
condition|(
name|memory_address_p
argument_list|(
name|mode
argument_list|,
name|oldx
argument_list|)
condition|)
goto|goto
name|win2
goto|;
comment|/* Perform machine-dependent transformations on X 	 in certain cases.  This is not necessary since the code 	 below can handle all possible cases, but machine-dependent 	 transformations can make better code.  */
name|LEGITIMIZE_ADDRESS
argument_list|(
name|x
argument_list|,
name|oldx
argument_list|,
name|mode
argument_list|,
name|win
argument_list|)
expr_stmt|;
comment|/* PLUS and MULT can appear in special ways 	 as the result of attempts to make an address usable for indexing. 	 Usually they are dealt with by calling force_operand, below. 	 But a sum containing constant terms is special 	 if removing them makes the sum a valid address: 	 then we generate that address in a register 	 and index off of it.  We do this because it often makes 	 shorter code, and because the addresses thus generated 	 in registers often become common subexpressions.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|rtx
name|constant_term
init|=
name|const0_rtx
decl_stmt|;
name|rtx
name|y
init|=
name|eliminate_constant_term
argument_list|(
name|x
argument_list|,
operator|&
name|constant_term
argument_list|)
decl_stmt|;
if|if
condition|(
name|constant_term
operator|==
name|const0_rtx
operator|||
operator|!
name|memory_address_p
argument_list|(
name|mode
argument_list|,
name|y
argument_list|)
condition|)
name|x
operator|=
name|force_operand
argument_list|(
name|x
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
else|else
block|{
name|y
operator|=
name|gen_rtx_PLUS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|copy_to_reg
argument_list|(
name|y
argument_list|)
argument_list|,
name|constant_term
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|memory_address_p
argument_list|(
name|mode
argument_list|,
name|y
argument_list|)
condition|)
name|x
operator|=
name|force_operand
argument_list|(
name|x
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
else|else
name|x
operator|=
name|y
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MULT
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MINUS
condition|)
name|x
operator|=
name|force_operand
argument_list|(
name|x
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
comment|/* If we have a register that's an invalid address, 	 it must be a hard reg of the wrong class.  Copy it to a pseudo.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
name|x
operator|=
name|copy_to_reg
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* Last resort: copy the value to a register, since 	 the register is a valid address.  */
else|else
name|x
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|x
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
name|win2
label|:
name|x
operator|=
name|oldx
expr_stmt|;
name|win
label|:
if|if
condition|(
name|flag_force_addr
operator|&&
operator|!
name|cse_not_expected
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
comment|/* Don't copy an addr via a reg if it is one of our stack slots.  */
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
operator|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|virtual_stack_vars_rtx
operator|||
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|virtual_incoming_args_rtx
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|general_operand
argument_list|(
name|x
argument_list|,
name|Pmode
argument_list|)
condition|)
name|x
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|x
argument_list|)
expr_stmt|;
else|else
name|x
operator|=
name|force_operand
argument_list|(
name|x
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
block|}
name|done
label|:
comment|/* If we didn't change the address, we are done.  Otherwise, mark      a reg as a pointer if we have REG or REG + CONST_INT.  */
if|if
condition|(
name|oldx
operator|==
name|x
condition|)
return|return
name|x
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
name|mark_reg_pointer
argument_list|(
name|x
argument_list|,
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
name|mark_reg_pointer
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
comment|/* OLDX may have been the address on a temporary.  Update the address      to indicate that X is now used.  */
name|update_temp_slot_address
argument_list|(
name|oldx
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Like `memory_address' but pretend `flag_force_addr' is 0.  */
end_comment

begin_function
name|rtx
name|memory_address_noforce
parameter_list|(
name|mode
parameter_list|,
name|x
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
name|int
name|ambient_force_addr
init|=
name|flag_force_addr
decl_stmt|;
name|rtx
name|val
decl_stmt|;
name|flag_force_addr
operator|=
literal|0
expr_stmt|;
name|val
operator|=
name|memory_address
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|flag_force_addr
operator|=
name|ambient_force_addr
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Convert a mem ref into one with a valid memory address.    Pass through anything else unchanged.  */
end_comment

begin_function
name|rtx
name|validize_mem
parameter_list|(
name|ref
parameter_list|)
name|rtx
name|ref
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|ref
argument_list|)
operator|!=
name|MEM
condition|)
return|return
name|ref
return|;
if|if
condition|(
operator|!
operator|(
name|flag_force_addr
operator|&&
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|&&
name|memory_address_p
argument_list|(
name|GET_MODE
argument_list|(
name|ref
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|ref
return|;
comment|/* Don't alter REF itself, since that is probably a stack slot.  */
return|return
name|replace_equiv_address
argument_list|(
name|ref
argument_list|,
name|XEXP
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given REF, either a MEM or a REG, and T, either the type of X or    the expression corresponding to REF, set RTX_UNCHANGING_P if    appropriate.  */
end_comment

begin_function
name|void
name|maybe_set_unchanging
parameter_list|(
name|ref
parameter_list|,
name|t
parameter_list|)
name|rtx
name|ref
decl_stmt|;
name|tree
name|t
decl_stmt|;
block|{
comment|/* We can set RTX_UNCHANGING_P from TREE_READONLY for decls whose      initialization is only executed once, or whose initializer always      has the same value.  Currently we simplify this to PARM_DECLs in the      first case, and decls with TREE_CONSTANT initializers in the second.  */
if|if
condition|(
operator|(
name|TREE_READONLY
argument_list|(
name|t
argument_list|)
operator|&&
name|DECL_P
argument_list|(
name|t
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|PARM_DECL
operator|||
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
operator|==
name|NULL_TREE
operator|||
name|TREE_CONSTANT
argument_list|(
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
argument_list|)
operator|)
operator|)
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
literal|'c'
condition|)
name|RTX_UNCHANGING_P
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a modified copy of X with its memory address copied    into a temporary register to protect it from side effects.    If X is not a MEM, it is returned unchanged (and not copied).    Perhaps even if it is a MEM, if there is no need to change it.  */
end_comment

begin_function
name|rtx
name|stabilize
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM
operator|||
operator|!
name|rtx_unstable_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|x
return|;
return|return
name|replace_equiv_address
argument_list|(
name|x
argument_list|,
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|copy_all_regs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Copy the value or contents of X to a new temp reg and return that reg.  */
end_comment

begin_function
name|rtx
name|copy_to_reg
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|rtx
name|temp
init|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
comment|/* If not an operand, must be an address with PLUS and MULT so      do the computation.  */
if|if
condition|(
operator|!
name|general_operand
argument_list|(
name|x
argument_list|,
name|VOIDmode
argument_list|)
condition|)
name|x
operator|=
name|force_operand
argument_list|(
name|x
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|temp
condition|)
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
end_function

begin_comment
comment|/* Like copy_to_reg but always give the new register mode Pmode    in case X is a constant.  */
end_comment

begin_function
name|rtx
name|copy_addr_to_reg
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
return|return
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|x
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Like copy_to_reg but always give the new register mode MODE    in case X is a constant.  */
end_comment

begin_function
name|rtx
name|copy_to_mode_reg
parameter_list|(
name|mode
parameter_list|,
name|x
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
name|rtx
name|temp
init|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
decl_stmt|;
comment|/* If not an operand, must be an address with PLUS and MULT so      do the computation.  */
if|if
condition|(
operator|!
name|general_operand
argument_list|(
name|x
argument_list|,
name|VOIDmode
argument_list|)
condition|)
name|x
operator|=
name|force_operand
argument_list|(
name|x
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|mode
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|VOIDmode
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|temp
condition|)
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
end_function

begin_comment
comment|/* Load X into a register if it is not already one.    Use mode MODE for the register.    X should be valid for mode MODE, but it may be a constant which    is valid for all integer modes; that's why caller must specify MODE.     The caller must not alter the value in the register we return,    since we mark it as a "constant" register.  */
end_comment

begin_function
name|rtx
name|force_reg
parameter_list|(
name|mode
parameter_list|,
name|x
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
name|rtx
name|temp
decl_stmt|,
name|insn
decl_stmt|,
name|set
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
return|return
name|x
return|;
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|general_operand
argument_list|(
name|x
argument_list|,
name|mode
argument_list|)
condition|)
name|x
operator|=
name|force_operand
argument_list|(
name|x
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* Let optimizers know that TEMP's value never changes      and that X can be substituted for it.  Don't get confused      if INSN set something else (such as a SUBREG of TEMP).  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
operator|&&
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|==
name|temp
condition|)
name|set_unique_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EQUAL
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
end_function

begin_comment
comment|/* If X is a memory ref, copy its contents to a new temp reg and return    that reg.  Otherwise, return X.  */
end_comment

begin_function
name|rtx
name|force_not_mem
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|rtx
name|temp
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM
operator|||
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|BLKmode
condition|)
return|return
name|x
return|;
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
end_function

begin_comment
comment|/* Copy X to TARGET (if it's nonzero and a reg)    or to a new temp reg and return that reg.    MODE is the mode to use for X in case it is a constant.  */
end_comment

begin_function
name|rtx
name|copy_to_suggested_reg
parameter_list|(
name|x
parameter_list|,
name|target
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|target
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|rtx
name|temp
decl_stmt|;
if|if
condition|(
name|target
operator|&&
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|REG
condition|)
name|temp
operator|=
name|target
expr_stmt|;
else|else
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the mode to use to store a scalar of TYPE and MODE.    PUNSIGNEDP points to the signedness of the type and may be adjusted    to show what signedness to use on extension operations.     FOR_CALL is non-zero if this call is promoting args for a call.  */
end_comment

begin_function
name|enum
name|machine_mode
name|promote_mode
parameter_list|(
name|type
parameter_list|,
name|mode
parameter_list|,
name|punsignedp
parameter_list|,
name|for_call
parameter_list|)
name|tree
name|type
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
modifier|*
name|punsignedp
decl_stmt|;
name|int
name|for_call
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|unsignedp
init|=
operator|*
name|punsignedp
decl_stmt|;
ifdef|#
directive|ifdef
name|PROMOTE_FOR_CALL_ONLY
if|if
condition|(
operator|!
name|for_call
condition|)
return|return
name|mode
return|;
endif|#
directive|endif
switch|switch
condition|(
name|code
condition|)
block|{
ifdef|#
directive|ifdef
name|PROMOTE_MODE
case|case
name|INTEGER_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
case|case
name|BOOLEAN_TYPE
case|:
case|case
name|CHAR_TYPE
case|:
case|case
name|REAL_TYPE
case|:
case|case
name|OFFSET_TYPE
case|:
name|PROMOTE_MODE
argument_list|(
name|mode
argument_list|,
name|unsignedp
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|POINTERS_EXTEND_UNSIGNED
case|case
name|REFERENCE_TYPE
case|:
case|case
name|POINTER_TYPE
case|:
name|mode
operator|=
name|Pmode
expr_stmt|;
name|unsignedp
operator|=
name|POINTERS_EXTEND_UNSIGNED
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
break|break;
block|}
operator|*
name|punsignedp
operator|=
name|unsignedp
expr_stmt|;
return|return
name|mode
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Adjust the stack pointer by ADJUST (an rtx for a number of bytes).    This pops when ADJUST is positive.  ADJUST need not be constant.  */
end_comment

begin_function
name|void
name|adjust_stack
parameter_list|(
name|adjust
parameter_list|)
name|rtx
name|adjust
decl_stmt|;
block|{
name|rtx
name|temp
decl_stmt|;
name|adjust
operator|=
name|protect_from_queue
argument_list|(
name|adjust
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|adjust
operator|==
name|const0_rtx
condition|)
return|return;
comment|/* We expect all variable sized adjustments to be multiple of      PREFERRED_STACK_BOUNDARY.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|adjust
argument_list|)
operator|==
name|CONST_INT
condition|)
name|stack_pointer_delta
operator|-=
name|INTVAL
argument_list|(
name|adjust
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_binop
argument_list|(
name|Pmode
argument_list|,
ifdef|#
directive|ifdef
name|STACK_GROWS_DOWNWARD
name|add_optab
argument_list|,
else|#
directive|else
name|sub_optab
argument_list|,
endif|#
directive|endif
name|stack_pointer_rtx
argument_list|,
name|adjust
argument_list|,
name|stack_pointer_rtx
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
name|stack_pointer_rtx
condition|)
name|emit_move_insn
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Adjust the stack pointer by minus ADJUST (an rtx for a number of bytes).    This pushes when ADJUST is positive.  ADJUST need not be constant.  */
end_comment

begin_function
name|void
name|anti_adjust_stack
parameter_list|(
name|adjust
parameter_list|)
name|rtx
name|adjust
decl_stmt|;
block|{
name|rtx
name|temp
decl_stmt|;
name|adjust
operator|=
name|protect_from_queue
argument_list|(
name|adjust
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|adjust
operator|==
name|const0_rtx
condition|)
return|return;
comment|/* We expect all variable sized adjustments to be multiple of      PREFERRED_STACK_BOUNDARY.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|adjust
argument_list|)
operator|==
name|CONST_INT
condition|)
name|stack_pointer_delta
operator|+=
name|INTVAL
argument_list|(
name|adjust
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_binop
argument_list|(
name|Pmode
argument_list|,
ifdef|#
directive|ifdef
name|STACK_GROWS_DOWNWARD
name|sub_optab
argument_list|,
else|#
directive|else
name|add_optab
argument_list|,
endif|#
directive|endif
name|stack_pointer_rtx
argument_list|,
name|adjust
argument_list|,
name|stack_pointer_rtx
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
name|stack_pointer_rtx
condition|)
name|emit_move_insn
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Round the size of a block to be pushed up to the boundary required    by this machine.  SIZE is the desired size, which need not be constant.  */
end_comment

begin_function
name|rtx
name|round_push
parameter_list|(
name|size
parameter_list|)
name|rtx
name|size
decl_stmt|;
block|{
name|int
name|align
init|=
name|PREFERRED_STACK_BOUNDARY
operator|/
name|BITS_PER_UNIT
decl_stmt|;
if|if
condition|(
name|align
operator|==
literal|1
condition|)
return|return
name|size
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|int
name|new
init|=
operator|(
name|INTVAL
argument_list|(
name|size
argument_list|)
operator|+
name|align
operator|-
literal|1
operator|)
operator|/
name|align
operator|*
name|align
decl_stmt|;
if|if
condition|(
name|INTVAL
argument_list|(
name|size
argument_list|)
operator|!=
name|new
condition|)
name|size
operator|=
name|GEN_INT
argument_list|(
name|new
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* CEIL_DIV_EXPR needs to worry about the addition overflowing, 	 but we know it can't.  So add ourselves and then do 	 TRUNC_DIV_EXPR.  */
name|size
operator|=
name|expand_binop
argument_list|(
name|Pmode
argument_list|,
name|add_optab
argument_list|,
name|size
argument_list|,
name|GEN_INT
argument_list|(
name|align
operator|-
literal|1
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
name|size
operator|=
name|expand_divmod
argument_list|(
literal|0
argument_list|,
name|TRUNC_DIV_EXPR
argument_list|,
name|Pmode
argument_list|,
name|size
argument_list|,
name|GEN_INT
argument_list|(
name|align
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|size
operator|=
name|expand_mult
argument_list|(
name|Pmode
argument_list|,
name|size
argument_list|,
name|GEN_INT
argument_list|(
name|align
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|size
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Save the stack pointer for the purpose in SAVE_LEVEL.  PSAVE is a pointer    to a previously-created save area.  If no save area has been allocated,    this function will allocate one.  If a save area is specified, it    must be of the proper mode.     The insns are emitted after insn AFTER, if nonzero, otherwise the insns    are emitted at the current position.  */
end_comment

begin_function
name|void
name|emit_stack_save
parameter_list|(
name|save_level
parameter_list|,
name|psave
parameter_list|,
name|after
parameter_list|)
name|enum
name|save_level
name|save_level
decl_stmt|;
name|rtx
modifier|*
name|psave
decl_stmt|;
name|rtx
name|after
decl_stmt|;
block|{
name|rtx
name|sa
init|=
operator|*
name|psave
decl_stmt|;
comment|/* The default is that we use a move insn and save in a Pmode object.  */
name|rtx
argument_list|(
argument|*fcn
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
operator|=
name|gen_move_insn
expr_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|STACK_SAVEAREA_MODE
argument_list|(
name|save_level
argument_list|)
decl_stmt|;
comment|/* See if this machine has anything special to do for this kind of save.  */
switch|switch
condition|(
name|save_level
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_save_stack_block
case|case
name|SAVE_BLOCK
case|:
if|if
condition|(
name|HAVE_save_stack_block
condition|)
name|fcn
operator|=
name|gen_save_stack_block
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_save_stack_function
case|case
name|SAVE_FUNCTION
case|:
if|if
condition|(
name|HAVE_save_stack_function
condition|)
name|fcn
operator|=
name|gen_save_stack_function
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_save_stack_nonlocal
case|case
name|SAVE_NONLOCAL
case|:
if|if
condition|(
name|HAVE_save_stack_nonlocal
condition|)
name|fcn
operator|=
name|gen_save_stack_nonlocal
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
break|break;
block|}
comment|/* If there is no save area and we have to allocate one, do so.  Otherwise      verify the save area is the proper mode.  */
if|if
condition|(
name|sa
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
condition|)
block|{
if|if
condition|(
name|save_level
operator|==
name|SAVE_NONLOCAL
condition|)
operator|*
name|psave
operator|=
name|sa
operator|=
name|assign_stack_local
argument_list|(
name|mode
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
operator|*
name|psave
operator|=
name|sa
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|mode
operator|==
name|VOIDmode
operator|||
name|GET_MODE
argument_list|(
name|sa
argument_list|)
operator|!=
name|mode
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|after
condition|)
block|{
name|rtx
name|seq
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
comment|/* We must validize inside the sequence, to ensure that any instructions 	 created by the validize call also get moved to the right place.  */
if|if
condition|(
name|sa
operator|!=
literal|0
condition|)
name|sa
operator|=
name|validize_mem
argument_list|(
name|sa
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|fcn
argument_list|(
name|sa
argument_list|,
name|stack_pointer_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|seq
operator|=
name|gen_sequence
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insn_after
argument_list|(
name|seq
argument_list|,
name|after
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sa
operator|!=
literal|0
condition|)
name|sa
operator|=
name|validize_mem
argument_list|(
name|sa
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|fcn
argument_list|(
name|sa
argument_list|,
name|stack_pointer_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Restore the stack pointer for the purpose in SAVE_LEVEL.  SA is the save    area made by emit_stack_save.  If it is zero, we have nothing to do.      Put any emitted insns after insn AFTER, if nonzero, otherwise at     current position.  */
end_comment

begin_function
name|void
name|emit_stack_restore
parameter_list|(
name|save_level
parameter_list|,
name|sa
parameter_list|,
name|after
parameter_list|)
name|enum
name|save_level
name|save_level
decl_stmt|;
name|rtx
name|after
decl_stmt|;
name|rtx
name|sa
decl_stmt|;
block|{
comment|/* The default is that we use a move insn.  */
name|rtx
argument_list|(
argument|*fcn
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
operator|=
name|gen_move_insn
expr_stmt|;
comment|/* See if this machine has anything special to do for this kind of save.  */
switch|switch
condition|(
name|save_level
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_restore_stack_block
case|case
name|SAVE_BLOCK
case|:
if|if
condition|(
name|HAVE_restore_stack_block
condition|)
name|fcn
operator|=
name|gen_restore_stack_block
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_restore_stack_function
case|case
name|SAVE_FUNCTION
case|:
if|if
condition|(
name|HAVE_restore_stack_function
condition|)
name|fcn
operator|=
name|gen_restore_stack_function
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_restore_stack_nonlocal
case|case
name|SAVE_NONLOCAL
case|:
if|if
condition|(
name|HAVE_restore_stack_nonlocal
condition|)
name|fcn
operator|=
name|gen_restore_stack_nonlocal
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
break|break;
block|}
if|if
condition|(
name|sa
operator|!=
literal|0
condition|)
name|sa
operator|=
name|validize_mem
argument_list|(
name|sa
argument_list|)
expr_stmt|;
if|if
condition|(
name|after
condition|)
block|{
name|rtx
name|seq
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|emit_insn
argument_list|(
name|fcn
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|sa
argument_list|)
argument_list|)
expr_stmt|;
name|seq
operator|=
name|gen_sequence
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insn_after
argument_list|(
name|seq
argument_list|,
name|after
argument_list|)
expr_stmt|;
block|}
else|else
name|emit_insn
argument_list|(
name|fcn
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|sa
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|SETJMP_VIA_SAVE_AREA
end_ifdef

begin_comment
comment|/* Optimize RTL generated by allocate_dynamic_stack_space for targets    where SETJMP_VIA_SAVE_AREA is true.  The problem is that on these    platforms, the dynamic stack space used can corrupt the original    frame, thus causing a crash if a longjmp unwinds to it.  */
end_comment

begin_function
name|void
name|optimize_save_area_alloca
parameter_list|(
name|insns
parameter_list|)
name|rtx
name|insns
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|insns
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|rtx
name|note
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|INSN
condition|)
continue|continue;
for|for
control|(
name|note
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
block|{
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|!=
name|REG_SAVE_AREA
condition|)
continue|continue;
if|if
condition|(
operator|!
name|current_function_calls_setjmp
condition|)
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* If we do not see the note in a pattern matching 		 these precise characteristics, we did something 		 entirely wrong in allocate_dynamic_stack_space.   		 Note, one way this could happen is if SETJMP_VIA_SAVE_AREA 		 was defined on a machine where stacks grow towards higher 		 addresses.  		 Right now only supported port with stack that grow upward 		 is the HPPA and it does not define SETJMP_VIA_SAVE_AREA.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|!=
name|SET
operator|||
name|SET_DEST
argument_list|(
name|pat
argument_list|)
operator|!=
name|stack_pointer_rtx
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|!=
name|MINUS
operator|||
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|!=
name|stack_pointer_rtx
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* This will now be transformed into a (set REG REG) 		 so we can just blow away all the other notes.  */
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|NULL_RTX
expr_stmt|;
block|}
else|else
block|{
comment|/* setjmp was called, we must remove the REG_SAVE_AREA 		 note so that later passes do not get confused by its 		 presence.  */
if|if
condition|(
name|note
operator|==
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|srch
decl_stmt|;
for|for
control|(
name|srch
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|srch
condition|;
name|srch
operator|=
name|XEXP
argument_list|(
name|srch
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|XEXP
argument_list|(
name|srch
argument_list|,
literal|1
argument_list|)
operator|==
name|note
condition|)
break|break;
if|if
condition|(
name|srch
operator|==
name|NULL_RTX
condition|)
name|abort
argument_list|()
expr_stmt|;
name|XEXP
argument_list|(
name|srch
argument_list|,
literal|1
argument_list|)
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Once we've seen the note of interest, we need not look at 	     the rest of them.  */
break|break;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SETJMP_VIA_SAVE_AREA */
end_comment

begin_comment
comment|/* Return an rtx representing the address of an area of memory dynamically    pushed on the stack.  This region of memory is always aligned to    a multiple of BIGGEST_ALIGNMENT.     Any required stack pointer alignment is preserved.     SIZE is an rtx representing the size of the area.    TARGET is a place in which the address can be placed.     KNOWN_ALIGN is the alignment (in bits) that we know SIZE has.  */
end_comment

begin_function
name|rtx
name|allocate_dynamic_stack_space
parameter_list|(
name|size
parameter_list|,
name|target
parameter_list|,
name|known_align
parameter_list|)
name|rtx
name|size
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|int
name|known_align
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|SETJMP_VIA_SAVE_AREA
name|rtx
name|setjmpless_size
init|=
name|NULL_RTX
decl_stmt|;
endif|#
directive|endif
comment|/* If we're asking for zero bytes, it doesn't matter what we point      to since we can't dereference it.  But return a reasonable      address anyway.  */
if|if
condition|(
name|size
operator|==
name|const0_rtx
condition|)
return|return
name|virtual_stack_dynamic_rtx
return|;
comment|/* Otherwise, show we're calling alloca or equivalent.  */
name|current_function_calls_alloca
operator|=
literal|1
expr_stmt|;
comment|/* Ensure the size is in the proper mode.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|size
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|size
argument_list|)
operator|!=
name|Pmode
condition|)
name|size
operator|=
name|convert_to_mode
argument_list|(
name|Pmode
argument_list|,
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* We can't attempt to minimize alignment necessary, because we don't      know the final value of preferred_stack_boundary yet while executing      this code.  */
name|cfun
operator|->
name|preferred_stack_boundary
operator|=
name|PREFERRED_STACK_BOUNDARY
expr_stmt|;
comment|/* We will need to ensure that the address we return is aligned to      BIGGEST_ALIGNMENT.  If STACK_DYNAMIC_OFFSET is defined, we don't      always know its final value at this point in the compilation (it       might depend on the size of the outgoing parameter lists, for      example), so we must align the value to be returned in that case.      (Note that STACK_DYNAMIC_OFFSET will have a default non-zero value if      STACK_POINTER_OFFSET or ACCUMULATE_OUTGOING_ARGS are defined).      We must also do an alignment operation on the returned value if      the stack pointer alignment is less strict that BIGGEST_ALIGNMENT.       If we have to align, we must leave space in SIZE for the hole      that might result from the alignment operation.  */
if|#
directive|if
name|defined
argument_list|(
name|STACK_DYNAMIC_OFFSET
argument_list|)
operator|||
name|defined
argument_list|(
name|STACK_POINTER_OFFSET
argument_list|)
define|#
directive|define
name|MUST_ALIGN
value|1
else|#
directive|else
define|#
directive|define
name|MUST_ALIGN
value|(PREFERRED_STACK_BOUNDARY< BIGGEST_ALIGNMENT)
endif|#
directive|endif
if|if
condition|(
name|MUST_ALIGN
condition|)
name|size
operator|=
name|force_operand
argument_list|(
name|plus_constant
argument_list|(
name|size
argument_list|,
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
operator|-
literal|1
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SETJMP_VIA_SAVE_AREA
comment|/* If setjmp restores regs from a save area in the stack frame,      avoid clobbering the reg save area.  Note that the offset of      virtual_incoming_args_rtx includes the preallocated stack args space.      It would be no problem to clobber that, but it's on the wrong side      of the old save area.  */
block|{
name|rtx
name|dynamic_offset
init|=
name|expand_binop
argument_list|(
name|Pmode
argument_list|,
name|sub_optab
argument_list|,
name|virtual_stack_dynamic_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|current_function_calls_setjmp
condition|)
block|{
name|int
name|align
init|=
name|PREFERRED_STACK_BOUNDARY
operator|/
name|BITS_PER_UNIT
decl_stmt|;
comment|/* See optimize_save_area_alloca to understand what is being 	   set up here.  */
comment|/* ??? Code below assumes that the save area needs maximal 	   alignment.  This constraint may be too strong.  */
if|if
condition|(
name|PREFERRED_STACK_BOUNDARY
operator|!=
name|BIGGEST_ALIGNMENT
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|HOST_WIDE_INT
name|new
init|=
name|INTVAL
argument_list|(
name|size
argument_list|)
operator|/
name|align
operator|*
name|align
decl_stmt|;
if|if
condition|(
name|INTVAL
argument_list|(
name|size
argument_list|)
operator|!=
name|new
condition|)
name|setjmpless_size
operator|=
name|GEN_INT
argument_list|(
name|new
argument_list|)
expr_stmt|;
else|else
name|setjmpless_size
operator|=
name|size
expr_stmt|;
block|}
else|else
block|{
comment|/* Since we know overflow is not possible, we avoid using 	       CEIL_DIV_EXPR and use TRUNC_DIV_EXPR instead.  */
name|setjmpless_size
operator|=
name|expand_divmod
argument_list|(
literal|0
argument_list|,
name|TRUNC_DIV_EXPR
argument_list|,
name|Pmode
argument_list|,
name|size
argument_list|,
name|GEN_INT
argument_list|(
name|align
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|setjmpless_size
operator|=
name|expand_mult
argument_list|(
name|Pmode
argument_list|,
name|setjmpless_size
argument_list|,
name|GEN_INT
argument_list|(
name|align
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Our optimization works based upon being able to perform a simple 	   transformation of this RTL into a (set REG REG) so make sure things 	   did in fact end up in a REG.  */
if|if
condition|(
operator|!
name|register_operand
argument_list|(
name|setjmpless_size
argument_list|,
name|Pmode
argument_list|)
condition|)
name|setjmpless_size
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|setjmpless_size
argument_list|)
expr_stmt|;
block|}
name|size
operator|=
name|expand_binop
argument_list|(
name|Pmode
argument_list|,
name|add_optab
argument_list|,
name|size
argument_list|,
name|dynamic_offset
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SETJMP_VIA_SAVE_AREA */
comment|/* Round the size to a multiple of the required stack alignment.      Since the stack if presumed to be rounded before this allocation,      this will maintain the required alignment.       If the stack grows downward, we could save an insn by subtracting      SIZE from the stack pointer and then aligning the stack pointer.      The problem with this is that the stack pointer may be unaligned      between the execution of the subtraction and alignment insns and      some machines do not allow this.  Even on those that do, some      signal handlers malfunction if a signal should occur between those      insns.  Since this is an extremely rare event, we have no reliable      way of knowing which systems have this problem.  So we avoid even      momentarily mis-aligning the stack.  */
comment|/* If we added a variable amount to SIZE,      we can no longer assume it is aligned.  */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SETJMP_VIA_SAVE_AREA
argument_list|)
if|if
condition|(
name|MUST_ALIGN
operator|||
name|known_align
operator|%
name|PREFERRED_STACK_BOUNDARY
operator|!=
literal|0
condition|)
endif|#
directive|endif
name|size
operator|=
name|round_push
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|do_pending_stack_adjust
argument_list|()
expr_stmt|;
comment|/* We ought to be called always on the toplevel and stack ought to be aligned     properly.  */
if|if
condition|(
name|stack_pointer_delta
operator|%
operator|(
name|PREFERRED_STACK_BOUNDARY
operator|/
name|BITS_PER_UNIT
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If needed, check that we have the required amount of stack.  Take into      account what has already been checked.  */
if|if
condition|(
name|flag_stack_check
operator|&&
operator|!
name|STACK_CHECK_BUILTIN
condition|)
name|probe_stack_range
argument_list|(
name|STACK_CHECK_MAX_FRAME_SIZE
operator|+
name|STACK_CHECK_PROTECT
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* Don't use a TARGET that isn't a pseudo or is the wrong mode.  */
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|target
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|Pmode
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|mark_reg_pointer
argument_list|(
name|target
argument_list|,
name|known_align
argument_list|)
expr_stmt|;
comment|/* Perform the required allocation from the stack.  Some systems do      this differently than simply incrementing/decrementing from the      stack pointer, such as acquiring the space by calling malloc().  */
ifdef|#
directive|ifdef
name|HAVE_allocate_stack
if|if
condition|(
name|HAVE_allocate_stack
condition|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|STACK_SIZE_MODE
decl_stmt|;
name|insn_operand_predicate_fn
name|pred
decl_stmt|;
comment|/* We don't have to check against the predicate for operand 0 since 	 TARGET is known to be a pseudo of the proper mode, which must 	 be valid for the operand.  For operand 1, convert to the 	 proper mode and validate.  */
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|mode
operator|=
name|insn_data
index|[
operator|(
name|int
operator|)
name|CODE_FOR_allocate_stack
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
expr_stmt|;
name|pred
operator|=
name|insn_data
index|[
operator|(
name|int
operator|)
name|CODE_FOR_allocate_stack
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
expr_stmt|;
if|if
condition|(
name|pred
operator|&&
operator|!
operator|(
call|(
modifier|*
name|pred
call|)
argument_list|(
name|size
argument_list|,
name|mode
argument_list|)
operator|)
condition|)
name|size
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_allocate_stack
argument_list|(
name|target
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
ifndef|#
directive|ifndef
name|STACK_GROWS_DOWNWARD
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|virtual_stack_dynamic_rtx
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Check stack bounds if necessary.  */
if|if
condition|(
name|current_function_limit_stack
condition|)
block|{
name|rtx
name|available
decl_stmt|;
name|rtx
name|space_available
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
ifdef|#
directive|ifdef
name|STACK_GROWS_DOWNWARD
name|available
operator|=
name|expand_binop
argument_list|(
name|Pmode
argument_list|,
name|sub_optab
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|stack_limit_rtx
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
else|#
directive|else
name|available
operator|=
name|expand_binop
argument_list|(
name|Pmode
argument_list|,
name|sub_optab
argument_list|,
name|stack_limit_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|emit_cmp_and_jump_insns
argument_list|(
name|available
argument_list|,
name|size
argument_list|,
name|GEU
argument_list|,
name|NULL_RTX
argument_list|,
name|Pmode
argument_list|,
literal|1
argument_list|,
name|space_available
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_trap
if|if
condition|(
name|HAVE_trap
condition|)
name|emit_insn
argument_list|(
name|gen_trap
argument_list|()
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|error
argument_list|(
literal|"stack limits not supported on this target"
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|space_available
argument_list|)
expr_stmt|;
block|}
name|anti_adjust_stack
argument_list|(
name|size
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SETJMP_VIA_SAVE_AREA
if|if
condition|(
name|setjmpless_size
operator|!=
name|NULL_RTX
condition|)
block|{
name|rtx
name|note_target
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
name|REG_NOTES
argument_list|(
name|note_target
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_SAVE_AREA
argument_list|,
name|setjmpless_size
argument_list|,
name|REG_NOTES
argument_list|(
name|note_target
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SETJMP_VIA_SAVE_AREA */
ifdef|#
directive|ifdef
name|STACK_GROWS_DOWNWARD
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|virtual_stack_dynamic_rtx
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|MUST_ALIGN
condition|)
block|{
comment|/* CEIL_DIV_EXPR needs to worry about the addition overflowing, 	 but we know it can't.  So add ourselves and then do 	 TRUNC_DIV_EXPR.  */
name|target
operator|=
name|expand_binop
argument_list|(
name|Pmode
argument_list|,
name|add_optab
argument_list|,
name|target
argument_list|,
name|GEN_INT
argument_list|(
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
operator|-
literal|1
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
name|target
operator|=
name|expand_divmod
argument_list|(
literal|0
argument_list|,
name|TRUNC_DIV_EXPR
argument_list|,
name|Pmode
argument_list|,
name|target
argument_list|,
name|GEN_INT
argument_list|(
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|target
operator|=
name|expand_mult
argument_list|(
name|Pmode
argument_list|,
name|target
argument_list|,
name|GEN_INT
argument_list|(
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Some systems require a particular insn to refer to the stack      to make the pages exist.  */
ifdef|#
directive|ifdef
name|HAVE_probe
if|if
condition|(
name|HAVE_probe
condition|)
name|emit_insn
argument_list|(
name|gen_probe
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Record the new stack level for nonlocal gotos.  */
if|if
condition|(
name|nonlocal_goto_handler_slots
operator|!=
literal|0
condition|)
name|emit_stack_save
argument_list|(
name|SAVE_NONLOCAL
argument_list|,
operator|&
name|nonlocal_goto_stack_level
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A front end may want to override GCC's stack checking by providing a     run-time routine to call to check the stack, so provide a mechanism for    calling that routine.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|stack_check_libfunc
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|set_stack_check_libfunc
parameter_list|(
name|libfunc
parameter_list|)
name|rtx
name|libfunc
decl_stmt|;
block|{
name|stack_check_libfunc
operator|=
name|libfunc
expr_stmt|;
name|ggc_add_rtx_root
argument_list|(
operator|&
name|stack_check_libfunc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit one stack probe at ADDRESS, an address within the stack.  */
end_comment

begin_function
specifier|static
name|void
name|emit_stack_probe
parameter_list|(
name|address
parameter_list|)
name|rtx
name|address
decl_stmt|;
block|{
name|rtx
name|memref
init|=
name|gen_rtx_MEM
argument_list|(
name|word_mode
argument_list|,
name|address
argument_list|)
decl_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|memref
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|STACK_CHECK_PROBE_LOAD
condition|)
name|emit_move_insn
argument_list|(
name|gen_reg_rtx
argument_list|(
name|word_mode
argument_list|)
argument_list|,
name|memref
argument_list|)
expr_stmt|;
else|else
name|emit_move_insn
argument_list|(
name|memref
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Probe a range of stack addresses from FIRST to FIRST+SIZE, inclusive.     FIRST is a constant and size is a Pmode RTX.  These are offsets from the    current stack pointer.  STACK_GROWS_DOWNWARD says whether to add or    subtract from the stack.  If SIZE is constant, this is done    with a fixed number of probes.  Otherwise, we must make a loop.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|STACK_GROWS_DOWNWARD
end_ifdef

begin_define
define|#
directive|define
name|STACK_GROW_OP
value|MINUS
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|STACK_GROW_OP
value|PLUS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|probe_stack_range
parameter_list|(
name|first
parameter_list|,
name|size
parameter_list|)
name|HOST_WIDE_INT
name|first
decl_stmt|;
name|rtx
name|size
decl_stmt|;
block|{
comment|/* First ensure SIZE is Pmode.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|size
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|size
argument_list|)
operator|!=
name|Pmode
condition|)
name|size
operator|=
name|convert_to_mode
argument_list|(
name|Pmode
argument_list|,
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Next see if the front end has set up a function for us to call to      check the stack.  */
if|if
condition|(
name|stack_check_libfunc
operator|!=
literal|0
condition|)
block|{
name|rtx
name|addr
init|=
name|memory_address
argument_list|(
name|QImode
argument_list|,
name|gen_rtx
argument_list|(
name|STACK_GROW_OP
argument_list|,
name|Pmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|plus_constant
argument_list|(
name|size
argument_list|,
name|first
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|POINTERS_EXTEND_UNSIGNED
if|if
condition|(
name|GET_MODE
argument_list|(
name|addr
argument_list|)
operator|!=
name|ptr_mode
condition|)
name|addr
operator|=
name|convert_memory_address
argument_list|(
name|ptr_mode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|emit_library_call
argument_list|(
name|stack_check_libfunc
argument_list|,
name|LCT_NORMAL
argument_list|,
name|VOIDmode
argument_list|,
literal|1
argument_list|,
name|addr
argument_list|,
name|ptr_mode
argument_list|)
expr_stmt|;
block|}
comment|/* Next see if we have an insn to check the stack.  Use it if so.  */
ifdef|#
directive|ifdef
name|HAVE_check_stack
elseif|else
if|if
condition|(
name|HAVE_check_stack
condition|)
block|{
name|insn_operand_predicate_fn
name|pred
decl_stmt|;
name|rtx
name|last_addr
init|=
name|force_operand
argument_list|(
name|gen_rtx_STACK_GROW_OP
argument_list|(
name|Pmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|plus_constant
argument_list|(
name|size
argument_list|,
name|first
argument_list|)
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
name|pred
operator|=
name|insn_data
index|[
operator|(
name|int
operator|)
name|CODE_FOR_check_stack
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
expr_stmt|;
if|if
condition|(
name|pred
operator|&&
operator|!
operator|(
call|(
modifier|*
name|pred
call|)
argument_list|(
name|last_addr
argument_list|,
name|Pmode
argument_list|)
operator|)
condition|)
name|last_addr
operator|=
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|last_addr
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_check_stack
argument_list|(
name|last_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* If we have to generate explicit probes, see if we have a constant      small number of them to generate.  If so, that's the easy case.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|size
argument_list|)
operator|<
literal|10
operator|*
name|STACK_CHECK_PROBE_INTERVAL
condition|)
block|{
name|HOST_WIDE_INT
name|offset
decl_stmt|;
comment|/* Start probing at FIRST + N * STACK_CHECK_PROBE_INTERVAL 	 for values of N from 1 until it exceeds LAST.  If only one 	 probe is needed, this will not generate any code.  Then probe 	 at LAST.  */
for|for
control|(
name|offset
operator|=
name|first
operator|+
name|STACK_CHECK_PROBE_INTERVAL
init|;
name|offset
operator|<
name|INTVAL
argument_list|(
name|size
argument_list|)
condition|;
name|offset
operator|=
name|offset
operator|+
name|STACK_CHECK_PROBE_INTERVAL
control|)
name|emit_stack_probe
argument_list|(
name|gen_rtx_fmt_ee
argument_list|(
name|STACK_GROW_OP
argument_list|,
name|Pmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|offset
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_stack_probe
argument_list|(
name|gen_rtx_fmt_ee
argument_list|(
name|STACK_GROW_OP
argument_list|,
name|Pmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|plus_constant
argument_list|(
name|size
argument_list|,
name|first
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* In the variable case, do the same as above, but in a loop.  We emit loop      notes so that loop optimization can be done.  */
else|else
block|{
name|rtx
name|test_addr
init|=
name|force_operand
argument_list|(
name|gen_rtx_fmt_ee
argument_list|(
name|STACK_GROW_OP
argument_list|,
name|Pmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|first
operator|+
name|STACK_CHECK_PROBE_INTERVAL
argument_list|)
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
name|rtx
name|last_addr
init|=
name|force_operand
argument_list|(
name|gen_rtx_fmt_ee
argument_list|(
name|STACK_GROW_OP
argument_list|,
name|Pmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|plus_constant
argument_list|(
name|size
argument_list|,
name|first
argument_list|)
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
name|rtx
name|incr
init|=
name|GEN_INT
argument_list|(
name|STACK_CHECK_PROBE_INTERVAL
argument_list|)
decl_stmt|;
name|rtx
name|loop_lab
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|rtx
name|test_lab
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|rtx
name|end_lab
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|test_addr
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|test_addr
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|test_addr
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|test_addr
argument_list|)
expr_stmt|;
name|emit_note
argument_list|(
name|NULL
argument_list|,
name|NOTE_INSN_LOOP_BEG
argument_list|)
expr_stmt|;
name|emit_jump
argument_list|(
name|test_lab
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|loop_lab
argument_list|)
expr_stmt|;
name|emit_stack_probe
argument_list|(
name|test_addr
argument_list|)
expr_stmt|;
name|emit_note
argument_list|(
name|NULL
argument_list|,
name|NOTE_INSN_LOOP_CONT
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|STACK_GROWS_DOWNWARD
define|#
directive|define
name|CMP_OPCODE
value|GTU
name|temp
operator|=
name|expand_binop
argument_list|(
name|Pmode
argument_list|,
name|sub_optab
argument_list|,
name|test_addr
argument_list|,
name|incr
argument_list|,
name|test_addr
argument_list|,
literal|1
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
else|#
directive|else
define|#
directive|define
name|CMP_OPCODE
value|LTU
name|temp
operator|=
name|expand_binop
argument_list|(
name|Pmode
argument_list|,
name|add_optab
argument_list|,
name|test_addr
argument_list|,
name|incr
argument_list|,
name|test_addr
argument_list|,
literal|1
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|temp
operator|!=
name|test_addr
condition|)
name|abort
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|test_lab
argument_list|)
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|test_addr
argument_list|,
name|last_addr
argument_list|,
name|CMP_OPCODE
argument_list|,
name|NULL_RTX
argument_list|,
name|Pmode
argument_list|,
literal|1
argument_list|,
name|loop_lab
argument_list|)
expr_stmt|;
name|emit_jump
argument_list|(
name|end_lab
argument_list|)
expr_stmt|;
name|emit_note
argument_list|(
name|NULL
argument_list|,
name|NOTE_INSN_LOOP_END
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|end_lab
argument_list|)
expr_stmt|;
name|emit_stack_probe
argument_list|(
name|last_addr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return an rtx representing the register or memory location    in which a scalar value of data type VALTYPE    was returned by a function call to function FUNC.    FUNC is a FUNCTION_DECL node if the precise function is known,    otherwise 0.    OUTGOING is 1 if on a machine with register windows this function    should return the register in which the function will put its result    and 0 otherwise.  */
end_comment

begin_function
name|rtx
name|hard_function_value
parameter_list|(
name|valtype
parameter_list|,
name|func
parameter_list|,
name|outgoing
parameter_list|)
name|tree
name|valtype
decl_stmt|;
name|tree
name|func
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|outgoing
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|rtx
name|val
decl_stmt|;
ifdef|#
directive|ifdef
name|FUNCTION_OUTGOING_VALUE
if|if
condition|(
name|outgoing
condition|)
name|val
operator|=
name|FUNCTION_OUTGOING_VALUE
argument_list|(
name|valtype
argument_list|,
name|func
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|val
operator|=
name|FUNCTION_VALUE
argument_list|(
name|valtype
argument_list|,
name|func
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|REG
operator|&&
name|GET_MODE
argument_list|(
name|val
argument_list|)
operator|==
name|BLKmode
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|bytes
init|=
name|int_size_in_bytes
argument_list|(
name|valtype
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|tmpmode
decl_stmt|;
for|for
control|(
name|tmpmode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_INT
argument_list|)
init|;
name|tmpmode
operator|!=
name|VOIDmode
condition|;
name|tmpmode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|tmpmode
argument_list|)
control|)
block|{
comment|/* Have we found a large enough mode?  */
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|tmpmode
argument_list|)
operator|>=
name|bytes
condition|)
break|break;
block|}
comment|/* No suitable mode found.  */
if|if
condition|(
name|tmpmode
operator|==
name|VOIDmode
condition|)
name|abort
argument_list|()
expr_stmt|;
name|PUT_MODE
argument_list|(
name|val
argument_list|,
name|tmpmode
argument_list|)
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Return an rtx representing the register or memory location    in which a scalar value of mode MODE was returned by a library call.  */
end_comment

begin_function
name|rtx
name|hard_libcall_value
parameter_list|(
name|mode
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
name|LIBCALL_VALUE
argument_list|(
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Look up the tree code for a given rtx code    to provide the arithmetic operation for REAL_ARITHMETIC.    The function returns an int because the caller may not know    what `enum tree_code' means.  */
end_comment

begin_function
name|int
name|rtx_to_tree_code
parameter_list|(
name|code
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
block|{
name|enum
name|tree_code
name|tcode
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PLUS
case|:
name|tcode
operator|=
name|PLUS_EXPR
expr_stmt|;
break|break;
case|case
name|MINUS
case|:
name|tcode
operator|=
name|MINUS_EXPR
expr_stmt|;
break|break;
case|case
name|MULT
case|:
name|tcode
operator|=
name|MULT_EXPR
expr_stmt|;
break|break;
case|case
name|DIV
case|:
name|tcode
operator|=
name|RDIV_EXPR
expr_stmt|;
break|break;
case|case
name|SMIN
case|:
name|tcode
operator|=
name|MIN_EXPR
expr_stmt|;
break|break;
case|case
name|SMAX
case|:
name|tcode
operator|=
name|MAX_EXPR
expr_stmt|;
break|break;
default|default:
name|tcode
operator|=
name|LAST_AND_UNUSED_TREE_CODE
expr_stmt|;
break|break;
block|}
return|return
operator|(
operator|(
name|int
operator|)
name|tcode
operator|)
return|;
block|}
end_function

end_unit

