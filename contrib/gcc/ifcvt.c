begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* If-conversion support.    Copyright (C) 2000, 2001 Free Software Foundation, Inc.     This file is part of GCC.     GCC is free software; you can redistribute it and/or modify it    under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GCC is distributed in the hope that it will be useful, but WITHOUT    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public    License for more details.     You should have received a copy of the GNU General Public License    along with GCC; see the file COPYING.  If not, write to the Free    Software Foundation, 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_conditional_execution
end_ifndef

begin_define
define|#
directive|define
name|HAVE_conditional_execution
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_conditional_move
end_ifndef

begin_define
define|#
directive|define
name|HAVE_conditional_move
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_incscc
end_ifndef

begin_define
define|#
directive|define
name|HAVE_incscc
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_decscc
end_ifndef

begin_define
define|#
directive|define
name|HAVE_decscc
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_trap
end_ifndef

begin_define
define|#
directive|define
name|HAVE_trap
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_conditional_trap
end_ifndef

begin_define
define|#
directive|define
name|HAVE_conditional_trap
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MAX_CONDITIONAL_EXECUTE
end_ifndef

begin_define
define|#
directive|define
name|MAX_CONDITIONAL_EXECUTE
value|(BRANCH_COST + 1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|NULL_EDGE
value|((struct edge_def *)NULL)
end_define

begin_define
define|#
directive|define
name|NULL_BLOCK
value|((struct basic_block_def *)NULL)
end_define

begin_comment
comment|/* # of IF-THEN or IF-THEN-ELSE blocks we looked at  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|num_possible_if_blocks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # of IF-THEN or IF-THEN-ELSE blocks were converted to conditional    execution.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|num_updated_if_blocks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # of basic blocks that were removed.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|num_removed_blocks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True if life data ok at present.  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|life_data_ok
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The post-dominator relation on the original block numbers.  */
end_comment

begin_decl_stmt
specifier|static
name|sbitmap
modifier|*
name|post_dominators
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward references.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|count_bb_insns
name|PARAMS
argument_list|(
operator|(
name|basic_block
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|first_active_insn
name|PARAMS
argument_list|(
operator|(
name|basic_block
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|last_active_insn_p
name|PARAMS
argument_list|(
operator|(
name|basic_block
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|seq_contains_jump
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cond_exec_process_insns
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|cond_exec_get_condition
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cond_exec_process_if_block
name|PARAMS
argument_list|(
operator|(
name|basic_block
operator|,
name|basic_block
operator|,
name|basic_block
operator|,
name|basic_block
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|noce_get_condition
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|noce_operand_ok
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|noce_process_if_block
name|PARAMS
argument_list|(
operator|(
name|basic_block
operator|,
name|basic_block
operator|,
name|basic_block
operator|,
name|basic_block
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|process_if_block
name|PARAMS
argument_list|(
operator|(
name|basic_block
operator|,
name|basic_block
operator|,
name|basic_block
operator|,
name|basic_block
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|merge_if_block
name|PARAMS
argument_list|(
operator|(
name|basic_block
operator|,
name|basic_block
operator|,
name|basic_block
operator|,
name|basic_block
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|find_if_header
name|PARAMS
argument_list|(
operator|(
name|basic_block
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|find_if_block
name|PARAMS
argument_list|(
operator|(
name|basic_block
operator|,
name|edge
operator|,
name|edge
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|find_if_case_1
name|PARAMS
argument_list|(
operator|(
name|basic_block
operator|,
name|edge
operator|,
name|edge
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|find_if_case_2
name|PARAMS
argument_list|(
operator|(
name|basic_block
operator|,
name|edge
operator|,
name|edge
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|find_cond_trap
name|PARAMS
argument_list|(
operator|(
name|basic_block
operator|,
name|edge
operator|,
name|edge
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|find_memory
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dead_or_predicable
name|PARAMS
argument_list|(
operator|(
name|basic_block
operator|,
name|basic_block
operator|,
name|basic_block
operator|,
name|basic_block
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|noce_emit_move_insn
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Abuse the basic_block AUX field to store the original block index,    as well as a flag indicating that the block should be rescaned for    life analysis.  */
end_comment

begin_define
define|#
directive|define
name|SET_ORIG_INDEX
parameter_list|(
name|BB
parameter_list|,
name|I
parameter_list|)
value|((BB)->aux = (void *)((size_t)(I)<< 1))
end_define

begin_define
define|#
directive|define
name|ORIG_INDEX
parameter_list|(
name|BB
parameter_list|)
value|((size_t)(BB)->aux>> 1)
end_define

begin_define
define|#
directive|define
name|SET_UPDATE_LIFE
parameter_list|(
name|BB
parameter_list|)
value|((BB)->aux = (void *)((size_t)(BB)->aux | 1))
end_define

begin_define
define|#
directive|define
name|UPDATE_LIFE
parameter_list|(
name|BB
parameter_list|)
value|((size_t)(BB)->aux& 1)
end_define

begin_escape
end_escape

begin_comment
comment|/* Count the number of non-jump active insns in BB.  */
end_comment

begin_function
specifier|static
name|int
name|count_bb_insns
parameter_list|(
name|bb
parameter_list|)
name|basic_block
name|bb
decl_stmt|;
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
name|rtx
name|insn
init|=
name|bb
operator|->
name|head
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
condition|)
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|bb
operator|->
name|end
condition|)
break|break;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/* Return the first non-jump active insn in the basic block.  */
end_comment

begin_function
specifier|static
name|rtx
name|first_active_insn
parameter_list|(
name|bb
parameter_list|)
name|basic_block
name|bb
decl_stmt|;
block|{
name|rtx
name|insn
init|=
name|bb
operator|->
name|head
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
block|{
if|if
condition|(
name|insn
operator|==
name|bb
operator|->
name|end
condition|)
return|return
name|NULL_RTX
return|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
block|{
if|if
condition|(
name|insn
operator|==
name|bb
operator|->
name|end
condition|)
return|return
name|NULL_RTX
return|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
return|return
name|NULL_RTX
return|;
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Return true if INSN is the last active non-jump insn in BB.  */
end_comment

begin_function
specifier|static
name|int
name|last_active_insn_p
parameter_list|(
name|bb
parameter_list|,
name|insn
parameter_list|)
name|basic_block
name|bb
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
do|do
block|{
if|if
condition|(
name|insn
operator|==
name|bb
operator|->
name|end
condition|)
return|return
name|TRUE
return|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
do|;
return|return
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
return|;
block|}
end_function

begin_comment
comment|/* It is possible, especially when having dealt with multi-word     arithmetic, for the expanders to have emitted jumps.  Search    through the sequence and return TRUE if a jump exists so that    we can abort the conversion.  */
end_comment

begin_function
specifier|static
name|int
name|seq_contains_jump
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
while|while
condition|(
name|insn
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
return|return
literal|1
return|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Go through a bunch of insns, converting them to conditional    execution format if possible.  Return TRUE if all of the non-note    insns were processed.  */
end_comment

begin_function
specifier|static
name|int
name|cond_exec_process_insns
parameter_list|(
name|start
parameter_list|,
name|end
parameter_list|,
name|test
parameter_list|,
name|prob_val
parameter_list|,
name|mod_ok
parameter_list|)
name|rtx
name|start
decl_stmt|;
comment|/* first insn to look at */
name|rtx
name|end
decl_stmt|;
comment|/* last insn to look at */
name|rtx
name|test
decl_stmt|;
comment|/* conditional execution test */
name|rtx
name|prob_val
decl_stmt|;
comment|/* probability of branch taken.  */
name|int
name|mod_ok
decl_stmt|;
comment|/* true if modifications ok last insn.  */
block|{
name|int
name|must_be_last
init|=
name|FALSE
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|rtx
name|pattern
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|start
init|;
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
goto|goto
name|insn_done
goto|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|CALL_INSN
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Remove USE insns that get in the way.  */
if|if
condition|(
name|reload_completed
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|USE
condition|)
block|{
comment|/* ??? Ug.  Actually unlinking the thing is problematic,  	     given what we'd have to coordinate with our callers.  */
name|PUT_CODE
argument_list|(
name|insn
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
goto|goto
name|insn_done
goto|;
block|}
comment|/* Last insn wasn't last?  */
if|if
condition|(
name|must_be_last
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|modified_in_p
argument_list|(
name|test
argument_list|,
name|insn
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|mod_ok
condition|)
return|return
name|FALSE
return|;
name|must_be_last
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* Now build the conditional form of the instruction.  */
name|pattern
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* If the machine needs to modify the insn being conditionally executed,          say for example to force a constant integer operand into a temp          register, do so here.  */
ifdef|#
directive|ifdef
name|IFCVT_MODIFY_INSN
name|IFCVT_MODIFY_INSN
argument_list|(
name|pattern
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pattern
condition|)
return|return
name|FALSE
return|;
endif|#
directive|endif
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|gen_rtx_COND_EXEC
argument_list|(
name|VOIDmode
argument_list|,
name|copy_rtx
argument_list|(
name|test
argument_list|)
argument_list|,
name|pattern
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|&&
name|prob_val
condition|)
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|,
name|alloc_EXPR_LIST
argument_list|(
name|REG_BR_PROB
argument_list|,
name|prob_val
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|insn_done
label|:
if|if
condition|(
name|insn
operator|==
name|end
condition|)
break|break;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Return the condition for a jump.  Do not do any special processing.  */
end_comment

begin_function
specifier|static
name|rtx
name|cond_exec_get_condition
parameter_list|(
name|jump
parameter_list|)
name|rtx
name|jump
decl_stmt|;
block|{
name|rtx
name|test_if
decl_stmt|,
name|cond
decl_stmt|;
if|if
condition|(
name|any_condjump_p
argument_list|(
name|jump
argument_list|)
condition|)
name|test_if
operator|=
name|SET_SRC
argument_list|(
name|pc_set
argument_list|(
name|jump
argument_list|)
argument_list|)
expr_stmt|;
else|else
return|return
name|NULL_RTX
return|;
name|cond
operator|=
name|XEXP
argument_list|(
name|test_if
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If this branches to JUMP_LABEL when the condition is false,      reverse the condition.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|test_if
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|test_if
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|JUMP_LABEL
argument_list|(
name|jump
argument_list|)
condition|)
block|{
name|enum
name|rtx_code
name|rev
init|=
name|reversed_comparison_code
argument_list|(
name|cond
argument_list|,
name|jump
argument_list|)
decl_stmt|;
if|if
condition|(
name|rev
operator|==
name|UNKNOWN
condition|)
return|return
name|NULL_RTX
return|;
name|cond
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|rev
argument_list|,
name|GET_MODE
argument_list|(
name|cond
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|cond
return|;
block|}
end_function

begin_comment
comment|/* Given a simple IF-THEN or IF-THEN-ELSE block, attempt to convert it    to conditional execution.  Return TRUE if we were successful at    converting the the block.  */
end_comment

begin_function
specifier|static
name|int
name|cond_exec_process_if_block
parameter_list|(
name|test_bb
parameter_list|,
name|then_bb
parameter_list|,
name|else_bb
parameter_list|,
name|join_bb
parameter_list|)
name|basic_block
name|test_bb
decl_stmt|;
comment|/* Basic block test is in */
name|basic_block
name|then_bb
decl_stmt|;
comment|/* Basic block for THEN block */
name|basic_block
name|else_bb
decl_stmt|;
comment|/* Basic block for ELSE block */
name|basic_block
name|join_bb
decl_stmt|;
comment|/* Basic block the join label is in */
block|{
name|rtx
name|test_expr
decl_stmt|;
comment|/* expression in IF_THEN_ELSE that is tested */
name|rtx
name|then_start
decl_stmt|;
comment|/* first insn in THEN block */
name|rtx
name|then_end
decl_stmt|;
comment|/* last insn + 1 in THEN block */
name|rtx
name|else_start
init|=
name|NULL_RTX
decl_stmt|;
comment|/* first insn in ELSE block or NULL */
name|rtx
name|else_end
init|=
name|NULL_RTX
decl_stmt|;
comment|/* last insn + 1 in ELSE block */
name|int
name|max
decl_stmt|;
comment|/* max # of insns to convert.  */
name|int
name|then_mod_ok
decl_stmt|;
comment|/* whether conditional mods are ok in THEN */
name|rtx
name|true_expr
decl_stmt|;
comment|/* test for else block insns */
name|rtx
name|false_expr
decl_stmt|;
comment|/* test for then block insns */
name|rtx
name|true_prob_val
decl_stmt|;
comment|/* probability of else block */
name|rtx
name|false_prob_val
decl_stmt|;
comment|/* probability of then block */
name|int
name|n_insns
decl_stmt|;
name|enum
name|rtx_code
name|false_code
decl_stmt|;
comment|/* Find the conditional jump to the ELSE or JOIN part, and isolate      the test.  */
name|test_expr
operator|=
name|cond_exec_get_condition
argument_list|(
name|test_bb
operator|->
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|test_expr
condition|)
return|return
name|FALSE
return|;
comment|/* If the conditional jump is more than just a conditional jump,      then we can not do conditional execution conversion on this block.  */
if|if
condition|(
operator|!
name|onlyjump_p
argument_list|(
name|test_bb
operator|->
name|end
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Collect the bounds of where we're to search.  */
name|then_start
operator|=
name|then_bb
operator|->
name|head
expr_stmt|;
name|then_end
operator|=
name|then_bb
operator|->
name|end
expr_stmt|;
comment|/* Skip a label heading THEN block.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|then_start
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|then_start
operator|=
name|NEXT_INSN
argument_list|(
name|then_start
argument_list|)
expr_stmt|;
comment|/* Skip a (use (const_int 0)) or branch as the final insn.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|then_end
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|then_end
argument_list|)
argument_list|)
operator|==
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|then_end
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
name|then_end
operator|=
name|PREV_INSN
argument_list|(
name|then_end
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|then_end
argument_list|)
operator|==
name|JUMP_INSN
condition|)
name|then_end
operator|=
name|PREV_INSN
argument_list|(
name|then_end
argument_list|)
expr_stmt|;
if|if
condition|(
name|else_bb
condition|)
block|{
comment|/* Skip the ELSE block's label.  */
name|else_start
operator|=
name|NEXT_INSN
argument_list|(
name|else_bb
operator|->
name|head
argument_list|)
expr_stmt|;
name|else_end
operator|=
name|else_bb
operator|->
name|end
expr_stmt|;
comment|/* Skip a (use (const_int 0)) or branch as the final insn.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|else_end
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|else_end
argument_list|)
argument_list|)
operator|==
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|else_end
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
name|else_end
operator|=
name|PREV_INSN
argument_list|(
name|else_end
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|else_end
argument_list|)
operator|==
name|JUMP_INSN
condition|)
name|else_end
operator|=
name|PREV_INSN
argument_list|(
name|else_end
argument_list|)
expr_stmt|;
block|}
comment|/* How many instructions should we convert in total?  */
name|n_insns
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|else_bb
condition|)
block|{
name|max
operator|=
literal|2
operator|*
name|MAX_CONDITIONAL_EXECUTE
expr_stmt|;
name|n_insns
operator|=
name|count_bb_insns
argument_list|(
name|else_bb
argument_list|)
expr_stmt|;
block|}
else|else
name|max
operator|=
name|MAX_CONDITIONAL_EXECUTE
expr_stmt|;
name|n_insns
operator|+=
name|count_bb_insns
argument_list|(
name|then_bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_insns
operator|>
name|max
condition|)
return|return
name|FALSE
return|;
comment|/* Map test_expr/test_jump into the appropriate MD tests to use on      the conditionally executed code.  */
name|true_expr
operator|=
name|test_expr
expr_stmt|;
name|false_code
operator|=
name|reversed_comparison_code
argument_list|(
name|true_expr
argument_list|,
name|test_bb
operator|->
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|false_code
operator|!=
name|UNKNOWN
condition|)
name|false_expr
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|false_code
argument_list|,
name|GET_MODE
argument_list|(
name|true_expr
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|true_expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|true_expr
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|false_expr
operator|=
name|NULL_RTX
expr_stmt|;
ifdef|#
directive|ifdef
name|IFCVT_MODIFY_TESTS
comment|/* If the machine description needs to modify the tests, such as setting a      conditional execution register from a comparison, it can do so here.  */
name|IFCVT_MODIFY_TESTS
argument_list|(
name|true_expr
argument_list|,
name|false_expr
argument_list|,
name|test_bb
argument_list|,
name|then_bb
argument_list|,
name|else_bb
argument_list|,
name|join_bb
argument_list|)
expr_stmt|;
comment|/* See if the conversion failed */
if|if
condition|(
operator|!
name|true_expr
operator|||
operator|!
name|false_expr
condition|)
goto|goto
name|fail
goto|;
endif|#
directive|endif
name|true_prob_val
operator|=
name|find_reg_note
argument_list|(
name|test_bb
operator|->
name|end
argument_list|,
name|REG_BR_PROB
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|true_prob_val
condition|)
block|{
name|true_prob_val
operator|=
name|XEXP
argument_list|(
name|true_prob_val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|false_prob_val
operator|=
name|GEN_INT
argument_list|(
name|REG_BR_PROB_BASE
operator|-
name|INTVAL
argument_list|(
name|true_prob_val
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|false_prob_val
operator|=
name|NULL_RTX
expr_stmt|;
comment|/* For IF-THEN-ELSE blocks, we don't allow modifications of the test      on then THEN block.  */
name|then_mod_ok
operator|=
operator|(
name|else_bb
operator|==
name|NULL_BLOCK
operator|)
expr_stmt|;
comment|/* Go through the THEN and ELSE blocks converting the insns if possible      to conditional execution.  */
if|if
condition|(
name|then_end
operator|&&
operator|(
operator|!
name|false_expr
operator|||
operator|!
name|cond_exec_process_insns
argument_list|(
name|then_start
argument_list|,
name|then_end
argument_list|,
name|false_expr
argument_list|,
name|false_prob_val
argument_list|,
name|then_mod_ok
argument_list|)
operator|)
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|else_bb
operator|&&
operator|!
name|cond_exec_process_insns
argument_list|(
name|else_start
argument_list|,
name|else_end
argument_list|,
name|true_expr
argument_list|,
name|true_prob_val
argument_list|,
name|TRUE
argument_list|)
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
operator|!
name|apply_change_group
argument_list|()
condition|)
return|return
name|FALSE
return|;
ifdef|#
directive|ifdef
name|IFCVT_MODIFY_FINAL
comment|/* Do any machine dependent final modifications */
name|IFCVT_MODIFY_FINAL
argument_list|(
name|test_bb
argument_list|,
name|then_bb
argument_list|,
name|else_bb
argument_list|,
name|join_bb
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Conversion succeeded.  */
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"%d insn%s converted to conditional execution.\n"
argument_list|,
name|n_insns
argument_list|,
operator|(
name|n_insns
operator|==
literal|1
operator|)
condition|?
literal|" was"
else|:
literal|"s were"
argument_list|)
expr_stmt|;
comment|/* Merge the blocks!  */
name|merge_if_block
argument_list|(
name|test_bb
argument_list|,
name|then_bb
argument_list|,
name|else_bb
argument_list|,
name|join_bb
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
name|fail
label|:
ifdef|#
directive|ifdef
name|IFCVT_MODIFY_CANCEL
comment|/* Cancel any machine dependent changes.  */
name|IFCVT_MODIFY_CANCEL
argument_list|(
name|test_bb
argument_list|,
name|then_bb
argument_list|,
name|else_bb
argument_list|,
name|join_bb
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cancel_changes
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Used by noce_process_if_block to communicate with its subroutines.      The subroutines know that A and B may be evaluated freely.  They    know that X is a register.  They should insert new instructions     before cond_earliest.  */
end_comment

begin_struct
struct|struct
name|noce_if_info
block|{
name|basic_block
name|test_bb
decl_stmt|;
name|rtx
name|insn_a
decl_stmt|,
name|insn_b
decl_stmt|;
name|rtx
name|x
decl_stmt|,
name|a
decl_stmt|,
name|b
decl_stmt|;
name|rtx
name|jump
decl_stmt|,
name|cond
decl_stmt|,
name|cond_earliest
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|rtx
name|noce_emit_store_flag
name|PARAMS
argument_list|(
operator|(
expr|struct
name|noce_if_info
operator|*
operator|,
name|rtx
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|noce_try_store_flag
name|PARAMS
argument_list|(
operator|(
expr|struct
name|noce_if_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|noce_try_store_flag_inc
name|PARAMS
argument_list|(
operator|(
expr|struct
name|noce_if_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|noce_try_store_flag_constants
name|PARAMS
argument_list|(
operator|(
expr|struct
name|noce_if_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|noce_try_store_flag_mask
name|PARAMS
argument_list|(
operator|(
expr|struct
name|noce_if_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|noce_emit_cmove
name|PARAMS
argument_list|(
operator|(
expr|struct
name|noce_if_info
operator|*
operator|,
name|rtx
operator|,
expr|enum
name|rtx_code
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|noce_try_cmove
name|PARAMS
argument_list|(
operator|(
expr|struct
name|noce_if_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|noce_try_cmove_arith
name|PARAMS
argument_list|(
operator|(
expr|struct
name|noce_if_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|noce_get_alt_condition
name|PARAMS
argument_list|(
operator|(
expr|struct
name|noce_if_info
operator|*
operator|,
name|rtx
operator|,
name|rtx
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|noce_try_minmax
name|PARAMS
argument_list|(
operator|(
expr|struct
name|noce_if_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|noce_try_abs
name|PARAMS
argument_list|(
operator|(
expr|struct
name|noce_if_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Helper function for noce_try_store_flag*.  */
end_comment

begin_function
specifier|static
name|rtx
name|noce_emit_store_flag
parameter_list|(
name|if_info
parameter_list|,
name|x
parameter_list|,
name|reversep
parameter_list|,
name|normalize
parameter_list|)
name|struct
name|noce_if_info
modifier|*
name|if_info
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|int
name|reversep
decl_stmt|,
name|normalize
decl_stmt|;
block|{
name|rtx
name|cond
init|=
name|if_info
operator|->
name|cond
decl_stmt|;
name|int
name|cond_complex
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
name|cond_complex
operator|=
operator|(
operator|!
name|general_operand
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|,
name|VOIDmode
argument_list|)
operator|||
operator|!
name|general_operand
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|,
name|VOIDmode
argument_list|)
operator|)
expr_stmt|;
comment|/* If earliest == jump, or when the condition is complex, try to      build the store_flag insn directly.  */
if|if
condition|(
name|cond_complex
condition|)
name|cond
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|pc_set
argument_list|(
name|if_info
operator|->
name|jump
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|reversep
condition|)
name|code
operator|=
name|reversed_comparison_code
argument_list|(
name|cond
argument_list|,
name|if_info
operator|->
name|jump
argument_list|)
expr_stmt|;
else|else
name|code
operator|=
name|GET_CODE
argument_list|(
name|cond
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|if_info
operator|->
name|cond_earliest
operator|==
name|if_info
operator|->
name|jump
operator|||
name|cond_complex
operator|)
operator|&&
operator|(
name|normalize
operator|==
literal|0
operator|||
name|STORE_FLAG_VALUE
operator|==
name|normalize
operator|)
condition|)
block|{
name|rtx
name|tmp
decl_stmt|;
name|tmp
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|x
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|tmp
operator|=
name|emit_insn
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|recog_memoized
argument_list|(
name|tmp
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|tmp
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insns
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|if_info
operator|->
name|cond_earliest
operator|=
name|if_info
operator|->
name|jump
expr_stmt|;
return|return
name|x
return|;
block|}
name|end_sequence
argument_list|()
expr_stmt|;
block|}
comment|/* Don't even try if the comparison operands are weird.  */
if|if
condition|(
name|cond_complex
condition|)
return|return
name|NULL_RTX
return|;
return|return
name|emit_store_flag
argument_list|(
name|x
argument_list|,
name|code
argument_list|,
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|,
name|VOIDmode
argument_list|,
operator|(
name|code
operator|==
name|LTU
operator|||
name|code
operator|==
name|LEU
operator|||
name|code
operator|==
name|GEU
operator|||
name|code
operator|==
name|GTU
operator|)
argument_list|,
name|normalize
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Emit instruction to move an rtx into STRICT_LOW_PART.  */
end_comment

begin_function
specifier|static
name|void
name|noce_emit_move_insn
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
name|enum
name|machine_mode
name|outmode
decl_stmt|,
name|inmode
decl_stmt|;
name|rtx
name|outer
decl_stmt|,
name|inner
decl_stmt|;
name|int
name|bitpos
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|STRICT_LOW_PART
condition|)
block|{
name|emit_move_insn
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
return|return;
block|}
name|outer
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|inner
operator|=
name|XEXP
argument_list|(
name|outer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outmode
operator|=
name|GET_MODE
argument_list|(
name|outer
argument_list|)
expr_stmt|;
name|inmode
operator|=
name|GET_MODE
argument_list|(
name|inner
argument_list|)
expr_stmt|;
name|bitpos
operator|=
name|SUBREG_BYTE
argument_list|(
name|outer
argument_list|)
operator|*
name|BITS_PER_UNIT
expr_stmt|;
name|store_bit_field
argument_list|(
name|inner
argument_list|,
name|GET_MODE_BITSIZE
argument_list|(
name|outmode
argument_list|)
argument_list|,
name|bitpos
argument_list|,
name|outmode
argument_list|,
name|y
argument_list|,
name|GET_MODE_BITSIZE
argument_list|(
name|inmode
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Convert "if (test) x = 1; else x = 0".     Only try 0 and STORE_FLAG_VALUE here.  Other combinations will be    tried in noce_try_store_flag_constants after noce_try_cmove has had    a go at the conversion.  */
end_comment

begin_function
specifier|static
name|int
name|noce_try_store_flag
parameter_list|(
name|if_info
parameter_list|)
name|struct
name|noce_if_info
modifier|*
name|if_info
decl_stmt|;
block|{
name|int
name|reversep
decl_stmt|;
name|rtx
name|target
decl_stmt|,
name|seq
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|if_info
operator|->
name|b
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|if_info
operator|->
name|b
argument_list|)
operator|==
name|STORE_FLAG_VALUE
operator|&&
name|if_info
operator|->
name|a
operator|==
name|const0_rtx
condition|)
name|reversep
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|if_info
operator|->
name|b
operator|==
name|const0_rtx
operator|&&
name|GET_CODE
argument_list|(
name|if_info
operator|->
name|a
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|if_info
operator|->
name|a
argument_list|)
operator|==
name|STORE_FLAG_VALUE
operator|&&
operator|(
name|reversed_comparison_code
argument_list|(
name|if_info
operator|->
name|cond
argument_list|,
name|if_info
operator|->
name|jump
argument_list|)
operator|!=
name|UNKNOWN
operator|)
condition|)
name|reversep
operator|=
literal|1
expr_stmt|;
else|else
return|return
name|FALSE
return|;
name|start_sequence
argument_list|()
expr_stmt|;
name|target
operator|=
name|noce_emit_store_flag
argument_list|(
name|if_info
argument_list|,
name|if_info
operator|->
name|x
argument_list|,
name|reversep
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
block|{
if|if
condition|(
name|target
operator|!=
name|if_info
operator|->
name|x
condition|)
name|noce_emit_move_insn
argument_list|(
name|if_info
operator|->
name|x
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insns_before
argument_list|(
name|seq
argument_list|,
name|if_info
operator|->
name|cond_earliest
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
else|else
block|{
name|end_sequence
argument_list|()
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
end_function

begin_comment
comment|/* Convert "if (test) x = a; else x = b", for A and B constant.  */
end_comment

begin_function
specifier|static
name|int
name|noce_try_store_flag_constants
parameter_list|(
name|if_info
parameter_list|)
name|struct
name|noce_if_info
modifier|*
name|if_info
decl_stmt|;
block|{
name|rtx
name|target
decl_stmt|,
name|seq
decl_stmt|;
name|int
name|reversep
decl_stmt|;
name|HOST_WIDE_INT
name|itrue
decl_stmt|,
name|ifalse
decl_stmt|,
name|diff
decl_stmt|,
name|tmp
decl_stmt|;
name|int
name|normalize
decl_stmt|,
name|can_reverse
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
if|if
condition|(
operator|!
name|no_new_pseudos
operator|&&
name|GET_CODE
argument_list|(
name|if_info
operator|->
name|a
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|if_info
operator|->
name|b
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|mode
operator|=
name|GET_MODE
argument_list|(
name|if_info
operator|->
name|x
argument_list|)
expr_stmt|;
name|ifalse
operator|=
name|INTVAL
argument_list|(
name|if_info
operator|->
name|a
argument_list|)
expr_stmt|;
name|itrue
operator|=
name|INTVAL
argument_list|(
name|if_info
operator|->
name|b
argument_list|)
expr_stmt|;
comment|/* Make sure we can represent the difference between the two values.  */
if|if
condition|(
operator|(
name|itrue
operator|-
name|ifalse
operator|>
literal|0
operator|)
operator|!=
operator|(
operator|(
name|ifalse
operator|<
literal|0
operator|)
operator|!=
operator|(
name|itrue
operator|<
literal|0
operator|)
condition|?
name|ifalse
operator|<
literal|0
else|:
name|ifalse
operator|<
name|itrue
operator|)
condition|)
return|return
name|FALSE
return|;
name|diff
operator|=
name|trunc_int_for_mode
argument_list|(
name|itrue
operator|-
name|ifalse
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|can_reverse
operator|=
operator|(
name|reversed_comparison_code
argument_list|(
name|if_info
operator|->
name|cond
argument_list|,
name|if_info
operator|->
name|jump
argument_list|)
operator|!=
name|UNKNOWN
operator|)
expr_stmt|;
name|reversep
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|diff
operator|==
name|STORE_FLAG_VALUE
operator|||
name|diff
operator|==
operator|-
name|STORE_FLAG_VALUE
condition|)
name|normalize
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|ifalse
operator|==
literal|0
operator|&&
name|exact_log2
argument_list|(
name|itrue
argument_list|)
operator|>=
literal|0
operator|&&
operator|(
name|STORE_FLAG_VALUE
operator|==
literal|1
operator|||
name|BRANCH_COST
operator|>=
literal|2
operator|)
condition|)
name|normalize
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|itrue
operator|==
literal|0
operator|&&
name|exact_log2
argument_list|(
name|ifalse
argument_list|)
operator|>=
literal|0
operator|&&
name|can_reverse
operator|&&
operator|(
name|STORE_FLAG_VALUE
operator|==
literal|1
operator|||
name|BRANCH_COST
operator|>=
literal|2
operator|)
condition|)
name|normalize
operator|=
literal|1
operator|,
name|reversep
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|itrue
operator|==
operator|-
literal|1
operator|&&
operator|(
name|STORE_FLAG_VALUE
operator|==
operator|-
literal|1
operator|||
name|BRANCH_COST
operator|>=
literal|2
operator|)
condition|)
name|normalize
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|ifalse
operator|==
operator|-
literal|1
operator|&&
name|can_reverse
operator|&&
operator|(
name|STORE_FLAG_VALUE
operator|==
operator|-
literal|1
operator|||
name|BRANCH_COST
operator|>=
literal|2
operator|)
condition|)
name|normalize
operator|=
operator|-
literal|1
operator|,
name|reversep
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|BRANCH_COST
operator|>=
literal|2
operator|&&
name|STORE_FLAG_VALUE
operator|==
operator|-
literal|1
operator|)
operator|||
name|BRANCH_COST
operator|>=
literal|3
condition|)
name|normalize
operator|=
operator|-
literal|1
expr_stmt|;
else|else
return|return
name|FALSE
return|;
if|if
condition|(
name|reversep
condition|)
block|{
name|tmp
operator|=
name|itrue
expr_stmt|;
name|itrue
operator|=
name|ifalse
expr_stmt|;
name|ifalse
operator|=
name|tmp
expr_stmt|;
name|diff
operator|=
name|trunc_int_for_mode
argument_list|(
operator|-
name|diff
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
name|start_sequence
argument_list|()
expr_stmt|;
name|target
operator|=
name|noce_emit_store_flag
argument_list|(
name|if_info
argument_list|,
name|if_info
operator|->
name|x
argument_list|,
name|reversep
argument_list|,
name|normalize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target
condition|)
block|{
name|end_sequence
argument_list|()
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* if (test) x = 3; else x = 4; 	 =>   x = 3 + (test == 0);  */
if|if
condition|(
name|diff
operator|==
name|STORE_FLAG_VALUE
operator|||
name|diff
operator|==
operator|-
name|STORE_FLAG_VALUE
condition|)
block|{
name|target
operator|=
name|expand_simple_binop
argument_list|(
name|mode
argument_list|,
operator|(
name|diff
operator|==
name|STORE_FLAG_VALUE
condition|?
name|PLUS
else|:
name|MINUS
operator|)
argument_list|,
name|GEN_INT
argument_list|(
name|ifalse
argument_list|)
argument_list|,
name|target
argument_list|,
name|if_info
operator|->
name|x
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
block|}
comment|/* if (test) x = 8; else x = 0; 	 =>   x = (test != 0)<< 3;  */
elseif|else
if|if
condition|(
name|ifalse
operator|==
literal|0
operator|&&
operator|(
name|tmp
operator|=
name|exact_log2
argument_list|(
name|itrue
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|target
operator|=
name|expand_simple_binop
argument_list|(
name|mode
argument_list|,
name|ASHIFT
argument_list|,
name|target
argument_list|,
name|GEN_INT
argument_list|(
name|tmp
argument_list|)
argument_list|,
name|if_info
operator|->
name|x
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
block|}
comment|/* if (test) x = -1; else x = b; 	 =>   x = -(test != 0) | b;  */
elseif|else
if|if
condition|(
name|itrue
operator|==
operator|-
literal|1
condition|)
block|{
name|target
operator|=
name|expand_simple_binop
argument_list|(
name|mode
argument_list|,
name|IOR
argument_list|,
name|target
argument_list|,
name|GEN_INT
argument_list|(
name|ifalse
argument_list|)
argument_list|,
name|if_info
operator|->
name|x
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
block|}
comment|/* if (test) x = a; else x = b; 	 =>   x = (-(test != 0)& (b - a)) + a;  */
else|else
block|{
name|target
operator|=
name|expand_simple_binop
argument_list|(
name|mode
argument_list|,
name|AND
argument_list|,
name|target
argument_list|,
name|GEN_INT
argument_list|(
name|diff
argument_list|)
argument_list|,
name|if_info
operator|->
name|x
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
name|target
operator|=
name|expand_simple_binop
argument_list|(
name|mode
argument_list|,
name|PLUS
argument_list|,
name|target
argument_list|,
name|GEN_INT
argument_list|(
name|ifalse
argument_list|)
argument_list|,
name|if_info
operator|->
name|x
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|target
condition|)
block|{
name|end_sequence
argument_list|()
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|target
operator|!=
name|if_info
operator|->
name|x
condition|)
name|noce_emit_move_insn
argument_list|(
name|if_info
operator|->
name|x
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
name|seq_contains_jump
argument_list|(
name|seq
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|emit_insns_before
argument_list|(
name|seq
argument_list|,
name|if_info
operator|->
name|cond_earliest
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Convert "if (test) foo++" into "foo += (test != 0)", and     similarly for "foo--".  */
end_comment

begin_function
specifier|static
name|int
name|noce_try_store_flag_inc
parameter_list|(
name|if_info
parameter_list|)
name|struct
name|noce_if_info
modifier|*
name|if_info
decl_stmt|;
block|{
name|rtx
name|target
decl_stmt|,
name|seq
decl_stmt|;
name|int
name|subtract
decl_stmt|,
name|normalize
decl_stmt|;
if|if
condition|(
operator|!
name|no_new_pseudos
operator|&&
operator|(
name|BRANCH_COST
operator|>=
literal|2
operator|||
name|HAVE_incscc
operator|||
name|HAVE_decscc
operator|)
comment|/* Should be no `else' case to worry about.  */
operator|&&
name|if_info
operator|->
name|b
operator|==
name|if_info
operator|->
name|x
operator|&&
name|GET_CODE
argument_list|(
name|if_info
operator|->
name|a
argument_list|)
operator|==
name|PLUS
operator|&&
operator|(
name|XEXP
argument_list|(
name|if_info
operator|->
name|a
argument_list|,
literal|1
argument_list|)
operator|==
name|const1_rtx
operator|||
name|XEXP
argument_list|(
name|if_info
operator|->
name|a
argument_list|,
literal|1
argument_list|)
operator|==
name|constm1_rtx
operator|)
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|if_info
operator|->
name|a
argument_list|,
literal|0
argument_list|)
argument_list|,
name|if_info
operator|->
name|x
argument_list|)
operator|&&
operator|(
name|reversed_comparison_code
argument_list|(
name|if_info
operator|->
name|cond
argument_list|,
name|if_info
operator|->
name|jump
argument_list|)
operator|!=
name|UNKNOWN
operator|)
condition|)
block|{
if|if
condition|(
name|STORE_FLAG_VALUE
operator|==
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|if_info
operator|->
name|a
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|subtract
operator|=
literal|0
operator|,
name|normalize
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|-
name|STORE_FLAG_VALUE
operator|==
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|if_info
operator|->
name|a
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|subtract
operator|=
literal|1
operator|,
name|normalize
operator|=
literal|0
expr_stmt|;
else|else
name|subtract
operator|=
literal|0
operator|,
name|normalize
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|if_info
operator|->
name|a
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|target
operator|=
name|noce_emit_store_flag
argument_list|(
name|if_info
argument_list|,
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|if_info
operator|->
name|x
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|,
name|normalize
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
name|target
operator|=
name|expand_simple_binop
argument_list|(
name|GET_MODE
argument_list|(
name|if_info
operator|->
name|x
argument_list|)
argument_list|,
name|subtract
condition|?
name|MINUS
else|:
name|PLUS
argument_list|,
name|if_info
operator|->
name|x
argument_list|,
name|target
argument_list|,
name|if_info
operator|->
name|x
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
block|{
if|if
condition|(
name|target
operator|!=
name|if_info
operator|->
name|x
condition|)
name|noce_emit_move_insn
argument_list|(
name|if_info
operator|->
name|x
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
name|seq_contains_jump
argument_list|(
name|seq
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|emit_insns_before
argument_list|(
name|seq
argument_list|,
name|if_info
operator|->
name|cond_earliest
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|end_sequence
argument_list|()
expr_stmt|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Convert "if (test) x = 0;" to "x&= -(test == 0);"  */
end_comment

begin_function
specifier|static
name|int
name|noce_try_store_flag_mask
parameter_list|(
name|if_info
parameter_list|)
name|struct
name|noce_if_info
modifier|*
name|if_info
decl_stmt|;
block|{
name|rtx
name|target
decl_stmt|,
name|seq
decl_stmt|;
name|int
name|reversep
decl_stmt|;
name|reversep
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|no_new_pseudos
operator|&&
operator|(
name|BRANCH_COST
operator|>=
literal|2
operator|||
name|STORE_FLAG_VALUE
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
operator|(
name|if_info
operator|->
name|a
operator|==
name|const0_rtx
operator|&&
name|rtx_equal_p
argument_list|(
name|if_info
operator|->
name|b
argument_list|,
name|if_info
operator|->
name|x
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|reversep
operator|=
operator|(
name|reversed_comparison_code
argument_list|(
name|if_info
operator|->
name|cond
argument_list|,
name|if_info
operator|->
name|jump
argument_list|)
operator|!=
name|UNKNOWN
operator|)
operator|)
operator|&&
name|if_info
operator|->
name|b
operator|==
name|const0_rtx
operator|&&
name|rtx_equal_p
argument_list|(
name|if_info
operator|->
name|a
argument_list|,
name|if_info
operator|->
name|x
argument_list|)
operator|)
operator|)
condition|)
block|{
name|start_sequence
argument_list|()
expr_stmt|;
name|target
operator|=
name|noce_emit_store_flag
argument_list|(
name|if_info
argument_list|,
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|if_info
operator|->
name|x
argument_list|)
argument_list|)
argument_list|,
name|reversep
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
name|target
operator|=
name|expand_simple_binop
argument_list|(
name|GET_MODE
argument_list|(
name|if_info
operator|->
name|x
argument_list|)
argument_list|,
name|AND
argument_list|,
name|if_info
operator|->
name|x
argument_list|,
name|target
argument_list|,
name|if_info
operator|->
name|x
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
block|{
if|if
condition|(
name|target
operator|!=
name|if_info
operator|->
name|x
condition|)
name|noce_emit_move_insn
argument_list|(
name|if_info
operator|->
name|x
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
name|seq_contains_jump
argument_list|(
name|seq
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|emit_insns_before
argument_list|(
name|seq
argument_list|,
name|if_info
operator|->
name|cond_earliest
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|end_sequence
argument_list|()
expr_stmt|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Helper function for noce_try_cmove and noce_try_cmove_arith.  */
end_comment

begin_function
specifier|static
name|rtx
name|noce_emit_cmove
parameter_list|(
name|if_info
parameter_list|,
name|x
parameter_list|,
name|code
parameter_list|,
name|cmp_a
parameter_list|,
name|cmp_b
parameter_list|,
name|vfalse
parameter_list|,
name|vtrue
parameter_list|)
name|struct
name|noce_if_info
modifier|*
name|if_info
decl_stmt|;
name|rtx
name|x
decl_stmt|,
name|cmp_a
decl_stmt|,
name|cmp_b
decl_stmt|,
name|vfalse
decl_stmt|,
name|vtrue
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
block|{
comment|/* If earliest == jump, try to build the cmove insn directly.      This is helpful when combine has created some complex condition      (like for alpha's cmovlbs) that we can't hope to regenerate      through the normal interface.  */
if|if
condition|(
name|if_info
operator|->
name|cond_earliest
operator|==
name|if_info
operator|->
name|jump
condition|)
block|{
name|rtx
name|tmp
decl_stmt|;
name|tmp
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|GET_MODE
argument_list|(
name|if_info
operator|->
name|cond
argument_list|)
argument_list|,
name|cmp_a
argument_list|,
name|cmp_b
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|tmp
argument_list|,
name|vtrue
argument_list|,
name|vfalse
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|x
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|tmp
operator|=
name|emit_insn
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|recog_memoized
argument_list|(
name|tmp
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|tmp
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insns
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
name|end_sequence
argument_list|()
expr_stmt|;
block|}
comment|/* Don't even try if the comparison operands are weird.  */
if|if
condition|(
operator|!
name|general_operand
argument_list|(
name|cmp_a
argument_list|,
name|GET_MODE
argument_list|(
name|cmp_a
argument_list|)
argument_list|)
operator|||
operator|!
name|general_operand
argument_list|(
name|cmp_b
argument_list|,
name|GET_MODE
argument_list|(
name|cmp_b
argument_list|)
argument_list|)
condition|)
return|return
name|NULL_RTX
return|;
if|#
directive|if
name|HAVE_conditional_move
return|return
name|emit_conditional_move
argument_list|(
name|x
argument_list|,
name|code
argument_list|,
name|cmp_a
argument_list|,
name|cmp_b
argument_list|,
name|VOIDmode
argument_list|,
name|vtrue
argument_list|,
name|vfalse
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
operator|(
name|code
operator|==
name|LTU
operator|||
name|code
operator|==
name|GEU
operator|||
name|code
operator|==
name|LEU
operator|||
name|code
operator|==
name|GTU
operator|)
argument_list|)
return|;
else|#
directive|else
comment|/* We'll never get here, as noce_process_if_block doesn't call the      functions involved.  Ifdef code, however, should be discouraged      because it leads to typos in the code not selected.  However,       emit_conditional_move won't exist either.  */
return|return
name|NULL_RTX
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Try only simple constants and registers here.  More complex cases    are handled in noce_try_cmove_arith after noce_try_store_flag_arith    has had a go at it.  */
end_comment

begin_function
specifier|static
name|int
name|noce_try_cmove
parameter_list|(
name|if_info
parameter_list|)
name|struct
name|noce_if_info
modifier|*
name|if_info
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
decl_stmt|;
name|rtx
name|target
decl_stmt|,
name|seq
decl_stmt|;
if|if
condition|(
operator|(
name|CONSTANT_P
argument_list|(
name|if_info
operator|->
name|a
argument_list|)
operator|||
name|register_operand
argument_list|(
name|if_info
operator|->
name|a
argument_list|,
name|VOIDmode
argument_list|)
operator|)
operator|&&
operator|(
name|CONSTANT_P
argument_list|(
name|if_info
operator|->
name|b
argument_list|)
operator|||
name|register_operand
argument_list|(
name|if_info
operator|->
name|b
argument_list|,
name|VOIDmode
argument_list|)
operator|)
condition|)
block|{
name|start_sequence
argument_list|()
expr_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|if_info
operator|->
name|cond
argument_list|)
expr_stmt|;
name|target
operator|=
name|noce_emit_cmove
argument_list|(
name|if_info
argument_list|,
name|if_info
operator|->
name|x
argument_list|,
name|code
argument_list|,
name|XEXP
argument_list|(
name|if_info
operator|->
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|if_info
operator|->
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|,
name|if_info
operator|->
name|a
argument_list|,
name|if_info
operator|->
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
block|{
if|if
condition|(
name|target
operator|!=
name|if_info
operator|->
name|x
condition|)
name|noce_emit_move_insn
argument_list|(
name|if_info
operator|->
name|x
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insns_before
argument_list|(
name|seq
argument_list|,
name|if_info
operator|->
name|cond_earliest
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
else|else
block|{
name|end_sequence
argument_list|()
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Try more complex cases involving conditional_move.  */
end_comment

begin_function
specifier|static
name|int
name|noce_try_cmove_arith
parameter_list|(
name|if_info
parameter_list|)
name|struct
name|noce_if_info
modifier|*
name|if_info
decl_stmt|;
block|{
name|rtx
name|a
init|=
name|if_info
operator|->
name|a
decl_stmt|;
name|rtx
name|b
init|=
name|if_info
operator|->
name|b
decl_stmt|;
name|rtx
name|x
init|=
name|if_info
operator|->
name|x
decl_stmt|;
name|rtx
name|insn_a
decl_stmt|,
name|insn_b
decl_stmt|;
name|rtx
name|tmp
decl_stmt|,
name|target
decl_stmt|;
name|int
name|is_mem
init|=
literal|0
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
comment|/* A conditional move from two memory sources is equivalent to a      conditional on their addresses followed by a load.  Don't do this      early because it'll screw alias analysis.  Note that we've      already checked for no side effects.  */
if|if
condition|(
operator|!
name|no_new_pseudos
operator|&&
name|cse_not_expected
operator|&&
name|GET_CODE
argument_list|(
name|a
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|b
argument_list|)
operator|==
name|MEM
operator|&&
name|BRANCH_COST
operator|>=
literal|5
condition|)
block|{
name|a
operator|=
name|XEXP
argument_list|(
name|a
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|b
operator|=
name|XEXP
argument_list|(
name|b
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|x
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|is_mem
operator|=
literal|1
expr_stmt|;
block|}
comment|/* ??? We could handle this if we knew that a load from A or B could      not fault.  This is also true if we've already loaded      from the address along the path from ENTRY.  */
elseif|else
if|if
condition|(
name|may_trap_p
argument_list|(
name|a
argument_list|)
operator|||
name|may_trap_p
argument_list|(
name|b
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* if (test) x = a + b; else x = c - d;      => y = a + b;         x = c - d; 	if (test) 	  x = y;   */
name|code
operator|=
name|GET_CODE
argument_list|(
name|if_info
operator|->
name|cond
argument_list|)
expr_stmt|;
name|insn_a
operator|=
name|if_info
operator|->
name|insn_a
expr_stmt|;
name|insn_b
operator|=
name|if_info
operator|->
name|insn_b
expr_stmt|;
comment|/* Possibly rearrange operands to make things come out more natural.  */
if|if
condition|(
name|reversed_comparison_code
argument_list|(
name|if_info
operator|->
name|cond
argument_list|,
name|if_info
operator|->
name|jump
argument_list|)
operator|!=
name|UNKNOWN
condition|)
block|{
name|int
name|reversep
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|b
argument_list|,
name|x
argument_list|)
condition|)
name|reversep
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|general_operand
argument_list|(
name|b
argument_list|,
name|GET_MODE
argument_list|(
name|b
argument_list|)
argument_list|)
condition|)
name|reversep
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|reversep
condition|)
block|{
name|code
operator|=
name|reversed_comparison_code
argument_list|(
name|if_info
operator|->
name|cond
argument_list|,
name|if_info
operator|->
name|jump
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|a
operator|,
name|a
operator|=
name|b
operator|,
name|b
operator|=
name|tmp
expr_stmt|;
name|tmp
operator|=
name|insn_a
operator|,
name|insn_a
operator|=
name|insn_b
operator|,
name|insn_b
operator|=
name|tmp
expr_stmt|;
block|}
block|}
name|start_sequence
argument_list|()
expr_stmt|;
comment|/* If either operand is complex, load it into a register first.      The best way to do this is to copy the original insn.  In this      way we preserve any clobbers etc that the insn may have had.        This is of course not possible in the IS_MEM case.  */
if|if
condition|(
operator|!
name|general_operand
argument_list|(
name|a
argument_list|,
name|GET_MODE
argument_list|(
name|a
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|set
decl_stmt|;
if|if
condition|(
name|no_new_pseudos
condition|)
goto|goto
name|end_seq_and_fail
goto|;
if|if
condition|(
name|is_mem
condition|)
block|{
name|tmp
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|tmp
argument_list|,
name|a
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|insn_a
condition|)
goto|goto
name|end_seq_and_fail
goto|;
else|else
block|{
name|a
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|copy_rtx
argument_list|(
name|insn_a
argument_list|)
expr_stmt|;
name|set
operator|=
name|single_set
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|=
name|a
expr_stmt|;
name|tmp
operator|=
name|emit_insn
argument_list|(
name|PATTERN
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|recog_memoized
argument_list|(
name|tmp
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|end_seq_and_fail
goto|;
block|}
if|if
condition|(
operator|!
name|general_operand
argument_list|(
name|b
argument_list|,
name|GET_MODE
argument_list|(
name|b
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|set
decl_stmt|;
if|if
condition|(
name|no_new_pseudos
condition|)
goto|goto
name|end_seq_and_fail
goto|;
if|if
condition|(
name|is_mem
condition|)
block|{
name|tmp
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|tmp
argument_list|,
name|b
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|insn_b
condition|)
goto|goto
name|end_seq_and_fail
goto|;
else|else
block|{
name|b
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|copy_rtx
argument_list|(
name|insn_b
argument_list|)
expr_stmt|;
name|set
operator|=
name|single_set
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|=
name|b
expr_stmt|;
name|tmp
operator|=
name|emit_insn
argument_list|(
name|PATTERN
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|recog_memoized
argument_list|(
name|tmp
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|end_seq_and_fail
goto|;
block|}
name|target
operator|=
name|noce_emit_cmove
argument_list|(
name|if_info
argument_list|,
name|x
argument_list|,
name|code
argument_list|,
name|XEXP
argument_list|(
name|if_info
operator|->
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|if_info
operator|->
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|,
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target
condition|)
goto|goto
name|end_seq_and_fail
goto|;
comment|/* If we're handling a memory for above, emit the load now.  */
if|if
condition|(
name|is_mem
condition|)
block|{
name|tmp
operator|=
name|gen_rtx_MEM
argument_list|(
name|GET_MODE
argument_list|(
name|if_info
operator|->
name|x
argument_list|)
argument_list|,
name|target
argument_list|)
expr_stmt|;
comment|/* Copy over flags as appropriate.  */
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|if_info
operator|->
name|a
argument_list|)
operator|||
name|MEM_VOLATILE_P
argument_list|(
name|if_info
operator|->
name|b
argument_list|)
condition|)
name|MEM_VOLATILE_P
argument_list|(
name|tmp
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|MEM_IN_STRUCT_P
argument_list|(
name|if_info
operator|->
name|a
argument_list|)
operator|&&
name|MEM_IN_STRUCT_P
argument_list|(
name|if_info
operator|->
name|b
argument_list|)
condition|)
name|MEM_IN_STRUCT_P
argument_list|(
name|tmp
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|MEM_SCALAR_P
argument_list|(
name|if_info
operator|->
name|a
argument_list|)
operator|&&
name|MEM_SCALAR_P
argument_list|(
name|if_info
operator|->
name|b
argument_list|)
condition|)
name|MEM_SCALAR_P
argument_list|(
name|tmp
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|MEM_ALIAS_SET
argument_list|(
name|if_info
operator|->
name|a
argument_list|)
operator|==
name|MEM_ALIAS_SET
argument_list|(
name|if_info
operator|->
name|b
argument_list|)
condition|)
name|set_mem_alias_set
argument_list|(
name|tmp
argument_list|,
name|MEM_ALIAS_SET
argument_list|(
name|if_info
operator|->
name|a
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_align
argument_list|(
name|tmp
argument_list|,
name|MIN
argument_list|(
name|MEM_ALIGN
argument_list|(
name|if_info
operator|->
name|a
argument_list|)
argument_list|,
name|MEM_ALIGN
argument_list|(
name|if_info
operator|->
name|b
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|noce_emit_move_insn
argument_list|(
name|if_info
operator|->
name|x
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|target
operator|!=
name|x
condition|)
name|noce_emit_move_insn
argument_list|(
name|x
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insns_before
argument_list|(
name|tmp
argument_list|,
name|if_info
operator|->
name|cond_earliest
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
name|end_seq_and_fail
label|:
name|end_sequence
argument_list|()
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* For most cases, the simplified condition we found is the best    choice, but this is not the case for the min/max/abs transforms.    For these we wish to know that it is A or B in the condition.  */
end_comment

begin_function
specifier|static
name|rtx
name|noce_get_alt_condition
parameter_list|(
name|if_info
parameter_list|,
name|target
parameter_list|,
name|earliest
parameter_list|)
name|struct
name|noce_if_info
modifier|*
name|if_info
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|rtx
modifier|*
name|earliest
decl_stmt|;
block|{
name|rtx
name|cond
decl_stmt|,
name|set
decl_stmt|,
name|insn
decl_stmt|;
name|int
name|reverse
decl_stmt|;
comment|/* If target is already mentioned in the known condition, return it.  */
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|target
argument_list|,
name|if_info
operator|->
name|cond
argument_list|)
condition|)
block|{
operator|*
name|earliest
operator|=
name|if_info
operator|->
name|cond_earliest
expr_stmt|;
return|return
name|if_info
operator|->
name|cond
return|;
block|}
name|set
operator|=
name|pc_set
argument_list|(
name|if_info
operator|->
name|jump
argument_list|)
expr_stmt|;
name|cond
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|reverse
operator|=
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|JUMP_LABEL
argument_list|(
name|if_info
operator|->
name|jump
argument_list|)
expr_stmt|;
comment|/* If we're looking for a constant, try to make the conditional      have that constant in it.  There are two reasons why it may      not have the constant we want:       1. GCC may have needed to put the constant in a register, because         the target can't compare directly against that constant.  For         this case, we look for a SET immediately before the comparison         that puts a constant in that register.       2. GCC may have canonicalized the conditional, for example 	replacing "if x< 4" with "if x<= 3".  We can undo that (or 	make equivalent types of changes) to get the constants we need 	if they're off by one in the right direction.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|if_info
operator|->
name|cond
argument_list|)
decl_stmt|;
name|rtx
name|op_a
init|=
name|XEXP
argument_list|(
name|if_info
operator|->
name|cond
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|op_b
init|=
name|XEXP
argument_list|(
name|if_info
operator|->
name|cond
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|rtx
name|prev_insn
decl_stmt|;
comment|/* First, look to see if we put a constant in a register.  */
name|prev_insn
operator|=
name|PREV_INSN
argument_list|(
name|if_info
operator|->
name|cond_earliest
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev_insn
operator|&&
name|INSN_P
argument_list|(
name|prev_insn
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|prev_insn
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
block|{
name|rtx
name|src
init|=
name|find_reg_equal_equiv_note
argument_list|(
name|prev_insn
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|src
condition|)
name|src
operator|=
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|prev_insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|op_a
argument_list|,
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|prev_insn
argument_list|)
argument_list|)
argument_list|)
condition|)
name|op_a
operator|=
name|src
expr_stmt|;
elseif|else
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|op_b
argument_list|,
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|prev_insn
argument_list|)
argument_list|)
argument_list|)
condition|)
name|op_b
operator|=
name|src
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op_a
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|rtx
name|tmp
init|=
name|op_a
decl_stmt|;
name|op_a
operator|=
name|op_b
expr_stmt|;
name|op_b
operator|=
name|tmp
expr_stmt|;
name|code
operator|=
name|swap_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Now, look to see if we can get the right constant by 	 adjusting the conditional.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op_b
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|HOST_WIDE_INT
name|desired_val
init|=
name|INTVAL
argument_list|(
name|target
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|actual_val
init|=
name|INTVAL
argument_list|(
name|op_b
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LT
case|:
if|if
condition|(
name|actual_val
operator|==
name|desired_val
operator|+
literal|1
condition|)
block|{
name|code
operator|=
name|LE
expr_stmt|;
name|op_b
operator|=
name|GEN_INT
argument_list|(
name|desired_val
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LE
case|:
if|if
condition|(
name|actual_val
operator|==
name|desired_val
operator|-
literal|1
condition|)
block|{
name|code
operator|=
name|LT
expr_stmt|;
name|op_b
operator|=
name|GEN_INT
argument_list|(
name|desired_val
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|GT
case|:
if|if
condition|(
name|actual_val
operator|==
name|desired_val
operator|-
literal|1
condition|)
block|{
name|code
operator|=
name|GE
expr_stmt|;
name|op_b
operator|=
name|GEN_INT
argument_list|(
name|desired_val
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|GE
case|:
if|if
condition|(
name|actual_val
operator|==
name|desired_val
operator|+
literal|1
condition|)
block|{
name|code
operator|=
name|GT
expr_stmt|;
name|op_b
operator|=
name|GEN_INT
argument_list|(
name|desired_val
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
comment|/* If we made any changes, generate a new conditional that is 	 equivalent to what we started with, but has the right 	 constants in it.  */
if|if
condition|(
name|code
operator|!=
name|GET_CODE
argument_list|(
name|if_info
operator|->
name|cond
argument_list|)
operator|||
name|op_a
operator|!=
name|XEXP
argument_list|(
name|if_info
operator|->
name|cond
argument_list|,
literal|0
argument_list|)
operator|||
name|op_b
operator|!=
name|XEXP
argument_list|(
name|if_info
operator|->
name|cond
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|cond
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|GET_MODE
argument_list|(
name|cond
argument_list|)
argument_list|,
name|op_a
argument_list|,
name|op_b
argument_list|)
expr_stmt|;
operator|*
name|earliest
operator|=
name|if_info
operator|->
name|cond_earliest
expr_stmt|;
return|return
name|cond
return|;
block|}
block|}
name|cond
operator|=
name|canonicalize_condition
argument_list|(
name|if_info
operator|->
name|jump
argument_list|,
name|cond
argument_list|,
name|reverse
argument_list|,
name|earliest
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cond
operator|||
operator|!
name|reg_mentioned_p
argument_list|(
name|target
argument_list|,
name|cond
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* We almost certainly searched back to a different place.      Need to re-verify correct lifetimes.  */
comment|/* X may not be mentioned in the range (cond_earliest, jump].  */
for|for
control|(
name|insn
operator|=
name|if_info
operator|->
name|jump
init|;
name|insn
operator|!=
operator|*
name|earliest
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|reg_mentioned_p
argument_list|(
name|if_info
operator|->
name|x
argument_list|,
name|insn
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* A and B may not be modified in the range [cond_earliest, jump).  */
for|for
control|(
name|insn
operator|=
operator|*
name|earliest
init|;
name|insn
operator|!=
name|if_info
operator|->
name|jump
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
operator|(
name|modified_in_p
argument_list|(
name|if_info
operator|->
name|a
argument_list|,
name|insn
argument_list|)
operator|||
name|modified_in_p
argument_list|(
name|if_info
operator|->
name|b
argument_list|,
name|insn
argument_list|)
operator|)
condition|)
return|return
name|NULL
return|;
return|return
name|cond
return|;
block|}
end_function

begin_comment
comment|/* Convert "if (a< b) x = a; else x = b;" to "x = min(a, b);", etc.  */
end_comment

begin_function
specifier|static
name|int
name|noce_try_minmax
parameter_list|(
name|if_info
parameter_list|)
name|struct
name|noce_if_info
modifier|*
name|if_info
decl_stmt|;
block|{
name|rtx
name|cond
decl_stmt|,
name|earliest
decl_stmt|,
name|target
decl_stmt|,
name|seq
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|,
name|op
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
comment|/* ??? Can't guarantee that expand_binop won't create pseudos.  */
if|if
condition|(
name|no_new_pseudos
condition|)
return|return
name|FALSE
return|;
comment|/* ??? Reject FP modes since we don't know how 0 vs -0 or NaNs      will be resolved with an SMIN/SMAX.  It wouldn't be too hard      to get the target to tell us...  */
if|if
condition|(
name|FLOAT_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|if_info
operator|->
name|x
argument_list|)
argument_list|)
operator|&&
name|TARGET_FLOAT_FORMAT
operator|==
name|IEEE_FLOAT_FORMAT
operator|&&
operator|!
name|flag_unsafe_math_optimizations
condition|)
return|return
name|FALSE
return|;
name|cond
operator|=
name|noce_get_alt_condition
argument_list|(
name|if_info
argument_list|,
name|if_info
operator|->
name|a
argument_list|,
operator|&
name|earliest
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cond
condition|)
return|return
name|FALSE
return|;
comment|/* Verify the condition is of the form we expect, and canonicalize      the comparison code.  */
name|code
operator|=
name|GET_CODE
argument_list|(
name|cond
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|,
name|if_info
operator|->
name|a
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|,
name|if_info
operator|->
name|b
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
elseif|else
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|,
name|if_info
operator|->
name|a
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|,
name|if_info
operator|->
name|b
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|code
operator|=
name|swap_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
else|else
return|return
name|FALSE
return|;
comment|/* Determine what sort of operation this is.  Note that the code is for      a taken branch, so the code->operation mapping appears backwards.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LT
case|:
case|case
name|LE
case|:
case|case
name|UNLT
case|:
case|case
name|UNLE
case|:
name|op
operator|=
name|SMAX
expr_stmt|;
name|unsignedp
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|GT
case|:
case|case
name|GE
case|:
case|case
name|UNGT
case|:
case|case
name|UNGE
case|:
name|op
operator|=
name|SMIN
expr_stmt|;
name|unsignedp
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|LTU
case|:
case|case
name|LEU
case|:
name|op
operator|=
name|UMAX
expr_stmt|;
name|unsignedp
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|GTU
case|:
case|case
name|GEU
case|:
name|op
operator|=
name|UMIN
expr_stmt|;
name|unsignedp
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
return|return
name|FALSE
return|;
block|}
name|start_sequence
argument_list|()
expr_stmt|;
name|target
operator|=
name|expand_simple_binop
argument_list|(
name|GET_MODE
argument_list|(
name|if_info
operator|->
name|x
argument_list|)
argument_list|,
name|op
argument_list|,
name|if_info
operator|->
name|a
argument_list|,
name|if_info
operator|->
name|b
argument_list|,
name|if_info
operator|->
name|x
argument_list|,
name|unsignedp
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target
condition|)
block|{
name|end_sequence
argument_list|()
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|target
operator|!=
name|if_info
operator|->
name|x
condition|)
name|noce_emit_move_insn
argument_list|(
name|if_info
operator|->
name|x
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
name|seq_contains_jump
argument_list|(
name|seq
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|emit_insns_before
argument_list|(
name|seq
argument_list|,
name|earliest
argument_list|)
expr_stmt|;
name|if_info
operator|->
name|cond
operator|=
name|cond
expr_stmt|;
name|if_info
operator|->
name|cond_earliest
operator|=
name|earliest
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Convert "if (a< 0) x = -a; else x = a;" to "x = abs(a);", etc.  */
end_comment

begin_function
specifier|static
name|int
name|noce_try_abs
parameter_list|(
name|if_info
parameter_list|)
name|struct
name|noce_if_info
modifier|*
name|if_info
decl_stmt|;
block|{
name|rtx
name|cond
decl_stmt|,
name|earliest
decl_stmt|,
name|target
decl_stmt|,
name|seq
decl_stmt|,
name|a
decl_stmt|,
name|b
decl_stmt|,
name|c
decl_stmt|;
name|int
name|negate
decl_stmt|;
comment|/* ??? Can't guarantee that expand_binop won't create pseudos.  */
if|if
condition|(
name|no_new_pseudos
condition|)
return|return
name|FALSE
return|;
comment|/* Recognize A and B as constituting an ABS or NABS.  */
name|a
operator|=
name|if_info
operator|->
name|a
expr_stmt|;
name|b
operator|=
name|if_info
operator|->
name|b
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|a
argument_list|)
operator|==
name|NEG
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|a
argument_list|,
literal|0
argument_list|)
argument_list|,
name|b
argument_list|)
condition|)
name|negate
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|b
argument_list|)
operator|==
name|NEG
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|b
argument_list|,
literal|0
argument_list|)
argument_list|,
name|a
argument_list|)
condition|)
block|{
name|c
operator|=
name|a
expr_stmt|;
name|a
operator|=
name|b
expr_stmt|;
name|b
operator|=
name|c
expr_stmt|;
name|negate
operator|=
literal|1
expr_stmt|;
block|}
else|else
return|return
name|FALSE
return|;
name|cond
operator|=
name|noce_get_alt_condition
argument_list|(
name|if_info
argument_list|,
name|b
argument_list|,
operator|&
name|earliest
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cond
condition|)
return|return
name|FALSE
return|;
comment|/* Verify the condition is of the form we expect.  */
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|,
name|b
argument_list|)
condition|)
name|c
operator|=
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|,
name|b
argument_list|)
condition|)
name|c
operator|=
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
return|return
name|FALSE
return|;
comment|/* Verify that C is zero.  Search backward through the block for      a REG_EQUAL note if necessary.  */
if|if
condition|(
name|REG_P
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|rtx
name|insn
decl_stmt|,
name|note
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|earliest
init|;
name|insn
operator|!=
name|if_info
operator|->
name|test_bb
operator|->
name|head
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
operator|(
operator|(
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EQUAL
argument_list|,
name|c
argument_list|)
operator|)
operator|||
operator|(
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EQUIV
argument_list|,
name|c
argument_list|)
operator|)
operator|)
condition|)
break|break;
if|if
condition|(
operator|!
name|note
condition|)
return|return
name|FALSE
return|;
name|c
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|c
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|c
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|c
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|c
operator|=
name|get_pool_constant
argument_list|(
name|XEXP
argument_list|(
name|c
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Work around funny ideas get_condition has wrt canonicalization.      Note that these rtx constants are known to be CONST_INT, and       therefore imply integer comparisons.  */
if|if
condition|(
name|c
operator|==
name|constm1_rtx
operator|&&
name|GET_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|GT
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
name|const1_rtx
operator|&&
name|GET_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|LT
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|c
operator|!=
name|CONST0_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|b
argument_list|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Determine what sort of operation this is.  */
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|cond
argument_list|)
condition|)
block|{
case|case
name|LT
case|:
case|case
name|LE
case|:
case|case
name|UNLT
case|:
case|case
name|UNLE
case|:
name|negate
operator|=
operator|!
name|negate
expr_stmt|;
break|break;
case|case
name|GT
case|:
case|case
name|GE
case|:
case|case
name|UNGT
case|:
case|case
name|UNGE
case|:
break|break;
default|default:
return|return
name|FALSE
return|;
block|}
name|start_sequence
argument_list|()
expr_stmt|;
name|target
operator|=
name|expand_simple_unop
argument_list|(
name|GET_MODE
argument_list|(
name|if_info
operator|->
name|x
argument_list|)
argument_list|,
name|ABS
argument_list|,
name|b
argument_list|,
name|if_info
operator|->
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* ??? It's a quandry whether cmove would be better here, especially      for integers.  Perhaps combine will clean things up.  */
if|if
condition|(
name|target
operator|&&
name|negate
condition|)
name|target
operator|=
name|expand_simple_unop
argument_list|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|,
name|NEG
argument_list|,
name|target
argument_list|,
name|if_info
operator|->
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target
condition|)
block|{
name|end_sequence
argument_list|()
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|target
operator|!=
name|if_info
operator|->
name|x
condition|)
name|noce_emit_move_insn
argument_list|(
name|if_info
operator|->
name|x
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
name|seq_contains_jump
argument_list|(
name|seq
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|emit_insns_before
argument_list|(
name|seq
argument_list|,
name|earliest
argument_list|)
expr_stmt|;
name|if_info
operator|->
name|cond
operator|=
name|cond
expr_stmt|;
name|if_info
operator|->
name|cond_earliest
operator|=
name|earliest
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Look for the condition for the jump first.  We'd prefer to avoid    get_condition if we can -- it tries to look back for the contents    of an original compare.  On targets that use normal integers for    comparisons, e.g. alpha, this is wasteful.  */
end_comment

begin_function
specifier|static
name|rtx
name|noce_get_condition
parameter_list|(
name|jump
parameter_list|,
name|earliest
parameter_list|)
name|rtx
name|jump
decl_stmt|;
name|rtx
modifier|*
name|earliest
decl_stmt|;
block|{
name|rtx
name|cond
decl_stmt|;
name|rtx
name|set
decl_stmt|;
comment|/* If the condition variable is a register and is MODE_INT, accept it.      Otherwise, fall back on get_condition.  */
if|if
condition|(
operator|!
name|any_condjump_p
argument_list|(
name|jump
argument_list|)
condition|)
return|return
name|NULL_RTX
return|;
name|set
operator|=
name|pc_set
argument_list|(
name|jump
argument_list|)
expr_stmt|;
name|cond
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|MODE_INT
condition|)
block|{
operator|*
name|earliest
operator|=
name|jump
expr_stmt|;
comment|/* If this branches to JUMP_LABEL when the condition is false, 	 reverse the condition.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|JUMP_LABEL
argument_list|(
name|jump
argument_list|)
condition|)
name|cond
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|reverse_condition
argument_list|(
name|GET_CODE
argument_list|(
name|cond
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|cond
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|cond
operator|=
name|get_condition
argument_list|(
name|jump
argument_list|,
name|earliest
argument_list|)
expr_stmt|;
return|return
name|cond
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP is ok for if-then-else processing.  */
end_comment

begin_function
specifier|static
name|int
name|noce_operand_ok
parameter_list|(
name|op
parameter_list|)
name|rtx
name|op
decl_stmt|;
block|{
comment|/* We special-case memories, so handle any of them with      no address side effects.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
condition|)
return|return
operator|!
name|side_effects_p
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|side_effects_p
argument_list|(
name|op
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* ??? Unfortuantely may_trap_p can't look at flag_trapping_math, due to      being linked into the genfoo programs.  This is probably a mistake.      With finite operands, most fp operations don't trap.  */
if|if
condition|(
operator|!
name|flag_trapping_math
operator|&&
name|FLOAT_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|)
condition|)
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|DIV
case|:
case|case
name|MOD
case|:
case|case
name|UDIV
case|:
case|case
name|UMOD
case|:
comment|/* ??? This is kinda lame -- almost every target will have forced 	   the constant into a register first.  But given the expense of 	   division, this is probably for the best.  */
return|return
operator|(
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
operator|!=
name|CONST0_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|&&
operator|!
name|may_trap_p
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
return|;
default|default:
switch|switch
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
argument_list|)
condition|)
block|{
case|case
literal|'1'
case|:
return|return
operator|!
name|may_trap_p
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
literal|'c'
case|:
case|case
literal|'2'
case|:
return|return
operator|!
name|may_trap_p
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|!
name|may_trap_p
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
break|break;
block|}
return|return
operator|!
name|may_trap_p
argument_list|(
name|op
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given a simple IF-THEN or IF-THEN-ELSE block, attempt to convert it    without using conditional execution.  Return TRUE if we were    successful at converting the the block.  */
end_comment

begin_function
specifier|static
name|int
name|noce_process_if_block
parameter_list|(
name|test_bb
parameter_list|,
name|then_bb
parameter_list|,
name|else_bb
parameter_list|,
name|join_bb
parameter_list|)
name|basic_block
name|test_bb
decl_stmt|;
comment|/* Basic block test is in */
name|basic_block
name|then_bb
decl_stmt|;
comment|/* Basic block for THEN block */
name|basic_block
name|else_bb
decl_stmt|;
comment|/* Basic block for ELSE block */
name|basic_block
name|join_bb
decl_stmt|;
comment|/* Basic block the join label is in */
block|{
comment|/* We're looking for patterns of the form       (1) if (...) x = a; else x = b;      (2) x = b; if (...) x = a;      (3) if (...) x = a;   // as if with an initial x = x.       The later patterns require jumps to be more expensive.       ??? For future expansion, look for multiple X in such patterns.  */
name|struct
name|noce_if_info
name|if_info
decl_stmt|;
name|rtx
name|insn_a
decl_stmt|,
name|insn_b
decl_stmt|;
name|rtx
name|set_a
decl_stmt|,
name|set_b
decl_stmt|;
name|rtx
name|orig_x
decl_stmt|,
name|x
decl_stmt|,
name|a
decl_stmt|,
name|b
decl_stmt|;
name|rtx
name|jump
decl_stmt|,
name|cond
decl_stmt|,
name|insn
decl_stmt|;
comment|/* If this is not a standard conditional jump, we can't parse it.  */
name|jump
operator|=
name|test_bb
operator|->
name|end
expr_stmt|;
name|cond
operator|=
name|noce_get_condition
argument_list|(
name|jump
argument_list|,
operator|&
name|if_info
operator|.
name|cond_earliest
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cond
condition|)
return|return
name|FALSE
return|;
comment|/* If the conditional jump is more than just a conditional jump,      then we can not do if-conversion on this block.  */
if|if
condition|(
operator|!
name|onlyjump_p
argument_list|(
name|jump
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* We must be comparing objects whose modes imply the size.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|BLKmode
condition|)
return|return
name|FALSE
return|;
comment|/* Look for one of the potential sets.  */
name|insn_a
operator|=
name|first_active_insn
argument_list|(
name|then_bb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|insn_a
operator|||
operator|!
name|last_active_insn_p
argument_list|(
name|then_bb
argument_list|,
name|insn_a
argument_list|)
operator|||
operator|(
name|set_a
operator|=
name|single_set
argument_list|(
name|insn_a
argument_list|)
operator|)
operator|==
name|NULL_RTX
condition|)
return|return
name|FALSE
return|;
name|x
operator|=
name|SET_DEST
argument_list|(
name|set_a
argument_list|)
expr_stmt|;
name|a
operator|=
name|SET_SRC
argument_list|(
name|set_a
argument_list|)
expr_stmt|;
comment|/* Look for the other potential set.  Make sure we've got equivalent      destinations.  */
comment|/* ??? This is overconservative.  Storing to two different mems is      as easy as conditionally computing the address.  Storing to a      single mem merely requires a scratch memory to use as one of the      destination addresses; often the memory immediately below the      stack pointer is available for this.  */
name|set_b
operator|=
name|NULL_RTX
expr_stmt|;
if|if
condition|(
name|else_bb
condition|)
block|{
name|insn_b
operator|=
name|first_active_insn
argument_list|(
name|else_bb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|insn_b
operator|||
operator|!
name|last_active_insn_p
argument_list|(
name|else_bb
argument_list|,
name|insn_b
argument_list|)
operator|||
operator|(
name|set_b
operator|=
name|single_set
argument_list|(
name|insn_b
argument_list|)
operator|)
operator|==
name|NULL_RTX
operator|||
operator|!
name|rtx_equal_p
argument_list|(
name|x
argument_list|,
name|SET_DEST
argument_list|(
name|set_b
argument_list|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
else|else
block|{
name|insn_b
operator|=
name|prev_nonnote_insn
argument_list|(
name|if_info
operator|.
name|cond_earliest
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|insn_b
operator|||
name|GET_CODE
argument_list|(
name|insn_b
argument_list|)
operator|!=
name|INSN
operator|||
operator|(
name|set_b
operator|=
name|single_set
argument_list|(
name|insn_b
argument_list|)
operator|)
operator|==
name|NULL_RTX
operator|||
operator|!
name|rtx_equal_p
argument_list|(
name|x
argument_list|,
name|SET_DEST
argument_list|(
name|set_b
argument_list|)
argument_list|)
operator|||
name|reg_mentioned_p
argument_list|(
name|x
argument_list|,
name|cond
argument_list|)
operator|||
name|reg_mentioned_p
argument_list|(
name|x
argument_list|,
name|a
argument_list|)
operator|||
name|reg_mentioned_p
argument_list|(
name|x
argument_list|,
name|SET_SRC
argument_list|(
name|set_b
argument_list|)
argument_list|)
condition|)
name|insn_b
operator|=
name|set_b
operator|=
name|NULL_RTX
expr_stmt|;
block|}
name|b
operator|=
operator|(
name|set_b
condition|?
name|SET_SRC
argument_list|(
name|set_b
argument_list|)
else|:
name|x
operator|)
expr_stmt|;
comment|/* X may not be mentioned in the range (cond_earliest, jump].  */
for|for
control|(
name|insn
operator|=
name|jump
init|;
name|insn
operator|!=
name|if_info
operator|.
name|cond_earliest
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|reg_mentioned_p
argument_list|(
name|x
argument_list|,
name|insn
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* A and B may not be modified in the range [cond_earliest, jump).  */
for|for
control|(
name|insn
operator|=
name|if_info
operator|.
name|cond_earliest
init|;
name|insn
operator|!=
name|jump
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
operator|(
name|modified_in_p
argument_list|(
name|a
argument_list|,
name|insn
argument_list|)
operator|||
name|modified_in_p
argument_list|(
name|b
argument_list|,
name|insn
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
comment|/* Only operate on register destinations, and even then avoid extending      the lifetime of hard registers on small register class machines.  */
name|orig_x
operator|=
name|x
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
operator|||
operator|(
name|SMALL_REGISTER_CLASSES
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
condition|)
block|{
if|if
condition|(
name|no_new_pseudos
condition|)
return|return
name|FALSE
return|;
name|x
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|?
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
else|:
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Don't operate on sources that may trap or are volatile.  */
if|if
condition|(
operator|!
name|noce_operand_ok
argument_list|(
name|a
argument_list|)
operator|||
operator|!
name|noce_operand_ok
argument_list|(
name|b
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Set up the info block for our subroutines.  */
name|if_info
operator|.
name|test_bb
operator|=
name|test_bb
expr_stmt|;
name|if_info
operator|.
name|cond
operator|=
name|cond
expr_stmt|;
name|if_info
operator|.
name|jump
operator|=
name|jump
expr_stmt|;
name|if_info
operator|.
name|insn_a
operator|=
name|insn_a
expr_stmt|;
name|if_info
operator|.
name|insn_b
operator|=
name|insn_b
expr_stmt|;
name|if_info
operator|.
name|x
operator|=
name|x
expr_stmt|;
name|if_info
operator|.
name|a
operator|=
name|a
expr_stmt|;
name|if_info
operator|.
name|b
operator|=
name|b
expr_stmt|;
comment|/* Try optimizations in some approximation of a useful order.  */
comment|/* ??? Should first look to see if X is live incoming at all.  If it      isn't, we don't need anything but an unconditional set.  */
comment|/* Look and see if A and B are really the same.  Avoid creating silly      cmove constructs that no one will fix up later.  */
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
condition|)
block|{
comment|/* If we have an INSN_B, we don't have to create any new rtl.  Just 	 move the instruction that we already have.  If we don't have an 	 INSN_B, that means that A == X, and we've got a noop move.  In 	 that case don't do anything and let the code below delete INSN_A.  */
if|if
condition|(
name|insn_b
operator|&&
name|else_bb
condition|)
block|{
name|rtx
name|note
decl_stmt|;
if|if
condition|(
name|else_bb
operator|&&
name|insn_b
operator|==
name|else_bb
operator|->
name|end
condition|)
name|else_bb
operator|->
name|end
operator|=
name|PREV_INSN
argument_list|(
name|insn_b
argument_list|)
expr_stmt|;
name|reorder_insns
argument_list|(
name|insn_b
argument_list|,
name|insn_b
argument_list|,
name|PREV_INSN
argument_list|(
name|if_info
operator|.
name|cond_earliest
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If there was a REG_EQUAL note, delete it since it may have been 	     true due to this insn being after a jump.  */
if|if
condition|(
operator|(
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn_b
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|remove_note
argument_list|(
name|insn_b
argument_list|,
name|note
argument_list|)
expr_stmt|;
name|insn_b
operator|=
name|NULL_RTX
expr_stmt|;
block|}
comment|/* If we have "x = b; if (...) x = a;", and x has side-effects, then 	 x must be executed twice.  */
elseif|else
if|if
condition|(
name|insn_b
operator|&&
name|side_effects_p
argument_list|(
name|orig_x
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|x
operator|=
name|orig_x
expr_stmt|;
goto|goto
name|success
goto|;
block|}
if|if
condition|(
name|noce_try_store_flag
argument_list|(
operator|&
name|if_info
argument_list|)
condition|)
goto|goto
name|success
goto|;
if|if
condition|(
name|noce_try_minmax
argument_list|(
operator|&
name|if_info
argument_list|)
condition|)
goto|goto
name|success
goto|;
if|if
condition|(
name|noce_try_abs
argument_list|(
operator|&
name|if_info
argument_list|)
condition|)
goto|goto
name|success
goto|;
if|if
condition|(
name|HAVE_conditional_move
operator|&&
name|noce_try_cmove
argument_list|(
operator|&
name|if_info
argument_list|)
condition|)
goto|goto
name|success
goto|;
if|if
condition|(
operator|!
name|HAVE_conditional_execution
condition|)
block|{
if|if
condition|(
name|noce_try_store_flag_constants
argument_list|(
operator|&
name|if_info
argument_list|)
condition|)
goto|goto
name|success
goto|;
if|if
condition|(
name|noce_try_store_flag_inc
argument_list|(
operator|&
name|if_info
argument_list|)
condition|)
goto|goto
name|success
goto|;
if|if
condition|(
name|noce_try_store_flag_mask
argument_list|(
operator|&
name|if_info
argument_list|)
condition|)
goto|goto
name|success
goto|;
if|if
condition|(
name|HAVE_conditional_move
operator|&&
name|noce_try_cmove_arith
argument_list|(
operator|&
name|if_info
argument_list|)
condition|)
goto|goto
name|success
goto|;
block|}
return|return
name|FALSE
return|;
name|success
label|:
comment|/* The original sets may now be killed.  */
name|delete_insn
argument_list|(
name|insn_a
argument_list|)
expr_stmt|;
comment|/* Several special cases here: First, we may have reused insn_b above,      in which case insn_b is now NULL.  Second, we want to delete insn_b      if it came from the ELSE block, because follows the now correct      write that appears in the TEST block.  However, if we got insn_b from      the TEST block, it may in fact be loading data needed for the comparison.      We'll let life_analysis remove the insn if it's really dead.  */
if|if
condition|(
name|insn_b
operator|&&
name|else_bb
condition|)
name|delete_insn
argument_list|(
name|insn_b
argument_list|)
expr_stmt|;
comment|/* The new insns will have been inserted before cond_earliest.  We should      be able to remove the jump with impunity, but the condition itself may      have been modified by gcse to be shared across basic blocks.  */
name|delete_insn
argument_list|(
name|jump
argument_list|)
expr_stmt|;
comment|/* If we used a temporary, fix it up now.  */
if|if
condition|(
name|orig_x
operator|!=
name|x
condition|)
block|{
name|start_sequence
argument_list|()
expr_stmt|;
name|noce_emit_move_insn
argument_list|(
name|copy_rtx
argument_list|(
name|orig_x
argument_list|)
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|insn_b
operator|=
name|gen_sequence
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insn_after
argument_list|(
name|insn_b
argument_list|,
name|test_bb
operator|->
name|end
argument_list|)
expr_stmt|;
block|}
comment|/* Merge the blocks!  */
name|merge_if_block
argument_list|(
name|test_bb
argument_list|,
name|then_bb
argument_list|,
name|else_bb
argument_list|,
name|join_bb
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Attempt to convert an IF-THEN or IF-THEN-ELSE block into    straight line code.  Return true if successful.  */
end_comment

begin_function
specifier|static
name|int
name|process_if_block
parameter_list|(
name|test_bb
parameter_list|,
name|then_bb
parameter_list|,
name|else_bb
parameter_list|,
name|join_bb
parameter_list|)
name|basic_block
name|test_bb
decl_stmt|;
comment|/* Basic block test is in */
name|basic_block
name|then_bb
decl_stmt|;
comment|/* Basic block for THEN block */
name|basic_block
name|else_bb
decl_stmt|;
comment|/* Basic block for ELSE block */
name|basic_block
name|join_bb
decl_stmt|;
comment|/* Basic block the join label is in */
block|{
if|if
condition|(
operator|!
name|reload_completed
operator|&&
name|noce_process_if_block
argument_list|(
name|test_bb
argument_list|,
name|then_bb
argument_list|,
name|else_bb
argument_list|,
name|join_bb
argument_list|)
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|HAVE_conditional_execution
operator|&&
name|reload_completed
operator|&&
name|cond_exec_process_if_block
argument_list|(
name|test_bb
argument_list|,
name|then_bb
argument_list|,
name|else_bb
argument_list|,
name|join_bb
argument_list|)
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Merge the blocks and mark for local life update.  */
end_comment

begin_function
specifier|static
name|void
name|merge_if_block
parameter_list|(
name|test_bb
parameter_list|,
name|then_bb
parameter_list|,
name|else_bb
parameter_list|,
name|join_bb
parameter_list|)
name|basic_block
name|test_bb
decl_stmt|;
comment|/* Basic block test is in */
name|basic_block
name|then_bb
decl_stmt|;
comment|/* Basic block for THEN block */
name|basic_block
name|else_bb
decl_stmt|;
comment|/* Basic block for ELSE block */
name|basic_block
name|join_bb
decl_stmt|;
comment|/* Basic block the join label is in */
block|{
name|basic_block
name|combo_bb
decl_stmt|;
comment|/* All block merging is done into the lower block numbers.  */
name|combo_bb
operator|=
name|test_bb
expr_stmt|;
comment|/* First merge TEST block into THEN block.  This is a no-brainer since      the THEN block did not have a code label to begin with.  */
if|if
condition|(
name|life_data_ok
condition|)
name|COPY_REG_SET
argument_list|(
name|combo_bb
operator|->
name|global_live_at_end
argument_list|,
name|then_bb
operator|->
name|global_live_at_end
argument_list|)
expr_stmt|;
name|merge_blocks_nomove
argument_list|(
name|combo_bb
argument_list|,
name|then_bb
argument_list|)
expr_stmt|;
name|num_removed_blocks
operator|++
expr_stmt|;
comment|/* The ELSE block, if it existed, had a label.  That label count      will almost always be zero, but odd things can happen when labels      get their addresses taken.  */
if|if
condition|(
name|else_bb
condition|)
block|{
name|merge_blocks_nomove
argument_list|(
name|combo_bb
argument_list|,
name|else_bb
argument_list|)
expr_stmt|;
name|num_removed_blocks
operator|++
expr_stmt|;
block|}
comment|/* If there was no join block reported, that means it was not adjacent      to the others, and so we cannot merge them.  */
if|if
condition|(
operator|!
name|join_bb
condition|)
block|{
comment|/* The outgoing edge for the current COMBO block should already 	 be correct.  Verify this.  */
if|if
condition|(
name|combo_bb
operator|->
name|succ
operator|==
name|NULL_EDGE
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* There should still be a branch at the end of the THEN or ELSE          blocks taking us to our final destination.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|combo_bb
operator|->
name|end
argument_list|)
operator|!=
name|JUMP_INSN
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* The JOIN block may have had quite a number of other predecessors too.      Since we've already merged the TEST, THEN and ELSE blocks, we should      have only one remaining edge from our if-then-else diamond.  If there      is more than one remaining edge, it must come from elsewhere.  There      may be zero incoming edges if the THEN block didn't actually join       back up (as with a call to abort).  */
elseif|else
if|if
condition|(
operator|(
name|join_bb
operator|->
name|pred
operator|==
name|NULL
operator|||
name|join_bb
operator|->
name|pred
operator|->
name|pred_next
operator|==
name|NULL
operator|)
operator|&&
name|join_bb
operator|!=
name|EXIT_BLOCK_PTR
condition|)
block|{
comment|/* We can merge the JOIN.  */
if|if
condition|(
name|life_data_ok
condition|)
name|COPY_REG_SET
argument_list|(
name|combo_bb
operator|->
name|global_live_at_end
argument_list|,
name|join_bb
operator|->
name|global_live_at_end
argument_list|)
expr_stmt|;
name|merge_blocks_nomove
argument_list|(
name|combo_bb
argument_list|,
name|join_bb
argument_list|)
expr_stmt|;
name|num_removed_blocks
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* We cannot merge the JOIN.  */
comment|/* The outgoing edge for the current COMBO block should already 	 be correct.  Verify this.  */
if|if
condition|(
name|combo_bb
operator|->
name|succ
operator|->
name|succ_next
operator|!=
name|NULL_EDGE
operator|||
name|combo_bb
operator|->
name|succ
operator|->
name|dest
operator|!=
name|join_bb
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Remove the jump and cruft from the end of the COMBO block.  */
if|if
condition|(
name|join_bb
operator|!=
name|EXIT_BLOCK_PTR
condition|)
name|tidy_fallthru_edge
argument_list|(
name|combo_bb
operator|->
name|succ
argument_list|,
name|combo_bb
argument_list|,
name|join_bb
argument_list|)
expr_stmt|;
block|}
comment|/* Make sure we update life info properly.  */
name|SET_UPDATE_LIFE
argument_list|(
name|combo_bb
argument_list|)
expr_stmt|;
name|num_updated_if_blocks
operator|++
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find a block ending in a simple IF condition.  Return TRUE if    we were able to transform it in some way.  */
end_comment

begin_function
specifier|static
name|int
name|find_if_header
parameter_list|(
name|test_bb
parameter_list|)
name|basic_block
name|test_bb
decl_stmt|;
block|{
name|edge
name|then_edge
decl_stmt|;
name|edge
name|else_edge
decl_stmt|;
comment|/* The kind of block we're looking for has exactly two successors.  */
if|if
condition|(
operator|(
name|then_edge
operator|=
name|test_bb
operator|->
name|succ
operator|)
operator|==
name|NULL_EDGE
operator|||
operator|(
name|else_edge
operator|=
name|then_edge
operator|->
name|succ_next
operator|)
operator|==
name|NULL_EDGE
operator|||
name|else_edge
operator|->
name|succ_next
operator|!=
name|NULL_EDGE
condition|)
return|return
name|FALSE
return|;
comment|/* Neither edge should be abnormal.  */
if|if
condition|(
operator|(
name|then_edge
operator|->
name|flags
operator|&
name|EDGE_COMPLEX
operator|)
operator|||
operator|(
name|else_edge
operator|->
name|flags
operator|&
name|EDGE_COMPLEX
operator|)
condition|)
return|return
name|FALSE
return|;
comment|/* The THEN edge is canonically the one that falls through.  */
if|if
condition|(
name|then_edge
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|else_edge
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
condition|)
block|{
name|edge
name|e
init|=
name|else_edge
decl_stmt|;
name|else_edge
operator|=
name|then_edge
expr_stmt|;
name|then_edge
operator|=
name|e
expr_stmt|;
block|}
else|else
comment|/* Otherwise this must be a multiway branch of some sort.  */
return|return
name|FALSE
return|;
if|if
condition|(
name|find_if_block
argument_list|(
name|test_bb
argument_list|,
name|then_edge
argument_list|,
name|else_edge
argument_list|)
condition|)
goto|goto
name|success
goto|;
if|if
condition|(
name|HAVE_trap
operator|&&
name|HAVE_conditional_trap
operator|&&
name|find_cond_trap
argument_list|(
name|test_bb
argument_list|,
name|then_edge
argument_list|,
name|else_edge
argument_list|)
condition|)
goto|goto
name|success
goto|;
if|if
condition|(
name|post_dominators
operator|&&
operator|(
operator|!
name|HAVE_conditional_execution
operator|||
name|reload_completed
operator|)
condition|)
block|{
if|if
condition|(
name|find_if_case_1
argument_list|(
name|test_bb
argument_list|,
name|then_edge
argument_list|,
name|else_edge
argument_list|)
condition|)
goto|goto
name|success
goto|;
if|if
condition|(
name|find_if_case_2
argument_list|(
name|test_bb
argument_list|,
name|then_edge
argument_list|,
name|else_edge
argument_list|)
condition|)
goto|goto
name|success
goto|;
block|}
return|return
name|FALSE
return|;
name|success
label|:
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Conversion succeeded.\n"
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Determine if a given basic block heads a simple IF-THEN or IF-THEN-ELSE    block.  If so, we'll try to convert the insns to not require the branch.    Return TRUE if we were successful at converting the the block.  */
end_comment

begin_function
specifier|static
name|int
name|find_if_block
parameter_list|(
name|test_bb
parameter_list|,
name|then_edge
parameter_list|,
name|else_edge
parameter_list|)
name|basic_block
name|test_bb
decl_stmt|;
name|edge
name|then_edge
decl_stmt|,
name|else_edge
decl_stmt|;
block|{
name|basic_block
name|then_bb
init|=
name|then_edge
operator|->
name|dest
decl_stmt|;
name|basic_block
name|else_bb
init|=
name|else_edge
operator|->
name|dest
decl_stmt|;
name|basic_block
name|join_bb
init|=
name|NULL_BLOCK
decl_stmt|;
name|edge
name|then_succ
init|=
name|then_bb
operator|->
name|succ
decl_stmt|;
name|edge
name|else_succ
init|=
name|else_bb
operator|->
name|succ
decl_stmt|;
name|int
name|next_index
decl_stmt|;
comment|/* The THEN block of an IF-THEN combo must have exactly one predecessor.  */
if|if
condition|(
name|then_bb
operator|->
name|pred
operator|->
name|pred_next
operator|!=
name|NULL_EDGE
condition|)
return|return
name|FALSE
return|;
comment|/* The THEN block of an IF-THEN combo must have zero or one successors.  */
if|if
condition|(
name|then_succ
operator|!=
name|NULL_EDGE
operator|&&
operator|(
name|then_succ
operator|->
name|succ_next
operator|!=
name|NULL_EDGE
operator|||
operator|(
name|then_succ
operator|->
name|flags
operator|&
name|EDGE_COMPLEX
operator|)
operator|)
condition|)
return|return
name|FALSE
return|;
comment|/* If the THEN block has no successors, conditional execution can still      make a conditional call.  Don't do this unless the ELSE block has      only one incoming edge -- the CFG manipulation is too ugly otherwise.      Check for the last insn of the THEN block being an indirect jump, which      is listed as not having any successors, but confuses the rest of the CE      code processing.  XXX we should fix this in the future.  */
if|if
condition|(
name|then_succ
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|else_bb
operator|->
name|pred
operator|->
name|pred_next
operator|==
name|NULL_EDGE
condition|)
block|{
name|rtx
name|last_insn
init|=
name|then_bb
operator|->
name|end
decl_stmt|;
while|while
condition|(
name|last_insn
operator|&&
name|GET_CODE
argument_list|(
name|last_insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|last_insn
operator|!=
name|then_bb
operator|->
name|head
condition|)
name|last_insn
operator|=
name|PREV_INSN
argument_list|(
name|last_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_insn
operator|&&
name|GET_CODE
argument_list|(
name|last_insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
operator|!
name|simplejump_p
argument_list|(
name|last_insn
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|join_bb
operator|=
name|else_bb
expr_stmt|;
name|else_bb
operator|=
name|NULL_BLOCK
expr_stmt|;
block|}
else|else
return|return
name|FALSE
return|;
block|}
comment|/* If the THEN block's successor is the other edge out of the TEST block,      then we have an IF-THEN combo without an ELSE.  */
elseif|else
if|if
condition|(
name|then_succ
operator|->
name|dest
operator|==
name|else_bb
condition|)
block|{
name|join_bb
operator|=
name|else_bb
expr_stmt|;
name|else_bb
operator|=
name|NULL_BLOCK
expr_stmt|;
block|}
comment|/* If the THEN and ELSE block meet in a subsequent block, and the ELSE      has exactly one predecessor and one successor, and the outgoing edge      is not complex, then we have an IF-THEN-ELSE combo.  */
elseif|else
if|if
condition|(
name|else_succ
operator|!=
name|NULL_EDGE
operator|&&
name|then_succ
operator|->
name|dest
operator|==
name|else_succ
operator|->
name|dest
operator|&&
name|else_bb
operator|->
name|pred
operator|->
name|pred_next
operator|==
name|NULL_EDGE
operator|&&
name|else_succ
operator|->
name|succ_next
operator|==
name|NULL_EDGE
operator|&&
operator|!
operator|(
name|else_succ
operator|->
name|flags
operator|&
name|EDGE_COMPLEX
operator|)
condition|)
name|join_bb
operator|=
name|else_succ
operator|->
name|dest
expr_stmt|;
comment|/* Otherwise it is not an IF-THEN or IF-THEN-ELSE combination.  */
else|else
return|return
name|FALSE
return|;
name|num_possible_if_blocks
operator|++
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
block|{
if|if
condition|(
name|else_bb
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"\nIF-THEN-ELSE block found, start %d, then %d, else %d, join %d\n"
argument_list|,
name|test_bb
operator|->
name|index
argument_list|,
name|then_bb
operator|->
name|index
argument_list|,
name|else_bb
operator|->
name|index
argument_list|,
name|join_bb
operator|->
name|index
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"\nIF-THEN block found, start %d, then %d, join %d\n"
argument_list|,
name|test_bb
operator|->
name|index
argument_list|,
name|then_bb
operator|->
name|index
argument_list|,
name|join_bb
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
comment|/* Make sure IF, THEN, and ELSE, blocks are adjacent.  Actually, we      get the first condition for free, since we've already asserted that      there's a fallthru edge from IF to THEN.  */
comment|/* ??? As an enhancement, move the ELSE block.  Have to deal with      BLOCK notes, if by no other means than aborting the merge if they      exist.  Sticky enough I don't want to think about it now.  */
name|next_index
operator|=
name|then_bb
operator|->
name|index
expr_stmt|;
if|if
condition|(
name|else_bb
operator|&&
operator|++
name|next_index
operator|!=
name|else_bb
operator|->
name|index
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|++
name|next_index
operator|!=
name|join_bb
operator|->
name|index
operator|&&
name|join_bb
operator|->
name|index
operator|!=
name|EXIT_BLOCK
condition|)
block|{
if|if
condition|(
name|else_bb
condition|)
name|join_bb
operator|=
name|NULL
expr_stmt|;
else|else
return|return
name|FALSE
return|;
block|}
comment|/* Do the real work.  */
return|return
name|process_if_block
argument_list|(
name|test_bb
argument_list|,
name|then_bb
argument_list|,
name|else_bb
argument_list|,
name|join_bb
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Convert a branch over a trap, or a branch to a trap,    into a conditional trap.  */
end_comment

begin_function
specifier|static
name|int
name|find_cond_trap
parameter_list|(
name|test_bb
parameter_list|,
name|then_edge
parameter_list|,
name|else_edge
parameter_list|)
name|basic_block
name|test_bb
decl_stmt|;
name|edge
name|then_edge
decl_stmt|,
name|else_edge
decl_stmt|;
block|{
name|basic_block
name|then_bb
decl_stmt|,
name|else_bb
decl_stmt|,
name|join_bb
decl_stmt|,
name|trap_bb
decl_stmt|;
name|rtx
name|trap
decl_stmt|,
name|jump
decl_stmt|,
name|cond
decl_stmt|,
name|cond_earliest
decl_stmt|,
name|seq
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
name|then_bb
operator|=
name|then_edge
operator|->
name|dest
expr_stmt|;
name|else_bb
operator|=
name|else_edge
operator|->
name|dest
expr_stmt|;
name|join_bb
operator|=
name|NULL
expr_stmt|;
comment|/* Locate the block with the trap instruction.  */
comment|/* ??? While we look for no successors, we really ought to allow      EH successors.  Need to fix merge_if_block for that to work.  */
comment|/* ??? We can't currently handle merging the blocks if they are not      already adjacent.  Prevent losage in merge_if_block by detecting      this now.  */
if|if
condition|(
name|then_bb
operator|->
name|succ
operator|==
name|NULL
condition|)
block|{
name|trap_bb
operator|=
name|then_bb
expr_stmt|;
if|if
condition|(
name|else_bb
operator|->
name|index
operator|!=
name|then_bb
operator|->
name|index
operator|+
literal|1
condition|)
return|return
name|FALSE
return|;
name|join_bb
operator|=
name|else_bb
expr_stmt|;
name|else_bb
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|else_bb
operator|->
name|succ
operator|==
name|NULL
condition|)
block|{
name|trap_bb
operator|=
name|else_bb
expr_stmt|;
if|if
condition|(
name|else_bb
operator|->
name|index
operator|!=
name|then_bb
operator|->
name|index
operator|+
literal|1
condition|)
name|else_bb
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
name|then_bb
operator|->
name|succ
operator|&&
operator|!
name|then_bb
operator|->
name|succ
operator|->
name|succ_next
operator|&&
operator|!
operator|(
name|then_bb
operator|->
name|succ
operator|->
name|flags
operator|&
name|EDGE_COMPLEX
operator|)
operator|&&
name|then_bb
operator|->
name|succ
operator|->
name|dest
operator|->
name|index
operator|==
name|else_bb
operator|->
name|index
operator|+
literal|1
condition|)
name|join_bb
operator|=
name|then_bb
operator|->
name|succ
operator|->
name|dest
expr_stmt|;
block|}
else|else
return|return
name|FALSE
return|;
comment|/* Don't confuse a conditional return with something we want to      optimize here.  */
if|if
condition|(
name|trap_bb
operator|==
name|EXIT_BLOCK_PTR
condition|)
return|return
name|FALSE
return|;
comment|/* The only instruction in the THEN block must be the trap.  */
name|trap
operator|=
name|first_active_insn
argument_list|(
name|trap_bb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|trap
operator|==
name|trap_bb
operator|->
name|end
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|trap
argument_list|)
argument_list|)
operator|==
name|TRAP_IF
operator|&&
name|TRAP_CONDITION
argument_list|(
name|PATTERN
argument_list|(
name|trap
argument_list|)
argument_list|)
operator|==
name|const_true_rtx
operator|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|rtl_dump_file
condition|)
block|{
if|if
condition|(
name|trap_bb
operator|==
name|then_bb
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"\nTRAP-IF block found, start %d, trap %d"
argument_list|,
name|test_bb
operator|->
name|index
argument_list|,
name|then_bb
operator|->
name|index
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"\nTRAP-IF block found, start %d, then %d, trap %d"
argument_list|,
name|test_bb
operator|->
name|index
argument_list|,
name|then_bb
operator|->
name|index
argument_list|,
name|trap_bb
operator|->
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|join_bb
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|", join %d\n"
argument_list|,
name|join_bb
operator|->
name|index
argument_list|)
expr_stmt|;
else|else
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|rtl_dump_file
argument_list|)
expr_stmt|;
block|}
comment|/* If this is not a standard conditional jump, we can't parse it.  */
name|jump
operator|=
name|test_bb
operator|->
name|end
expr_stmt|;
name|cond
operator|=
name|noce_get_condition
argument_list|(
name|jump
argument_list|,
operator|&
name|cond_earliest
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cond
condition|)
return|return
name|FALSE
return|;
comment|/* If the conditional jump is more than just a conditional jump,      then we can not do if-conversion on this block.  */
if|if
condition|(
operator|!
name|onlyjump_p
argument_list|(
name|jump
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* We must be comparing objects whose modes imply the size.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|BLKmode
condition|)
return|return
name|FALSE
return|;
comment|/* Reverse the comparison code, if necessary.  */
name|code
operator|=
name|GET_CODE
argument_list|(
name|cond
argument_list|)
expr_stmt|;
if|if
condition|(
name|then_bb
operator|==
name|trap_bb
condition|)
block|{
name|code
operator|=
name|reversed_comparison_code
argument_list|(
name|cond
argument_list|,
name|jump
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|UNKNOWN
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* Attempt to generate the conditional trap.  */
name|seq
operator|=
name|gen_cond_trap
argument_list|(
name|code
argument_list|,
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TRAP_CODE
argument_list|(
name|PATTERN
argument_list|(
name|trap
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|seq
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
comment|/* Emit the new insns before cond_earliest; delete the old jump      and trap insns.  */
name|emit_insn_before
argument_list|(
name|seq
argument_list|,
name|cond_earliest
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|jump
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|trap
argument_list|)
expr_stmt|;
comment|/* Merge the blocks!  */
if|if
condition|(
name|trap_bb
operator|!=
name|then_bb
operator|&&
operator|!
name|else_bb
condition|)
block|{
name|flow_delete_block
argument_list|(
name|trap_bb
argument_list|)
expr_stmt|;
name|num_removed_blocks
operator|++
expr_stmt|;
block|}
name|merge_if_block
argument_list|(
name|test_bb
argument_list|,
name|then_bb
argument_list|,
name|else_bb
argument_list|,
name|join_bb
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Look for IF-THEN-ELSE cases in which one of THEN or ELSE is    transformable, but not necessarily the other.  There need be no    JOIN block.     Return TRUE if we were successful at converting the the block.     Cases we'd like to look at:     (1) 	if (test) goto over; // x not live 	x = a; 	goto label; 	over:     becomes  	x = a; 	if (! test) goto label;     (2) 	if (test) goto E; // x not live 	x = big(); 	goto L; 	E: 	x = b; 	goto M;     becomes  	x = b; 	if (test) goto M; 	x = big(); 	goto L;     (3) // This one's really only interesting for targets that can do        // multiway branching, e.g. IA-64 BBB bundles.  For other targets        // it results in multiple branches on a cache line, which often        // does not sit well with predictors.  	if (test1) goto E; // predicted not taken 	x = a; 	if (test2) goto F; 	... 	E: 	x = b; 	J:     becomes  	x = a; 	if (test1) goto E; 	if (test2) goto F;     Notes:     (A) Don't do (2) if the branch is predicted against the block we're    eliminating.  Do it anyway if we can eliminate a branch; this requires    that the sole successor of the eliminated block postdominate the other    side of the if.     (B) With CE, on (3) we can steal from both sides of the if, creating  	if (test1) x = a; 	if (!test1) x = b; 	if (test1) goto J; 	if (test2) goto F; 	... 	J:     Again, this is most useful if J postdominates.     (C) CE substitutes for helpful life information.     (D) These heuristics need a lot of work.  */
end_comment

begin_comment
comment|/* Tests for case 1 above.  */
end_comment

begin_function
specifier|static
name|int
name|find_if_case_1
parameter_list|(
name|test_bb
parameter_list|,
name|then_edge
parameter_list|,
name|else_edge
parameter_list|)
name|basic_block
name|test_bb
decl_stmt|;
name|edge
name|then_edge
decl_stmt|,
name|else_edge
decl_stmt|;
block|{
name|basic_block
name|then_bb
init|=
name|then_edge
operator|->
name|dest
decl_stmt|;
name|basic_block
name|else_bb
init|=
name|else_edge
operator|->
name|dest
decl_stmt|,
name|new_bb
decl_stmt|;
name|edge
name|then_succ
init|=
name|then_bb
operator|->
name|succ
decl_stmt|;
comment|/* THEN has one successor.  */
if|if
condition|(
operator|!
name|then_succ
operator|||
name|then_succ
operator|->
name|succ_next
operator|!=
name|NULL
condition|)
return|return
name|FALSE
return|;
comment|/* THEN does not fall through, but is not strange either.  */
if|if
condition|(
name|then_succ
operator|->
name|flags
operator|&
operator|(
name|EDGE_COMPLEX
operator||
name|EDGE_FALLTHRU
operator|)
condition|)
return|return
name|FALSE
return|;
comment|/* THEN has one predecessor.  */
if|if
condition|(
name|then_bb
operator|->
name|pred
operator|->
name|pred_next
operator|!=
name|NULL
condition|)
return|return
name|FALSE
return|;
comment|/* THEN must do something.  */
if|if
condition|(
name|forwarder_block_p
argument_list|(
name|then_bb
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|num_possible_if_blocks
operator|++
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"\nIF-CASE-1 found, start %d, then %d\n"
argument_list|,
name|test_bb
operator|->
name|index
argument_list|,
name|then_bb
operator|->
name|index
argument_list|)
expr_stmt|;
comment|/* THEN is small.  */
if|if
condition|(
name|count_bb_insns
argument_list|(
name|then_bb
argument_list|)
operator|>
name|BRANCH_COST
condition|)
return|return
name|FALSE
return|;
comment|/* Registers set are dead, or are predicable.  */
if|if
condition|(
operator|!
name|dead_or_predicable
argument_list|(
name|test_bb
argument_list|,
name|then_bb
argument_list|,
name|else_bb
argument_list|,
name|then_bb
operator|->
name|succ
operator|->
name|dest
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Conversion went ok, including moving the insns and fixing up the      jump.  Adjust the CFG to match.  */
name|SET_UPDATE_LIFE
argument_list|(
name|test_bb
argument_list|)
expr_stmt|;
name|bitmap_operation
argument_list|(
name|test_bb
operator|->
name|global_live_at_end
argument_list|,
name|else_bb
operator|->
name|global_live_at_start
argument_list|,
name|then_bb
operator|->
name|global_live_at_end
argument_list|,
name|BITMAP_IOR
argument_list|)
expr_stmt|;
name|new_bb
operator|=
name|redirect_edge_and_branch_force
argument_list|(
name|FALLTHRU_EDGE
argument_list|(
name|test_bb
argument_list|)
argument_list|,
name|else_bb
argument_list|)
expr_stmt|;
comment|/* Make rest of code believe that the newly created block is the THEN_BB      block we are going to remove.  */
if|if
condition|(
name|new_bb
condition|)
block|{
name|new_bb
operator|->
name|aux
operator|=
name|then_bb
operator|->
name|aux
expr_stmt|;
name|SET_UPDATE_LIFE
argument_list|(
name|then_bb
argument_list|)
expr_stmt|;
block|}
name|flow_delete_block
argument_list|(
name|then_bb
argument_list|)
expr_stmt|;
comment|/* We've possibly created jump to next insn, cleanup_cfg will solve that      later.  */
name|num_removed_blocks
operator|++
expr_stmt|;
name|num_updated_if_blocks
operator|++
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Test for case 2 above.  */
end_comment

begin_function
specifier|static
name|int
name|find_if_case_2
parameter_list|(
name|test_bb
parameter_list|,
name|then_edge
parameter_list|,
name|else_edge
parameter_list|)
name|basic_block
name|test_bb
decl_stmt|;
name|edge
name|then_edge
decl_stmt|,
name|else_edge
decl_stmt|;
block|{
name|basic_block
name|then_bb
init|=
name|then_edge
operator|->
name|dest
decl_stmt|;
name|basic_block
name|else_bb
init|=
name|else_edge
operator|->
name|dest
decl_stmt|;
name|edge
name|else_succ
init|=
name|else_bb
operator|->
name|succ
decl_stmt|;
name|rtx
name|note
decl_stmt|;
comment|/* ELSE has one successor.  */
if|if
condition|(
operator|!
name|else_succ
operator|||
name|else_succ
operator|->
name|succ_next
operator|!=
name|NULL
condition|)
return|return
name|FALSE
return|;
comment|/* ELSE outgoing edge is not complex.  */
if|if
condition|(
name|else_succ
operator|->
name|flags
operator|&
name|EDGE_COMPLEX
condition|)
return|return
name|FALSE
return|;
comment|/* ELSE has one predecessor.  */
if|if
condition|(
name|else_bb
operator|->
name|pred
operator|->
name|pred_next
operator|!=
name|NULL
condition|)
return|return
name|FALSE
return|;
comment|/* THEN is not EXIT.  */
if|if
condition|(
name|then_bb
operator|->
name|index
operator|<
literal|0
condition|)
return|return
name|FALSE
return|;
comment|/* ELSE is predicted or SUCC(ELSE) postdominates THEN.  */
name|note
operator|=
name|find_reg_note
argument_list|(
name|test_bb
operator|->
name|end
argument_list|,
name|REG_BR_PROB
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|note
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>=
name|REG_BR_PROB_BASE
operator|/
literal|2
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|else_succ
operator|->
name|dest
operator|->
name|index
operator|<
literal|0
operator|||
name|TEST_BIT
argument_list|(
name|post_dominators
index|[
name|ORIG_INDEX
argument_list|(
name|then_bb
argument_list|)
index|]
argument_list|,
name|ORIG_INDEX
argument_list|(
name|else_succ
operator|->
name|dest
argument_list|)
argument_list|)
condition|)
empty_stmt|;
else|else
return|return
name|FALSE
return|;
name|num_possible_if_blocks
operator|++
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"\nIF-CASE-2 found, start %d, else %d\n"
argument_list|,
name|test_bb
operator|->
name|index
argument_list|,
name|else_bb
operator|->
name|index
argument_list|)
expr_stmt|;
comment|/* ELSE is small.  */
if|if
condition|(
name|count_bb_insns
argument_list|(
name|then_bb
argument_list|)
operator|>
name|BRANCH_COST
condition|)
return|return
name|FALSE
return|;
comment|/* Registers set are dead, or are predicable.  */
if|if
condition|(
operator|!
name|dead_or_predicable
argument_list|(
name|test_bb
argument_list|,
name|else_bb
argument_list|,
name|then_bb
argument_list|,
name|else_succ
operator|->
name|dest
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Conversion went ok, including moving the insns and fixing up the      jump.  Adjust the CFG to match.  */
name|SET_UPDATE_LIFE
argument_list|(
name|test_bb
argument_list|)
expr_stmt|;
name|bitmap_operation
argument_list|(
name|test_bb
operator|->
name|global_live_at_end
argument_list|,
name|then_bb
operator|->
name|global_live_at_start
argument_list|,
name|else_bb
operator|->
name|global_live_at_end
argument_list|,
name|BITMAP_IOR
argument_list|)
expr_stmt|;
name|flow_delete_block
argument_list|(
name|else_bb
argument_list|)
expr_stmt|;
name|num_removed_blocks
operator|++
expr_stmt|;
name|num_updated_if_blocks
operator|++
expr_stmt|;
comment|/* ??? We may now fallthru from one of THEN's successors into a join      block.  Rerun cleanup_cfg?  Examine things manually?  Wait?  */
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of dead_or_predicable called through for_each_rtx.    Return 1 if a memory is found.  */
end_comment

begin_function
specifier|static
name|int
name|find_memory
parameter_list|(
name|px
parameter_list|,
name|data
parameter_list|)
name|rtx
modifier|*
name|px
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
name|GET_CODE
argument_list|(
operator|*
name|px
argument_list|)
operator|==
name|MEM
return|;
block|}
end_function

begin_comment
comment|/* Used by the code above to perform the actual rtl transformations.    Return TRUE if successful.     TEST_BB is the block containing the conditional branch.  MERGE_BB    is the block containing the code to manipulate.  NEW_DEST is the    label TEST_BB should be branching to after the conversion.    REVERSEP is true if the sense of the branch should be reversed.  */
end_comment

begin_function
specifier|static
name|int
name|dead_or_predicable
parameter_list|(
name|test_bb
parameter_list|,
name|merge_bb
parameter_list|,
name|other_bb
parameter_list|,
name|new_dest
parameter_list|,
name|reversep
parameter_list|)
name|basic_block
name|test_bb
decl_stmt|,
name|merge_bb
decl_stmt|,
name|other_bb
decl_stmt|;
name|basic_block
name|new_dest
decl_stmt|;
name|int
name|reversep
decl_stmt|;
block|{
name|rtx
name|head
decl_stmt|,
name|end
decl_stmt|,
name|jump
decl_stmt|,
name|earliest
decl_stmt|,
name|old_dest
decl_stmt|,
name|new_label
decl_stmt|;
name|jump
operator|=
name|test_bb
operator|->
name|end
expr_stmt|;
comment|/* Find the extent of the real code in the merge block.  */
name|head
operator|=
name|merge_bb
operator|->
name|head
expr_stmt|;
name|end
operator|=
name|merge_bb
operator|->
name|end
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|head
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|head
operator|=
name|NEXT_INSN
argument_list|(
name|head
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|head
argument_list|)
operator|==
name|NOTE
condition|)
block|{
if|if
condition|(
name|head
operator|==
name|end
condition|)
block|{
name|head
operator|=
name|end
operator|=
name|NULL_RTX
expr_stmt|;
goto|goto
name|no_body
goto|;
block|}
name|head
operator|=
name|NEXT_INSN
argument_list|(
name|head
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|end
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
if|if
condition|(
name|head
operator|==
name|end
condition|)
block|{
name|head
operator|=
name|end
operator|=
name|NULL_RTX
expr_stmt|;
goto|goto
name|no_body
goto|;
block|}
name|end
operator|=
name|PREV_INSN
argument_list|(
name|end
argument_list|)
expr_stmt|;
block|}
comment|/* Disable handling dead code by conditional execution if the machine needs      to do anything funny with the tests, etc.  */
ifndef|#
directive|ifndef
name|IFCVT_MODIFY_TESTS
if|if
condition|(
name|HAVE_conditional_execution
condition|)
block|{
comment|/* In the conditional execution case, we have things easy.  We know 	 the condition is reversable.  We don't have to check life info, 	 becase we're going to conditionally execute the code anyway. 	 All that's left is making sure the insns involved can actually 	 be predicated.  */
name|rtx
name|cond
decl_stmt|,
name|prob_val
decl_stmt|;
name|cond
operator|=
name|cond_exec_get_condition
argument_list|(
name|jump
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cond
condition|)
return|return
name|FALSE
return|;
name|prob_val
operator|=
name|find_reg_note
argument_list|(
name|jump
argument_list|,
name|REG_BR_PROB
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|prob_val
condition|)
name|prob_val
operator|=
name|XEXP
argument_list|(
name|prob_val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|reversep
condition|)
block|{
name|enum
name|rtx_code
name|rev
init|=
name|reversed_comparison_code
argument_list|(
name|cond
argument_list|,
name|jump
argument_list|)
decl_stmt|;
if|if
condition|(
name|rev
operator|==
name|UNKNOWN
condition|)
return|return
name|FALSE
return|;
name|cond
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|rev
argument_list|,
name|GET_MODE
argument_list|(
name|cond
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|prob_val
condition|)
name|prob_val
operator|=
name|GEN_INT
argument_list|(
name|REG_BR_PROB_BASE
operator|-
name|INTVAL
argument_list|(
name|prob_val
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|cond_exec_process_insns
argument_list|(
name|head
argument_list|,
name|end
argument_list|,
name|cond
argument_list|,
name|prob_val
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|cancel
goto|;
name|earliest
operator|=
name|jump
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
comment|/* In the non-conditional execution case, we have to verify that there 	 are no trapping operations, no calls, no references to memory, and 	 that any registers modified are dead at the branch site.  */
name|rtx
name|insn
decl_stmt|,
name|cond
decl_stmt|,
name|prev
decl_stmt|;
name|regset_head
name|merge_set_head
decl_stmt|,
name|tmp_head
decl_stmt|,
name|test_live_head
decl_stmt|,
name|test_set_head
decl_stmt|;
name|regset
name|merge_set
decl_stmt|,
name|tmp
decl_stmt|,
name|test_live
decl_stmt|,
name|test_set
decl_stmt|;
name|struct
name|propagate_block_info
modifier|*
name|pbi
decl_stmt|;
name|int
name|i
decl_stmt|,
name|fail
init|=
literal|0
decl_stmt|;
comment|/* Check for no calls or trapping operations.  */
for|for
control|(
name|insn
operator|=
name|head
init|;
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
if|if
condition|(
name|may_trap_p
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* ??? Even non-trapping memories such as stack frame 		 references must be avoided.  For stores, we collect 		 no lifetime info; for reads, we'd have to assert 		 true_dependence false against every store in the 		 TEST range.  */
if|if
condition|(
name|for_each_rtx
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|find_memory
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|insn
operator|==
name|end
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|any_condjump_p
argument_list|(
name|jump
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* Find the extent of the conditional.  */
name|cond
operator|=
name|noce_get_condition
argument_list|(
name|jump
argument_list|,
operator|&
name|earliest
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cond
condition|)
return|return
name|FALSE
return|;
comment|/* Collect: 	   MERGE_SET = set of registers set in MERGE_BB 	   TEST_LIVE = set of registers live at EARLIEST 	   TEST_SET  = set of registers set between EARLIEST and the 		       end of the block.  */
name|tmp
operator|=
name|INITIALIZE_REG_SET
argument_list|(
name|tmp_head
argument_list|)
expr_stmt|;
name|merge_set
operator|=
name|INITIALIZE_REG_SET
argument_list|(
name|merge_set_head
argument_list|)
expr_stmt|;
name|test_live
operator|=
name|INITIALIZE_REG_SET
argument_list|(
name|test_live_head
argument_list|)
expr_stmt|;
name|test_set
operator|=
name|INITIALIZE_REG_SET
argument_list|(
name|test_set_head
argument_list|)
expr_stmt|;
comment|/* ??? bb->local_set is only valid during calculate_global_regs_live, 	 so we must recompute usage for MERGE_BB.  Not so bad, I suppose,           since we've already asserted that MERGE_BB is small.  */
name|propagate_block
argument_list|(
name|merge_bb
argument_list|,
name|tmp
argument_list|,
name|merge_set
argument_list|,
name|merge_set
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* For small register class machines, don't lengthen lifetimes of 	 hard registers before reload.  */
if|if
condition|(
name|SMALL_REGISTER_CLASSES
operator|&&
operator|!
name|reload_completed
condition|)
block|{
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|merge_set
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|{ 	       if (i< FIRST_PSEUDO_REGISTER&& ! fixed_regs[i]&& ! global_regs[i]) 		fail =
literal|1
argument|; 	     }
argument_list|)
empty_stmt|;
block|}
comment|/* For TEST, we're interested in a range of insns, not a whole block. 	 Moreover, we're interested in the insns live from OTHER_BB.  */
name|COPY_REG_SET
argument_list|(
name|test_live
argument_list|,
name|other_bb
operator|->
name|global_live_at_start
argument_list|)
expr_stmt|;
name|pbi
operator|=
name|init_propagate_block_info
argument_list|(
name|test_bb
argument_list|,
name|test_live
argument_list|,
name|test_set
argument_list|,
name|test_set
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|jump
init|;
condition|;
name|insn
operator|=
name|prev
control|)
block|{
name|prev
operator|=
name|propagate_one_insn
argument_list|(
name|pbi
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|earliest
condition|)
break|break;
block|}
name|free_propagate_block_info
argument_list|(
name|pbi
argument_list|)
expr_stmt|;
comment|/* We can perform the transformation if 	   MERGE_SET& (TEST_SET | TEST_LIVE) 	 and 	   TEST_SET& merge_bb->global_live_at_start 	 are empty.  */
name|bitmap_operation
argument_list|(
name|tmp
argument_list|,
name|test_set
argument_list|,
name|test_live
argument_list|,
name|BITMAP_IOR
argument_list|)
expr_stmt|;
name|bitmap_operation
argument_list|(
name|tmp
argument_list|,
name|tmp
argument_list|,
name|merge_set
argument_list|,
name|BITMAP_AND
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|,
name|i
argument_list|,
name|fail
operator|=
literal|1
argument_list|)
expr_stmt|;
name|bitmap_operation
argument_list|(
name|tmp
argument_list|,
name|test_set
argument_list|,
name|merge_bb
operator|->
name|global_live_at_start
argument_list|,
name|BITMAP_AND
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|,
name|i
argument_list|,
name|fail
operator|=
literal|1
argument_list|)
expr_stmt|;
name|FREE_REG_SET
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|FREE_REG_SET
argument_list|(
name|merge_set
argument_list|)
expr_stmt|;
name|FREE_REG_SET
argument_list|(
name|test_live
argument_list|)
expr_stmt|;
name|FREE_REG_SET
argument_list|(
name|test_set
argument_list|)
expr_stmt|;
if|if
condition|(
name|fail
condition|)
return|return
name|FALSE
return|;
block|}
name|no_body
label|:
comment|/* We don't want to use normal invert_jump or redirect_jump because      we don't want to delete_insn called.  Also, we want to do our own      change group management.  */
name|old_dest
operator|=
name|JUMP_LABEL
argument_list|(
name|jump
argument_list|)
expr_stmt|;
if|if
condition|(
name|other_bb
operator|!=
name|new_dest
condition|)
block|{
name|new_label
operator|=
name|block_label
argument_list|(
name|new_dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|reversep
condition|?
operator|!
name|invert_jump_1
argument_list|(
name|jump
argument_list|,
name|new_label
argument_list|)
else|:
operator|!
name|redirect_jump_1
argument_list|(
name|jump
argument_list|,
name|new_label
argument_list|)
condition|)
goto|goto
name|cancel
goto|;
block|}
if|if
condition|(
operator|!
name|apply_change_group
argument_list|()
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|other_bb
operator|!=
name|new_dest
condition|)
block|{
if|if
condition|(
name|old_dest
condition|)
name|LABEL_NUSES
argument_list|(
name|old_dest
argument_list|)
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
name|new_label
condition|)
name|LABEL_NUSES
argument_list|(
name|new_label
argument_list|)
operator|+=
literal|1
expr_stmt|;
name|JUMP_LABEL
argument_list|(
name|jump
argument_list|)
operator|=
name|new_label
expr_stmt|;
if|if
condition|(
name|reversep
condition|)
name|invert_br_probabilities
argument_list|(
name|jump
argument_list|)
expr_stmt|;
name|redirect_edge_succ
argument_list|(
name|BRANCH_EDGE
argument_list|(
name|test_bb
argument_list|)
argument_list|,
name|new_dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|reversep
condition|)
block|{
name|gcov_type
name|count
decl_stmt|,
name|probability
decl_stmt|;
name|count
operator|=
name|BRANCH_EDGE
argument_list|(
name|test_bb
argument_list|)
operator|->
name|count
expr_stmt|;
name|BRANCH_EDGE
argument_list|(
name|test_bb
argument_list|)
operator|->
name|count
operator|=
name|FALLTHRU_EDGE
argument_list|(
name|test_bb
argument_list|)
operator|->
name|count
expr_stmt|;
name|FALLTHRU_EDGE
argument_list|(
name|test_bb
argument_list|)
operator|->
name|count
operator|=
name|count
expr_stmt|;
name|probability
operator|=
name|BRANCH_EDGE
argument_list|(
name|test_bb
argument_list|)
operator|->
name|probability
expr_stmt|;
name|BRANCH_EDGE
argument_list|(
name|test_bb
argument_list|)
operator|->
name|probability
operator|=
name|FALLTHRU_EDGE
argument_list|(
name|test_bb
argument_list|)
operator|->
name|probability
expr_stmt|;
name|FALLTHRU_EDGE
argument_list|(
name|test_bb
argument_list|)
operator|->
name|probability
operator|=
name|probability
expr_stmt|;
name|update_br_prob_note
argument_list|(
name|test_bb
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Move the insns out of MERGE_BB to before the branch.  */
if|if
condition|(
name|head
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|end
operator|==
name|merge_bb
operator|->
name|end
condition|)
name|merge_bb
operator|->
name|end
operator|=
name|PREV_INSN
argument_list|(
name|head
argument_list|)
expr_stmt|;
if|if
condition|(
name|squeeze_notes
argument_list|(
operator|&
name|head
argument_list|,
operator|&
name|end
argument_list|)
condition|)
return|return
name|TRUE
return|;
name|reorder_insns
argument_list|(
name|head
argument_list|,
name|end
argument_list|,
name|PREV_INSN
argument_list|(
name|earliest
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Remove the jump and edge if we can.  */
if|if
condition|(
name|other_bb
operator|==
name|new_dest
condition|)
block|{
name|delete_insn
argument_list|(
name|jump
argument_list|)
expr_stmt|;
name|remove_edge
argument_list|(
name|BRANCH_EDGE
argument_list|(
name|test_bb
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ??? Can't merge blocks here, as then_bb is still in use. 	 At minimum, the merge will get done just before bb-reorder.  */
block|}
return|return
name|TRUE
return|;
name|cancel
label|:
name|cancel_changes
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Main entry point for all if-conversion.  */
end_comment

begin_function
name|void
name|if_convert
parameter_list|(
name|x_life_data_ok
parameter_list|)
name|int
name|x_life_data_ok
decl_stmt|;
block|{
name|int
name|block_num
decl_stmt|;
name|num_possible_if_blocks
operator|=
literal|0
expr_stmt|;
name|num_updated_if_blocks
operator|=
literal|0
expr_stmt|;
name|num_removed_blocks
operator|=
literal|0
expr_stmt|;
name|life_data_ok
operator|=
operator|(
name|x_life_data_ok
operator|!=
literal|0
operator|)
expr_stmt|;
comment|/* Free up basic_block_for_insn so that we don't have to keep it       up to date, either here or in merge_blocks_nomove.  */
name|free_basic_block_vars
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Compute postdominators if we think we'll use them.  */
name|post_dominators
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|HAVE_conditional_execution
operator|||
name|life_data_ok
condition|)
block|{
name|post_dominators
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_basic_blocks
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|calculate_dominance_info
argument_list|(
name|NULL
argument_list|,
name|post_dominators
argument_list|,
name|CDI_POST_DOMINATORS
argument_list|)
expr_stmt|;
block|}
comment|/* Record initial block numbers.  */
for|for
control|(
name|block_num
operator|=
literal|0
init|;
name|block_num
operator|<
name|n_basic_blocks
condition|;
name|block_num
operator|++
control|)
name|SET_ORIG_INDEX
argument_list|(
name|BASIC_BLOCK
argument_list|(
name|block_num
argument_list|)
argument_list|,
name|block_num
argument_list|)
expr_stmt|;
comment|/* Go through each of the basic blocks looking for things to convert.  */
for|for
control|(
name|block_num
operator|=
literal|0
init|;
name|block_num
operator|<
name|n_basic_blocks
condition|;
control|)
block|{
name|basic_block
name|bb
init|=
name|BASIC_BLOCK
argument_list|(
name|block_num
argument_list|)
decl_stmt|;
if|if
condition|(
name|find_if_header
argument_list|(
name|bb
argument_list|)
condition|)
name|block_num
operator|=
name|bb
operator|->
name|index
expr_stmt|;
else|else
name|block_num
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|post_dominators
condition|)
name|sbitmap_vector_free
argument_list|(
name|post_dominators
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fflush
argument_list|(
name|rtl_dump_file
argument_list|)
expr_stmt|;
comment|/* Rebuild life info for basic blocks that require it.  */
if|if
condition|(
name|num_removed_blocks
operator|&&
name|life_data_ok
condition|)
block|{
name|sbitmap
name|update_life_blocks
init|=
name|sbitmap_alloc
argument_list|(
name|n_basic_blocks
argument_list|)
decl_stmt|;
name|sbitmap_zero
argument_list|(
name|update_life_blocks
argument_list|)
expr_stmt|;
comment|/* If we allocated new pseudos, we must resize the array for sched1.  */
if|if
condition|(
name|max_regno
operator|<
name|max_reg_num
argument_list|()
condition|)
block|{
name|max_regno
operator|=
name|max_reg_num
argument_list|()
expr_stmt|;
name|allocate_reg_info
argument_list|(
name|max_regno
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|block_num
operator|=
literal|0
init|;
name|block_num
operator|<
name|n_basic_blocks
condition|;
name|block_num
operator|++
control|)
if|if
condition|(
name|UPDATE_LIFE
argument_list|(
name|BASIC_BLOCK
argument_list|(
name|block_num
argument_list|)
argument_list|)
condition|)
name|SET_BIT
argument_list|(
name|update_life_blocks
argument_list|,
name|block_num
argument_list|)
expr_stmt|;
name|count_or_remove_death_notes
argument_list|(
name|update_life_blocks
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* ??? See about adding a mode that verifies that the initial 	set of blocks don't let registers come live.  */
name|update_life_info
argument_list|(
name|update_life_blocks
argument_list|,
name|UPDATE_LIFE_GLOBAL
argument_list|,
name|PROP_DEATH_NOTES
operator||
name|PROP_SCAN_DEAD_CODE
operator||
name|PROP_KILL_DEAD_CODE
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|update_life_blocks
argument_list|)
expr_stmt|;
block|}
name|clear_aux_for_blocks
argument_list|()
expr_stmt|;
comment|/* Write the final stats.  */
if|if
condition|(
name|rtl_dump_file
operator|&&
name|num_possible_if_blocks
operator|>
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"\n%d possible IF blocks searched.\n"
argument_list|,
name|num_possible_if_blocks
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"%d IF blocks converted.\n"
argument_list|,
name|num_updated_if_blocks
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"%d basic blocks deleted.\n\n\n"
argument_list|,
name|num_removed_blocks
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|verify_flow_info
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

end_unit

