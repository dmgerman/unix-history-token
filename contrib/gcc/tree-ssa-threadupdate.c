begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Thread edges through blocks and update the control flow and SSA graphs.    Copyright (C) 2004, 2005, 2006 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"tree-dump.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_include
include|#
directive|include
file|"cfgloop.h"
end_include

begin_comment
comment|/* Given a block B, update the CFG and SSA graph to reflect redirecting    one or more in-edges to B to instead reach the destination of an    out-edge from B while preserving any side effects in B.     i.e., given A->B and B->C, change A->B to be A->C yet still preserve the    side effects of executing B.       1. Make a copy of B (including its outgoing edges and statements).  Call 	the copy B'.  Note B' has no incoming edges or PHIs at this time.       2. Remove the control statement at the end of B' and all outgoing edges 	except B'->C.       3. Add a new argument to each PHI in C with the same value as the existing 	argument associated with edge B->C.  Associate the new PHI arguments 	with the edge B'->C.       4. For each PHI in B, find or create a PHI in B' with an identical 	PHI_RESULT.  Add an argument to the PHI in B' which has the same 	value as the PHI in B associated with the edge A->B.  Associate 	the new argument in the PHI in B' with the edge A->B.       5. Change the edge A->B to A->B'.  	5a. This automatically deletes any PHI arguments associated with the 	    edge A->B in B.  	5b. This automatically associates each new argument added in step 4 	    with the edge A->B'.       6. Repeat for other incoming edges into B.       7. Put the duplicated resources in B and all the B' blocks into SSA form.     Note that block duplication can be minimized by first collecting the    the set of unique destination blocks that the incoming edges should    be threaded to.  Block duplication can be further minimized by using    B instead of creating B' for one destination if all edges into B are    going to be threaded to a successor of B.     We further reduce the number of edges and statements we create by    not copying all the outgoing edges and the control statement in    step #1.  We instead create a template block without the outgoing    edges and duplicate the template.  */
end_comment

begin_comment
comment|/* Steps #5 and #6 of the above algorithm are best implemented by walking    all the incoming edges which thread to the same destination edge at    the same time.  That avoids lots of table lookups to get information    for the destination edge.     To realize that implementation we create a list of incoming edges    which thread to the same outgoing edge.  Thus to implement steps    #5 and #6 we traverse our hash table of outgoing edge information.    For each entry we walk the list of incoming edges which thread to    the current outgoing edge.  */
end_comment

begin_struct
struct|struct
name|el
block|{
name|edge
name|e
decl_stmt|;
name|struct
name|el
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Main data structure recording information regarding B's duplicate    blocks.  */
end_comment

begin_comment
comment|/* We need to efficiently record the unique thread destinations of this    block and specific information associated with those destinations.  We    may have many incoming edges threaded to the same outgoing edge.  This    can be naturally implemented with a hash table.  */
end_comment

begin_struct
struct|struct
name|redirection_data
block|{
comment|/* A duplicate of B with the trailing control statement removed and which      targets a single successor of B.  */
name|basic_block
name|dup_block
decl_stmt|;
comment|/* An outgoing edge from B.  DUP_BLOCK will have OUTGOING_EDGE->dest as      its single successor.  */
name|edge
name|outgoing_edge
decl_stmt|;
comment|/* A list of incoming edges which we want to thread to      OUTGOING_EDGE->dest.  */
name|struct
name|el
modifier|*
name|incoming_edges
decl_stmt|;
comment|/* Flag indicating whether or not we should create a duplicate block      for this thread destination.  This is only true if we are threading      all incoming edges and thus are using BB itself as a duplicate block.  */
name|bool
name|do_not_duplicate
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Main data structure to hold information for duplicates of BB.  */
end_comment

begin_decl_stmt
specifier|static
name|htab_t
name|redirection_data
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Data structure of information to pass to hash table traversal routines.  */
end_comment

begin_struct
struct|struct
name|local_info
block|{
comment|/* The current block we are working on.  */
name|basic_block
name|bb
decl_stmt|;
comment|/* A template copy of BB with no outgoing edges or control statement that      we use for creating copies.  */
name|basic_block
name|template_block
decl_stmt|;
comment|/* TRUE if we thread one or more jumps, FALSE otherwise.  */
name|bool
name|jumps_threaded
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Passes which use the jump threading code register jump threading    opportunities as they are discovered.  We keep the registered    jump threading opportunities in this vector as edge pairs    (original_edge, target_edge).  */
end_comment

begin_expr_stmt
name|DEF_VEC_ALLOC_P
argument_list|(
name|edge
argument_list|,
name|heap
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|VEC
argument_list|(
name|edge
argument_list|,
name|heap
argument_list|)
operator|*
name|threaded_edges
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Jump threading statistics.  */
end_comment

begin_struct
struct|struct
name|thread_stats_d
block|{
name|unsigned
name|long
name|num_threaded_edges
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|thread_stats_d
name|thread_stats
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Remove the last statement in block BB if it is a control statement    Also remove all outgoing edges except the edge which reaches DEST_BB.    If DEST_BB is NULL, then remove all outgoing edges.  */
end_comment

begin_function
specifier|static
name|void
name|remove_ctrl_stmt_and_useless_edges
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|basic_block
name|dest_bb
parameter_list|)
block|{
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|bsi
operator|=
name|bsi_last
argument_list|(
name|bb
argument_list|)
expr_stmt|;
comment|/* If the duplicate ends with a control statement, then remove it.       Note that if we are duplicating the template block rather than the      original basic block, then the duplicate might not have any real      statements in it.  */
if|if
condition|(
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
operator|&&
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
argument_list|)
operator|==
name|COND_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
argument_list|)
operator|==
name|GOTO_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
argument_list|)
operator|==
name|SWITCH_EXPR
operator|)
condition|)
name|bsi_remove
argument_list|(
operator|&
name|bsi
argument_list|,
name|true
argument_list|)
expr_stmt|;
for|for
control|(
name|ei
operator|=
name|ei_start
argument_list|(
name|bb
operator|->
name|succs
argument_list|)
init|;
operator|(
name|e
operator|=
name|ei_safe_edge
argument_list|(
name|ei
argument_list|)
operator|)
condition|;
control|)
block|{
if|if
condition|(
name|e
operator|->
name|dest
operator|!=
name|dest_bb
condition|)
name|remove_edge
argument_list|(
name|e
argument_list|)
expr_stmt|;
else|else
name|ei_next
argument_list|(
operator|&
name|ei
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Create a duplicate of BB which only reaches the destination of the edge    stored in RD.  Record the duplicate block in RD.  */
end_comment

begin_function
specifier|static
name|void
name|create_block_for_threading
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|struct
name|redirection_data
modifier|*
name|rd
parameter_list|)
block|{
comment|/* We can use the generic block duplication code and simply remove      the stuff we do not need.  */
name|rd
operator|->
name|dup_block
operator|=
name|duplicate_block
argument_list|(
name|bb
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Zero out the profile, since the block is unreachable for now.  */
name|rd
operator|->
name|dup_block
operator|->
name|frequency
operator|=
literal|0
expr_stmt|;
name|rd
operator|->
name|dup_block
operator|->
name|count
operator|=
literal|0
expr_stmt|;
comment|/* The call to duplicate_block will copy everything, including the      useless COND_EXPR or SWITCH_EXPR at the end of BB.  We just remove      the useless COND_EXPR or SWITCH_EXPR here rather than having a      specialized block copier.  We also remove all outgoing edges      from the duplicate block.  The appropriate edge will be created      later.  */
name|remove_ctrl_stmt_and_useless_edges
argument_list|(
name|rd
operator|->
name|dup_block
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Hashing and equality routines for our hash table.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|redirection_data_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
name|edge
name|e
init|=
operator|(
operator|(
expr|struct
name|redirection_data
operator|*
operator|)
name|p
operator|)
operator|->
name|outgoing_edge
decl_stmt|;
return|return
name|e
operator|->
name|dest
operator|->
name|index
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|redirection_data_eq
parameter_list|(
specifier|const
name|void
modifier|*
name|p1
parameter_list|,
specifier|const
name|void
modifier|*
name|p2
parameter_list|)
block|{
name|edge
name|e1
init|=
operator|(
operator|(
expr|struct
name|redirection_data
operator|*
operator|)
name|p1
operator|)
operator|->
name|outgoing_edge
decl_stmt|;
name|edge
name|e2
init|=
operator|(
operator|(
expr|struct
name|redirection_data
operator|*
operator|)
name|p2
operator|)
operator|->
name|outgoing_edge
decl_stmt|;
return|return
name|e1
operator|==
name|e2
return|;
block|}
end_function

begin_comment
comment|/* Given an outgoing edge E lookup and return its entry in our hash table.     If INSERT is true, then we insert the entry into the hash table if    it is not already present.  INCOMING_EDGE is added to the list of incoming    edges associated with E in the hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|redirection_data
modifier|*
name|lookup_redirection_data
parameter_list|(
name|edge
name|e
parameter_list|,
name|edge
name|incoming_edge
parameter_list|,
name|enum
name|insert_option
name|insert
parameter_list|)
block|{
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
name|struct
name|redirection_data
modifier|*
name|elt
decl_stmt|;
comment|/* Build a hash table element so we can see if E is already      in the table.  */
name|elt
operator|=
name|XNEW
argument_list|(
expr|struct
name|redirection_data
argument_list|)
expr_stmt|;
name|elt
operator|->
name|outgoing_edge
operator|=
name|e
expr_stmt|;
name|elt
operator|->
name|dup_block
operator|=
name|NULL
expr_stmt|;
name|elt
operator|->
name|do_not_duplicate
operator|=
name|false
expr_stmt|;
name|elt
operator|->
name|incoming_edges
operator|=
name|NULL
expr_stmt|;
name|slot
operator|=
name|htab_find_slot
argument_list|(
name|redirection_data
argument_list|,
name|elt
argument_list|,
name|insert
argument_list|)
expr_stmt|;
comment|/* This will only happen if INSERT is false and the entry is not      in the hash table.  */
if|if
condition|(
name|slot
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|elt
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* This will only happen if E was not in the hash table and      INSERT is true.  */
if|if
condition|(
operator|*
name|slot
operator|==
name|NULL
condition|)
block|{
operator|*
name|slot
operator|=
operator|(
name|void
operator|*
operator|)
name|elt
expr_stmt|;
name|elt
operator|->
name|incoming_edges
operator|=
name|XNEW
argument_list|(
expr|struct
name|el
argument_list|)
expr_stmt|;
name|elt
operator|->
name|incoming_edges
operator|->
name|e
operator|=
name|incoming_edge
expr_stmt|;
name|elt
operator|->
name|incoming_edges
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
return|return
name|elt
return|;
block|}
comment|/* E was in the hash table.  */
else|else
block|{
comment|/* Free ELT as we do not need it anymore, we will extract the 	 relevant entry from the hash table itself.  */
name|free
argument_list|(
name|elt
argument_list|)
expr_stmt|;
comment|/* Get the entry stored in the hash table.  */
name|elt
operator|=
operator|(
expr|struct
name|redirection_data
operator|*
operator|)
operator|*
name|slot
expr_stmt|;
comment|/* If insertion was requested, then we need to add INCOMING_EDGE 	 to the list of incoming edges associated with E.  */
if|if
condition|(
name|insert
condition|)
block|{
name|struct
name|el
modifier|*
name|el
init|=
name|XNEW
argument_list|(
expr|struct
name|el
argument_list|)
decl_stmt|;
name|el
operator|->
name|next
operator|=
name|elt
operator|->
name|incoming_edges
expr_stmt|;
name|el
operator|->
name|e
operator|=
name|incoming_edge
expr_stmt|;
name|elt
operator|->
name|incoming_edges
operator|=
name|el
expr_stmt|;
block|}
return|return
name|elt
return|;
block|}
block|}
end_function

begin_comment
comment|/* Given a duplicate block and its single destination (both stored    in RD).  Create an edge between the duplicate and its single    destination.     Add an additional argument to any PHI nodes at the single    destination.  */
end_comment

begin_function
specifier|static
name|void
name|create_edge_and_update_destination_phis
parameter_list|(
name|struct
name|redirection_data
modifier|*
name|rd
parameter_list|)
block|{
name|edge
name|e
init|=
name|make_edge
argument_list|(
name|rd
operator|->
name|dup_block
argument_list|,
name|rd
operator|->
name|outgoing_edge
operator|->
name|dest
argument_list|,
name|EDGE_FALLTHRU
argument_list|)
decl_stmt|;
name|tree
name|phi
decl_stmt|;
name|e
operator|->
name|probability
operator|=
name|REG_BR_PROB_BASE
expr_stmt|;
name|e
operator|->
name|count
operator|=
name|rd
operator|->
name|dup_block
operator|->
name|count
expr_stmt|;
comment|/* If there are any PHI nodes at the destination of the outgoing edge      from the duplicate block, then we will need to add a new argument      to them.  The argument should have the same value as the argument      associated with the outgoing edge stored in RD.  */
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|e
operator|->
name|dest
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
block|{
name|int
name|indx
init|=
name|rd
operator|->
name|outgoing_edge
operator|->
name|dest_idx
decl_stmt|;
name|add_phi_arg
argument_list|(
name|phi
argument_list|,
name|PHI_ARG_DEF
argument_list|(
name|phi
argument_list|,
name|indx
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Hash table traversal callback routine to create duplicate blocks.  */
end_comment

begin_function
specifier|static
name|int
name|create_duplicates
parameter_list|(
name|void
modifier|*
modifier|*
name|slot
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|redirection_data
modifier|*
name|rd
init|=
operator|(
expr|struct
name|redirection_data
operator|*
operator|)
operator|*
name|slot
decl_stmt|;
name|struct
name|local_info
modifier|*
name|local_info
init|=
operator|(
expr|struct
name|local_info
operator|*
operator|)
name|data
decl_stmt|;
comment|/* If this entry should not have a duplicate created, then there's      nothing to do.  */
if|if
condition|(
name|rd
operator|->
name|do_not_duplicate
condition|)
return|return
literal|1
return|;
comment|/* Create a template block if we have not done so already.  Otherwise      use the template to create a new block.  */
if|if
condition|(
name|local_info
operator|->
name|template_block
operator|==
name|NULL
condition|)
block|{
name|create_block_for_threading
argument_list|(
name|local_info
operator|->
name|bb
argument_list|,
name|rd
argument_list|)
expr_stmt|;
name|local_info
operator|->
name|template_block
operator|=
name|rd
operator|->
name|dup_block
expr_stmt|;
comment|/* We do not create any outgoing edges for the template.  We will 	 take care of that in a later traversal.  That way we do not 	 create edges that are going to just be deleted.  */
block|}
else|else
block|{
name|create_block_for_threading
argument_list|(
name|local_info
operator|->
name|template_block
argument_list|,
name|rd
argument_list|)
expr_stmt|;
comment|/* Go ahead and wire up outgoing edges and update PHIs for the duplicate          block.  */
name|create_edge_and_update_destination_phis
argument_list|(
name|rd
argument_list|)
expr_stmt|;
block|}
comment|/* Keep walking the hash table.  */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* We did not create any outgoing edges for the template block during    block creation.  This hash table traversal callback creates the    outgoing edge for the template block.  */
end_comment

begin_function
specifier|static
name|int
name|fixup_template_block
parameter_list|(
name|void
modifier|*
modifier|*
name|slot
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|redirection_data
modifier|*
name|rd
init|=
operator|(
expr|struct
name|redirection_data
operator|*
operator|)
operator|*
name|slot
decl_stmt|;
name|struct
name|local_info
modifier|*
name|local_info
init|=
operator|(
expr|struct
name|local_info
operator|*
operator|)
name|data
decl_stmt|;
comment|/* If this is the template block, then create its outgoing edges      and halt the hash table traversal.  */
if|if
condition|(
name|rd
operator|->
name|dup_block
operator|&&
name|rd
operator|->
name|dup_block
operator|==
name|local_info
operator|->
name|template_block
condition|)
block|{
name|create_edge_and_update_destination_phis
argument_list|(
name|rd
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Not all jump threading requests are useful.  In particular some    jump threading requests can create irreducible regions which are    undesirable.     This routine will examine the BB's incoming edges for jump threading    requests which, if acted upon, would create irreducible regions.  Any    such jump threading requests found will be pruned away.  */
end_comment

begin_function
specifier|static
name|void
name|prune_undesirable_thread_requests
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|bool
name|may_create_irreducible_region
init|=
name|false
decl_stmt|;
name|unsigned
name|int
name|num_outgoing_edges_into_loop
init|=
literal|0
decl_stmt|;
comment|/* For the heuristics below, we need to know if BB has more than      one outgoing edge into a loop.  */
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
name|num_outgoing_edges_into_loop
operator|+=
operator|(
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_LOOP_EXIT
operator|)
operator|==
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|num_outgoing_edges_into_loop
operator|>
literal|1
condition|)
block|{
name|edge
name|backedge
init|=
name|NULL
decl_stmt|;
comment|/* Consider the effect of threading the edge (0, 1) to 2 on the left 	 CFG to produce the right CFG:                    0            0              |            |              1<--+        2<--------+             / \  |        |         |            2   3 |        4<----+   |             \ /  |       / \    |   |              4---+      E   1-- | --+              |              |   |              E              3---+    	Threading the (0, 1) edge to 2 effectively creates two loops  	(2, 4, 1) and (4, 1, 3) which are neither disjoint nor nested. 	This is not good.  	However, we do need to be able to thread  (0, 1) to 2 or 3 	in the left CFG below (which creates the middle and right 	CFGs with nested loops).               0          0             0              |          |             |              1<--+      2<----+       3<-+<-+             /|   |      |     |       |  |  |            2 |   |      3<-+  |       1--+  |             \|   |      |  |  |       |     |              3---+      1--+--+       2-----+  	  	 A safe heuristic appears to be to only allow threading if BB 	 has a single incoming backedge from one of its direct successors.  */
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->preds
argument_list|)
block|{
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_DFS_BACK
condition|)
block|{
if|if
condition|(
name|backedge
condition|)
block|{
name|backedge
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
else|else
block|{
name|backedge
operator|=
name|e
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|backedge
operator|&&
name|find_edge
argument_list|(
name|bb
argument_list|,
name|backedge
operator|->
name|src
argument_list|)
condition|)
empty_stmt|;
else|else
name|may_create_irreducible_region
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
name|edge
name|dest
init|=
name|NULL
decl_stmt|;
comment|/* If we thread across the loop entry block (BB) into the 	 loop and BB is still reached from outside the loop, then 	 we would create an irreducible CFG.  Consider the effect 	 of threading the edge (1, 4) to 5 on the left CFG to produce 	 the right CFG               0               0             / \             / \            1   2           1   2             \ /            |   |              4<----+       5<->4             / \    |           |            E   5---+           E   	 Threading the (1, 4) edge to 5 creates two entry points 	 into the loop (4, 5) (one from block 1, the other from 	 block 2).  A classic irreducible region.   	 So look at all of BB's incoming edges which are not 	 backedges and which are not threaded to the loop exit. 	 If that subset of incoming edges do not all thread 	 to the same block, then threading any of them will create 	 an irreducible region.  */
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->preds
argument_list|)
block|{
name|edge
name|e2
decl_stmt|;
comment|/* We ignore back edges for now.  This may need refinement     	     as threading a backedge creates an inner loop which 	     we would need to verify has a single entry point.   	     If all backedges thread to new locations, then this 	     block will no longer have incoming backedges and we 	     need not worry about creating irreducible regions 	     by threading through BB.  I don't think this happens 	     enough in practice to worry about it.  */
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_DFS_BACK
condition|)
continue|continue;
comment|/* If the incoming edge threads to the loop exit, then it 	     is clearly safe.  */
name|e2
operator|=
name|e
operator|->
name|aux
expr_stmt|;
if|if
condition|(
name|e2
operator|&&
operator|(
name|e2
operator|->
name|flags
operator|&
name|EDGE_LOOP_EXIT
operator|)
condition|)
continue|continue;
comment|/* E enters the loop header and is not threaded.  We can 	     not allow any other incoming edges to thread into 	     the loop as that would create an irreducible region.  */
if|if
condition|(
operator|!
name|e2
condition|)
block|{
name|may_create_irreducible_region
operator|=
name|true
expr_stmt|;
break|break;
block|}
comment|/* We know that this incoming edge threads to a block inside 	     the loop.  This edge must thread to the same target in 	     the loop as any previously seen threaded edges.  Otherwise 	     we will create an irreducible region.  */
if|if
condition|(
operator|!
name|dest
condition|)
name|dest
operator|=
name|e2
expr_stmt|;
elseif|else
if|if
condition|(
name|e2
operator|!=
name|dest
condition|)
block|{
name|may_create_irreducible_region
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* If we might create an irreducible region, then cancel any of      the jump threading requests for incoming edges which are      not backedges and which do not thread to the exit block.  */
if|if
condition|(
name|may_create_irreducible_region
condition|)
block|{
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->preds
argument_list|)
block|{
name|edge
name|e2
decl_stmt|;
comment|/* Ignore back edges.  */
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_DFS_BACK
condition|)
continue|continue;
name|e2
operator|=
name|e
operator|->
name|aux
expr_stmt|;
comment|/* If this incoming edge was not threaded, then there is 	     nothing to do.  */
if|if
condition|(
operator|!
name|e2
condition|)
continue|continue;
comment|/* If this incoming edge threaded to the loop exit, 	     then it can be ignored as it is safe.  */
if|if
condition|(
name|e2
operator|->
name|flags
operator|&
name|EDGE_LOOP_EXIT
condition|)
continue|continue;
if|if
condition|(
name|e2
condition|)
block|{
comment|/* This edge threaded into the loop and the jump thread 		 request must be cancelled.  */
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  Not threading jump %d --> %d to %d\n"
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|,
name|e2
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
name|e
operator|->
name|aux
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Hash table traversal callback to redirect each incoming edge    associated with this hash table element to its new destination.  */
end_comment

begin_function
specifier|static
name|int
name|redirect_edges
parameter_list|(
name|void
modifier|*
modifier|*
name|slot
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|redirection_data
modifier|*
name|rd
init|=
operator|(
expr|struct
name|redirection_data
operator|*
operator|)
operator|*
name|slot
decl_stmt|;
name|struct
name|local_info
modifier|*
name|local_info
init|=
operator|(
expr|struct
name|local_info
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|el
modifier|*
name|next
decl_stmt|,
modifier|*
name|el
decl_stmt|;
comment|/* Walk over all the incoming edges associated associated with this      hash table entry.  */
for|for
control|(
name|el
operator|=
name|rd
operator|->
name|incoming_edges
init|;
name|el
condition|;
name|el
operator|=
name|next
control|)
block|{
name|edge
name|e
init|=
name|el
operator|->
name|e
decl_stmt|;
comment|/* Go ahead and free this element from the list.  Doing this now 	 avoids the need for another list walk when we destroy the hash 	 table.  */
name|next
operator|=
name|el
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|el
argument_list|)
expr_stmt|;
comment|/* Go ahead and clear E->aux.  It's not needed anymore and failure          to clear it will cause all kinds of unpleasant problems later.  */
name|e
operator|->
name|aux
operator|=
name|NULL
expr_stmt|;
name|thread_stats
operator|.
name|num_threaded_edges
operator|++
expr_stmt|;
if|if
condition|(
name|rd
operator|->
name|dup_block
condition|)
block|{
name|edge
name|e2
decl_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  Threaded jump %d --> %d to %d\n"
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|,
name|rd
operator|->
name|dup_block
operator|->
name|index
argument_list|)
expr_stmt|;
name|rd
operator|->
name|dup_block
operator|->
name|count
operator|+=
name|e
operator|->
name|count
expr_stmt|;
name|rd
operator|->
name|dup_block
operator|->
name|frequency
operator|+=
name|EDGE_FREQUENCY
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|EDGE_SUCC
argument_list|(
name|rd
operator|->
name|dup_block
argument_list|,
literal|0
argument_list|)
operator|->
name|count
operator|+=
name|e
operator|->
name|count
expr_stmt|;
comment|/* Redirect the incoming edge to the appropriate duplicate 	     block.  */
name|e2
operator|=
name|redirect_edge_and_branch
argument_list|(
name|e
argument_list|,
name|rd
operator|->
name|dup_block
argument_list|)
expr_stmt|;
name|flush_pending_stmts
argument_list|(
name|e2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
operator|)
operator|&&
name|e
operator|->
name|src
operator|!=
name|e2
operator|->
name|src
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"    basic block %d created\n"
argument_list|,
name|e2
operator|->
name|src
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  Threaded jump %d --> %d to %d\n"
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|,
name|local_info
operator|->
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
comment|/* We are using BB as the duplicate.  Remove the unnecessary 	     outgoing edges and statements from BB.  */
name|remove_ctrl_stmt_and_useless_edges
argument_list|(
name|local_info
operator|->
name|bb
argument_list|,
name|rd
operator|->
name|outgoing_edge
operator|->
name|dest
argument_list|)
expr_stmt|;
comment|/* And fixup the flags on the single remaining edge.  */
name|single_succ_edge
argument_list|(
name|local_info
operator|->
name|bb
argument_list|)
operator|->
name|flags
operator|&=
operator|~
operator|(
name|EDGE_TRUE_VALUE
operator||
name|EDGE_FALSE_VALUE
operator||
name|EDGE_ABNORMAL
operator|)
expr_stmt|;
name|single_succ_edge
argument_list|(
name|local_info
operator|->
name|bb
argument_list|)
operator|->
name|flags
operator||=
name|EDGE_FALLTHRU
expr_stmt|;
block|}
block|}
comment|/* Indicate that we actually threaded one or more jumps.  */
if|if
condition|(
name|rd
operator|->
name|incoming_edges
condition|)
name|local_info
operator|->
name|jumps_threaded
operator|=
name|true
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return true if this block has no executable statements other than    a simple ctrl flow instruction.  When the number of outgoing edges    is one, this is equivalent to a "forwarder" block.  */
end_comment

begin_function
specifier|static
name|bool
name|redirection_block_p
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|block_stmt_iterator
name|bsi
decl_stmt|;
comment|/* Advance to the first executable statement.  */
name|bsi
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
argument_list|)
operator|==
name|LABEL_EXPR
operator|||
name|IS_EMPTY_STMT
argument_list|(
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
argument_list|)
operator|)
condition|)
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
expr_stmt|;
comment|/* Check if this is an empty block.  */
if|if
condition|(
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* Test that we've reached the terminating control statement.  */
return|return
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
argument_list|)
operator|==
name|COND_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
argument_list|)
operator|==
name|GOTO_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
argument_list|)
operator|==
name|SWITCH_EXPR
operator|)
return|;
block|}
end_function

begin_comment
comment|/* BB is a block which ends with a COND_EXPR or SWITCH_EXPR and when BB    is reached via one or more specific incoming edges, we know which    outgoing edge from BB will be traversed.     We want to redirect those incoming edges to the target of the    appropriate outgoing edge.  Doing so avoids a conditional branch    and may expose new optimization opportunities.  Note that we have    to update dominator tree and SSA graph after such changes.     The key to keeping the SSA graph update manageable is to duplicate    the side effects occurring in BB so that those side effects still    occur on the paths which bypass BB after redirecting edges.     We accomplish this by creating duplicates of BB and arranging for    the duplicates to unconditionally pass control to one specific    successor of BB.  We then revector the incoming edges into BB to    the appropriate duplicate of BB.     BB and its duplicates will have assignments to the same set of    SSA_NAMEs.  Right now, we just call into update_ssa to update the    SSA graph for those names.     We are also going to experiment with a true incremental update    scheme for the duplicated resources.  One of the interesting    properties we can exploit here is that all the resources set    in BB will have the same IDFS, so we have one IDFS computation    per block with incoming threaded edges, which can lower the    cost of the true incremental update algorithm.  */
end_comment

begin_function
specifier|static
name|bool
name|thread_block
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
comment|/* E is an incoming edge into BB that we may or may not want to      redirect to a duplicate of BB.  */
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|struct
name|local_info
name|local_info
decl_stmt|;
comment|/* FOUND_BACKEDGE indicates that we found an incoming backedge      into BB, in which case we may ignore certain jump threads      to avoid creating irreducible regions.  */
name|bool
name|found_backedge
init|=
name|false
decl_stmt|;
comment|/* ALL indicates whether or not all incoming edges into BB should      be threaded to a duplicate of BB.  */
name|bool
name|all
init|=
name|true
decl_stmt|;
comment|/* If optimizing for size, only thread this block if we don't have      to duplicate it or it's an otherwise empty redirection block.  */
if|if
condition|(
name|optimize_size
operator|&&
name|EDGE_COUNT
argument_list|(
name|bb
operator|->
name|preds
argument_list|)
operator|>
literal|1
operator|&&
operator|!
name|redirection_block_p
argument_list|(
name|bb
argument_list|)
condition|)
block|{
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->preds
argument_list|)
name|e
operator|->
name|aux
operator|=
name|NULL
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* To avoid scanning a linear array for the element we need we instead      use a hash table.  For normal code there should be no noticeable      difference.  However, if we have a block with a large number of      incoming and outgoing edges such linear searches can get expensive.  */
name|redirection_data
operator|=
name|htab_create
argument_list|(
name|EDGE_COUNT
argument_list|(
name|bb
operator|->
name|succs
argument_list|)
argument_list|,
name|redirection_data_hash
argument_list|,
name|redirection_data_eq
argument_list|,
name|free
argument_list|)
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->preds
argument_list|)
name|found_backedge
operator||=
operator|(
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_DFS_BACK
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
comment|/* If BB has incoming backedges, then threading across BB might      introduce an irreducible region, which would be undesirable      as that inhibits various optimizations later.  Prune away      any jump threading requests which we know will result in      an irreducible region.  */
if|if
condition|(
name|found_backedge
condition|)
name|prune_undesirable_thread_requests
argument_list|(
name|bb
argument_list|)
expr_stmt|;
comment|/* Record each unique threaded destination into a hash table for      efficient lookups.  */
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->preds
argument_list|)
block|{
if|if
condition|(
operator|!
name|e
operator|->
name|aux
condition|)
block|{
name|all
operator|=
name|false
expr_stmt|;
block|}
else|else
block|{
name|edge
name|e2
init|=
name|e
operator|->
name|aux
decl_stmt|;
name|update_bb_profile_for_threading
argument_list|(
name|e
operator|->
name|dest
argument_list|,
name|EDGE_FREQUENCY
argument_list|(
name|e
argument_list|)
argument_list|,
name|e
operator|->
name|count
argument_list|,
name|e
operator|->
name|aux
argument_list|)
expr_stmt|;
comment|/* Insert the outgoing edge into the hash table if it is not 	     already in the hash table.  */
name|lookup_redirection_data
argument_list|(
name|e2
argument_list|,
name|e
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If we are going to thread all incoming edges to an outgoing edge, then      BB will become unreachable.  Rather than just throwing it away, use      it for one of the duplicates.  Mark the first incoming edge with the      DO_NOT_DUPLICATE attribute.  */
if|if
condition|(
name|all
condition|)
block|{
name|edge
name|e
init|=
name|EDGE_PRED
argument_list|(
name|bb
argument_list|,
literal|0
argument_list|)
operator|->
name|aux
decl_stmt|;
name|lookup_redirection_data
argument_list|(
name|e
argument_list|,
name|NULL
argument_list|,
name|NO_INSERT
argument_list|)
operator|->
name|do_not_duplicate
operator|=
name|true
expr_stmt|;
block|}
comment|/* Now create duplicates of BB.       Note that for a block with a high outgoing degree we can waste      a lot of time and memory creating and destroying useless edges.       So we first duplicate BB and remove the control structure at the      tail of the duplicate as well as all outgoing edges from the      duplicate.  We then use that duplicate block as a template for      the rest of the duplicates.  */
name|local_info
operator|.
name|template_block
operator|=
name|NULL
expr_stmt|;
name|local_info
operator|.
name|bb
operator|=
name|bb
expr_stmt|;
name|local_info
operator|.
name|jumps_threaded
operator|=
name|false
expr_stmt|;
name|htab_traverse
argument_list|(
name|redirection_data
argument_list|,
name|create_duplicates
argument_list|,
operator|&
name|local_info
argument_list|)
expr_stmt|;
comment|/* The template does not have an outgoing edge.  Create that outgoing      edge and update PHI nodes as the edge's target as necessary.       We do this after creating all the duplicates to avoid creating      unnecessary edges.  */
name|htab_traverse
argument_list|(
name|redirection_data
argument_list|,
name|fixup_template_block
argument_list|,
operator|&
name|local_info
argument_list|)
expr_stmt|;
comment|/* The hash table traversals above created the duplicate blocks (and the      statements within the duplicate blocks).  This loop creates PHI nodes for      the duplicated blocks and redirects the incoming edges into BB to reach      the duplicates of BB.  */
name|htab_traverse
argument_list|(
name|redirection_data
argument_list|,
name|redirect_edges
argument_list|,
operator|&
name|local_info
argument_list|)
expr_stmt|;
comment|/* Done with this block.  Clear REDIRECTION_DATA.  */
name|htab_delete
argument_list|(
name|redirection_data
argument_list|)
expr_stmt|;
name|redirection_data
operator|=
name|NULL
expr_stmt|;
comment|/* Indicate to our caller whether or not any jumps were threaded.  */
return|return
name|local_info
operator|.
name|jumps_threaded
return|;
block|}
end_function

begin_comment
comment|/* Walk through the registered jump threads and convert them into a    form convenient for this pass.     Any block which has incoming edges threaded to outgoing edges    will have its entry in THREADED_BLOCK set.     Any threaded edge will have its new outgoing edge stored in the    original edge's AUX field.     This form avoids the need to walk all the edges in the CFG to    discover blocks which need processing and avoids unnecessary    hash table lookups to map from threaded edge to new target.  */
end_comment

begin_function
specifier|static
name|void
name|mark_threaded_blocks
parameter_list|(
name|bitmap
name|threaded_blocks
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VEC_length
argument_list|(
name|edge
argument_list|,
name|threaded_edges
argument_list|)
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|edge
name|e
init|=
name|VEC_index
argument_list|(
name|edge
argument_list|,
name|threaded_edges
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|edge
name|e2
init|=
name|VEC_index
argument_list|(
name|edge
argument_list|,
name|threaded_edges
argument_list|,
name|i
operator|+
literal|1
argument_list|)
decl_stmt|;
name|e
operator|->
name|aux
operator|=
name|e2
expr_stmt|;
name|bitmap_set_bit
argument_list|(
name|threaded_blocks
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Walk through all blocks and thread incoming edges to the appropriate    outgoing edge for each edge pair recorded in THREADED_EDGES.     It is the caller's responsibility to fix the dominance information    and rewrite duplicated SSA_NAMEs back into SSA form.     Returns true if one or more edges were threaded, false otherwise.  */
end_comment

begin_function
name|bool
name|thread_through_all_blocks
parameter_list|(
name|void
parameter_list|)
block|{
name|bool
name|retval
init|=
name|false
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|bitmap
name|threaded_blocks
decl_stmt|;
if|if
condition|(
name|threaded_edges
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|threaded_blocks
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|thread_stats
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|thread_stats
argument_list|)
argument_list|)
expr_stmt|;
name|mark_threaded_blocks
argument_list|(
name|threaded_blocks
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|threaded_blocks
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
block|{
name|basic_block
name|bb
init|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|EDGE_COUNT
argument_list|(
name|bb
operator|->
name|preds
argument_list|)
operator|>
literal|0
condition|)
name|retval
operator||=
name|thread_block
argument_list|(
name|bb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_STATS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\nJumps threaded: %lu\n"
argument_list|,
name|thread_stats
operator|.
name|num_threaded_edges
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|threaded_blocks
argument_list|)
expr_stmt|;
name|threaded_blocks
operator|=
name|NULL
expr_stmt|;
name|VEC_free
argument_list|(
name|edge
argument_list|,
name|heap
argument_list|,
name|threaded_edges
argument_list|)
expr_stmt|;
name|threaded_edges
operator|=
name|NULL
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Register a jump threading opportunity.  We queue up all the jump    threading opportunities discovered by a pass and update the CFG    and SSA form all at once.     E is the edge we can thread, E2 is the new target edge.  ie, we    are effectively recording that E->dest can be changed to E2->dest    after fixing the SSA graph.  */
end_comment

begin_function
name|void
name|register_jump_thread
parameter_list|(
name|edge
name|e
parameter_list|,
name|edge
name|e2
parameter_list|)
block|{
if|if
condition|(
name|threaded_edges
operator|==
name|NULL
condition|)
name|threaded_edges
operator|=
name|VEC_alloc
argument_list|(
name|edge
argument_list|,
name|heap
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|edge
argument_list|,
name|heap
argument_list|,
name|threaded_edges
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|edge
argument_list|,
name|heap
argument_list|,
name|threaded_edges
argument_list|,
name|e2
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

