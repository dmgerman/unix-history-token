begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* CPP Library.    Copyright (C) 1986, 87, 89, 92-98, 1999 Free Software Foundation, Inc.    Contributed by Per Bothner, 1994-95.    Based on CCCP program by Paul Rubin, June 1986    Adapted to ANSI C, Richard Stallman, Jan 1987  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"cpplib.h"
end_include

begin_include
include|#
directive|include
file|"cpphash.h"
end_include

begin_include
include|#
directive|include
file|"intl.h"
end_include

begin_define
define|#
directive|define
name|SKIP_WHITE_SPACE
parameter_list|(
name|p
parameter_list|)
value|do { while (is_hor_space[*p]) p++; } while (0)
end_define

begin_define
define|#
directive|define
name|SKIP_ALL_WHITE_SPACE
parameter_list|(
name|p
parameter_list|)
value|do { while (is_space[*p]) p++; } while (0)
end_define

begin_define
define|#
directive|define
name|PEEKN
parameter_list|(
name|N
parameter_list|)
value|(CPP_BUFFER (pfile)->rlimit - CPP_BUFFER (pfile)->cur>= (N) ? CPP_BUFFER (pfile)->cur[N] : EOF)
end_define

begin_define
define|#
directive|define
name|FORWARD
parameter_list|(
name|N
parameter_list|)
value|CPP_FORWARD (CPP_BUFFER (pfile), (N))
end_define

begin_define
define|#
directive|define
name|GETC
parameter_list|()
value|CPP_BUF_GET (CPP_BUFFER (pfile))
end_define

begin_define
define|#
directive|define
name|PEEKC
parameter_list|()
value|CPP_BUF_PEEK (CPP_BUFFER (pfile))
end_define

begin_comment
comment|/* CPP_IS_MACRO_BUFFER is true if the buffer contains macro expansion.    (Note that it is false while we're expanding macro *arguments*.) */
end_comment

begin_define
define|#
directive|define
name|CPP_IS_MACRO_BUFFER
parameter_list|(
name|PBUF
parameter_list|)
value|((PBUF)->data != NULL)
end_define

begin_comment
comment|/* Forward declarations.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|my_strerror
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|validate_else
name|PROTO
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|HOST_WIDEST_INT
name|eval_if_expression
name|PROTO
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|conditional_skip
name|PROTO
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|int
operator|,
expr|enum
name|node_type
operator|,
name|U_CHAR
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|skip_if_group
name|PROTO
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|parse_name
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|parse_string
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|parse_assertion
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* External declarations.  */
end_comment

begin_decl_stmt
specifier|extern
name|HOST_WIDEST_INT
name|cpp_parse_expr
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* `struct directive' defines one #-directive, including how to handle it.  */
end_comment

begin_struct
struct|struct
name|directive
block|{
name|int
name|length
decl_stmt|;
comment|/* Length of name */
name|int
argument_list|(
argument|*func
argument_list|)
comment|/* Function to handle directive */
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
expr|struct
name|directive
operator|*
operator|)
argument_list|)
expr_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Name of directive */
name|enum
name|node_type
name|type
decl_stmt|;
comment|/* Code which describes which directive.  */
block|}
struct|;
end_struct

begin_comment
comment|/* These functions are declared to return int instead of void since they    are going to be placed in a table and some old compilers have trouble with    pointers to functions returning void.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|do_define
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
expr|struct
name|directive
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_line
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
expr|struct
name|directive
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_include
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
expr|struct
name|directive
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_undef
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
expr|struct
name|directive
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_error
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
expr|struct
name|directive
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_pragma
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
expr|struct
name|directive
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_ident
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
expr|struct
name|directive
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_if
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
expr|struct
name|directive
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_xifdef
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
expr|struct
name|directive
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_else
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
expr|struct
name|directive
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_elif
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
expr|struct
name|directive
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_endif
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
expr|struct
name|directive
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SCCS_DIRECTIVE
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|do_sccs
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
expr|struct
name|directive
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|do_assert
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
expr|struct
name|directive
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_unassert
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
expr|struct
name|directive
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_warning
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
expr|struct
name|directive
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|IS_INCLUDE_DIRECTIVE_TYPE
parameter_list|(
name|t
parameter_list|)
define|\
value|((int) T_INCLUDE<= (int) (t)&& (int) (t)<= (int) T_IMPORT)
end_define

begin_comment
comment|/* Here is the actual list of #-directives, most-often-used first.    The initialize_builtins function assumes #define is the very first.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|directive
name|directive_table
index|[]
init|=
block|{
block|{
literal|6
block|,
name|do_define
block|,
literal|"define"
block|,
name|T_DEFINE
block|}
block|,
block|{
literal|5
block|,
name|do_xifdef
block|,
literal|"ifdef"
block|,
name|T_IFDEF
block|}
block|,
block|{
literal|6
block|,
name|do_xifdef
block|,
literal|"ifndef"
block|,
name|T_IFNDEF
block|}
block|,
block|{
literal|7
block|,
name|do_include
block|,
literal|"include"
block|,
name|T_INCLUDE
block|}
block|,
block|{
literal|12
block|,
name|do_include
block|,
literal|"include_next"
block|,
name|T_INCLUDE_NEXT
block|}
block|,
block|{
literal|6
block|,
name|do_include
block|,
literal|"import"
block|,
name|T_IMPORT
block|}
block|,
block|{
literal|5
block|,
name|do_endif
block|,
literal|"endif"
block|,
name|T_ENDIF
block|}
block|,
block|{
literal|4
block|,
name|do_else
block|,
literal|"else"
block|,
name|T_ELSE
block|}
block|,
block|{
literal|2
block|,
name|do_if
block|,
literal|"if"
block|,
name|T_IF
block|}
block|,
block|{
literal|4
block|,
name|do_elif
block|,
literal|"elif"
block|,
name|T_ELIF
block|}
block|,
block|{
literal|5
block|,
name|do_undef
block|,
literal|"undef"
block|,
name|T_UNDEF
block|}
block|,
block|{
literal|5
block|,
name|do_error
block|,
literal|"error"
block|,
name|T_ERROR
block|}
block|,
block|{
literal|7
block|,
name|do_warning
block|,
literal|"warning"
block|,
name|T_WARNING
block|}
block|,
block|{
literal|6
block|,
name|do_pragma
block|,
literal|"pragma"
block|,
name|T_PRAGMA
block|}
block|,
block|{
literal|4
block|,
name|do_line
block|,
literal|"line"
block|,
name|T_LINE
block|}
block|,
block|{
literal|5
block|,
name|do_ident
block|,
literal|"ident"
block|,
name|T_IDENT
block|}
block|,
ifdef|#
directive|ifdef
name|SCCS_DIRECTIVE
block|{
literal|4
block|,
name|do_sccs
block|,
literal|"sccs"
block|,
name|T_SCCS
block|}
block|,
endif|#
directive|endif
block|{
literal|6
block|,
name|do_assert
block|,
literal|"assert"
block|,
name|T_ASSERT
block|}
block|,
block|{
literal|8
block|,
name|do_unassert
block|,
literal|"unassert"
block|,
name|T_UNASSERT
block|}
block|,
block|{
operator|-
literal|1
block|,
literal|0
block|,
literal|""
block|,
name|T_UNUSED
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Place into PFILE a quoted string representing the string SRC.    Caller must reserve enough space in pfile->token_buffer.  */
end_comment

begin_function
name|void
name|quote_string
parameter_list|(
name|pfile
parameter_list|,
name|src
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
specifier|const
name|char
modifier|*
name|src
decl_stmt|;
block|{
name|U_CHAR
name|c
decl_stmt|;
name|CPP_PUTC_Q
argument_list|(
name|pfile
argument_list|,
literal|'\"'
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
switch|switch
condition|(
operator|(
name|c
operator|=
operator|*
name|src
operator|++
operator|)
condition|)
block|{
default|default:
if|if
condition|(
name|ISPRINT
argument_list|(
name|c
argument_list|)
condition|)
name|CPP_PUTC_Q
argument_list|(
name|pfile
argument_list|,
name|c
argument_list|)
expr_stmt|;
else|else
block|{
name|sprintf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|CPP_PWRITTEN
argument_list|(
name|pfile
argument_list|)
argument_list|,
literal|"\\%03o"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|CPP_ADJUST_WRITTEN
argument_list|(
name|pfile
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'\"'
case|:
case|case
literal|'\\'
case|:
name|CPP_PUTC_Q
argument_list|(
name|pfile
argument_list|,
literal|'\\'
argument_list|)
expr_stmt|;
name|CPP_PUTC_Q
argument_list|(
name|pfile
argument_list|,
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\0'
case|:
name|CPP_PUTC_Q
argument_list|(
name|pfile
argument_list|,
literal|'\"'
argument_list|)
expr_stmt|;
name|CPP_NUL_TERMINATE_Q
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_comment
comment|/* Re-allocates PFILE->token_buffer so it will hold at least N more chars.  */
end_comment

begin_function
name|void
name|cpp_grow_buffer
parameter_list|(
name|pfile
parameter_list|,
name|n
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|long
name|n
decl_stmt|;
block|{
name|long
name|old_written
init|=
name|CPP_WRITTEN
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
name|pfile
operator|->
name|token_buffer_size
operator|=
name|n
operator|+
literal|2
operator|*
name|pfile
operator|->
name|token_buffer_size
expr_stmt|;
name|pfile
operator|->
name|token_buffer
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xrealloc
argument_list|(
name|pfile
operator|->
name|token_buffer
argument_list|,
name|pfile
operator|->
name|token_buffer_size
argument_list|)
expr_stmt|;
name|CPP_SET_WRITTEN
argument_list|(
name|pfile
argument_list|,
name|old_written
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Process the string STR as if it appeared as the body of a #define    If STR is just an identifier, define it with value 1.    If STR has anything after the identifier, then it should    be identifier=definition. */
end_comment

begin_function
name|void
name|cpp_define
parameter_list|(
name|pfile
parameter_list|,
name|str
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|U_CHAR
modifier|*
name|str
decl_stmt|;
block|{
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|size_t
name|count
decl_stmt|;
comment|/* Copy the entire option so we can modify it.  */
name|count
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|3
expr_stmt|;
name|buf
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|alloca
argument_list|(
name|count
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
name|str
argument_list|,
name|count
operator|-
literal|2
argument_list|)
expr_stmt|;
comment|/* Change the first "=" in the string to a space.  If there is none,      tack " 1" on the end. */
name|p
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|strchr
argument_list|(
name|buf
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
block|{
operator|*
name|p
operator|=
literal|' '
expr_stmt|;
name|count
operator|-=
literal|2
expr_stmt|;
block|}
else|else
name|strcpy
argument_list|(
operator|&
name|buf
index|[
name|count
operator|-
literal|3
index|]
argument_list|,
literal|" 1"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpp_push_buffer
argument_list|(
name|pfile
argument_list|,
name|buf
argument_list|,
name|count
operator|-
literal|1
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|do_define
argument_list|(
name|pfile
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cpp_pop_buffer
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Process the string STR as if it appeared as the body of a #assert. */
end_comment

begin_function
name|void
name|cpp_assert
parameter_list|(
name|pfile
parameter_list|,
name|str
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|U_CHAR
modifier|*
name|str
decl_stmt|;
block|{
if|if
condition|(
name|cpp_push_buffer
argument_list|(
name|pfile
argument_list|,
name|str
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|do_assert
argument_list|(
name|pfile
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cpp_pop_buffer
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|enum
name|cpp_token
name|null_underflow
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
name|CPP_EOF
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|null_cleanup
parameter_list|(
name|pbuf
parameter_list|,
name|pfile
parameter_list|)
name|cpp_buffer
modifier|*
name|pbuf
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|cpp_reader
modifier|*
name|pfile
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Skip a comment - C, C++, or Chill style.  M is the first character    of the comment marker.  If this really is a comment, skip to its    end and return ' '.  If we hit end-of-file before end-of-comment,    return EOF.  If this is not a comment, return M (which will be    '/' or '-').  */
end_comment

begin_function
specifier|static
name|int
name|skip_comment
parameter_list|(
name|pfile
parameter_list|,
name|m
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|int
name|m
decl_stmt|;
block|{
if|if
condition|(
name|m
operator|==
literal|'/'
operator|&&
name|PEEKC
argument_list|()
operator|==
literal|'*'
condition|)
block|{
name|int
name|c
decl_stmt|,
name|prev_c
init|=
operator|-
literal|1
decl_stmt|;
name|long
name|line
decl_stmt|,
name|col
decl_stmt|;
name|FORWARD
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|cpp_buf_line_and_col
argument_list|(
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
argument_list|,
operator|&
name|line
argument_list|,
operator|&
name|col
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|GETC
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
name|cpp_error_with_line
argument_list|(
name|pfile
argument_list|,
name|line
argument_list|,
name|col
argument_list|,
literal|"unterminated comment"
argument_list|)
expr_stmt|;
return|return
name|EOF
return|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|'\r'
condition|)
comment|/* \r cannot be a macro escape marker here. */
name|CPP_BUMP_LINE
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'/'
operator|&&
name|prev_c
operator|==
literal|'*'
condition|)
return|return
literal|' '
return|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'*'
operator|&&
name|prev_c
operator|==
literal|'/'
operator|&&
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|warn_comments
condition|)
name|cpp_warning
argument_list|(
name|pfile
argument_list|,
literal|"`/*' within comment"
argument_list|)
expr_stmt|;
name|prev_c
operator|=
name|c
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|m
operator|==
literal|'/'
operator|&&
name|PEEKC
argument_list|()
operator|==
literal|'/'
operator|&&
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|cplusplus_comments
operator|)
operator|||
operator|(
name|m
operator|==
literal|'-'
operator|&&
name|PEEKC
argument_list|()
operator|==
literal|'-'
operator|&&
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|chill
operator|)
condition|)
block|{
name|FORWARD
argument_list|(
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|c
init|=
name|GETC
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
return|return
literal|' '
return|;
comment|/* Allow // to be terminated by EOF.  */
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
comment|/* Don't consider final '\n' to be part of comment.  */
name|FORWARD
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
literal|' '
return|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\r'
condition|)
comment|/* \r cannot be a macro escape marker here. */
name|CPP_BUMP_LINE
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
block|}
else|else
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/* Identical to skip_comment except that it copies the comment into the    token_buffer.  This is used if put_out_comments.  */
end_comment

begin_function
specifier|static
name|int
name|copy_comment
parameter_list|(
name|pfile
parameter_list|,
name|m
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|int
name|m
decl_stmt|;
block|{
if|if
condition|(
name|m
operator|==
literal|'/'
operator|&&
name|PEEKC
argument_list|()
operator|==
literal|'*'
condition|)
block|{
name|int
name|c
decl_stmt|,
name|prev_c
init|=
operator|-
literal|1
decl_stmt|;
name|long
name|line
decl_stmt|,
name|col
decl_stmt|;
name|CPP_PUTC
argument_list|(
name|pfile
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
name|CPP_PUTC
argument_list|(
name|pfile
argument_list|,
literal|'*'
argument_list|)
expr_stmt|;
name|FORWARD
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|cpp_buf_line_and_col
argument_list|(
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
argument_list|,
operator|&
name|line
argument_list|,
operator|&
name|col
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|GETC
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
name|cpp_error_with_line
argument_list|(
name|pfile
argument_list|,
name|line
argument_list|,
name|col
argument_list|,
literal|"unterminated comment"
argument_list|)
expr_stmt|;
comment|/* We must pretend this was a legitimate comment, so that the 		 output in token_buffer is not passed back tagged CPP_POP. */
return|return
literal|' '
return|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\r'
condition|)
block|{
comment|/* \r cannot be a macro escape marker here. */
name|CPP_BUMP_LINE
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|CPP_PUTC
argument_list|(
name|pfile
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|pfile
operator|->
name|lineno
operator|++
expr_stmt|;
name|CPP_BUMP_LINE
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'/'
operator|&&
name|prev_c
operator|==
literal|'*'
condition|)
return|return
literal|' '
return|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'*'
operator|&&
name|prev_c
operator|==
literal|'/'
operator|&&
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|warn_comments
condition|)
name|cpp_warning
argument_list|(
name|pfile
argument_list|,
literal|"`/*' within comment"
argument_list|)
expr_stmt|;
name|prev_c
operator|=
name|c
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|m
operator|==
literal|'/'
operator|&&
name|PEEKC
argument_list|()
operator|==
literal|'/'
operator|&&
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|cplusplus_comments
operator|)
operator|||
operator|(
name|m
operator|==
literal|'-'
operator|&&
name|PEEKC
argument_list|()
operator|==
literal|'-'
operator|&&
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|chill
operator|)
condition|)
block|{
name|CPP_PUTC
argument_list|(
name|pfile
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|CPP_PUTC
argument_list|(
name|pfile
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|FORWARD
argument_list|(
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|c
init|=
name|GETC
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
return|return
literal|' '
return|;
comment|/* Allow line comments to be terminated by EOF. */
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
comment|/* Don't consider final '\n' to be part of comment.  */
name|FORWARD
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
literal|' '
return|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\r'
condition|)
comment|/* \r cannot be a macro escape marker here. */
name|CPP_BUMP_LINE
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|CPP_PUTC
argument_list|(
name|pfile
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
block|}
else|else
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/* Skip whitespace \-newline and comments.  Does not macro-expand.  */
end_comment

begin_function
name|void
name|cpp_skip_hspace
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|c
operator|=
name|GETC
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
return|return;
elseif|else
if|if
condition|(
name|is_hor_space
index|[
name|c
index|]
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|==
literal|'\f'
operator|||
name|c
operator|==
literal|'\v'
operator|)
operator|&&
name|CPP_PEDANTIC
argument_list|(
name|pfile
argument_list|)
condition|)
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"%s in preprocessing directive"
argument_list|,
name|c
operator|==
literal|'\f'
condition|?
literal|"formfeed"
else|:
literal|"vertical tab"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\r'
condition|)
block|{
comment|/* \r is a backslash-newline marker if !has_escapes, and 	     a deletable-whitespace or no-reexpansion marker otherwise. */
if|if
condition|(
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|->
name|has_escapes
condition|)
block|{
if|if
condition|(
name|PEEKC
argument_list|()
operator|==
literal|' '
condition|)
name|FORWARD
argument_list|(
literal|1
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
else|else
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|->
name|lineno
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'/'
operator|||
name|c
operator|==
literal|'-'
condition|)
block|{
name|c
operator|=
name|skip_comment
argument_list|(
name|pfile
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
return|return;
elseif|else
if|if
condition|(
name|c
operator|!=
literal|' '
condition|)
break|break;
block|}
else|else
break|break;
block|}
name|FORWARD
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read the rest of the current line.    The line is appended to PFILE's output buffer.  */
end_comment

begin_function
specifier|static
name|void
name|copy_rest_of_line
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|c
init|=
name|GETC
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
name|FORWARD
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
case|case
name|EOF
case|:
name|CPP_NUL_TERMINATE
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'\r'
case|:
if|if
condition|(
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|->
name|has_escapes
condition|)
break|break;
else|else
block|{
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|->
name|lineno
operator|++
expr_stmt|;
continue|continue;
block|}
case|case
literal|'\''
case|:
case|case
literal|'\"'
case|:
name|parse_string
argument_list|(
name|pfile
argument_list|,
name|c
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'/'
case|:
if|if
condition|(
name|PEEKC
argument_list|()
operator|==
literal|'*'
operator|&&
name|CPP_TRADITIONAL
argument_list|(
name|pfile
argument_list|)
condition|)
block|{
name|CPP_PUTS
argument_list|(
name|pfile
argument_list|,
literal|"/**/"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|skip_comment
argument_list|(
name|pfile
argument_list|,
name|c
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* else fall through */
case|case
literal|'-'
case|:
name|c
operator|=
name|skip_comment
argument_list|(
name|pfile
argument_list|,
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\f'
case|:
case|case
literal|'\v'
case|:
if|if
condition|(
name|CPP_PEDANTIC
argument_list|(
name|pfile
argument_list|)
condition|)
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"%s in preprocessing directive"
argument_list|,
name|c
operator|==
literal|'\f'
condition|?
literal|"formfeed"
else|:
literal|"vertical tab"
argument_list|)
expr_stmt|;
break|break;
block|}
name|CPP_PUTC
argument_list|(
name|pfile
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* FIXME: It is almost definitely a performance win to make this do    the scan itself.>75% of calls to copy_r_o_l are from here or    skip_if_group, which means the common case is to copy stuff into the    token_buffer only to discard it.  */
end_comment

begin_function
name|void
name|skip_rest_of_line
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|long
name|old
init|=
name|CPP_WRITTEN
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
name|copy_rest_of_line
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|CPP_SET_WRITTEN
argument_list|(
name|pfile
argument_list|,
name|old
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle a possible # directive.    '#' has already been read.  */
end_comment

begin_function
specifier|static
name|int
name|handle_directive
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
specifier|register
name|struct
name|directive
modifier|*
name|kt
decl_stmt|;
name|int
name|ident_length
decl_stmt|;
name|U_CHAR
modifier|*
name|ident
decl_stmt|;
name|long
name|old_written
init|=
name|CPP_WRITTEN
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
name|cpp_skip_hspace
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|c
operator|=
name|PEEKC
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
block|{
comment|/* Handle # followed by a line number.  */
if|if
condition|(
name|CPP_PEDANTIC
argument_list|(
name|pfile
argument_list|)
condition|)
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"`#' followed by integer"
argument_list|)
expr_stmt|;
name|do_line
argument_list|(
name|pfile
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Now find the directive name.  */
name|CPP_PUTC
argument_list|(
name|pfile
argument_list|,
literal|'#'
argument_list|)
expr_stmt|;
name|parse_name
argument_list|(
name|pfile
argument_list|,
name|GETC
argument_list|()
argument_list|)
expr_stmt|;
name|ident
operator|=
name|pfile
operator|->
name|token_buffer
operator|+
name|old_written
operator|+
literal|1
expr_stmt|;
name|ident_length
operator|=
name|CPP_PWRITTEN
argument_list|(
name|pfile
argument_list|)
operator|-
name|ident
expr_stmt|;
if|if
condition|(
name|ident_length
operator|==
literal|0
condition|)
block|{
comment|/* A line of just `#' becomes blank.  */
if|if
condition|(
name|PEEKC
argument_list|()
operator|==
literal|'\n'
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
comment|/*    * Decode the keyword and call the appropriate expansion    * routine, after moving the input pointer up to the next line.    */
for|for
control|(
name|kt
operator|=
name|directive_table
init|;
condition|;
name|kt
operator|++
control|)
block|{
if|if
condition|(
name|kt
operator|->
name|length
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|kt
operator|->
name|length
operator|==
name|ident_length
operator|&&
operator|!
name|strncmp
argument_list|(
name|kt
operator|->
name|name
argument_list|,
name|ident
argument_list|,
name|ident_length
argument_list|)
condition|)
break|break;
block|}
name|CPP_SET_WRITTEN
argument_list|(
name|pfile
argument_list|,
name|old_written
argument_list|)
expr_stmt|;
call|(
modifier|*
name|kt
operator|->
name|func
call|)
argument_list|(
name|pfile
argument_list|,
name|kt
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Pass a directive through to the output file.    BUF points to the contents of the directive, as a contiguous string.    LEN is the length of the string pointed to by BUF.    KEYWORD is the keyword-table entry for the directive.  */
end_comment

begin_function
specifier|static
name|void
name|pass_thru_directive
parameter_list|(
name|buf
parameter_list|,
name|len
parameter_list|,
name|pfile
parameter_list|,
name|keyword
parameter_list|)
name|U_CHAR
modifier|*
name|buf
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|struct
name|directive
modifier|*
name|keyword
decl_stmt|;
block|{
specifier|register
name|unsigned
name|keyword_length
init|=
name|keyword
operator|->
name|length
decl_stmt|;
name|CPP_RESERVE
argument_list|(
name|pfile
argument_list|,
literal|1
operator|+
name|keyword_length
operator|+
name|len
argument_list|)
expr_stmt|;
name|CPP_PUTC_Q
argument_list|(
name|pfile
argument_list|,
literal|'#'
argument_list|)
expr_stmt|;
name|CPP_PUTS_Q
argument_list|(
name|pfile
argument_list|,
name|keyword
operator|->
name|name
argument_list|,
name|keyword_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|!=
literal|0
operator|&&
name|buf
index|[
literal|0
index|]
operator|!=
literal|' '
condition|)
name|CPP_PUTC_Q
argument_list|(
name|pfile
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|CPP_PUTS_Q
argument_list|(
name|pfile
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check a purported macro name SYMNAME, and yield its length.    ASSERTION is nonzero if this is really for an assertion name.  */
end_comment

begin_function
name|int
name|check_macro_name
parameter_list|(
name|pfile
parameter_list|,
name|symname
parameter_list|,
name|assertion
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|U_CHAR
modifier|*
name|symname
decl_stmt|;
name|int
name|assertion
decl_stmt|;
block|{
name|U_CHAR
modifier|*
name|p
decl_stmt|;
name|int
name|sym_length
decl_stmt|;
for|for
control|(
name|p
operator|=
name|symname
init|;
name|is_idchar
index|[
operator|*
name|p
index|]
condition|;
name|p
operator|++
control|)
empty_stmt|;
name|sym_length
operator|=
name|p
operator|-
name|symname
expr_stmt|;
if|if
condition|(
name|sym_length
operator|==
literal|0
operator|||
operator|(
name|sym_length
operator|==
literal|1
operator|&&
operator|*
name|symname
operator|==
literal|'L'
operator|&&
operator|(
operator|*
name|p
operator|==
literal|'\''
operator|||
operator|*
name|p
operator|==
literal|'"'
operator|)
operator|)
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
name|assertion
condition|?
literal|"invalid assertion name"
else|:
literal|"invalid macro name"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|is_idstart
index|[
operator|*
name|symname
index|]
operator|||
operator|(
operator|!
name|strncmp
argument_list|(
name|symname
argument_list|,
literal|"defined"
argument_list|,
literal|7
argument_list|)
operator|&&
name|sym_length
operator|==
literal|7
operator|)
condition|)
block|{
name|U_CHAR
modifier|*
name|msg
decl_stmt|;
comment|/* what pain...  */
name|msg
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|alloca
argument_list|(
name|sym_length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|symname
argument_list|,
name|msg
argument_list|,
name|sym_length
argument_list|)
expr_stmt|;
name|msg
index|[
name|sym_length
index|]
operator|=
literal|0
expr_stmt|;
name|cpp_error
argument_list|(
name|pfile
argument_list|,
operator|(
name|assertion
condition|?
literal|"invalid assertion name `%s'"
else|:
literal|"invalid macro name `%s'"
operator|)
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
return|return
name|sym_length
return|;
block|}
end_function

begin_comment
comment|/* Process a #define command. KEYWORD is the keyword-table entry for #define, or NULL for a "predefined" macro.  */
end_comment

begin_function
specifier|static
name|int
name|do_define
parameter_list|(
name|pfile
parameter_list|,
name|keyword
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|struct
name|directive
modifier|*
name|keyword
decl_stmt|;
block|{
name|int
name|hashcode
decl_stmt|;
name|MACRODEF
name|mdef
decl_stmt|;
name|HASHNODE
modifier|*
name|hp
decl_stmt|;
name|long
name|here
decl_stmt|;
name|U_CHAR
modifier|*
name|macro
decl_stmt|,
modifier|*
name|buf
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|here
operator|=
name|CPP_WRITTEN
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|copy_rest_of_line
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
comment|/* Copy out the line so we can pop the token buffer. */
name|buf
operator|=
name|pfile
operator|->
name|token_buffer
operator|+
name|here
expr_stmt|;
name|end
operator|=
name|CPP_PWRITTEN
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|macro
operator|=
name|alloca
argument_list|(
name|end
operator|-
name|buf
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|buf
argument_list|,
name|macro
argument_list|,
name|end
operator|-
name|buf
operator|+
literal|1
argument_list|)
expr_stmt|;
name|end
operator|=
name|macro
operator|+
operator|(
name|end
operator|-
name|buf
operator|)
expr_stmt|;
name|CPP_SET_WRITTEN
argument_list|(
name|pfile
argument_list|,
name|here
argument_list|)
expr_stmt|;
name|mdef
operator|=
name|create_definition
argument_list|(
name|macro
argument_list|,
name|end
argument_list|,
name|pfile
argument_list|,
name|keyword
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mdef
operator|.
name|defn
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|hashcode
operator|=
name|hashf
argument_list|(
name|mdef
operator|.
name|symnam
argument_list|,
name|mdef
operator|.
name|symlen
argument_list|,
name|HASHSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hp
operator|=
name|cpp_lookup
argument_list|(
name|pfile
argument_list|,
name|mdef
operator|.
name|symnam
argument_list|,
name|mdef
operator|.
name|symlen
argument_list|,
name|hashcode
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|int
name|ok
init|=
literal|0
decl_stmt|;
comment|/* Redefining a precompiled key is ok.  */
if|if
condition|(
name|hp
operator|->
name|type
operator|==
name|T_PCSTRING
condition|)
name|ok
operator|=
literal|1
expr_stmt|;
comment|/* Redefining a macro is ok if the definitions are the same.  */
elseif|else
if|if
condition|(
name|hp
operator|->
name|type
operator|==
name|T_MACRO
condition|)
name|ok
operator|=
operator|!
name|compare_defs
argument_list|(
name|pfile
argument_list|,
name|mdef
operator|.
name|defn
argument_list|,
name|hp
operator|->
name|value
operator|.
name|defn
argument_list|)
expr_stmt|;
comment|/* Redefining a constant is ok with -D.  */
elseif|else
if|if
condition|(
name|hp
operator|->
name|type
operator|==
name|T_CONST
operator|||
name|hp
operator|->
name|type
operator|==
name|T_STDC
condition|)
name|ok
operator|=
operator|!
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|done_initializing
expr_stmt|;
comment|/* Print the warning if it's not ok.  */
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"`%.*s' redefined"
argument_list|,
name|mdef
operator|.
name|symlen
argument_list|,
name|mdef
operator|.
name|symnam
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|type
operator|==
name|T_MACRO
condition|)
name|cpp_pedwarn_with_file_and_line
argument_list|(
name|pfile
argument_list|,
name|hp
operator|->
name|value
operator|.
name|defn
operator|->
name|file
argument_list|,
name|hp
operator|->
name|value
operator|.
name|defn
operator|->
name|line
argument_list|,
literal|"this is the location of the previous definition"
argument_list|)
expr_stmt|;
block|}
comment|/* Replace the old definition.  */
name|hp
operator|->
name|type
operator|=
name|T_MACRO
expr_stmt|;
name|hp
operator|->
name|value
operator|.
name|defn
operator|=
name|mdef
operator|.
name|defn
expr_stmt|;
block|}
else|else
name|cpp_install
argument_list|(
name|pfile
argument_list|,
name|mdef
operator|.
name|symnam
argument_list|,
name|mdef
operator|.
name|symlen
argument_list|,
name|T_MACRO
argument_list|,
operator|(
name|char
operator|*
operator|)
name|mdef
operator|.
name|defn
argument_list|,
name|hashcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|keyword
condition|)
block|{
if|if
condition|(
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|debug_output
operator|||
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|dump_macros
operator|==
name|dump_definitions
condition|)
name|dump_definition
argument_list|(
name|pfile
argument_list|,
name|mdef
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|dump_macros
operator|==
name|dump_names
condition|)
name|pass_thru_directive
argument_list|(
name|mdef
operator|.
name|symnam
argument_list|,
name|mdef
operator|.
name|symlen
argument_list|,
name|pfile
argument_list|,
name|keyword
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Allocate a new cpp_buffer for PFILE, and push it on the input buffer stack.    If BUFFER != NULL, then use the LENGTH characters in BUFFER    as the new input buffer.    Return the new buffer, or NULL on failure.  */
end_comment

begin_function
name|cpp_buffer
modifier|*
name|cpp_push_buffer
parameter_list|(
name|pfile
parameter_list|,
name|buffer
parameter_list|,
name|length
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|U_CHAR
modifier|*
name|buffer
decl_stmt|;
name|long
name|length
decl_stmt|;
block|{
name|cpp_buffer
modifier|*
name|buf
init|=
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
name|cpp_buffer
modifier|*
name|new
decl_stmt|;
if|if
condition|(
operator|++
name|pfile
operator|->
name|buffer_stack_depth
operator|==
name|CPP_STACK_MAX
condition|)
block|{
name|cpp_fatal
argument_list|(
name|pfile
argument_list|,
literal|"macro or `#include' recursion too deep"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|new
operator|=
operator|(
name|cpp_buffer
operator|*
operator|)
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|cpp_buffer
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|new
operator|->
name|if_stack
operator|=
name|pfile
operator|->
name|if_stack
expr_stmt|;
name|new
operator|->
name|cleanup
operator|=
name|null_cleanup
expr_stmt|;
name|new
operator|->
name|underflow
operator|=
name|null_underflow
expr_stmt|;
name|new
operator|->
name|buf
operator|=
name|new
operator|->
name|cur
operator|=
name|buffer
expr_stmt|;
name|new
operator|->
name|alimit
operator|=
name|new
operator|->
name|rlimit
operator|=
name|buffer
operator|+
name|length
expr_stmt|;
name|new
operator|->
name|prev
operator|=
name|buf
expr_stmt|;
name|new
operator|->
name|mark
operator|=
operator|-
literal|1
expr_stmt|;
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|=
name|new
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_function
name|cpp_buffer
modifier|*
name|cpp_pop_buffer
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|cpp_buffer
modifier|*
name|buf
init|=
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
call|(
modifier|*
name|buf
operator|->
name|cleanup
call|)
argument_list|(
name|buf
argument_list|,
name|pfile
argument_list|)
expr_stmt|;
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|=
name|CPP_PREV_BUFFER
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|buffer_stack_depth
operator|--
expr_stmt|;
return|return
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Scan until CPP_BUFFER (PFILE) is exhausted into PFILE->token_buffer.    Pop the buffer when done.  */
end_comment

begin_function
name|void
name|cpp_scan_buffer
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|cpp_buffer
modifier|*
name|buffer
init|=
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|enum
name|cpp_token
name|token
init|=
name|cpp_get_token
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
if|if
condition|(
name|token
operator|==
name|CPP_EOF
condition|)
comment|/* Should not happen ...  */
break|break;
if|if
condition|(
name|token
operator|==
name|CPP_POP
operator|&&
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|==
name|buffer
condition|)
block|{
name|cpp_pop_buffer
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Rescan a string (which may have escape marks) into pfile's buffer.  * Place the result in pfile->token_buffer.  *  * The input is copied before it is scanned, so it is safe to pass  * it something from the token_buffer that will get overwritten  * (because it follows CPP_WRITTEN).  This is used by do_include.  */
end_comment

begin_function
name|void
name|cpp_expand_to_buffer
parameter_list|(
name|pfile
parameter_list|,
name|buf
parameter_list|,
name|length
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|U_CHAR
modifier|*
name|buf
decl_stmt|;
name|int
name|length
decl_stmt|;
block|{
specifier|register
name|cpp_buffer
modifier|*
name|ip
decl_stmt|;
if|#
directive|if
literal|0
block|cpp_buffer obuf;
endif|#
directive|endif
name|U_CHAR
modifier|*
name|buf1
decl_stmt|;
if|#
directive|if
literal|0
block|int odepth = indepth;
endif|#
directive|endif
if|if
condition|(
name|length
operator|<
literal|0
condition|)
block|{
name|cpp_fatal
argument_list|(
name|pfile
argument_list|,
literal|"internal error: length< 0 in cpp_expand_to_buffer"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Set up the input on the input stack.  */
name|buf1
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|alloca
argument_list|(
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buf1
argument_list|,
name|buf
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|buf1
index|[
name|length
index|]
operator|=
literal|0
expr_stmt|;
name|ip
operator|=
name|cpp_push_buffer
argument_list|(
name|pfile
argument_list|,
name|buf1
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|==
name|NULL
condition|)
return|return;
name|ip
operator|->
name|has_escapes
operator|=
literal|1
expr_stmt|;
if|#
directive|if
literal|0
block|ip->lineno = obuf.lineno = 1;
endif|#
directive|endif
comment|/* Scan the input, create the output.  */
name|cpp_scan_buffer
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|CPP_NUL_TERMINATE
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cpp_buf_line_and_col
parameter_list|(
name|pbuf
parameter_list|,
name|linep
parameter_list|,
name|colp
parameter_list|)
specifier|register
name|cpp_buffer
modifier|*
name|pbuf
decl_stmt|;
name|long
modifier|*
name|linep
decl_stmt|,
decl|*
name|colp
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
name|pbuf
condition|)
block|{
operator|*
name|linep
operator|=
name|pbuf
operator|->
name|lineno
expr_stmt|;
if|if
condition|(
name|colp
condition|)
operator|*
name|colp
operator|=
name|pbuf
operator|->
name|cur
operator|-
name|pbuf
operator|->
name|line_base
expr_stmt|;
block|}
else|else
block|{
operator|*
name|linep
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|colp
condition|)
operator|*
name|colp
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Return the cpp_buffer that corresponds to a file (not a macro).  */
end_comment

begin_function
name|cpp_buffer
modifier|*
name|cpp_file_buffer
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|cpp_buffer
modifier|*
name|ip
init|=
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|ip
operator|!=
name|CPP_NULL_BUFFER
argument_list|(
name|pfile
argument_list|)
condition|;
name|ip
operator|=
name|CPP_PREV_BUFFER
argument_list|(
name|ip
argument_list|)
control|)
if|if
condition|(
name|ip
operator|->
name|fname
operator|!=
name|NULL
condition|)
return|return
name|ip
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * write out a #line command, for instance, after an #include file.  * FILE_CHANGE says whether we are entering a file, leaving, or neither.  */
end_comment

begin_function
name|void
name|output_line_command
parameter_list|(
name|pfile
parameter_list|,
name|file_change
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|enum
name|file_change_code
name|file_change
decl_stmt|;
block|{
name|long
name|line
decl_stmt|;
name|cpp_buffer
modifier|*
name|ip
init|=
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
if|if
condition|(
name|ip
operator|->
name|fname
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|no_line_commands
operator|||
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|no_output
condition|)
return|return;
name|cpp_buf_line_and_col
argument_list|(
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
argument_list|,
operator|&
name|line
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* If the current file has not changed, we omit the #line if it would      appear to be a no-op, and we output a few newlines instead      if we want to increase the line number by a small amount.      We cannot do this if pfile->lineno is zero, because that means we      haven't output any line commands yet.  (The very first line command      output is a `same_file' command.)  */
if|if
condition|(
name|file_change
operator|==
name|same_file
operator|&&
name|pfile
operator|->
name|lineno
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|line
operator|==
name|pfile
operator|->
name|lineno
condition|)
return|return;
comment|/* If the inherited line number is a little too small, 	 output some newlines instead of a #line command.  */
if|if
condition|(
name|line
operator|>
name|pfile
operator|->
name|lineno
operator|&&
name|line
operator|<
name|pfile
operator|->
name|lineno
operator|+
literal|8
condition|)
block|{
name|CPP_RESERVE
argument_list|(
name|pfile
argument_list|,
literal|20
argument_list|)
expr_stmt|;
while|while
condition|(
name|line
operator|>
name|pfile
operator|->
name|lineno
condition|)
block|{
name|CPP_PUTC_Q
argument_list|(
name|pfile
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|lineno
operator|++
expr_stmt|;
block|}
return|return;
block|}
block|}
name|CPP_RESERVE
argument_list|(
name|pfile
argument_list|,
literal|4
operator|*
name|strlen
argument_list|(
name|ip
operator|->
name|nominal_fname
argument_list|)
operator|+
literal|50
argument_list|)
expr_stmt|;
name|CPP_PUTS_Q
argument_list|(
name|pfile
argument_list|,
literal|"# "
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|CPP_PWRITTEN
argument_list|(
name|pfile
argument_list|)
argument_list|,
literal|"%ld "
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|CPP_ADJUST_WRITTEN
argument_list|(
name|pfile
argument_list|,
name|strlen
argument_list|(
name|CPP_PWRITTEN
argument_list|(
name|pfile
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|quote_string
argument_list|(
name|pfile
argument_list|,
name|ip
operator|->
name|nominal_fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|file_change
operator|!=
name|same_file
condition|)
block|{
name|CPP_PUTC_Q
argument_list|(
name|pfile
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|CPP_PUTC_Q
argument_list|(
name|pfile
argument_list|,
name|file_change
operator|==
name|enter_file
condition|?
literal|'1'
else|:
literal|'2'
argument_list|)
expr_stmt|;
block|}
comment|/* Tell cc1 if following text comes from a system header file.  */
if|if
condition|(
name|ip
operator|->
name|system_header_p
condition|)
block|{
name|CPP_PUTC_Q
argument_list|(
name|pfile
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|CPP_PUTC_Q
argument_list|(
name|pfile
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|NO_IMPLICIT_EXTERN_C
comment|/* Tell cc1plus if following text should be treated as C.  */
if|if
condition|(
name|ip
operator|->
name|system_header_p
operator|==
literal|2
operator|&&
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|cplusplus
condition|)
block|{
name|CPP_PUTC_Q
argument_list|(
name|pfile
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|CPP_PUTC_Q
argument_list|(
name|pfile
argument_list|,
literal|'4'
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|CPP_PUTC_Q
argument_list|(
name|pfile
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|lineno
operator|=
name|line
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Like cpp_get_token, except that it does not read past end-of-line.    Also, horizontal space is skipped, and macros are popped.  */
end_comment

begin_function
specifier|static
name|enum
name|cpp_token
name|get_directive_token
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|long
name|old_written
init|=
name|CPP_WRITTEN
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
name|enum
name|cpp_token
name|token
decl_stmt|;
name|cpp_skip_hspace
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|PEEKC
argument_list|()
operator|==
literal|'\n'
condition|)
return|return
name|CPP_VSPACE
return|;
name|token
operator|=
name|cpp_get_token
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|token
condition|)
block|{
case|case
name|CPP_POP
case|:
if|if
condition|(
operator|!
name|CPP_IS_MACRO_BUFFER
argument_list|(
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
argument_list|)
condition|)
return|return
name|token
return|;
comment|/* ... else fall though ...  */
case|case
name|CPP_HSPACE
case|:
case|case
name|CPP_COMMENT
case|:
name|CPP_SET_WRITTEN
argument_list|(
name|pfile
argument_list|,
name|old_written
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
name|token
return|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Handle #include and #import.    This function expects to see "fname" or<fname> on the input.     The input is normally in part of the output_buffer following    CPP_WRITTEN, and will get overwritten by output_line_command.    I.e. in input file specification has been popped by handle_directive.    This is safe.  */
end_comment

begin_function
specifier|static
name|int
name|do_include
parameter_list|(
name|pfile
parameter_list|,
name|keyword
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|struct
name|directive
modifier|*
name|keyword
decl_stmt|;
block|{
name|int
name|importing
init|=
operator|(
name|keyword
operator|->
name|type
operator|==
name|T_IMPORT
operator|)
decl_stmt|;
name|int
name|skip_dirs
init|=
operator|(
name|keyword
operator|->
name|type
operator|==
name|T_INCLUDE_NEXT
operator|)
decl_stmt|;
name|int
name|angle_brackets
init|=
literal|0
decl_stmt|;
comment|/* 0 for "...", 1 for<...> */
name|int
name|before
decl_stmt|;
comment|/* included before? */
name|long
name|flen
decl_stmt|;
name|unsigned
name|char
modifier|*
name|ftok
decl_stmt|;
name|cpp_buffer
modifier|*
name|fp
decl_stmt|;
name|enum
name|cpp_token
name|token
decl_stmt|;
comment|/* Chain of dirs to search */
name|struct
name|include_hash
modifier|*
name|ihash
decl_stmt|;
name|struct
name|file_name_list
modifier|*
name|search_start
decl_stmt|;
name|long
name|old_written
init|=
name|CPP_WRITTEN
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
name|int
name|fd
decl_stmt|;
if|if
condition|(
name|CPP_PEDANTIC
argument_list|(
name|pfile
argument_list|)
operator|&&
operator|!
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|->
name|system_header_p
condition|)
block|{
if|if
condition|(
name|importing
condition|)
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"ANSI C does not allow `#import'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|skip_dirs
condition|)
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"ANSI C does not allow `#include_next'"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|importing
operator|&&
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|warn_import
operator|&&
operator|!
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|inhibit_warnings
operator|&&
operator|!
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|->
name|system_header_p
operator|&&
operator|!
name|pfile
operator|->
name|import_warning
condition|)
block|{
name|pfile
operator|->
name|import_warning
operator|=
literal|1
expr_stmt|;
name|cpp_warning
argument_list|(
name|pfile
argument_list|,
literal|"#import is obsolete, use an #ifndef wrapper in the header file"
argument_list|)
expr_stmt|;
block|}
name|pfile
operator|->
name|parsing_include_directive
operator|++
expr_stmt|;
name|token
operator|=
name|get_directive_token
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|parsing_include_directive
operator|--
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|CPP_STRING
condition|)
block|{
if|if
condition|(
name|pfile
operator|->
name|token_buffer
index|[
name|old_written
index|]
operator|==
literal|'<'
condition|)
name|angle_brackets
operator|=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|VMS
elseif|else
if|if
condition|(
name|token
operator|==
name|CPP_NAME
condition|)
block|{
comment|/* Support '#include xyz' like VAX-C.  It is taken as          '#include<xyz.h>' and generates a warning.  */
name|cpp_warning
argument_list|(
name|pfile
argument_list|,
literal|"`#include filename' is obsolete, use `#include<filename.h>'"
argument_list|)
expr_stmt|;
name|angle_brackets
operator|=
literal|1
expr_stmt|;
comment|/* Append the missing `.h' to the name. */
name|CPP_PUTS
argument_list|(
name|pfile
argument_list|,
literal|".h"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
else|else
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"`#%s' expects \"FILENAME\" or<FILENAME>"
argument_list|,
name|keyword
operator|->
name|name
argument_list|)
expr_stmt|;
name|CPP_SET_WRITTEN
argument_list|(
name|pfile
argument_list|,
name|old_written
argument_list|)
expr_stmt|;
name|skip_rest_of_line
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|flen
operator|=
name|CPP_WRITTEN
argument_list|(
name|pfile
argument_list|)
operator|-
name|old_written
expr_stmt|;
name|ftok
operator|=
name|alloca
argument_list|(
name|flen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ftok
argument_list|,
name|pfile
operator|->
name|token_buffer
operator|+
name|old_written
argument_list|,
name|flen
argument_list|)
expr_stmt|;
name|ftok
index|[
name|flen
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|get_directive_token
argument_list|(
name|pfile
argument_list|)
operator|!=
name|CPP_VSPACE
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"junk at end of `#include'"
argument_list|)
expr_stmt|;
name|skip_rest_of_line
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
name|CPP_SET_WRITTEN
argument_list|(
name|pfile
argument_list|,
name|old_written
argument_list|)
expr_stmt|;
if|if
condition|(
name|flen
operator|==
literal|0
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"empty file name in `#%s'"
argument_list|,
name|keyword
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|dump_includes
condition|)
name|pass_thru_directive
argument_list|(
name|ftok
argument_list|,
name|flen
ifdef|#
directive|ifdef
name|VMS
operator|-
operator|(
operator|(
name|token
operator|==
name|CPP_NAME
operator|)
condition|?
literal|2
else|:
literal|0
operator|)
endif|#
directive|endif
argument_list|,
name|pfile
argument_list|,
name|keyword
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VMS
if|if
condition|(
name|token
operator|==
name|CPP_STRING
condition|)
endif|#
directive|endif
block|{
name|ftok
operator|++
expr_stmt|;
name|flen
operator|-=
literal|2
expr_stmt|;
name|ftok
index|[
name|flen
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|search_start
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|fp
operator|=
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
init|;
name|fp
operator|!=
name|CPP_NULL_BUFFER
argument_list|(
name|pfile
argument_list|)
condition|;
name|fp
operator|=
name|CPP_PREV_BUFFER
argument_list|(
name|fp
argument_list|)
control|)
if|if
condition|(
name|fp
operator|->
name|fname
operator|!=
name|NULL
condition|)
break|break;
if|if
condition|(
name|fp
operator|==
name|CPP_NULL_BUFFER
argument_list|(
name|pfile
argument_list|)
condition|)
block|{
name|cpp_fatal
argument_list|(
name|pfile
argument_list|,
literal|"cpp internal error: fp == NULL_BUFFER in do_include"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* For #include_next, skip in the search path past the dir in which the      containing file was found.  Treat files specified using an absolute path      as if there are no more directories to search.  Treat the primary source      file like any other included source, but generate a warning.  */
if|if
condition|(
name|skip_dirs
operator|&&
name|CPP_PREV_BUFFER
argument_list|(
name|fp
argument_list|)
operator|!=
name|CPP_NULL_BUFFER
argument_list|(
name|pfile
argument_list|)
condition|)
block|{
if|if
condition|(
name|fp
operator|->
name|ihash
operator|->
name|foundhere
operator|!=
name|ABSOLUTE_PATH
condition|)
name|search_start
operator|=
name|fp
operator|->
name|ihash
operator|->
name|foundhere
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|skip_dirs
condition|)
name|cpp_warning
argument_list|(
name|pfile
argument_list|,
literal|"#include_next in primary source file"
argument_list|)
expr_stmt|;
if|if
condition|(
name|angle_brackets
condition|)
name|search_start
operator|=
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|bracket_include
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|ignore_srcdir
condition|)
block|{
if|if
condition|(
name|fp
condition|)
name|search_start
operator|=
name|fp
operator|->
name|actual_dir
expr_stmt|;
block|}
else|else
name|search_start
operator|=
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|quote_include
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|search_start
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"No include path in which to find %s"
argument_list|,
name|ftok
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|fd
operator|=
name|find_include_file
argument_list|(
name|pfile
argument_list|,
name|ftok
argument_list|,
name|search_start
argument_list|,
operator|&
name|ihash
argument_list|,
operator|&
name|before
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|2
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|print_deps_missing_files
operator|&&
name|CPP_PRINT_DEPS
argument_list|(
name|pfile
argument_list|)
operator|>
operator|(
name|angle_brackets
operator|||
operator|(
name|pfile
operator|->
name|system_include_depth
operator|>
literal|0
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|angle_brackets
condition|)
name|deps_output
argument_list|(
name|pfile
argument_list|,
name|ftok
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|struct
name|file_name_list
modifier|*
name|ptr
decl_stmt|;
comment|/* If requested as a system header, assume it belongs in 		 the first system header directory. */
if|if
condition|(
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|bracket_include
condition|)
name|ptr
operator|=
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|bracket_include
expr_stmt|;
else|else
name|ptr
operator|=
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|quote_include
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|ptr
operator|->
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
name|ftok
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|->
name|name
operator|!=
literal|'\0'
condition|)
block|{
name|strcpy
argument_list|(
name|p
argument_list|,
name|ptr
operator|->
name|name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|p
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
block|}
name|strcat
argument_list|(
name|p
argument_list|,
name|ftok
argument_list|)
expr_stmt|;
name|deps_output
argument_list|(
name|pfile
argument_list|,
name|p
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If -M was specified, and this header file won't be added to 	 the dependency list, then don't count this as an error, 	 because we can still produce correct output.  Otherwise, we 	 can't produce correct output, because there may be 	 dependencies we need inside the missing file, and we don't 	 know what directory this missing file exists in. */
elseif|else
if|if
condition|(
name|CPP_PRINT_DEPS
argument_list|(
name|pfile
argument_list|)
operator|&&
operator|(
name|CPP_PRINT_DEPS
argument_list|(
name|pfile
argument_list|)
operator|<=
operator|(
name|angle_brackets
operator|||
operator|(
name|pfile
operator|->
name|system_include_depth
operator|>
literal|0
operator|)
operator|)
operator|)
condition|)
name|cpp_warning
argument_list|(
name|pfile
argument_list|,
literal|"No include path in which to find %s"
argument_list|,
name|ftok
argument_list|)
expr_stmt|;
else|else
name|cpp_error_from_errno
argument_list|(
name|pfile
argument_list|,
name|ftok
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* For -M, add the file to the dependencies on its first inclusion. */
if|if
condition|(
operator|!
name|before
operator|&&
operator|(
name|CPP_PRINT_DEPS
argument_list|(
name|pfile
argument_list|)
operator|>
operator|(
name|angle_brackets
operator|||
operator|(
name|pfile
operator|->
name|system_include_depth
operator|>
literal|0
operator|)
operator|)
operator|)
condition|)
name|deps_output
argument_list|(
name|pfile
argument_list|,
name|ihash
operator|->
name|name
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
comment|/* Handle -H option.  */
if|if
condition|(
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|print_include_names
condition|)
block|{
name|fp
operator|=
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|fp
operator|=
name|CPP_PREV_BUFFER
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|CPP_NULL_BUFFER
argument_list|(
name|pfile
argument_list|)
condition|)
name|putc
argument_list|(
literal|'.'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %s\n"
argument_list|,
name|ihash
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* Actually process the file */
if|if
condition|(
name|importing
condition|)
name|ihash
operator|->
name|control_macro
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|cpp_push_buffer
argument_list|(
name|pfile
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|angle_brackets
condition|)
name|pfile
operator|->
name|system_include_depth
operator|++
expr_stmt|;
comment|/* Decremented in file_cleanup. */
if|if
condition|(
name|finclude
argument_list|(
name|pfile
argument_list|,
name|fd
argument_list|,
name|ihash
argument_list|)
condition|)
block|{
name|output_line_command
argument_list|(
name|pfile
argument_list|,
name|enter_file
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|only_seen_white
operator|=
literal|2
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Interpret #line command.    Note that the filename string (if any) is treated as if it were an    include filename.  That means no escape handling.  */
end_comment

begin_function
specifier|static
name|int
name|do_line
parameter_list|(
name|pfile
parameter_list|,
name|keyword
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|struct
name|directive
modifier|*
name|keyword
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|cpp_buffer
modifier|*
name|ip
init|=
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
name|int
name|new_lineno
decl_stmt|;
name|long
name|old_written
init|=
name|CPP_WRITTEN
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
name|enum
name|file_change_code
name|file_change
init|=
name|same_file
decl_stmt|;
name|enum
name|cpp_token
name|token
decl_stmt|;
name|char
modifier|*
name|x
decl_stmt|;
name|token
operator|=
name|get_directive_token
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|CPP_NUMBER
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"token after `#line' is not an integer"
argument_list|)
expr_stmt|;
goto|goto
name|bad_line_directive
goto|;
block|}
name|new_lineno
operator|=
name|strtol
argument_list|(
name|pfile
operator|->
name|token_buffer
operator|+
name|old_written
argument_list|,
operator|&
name|x
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"token after `#line' is not an integer"
argument_list|)
expr_stmt|;
goto|goto
name|bad_line_directive
goto|;
block|}
name|CPP_SET_WRITTEN
argument_list|(
name|pfile
argument_list|,
name|old_written
argument_list|)
expr_stmt|;
if|if
condition|(
name|CPP_PEDANTIC
argument_list|(
name|pfile
argument_list|)
operator|&&
name|new_lineno
operator|<=
literal|0
condition|)
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"line number out of range in `#line' command"
argument_list|)
expr_stmt|;
name|token
operator|=
name|get_directive_token
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|CPP_STRING
condition|)
block|{
name|U_CHAR
modifier|*
name|fname
init|=
name|pfile
operator|->
name|token_buffer
operator|+
name|old_written
operator|+
literal|1
decl_stmt|;
name|U_CHAR
modifier|*
name|end_name
init|=
name|CPP_PWRITTEN
argument_list|(
name|pfile
argument_list|)
operator|-
literal|1
decl_stmt|;
name|long
name|num_start
init|=
name|CPP_WRITTEN
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
name|token
operator|=
name|get_directive_token
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|CPP_VSPACE
operator|&&
name|token
operator|!=
name|CPP_EOF
operator|&&
name|token
operator|!=
name|CPP_POP
condition|)
block|{
name|U_CHAR
modifier|*
name|p
init|=
name|pfile
operator|->
name|token_buffer
operator|+
name|num_start
decl_stmt|;
if|if
condition|(
name|CPP_PEDANTIC
argument_list|(
name|pfile
argument_list|)
condition|)
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"garbage at end of `#line' command"
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|CPP_NUMBER
operator|||
operator|*
name|p
operator|<
literal|'0'
operator|||
operator|*
name|p
operator|>
literal|'4'
operator|||
name|p
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"invalid format `#line' command"
argument_list|)
expr_stmt|;
goto|goto
name|bad_line_directive
goto|;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'1'
condition|)
name|file_change
operator|=
name|enter_file
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'2'
condition|)
name|file_change
operator|=
name|leave_file
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'3'
condition|)
name|ip
operator|->
name|system_header_p
operator|=
literal|1
expr_stmt|;
else|else
comment|/* if (*p == '4') */
name|ip
operator|->
name|system_header_p
operator|=
literal|2
expr_stmt|;
name|CPP_SET_WRITTEN
argument_list|(
name|pfile
argument_list|,
name|num_start
argument_list|)
expr_stmt|;
name|token
operator|=
name|get_directive_token
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|p
operator|=
name|pfile
operator|->
name|token_buffer
operator|+
name|num_start
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|CPP_NUMBER
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|&&
operator|(
operator|*
name|p
operator|==
literal|'3'
operator|||
operator|*
name|p
operator|==
literal|'4'
operator|)
condition|)
block|{
name|ip
operator|->
name|system_header_p
operator|=
operator|*
name|p
operator|==
literal|'3'
condition|?
literal|1
else|:
literal|2
expr_stmt|;
name|token
operator|=
name|get_directive_token
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|token
operator|!=
name|CPP_VSPACE
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"invalid format `#line' command"
argument_list|)
expr_stmt|;
goto|goto
name|bad_line_directive
goto|;
block|}
block|}
operator|*
name|end_name
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|fname
argument_list|,
name|ip
operator|->
name|nominal_fname
argument_list|)
condition|)
block|{
name|char
modifier|*
name|newname
decl_stmt|,
modifier|*
name|oldname
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|fname
argument_list|,
name|ip
operator|->
name|fname
argument_list|)
condition|)
name|newname
operator|=
name|ip
operator|->
name|fname
expr_stmt|;
elseif|else
if|if
condition|(
name|ip
operator|->
name|last_nominal_fname
operator|&&
operator|!
name|strcmp
argument_list|(
name|fname
argument_list|,
name|ip
operator|->
name|last_nominal_fname
argument_list|)
condition|)
name|newname
operator|=
name|ip
operator|->
name|last_nominal_fname
expr_stmt|;
else|else
name|newname
operator|=
name|xstrdup
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|oldname
operator|=
name|ip
operator|->
name|nominal_fname
expr_stmt|;
name|ip
operator|->
name|nominal_fname
operator|=
name|newname
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|last_nominal_fname
operator|&&
name|ip
operator|->
name|last_nominal_fname
operator|!=
name|oldname
operator|&&
name|ip
operator|->
name|last_nominal_fname
operator|!=
name|newname
operator|&&
name|ip
operator|->
name|last_nominal_fname
operator|!=
name|ip
operator|->
name|fname
condition|)
name|free
argument_list|(
name|ip
operator|->
name|last_nominal_fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|newname
operator|==
name|ip
operator|->
name|fname
condition|)
name|ip
operator|->
name|last_nominal_fname
operator|=
name|NULL
expr_stmt|;
else|else
name|ip
operator|->
name|last_nominal_fname
operator|=
name|oldname
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|token
operator|!=
name|CPP_VSPACE
operator|&&
name|token
operator|!=
name|CPP_EOF
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"token after `#line %d' is not a string"
argument_list|,
name|new_lineno
argument_list|)
expr_stmt|;
goto|goto
name|bad_line_directive
goto|;
block|}
comment|/* The Newline at the end of this line remains to be processed.      To put the next line at the specified line number,      we must store a line number now that is one less.  */
name|ip
operator|->
name|lineno
operator|=
name|new_lineno
operator|-
literal|1
expr_stmt|;
name|CPP_SET_WRITTEN
argument_list|(
name|pfile
argument_list|,
name|old_written
argument_list|)
expr_stmt|;
name|output_line_command
argument_list|(
name|pfile
argument_list|,
name|file_change
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|bad_line_directive
label|:
name|skip_rest_of_line
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|CPP_SET_WRITTEN
argument_list|(
name|pfile
argument_list|,
name|old_written
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Remove the definition of a symbol from the symbol table.    According to the C standard, it is not an error to undef    something that has no definitions. */
end_comment

begin_function
specifier|static
name|int
name|do_undef
parameter_list|(
name|pfile
parameter_list|,
name|keyword
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|struct
name|directive
modifier|*
name|keyword
decl_stmt|;
block|{
name|int
name|sym_length
decl_stmt|;
name|HASHNODE
modifier|*
name|hp
decl_stmt|;
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
modifier|*
name|name
decl_stmt|,
modifier|*
name|limit
decl_stmt|;
name|int
name|c
decl_stmt|;
name|long
name|here
init|=
name|CPP_WRITTEN
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
name|enum
name|cpp_token
name|token
decl_stmt|;
name|cpp_skip_hspace
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|c
operator|=
name|GETC
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|is_idstart
index|[
name|c
index|]
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"token after #undef is not an identifier"
argument_list|)
expr_stmt|;
name|skip_rest_of_line
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|parse_name
argument_list|(
name|pfile
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|buf
operator|=
name|pfile
operator|->
name|token_buffer
operator|+
name|here
expr_stmt|;
name|limit
operator|=
name|CPP_PWRITTEN
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
comment|/* Copy out the token so we can pop the token buffer. */
name|name
operator|=
name|alloca
argument_list|(
name|limit
operator|-
name|buf
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|buf
argument_list|,
name|name
argument_list|,
name|limit
operator|-
name|buf
argument_list|)
expr_stmt|;
name|name
index|[
name|limit
operator|-
name|buf
index|]
operator|=
literal|'\0'
expr_stmt|;
name|token
operator|=
name|get_directive_token
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|CPP_VSPACE
operator|&&
name|token
operator|!=
name|CPP_POP
condition|)
block|{
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"junk on line after #undef"
argument_list|)
expr_stmt|;
name|skip_rest_of_line
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
name|CPP_SET_WRITTEN
argument_list|(
name|pfile
argument_list|,
name|here
argument_list|)
expr_stmt|;
name|sym_length
operator|=
name|check_macro_name
argument_list|(
name|pfile
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|hp
operator|=
name|cpp_lookup
argument_list|(
name|pfile
argument_list|,
name|name
argument_list|,
name|sym_length
argument_list|,
operator|-
literal|1
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* If we are generating additional info for debugging (with -g) we 	 need to pass through all effective #undef commands.  */
if|if
condition|(
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|debug_output
operator|&&
name|keyword
condition|)
name|pass_thru_directive
argument_list|(
name|name
argument_list|,
name|sym_length
argument_list|,
name|pfile
argument_list|,
name|keyword
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|type
operator|!=
name|T_MACRO
condition|)
name|cpp_warning
argument_list|(
name|pfile
argument_list|,
literal|"undefining `%s'"
argument_list|,
name|hp
operator|->
name|name
argument_list|)
expr_stmt|;
name|delete_macro
argument_list|(
name|hp
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Wrap do_undef for -U processing. */
end_comment

begin_function
name|void
name|cpp_undef
parameter_list|(
name|pfile
parameter_list|,
name|macro
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|U_CHAR
modifier|*
name|macro
decl_stmt|;
block|{
if|if
condition|(
name|cpp_push_buffer
argument_list|(
name|pfile
argument_list|,
name|macro
argument_list|,
name|strlen
argument_list|(
name|macro
argument_list|)
argument_list|)
condition|)
block|{
name|do_undef
argument_list|(
name|pfile
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cpp_pop_buffer
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Report an error detected by the program we are processing.  * Use the text of the line in the error message.  * (We use error because it prints the filename& line#.)  */
end_comment

begin_function
specifier|static
name|int
name|do_error
parameter_list|(
name|pfile
parameter_list|,
name|keyword
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|struct
name|directive
modifier|*
name|keyword
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|long
name|here
init|=
name|CPP_WRITTEN
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
name|U_CHAR
modifier|*
name|text
decl_stmt|;
name|copy_rest_of_line
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|text
operator|=
name|pfile
operator|->
name|token_buffer
operator|+
name|here
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|text
argument_list|)
expr_stmt|;
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"#error %s"
argument_list|,
name|text
argument_list|)
expr_stmt|;
name|CPP_SET_WRITTEN
argument_list|(
name|pfile
argument_list|,
name|here
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Report a warning detected by the program we are processing.  * Use the text of the line in the warning message, then continue.  */
end_comment

begin_function
specifier|static
name|int
name|do_warning
parameter_list|(
name|pfile
parameter_list|,
name|keyword
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|struct
name|directive
modifier|*
name|keyword
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|U_CHAR
modifier|*
name|text
decl_stmt|;
name|long
name|here
init|=
name|CPP_WRITTEN
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
name|copy_rest_of_line
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|text
operator|=
name|pfile
operator|->
name|token_buffer
operator|+
name|here
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|text
argument_list|)
expr_stmt|;
if|if
condition|(
name|CPP_PEDANTIC
argument_list|(
name|pfile
argument_list|)
operator|&&
operator|!
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|->
name|system_header_p
condition|)
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"ANSI C does not allow `#warning'"
argument_list|)
expr_stmt|;
comment|/* Use `pedwarn' not `warning', because #warning isn't in the C Standard;      if -pedantic-errors is given, #warning should cause an error.  */
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"#warning %s"
argument_list|,
name|text
argument_list|)
expr_stmt|;
name|CPP_SET_WRITTEN
argument_list|(
name|pfile
argument_list|,
name|here
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Report program identification.    This is not precisely what cccp does with #ident, however I believe    it matches `closely enough' (behavior is identical as long as there    are no macros on the #ident line, which is pathological in my opinion).  */
end_comment

begin_function
specifier|static
name|int
name|do_ident
parameter_list|(
name|pfile
parameter_list|,
name|keyword
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|struct
name|directive
modifier|*
name|keyword
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
comment|/* Allow #ident in system headers, since that's not user's fault.  */
if|if
condition|(
name|CPP_PEDANTIC
argument_list|(
name|pfile
argument_list|)
operator|&&
operator|!
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|->
name|system_header_p
condition|)
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"ANSI C does not allow `#ident'"
argument_list|)
expr_stmt|;
name|CPP_PUTS
argument_list|(
name|pfile
argument_list|,
literal|"#ident "
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|cpp_skip_hspace
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|copy_rest_of_line
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Just check for some recognized pragmas that need validation here,    and leave the text in the token buffer to be output. */
end_comment

begin_function
specifier|static
name|int
name|do_pragma
parameter_list|(
name|pfile
parameter_list|,
name|keyword
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|struct
name|directive
modifier|*
name|keyword
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|long
name|here
decl_stmt|;
name|U_CHAR
modifier|*
name|buf
decl_stmt|;
name|CPP_PUTS
argument_list|(
name|pfile
argument_list|,
literal|"#pragma "
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|cpp_skip_hspace
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|here
operator|=
name|CPP_WRITTEN
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|copy_rest_of_line
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|buf
operator|=
name|pfile
operator|->
name|token_buffer
operator|+
name|here
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|buf
argument_list|,
literal|"once"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|cpp_buffer
modifier|*
name|ip
init|=
name|NULL
decl_stmt|;
comment|/* Allow #pragma once in system headers, since that's not the user's 	 fault.  */
if|if
condition|(
operator|!
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|->
name|system_header_p
condition|)
name|cpp_warning
argument_list|(
name|pfile
argument_list|,
literal|"`#pragma once' is obsolete"
argument_list|)
expr_stmt|;
for|for
control|(
name|ip
operator|=
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
init|;
condition|;
name|ip
operator|=
name|CPP_PREV_BUFFER
argument_list|(
name|ip
argument_list|)
control|)
block|{
if|if
condition|(
name|ip
operator|==
name|CPP_NULL_BUFFER
argument_list|(
name|pfile
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|ip
operator|->
name|fname
operator|!=
name|NULL
condition|)
break|break;
block|}
if|if
condition|(
name|CPP_PREV_BUFFER
argument_list|(
name|ip
argument_list|)
operator|==
name|CPP_NULL_BUFFER
argument_list|(
name|pfile
argument_list|)
condition|)
name|cpp_warning
argument_list|(
name|pfile
argument_list|,
literal|"`#pragma once' outside include file"
argument_list|)
expr_stmt|;
else|else
name|ip
operator|->
name|ihash
operator|->
name|control_macro
operator|=
literal|""
expr_stmt|;
comment|/* never repeat */
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|buf
argument_list|,
literal|"implementation"
argument_list|,
literal|14
argument_list|)
condition|)
block|{
comment|/* Be quiet about `#pragma implementation' for a file only if it hasn't 	 been included yet.  */
name|struct
name|include_hash
modifier|*
name|ptr
decl_stmt|;
name|U_CHAR
modifier|*
name|p
init|=
name|buf
operator|+
literal|14
decl_stmt|,
modifier|*
name|fname
decl_stmt|,
modifier|*
name|fcopy
decl_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
operator|||
operator|*
name|p
operator|!=
literal|'\"'
condition|)
return|return
literal|0
return|;
name|fname
operator|=
name|p
operator|+
literal|1
expr_stmt|;
name|p
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|index
argument_list|(
name|fname
argument_list|,
literal|'\"'
argument_list|)
expr_stmt|;
name|fcopy
operator|=
name|alloca
argument_list|(
name|p
operator|-
name|fname
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|fname
argument_list|,
name|fcopy
argument_list|,
name|p
operator|-
name|fname
argument_list|)
expr_stmt|;
name|fcopy
index|[
name|p
operator|-
name|fname
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ptr
operator|=
name|include_hash
argument_list|(
name|pfile
argument_list|,
name|fcopy
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
condition|)
name|cpp_warning
argument_list|(
name|pfile
argument_list|,
literal|"`#pragma implementation' for `%s' appears after file is included"
argument_list|,
name|fcopy
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SCCS_DIRECTIVE
end_ifdef

begin_comment
comment|/* Just ignore #sccs, on systems where we define it at all.  */
end_comment

begin_function
specifier|static
name|int
name|do_sccs
parameter_list|(
name|pfile
parameter_list|,
name|keyword
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|struct
name|directive
modifier|*
name|keyword
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|CPP_PEDANTIC
argument_list|(
name|pfile
argument_list|)
condition|)
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"ANSI C does not allow `#sccs'"
argument_list|)
expr_stmt|;
name|skip_rest_of_line
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/*  * handle #if command by  *   1) inserting special `defined' keyword into the hash table  *	that gets turned into 0 or 1 by special_symbol (thus,  *	if the luser has a symbol called `defined' already, it won't  *      work inside the #if command)  *   2) rescan the input into a temporary output buffer  *   3) pass the output buffer to the yacc parser and collect a value  *   4) clean up the mess left from steps 1 and 2.  *   5) call conditional_skip to skip til the next #endif (etc.),  *      or not, depending on the value from step 3.  */
end_comment

begin_function
specifier|static
name|int
name|do_if
parameter_list|(
name|pfile
parameter_list|,
name|keyword
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|struct
name|directive
modifier|*
name|keyword
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|HOST_WIDEST_INT
name|value
init|=
name|eval_if_expression
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
name|conditional_skip
argument_list|(
name|pfile
argument_list|,
name|value
operator|==
literal|0
argument_list|,
name|T_IF
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * handle a #elif directive by not changing  if_stack  either.  * see the comment above do_else.  */
end_comment

begin_function
specifier|static
name|int
name|do_elif
parameter_list|(
name|pfile
parameter_list|,
name|keyword
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|struct
name|directive
modifier|*
name|keyword
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|pfile
operator|->
name|if_stack
operator|==
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|->
name|if_stack
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"`#elif' not within a conditional"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
if|if
condition|(
name|pfile
operator|->
name|if_stack
operator|->
name|type
operator|!=
name|T_IF
operator|&&
name|pfile
operator|->
name|if_stack
operator|->
name|type
operator|!=
name|T_ELIF
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"`#elif' after `#else'"
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|fprintf (stderr, " (matches line %d", pfile->if_stack->lineno);
endif|#
directive|endif
if|if
condition|(
name|pfile
operator|->
name|if_stack
operator|->
name|fname
operator|!=
name|NULL
operator|&&
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|->
name|fname
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|pfile
operator|->
name|if_stack
operator|->
name|fname
argument_list|,
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|->
name|nominal_fname
argument_list|)
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|", file %s"
argument_list|,
name|pfile
operator|->
name|if_stack
operator|->
name|fname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
block|}
name|pfile
operator|->
name|if_stack
operator|->
name|type
operator|=
name|T_ELIF
expr_stmt|;
block|}
if|if
condition|(
name|pfile
operator|->
name|if_stack
operator|->
name|if_succeeded
condition|)
name|skip_if_group
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
else|else
block|{
name|HOST_WIDEST_INT
name|value
init|=
name|eval_if_expression
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|0
condition|)
name|skip_if_group
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
else|else
block|{
operator|++
name|pfile
operator|->
name|if_stack
operator|->
name|if_succeeded
expr_stmt|;
comment|/* continue processing input */
name|output_line_command
argument_list|(
name|pfile
argument_list|,
name|same_file
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * evaluate a #if expression in BUF, of length LENGTH,  * then parse the result as a C expression and return the value as an int.  */
end_comment

begin_function
specifier|static
name|HOST_WIDEST_INT
name|eval_if_expression
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|HOST_WIDEST_INT
name|value
decl_stmt|;
name|long
name|old_written
init|=
name|CPP_WRITTEN
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
name|pfile
operator|->
name|pcp_inside_if
operator|=
literal|1
expr_stmt|;
name|value
operator|=
name|cpp_parse_expr
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|pcp_inside_if
operator|=
literal|0
expr_stmt|;
name|CPP_SET_WRITTEN
argument_list|(
name|pfile
argument_list|,
name|old_written
argument_list|)
expr_stmt|;
comment|/* Pop */
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/*  * routine to handle ifdef/ifndef.  Try to look up the symbol,  * then do or don't skip to the #endif/#else/#elif depending  * on what directive is actually being processed.  */
end_comment

begin_function
specifier|static
name|int
name|do_xifdef
parameter_list|(
name|pfile
parameter_list|,
name|keyword
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|struct
name|directive
modifier|*
name|keyword
decl_stmt|;
block|{
name|int
name|skip
decl_stmt|;
name|cpp_buffer
modifier|*
name|ip
init|=
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
name|U_CHAR
modifier|*
name|ident
decl_stmt|;
name|int
name|ident_length
decl_stmt|;
name|enum
name|cpp_token
name|token
decl_stmt|;
name|int
name|start_of_file
init|=
literal|0
decl_stmt|;
name|U_CHAR
modifier|*
name|control_macro
init|=
literal|0
decl_stmt|;
name|int
name|old_written
init|=
name|CPP_WRITTEN
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
comment|/* Detect a #ifndef at start of file (not counting comments).  */
if|if
condition|(
name|ip
operator|->
name|fname
operator|!=
literal|0
operator|&&
name|keyword
operator|->
name|type
operator|==
name|T_IFNDEF
condition|)
name|start_of_file
operator|=
name|pfile
operator|->
name|only_seen_white
operator|==
literal|2
expr_stmt|;
name|pfile
operator|->
name|no_macro_expand
operator|++
expr_stmt|;
name|token
operator|=
name|get_directive_token
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|no_macro_expand
operator|--
expr_stmt|;
name|ident
operator|=
name|pfile
operator|->
name|token_buffer
operator|+
name|old_written
expr_stmt|;
name|ident_length
operator|=
name|CPP_WRITTEN
argument_list|(
name|pfile
argument_list|)
operator|-
name|old_written
expr_stmt|;
name|CPP_SET_WRITTEN
argument_list|(
name|pfile
argument_list|,
name|old_written
argument_list|)
expr_stmt|;
comment|/* Pop */
if|if
condition|(
name|token
operator|==
name|CPP_VSPACE
operator|||
name|token
operator|==
name|CPP_POP
operator|||
name|token
operator|==
name|CPP_EOF
condition|)
block|{
name|skip
operator|=
operator|(
name|keyword
operator|->
name|type
operator|==
name|T_IFDEF
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|CPP_TRADITIONAL
argument_list|(
name|pfile
argument_list|)
condition|)
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"`#%s' with no argument"
argument_list|,
name|keyword
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|CPP_NAME
condition|)
block|{
name|HASHNODE
modifier|*
name|hp
init|=
name|cpp_lookup
argument_list|(
name|pfile
argument_list|,
name|ident
argument_list|,
name|ident_length
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
name|skip
operator|=
operator|(
name|hp
operator|==
name|NULL
operator|)
operator|^
operator|(
name|keyword
operator|->
name|type
operator|==
name|T_IFNDEF
operator|)
expr_stmt|;
if|if
condition|(
name|start_of_file
operator|&&
operator|!
name|skip
condition|)
block|{
name|control_macro
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xmalloc
argument_list|(
name|ident_length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|ident
argument_list|,
name|control_macro
argument_list|,
name|ident_length
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|skip
operator|=
operator|(
name|keyword
operator|->
name|type
operator|==
name|T_IFDEF
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|CPP_TRADITIONAL
argument_list|(
name|pfile
argument_list|)
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"`#%s' with invalid argument"
argument_list|,
name|keyword
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|CPP_TRADITIONAL
argument_list|(
name|pfile
argument_list|)
condition|)
block|{
name|int
name|c
decl_stmt|;
name|cpp_skip_hspace
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|c
operator|=
name|PEEKC
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|EOF
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"garbage at end of `#%s' argument"
argument_list|,
name|keyword
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|skip_rest_of_line
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (pcp_outfile) {
comment|/* Output a precondition for this macro.  */
block|if (hp&& hp->value.defn->predefined) 	fprintf (pcp_outfile, "#define %s\n", hp->name);       else { 	U_CHAR *cp = buf; 	fprintf (pcp_outfile, "#undef "); 	while (is_idchar[*cp])
comment|/* Ick! */
block|fputc (*cp++, pcp_outfile); 	putc ('\n', pcp_outfile);       }
endif|#
directive|endif
name|conditional_skip
argument_list|(
name|pfile
argument_list|,
name|skip
argument_list|,
name|T_IF
argument_list|,
name|control_macro
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Push TYPE on stack; then, if SKIP is nonzero, skip ahead.    If this is a #ifndef starting at the beginning of a file,    CONTROL_MACRO is the macro name tested by the #ifndef.    Otherwise, CONTROL_MACRO is 0.  */
end_comment

begin_function
specifier|static
name|void
name|conditional_skip
parameter_list|(
name|pfile
parameter_list|,
name|skip
parameter_list|,
name|type
parameter_list|,
name|control_macro
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|int
name|skip
decl_stmt|;
name|enum
name|node_type
name|type
decl_stmt|;
name|U_CHAR
modifier|*
name|control_macro
decl_stmt|;
block|{
name|IF_STACK_FRAME
modifier|*
name|temp
decl_stmt|;
name|temp
operator|=
operator|(
name|IF_STACK_FRAME
operator|*
operator|)
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|IF_STACK_FRAME
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|->
name|fname
operator|=
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|->
name|nominal_fname
expr_stmt|;
if|#
directive|if
literal|0
block|temp->lineno = CPP_BUFFER (pfile)->lineno;
endif|#
directive|endif
name|temp
operator|->
name|next
operator|=
name|pfile
operator|->
name|if_stack
expr_stmt|;
name|temp
operator|->
name|control_macro
operator|=
name|control_macro
expr_stmt|;
name|pfile
operator|->
name|if_stack
operator|=
name|temp
expr_stmt|;
name|pfile
operator|->
name|if_stack
operator|->
name|type
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|skip
operator|!=
literal|0
condition|)
block|{
name|skip_if_group
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
operator|++
name|pfile
operator|->
name|if_stack
operator|->
name|if_succeeded
expr_stmt|;
name|output_line_command
argument_list|(
name|pfile
argument_list|,
name|same_file
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Subroutine of skip_if_group.	 Examine one preprocessing directive and    return 0 if skipping should continue, 1 if it should halt.  Also    adjusts the if_stack as appropriate.    The `#' has been read, but not the identifier. */
end_comment

begin_function
specifier|static
name|int
name|consider_directive_while_skipping
parameter_list|(
name|pfile
parameter_list|,
name|stack
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|IF_STACK_FRAME
modifier|*
name|stack
decl_stmt|;
block|{
name|long
name|ident_len
decl_stmt|,
name|ident
decl_stmt|;
name|struct
name|directive
modifier|*
name|kt
decl_stmt|;
name|IF_STACK_FRAME
modifier|*
name|temp
decl_stmt|;
name|cpp_skip_hspace
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|ident
operator|=
name|CPP_WRITTEN
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|parse_name
argument_list|(
name|pfile
argument_list|,
name|GETC
argument_list|()
argument_list|)
expr_stmt|;
name|ident_len
operator|=
name|CPP_WRITTEN
argument_list|(
name|pfile
argument_list|)
operator|-
name|ident
expr_stmt|;
name|CPP_SET_WRITTEN
argument_list|(
name|pfile
argument_list|,
name|ident
argument_list|)
expr_stmt|;
for|for
control|(
name|kt
operator|=
name|directive_table
init|;
name|kt
operator|->
name|length
operator|>=
literal|0
condition|;
name|kt
operator|++
control|)
if|if
condition|(
name|kt
operator|->
name|length
operator|==
name|ident_len
operator|&&
name|strncmp
argument_list|(
name|pfile
operator|->
name|token_buffer
operator|+
name|ident
argument_list|,
name|kt
operator|->
name|name
argument_list|,
name|kt
operator|->
name|length
argument_list|)
operator|==
literal|0
condition|)
switch|switch
condition|(
name|kt
operator|->
name|type
condition|)
block|{
case|case
name|T_IF
case|:
case|case
name|T_IFDEF
case|:
case|case
name|T_IFNDEF
case|:
name|temp
operator|=
operator|(
name|IF_STACK_FRAME
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|IF_STACK_FRAME
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|->
name|next
operator|=
name|pfile
operator|->
name|if_stack
expr_stmt|;
name|pfile
operator|->
name|if_stack
operator|=
name|temp
expr_stmt|;
name|temp
operator|->
name|fname
operator|=
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|->
name|nominal_fname
expr_stmt|;
name|temp
operator|->
name|type
operator|=
name|kt
operator|->
name|type
expr_stmt|;
return|return
literal|0
return|;
case|case
name|T_ELSE
case|:
if|if
condition|(
name|CPP_PEDANTIC
argument_list|(
name|pfile
argument_list|)
operator|&&
name|pfile
operator|->
name|if_stack
operator|!=
name|stack
condition|)
name|validate_else
argument_list|(
name|pfile
argument_list|,
literal|"#else"
argument_list|)
expr_stmt|;
comment|/* fall through */
case|case
name|T_ELIF
case|:
if|if
condition|(
name|pfile
operator|->
name|if_stack
operator|->
name|type
operator|==
name|T_ELSE
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"`%s' after `#else'"
argument_list|,
name|kt
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfile
operator|->
name|if_stack
operator|==
name|stack
condition|)
return|return
literal|1
return|;
else|else
block|{
name|pfile
operator|->
name|if_stack
operator|->
name|type
operator|=
name|kt
operator|->
name|type
expr_stmt|;
return|return
literal|0
return|;
block|}
case|case
name|T_ENDIF
case|:
if|if
condition|(
name|CPP_PEDANTIC
argument_list|(
name|pfile
argument_list|)
operator|&&
name|pfile
operator|->
name|if_stack
operator|!=
name|stack
condition|)
name|validate_else
argument_list|(
name|pfile
argument_list|,
literal|"#endif"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfile
operator|->
name|if_stack
operator|==
name|stack
condition|)
return|return
literal|1
return|;
name|temp
operator|=
name|pfile
operator|->
name|if_stack
expr_stmt|;
name|pfile
operator|->
name|if_stack
operator|=
name|temp
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
default|default:
return|return
literal|0
return|;
block|}
comment|/* Don't let erroneous code go by.	*/
if|if
condition|(
operator|!
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|lang_asm
operator|&&
name|CPP_PEDANTIC
argument_list|(
name|pfile
argument_list|)
condition|)
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"invalid preprocessor directive name"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* skip to #endif, #else, or #elif.  adjust line numbers, etc.  * leaves input ptr at the sharp sign found.  */
end_comment

begin_function
specifier|static
name|void
name|skip_if_group
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|IF_STACK_FRAME
modifier|*
name|save_if_stack
init|=
name|pfile
operator|->
name|if_stack
decl_stmt|;
comment|/* don't pop past here */
name|U_CHAR
modifier|*
name|beg_of_line
decl_stmt|;
name|long
name|old_written
decl_stmt|;
if|if
condition|(
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|output_conditionals
condition|)
block|{
name|CPP_PUTS
argument_list|(
name|pfile
argument_list|,
literal|"#failed\n"
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|lineno
operator|++
expr_stmt|;
name|output_line_command
argument_list|(
name|pfile
argument_list|,
name|same_file
argument_list|)
expr_stmt|;
block|}
name|old_written
operator|=
name|CPP_WRITTEN
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|beg_of_line
operator|=
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|->
name|cur
expr_stmt|;
if|if
condition|(
operator|!
name|CPP_TRADITIONAL
argument_list|(
name|pfile
argument_list|)
condition|)
name|cpp_skip_hspace
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|c
operator|=
name|GETC
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|output_conditionals
condition|)
name|CPP_PUTC
argument_list|(
name|pfile
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|CPP_BUMP_LINE
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'#'
condition|)
block|{
if|if
condition|(
name|consider_directive_while_skipping
argument_list|(
name|pfile
argument_list|,
name|save_if_stack
argument_list|)
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
return|return;
comment|/* Caller will issue error. */
name|FORWARD
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|output_conditionals
condition|)
block|{
name|CPP_PUTS
argument_list|(
name|pfile
argument_list|,
name|beg_of_line
argument_list|,
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|->
name|cur
operator|-
name|beg_of_line
argument_list|)
expr_stmt|;
name|copy_rest_of_line
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|copy_rest_of_line
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|CPP_SET_WRITTEN
argument_list|(
name|pfile
argument_list|,
name|old_written
argument_list|)
expr_stmt|;
comment|/* discard it */
block|}
name|c
operator|=
name|GETC
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
return|return;
comment|/* Caller will issue error. */
else|else
block|{
comment|/* \n */
if|if
condition|(
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|output_conditionals
condition|)
block|{
name|CPP_PUTC
argument_list|(
name|pfile
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|lineno
operator|++
expr_stmt|;
block|}
name|CPP_BUMP_LINE
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Back up to the beginning of this line.  Caller will process the      directive. */
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|->
name|cur
operator|=
name|beg_of_line
expr_stmt|;
name|pfile
operator|->
name|only_seen_white
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|output_conditionals
condition|)
block|{
name|CPP_PUTS
argument_list|(
name|pfile
argument_list|,
literal|"#endfailed\n"
argument_list|,
literal|11
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|lineno
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * handle a #else directive.  Do this by just continuing processing  * without changing  if_stack ;  this is so that the error message  * for missing #endif's etc. will point to the original #if.  It  * is possible that something different would be better.  */
end_comment

begin_function
specifier|static
name|int
name|do_else
parameter_list|(
name|pfile
parameter_list|,
name|keyword
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|struct
name|directive
modifier|*
name|keyword
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|cpp_buffer
modifier|*
name|ip
init|=
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
if|if
condition|(
name|CPP_PEDANTIC
argument_list|(
name|pfile
argument_list|)
condition|)
name|validate_else
argument_list|(
name|pfile
argument_list|,
literal|"#else"
argument_list|)
expr_stmt|;
name|skip_rest_of_line
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfile
operator|->
name|if_stack
operator|==
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|->
name|if_stack
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"`#else' not within a conditional"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
comment|/* #ifndef can't have its special treatment for containing the whole file        if it has a #else clause.  */
name|pfile
operator|->
name|if_stack
operator|->
name|control_macro
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pfile
operator|->
name|if_stack
operator|->
name|type
operator|!=
name|T_IF
operator|&&
name|pfile
operator|->
name|if_stack
operator|->
name|type
operator|!=
name|T_ELIF
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"`#else' after `#else'"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" (matches line %d"
argument_list|,
name|pfile
operator|->
name|if_stack
operator|->
name|lineno
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|pfile
operator|->
name|if_stack
operator|->
name|fname
argument_list|,
name|ip
operator|->
name|nominal_fname
argument_list|)
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|", file %s"
argument_list|,
name|pfile
operator|->
name|if_stack
operator|->
name|fname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
block|}
name|pfile
operator|->
name|if_stack
operator|->
name|type
operator|=
name|T_ELSE
expr_stmt|;
block|}
if|if
condition|(
name|pfile
operator|->
name|if_stack
operator|->
name|if_succeeded
condition|)
name|skip_if_group
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
else|else
block|{
operator|++
name|pfile
operator|->
name|if_stack
operator|->
name|if_succeeded
expr_stmt|;
comment|/* continue processing input */
name|output_line_command
argument_list|(
name|pfile
argument_list|,
name|same_file
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * unstack after #endif command  */
end_comment

begin_function
specifier|static
name|int
name|do_endif
parameter_list|(
name|pfile
parameter_list|,
name|keyword
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|struct
name|directive
modifier|*
name|keyword
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|CPP_PEDANTIC
argument_list|(
name|pfile
argument_list|)
condition|)
name|validate_else
argument_list|(
name|pfile
argument_list|,
literal|"#endif"
argument_list|)
expr_stmt|;
name|skip_rest_of_line
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfile
operator|->
name|if_stack
operator|==
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|->
name|if_stack
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"unbalanced `#endif'"
argument_list|)
expr_stmt|;
else|else
block|{
name|IF_STACK_FRAME
modifier|*
name|temp
init|=
name|pfile
operator|->
name|if_stack
decl_stmt|;
name|pfile
operator|->
name|if_stack
operator|=
name|temp
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|temp
operator|->
name|control_macro
operator|!=
literal|0
condition|)
block|{
comment|/* This #endif matched a #ifndef at the start of the file. 	     See if it is at the end of the file.  */
name|int
name|c
decl_stmt|;
name|parse_set_mark
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|cpp_skip_hspace
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|c
operator|=
name|GETC
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'\n'
condition|)
break|break;
block|}
name|parse_goto_mark
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
comment|/* This #endif ends a #ifndef 		 that contains all of the file (aside from whitespace). 		 Arrange not to include the file again 		 if the macro that was tested is defined. */
name|struct
name|cpp_buffer
modifier|*
name|ip
decl_stmt|;
for|for
control|(
name|ip
operator|=
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
init|;
condition|;
name|ip
operator|=
name|CPP_PREV_BUFFER
argument_list|(
name|ip
argument_list|)
control|)
if|if
condition|(
name|ip
operator|->
name|fname
operator|!=
name|NULL
condition|)
break|break;
name|ip
operator|->
name|ihash
operator|->
name|control_macro
operator|=
operator|(
name|char
operator|*
operator|)
name|temp
operator|->
name|control_macro
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|output_line_command
argument_list|(
name|pfile
argument_list|,
name|same_file
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* When an #else or #endif is found while skipping failed conditional,    if -pedantic was specified, this is called to warn about text after    the command name.  P points to the first char after the command name.  */
end_comment

begin_function
specifier|static
name|void
name|validate_else
parameter_list|(
name|pfile
parameter_list|,
name|directive
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|char
modifier|*
name|directive
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|cpp_skip_hspace
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|c
operator|=
name|PEEKC
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|EOF
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"text following `%s' violates ANSI standard"
argument_list|,
name|directive
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get the next token, and add it to the text in pfile->token_buffer.    Return the kind of token we got.  */
end_comment

begin_function
name|enum
name|cpp_token
name|cpp_get_token
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|,
name|c2
decl_stmt|,
name|c3
decl_stmt|;
name|enum
name|cpp_token
name|token
decl_stmt|;
name|struct
name|cpp_options
modifier|*
name|opts
init|=
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
name|get_next
label|:
name|c
operator|=
name|GETC
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
name|handle_eof
label|:
if|if
condition|(
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|->
name|seen_eof
condition|)
block|{
if|if
condition|(
name|CPP_PREV_BUFFER
argument_list|(
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
argument_list|)
operator|==
name|CPP_NULL_BUFFER
argument_list|(
name|pfile
argument_list|)
condition|)
return|return
name|CPP_EOF
return|;
name|cpp_pop_buffer
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
goto|goto
name|get_next
goto|;
block|}
else|else
block|{
name|cpp_buffer
modifier|*
name|next_buf
init|=
name|CPP_PREV_BUFFER
argument_list|(
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
argument_list|)
decl_stmt|;
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|->
name|seen_eof
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|->
name|nominal_fname
operator|&&
name|next_buf
operator|!=
name|CPP_NULL_BUFFER
argument_list|(
name|pfile
argument_list|)
condition|)
block|{
comment|/* We're about to return from an #include file. 		 Emit #line information now (as part of the CPP_POP) result. 		 But the #line refers to the file we will pop to.  */
name|cpp_buffer
modifier|*
name|cur_buffer
init|=
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|=
name|next_buf
expr_stmt|;
name|pfile
operator|->
name|input_stack_listing_current
operator|=
literal|0
expr_stmt|;
name|output_line_command
argument_list|(
name|pfile
argument_list|,
name|leave_file
argument_list|)
expr_stmt|;
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|=
name|cur_buffer
expr_stmt|;
block|}
return|return
name|CPP_POP
return|;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'/'
case|:
if|if
condition|(
name|PEEKC
argument_list|()
operator|==
literal|'='
condition|)
goto|goto
name|op2
goto|;
name|comment
label|:
if|if
condition|(
name|opts
operator|->
name|put_out_comments
condition|)
name|c
operator|=
name|copy_comment
argument_list|(
name|pfile
argument_list|,
name|c
argument_list|)
expr_stmt|;
else|else
name|c
operator|=
name|skip_comment
argument_list|(
name|pfile
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
goto|goto
name|handle_eof
goto|;
elseif|else
if|if
condition|(
name|c
operator|!=
literal|' '
condition|)
goto|goto
name|randomchar
goto|;
comment|/* Comments are equivalent to spaces. 	     For -traditional, a comment is equivalent to nothing.  */
if|if
condition|(
name|opts
operator|->
name|traditional
operator|||
name|opts
operator|->
name|put_out_comments
condition|)
return|return
name|CPP_COMMENT
return|;
else|else
block|{
name|CPP_PUTC
argument_list|(
name|pfile
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
name|CPP_HSPACE
return|;
block|}
if|#
directive|if
literal|0
block|if (opts->for_lint) { 	    U_CHAR *argbp; 	    int cmdlen, arglen; 	    char *lintcmd = get_lintcmd (ibp, limit,&argbp,&arglen,&cmdlen); 	     	    if (lintcmd != NULL) {
comment|/* I believe it is always safe to emit this newline: */
block|obp[-1] = '\n'; 	      bcopy ("#pragma lint ", (char *) obp, 13); 	      obp += 13; 	      bcopy (lintcmd, (char *) obp, cmdlen); 	      obp += cmdlen;  	      if (arglen != 0) { 		*(obp++) = ' '; 		bcopy (argbp, (char *) obp, arglen); 		obp += arglen; 	      }
comment|/* OK, now bring us back to the state we were in before we entered 		 this branch.  We need #line because the newline for the pragma 		 could mess things up.  */
block|output_line_command (pfile, same_file); 	      *(obp++) = ' ';
comment|/* just in case, if comments are copied thru */
block|*(obp++) = '/'; 	    } 	  }
endif|#
directive|endif
case|case
literal|'#'
case|:
if|#
directive|if
literal|0
comment|/* If this is expanding a macro definition, don't recognize 	     preprocessor directives.  */
block|if (ip->macro != 0) 	    goto randomchar;
comment|/* If this is expand_into_temp_buffer, recognize them 	     only after an actual newline at this level, 	     not at the beginning of the input level.  */
block|if (ip->fname == 0&& beg_of_line == ip->buf) 	    goto randomchar; 	  if (ident_length) 	    goto specialchar;
endif|#
directive|endif
if|if
condition|(
operator|!
name|pfile
operator|->
name|only_seen_white
condition|)
goto|goto
name|randomchar
goto|;
if|if
condition|(
name|handle_directive
argument_list|(
name|pfile
argument_list|)
condition|)
return|return
name|CPP_DIRECTIVE
return|;
name|pfile
operator|->
name|only_seen_white
operator|=
literal|0
expr_stmt|;
return|return
name|CPP_OTHER
return|;
case|case
literal|'\"'
case|:
case|case
literal|'\''
case|:
name|string
label|:
name|parse_string
argument_list|(
name|pfile
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|only_seen_white
operator|=
literal|0
expr_stmt|;
return|return
name|c
operator|==
literal|'\''
condition|?
name|CPP_CHAR
else|:
name|CPP_STRING
return|;
case|case
literal|'$'
case|:
if|if
condition|(
operator|!
name|opts
operator|->
name|dollars_in_ident
condition|)
goto|goto
name|randomchar
goto|;
goto|goto
name|letter
goto|;
case|case
literal|':'
case|:
if|if
condition|(
name|opts
operator|->
name|cplusplus
operator|&&
name|PEEKC
argument_list|()
operator|==
literal|':'
condition|)
goto|goto
name|op2
goto|;
goto|goto
name|randomchar
goto|;
case|case
literal|'&'
case|:
case|case
literal|'+'
case|:
case|case
literal|'|'
case|:
name|c2
operator|=
name|PEEKC
argument_list|()
expr_stmt|;
if|if
condition|(
name|c2
operator|==
name|c
operator|||
name|c2
operator|==
literal|'='
condition|)
goto|goto
name|op2
goto|;
goto|goto
name|randomchar
goto|;
case|case
literal|'*'
case|:
case|case
literal|'!'
case|:
case|case
literal|'%'
case|:
case|case
literal|'='
case|:
case|case
literal|'^'
case|:
if|if
condition|(
name|PEEKC
argument_list|()
operator|==
literal|'='
condition|)
goto|goto
name|op2
goto|;
goto|goto
name|randomchar
goto|;
case|case
literal|'-'
case|:
name|c2
operator|=
name|PEEKC
argument_list|()
expr_stmt|;
if|if
condition|(
name|c2
operator|==
literal|'-'
operator|&&
name|opts
operator|->
name|chill
condition|)
goto|goto
name|comment
goto|;
comment|/* Chill style comment */
if|if
condition|(
name|c2
operator|==
literal|'-'
operator|||
name|c2
operator|==
literal|'='
operator|||
name|c2
operator|==
literal|'>'
condition|)
goto|goto
name|op2
goto|;
goto|goto
name|randomchar
goto|;
case|case
literal|'<'
case|:
if|if
condition|(
name|pfile
operator|->
name|parsing_include_directive
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|CPP_PUTC
argument_list|(
name|pfile
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'>'
condition|)
break|break;
name|c
operator|=
name|GETC
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
name|EOF
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"missing '>' in `#include<FILENAME>'"
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\r'
condition|)
block|{
if|if
condition|(
operator|!
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|->
name|has_escapes
condition|)
block|{
comment|/* Backslash newline is replaced by nothing. */
name|CPP_ADJUST_WRITTEN
argument_list|(
name|pfile
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|CPP_BUMP_LINE
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We might conceivably get \r- or \r<space> in 			     here.  Just delete 'em. */
name|int
name|d
init|=
name|GETC
argument_list|()
decl_stmt|;
if|if
condition|(
name|d
operator|!=
literal|'-'
operator|&&
name|d
operator|!=
literal|' '
condition|)
name|cpp_fatal
argument_list|(
name|pfile
argument_list|,
literal|"internal error: unrecognized escape \\r%c"
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|CPP_ADJUST_WRITTEN
argument_list|(
name|pfile
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|CPP_STRING
return|;
block|}
comment|/* else fall through */
case|case
literal|'>'
case|:
name|c2
operator|=
name|PEEKC
argument_list|()
expr_stmt|;
if|if
condition|(
name|c2
operator|==
literal|'='
condition|)
goto|goto
name|op2
goto|;
if|if
condition|(
name|c2
operator|!=
name|c
condition|)
goto|goto
name|randomchar
goto|;
name|FORWARD
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|CPP_RESERVE
argument_list|(
name|pfile
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|CPP_PUTC
argument_list|(
name|pfile
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|CPP_PUTC
argument_list|(
name|pfile
argument_list|,
name|c2
argument_list|)
expr_stmt|;
name|c3
operator|=
name|PEEKC
argument_list|()
expr_stmt|;
if|if
condition|(
name|c3
operator|==
literal|'='
condition|)
name|CPP_PUTC_Q
argument_list|(
name|pfile
argument_list|,
name|GETC
argument_list|()
argument_list|)
expr_stmt|;
name|CPP_NUL_TERMINATE_Q
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|only_seen_white
operator|=
literal|0
expr_stmt|;
return|return
name|CPP_OTHER
return|;
case|case
literal|'.'
case|:
name|c2
operator|=
name|PEEKC
argument_list|()
expr_stmt|;
if|if
condition|(
name|ISDIGIT
argument_list|(
name|c2
argument_list|)
condition|)
block|{
name|CPP_RESERVE
argument_list|(
name|pfile
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|CPP_PUTC_Q
argument_list|(
name|pfile
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
name|c
operator|=
name|GETC
argument_list|()
expr_stmt|;
goto|goto
name|number
goto|;
block|}
if|if
condition|(
name|c2
operator|==
literal|'.'
operator|&&
name|PEEKN
argument_list|(
literal|1
argument_list|)
operator|==
literal|'.'
condition|)
block|{
name|CPP_RESERVE
argument_list|(
name|pfile
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|CPP_PUTC_Q
argument_list|(
name|pfile
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
name|CPP_PUTC_Q
argument_list|(
name|pfile
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
name|CPP_PUTC_Q
argument_list|(
name|pfile
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
name|FORWARD
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|CPP_NUL_TERMINATE_Q
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|only_seen_white
operator|=
literal|0
expr_stmt|;
return|return
name|CPP_3DOTS
return|;
block|}
goto|goto
name|randomchar
goto|;
name|op2
label|:
name|token
operator|=
name|CPP_OTHER
expr_stmt|;
name|pfile
operator|->
name|only_seen_white
operator|=
literal|0
expr_stmt|;
name|CPP_RESERVE
argument_list|(
name|pfile
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|CPP_PUTC_Q
argument_list|(
name|pfile
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|CPP_PUTC_Q
argument_list|(
name|pfile
argument_list|,
name|GETC
argument_list|()
argument_list|)
expr_stmt|;
name|CPP_NUL_TERMINATE_Q
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
return|return
name|token
return|;
case|case
literal|'L'
case|:
name|c2
operator|=
name|PEEKC
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|c2
operator|==
literal|'\''
operator|||
name|c2
operator|==
literal|'\"'
operator|)
operator|&&
operator|!
name|CPP_TRADITIONAL
argument_list|(
name|pfile
argument_list|)
condition|)
block|{
name|CPP_PUTC
argument_list|(
name|pfile
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
name|GETC
argument_list|()
expr_stmt|;
goto|goto
name|string
goto|;
block|}
goto|goto
name|letter
goto|;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|number
label|:
name|c2
operator|=
literal|'.'
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|CPP_RESERVE
argument_list|(
name|pfile
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|CPP_PUTC_Q
argument_list|(
name|pfile
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
name|PEEKC
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
if|if
condition|(
operator|!
name|is_idchar
index|[
name|c
index|]
operator|&&
name|c
operator|!=
literal|'.'
operator|&&
operator|(
operator|(
name|c2
operator|!=
literal|'e'
operator|&&
name|c2
operator|!=
literal|'E'
operator|&&
operator|(
operator|(
name|c2
operator|!=
literal|'p'
operator|&&
name|c2
operator|!=
literal|'P'
operator|)
operator|||
name|CPP_C89
argument_list|(
name|pfile
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|c
operator|!=
literal|'+'
operator|&&
name|c
operator|!=
literal|'-'
operator|)
operator|)
condition|)
break|break;
name|FORWARD
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|c2
operator|=
name|c
expr_stmt|;
block|}
name|CPP_NUL_TERMINATE_Q
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|only_seen_white
operator|=
literal|0
expr_stmt|;
return|return
name|CPP_NUMBER
return|;
case|case
literal|'b'
case|:
case|case
literal|'c'
case|:
case|case
literal|'d'
case|:
case|case
literal|'h'
case|:
case|case
literal|'o'
case|:
case|case
literal|'B'
case|:
case|case
literal|'C'
case|:
case|case
literal|'D'
case|:
case|case
literal|'H'
case|:
case|case
literal|'O'
case|:
if|if
condition|(
name|opts
operator|->
name|chill
operator|&&
name|PEEKC
argument_list|()
operator|==
literal|'\''
condition|)
block|{
name|pfile
operator|->
name|only_seen_white
operator|=
literal|0
expr_stmt|;
name|CPP_RESERVE
argument_list|(
name|pfile
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|CPP_PUTC_Q
argument_list|(
name|pfile
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|CPP_PUTC_Q
argument_list|(
name|pfile
argument_list|,
literal|'\''
argument_list|)
expr_stmt|;
name|FORWARD
argument_list|(
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|GETC
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
goto|goto
name|chill_number_eof
goto|;
if|if
condition|(
operator|!
name|is_idchar
index|[
name|c
index|]
condition|)
break|break;
name|CPP_PUTC
argument_list|(
name|pfile
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\''
condition|)
block|{
name|CPP_RESERVE
argument_list|(
name|pfile
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|CPP_PUTC_Q
argument_list|(
name|pfile
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|CPP_NUL_TERMINATE_Q
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
return|return
name|CPP_STRING
return|;
block|}
else|else
block|{
name|FORWARD
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|chill_number_eof
label|:
name|CPP_NUL_TERMINATE
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
return|return
name|CPP_NUMBER
return|;
block|}
block|}
else|else
goto|goto
name|letter
goto|;
case|case
literal|'_'
case|:
case|case
literal|'a'
case|:
case|case
literal|'e'
case|:
case|case
literal|'f'
case|:
case|case
literal|'g'
case|:
case|case
literal|'i'
case|:
case|case
literal|'j'
case|:
case|case
literal|'k'
case|:
case|case
literal|'l'
case|:
case|case
literal|'m'
case|:
case|case
literal|'n'
case|:
case|case
literal|'p'
case|:
case|case
literal|'q'
case|:
case|case
literal|'r'
case|:
case|case
literal|'s'
case|:
case|case
literal|'t'
case|:
case|case
literal|'u'
case|:
case|case
literal|'v'
case|:
case|case
literal|'w'
case|:
case|case
literal|'x'
case|:
case|case
literal|'y'
case|:
case|case
literal|'z'
case|:
case|case
literal|'A'
case|:
case|case
literal|'E'
case|:
case|case
literal|'F'
case|:
case|case
literal|'G'
case|:
case|case
literal|'I'
case|:
case|case
literal|'J'
case|:
case|case
literal|'K'
case|:
case|case
literal|'M'
case|:
case|case
literal|'N'
case|:
case|case
literal|'P'
case|:
case|case
literal|'Q'
case|:
case|case
literal|'R'
case|:
case|case
literal|'S'
case|:
case|case
literal|'T'
case|:
case|case
literal|'U'
case|:
case|case
literal|'V'
case|:
case|case
literal|'W'
case|:
case|case
literal|'X'
case|:
case|case
literal|'Y'
case|:
case|case
literal|'Z'
case|:
name|letter
label|:
block|{
name|HASHNODE
modifier|*
name|hp
decl_stmt|;
name|unsigned
name|char
modifier|*
name|ident
decl_stmt|;
name|int
name|before_name_written
init|=
name|CPP_WRITTEN
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
name|int
name|ident_len
decl_stmt|;
name|parse_name
argument_list|(
name|pfile
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|only_seen_white
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pfile
operator|->
name|no_macro_expand
condition|)
return|return
name|CPP_NAME
return|;
name|ident
operator|=
name|pfile
operator|->
name|token_buffer
operator|+
name|before_name_written
expr_stmt|;
name|ident_len
operator|=
name|CPP_PWRITTEN
argument_list|(
name|pfile
argument_list|)
operator|-
name|ident
expr_stmt|;
name|hp
operator|=
name|cpp_lookup
argument_list|(
name|pfile
argument_list|,
name|ident
argument_list|,
name|ident_len
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hp
condition|)
return|return
name|CPP_NAME
return|;
if|if
condition|(
name|hp
operator|->
name|type
operator|==
name|T_DISABLED
condition|)
block|{
if|if
condition|(
name|pfile
operator|->
name|output_escapes
condition|)
block|{
comment|/* Return "\r-IDENT", followed by '\0'.  */
name|int
name|i
decl_stmt|;
name|CPP_RESERVE
argument_list|(
name|pfile
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|ident
operator|=
name|pfile
operator|->
name|token_buffer
operator|+
name|before_name_written
expr_stmt|;
name|CPP_ADJUST_WRITTEN
argument_list|(
name|pfile
argument_list|,
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|ident_len
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|ident
index|[
name|i
operator|+
literal|2
index|]
operator|=
name|ident
index|[
name|i
index|]
expr_stmt|;
name|ident
index|[
literal|0
index|]
operator|=
literal|'\r'
expr_stmt|;
name|ident
index|[
literal|1
index|]
operator|=
literal|'-'
expr_stmt|;
block|}
return|return
name|CPP_NAME
return|;
block|}
comment|/* If macro wants an arglist, verify that a '(' follows. 	       first skip all whitespace, copying it to the output 	       after the macro name.  Then, if there is no '(', 	       decide this is not a macro call and leave things that way.  */
if|if
condition|(
name|hp
operator|->
name|type
operator|==
name|T_MACRO
operator|&&
name|hp
operator|->
name|value
operator|.
name|defn
operator|->
name|nargs
operator|>=
literal|0
condition|)
block|{
name|int
name|is_macro_call
decl_stmt|,
name|macbuf_whitespace
init|=
literal|0
decl_stmt|;
name|parse_set_mark
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|cpp_skip_hspace
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|c
operator|=
name|PEEKC
argument_list|()
expr_stmt|;
name|is_macro_call
operator|=
name|c
operator|==
literal|'('
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
name|c
operator|!=
literal|'\n'
condition|)
break|break;
name|FORWARD
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|CPP_IS_MACRO_BUFFER
argument_list|(
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|->
name|mark
operator|!=
operator|(
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|->
name|cur
operator|-
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|->
name|buf
operator|)
condition|)
name|macbuf_whitespace
operator|=
literal|1
expr_stmt|;
comment|/* The mark goes away automatically when 			     the buffer is popped. */
name|cpp_pop_buffer
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|parse_set_mark
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|is_macro_call
condition|)
block|{
name|parse_goto_mark
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|macbuf_whitespace
condition|)
name|CPP_PUTC
argument_list|(
name|pfile
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
block|}
else|else
name|parse_clear_mark
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_macro_call
condition|)
return|return
name|CPP_NAME
return|;
block|}
comment|/* This is now known to be a macro call. 	       Expand the macro, reading arguments as needed, 	       and push the expansion on the input stack.  */
name|macroexpand
argument_list|(
name|pfile
argument_list|,
name|hp
argument_list|)
expr_stmt|;
name|CPP_SET_WRITTEN
argument_list|(
name|pfile
argument_list|,
name|before_name_written
argument_list|)
expr_stmt|;
block|}
goto|goto
name|get_next
goto|;
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\v'
case|:
for|for
control|(
init|;
condition|;
control|)
block|{
name|CPP_PUTC
argument_list|(
name|pfile
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
name|PEEKC
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
operator|||
operator|!
name|is_hor_space
index|[
name|c
index|]
condition|)
break|break;
name|FORWARD
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|CPP_HSPACE
return|;
case|case
literal|'\r'
case|:
if|if
condition|(
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|->
name|has_escapes
condition|)
block|{
name|c
operator|=
name|GETC
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
name|pfile
operator|->
name|output_escapes
condition|)
name|CPP_PUTS
argument_list|(
name|pfile
argument_list|,
literal|"\r-"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|parse_name
argument_list|(
name|pfile
argument_list|,
name|GETC
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|CPP_NAME
return|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|' '
condition|)
block|{
name|CPP_RESERVE
argument_list|(
name|pfile
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfile
operator|->
name|output_escapes
condition|)
name|CPP_PUTC_Q
argument_list|(
name|pfile
argument_list|,
literal|'\r'
argument_list|)
expr_stmt|;
name|CPP_PUTC_Q
argument_list|(
name|pfile
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
name|CPP_HSPACE
return|;
block|}
else|else
block|{
name|cpp_fatal
argument_list|(
name|pfile
argument_list|,
literal|"internal error: unrecognized escape \\r%c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
goto|goto
name|get_next
goto|;
block|}
block|}
else|else
block|{
comment|/* Backslash newline is ignored. */
name|CPP_BUMP_LINE
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
goto|goto
name|get_next
goto|;
block|}
case|case
literal|'\n'
case|:
name|CPP_PUTC
argument_list|(
name|pfile
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfile
operator|->
name|only_seen_white
operator|==
literal|0
condition|)
name|pfile
operator|->
name|only_seen_white
operator|=
literal|1
expr_stmt|;
name|CPP_BUMP_LINE
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|no_line_commands
condition|)
block|{
name|pfile
operator|->
name|lineno
operator|++
expr_stmt|;
if|if
condition|(
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|->
name|lineno
operator|!=
name|pfile
operator|->
name|lineno
condition|)
name|output_line_command
argument_list|(
name|pfile
argument_list|,
name|same_file
argument_list|)
expr_stmt|;
block|}
return|return
name|CPP_VSPACE
return|;
case|case
literal|'('
case|:
name|token
operator|=
name|CPP_LPAREN
expr_stmt|;
goto|goto
name|char1
goto|;
case|case
literal|')'
case|:
name|token
operator|=
name|CPP_RPAREN
expr_stmt|;
goto|goto
name|char1
goto|;
case|case
literal|'{'
case|:
name|token
operator|=
name|CPP_LBRACE
expr_stmt|;
goto|goto
name|char1
goto|;
case|case
literal|'}'
case|:
name|token
operator|=
name|CPP_RBRACE
expr_stmt|;
goto|goto
name|char1
goto|;
case|case
literal|','
case|:
name|token
operator|=
name|CPP_COMMA
expr_stmt|;
goto|goto
name|char1
goto|;
case|case
literal|';'
case|:
name|token
operator|=
name|CPP_SEMICOLON
expr_stmt|;
goto|goto
name|char1
goto|;
name|randomchar
label|:
default|default:
name|token
operator|=
name|CPP_OTHER
expr_stmt|;
name|char1
label|:
name|pfile
operator|->
name|only_seen_white
operator|=
literal|0
expr_stmt|;
name|CPP_PUTC
argument_list|(
name|pfile
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
name|token
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Like cpp_get_token, but skip spaces and comments.  */
end_comment

begin_function
name|enum
name|cpp_token
name|cpp_get_non_space_token
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|int
name|old_written
init|=
name|CPP_WRITTEN
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|enum
name|cpp_token
name|token
init|=
name|cpp_get_token
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
if|if
condition|(
name|token
operator|!=
name|CPP_COMMENT
operator|&&
name|token
operator|!=
name|CPP_POP
operator|&&
name|token
operator|!=
name|CPP_HSPACE
operator|&&
name|token
operator|!=
name|CPP_VSPACE
condition|)
return|return
name|token
return|;
name|CPP_SET_WRITTEN
argument_list|(
name|pfile
argument_list|,
name|old_written
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Parse an identifier starting with C.  */
end_comment

begin_function
specifier|static
name|void
name|parse_name
parameter_list|(
name|pfile
parameter_list|,
name|c
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|int
name|c
decl_stmt|;
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|is_idchar
index|[
name|c
index|]
condition|)
block|{
name|FORWARD
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|c
operator|==
literal|'$'
operator|&&
name|CPP_PEDANTIC
argument_list|(
name|pfile
argument_list|)
condition|)
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"`$' in identifier"
argument_list|)
expr_stmt|;
name|CPP_RESERVE
argument_list|(
name|pfile
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* One more for final NUL.  */
name|CPP_PUTC_Q
argument_list|(
name|pfile
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
name|GETC
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
block|}
name|CPP_NUL_TERMINATE_Q
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Parse a string starting with C.  A single quoted string is treated    like a double -- some programs (e.g., troff) are perverse this way.    (However, a single quoted string is not allowed to extend over    multiple lines.  */
end_comment

begin_function
specifier|static
name|void
name|parse_string
parameter_list|(
name|pfile
parameter_list|,
name|c
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|int
name|c
decl_stmt|;
block|{
name|long
name|start_line
decl_stmt|,
name|start_column
decl_stmt|;
name|cpp_buf_line_and_col
argument_list|(
name|cpp_file_buffer
argument_list|(
name|pfile
argument_list|)
argument_list|,
operator|&
name|start_line
argument_list|,
operator|&
name|start_column
argument_list|)
expr_stmt|;
name|CPP_PUTC
argument_list|(
name|pfile
argument_list|,
name|c
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|cc
init|=
name|GETC
argument_list|()
decl_stmt|;
if|if
condition|(
name|cc
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|CPP_IS_MACRO_BUFFER
argument_list|(
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
argument_list|)
condition|)
block|{
comment|/* try harder: this string crosses a macro expansion 		 boundary.  This can happen naturally if -traditional. 		 Otherwise, only -D can make a macro with an unmatched 		 quote.  */
name|cpp_pop_buffer
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|CPP_TRADITIONAL
argument_list|(
name|pfile
argument_list|)
condition|)
block|{
name|cpp_error_with_line
argument_list|(
name|pfile
argument_list|,
name|start_line
argument_list|,
name|start_column
argument_list|,
literal|"unterminated string or character constant"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfile
operator|->
name|multiline_string_line
operator|!=
name|start_line
operator|&&
name|pfile
operator|->
name|multiline_string_line
operator|!=
literal|0
condition|)
name|cpp_error_with_line
argument_list|(
name|pfile
argument_list|,
name|pfile
operator|->
name|multiline_string_line
argument_list|,
operator|-
literal|1
argument_list|,
literal|"possible real start of unterminated constant"
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|multiline_string_line
operator|=
literal|0
expr_stmt|;
block|}
break|break;
block|}
name|CPP_PUTC
argument_list|(
name|pfile
argument_list|,
name|cc
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cc
condition|)
block|{
case|case
literal|'\n'
case|:
name|CPP_BUMP_LINE
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|lineno
operator|++
expr_stmt|;
comment|/* Traditionally, end of line ends a string constant with 	     no error.  */
if|if
condition|(
name|CPP_TRADITIONAL
argument_list|(
name|pfile
argument_list|)
condition|)
return|return;
comment|/* Character constants may not extend over multiple lines.  */
if|if
condition|(
name|c
operator|==
literal|'\''
condition|)
block|{
name|cpp_error_with_line
argument_list|(
name|pfile
argument_list|,
name|start_line
argument_list|,
name|start_column
argument_list|,
literal|"unterminated character constant"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|CPP_PEDANTIC
argument_list|(
name|pfile
argument_list|)
operator|&&
name|pfile
operator|->
name|multiline_string_line
operator|==
literal|0
condition|)
block|{
name|cpp_pedwarn_with_line
argument_list|(
name|pfile
argument_list|,
name|start_line
argument_list|,
name|start_column
argument_list|,
literal|"string constant runs past end of line"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pfile
operator|->
name|multiline_string_line
operator|==
literal|0
condition|)
name|pfile
operator|->
name|multiline_string_line
operator|=
name|start_line
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
name|CPP_ADJUST_WRITTEN
argument_list|(
name|pfile
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|->
name|has_escapes
condition|)
block|{
name|cpp_fatal
argument_list|(
name|pfile
argument_list|,
literal|"internal error: \\r escape inside string constant"
argument_list|)
expr_stmt|;
name|FORWARD
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Backslash newline is replaced by nothing at all.  */
name|CPP_BUMP_LINE
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
name|cc
operator|=
name|GETC
argument_list|()
expr_stmt|;
if|if
condition|(
name|cc
operator|!=
name|EOF
condition|)
name|CPP_PUTC
argument_list|(
name|pfile
argument_list|,
name|cc
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\"'
case|:
case|case
literal|'\''
case|:
if|if
condition|(
name|cc
operator|==
name|c
condition|)
return|return;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Read an assertion into the token buffer, converting to    canonical form: `#predicate(a n swe r)'  The next non-whitespace    character to read should be the first letter of the predicate.    Returns 0 for syntax error, 1 for bare predicate, 2 for predicate    with answer (see callers for why). In case of 0, an error has been    printed. */
end_comment

begin_function
specifier|static
name|int
name|parse_assertion
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|int
name|c
decl_stmt|,
name|dropwhite
decl_stmt|;
name|cpp_skip_hspace
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|c
operator|=
name|PEEKC
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|is_idstart
index|[
name|c
index|]
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"assertion predicate is not an identifier"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|CPP_PUTC
argument_list|(
name|pfile
argument_list|,
literal|'#'
argument_list|)
expr_stmt|;
name|FORWARD
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|parse_name
argument_list|(
name|pfile
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
name|PEEKC
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'('
condition|)
block|{
if|if
condition|(
name|is_hor_space
index|[
name|c
index|]
operator|||
name|c
operator|==
literal|'\r'
condition|)
name|cpp_skip_hspace
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|c
operator|=
name|PEEKC
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|!=
literal|'('
condition|)
return|return
literal|1
return|;
name|CPP_PUTC
argument_list|(
name|pfile
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
name|FORWARD
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|dropwhite
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|GETC
argument_list|()
operator|)
operator|!=
literal|')'
condition|)
block|{
if|if
condition|(
name|is_hor_space
index|[
name|c
index|]
condition|)
block|{
if|if
condition|(
operator|!
name|dropwhite
condition|)
block|{
name|CPP_PUTC
argument_list|(
name|pfile
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|dropwhite
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|FORWARD
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"un-terminated assertion answer"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\r'
condition|)
comment|/* \r cannot be a macro escape here. */
name|CPP_BUMP_LINE
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
else|else
block|{
name|CPP_PUTC
argument_list|(
name|pfile
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|dropwhite
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pfile
operator|->
name|limit
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
name|pfile
operator|->
name|limit
index|[
operator|-
literal|1
index|]
operator|=
literal|')'
expr_stmt|;
elseif|else
if|if
condition|(
name|pfile
operator|->
name|limit
index|[
operator|-
literal|1
index|]
operator|==
literal|'('
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"empty token sequence in assertion"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
name|CPP_PUTC
argument_list|(
name|pfile
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
name|CPP_NUL_TERMINATE
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|do_assert
parameter_list|(
name|pfile
parameter_list|,
name|keyword
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|struct
name|directive
modifier|*
name|keyword
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|char
modifier|*
name|sym
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|c
decl_stmt|;
name|HASHNODE
modifier|*
name|base
decl_stmt|,
modifier|*
name|this
decl_stmt|;
name|int
name|baselen
decl_stmt|,
name|thislen
decl_stmt|;
if|if
condition|(
name|CPP_PEDANTIC
argument_list|(
name|pfile
argument_list|)
operator|&&
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|done_initializing
operator|&&
operator|!
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|->
name|system_header_p
condition|)
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"ANSI C does not allow `#assert'"
argument_list|)
expr_stmt|;
name|cpp_skip_hspace
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|sym
operator|=
operator|(
name|char
operator|*
operator|)
name|CPP_PWRITTEN
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
comment|/* remember where it starts */
name|ret
operator|=
name|parse_assertion
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
goto|goto
name|error
goto|;
elseif|else
if|if
condition|(
name|ret
operator|==
literal|1
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"missing token-sequence in `#assert'"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|cpp_skip_hspace
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|c
operator|=
name|PEEKC
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|EOF
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"junk at end of `#assert'"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|thislen
operator|=
name|strlen
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|baselen
operator|=
name|index
argument_list|(
name|sym
argument_list|,
literal|'('
argument_list|)
operator|-
name|sym
expr_stmt|;
name|this
operator|=
name|cpp_lookup
argument_list|(
name|pfile
argument_list|,
name|sym
argument_list|,
name|thislen
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
condition|)
block|{
name|cpp_warning
argument_list|(
name|pfile
argument_list|,
literal|"`%s' re-asserted"
argument_list|,
name|sym
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|base
operator|=
name|cpp_lookup
argument_list|(
name|pfile
argument_list|,
name|sym
argument_list|,
name|baselen
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|base
condition|)
name|base
operator|=
name|cpp_install
argument_list|(
name|pfile
argument_list|,
name|sym
argument_list|,
name|baselen
argument_list|,
name|T_ASSERT
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|base
operator|->
name|type
operator|!=
name|T_ASSERT
condition|)
block|{
comment|/* Token clash - but with what?! */
name|cpp_fatal
argument_list|(
name|pfile
argument_list|,
literal|"cpp internal error: base->type != T_ASSERT in do_assert"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|this
operator|=
name|cpp_install
argument_list|(
name|pfile
argument_list|,
name|sym
argument_list|,
name|thislen
argument_list|,
name|T_ASSERT
argument_list|,
operator|(
name|char
operator|*
operator|)
name|base
operator|->
name|value
operator|.
name|aschain
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|base
operator|->
name|value
operator|.
name|aschain
operator|=
name|this
expr_stmt|;
name|pfile
operator|->
name|limit
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|sym
expr_stmt|;
comment|/* Pop */
return|return
literal|0
return|;
name|error
label|:
name|skip_rest_of_line
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|limit
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|sym
expr_stmt|;
comment|/* Pop */
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|do_unassert
parameter_list|(
name|pfile
parameter_list|,
name|keyword
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|struct
name|directive
modifier|*
name|keyword
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|int
name|c
decl_stmt|,
name|ret
decl_stmt|;
name|char
modifier|*
name|sym
decl_stmt|;
name|long
name|baselen
decl_stmt|,
name|thislen
decl_stmt|;
name|HASHNODE
modifier|*
name|base
decl_stmt|,
modifier|*
name|this
decl_stmt|,
modifier|*
name|next
decl_stmt|;
if|if
condition|(
name|CPP_PEDANTIC
argument_list|(
name|pfile
argument_list|)
operator|&&
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|done_initializing
operator|&&
operator|!
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|->
name|system_header_p
condition|)
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"ANSI C does not allow `#unassert'"
argument_list|)
expr_stmt|;
name|cpp_skip_hspace
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|sym
operator|=
operator|(
name|char
operator|*
operator|)
name|CPP_PWRITTEN
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
comment|/* remember where it starts */
name|ret
operator|=
name|parse_assertion
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
goto|goto
name|error
goto|;
name|cpp_skip_hspace
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|c
operator|=
name|PEEKC
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|EOF
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"junk at end of `#unassert'"
argument_list|)
expr_stmt|;
name|thislen
operator|=
name|strlen
argument_list|(
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|1
condition|)
block|{
name|base
operator|=
name|cpp_lookup
argument_list|(
name|pfile
argument_list|,
name|sym
argument_list|,
name|thislen
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|base
condition|)
goto|goto
name|error
goto|;
comment|/* It isn't an error to #undef what isn't #defined, 			so it isn't an error to #unassert what isn't 			#asserted either. */
for|for
control|(
name|this
operator|=
name|base
operator|->
name|value
operator|.
name|aschain
init|;
name|this
condition|;
name|this
operator|=
name|next
control|)
block|{
name|next
operator|=
name|this
operator|->
name|value
operator|.
name|aschain
expr_stmt|;
name|delete_macro
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
name|delete_macro
argument_list|(
name|base
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|baselen
operator|=
name|index
argument_list|(
name|sym
argument_list|,
literal|'('
argument_list|)
operator|-
name|sym
expr_stmt|;
name|base
operator|=
name|cpp_lookup
argument_list|(
name|pfile
argument_list|,
name|sym
argument_list|,
name|baselen
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|base
condition|)
goto|goto
name|error
goto|;
name|this
operator|=
name|cpp_lookup
argument_list|(
name|pfile
argument_list|,
name|sym
argument_list|,
name|thislen
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|this
condition|)
goto|goto
name|error
goto|;
name|next
operator|=
name|base
expr_stmt|;
while|while
condition|(
name|next
operator|->
name|value
operator|.
name|aschain
operator|!=
name|this
condition|)
name|next
operator|=
name|next
operator|->
name|value
operator|.
name|aschain
expr_stmt|;
name|next
operator|->
name|value
operator|.
name|aschain
operator|=
name|this
operator|->
name|value
operator|.
name|aschain
expr_stmt|;
name|delete_macro
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
operator|->
name|value
operator|.
name|aschain
operator|==
name|NULL
condition|)
name|delete_macro
argument_list|(
name|base
argument_list|)
expr_stmt|;
comment|/* Last answer for this predicate deleted. */
block|}
name|pfile
operator|->
name|limit
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|sym
expr_stmt|;
comment|/* Pop */
return|return
literal|0
return|;
name|error
label|:
name|skip_rest_of_line
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|limit
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|sym
expr_stmt|;
comment|/* Pop */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Process STR as if it appeared as the body of an #unassert. */
end_comment

begin_function
name|void
name|cpp_unassert
parameter_list|(
name|pfile
parameter_list|,
name|str
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|unsigned
name|char
modifier|*
name|str
decl_stmt|;
block|{
if|if
condition|(
name|cpp_push_buffer
argument_list|(
name|pfile
argument_list|,
name|str
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|do_assert
argument_list|(
name|pfile
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cpp_pop_buffer
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|cpp_read_check_assertion
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|U_CHAR
modifier|*
name|name
init|=
name|CPP_PWRITTEN
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
name|int
name|result
decl_stmt|;
name|HASHNODE
modifier|*
name|hp
decl_stmt|;
name|FORWARD
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Skip '#' */
name|cpp_skip_hspace
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|parse_assertion
argument_list|(
name|pfile
argument_list|)
condition|)
name|result
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|hp
operator|=
name|cpp_lookup
argument_list|(
name|pfile
argument_list|,
name|name
argument_list|,
name|CPP_PWRITTEN
argument_list|(
name|pfile
argument_list|)
operator|-
name|name
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|result
operator|=
operator|(
name|hp
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
name|pfile
operator|->
name|limit
operator|=
name|name
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Remember the current position of PFILE.  */
end_comment

begin_function
name|void
name|parse_set_mark
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|cpp_buffer
modifier|*
name|ip
init|=
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
if|if
condition|(
name|ip
operator|->
name|mark
operator|!=
operator|-
literal|1
condition|)
name|cpp_fatal
argument_list|(
name|pfile
argument_list|,
literal|"cpp internal error: ip->mark != -1 in parse_set_mark"
argument_list|)
expr_stmt|;
name|ip
operator|->
name|mark
operator|=
name|ip
operator|->
name|cur
operator|-
name|ip
operator|->
name|buf
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clear the current mark - we no longer need it.  */
end_comment

begin_function
name|void
name|parse_clear_mark
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|cpp_buffer
modifier|*
name|ip
init|=
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
if|if
condition|(
name|ip
operator|->
name|mark
operator|==
operator|-
literal|1
condition|)
name|cpp_fatal
argument_list|(
name|pfile
argument_list|,
literal|"cpp internal error: ip->mark == -1 in parse_clear_mark"
argument_list|)
expr_stmt|;
name|ip
operator|->
name|mark
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Backup the current position of PFILE to that saved in its mark,    and clear the mark.  */
end_comment

begin_function
name|void
name|parse_goto_mark
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|cpp_buffer
modifier|*
name|ip
init|=
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
if|if
condition|(
name|ip
operator|->
name|mark
operator|==
operator|-
literal|1
condition|)
name|cpp_fatal
argument_list|(
name|pfile
argument_list|,
literal|"cpp internal error: ip->mark == -1 in parse_goto_mark"
argument_list|)
expr_stmt|;
name|ip
operator|->
name|cur
operator|=
name|ip
operator|->
name|buf
operator|+
name|ip
operator|->
name|mark
expr_stmt|;
name|ip
operator|->
name|mark
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cpp_print_file_and_line
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|cpp_buffer
modifier|*
name|ip
init|=
name|cpp_file_buffer
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
if|if
condition|(
name|ip
operator|!=
name|NULL
condition|)
block|{
name|long
name|line
decl_stmt|,
name|col
decl_stmt|;
name|cpp_buf_line_and_col
argument_list|(
name|ip
argument_list|,
operator|&
name|line
argument_list|,
operator|&
name|col
argument_list|)
expr_stmt|;
name|cpp_file_line_for_message
argument_list|(
name|pfile
argument_list|,
name|ip
operator|->
name|nominal_fname
argument_list|,
name|line
argument_list|,
name|pfile
operator|->
name|show_column
condition|?
name|col
else|:
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|v_cpp_error
parameter_list|(
name|pfile
parameter_list|,
name|msgid
parameter_list|,
name|ap
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
block|{
name|cpp_print_containing_files
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|cpp_print_file_and_line
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|v_cpp_message
argument_list|(
name|pfile
argument_list|,
literal|1
argument_list|,
name|msgid
argument_list|,
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|void
name|cpp_error
name|VPROTO
argument_list|(
operator|(
name|cpp_reader
operator|*
name|pfile
operator|,
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
endif|#
directive|endif
name|va_list
name|ap
decl_stmt|;
name|VA_START
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
name|pfile
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|cpp_reader
operator|*
argument_list|)
expr_stmt|;
name|msgid
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|v_cpp_error
argument_list|(
name|pfile
argument_list|,
name|msgid
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Print error message but don't count it.  */
end_comment

begin_function
specifier|static
name|void
name|v_cpp_warning
parameter_list|(
name|pfile
parameter_list|,
name|msgid
parameter_list|,
name|ap
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
block|{
if|if
condition|(
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|inhibit_warnings
condition|)
return|return;
if|if
condition|(
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|warnings_are_errors
condition|)
name|pfile
operator|->
name|errors
operator|++
expr_stmt|;
name|cpp_print_containing_files
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|cpp_print_file_and_line
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|v_cpp_message
argument_list|(
name|pfile
argument_list|,
literal|0
argument_list|,
name|msgid
argument_list|,
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|void
name|cpp_warning
name|VPROTO
argument_list|(
operator|(
name|cpp_reader
operator|*
name|pfile
operator|,
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
endif|#
directive|endif
name|va_list
name|ap
decl_stmt|;
name|VA_START
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
name|pfile
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|cpp_reader
operator|*
argument_list|)
expr_stmt|;
name|msgid
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|v_cpp_warning
argument_list|(
name|pfile
argument_list|,
name|msgid
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Print an error message and maybe count it.  */
end_comment

begin_decl_stmt
name|void
name|cpp_pedwarn
name|VPROTO
argument_list|(
operator|(
name|cpp_reader
operator|*
name|pfile
operator|,
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
endif|#
directive|endif
name|va_list
name|ap
decl_stmt|;
name|VA_START
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
name|pfile
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|cpp_reader
operator|*
argument_list|)
expr_stmt|;
name|msgid
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|pedantic_errors
condition|)
name|v_cpp_error
argument_list|(
name|pfile
argument_list|,
name|msgid
argument_list|,
name|ap
argument_list|)
expr_stmt|;
else|else
name|v_cpp_warning
argument_list|(
name|pfile
argument_list|,
name|msgid
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_function
specifier|static
name|void
name|v_cpp_error_with_line
parameter_list|(
name|pfile
parameter_list|,
name|line
parameter_list|,
name|column
parameter_list|,
name|msgid
parameter_list|,
name|ap
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|int
name|line
decl_stmt|;
name|int
name|column
decl_stmt|;
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
block|{
name|cpp_buffer
modifier|*
name|ip
init|=
name|cpp_file_buffer
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
name|cpp_print_containing_files
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|!=
name|NULL
condition|)
name|cpp_file_line_for_message
argument_list|(
name|pfile
argument_list|,
name|ip
operator|->
name|nominal_fname
argument_list|,
name|line
argument_list|,
name|column
argument_list|)
expr_stmt|;
name|v_cpp_message
argument_list|(
name|pfile
argument_list|,
literal|1
argument_list|,
name|msgid
argument_list|,
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|void
name|cpp_error_with_line
name|VPROTO
argument_list|(
operator|(
name|cpp_reader
operator|*
name|pfile
operator|,
name|int
name|line
operator|,
name|int
name|column
operator|,
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|int
name|line
decl_stmt|;
name|int
name|column
decl_stmt|;
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
endif|#
directive|endif
name|va_list
name|ap
decl_stmt|;
name|VA_START
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
name|pfile
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|cpp_reader
operator|*
argument_list|)
expr_stmt|;
name|line
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|column
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|msgid
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|v_cpp_error_with_line
argument_list|(
name|pfile
argument_list|,
name|line
argument_list|,
name|column
argument_list|,
name|msgid
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_function
specifier|static
name|void
name|v_cpp_warning_with_line
parameter_list|(
name|pfile
parameter_list|,
name|line
parameter_list|,
name|column
parameter_list|,
name|msgid
parameter_list|,
name|ap
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|int
name|line
decl_stmt|;
name|int
name|column
decl_stmt|;
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
block|{
name|cpp_buffer
modifier|*
name|ip
decl_stmt|;
if|if
condition|(
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|inhibit_warnings
condition|)
return|return;
if|if
condition|(
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|warnings_are_errors
condition|)
name|pfile
operator|->
name|errors
operator|++
expr_stmt|;
name|cpp_print_containing_files
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|ip
operator|=
name|cpp_file_buffer
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|!=
name|NULL
condition|)
name|cpp_file_line_for_message
argument_list|(
name|pfile
argument_list|,
name|ip
operator|->
name|nominal_fname
argument_list|,
name|line
argument_list|,
name|column
argument_list|)
expr_stmt|;
name|v_cpp_message
argument_list|(
name|pfile
argument_list|,
literal|0
argument_list|,
name|msgid
argument_list|,
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|void
name|cpp_warning_with_line
name|VPROTO
argument_list|(
operator|(
name|cpp_reader
operator|*
name|pfile
operator|,
name|int
name|line
operator|,
name|int
name|column
operator|,
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|int
name|line
decl_stmt|;
name|int
name|column
decl_stmt|;
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
endif|#
directive|endif
name|va_list
name|ap
decl_stmt|;
name|VA_START
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
name|pfile
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|cpp_reader
operator|*
argument_list|)
expr_stmt|;
name|line
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|column
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|msgid
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|v_cpp_warning_with_line
argument_list|(
name|pfile
argument_list|,
name|line
argument_list|,
name|column
argument_list|,
name|msgid
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|void
name|cpp_pedwarn_with_line
name|VPROTO
argument_list|(
operator|(
name|cpp_reader
operator|*
name|pfile
operator|,
name|int
name|line
operator|,
name|int
name|column
operator|,
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|int
name|line
decl_stmt|;
name|int
name|column
decl_stmt|;
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
endif|#
directive|endif
name|va_list
name|ap
decl_stmt|;
name|VA_START
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
name|pfile
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|cpp_reader
operator|*
argument_list|)
expr_stmt|;
name|line
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|column
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|msgid
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|pedantic_errors
condition|)
name|v_cpp_error_with_line
argument_list|(
name|pfile
argument_list|,
name|column
argument_list|,
name|line
argument_list|,
name|msgid
argument_list|,
name|ap
argument_list|)
expr_stmt|;
else|else
name|v_cpp_warning_with_line
argument_list|(
name|pfile
argument_list|,
name|line
argument_list|,
name|column
argument_list|,
name|msgid
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Report a warning (or an error if pedantic_errors)    giving specified file name and line number, not current.  */
end_comment

begin_decl_stmt
name|void
name|cpp_pedwarn_with_file_and_line
name|VPROTO
argument_list|(
operator|(
name|cpp_reader
operator|*
name|pfile
operator|,
name|char
operator|*
name|file
operator|,
name|int
name|line
operator|,
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
endif|#
directive|endif
name|va_list
name|ap
decl_stmt|;
name|VA_START
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
name|pfile
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|cpp_reader
operator|*
argument_list|)
expr_stmt|;
name|file
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|line
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|msgid
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|pedantic_errors
operator|&&
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|inhibit_warnings
condition|)
return|return;
if|if
condition|(
name|file
operator|!=
name|NULL
condition|)
name|cpp_file_line_for_message
argument_list|(
name|pfile
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|v_cpp_message
argument_list|(
name|pfile
argument_list|,
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|pedantic_errors
argument_list|,
name|msgid
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* my_strerror - return the descriptive text associated with an    `errno' code.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|my_strerror
parameter_list|(
name|errnum
parameter_list|)
name|int
name|errnum
decl_stmt|;
block|{
name|char
modifier|*
name|result
decl_stmt|;
ifndef|#
directive|ifndef
name|VMS
ifndef|#
directive|ifndef
name|HAVE_STRERROR
name|result
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
operator|(
name|errnum
operator|<
name|sys_nerr
operator|)
condition|?
name|sys_errlist
index|[
name|errnum
index|]
else|:
literal|0
operator|)
expr_stmt|;
else|#
directive|else
name|result
operator|=
name|strerror
argument_list|(
name|errnum
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
comment|/* VMS */
comment|/* VAXCRTL's strerror() takes an optional second argument, which only      matters when the first argument is EVMSERR.  However, it's simplest      just to pass it unconditionally.  `vaxc$errno' is declared in<errno.h>, and maintained by the library in parallel with `errno'.      We assume that caller's `errnum' either matches the last setting of      `errno' by the library or else does not have the value `EVMSERR'.  */
name|result
operator|=
name|strerror
argument_list|(
name|errnum
argument_list|,
name|vaxc$errno
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|result
condition|)
name|result
operator|=
literal|"errno = ?"
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Error including a message from `errno'.  */
end_comment

begin_function
name|void
name|cpp_error_from_errno
parameter_list|(
name|pfile
parameter_list|,
name|name
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|cpp_message_from_errno
argument_list|(
name|pfile
argument_list|,
literal|1
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cpp_message_from_errno
parameter_list|(
name|pfile
parameter_list|,
name|is_error
parameter_list|,
name|name
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|int
name|is_error
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|e
init|=
name|errno
decl_stmt|;
name|cpp_buffer
modifier|*
name|ip
init|=
name|cpp_file_buffer
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
name|cpp_print_containing_files
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|!=
name|NULL
condition|)
name|cpp_file_line_for_message
argument_list|(
name|pfile
argument_list|,
name|ip
operator|->
name|nominal_fname
argument_list|,
name|ip
operator|->
name|lineno
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|cpp_message
argument_list|(
name|pfile
argument_list|,
name|is_error
argument_list|,
literal|"%s: %s"
argument_list|,
name|name
argument_list|,
name|my_strerror
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cpp_perror_with_name
parameter_list|(
name|pfile
parameter_list|,
name|name
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|cpp_message
argument_list|(
name|pfile
argument_list|,
literal|1
argument_list|,
literal|"%s: %s: %s"
argument_list|,
name|progname
argument_list|,
name|name
argument_list|,
name|my_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* TODO:  * No pre-compiled header file support.  *  * Possibly different enum token codes for each C/C++ token.  *  * Find and cleanup remaining uses of static variables,  *  * Support -dM flag (dump_all_macros).  *  * Support for_lint flag.  */
end_comment

end_unit

