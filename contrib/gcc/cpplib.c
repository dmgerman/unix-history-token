begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* CPP Library. (Directive handling.)    Copyright (C) 1986, 1987, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002 Free Software Foundation, Inc.    Contributed by Per Bothner, 1994-95.    Based on CCCP program by Paul Rubin, June 1986    Adapted to ANSI C, Richard Stallman, Jan 1987  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"cpplib.h"
end_include

begin_include
include|#
directive|include
file|"cpphash.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_comment
comment|/* Chained list of answers to an assertion.  */
end_comment

begin_struct
struct|struct
name|answer
block|{
name|struct
name|answer
modifier|*
name|next
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
name|cpp_token
name|first
index|[
literal|1
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Stack of conditionals currently in progress    (including both successful and failing conditionals).  */
end_comment

begin_struct
struct|struct
name|if_stack
block|{
name|struct
name|if_stack
modifier|*
name|next
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
comment|/* Line where condition started.  */
specifier|const
name|cpp_hashnode
modifier|*
name|mi_cmacro
decl_stmt|;
comment|/* macro name for #ifndef around entire file */
name|bool
name|skip_elses
decl_stmt|;
comment|/* Can future #else / #elif be skipped?  */
name|bool
name|was_skipping
decl_stmt|;
comment|/* If were skipping on entry.  */
name|int
name|type
decl_stmt|;
comment|/* Most recent conditional, for diagnostics.  */
block|}
struct|;
end_struct

begin_comment
comment|/* Contains a registered pragma or pragma namespace.  */
end_comment

begin_typedef
typedef|typedef
name|void
argument_list|(
argument|*pragma_cb
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|)
argument_list|)
expr_stmt|;
end_typedef

begin_struct
struct|struct
name|pragma_entry
block|{
name|struct
name|pragma_entry
modifier|*
name|next
decl_stmt|;
specifier|const
name|cpp_hashnode
modifier|*
name|pragma
decl_stmt|;
comment|/* Name and length.  */
name|int
name|is_nspace
decl_stmt|;
union|union
block|{
name|pragma_cb
name|handler
decl_stmt|;
name|struct
name|pragma_entry
modifier|*
name|space
decl_stmt|;
block|}
name|u
union|;
block|}
struct|;
end_struct

begin_comment
comment|/* Values for the origin field of struct directive.  KANDR directives    come from traditional (K&R) C.  STDC89 directives come from the    1989 C standard.  EXTENSION directives are extensions.  */
end_comment

begin_define
define|#
directive|define
name|KANDR
value|0
end_define

begin_define
define|#
directive|define
name|STDC89
value|1
end_define

begin_define
define|#
directive|define
name|EXTENSION
value|2
end_define

begin_comment
comment|/* Values for the flags field of struct directive.  COND indicates a    conditional; IF_COND an opening conditional.  INCL means to treat    "..." and<...> as q-char and h-char sequences respectively.  IN_I    means this directive should be handled even if -fpreprocessed is in    effect (these are the directives with callback hooks).  */
end_comment

begin_define
define|#
directive|define
name|COND
value|(1<< 0)
end_define

begin_define
define|#
directive|define
name|IF_COND
value|(1<< 1)
end_define

begin_define
define|#
directive|define
name|INCL
value|(1<< 2)
end_define

begin_define
define|#
directive|define
name|IN_I
value|(1<< 3)
end_define

begin_comment
comment|/* Defines one #-directive, including how to handle it.  */
end_comment

begin_typedef
typedef|typedef
name|void
argument_list|(
argument|*directive_handler
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|)
argument_list|)
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|directive
name|directive
typedef|;
end_typedef

begin_struct
struct|struct
name|directive
block|{
name|directive_handler
name|handler
decl_stmt|;
comment|/* Function to handle directive.  */
specifier|const
name|U_CHAR
modifier|*
name|name
decl_stmt|;
comment|/* Name of directive.  */
name|unsigned
name|short
name|length
decl_stmt|;
comment|/* Length of name.  */
name|unsigned
name|char
name|origin
decl_stmt|;
comment|/* Origin of directive.  */
name|unsigned
name|char
name|flags
decl_stmt|;
comment|/* Flags describing this directive.  */
block|}
struct|;
end_struct

begin_comment
comment|/* Forward declarations.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|skip_rest_of_line
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|check_eol
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|start_directive
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|end_directive
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|directive_diagnostics
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
specifier|const
name|directive
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|run_directive
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|int
operator|,
specifier|const
name|char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|cpp_token
modifier|*
name|glue_header_name
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|cpp_token
modifier|*
name|parse_include
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|push_conditional
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|int
operator|,
name|int
operator|,
specifier|const
name|cpp_hashnode
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|read_flag
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|U_CHAR
modifier|*
name|dequote_string
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
specifier|const
name|U_CHAR
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|strtoul_for_line
name|PARAMS
argument_list|(
operator|(
specifier|const
name|U_CHAR
operator|*
operator|,
name|unsigned
name|int
operator|,
name|unsigned
name|long
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_diagnostic
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
expr|enum
name|error_type
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cpp_hashnode
modifier|*
name|lex_macro_node
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_include_common
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
expr|enum
name|include_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pragma_entry
modifier|*
name|lookup_pragma_entry
name|PARAMS
argument_list|(
operator|(
expr|struct
name|pragma_entry
operator|*
operator|,
specifier|const
name|cpp_hashnode
operator|*
name|pragma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pragma_entry
modifier|*
name|insert_pragma_entry
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
expr|struct
name|pragma_entry
operator|*
operator|*
operator|,
specifier|const
name|cpp_hashnode
operator|*
operator|,
name|pragma_cb
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_pragma_once
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_pragma_poison
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_pragma_system_header
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_pragma_dependency
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_linemarker
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|cpp_token
modifier|*
name|get_token_no_padding
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|cpp_token
modifier|*
name|get__Pragma_string
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|destringize_and_run
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
specifier|const
name|cpp_string
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|parse_answer
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
expr|struct
name|answer
operator|*
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cpp_hashnode
modifier|*
name|parse_assertion
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
expr|struct
name|answer
operator|*
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|answer
modifier|*
modifier|*
name|find_answer
name|PARAMS
argument_list|(
operator|(
name|cpp_hashnode
operator|*
operator|,
specifier|const
expr|struct
name|answer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|handle_assertion
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is the table of directive handlers.  It is ordered by    frequency of occurrence; the numbers at the end are directive    counts from all the source code I have lying around (egcs and libc    CVS as of 1999-05-18, plus grub-0.5.91, linux-2.2.9, and    pcmcia-cs-3.0.9).  This is no longer important as directive lookup    is now O(1).  All extensions other than #warning and #include_next    are deprecated.  The name is where the extension appears to have    come from.  */
end_comment

begin_define
define|#
directive|define
name|DIRECTIVE_TABLE
define|\
value|D(define,	T_DEFINE = 0,	KANDR,     IN_I)
comment|/* 270554 */
value|\ D(include,	T_INCLUDE,	KANDR,     INCL)
comment|/*  52262 */
value|\ D(endif,	T_ENDIF,	KANDR,     COND)
comment|/*  45855 */
value|\ D(ifdef,	T_IFDEF,	KANDR,     COND | IF_COND)
comment|/*  22000 */
value|\ D(if,		T_IF,		KANDR,     COND | IF_COND)
comment|/*  18162 */
value|\ D(else,		T_ELSE,		KANDR,     COND)
comment|/*   9863 */
value|\ D(ifndef,	T_IFNDEF,	KANDR,     COND | IF_COND)
comment|/*   9675 */
value|\ D(undef,	T_UNDEF,	KANDR,     IN_I)
comment|/*   4837 */
value|\ D(line,		T_LINE,		KANDR,     0)
comment|/*   2465 */
value|\ D(elif,		T_ELIF,		STDC89,    COND)
comment|/*    610 */
value|\ D(error,	T_ERROR,	STDC89,    0)
comment|/*    475 */
value|\ D(pragma,	T_PRAGMA,	STDC89,    IN_I)
comment|/*    195 */
value|\ D(warning,	T_WARNING,	EXTENSION, 0)
comment|/*     22 */
value|\ D(include_next,	T_INCLUDE_NEXT,	EXTENSION, INCL)
comment|/*     19 */
value|\ D(ident,	T_IDENT,	EXTENSION, IN_I)
comment|/*     11 */
value|\ D(import,	T_IMPORT,	EXTENSION, INCL)
comment|/* 0 ObjC */
value|\ D(assert,	T_ASSERT,	EXTENSION, 0)
comment|/* 0 SVR4 */
value|\ D(unassert,	T_UNASSERT,	EXTENSION, 0)
comment|/* 0 SVR4 */
value|\ SCCS_ENTRY
end_define

begin_comment
comment|/* 0 SVR4? */
end_comment

begin_comment
comment|/* #sccs is not always recognized.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SCCS_DIRECTIVE
end_ifdef

begin_define
define|#
directive|define
name|SCCS_ENTRY
value|D(sccs, T_SCCS, EXTENSION, 0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SCCS_ENTRY
end_define

begin_comment
comment|/* nothing */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Use the table to generate a series of prototypes, an enum for the    directive names, and an array of directive handlers.  */
end_comment

begin_comment
comment|/* Don't invoke CONCAT2 with any whitespace or K&R cc will fail.  */
end_comment

begin_define
define|#
directive|define
name|D
parameter_list|(
name|name
parameter_list|,
name|t
parameter_list|,
name|o
parameter_list|,
name|f
parameter_list|)
value|static void CONCAT2(do_,name) PARAMS ((cpp_reader *));
end_define

begin_decl_stmt
name|DIRECTIVE_TABLE
undef|#
directive|undef
name|D
define|#
directive|define
name|D
parameter_list|(
name|n
parameter_list|,
name|tag
parameter_list|,
name|o
parameter_list|,
name|f
parameter_list|)
value|tag,
name|enum
type|{
name|DIRECTIVE_TABLE
name|N_DIRECTIVES
end_decl_stmt

begin_undef
unit|};
undef|#
directive|undef
name|D
end_undef

begin_comment
comment|/* Don't invoke CONCAT2 with any whitespace or K&R cc will fail.  */
end_comment

begin_define
define|#
directive|define
name|D
parameter_list|(
name|name
parameter_list|,
name|t
parameter_list|,
name|origin
parameter_list|,
name|flags
parameter_list|)
define|\
value|{ CONCAT2(do_,name), (const U_CHAR *) STRINGX(name), \   sizeof STRINGX(name) - 1, origin, flags },
end_define

begin_decl_stmt
specifier|static
specifier|const
name|directive
name|dtable
index|[]
init|=
block|{
name|DIRECTIVE_TABLE
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|D
end_undef

begin_undef
undef|#
directive|undef
name|DIRECTIVE_TABLE
end_undef

begin_comment
comment|/* Wrapper struct directive for linemarkers.    The origin is more or less true - the original K+R cpp    did use this notation in its preprocessed output.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|directive
name|linemarker_dir
init|=
block|{
name|do_linemarker
block|,
literal|U"#"
block|,
literal|1
block|,
name|KANDR
block|,
name|IN_I
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SEEN_EOL
parameter_list|()
value|(pfile->cur_token[-1].type == CPP_EOF)
end_define

begin_comment
comment|/* Skip any remaining tokens in a directive.  */
end_comment

begin_function
specifier|static
name|void
name|skip_rest_of_line
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
comment|/* Discard all stacked contexts.  */
while|while
condition|(
name|pfile
operator|->
name|context
operator|!=
operator|&
name|pfile
operator|->
name|base_context
condition|)
name|_cpp_pop_context
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
comment|/* Sweep up all tokens remaining on the line.  */
if|if
condition|(
operator|!
name|SEEN_EOL
argument_list|()
condition|)
while|while
condition|(
name|_cpp_lex_token
argument_list|(
name|pfile
argument_list|)
operator|->
name|type
operator|!=
name|CPP_EOF
condition|)
empty_stmt|;
block|}
end_function

begin_comment
comment|/* Ensure there are no stray tokens at the end of a directive.  */
end_comment

begin_function
specifier|static
name|void
name|check_eol
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|SEEN_EOL
argument_list|()
operator|&&
name|_cpp_lex_token
argument_list|(
name|pfile
argument_list|)
operator|->
name|type
operator|!=
name|CPP_EOF
condition|)
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"extra tokens at end of #%s directive"
argument_list|,
name|pfile
operator|->
name|directive
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called when entering a directive, _Pragma or command-line directive.  */
end_comment

begin_function
specifier|static
name|void
name|start_directive
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
comment|/* Setup in-directive state.  */
name|pfile
operator|->
name|state
operator|.
name|in_directive
operator|=
literal|1
expr_stmt|;
name|pfile
operator|->
name|state
operator|.
name|save_comments
operator|=
literal|0
expr_stmt|;
comment|/* Some handlers need the position of the # for diagnostics.  */
name|pfile
operator|->
name|directive_line
operator|=
name|pfile
operator|->
name|line
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called when leaving a directive, _Pragma or command-line directive.  */
end_comment

begin_function
specifier|static
name|void
name|end_directive
parameter_list|(
name|pfile
parameter_list|,
name|skip_line
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|int
name|skip_line
decl_stmt|;
block|{
comment|/* We don't skip for an assembler #.  */
if|if
condition|(
name|skip_line
condition|)
block|{
name|skip_rest_of_line
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pfile
operator|->
name|keep_tokens
condition|)
block|{
name|pfile
operator|->
name|cur_run
operator|=
operator|&
name|pfile
operator|->
name|base_run
expr_stmt|;
name|pfile
operator|->
name|cur_token
operator|=
name|pfile
operator|->
name|base_run
operator|.
name|base
expr_stmt|;
block|}
block|}
comment|/* Restore state.  */
name|pfile
operator|->
name|state
operator|.
name|save_comments
operator|=
operator|!
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|discard_comments
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|state
operator|.
name|in_directive
operator|=
literal|0
expr_stmt|;
name|pfile
operator|->
name|state
operator|.
name|angled_headers
operator|=
literal|0
expr_stmt|;
name|pfile
operator|->
name|directive
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output diagnostics for a directive DIR.  INDENTED is non-zero if    the '#' was indented.  */
end_comment

begin_function
specifier|static
name|void
name|directive_diagnostics
parameter_list|(
name|pfile
parameter_list|,
name|dir
parameter_list|,
name|indented
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
specifier|const
name|directive
modifier|*
name|dir
decl_stmt|;
name|int
name|indented
decl_stmt|;
block|{
comment|/* Issue -pedantic warnings for extensions.  */
if|if
condition|(
name|CPP_PEDANTIC
argument_list|(
name|pfile
argument_list|)
operator|&&
operator|!
name|pfile
operator|->
name|state
operator|.
name|skipping
operator|&&
name|dir
operator|->
name|origin
operator|==
name|EXTENSION
condition|)
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"#%s is a GCC extension"
argument_list|,
name|dir
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* Traditionally, a directive is ignored unless its # is in      column 1.  Therefore in code intended to work with K+R      compilers, directives added by C89 must have their #      indented, and directives present in traditional C must not.      This is true even of directives in skipped conditional      blocks.  #elif cannot be used at all.  */
if|if
condition|(
name|CPP_WTRADITIONAL
argument_list|(
name|pfile
argument_list|)
condition|)
block|{
if|if
condition|(
name|dir
operator|==
operator|&
name|dtable
index|[
name|T_ELIF
index|]
condition|)
name|cpp_warning
argument_list|(
name|pfile
argument_list|,
literal|"suggest not using #elif in traditional C"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|indented
operator|&&
name|dir
operator|->
name|origin
operator|==
name|KANDR
condition|)
name|cpp_warning
argument_list|(
name|pfile
argument_list|,
literal|"traditional C ignores #%s with the # indented"
argument_list|,
name|dir
operator|->
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|indented
operator|&&
name|dir
operator|->
name|origin
operator|!=
name|KANDR
condition|)
name|cpp_warning
argument_list|(
name|pfile
argument_list|,
literal|"suggest hiding #%s from traditional C with an indented #"
argument_list|,
name|dir
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Check if we have a known directive.  INDENTED is non-zero if the    '#' of the directive was indented.  This function is in this file    to save unnecessarily exporting dtable etc. to cpplex.c.  Returns    non-zero if the line of tokens has been handled, zero if we should    continue processing the line.  */
end_comment

begin_function
name|int
name|_cpp_handle_directive
parameter_list|(
name|pfile
parameter_list|,
name|indented
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|int
name|indented
decl_stmt|;
block|{
specifier|const
name|directive
modifier|*
name|dir
init|=
literal|0
decl_stmt|;
specifier|const
name|cpp_token
modifier|*
name|dname
decl_stmt|;
name|int
name|skip
init|=
literal|1
decl_stmt|;
name|start_directive
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|dname
operator|=
name|_cpp_lex_token
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|dname
operator|->
name|type
operator|==
name|CPP_NAME
condition|)
block|{
if|if
condition|(
name|dname
operator|->
name|val
operator|.
name|node
operator|->
name|directive_index
condition|)
name|dir
operator|=
operator|&
name|dtable
index|[
name|dname
operator|->
name|val
operator|.
name|node
operator|->
name|directive_index
operator|-
literal|1
index|]
expr_stmt|;
block|}
comment|/* We do not recognise the # followed by a number extension in      assembler code.  */
elseif|else
if|if
condition|(
name|dname
operator|->
name|type
operator|==
name|CPP_NUMBER
operator|&&
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|lang
argument_list|)
operator|!=
name|CLK_ASM
condition|)
block|{
name|dir
operator|=
operator|&
name|linemarker_dir
expr_stmt|;
if|if
condition|(
name|CPP_PEDANTIC
argument_list|(
name|pfile
argument_list|)
operator|&&
operator|!
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|preprocessed
argument_list|)
operator|&&
operator|!
name|pfile
operator|->
name|state
operator|.
name|skipping
condition|)
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"style of line directive is a GCC extension"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dir
condition|)
block|{
comment|/* If we have a directive that is not an opening conditional, 	 invalidate any control macro.  */
if|if
condition|(
operator|!
operator|(
name|dir
operator|->
name|flags
operator|&
name|IF_COND
operator|)
condition|)
name|pfile
operator|->
name|mi_valid
operator|=
name|false
expr_stmt|;
comment|/* Kluge alert.  In order to be sure that code like this  	 #define HASH # 	 HASH define foo bar  	 does not cause '#define foo bar' to get executed when 	 compiled with -save-temps, we recognize directives in 	 -fpreprocessed mode only if the # is in column 1.  cppmacro.c 	 puts a space in front of any '#' at the start of a macro.  */
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|preprocessed
argument_list|)
operator|&&
operator|(
name|indented
operator|||
operator|!
operator|(
name|dir
operator|->
name|flags
operator|&
name|IN_I
operator|)
operator|)
condition|)
block|{
name|skip
operator|=
literal|0
expr_stmt|;
name|dir
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* In failed conditional groups, all non-conditional 	     directives are ignored.  Before doing that, whether 	     skipping or not, we should lex angle-bracketed headers 	     correctly, and maybe output some diagnostics.  */
name|pfile
operator|->
name|state
operator|.
name|angled_headers
operator|=
name|dir
operator|->
name|flags
operator|&
name|INCL
expr_stmt|;
if|if
condition|(
operator|!
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|preprocessed
argument_list|)
condition|)
name|directive_diagnostics
argument_list|(
name|pfile
argument_list|,
name|dir
argument_list|,
name|indented
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfile
operator|->
name|state
operator|.
name|skipping
operator|&&
operator|!
operator|(
name|dir
operator|->
name|flags
operator|&
name|COND
operator|)
condition|)
name|dir
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|dname
operator|->
name|type
operator|==
name|CPP_EOF
condition|)
empty_stmt|;
comment|/* CPP_EOF is the "null directive".  */
else|else
block|{
comment|/* An unknown directive.  Don't complain about it in assembly 	 source: we don't know where the comments are, and # may 	 introduce assembler pseudo-ops.  Don't complain about invalid 	 directives in skipped conditional groups (6.10 p4).  */
if|if
condition|(
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|lang
argument_list|)
operator|==
name|CLK_ASM
condition|)
name|skip
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|pfile
operator|->
name|state
operator|.
name|skipping
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"invalid preprocessing directive #%s"
argument_list|,
name|cpp_token_as_text
argument_list|(
name|pfile
argument_list|,
name|dname
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dir
condition|)
block|{
name|pfile
operator|->
name|directive
operator|=
name|dir
expr_stmt|;
call|(
modifier|*
name|pfile
operator|->
name|directive
operator|->
name|handler
call|)
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|skip
operator|==
literal|0
condition|)
name|_cpp_backup_tokens
argument_list|(
name|pfile
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|end_directive
argument_list|(
name|pfile
argument_list|,
name|skip
argument_list|)
expr_stmt|;
return|return
name|skip
return|;
block|}
end_function

begin_comment
comment|/* Directive handler wrapper used by the command line option    processor.  */
end_comment

begin_function
specifier|static
name|void
name|run_directive
parameter_list|(
name|pfile
parameter_list|,
name|dir_no
parameter_list|,
name|buf
parameter_list|,
name|count
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|int
name|dir_no
decl_stmt|;
specifier|const
name|char
modifier|*
name|buf
decl_stmt|;
name|size_t
name|count
decl_stmt|;
block|{
name|cpp_push_buffer
argument_list|(
name|pfile
argument_list|,
operator|(
specifier|const
name|U_CHAR
operator|*
operator|)
name|buf
argument_list|,
name|count
argument_list|,
comment|/* from_stage3 */
name|true
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Disgusting hack.  */
if|if
condition|(
name|dir_no
operator|==
name|T_PRAGMA
condition|)
name|pfile
operator|->
name|buffer
operator|->
name|inc
operator|=
name|pfile
operator|->
name|buffer
operator|->
name|prev
operator|->
name|inc
expr_stmt|;
name|start_directive
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
comment|/* We don't want a leading # to be interpreted as a directive.  */
name|pfile
operator|->
name|buffer
operator|->
name|saved_flags
operator|=
literal|0
expr_stmt|;
name|pfile
operator|->
name|directive
operator|=
operator|&
name|dtable
index|[
name|dir_no
index|]
expr_stmt|;
call|(
name|void
call|)
argument_list|(
operator|*
name|pfile
operator|->
name|directive
operator|->
name|handler
argument_list|)
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|end_directive
argument_list|(
name|pfile
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir_no
operator|==
name|T_PRAGMA
condition|)
name|pfile
operator|->
name|buffer
operator|->
name|inc
operator|=
name|NULL
expr_stmt|;
name|_cpp_pop_buffer
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Checks for validity the macro name in #define, #undef, #ifdef and    #ifndef directives.  */
end_comment

begin_function
specifier|static
name|cpp_hashnode
modifier|*
name|lex_macro_node
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|cpp_hashnode
modifier|*
name|node
decl_stmt|;
specifier|const
name|cpp_token
modifier|*
name|token
init|=
name|_cpp_lex_token
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
comment|/* The token immediately after #define must be an identifier.  That      identifier may not be "defined", per C99 6.10.8p4.      In C++, it may not be any of the "named operators" either,      per C++98 [lex.digraph], [lex.key].      Finally, the identifier may not have been poisoned.  (In that case      the lexer has issued the error message for us.)  */
if|if
condition|(
name|token
operator|->
name|type
operator|!=
name|CPP_NAME
condition|)
block|{
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_EOF
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"no macro name given in #%s directive"
argument_list|,
name|pfile
operator|->
name|directive
operator|->
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|token
operator|->
name|flags
operator|&
name|NAMED_OP
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"\"%s\" cannot be used as a macro name as it is an operator in C++"
argument_list|,
name|NODE_NAME
argument_list|(
name|token
operator|->
name|val
operator|.
name|node
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"macro names must be identifiers"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|node
operator|=
name|token
operator|->
name|val
operator|.
name|node
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|flags
operator|&
name|NODE_POISONED
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|node
operator|==
name|pfile
operator|->
name|spec_nodes
operator|.
name|n_defined
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"\"%s\" cannot be used as a macro name"
argument_list|,
name|NODE_NAME
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|node
return|;
block|}
end_function

begin_comment
comment|/* Process a #define directive.  Most work is done in cppmacro.c.  */
end_comment

begin_function
specifier|static
name|void
name|do_define
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|cpp_hashnode
modifier|*
name|node
init|=
name|lex_macro_node
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
condition|)
block|{
if|if
condition|(
name|_cpp_create_definition
argument_list|(
name|pfile
argument_list|,
name|node
argument_list|)
condition|)
if|if
condition|(
name|pfile
operator|->
name|cb
operator|.
name|define
condition|)
call|(
modifier|*
name|pfile
operator|->
name|cb
operator|.
name|define
call|)
argument_list|(
name|pfile
argument_list|,
name|pfile
operator|->
name|directive_line
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Handle #undef.  Mark the identifier NT_VOID in the hash table.  */
end_comment

begin_function
specifier|static
name|void
name|do_undef
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|cpp_hashnode
modifier|*
name|node
init|=
name|lex_macro_node
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
comment|/* 6.10.3.5 paragraph 2: [#undef] is ignored if the specified identifier      is not currently defined as a macro name.  */
if|if
condition|(
name|node
operator|&&
name|node
operator|->
name|type
operator|==
name|NT_MACRO
condition|)
block|{
if|if
condition|(
name|pfile
operator|->
name|cb
operator|.
name|undef
condition|)
call|(
modifier|*
name|pfile
operator|->
name|cb
operator|.
name|undef
call|)
argument_list|(
name|pfile
argument_list|,
name|pfile
operator|->
name|directive_line
argument_list|,
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|flags
operator|&
name|NODE_WARN
condition|)
name|cpp_warning
argument_list|(
name|pfile
argument_list|,
literal|"undefining \"%s\""
argument_list|,
name|NODE_NAME
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|_cpp_free_definition
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
name|check_eol
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Helper routine used by parse_include.  Reinterpret the current line    as an h-char-sequence (< ...>); we are looking at the first token    after the<.  Returns the header as a token, or NULL on failure.  */
end_comment

begin_function
specifier|static
specifier|const
name|cpp_token
modifier|*
name|glue_header_name
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|cpp_token
modifier|*
name|header
init|=
name|NULL
decl_stmt|;
specifier|const
name|cpp_token
modifier|*
name|token
decl_stmt|;
name|unsigned
name|char
modifier|*
name|buffer
decl_stmt|;
name|size_t
name|len
decl_stmt|,
name|total_len
init|=
literal|0
decl_stmt|,
name|capacity
init|=
literal|1024
decl_stmt|;
comment|/* To avoid lexed tokens overwriting our glued name, we can only      allocate from the string pool once we've lexed everything.  */
name|buffer
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|capacity
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|token
operator|=
name|cpp_get_token
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_GREATER
operator|||
name|token
operator|->
name|type
operator|==
name|CPP_EOF
condition|)
break|break;
name|len
operator|=
name|cpp_token_len
argument_list|(
name|token
argument_list|)
expr_stmt|;
if|if
condition|(
name|total_len
operator|+
name|len
operator|>
name|capacity
condition|)
block|{
name|capacity
operator|=
operator|(
name|capacity
operator|+
name|len
operator|)
operator|*
literal|2
expr_stmt|;
name|buffer
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|buffer
argument_list|,
name|capacity
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|token
operator|->
name|flags
operator|&
name|PREV_WHITE
condition|)
name|buffer
index|[
name|total_len
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
name|total_len
operator|=
name|cpp_spell_token
argument_list|(
name|pfile
argument_list|,
name|token
argument_list|,
operator|&
name|buffer
index|[
name|total_len
index|]
argument_list|)
operator|-
name|buffer
expr_stmt|;
block|}
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_EOF
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"missing terminating> character"
argument_list|)
expr_stmt|;
else|else
block|{
name|unsigned
name|char
modifier|*
name|token_mem
init|=
name|_cpp_unaligned_alloc
argument_list|(
name|pfile
argument_list|,
name|total_len
operator|+
literal|1
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|token_mem
argument_list|,
name|buffer
argument_list|,
name|total_len
argument_list|)
expr_stmt|;
name|token_mem
index|[
name|total_len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|header
operator|=
name|_cpp_temp_token
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|header
operator|->
name|type
operator|=
name|CPP_HEADER_NAME
expr_stmt|;
name|header
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|header
operator|->
name|val
operator|.
name|str
operator|.
name|len
operator|=
name|total_len
expr_stmt|;
name|header
operator|->
name|val
operator|.
name|str
operator|.
name|text
operator|=
name|token_mem
expr_stmt|;
block|}
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|buffer
argument_list|)
expr_stmt|;
return|return
name|header
return|;
block|}
end_function

begin_comment
comment|/* Returns the header string of #include, #include_next, #import and    #pragma dependency.  Returns NULL on error.  */
end_comment

begin_function
specifier|static
specifier|const
name|cpp_token
modifier|*
name|parse_include
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|dir
decl_stmt|;
specifier|const
name|cpp_token
modifier|*
name|header
decl_stmt|;
if|if
condition|(
name|pfile
operator|->
name|directive
operator|==
operator|&
name|dtable
index|[
name|T_PRAGMA
index|]
condition|)
name|dir
operator|=
literal|U"pragma dependency"
expr_stmt|;
else|else
name|dir
operator|=
name|pfile
operator|->
name|directive
operator|->
name|name
expr_stmt|;
comment|/* Allow macro expansion.  */
name|header
operator|=
name|cpp_get_token
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|header
operator|->
name|type
operator|!=
name|CPP_STRING
operator|&&
name|header
operator|->
name|type
operator|!=
name|CPP_HEADER_NAME
condition|)
block|{
if|if
condition|(
name|header
operator|->
name|type
operator|!=
name|CPP_LESS
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"#%s expects \"FILENAME\" or<FILENAME>"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|header
operator|=
name|glue_header_name
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|header
operator|==
name|NULL
condition|)
return|return
name|header
return|;
block|}
if|if
condition|(
name|header
operator|->
name|val
operator|.
name|str
operator|.
name|len
operator|==
literal|0
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"empty file name in #%s"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|header
return|;
block|}
end_function

begin_comment
comment|/* Handle #include, #include_next and #import.  */
end_comment

begin_function
specifier|static
name|void
name|do_include_common
parameter_list|(
name|pfile
parameter_list|,
name|type
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|enum
name|include_type
name|type
decl_stmt|;
block|{
specifier|const
name|cpp_token
modifier|*
name|header
decl_stmt|;
comment|/* For #include_next, if this is the primary source file, warn and      use the normal search logic.  */
if|if
condition|(
name|type
operator|==
name|IT_INCLUDE_NEXT
operator|&&
operator|!
name|pfile
operator|->
name|buffer
operator|->
name|prev
condition|)
block|{
name|cpp_warning
argument_list|(
name|pfile
argument_list|,
literal|"#include_next in primary source file"
argument_list|)
expr_stmt|;
name|type
operator|=
name|IT_INCLUDE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|IT_IMPORT
operator|&&
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|warn_import
argument_list|)
condition|)
block|{
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|warn_import
argument_list|)
operator|=
literal|0
expr_stmt|;
name|cpp_warning
argument_list|(
name|pfile
argument_list|,
literal|"#import is obsolete, use an #ifndef wrapper in the header file"
argument_list|)
expr_stmt|;
block|}
name|header
operator|=
name|parse_include
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|header
condition|)
block|{
comment|/* Prevent #include recursion.  */
if|if
condition|(
name|pfile
operator|->
name|line_maps
operator|.
name|depth
operator|>=
name|CPP_STACK_MAX
condition|)
name|cpp_fatal
argument_list|(
name|pfile
argument_list|,
literal|"#include nested too deeply"
argument_list|)
expr_stmt|;
else|else
block|{
name|check_eol
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
comment|/* Get out of macro context, if we are.  */
name|skip_rest_of_line
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfile
operator|->
name|cb
operator|.
name|include
condition|)
call|(
modifier|*
name|pfile
operator|->
name|cb
operator|.
name|include
call|)
argument_list|(
name|pfile
argument_list|,
name|pfile
operator|->
name|directive_line
argument_list|,
name|pfile
operator|->
name|directive
operator|->
name|name
argument_list|,
name|header
argument_list|)
expr_stmt|;
name|_cpp_execute_include
argument_list|(
name|pfile
argument_list|,
name|header
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|do_include
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|do_include_common
argument_list|(
name|pfile
argument_list|,
name|IT_INCLUDE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_import
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|do_include_common
argument_list|(
name|pfile
argument_list|,
name|IT_IMPORT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_include_next
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|do_include_common
argument_list|(
name|pfile
argument_list|,
name|IT_INCLUDE_NEXT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Subroutine of do_linemarker.  Read possible flags after file name.    LAST is the last flag seen; 0 if this is the first flag. Return the    flag if it is valid, 0 at the end of the directive. Otherwise    complain.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|read_flag
parameter_list|(
name|pfile
parameter_list|,
name|last
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|unsigned
name|int
name|last
decl_stmt|;
block|{
specifier|const
name|cpp_token
modifier|*
name|token
init|=
name|_cpp_lex_token
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_NUMBER
operator|&&
name|token
operator|->
name|val
operator|.
name|str
operator|.
name|len
operator|==
literal|1
condition|)
block|{
name|unsigned
name|int
name|flag
init|=
name|token
operator|->
name|val
operator|.
name|str
operator|.
name|text
index|[
literal|0
index|]
operator|-
literal|'0'
decl_stmt|;
if|if
condition|(
name|flag
operator|>
name|last
operator|&&
name|flag
operator|<=
literal|4
operator|&&
operator|(
name|flag
operator|!=
literal|4
operator|||
name|last
operator|==
literal|3
operator|)
operator|&&
operator|(
name|flag
operator|!=
literal|2
operator|||
name|last
operator|==
literal|0
operator|)
condition|)
return|return
name|flag
return|;
block|}
if|if
condition|(
name|token
operator|->
name|type
operator|!=
name|CPP_EOF
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"invalid flag \"%s\" in line directive"
argument_list|,
name|cpp_token_as_text
argument_list|(
name|pfile
argument_list|,
name|token
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of do_line and do_linemarker.  Returns a version of STR    which has a NUL terminator and all escape sequences converted to    their equivalents.  Temporary, hopefully.  */
end_comment

begin_function
specifier|static
name|U_CHAR
modifier|*
name|dequote_string
parameter_list|(
name|pfile
parameter_list|,
name|str
parameter_list|,
name|len
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
specifier|const
name|U_CHAR
modifier|*
name|str
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
block|{
name|U_CHAR
modifier|*
name|result
init|=
name|_cpp_unaligned_alloc
argument_list|(
name|pfile
argument_list|,
name|len
operator|+
literal|1
argument_list|)
decl_stmt|;
name|U_CHAR
modifier|*
name|dst
init|=
name|result
decl_stmt|;
specifier|const
name|U_CHAR
modifier|*
name|limit
init|=
name|str
operator|+
name|len
decl_stmt|;
name|unsigned
name|int
name|c
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|mask
decl_stmt|;
comment|/* We need the mask to match the host's 'unsigned char', not the      target's.  */
if|if
condition|(
name|CHAR_BIT
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
name|mask
operator|=
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|CHAR_BIT
operator|)
operator|-
literal|1
expr_stmt|;
else|else
name|mask
operator|=
operator|~
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0
expr_stmt|;
while|while
condition|(
name|str
operator|<
name|limit
condition|)
block|{
name|c
operator|=
operator|*
name|str
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'\\'
condition|)
operator|*
name|dst
operator|++
operator|=
name|c
expr_stmt|;
else|else
operator|*
name|dst
operator|++
operator|=
name|cpp_parse_escape
argument_list|(
name|pfile
argument_list|,
operator|(
specifier|const
name|U_CHAR
operator|*
operator|*
operator|)
operator|&
name|str
argument_list|,
name|limit
argument_list|,
name|mask
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
operator|*
name|dst
operator|++
operator|=
literal|'\0'
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of do_line and do_linemarker.  Convert a number in STR,    of length LEN, to binary; store it in NUMP, and return 0 if the    number was well-formed, 1 if not.  Temporary, hopefully.  */
end_comment

begin_function
specifier|static
name|int
name|strtoul_for_line
parameter_list|(
name|str
parameter_list|,
name|len
parameter_list|,
name|nump
parameter_list|)
specifier|const
name|U_CHAR
modifier|*
name|str
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
name|unsigned
name|long
modifier|*
name|nump
decl_stmt|;
block|{
name|unsigned
name|long
name|reg
init|=
literal|0
decl_stmt|;
name|U_CHAR
name|c
decl_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
block|{
name|c
operator|=
operator|*
name|str
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|ISDIGIT
argument_list|(
name|c
argument_list|)
condition|)
return|return
literal|1
return|;
name|reg
operator|*=
literal|10
expr_stmt|;
name|reg
operator|+=
name|c
operator|-
literal|'0'
expr_stmt|;
block|}
operator|*
name|nump
operator|=
name|reg
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Interpret #line command.    Note that the filename string (if any) is a true string constant    (escapes are interpreted), unlike in #line.  */
end_comment

begin_function
specifier|static
name|void
name|do_line
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
specifier|const
name|cpp_token
modifier|*
name|token
decl_stmt|;
specifier|const
name|char
modifier|*
name|new_file
init|=
name|pfile
operator|->
name|map
operator|->
name|to_file
decl_stmt|;
name|unsigned
name|long
name|new_lineno
decl_stmt|;
comment|/* C99 raised the minimum limit on #line numbers.  */
name|unsigned
name|int
name|cap
init|=
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|c99
argument_list|)
condition|?
literal|2147483647
else|:
literal|32767
decl_stmt|;
comment|/* #line commands expand macros.  */
name|token
operator|=
name|cpp_get_token
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|!=
name|CPP_NUMBER
operator|||
name|strtoul_for_line
argument_list|(
name|token
operator|->
name|val
operator|.
name|str
operator|.
name|text
argument_list|,
name|token
operator|->
name|val
operator|.
name|str
operator|.
name|len
argument_list|,
operator|&
name|new_lineno
argument_list|)
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"\"%s\" after #line is not a positive integer"
argument_list|,
name|cpp_token_as_text
argument_list|(
name|pfile
argument_list|,
name|token
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|CPP_PEDANTIC
argument_list|(
name|pfile
argument_list|)
operator|&&
operator|(
name|new_lineno
operator|==
literal|0
operator|||
name|new_lineno
operator|>
name|cap
operator|)
condition|)
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"line number out of range"
argument_list|)
expr_stmt|;
name|token
operator|=
name|cpp_get_token
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_STRING
condition|)
block|{
name|new_file
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|dequote_string
argument_list|(
name|pfile
argument_list|,
name|token
operator|->
name|val
operator|.
name|str
operator|.
name|text
argument_list|,
name|token
operator|->
name|val
operator|.
name|str
operator|.
name|len
argument_list|)
expr_stmt|;
name|check_eol
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|->
name|type
operator|!=
name|CPP_EOF
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"\"%s\" is not a valid filename"
argument_list|,
name|cpp_token_as_text
argument_list|(
name|pfile
argument_list|,
name|token
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|skip_rest_of_line
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|_cpp_do_file_change
argument_list|(
name|pfile
argument_list|,
name|LC_RENAME
argument_list|,
name|new_file
argument_list|,
name|new_lineno
argument_list|,
name|pfile
operator|->
name|map
operator|->
name|sysp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Interpret the # 44 "file" [flags] notation, which has slightly    different syntax and semantics from #line:  Flags are allowed,    and we never complain about the line number being too big.  */
end_comment

begin_function
specifier|static
name|void
name|do_linemarker
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
specifier|const
name|cpp_token
modifier|*
name|token
decl_stmt|;
specifier|const
name|char
modifier|*
name|new_file
init|=
name|pfile
operator|->
name|map
operator|->
name|to_file
decl_stmt|;
name|unsigned
name|long
name|new_lineno
decl_stmt|;
name|unsigned
name|int
name|new_sysp
init|=
name|pfile
operator|->
name|map
operator|->
name|sysp
decl_stmt|;
name|enum
name|lc_reason
name|reason
init|=
name|LC_RENAME
decl_stmt|;
name|int
name|flag
decl_stmt|;
comment|/* Back up so we can get the number again.  Putting this in      _cpp_handle_directive risks two calls to _cpp_backup_tokens in      some circumstances, which can segfault.  */
name|_cpp_backup_tokens
argument_list|(
name|pfile
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* #line commands expand macros.  */
name|token
operator|=
name|cpp_get_token
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|!=
name|CPP_NUMBER
operator|||
name|strtoul_for_line
argument_list|(
name|token
operator|->
name|val
operator|.
name|str
operator|.
name|text
argument_list|,
name|token
operator|->
name|val
operator|.
name|str
operator|.
name|len
argument_list|,
operator|&
name|new_lineno
argument_list|)
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"\"%s\" after # is not a positive integer"
argument_list|,
name|cpp_token_as_text
argument_list|(
name|pfile
argument_list|,
name|token
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|token
operator|=
name|cpp_get_token
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_STRING
condition|)
block|{
name|new_file
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|dequote_string
argument_list|(
name|pfile
argument_list|,
name|token
operator|->
name|val
operator|.
name|str
operator|.
name|text
argument_list|,
name|token
operator|->
name|val
operator|.
name|str
operator|.
name|len
argument_list|)
expr_stmt|;
name|new_sysp
operator|=
literal|0
expr_stmt|;
name|flag
operator|=
name|read_flag
argument_list|(
name|pfile
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
operator|==
literal|1
condition|)
block|{
name|reason
operator|=
name|LC_ENTER
expr_stmt|;
comment|/* Fake an include for cpp_included ().  */
name|_cpp_fake_include
argument_list|(
name|pfile
argument_list|,
name|new_file
argument_list|)
expr_stmt|;
name|flag
operator|=
name|read_flag
argument_list|(
name|pfile
argument_list|,
name|flag
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flag
operator|==
literal|2
condition|)
block|{
name|reason
operator|=
name|LC_LEAVE
expr_stmt|;
name|flag
operator|=
name|read_flag
argument_list|(
name|pfile
argument_list|,
name|flag
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag
operator|==
literal|3
condition|)
block|{
name|new_sysp
operator|=
literal|1
expr_stmt|;
name|flag
operator|=
name|read_flag
argument_list|(
name|pfile
argument_list|,
name|flag
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
operator|==
literal|4
condition|)
name|new_sysp
operator|=
literal|2
expr_stmt|;
block|}
name|check_eol
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|->
name|type
operator|!=
name|CPP_EOF
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"\"%s\" is not a valid filename"
argument_list|,
name|cpp_token_as_text
argument_list|(
name|pfile
argument_list|,
name|token
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|skip_rest_of_line
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|_cpp_do_file_change
argument_list|(
name|pfile
argument_list|,
name|reason
argument_list|,
name|new_file
argument_list|,
name|new_lineno
argument_list|,
name|new_sysp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Arrange the file_change callback.  pfile->line has changed to    FILE_LINE of TO_FILE, for reason REASON.  SYSP is 1 for a system    header, 2 for a system header that needs to be extern "C" protected,    and zero otherwise.  */
end_comment

begin_function
name|void
name|_cpp_do_file_change
parameter_list|(
name|pfile
parameter_list|,
name|reason
parameter_list|,
name|to_file
parameter_list|,
name|file_line
parameter_list|,
name|sysp
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|enum
name|lc_reason
name|reason
decl_stmt|;
specifier|const
name|char
modifier|*
name|to_file
decl_stmt|;
name|unsigned
name|int
name|file_line
decl_stmt|;
name|unsigned
name|int
name|sysp
decl_stmt|;
block|{
name|pfile
operator|->
name|map
operator|=
name|add_line_map
argument_list|(
operator|&
name|pfile
operator|->
name|line_maps
argument_list|,
name|reason
argument_list|,
name|sysp
argument_list|,
name|pfile
operator|->
name|line
argument_list|,
name|to_file
argument_list|,
name|file_line
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfile
operator|->
name|cb
operator|.
name|file_change
condition|)
call|(
modifier|*
name|pfile
operator|->
name|cb
operator|.
name|file_change
call|)
argument_list|(
name|pfile
argument_list|,
name|pfile
operator|->
name|map
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Report a warning or error detected by the program we are    processing.  Use the directive's tokens in the error message.  */
end_comment

begin_function
specifier|static
name|void
name|do_diagnostic
parameter_list|(
name|pfile
parameter_list|,
name|code
parameter_list|,
name|print_dir
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|enum
name|error_type
name|code
decl_stmt|;
name|int
name|print_dir
decl_stmt|;
block|{
if|if
condition|(
name|_cpp_begin_message
argument_list|(
name|pfile
argument_list|,
name|code
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
name|print_dir
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"#%s "
argument_list|,
name|pfile
operator|->
name|directive
operator|->
name|name
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|state
operator|.
name|prevent_expansion
operator|++
expr_stmt|;
name|cpp_output_line
argument_list|(
name|pfile
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|state
operator|.
name|prevent_expansion
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|do_error
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|do_diagnostic
argument_list|(
name|pfile
argument_list|,
name|ERROR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_warning
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
comment|/* We want #warning diagnostics to be emitted in system headers too.  */
name|do_diagnostic
argument_list|(
name|pfile
argument_list|,
name|WARNING_SYSHDR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Report program identification.  */
end_comment

begin_function
specifier|static
name|void
name|do_ident
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
specifier|const
name|cpp_token
modifier|*
name|str
init|=
name|cpp_get_token
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
if|if
condition|(
name|str
operator|->
name|type
operator|!=
name|CPP_STRING
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"invalid #ident directive"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pfile
operator|->
name|cb
operator|.
name|ident
condition|)
call|(
modifier|*
name|pfile
operator|->
name|cb
operator|.
name|ident
call|)
argument_list|(
name|pfile
argument_list|,
name|pfile
operator|->
name|directive_line
argument_list|,
operator|&
name|str
operator|->
name|val
operator|.
name|str
argument_list|)
expr_stmt|;
name|check_eol
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Lookup a PRAGMA name in a singly-linked CHAIN.  Returns the    matching entry, or NULL if none is found.  The returned entry could    be the start of a namespace chain, or a pragma.  */
end_comment

begin_function
specifier|static
name|struct
name|pragma_entry
modifier|*
name|lookup_pragma_entry
parameter_list|(
name|chain
parameter_list|,
name|pragma
parameter_list|)
name|struct
name|pragma_entry
modifier|*
name|chain
decl_stmt|;
specifier|const
name|cpp_hashnode
modifier|*
name|pragma
decl_stmt|;
block|{
while|while
condition|(
name|chain
operator|&&
name|chain
operator|->
name|pragma
operator|!=
name|pragma
condition|)
name|chain
operator|=
name|chain
operator|->
name|next
expr_stmt|;
return|return
name|chain
return|;
block|}
end_function

begin_comment
comment|/* Create and insert a pragma entry for NAME at the beginning of a    singly-linked CHAIN.  If handler is NULL, it is a namespace,    otherwise it is a pragma and its handler.  */
end_comment

begin_function
specifier|static
name|struct
name|pragma_entry
modifier|*
name|insert_pragma_entry
parameter_list|(
name|pfile
parameter_list|,
name|chain
parameter_list|,
name|pragma
parameter_list|,
name|handler
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|struct
name|pragma_entry
modifier|*
modifier|*
name|chain
decl_stmt|;
specifier|const
name|cpp_hashnode
modifier|*
name|pragma
decl_stmt|;
name|pragma_cb
name|handler
decl_stmt|;
block|{
name|struct
name|pragma_entry
modifier|*
name|new
decl_stmt|;
name|new
operator|=
operator|(
expr|struct
name|pragma_entry
operator|*
operator|)
name|_cpp_aligned_alloc
argument_list|(
name|pfile
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pragma_entry
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|pragma
operator|=
name|pragma
expr_stmt|;
if|if
condition|(
name|handler
condition|)
block|{
name|new
operator|->
name|is_nspace
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|u
operator|.
name|handler
operator|=
name|handler
expr_stmt|;
block|}
else|else
block|{
name|new
operator|->
name|is_nspace
operator|=
literal|1
expr_stmt|;
name|new
operator|->
name|u
operator|.
name|space
operator|=
name|NULL
expr_stmt|;
block|}
name|new
operator|->
name|next
operator|=
operator|*
name|chain
expr_stmt|;
operator|*
name|chain
operator|=
name|new
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_comment
comment|/* Register a pragma NAME in namespace SPACE.  If SPACE is null, it    goes in the global namespace.  HANDLER is the handler it will call,    which must be non-NULL.  */
end_comment

begin_function
name|void
name|cpp_register_pragma
parameter_list|(
name|pfile
parameter_list|,
name|space
parameter_list|,
name|name
parameter_list|,
name|handler
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
specifier|const
name|char
modifier|*
name|space
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|pragma_cb
name|handler
decl_stmt|;
block|{
name|struct
name|pragma_entry
modifier|*
modifier|*
name|chain
init|=
operator|&
name|pfile
operator|->
name|pragmas
decl_stmt|;
name|struct
name|pragma_entry
modifier|*
name|entry
decl_stmt|;
specifier|const
name|cpp_hashnode
modifier|*
name|node
decl_stmt|;
if|if
condition|(
operator|!
name|handler
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|space
condition|)
block|{
name|node
operator|=
name|cpp_lookup
argument_list|(
argument|pfile
argument_list|,
argument|U space
argument_list|,
argument|strlen (space)
argument_list|)
expr_stmt|;
name|entry
operator|=
name|lookup_pragma_entry
argument_list|(
operator|*
name|chain
argument_list|,
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|entry
condition|)
name|entry
operator|=
name|insert_pragma_entry
argument_list|(
name|pfile
argument_list|,
name|chain
argument_list|,
name|node
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|entry
operator|->
name|is_nspace
condition|)
goto|goto
name|clash
goto|;
name|chain
operator|=
operator|&
name|entry
operator|->
name|u
operator|.
name|space
expr_stmt|;
block|}
comment|/* Check for duplicates.  */
name|node
operator|=
name|cpp_lookup
argument_list|(
argument|pfile
argument_list|,
argument|U name
argument_list|,
argument|strlen (name)
argument_list|)
expr_stmt|;
name|entry
operator|=
name|lookup_pragma_entry
argument_list|(
operator|*
name|chain
argument_list|,
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
condition|)
block|{
if|if
condition|(
name|entry
operator|->
name|is_nspace
condition|)
name|clash
label|:
name|cpp_ice
argument_list|(
name|pfile
argument_list|,
literal|"registering \"%s\" as both a pragma and a pragma namespace"
argument_list|,
name|NODE_NAME
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|space
condition|)
name|cpp_ice
argument_list|(
name|pfile
argument_list|,
literal|"#pragma %s %s is already registered"
argument_list|,
name|space
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|cpp_ice
argument_list|(
name|pfile
argument_list|,
literal|"#pragma %s is already registered"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
name|insert_pragma_entry
argument_list|(
name|pfile
argument_list|,
name|chain
argument_list|,
name|node
argument_list|,
name|handler
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Register the pragmas the preprocessor itself handles.  */
end_comment

begin_function
name|void
name|_cpp_init_internal_pragmas
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
comment|/* Pragmas in the global namespace.  */
name|cpp_register_pragma
argument_list|(
name|pfile
argument_list|,
literal|0
argument_list|,
literal|"poison"
argument_list|,
name|do_pragma_poison
argument_list|)
expr_stmt|;
name|cpp_register_pragma
argument_list|(
name|pfile
argument_list|,
literal|0
argument_list|,
literal|"once"
argument_list|,
name|do_pragma_once
argument_list|)
expr_stmt|;
comment|/* New GCC-specific pragmas should be put in the GCC namespace.  */
name|cpp_register_pragma
argument_list|(
name|pfile
argument_list|,
literal|"GCC"
argument_list|,
literal|"poison"
argument_list|,
name|do_pragma_poison
argument_list|)
expr_stmt|;
name|cpp_register_pragma
argument_list|(
name|pfile
argument_list|,
literal|"GCC"
argument_list|,
literal|"system_header"
argument_list|,
name|do_pragma_system_header
argument_list|)
expr_stmt|;
name|cpp_register_pragma
argument_list|(
name|pfile
argument_list|,
literal|"GCC"
argument_list|,
literal|"dependency"
argument_list|,
name|do_pragma_dependency
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pragmata handling.  We handle some, and pass the rest on to the    front end.  C99 defines three pragmas and says that no macro    expansion is to be performed on them; whether or not macro    expansion happens for other pragmas is implementation defined.    This implementation never macro-expands the text after #pragma.  */
end_comment

begin_function
specifier|static
name|void
name|do_pragma
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
specifier|const
name|struct
name|pragma_entry
modifier|*
name|p
init|=
name|NULL
decl_stmt|;
specifier|const
name|cpp_token
modifier|*
name|token
decl_stmt|;
name|unsigned
name|int
name|count
init|=
literal|1
decl_stmt|;
name|pfile
operator|->
name|state
operator|.
name|prevent_expansion
operator|++
expr_stmt|;
name|token
operator|=
name|cpp_get_token
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_NAME
condition|)
block|{
name|p
operator|=
name|lookup_pragma_entry
argument_list|(
name|pfile
operator|->
name|pragmas
argument_list|,
name|token
operator|->
name|val
operator|.
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|&&
name|p
operator|->
name|is_nspace
condition|)
block|{
name|count
operator|=
literal|2
expr_stmt|;
name|token
operator|=
name|cpp_get_token
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_NAME
condition|)
name|p
operator|=
name|lookup_pragma_entry
argument_list|(
name|p
operator|->
name|u
operator|.
name|space
argument_list|,
name|token
operator|->
name|val
operator|.
name|node
argument_list|)
expr_stmt|;
else|else
name|p
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* FIXME.  This is an awful kludge to get the front ends to update      their notion of line number for diagnostic purposes.  The line      number should be passed to the handler and they should do it      themselves.  Stand-alone CPP must ignore us, otherwise it will      prefix the directive with spaces, hence the 1.  Ugh.  */
if|if
condition|(
name|pfile
operator|->
name|cb
operator|.
name|line_change
condition|)
call|(
modifier|*
name|pfile
operator|->
name|cb
operator|.
name|line_change
call|)
argument_list|(
name|pfile
argument_list|,
name|token
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
call|(
modifier|*
name|p
operator|->
name|u
operator|.
name|handler
call|)
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pfile
operator|->
name|cb
operator|.
name|def_pragma
condition|)
block|{
name|_cpp_backup_tokens
argument_list|(
name|pfile
argument_list|,
name|count
argument_list|)
expr_stmt|;
call|(
modifier|*
name|pfile
operator|->
name|cb
operator|.
name|def_pragma
call|)
argument_list|(
name|pfile
argument_list|,
name|pfile
operator|->
name|directive_line
argument_list|)
expr_stmt|;
block|}
name|pfile
operator|->
name|state
operator|.
name|prevent_expansion
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle #pragma once.  */
end_comment

begin_function
specifier|static
name|void
name|do_pragma_once
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|cpp_warning
argument_list|(
name|pfile
argument_list|,
literal|"#pragma once is obsolete"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfile
operator|->
name|buffer
operator|->
name|prev
operator|==
name|NULL
condition|)
name|cpp_warning
argument_list|(
name|pfile
argument_list|,
literal|"#pragma once in main file"
argument_list|)
expr_stmt|;
else|else
name|_cpp_never_reread
argument_list|(
name|pfile
operator|->
name|buffer
operator|->
name|inc
argument_list|)
expr_stmt|;
name|check_eol
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle #pragma poison, to poison one or more identifiers so that    the lexer produces a hard error for each subsequent usage.  */
end_comment

begin_function
specifier|static
name|void
name|do_pragma_poison
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
specifier|const
name|cpp_token
modifier|*
name|tok
decl_stmt|;
name|cpp_hashnode
modifier|*
name|hp
decl_stmt|;
name|pfile
operator|->
name|state
operator|.
name|poisoned_ok
operator|=
literal|1
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|tok
operator|=
name|_cpp_lex_token
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|tok
operator|->
name|type
operator|==
name|CPP_EOF
condition|)
break|break;
if|if
condition|(
name|tok
operator|->
name|type
operator|!=
name|CPP_NAME
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"invalid #pragma GCC poison directive"
argument_list|)
expr_stmt|;
break|break;
block|}
name|hp
operator|=
name|tok
operator|->
name|val
operator|.
name|node
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|flags
operator|&
name|NODE_POISONED
condition|)
continue|continue;
if|if
condition|(
name|hp
operator|->
name|type
operator|==
name|NT_MACRO
condition|)
name|cpp_warning
argument_list|(
name|pfile
argument_list|,
literal|"poisoning existing macro \"%s\""
argument_list|,
name|NODE_NAME
argument_list|(
name|hp
argument_list|)
argument_list|)
expr_stmt|;
name|_cpp_free_definition
argument_list|(
name|hp
argument_list|)
expr_stmt|;
name|hp
operator|->
name|flags
operator||=
name|NODE_POISONED
operator||
name|NODE_DIAGNOSTIC
expr_stmt|;
block|}
name|pfile
operator|->
name|state
operator|.
name|poisoned_ok
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Mark the current header as a system header.  This will suppress    some categories of warnings (notably those from -pedantic).  It is    intended for use in system libraries that cannot be implemented in    conforming C, but cannot be certain that their headers appear in a    system include directory.  To prevent abuse, it is rejected in the    primary source file.  */
end_comment

begin_function
specifier|static
name|void
name|do_pragma_system_header
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|cpp_buffer
modifier|*
name|buffer
init|=
name|pfile
operator|->
name|buffer
decl_stmt|;
if|if
condition|(
name|buffer
operator|->
name|prev
operator|==
literal|0
condition|)
name|cpp_warning
argument_list|(
name|pfile
argument_list|,
literal|"#pragma system_header ignored outside include file"
argument_list|)
expr_stmt|;
else|else
block|{
name|check_eol
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|skip_rest_of_line
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|cpp_make_system_header
argument_list|(
name|pfile
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Check the modified date of the current include file against a specified    file. Issue a diagnostic, if the specified file is newer. We use this to    determine if a fixed header should be refixed.  */
end_comment

begin_function
specifier|static
name|void
name|do_pragma_dependency
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
specifier|const
name|cpp_token
modifier|*
name|header
decl_stmt|;
name|int
name|ordering
decl_stmt|;
name|header
operator|=
name|parse_include
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|header
condition|)
return|return;
name|ordering
operator|=
name|_cpp_compare_file_date
argument_list|(
name|pfile
argument_list|,
name|header
argument_list|)
expr_stmt|;
if|if
condition|(
name|ordering
operator|<
literal|0
condition|)
name|cpp_warning
argument_list|(
name|pfile
argument_list|,
literal|"cannot find source %s"
argument_list|,
name|cpp_token_as_text
argument_list|(
name|pfile
argument_list|,
name|header
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ordering
operator|>
literal|0
condition|)
block|{
name|cpp_warning
argument_list|(
name|pfile
argument_list|,
literal|"current file is older than %s"
argument_list|,
name|cpp_token_as_text
argument_list|(
name|pfile
argument_list|,
name|header
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpp_get_token
argument_list|(
name|pfile
argument_list|)
operator|->
name|type
operator|!=
name|CPP_EOF
condition|)
block|{
name|_cpp_backup_tokens
argument_list|(
name|pfile
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|do_diagnostic
argument_list|(
name|pfile
argument_list|,
name|WARNING
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Get a token but skip padding.  */
end_comment

begin_function
specifier|static
specifier|const
name|cpp_token
modifier|*
name|get_token_no_padding
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|const
name|cpp_token
modifier|*
name|result
init|=
name|cpp_get_token
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|->
name|type
operator|!=
name|CPP_PADDING
condition|)
return|return
name|result
return|;
block|}
block|}
end_function

begin_comment
comment|/* Check syntax is "(string-literal)".  Returns the string on success,    or NULL on failure.  */
end_comment

begin_function
specifier|static
specifier|const
name|cpp_token
modifier|*
name|get__Pragma_string
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
specifier|const
name|cpp_token
modifier|*
name|string
decl_stmt|;
if|if
condition|(
name|get_token_no_padding
argument_list|(
name|pfile
argument_list|)
operator|->
name|type
operator|!=
name|CPP_OPEN_PAREN
condition|)
return|return
name|NULL
return|;
name|string
operator|=
name|get_token_no_padding
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|string
operator|->
name|type
operator|!=
name|CPP_STRING
operator|&&
name|string
operator|->
name|type
operator|!=
name|CPP_WSTRING
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|get_token_no_padding
argument_list|(
name|pfile
argument_list|)
operator|->
name|type
operator|!=
name|CPP_CLOSE_PAREN
condition|)
return|return
name|NULL
return|;
return|return
name|string
return|;
block|}
end_function

begin_comment
comment|/* Destringize IN into a temporary buffer, by removing the first \ of    \" and \\ sequences, and process the result as a #pragma directive.  */
end_comment

begin_function
specifier|static
name|void
name|destringize_and_run
parameter_list|(
name|pfile
parameter_list|,
name|in
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
specifier|const
name|cpp_string
modifier|*
name|in
decl_stmt|;
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|src
decl_stmt|,
modifier|*
name|limit
decl_stmt|;
name|char
modifier|*
name|dest
decl_stmt|,
modifier|*
name|result
decl_stmt|;
name|cpp_context
name|saved_context
decl_stmt|;
name|cpp_context
modifier|*
name|saved_cur_context
decl_stmt|;
name|unsigned
name|int
name|saved_line
decl_stmt|;
name|dest
operator|=
name|result
operator|=
name|alloca
argument_list|(
name|in
operator|->
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|src
operator|=
name|in
operator|->
name|text
operator|,
name|limit
operator|=
name|src
operator|+
name|in
operator|->
name|len
init|;
name|src
operator|<
name|limit
condition|;
control|)
block|{
comment|/* We know there is a character following the backslash.  */
if|if
condition|(
operator|*
name|src
operator|==
literal|'\\'
operator|&&
operator|(
name|src
index|[
literal|1
index|]
operator|==
literal|'\\'
operator|||
name|src
index|[
literal|1
index|]
operator|==
literal|'"'
operator|)
condition|)
name|src
operator|++
expr_stmt|;
operator|*
name|dest
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
block|}
operator|*
name|dest
operator|=
literal|'\0'
expr_stmt|;
comment|/* FIXME.  All this saving is a horrible kludge to handle the case      when we're in a macro expansion.                                            A better strategy it to not convert _Pragma to #pragma if doing      preprocessed output, but to just pass it through as-is, unless it      is a CPP pragma in which case is should be processed normally.      When compiling the preprocessed output the _Pragma should be        handled.  This will be become necessary when we move to           line-at-a-time lexing since we will be macro-expanding the line                         before outputting / compiling it.  */
name|saved_line
operator|=
name|pfile
operator|->
name|line
expr_stmt|;
name|saved_context
operator|=
name|pfile
operator|->
name|base_context
expr_stmt|;
name|saved_cur_context
operator|=
name|pfile
operator|->
name|context
expr_stmt|;
name|pfile
operator|->
name|context
operator|=
operator|&
name|pfile
operator|->
name|base_context
expr_stmt|;
name|run_directive
argument_list|(
name|pfile
argument_list|,
name|T_PRAGMA
argument_list|,
name|result
argument_list|,
name|dest
operator|-
name|result
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|context
operator|=
name|saved_cur_context
expr_stmt|;
name|pfile
operator|->
name|base_context
operator|=
name|saved_context
expr_stmt|;
name|pfile
operator|->
name|line
operator|=
name|saved_line
expr_stmt|;
comment|/* See above comment.  For the moment, we'd like       token1 _Pragma ("foo") token2       to be output as               token1              # 7 "file.c"              #pragma foo              # 7 "file.c"                             token2        Getting the line markers is a little tricky.  */
if|if
condition|(
name|pfile
operator|->
name|cb
operator|.
name|line_change
condition|)
call|(
modifier|*
name|pfile
operator|->
name|cb
operator|.
name|line_change
call|)
argument_list|(
name|pfile
argument_list|,
name|pfile
operator|->
name|cur_token
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the _Pragma operator.  */
end_comment

begin_function
name|void
name|_cpp_do__Pragma
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
specifier|const
name|cpp_token
modifier|*
name|string
init|=
name|get__Pragma_string
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
if|if
condition|(
name|string
condition|)
name|destringize_and_run
argument_list|(
name|pfile
argument_list|,
operator|&
name|string
operator|->
name|val
operator|.
name|str
argument_list|)
expr_stmt|;
else|else
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"_Pragma takes a parenthesized string literal"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Just ignore #sccs, on systems where we define it at all.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SCCS_DIRECTIVE
end_ifdef

begin_function
specifier|static
name|void
name|do_sccs
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{ }
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Handle #ifdef.  */
end_comment

begin_function
specifier|static
name|void
name|do_ifdef
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|int
name|skip
init|=
literal|1
decl_stmt|;
if|if
condition|(
operator|!
name|pfile
operator|->
name|state
operator|.
name|skipping
condition|)
block|{
specifier|const
name|cpp_hashnode
modifier|*
name|node
init|=
name|lex_macro_node
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
condition|)
name|skip
operator|=
name|node
operator|->
name|type
operator|!=
name|NT_MACRO
expr_stmt|;
if|if
condition|(
name|node
condition|)
name|check_eol
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
name|push_conditional
argument_list|(
name|pfile
argument_list|,
name|skip
argument_list|,
name|T_IFDEF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle #ifndef.  */
end_comment

begin_function
specifier|static
name|void
name|do_ifndef
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|int
name|skip
init|=
literal|1
decl_stmt|;
specifier|const
name|cpp_hashnode
modifier|*
name|node
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|pfile
operator|->
name|state
operator|.
name|skipping
condition|)
block|{
name|node
operator|=
name|lex_macro_node
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
condition|)
name|skip
operator|=
name|node
operator|->
name|type
operator|==
name|NT_MACRO
expr_stmt|;
if|if
condition|(
name|node
condition|)
name|check_eol
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
name|push_conditional
argument_list|(
name|pfile
argument_list|,
name|skip
argument_list|,
name|T_IFNDEF
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* _cpp_parse_expr puts a macro in a "#if !defined ()" expression in    pfile->mi_ind_cmacro so we can handle multiple-include    optimisations.  If macro expansion occurs in the expression, we    cannot treat it as a controlling conditional, since the expansion    could change in the future.  That is handled by cpp_get_token.  */
end_comment

begin_function
specifier|static
name|void
name|do_if
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|int
name|skip
init|=
literal|1
decl_stmt|;
if|if
condition|(
operator|!
name|pfile
operator|->
name|state
operator|.
name|skipping
condition|)
name|skip
operator|=
name|_cpp_parse_expr
argument_list|(
name|pfile
argument_list|)
operator|==
literal|0
expr_stmt|;
name|push_conditional
argument_list|(
name|pfile
argument_list|,
name|skip
argument_list|,
name|T_IF
argument_list|,
name|pfile
operator|->
name|mi_ind_cmacro
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Flip skipping state if appropriate and continue without changing    if_stack; this is so that the error message for missing #endif's    etc. will point to the original #if.  */
end_comment

begin_function
specifier|static
name|void
name|do_else
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|cpp_buffer
modifier|*
name|buffer
init|=
name|pfile
operator|->
name|buffer
decl_stmt|;
name|struct
name|if_stack
modifier|*
name|ifs
init|=
name|buffer
operator|->
name|if_stack
decl_stmt|;
if|if
condition|(
name|ifs
operator|==
name|NULL
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"#else without #if"
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|ifs
operator|->
name|type
operator|==
name|T_ELSE
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"#else after #else"
argument_list|)
expr_stmt|;
name|cpp_error_with_line
argument_list|(
name|pfile
argument_list|,
name|ifs
operator|->
name|line
argument_list|,
literal|0
argument_list|,
literal|"the conditional began here"
argument_list|)
expr_stmt|;
block|}
name|ifs
operator|->
name|type
operator|=
name|T_ELSE
expr_stmt|;
comment|/* Skip any future (erroneous) #elses or #elifs.  */
name|pfile
operator|->
name|state
operator|.
name|skipping
operator|=
name|ifs
operator|->
name|skip_elses
expr_stmt|;
name|ifs
operator|->
name|skip_elses
operator|=
name|true
expr_stmt|;
comment|/* Invalidate any controlling macro.  */
name|ifs
operator|->
name|mi_cmacro
operator|=
literal|0
expr_stmt|;
comment|/* Only check EOL if was not originally skipping.  */
if|if
condition|(
operator|!
name|ifs
operator|->
name|was_skipping
condition|)
name|check_eol
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Handle a #elif directive by not changing if_stack either.  See the    comment above do_else.  */
end_comment

begin_function
specifier|static
name|void
name|do_elif
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|cpp_buffer
modifier|*
name|buffer
init|=
name|pfile
operator|->
name|buffer
decl_stmt|;
name|struct
name|if_stack
modifier|*
name|ifs
init|=
name|buffer
operator|->
name|if_stack
decl_stmt|;
if|if
condition|(
name|ifs
operator|==
name|NULL
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"#elif without #if"
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|ifs
operator|->
name|type
operator|==
name|T_ELSE
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"#elif after #else"
argument_list|)
expr_stmt|;
name|cpp_error_with_line
argument_list|(
name|pfile
argument_list|,
name|ifs
operator|->
name|line
argument_list|,
literal|0
argument_list|,
literal|"the conditional began here"
argument_list|)
expr_stmt|;
block|}
name|ifs
operator|->
name|type
operator|=
name|T_ELIF
expr_stmt|;
comment|/* Only evaluate this if we aren't skipping elses.  During 	 evaluation, set skipping to false to get lexer warnings.  */
if|if
condition|(
name|ifs
operator|->
name|skip_elses
condition|)
name|pfile
operator|->
name|state
operator|.
name|skipping
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|pfile
operator|->
name|state
operator|.
name|skipping
operator|=
literal|0
expr_stmt|;
name|pfile
operator|->
name|state
operator|.
name|skipping
operator|=
operator|!
name|_cpp_parse_expr
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|ifs
operator|->
name|skip_elses
operator|=
operator|!
name|pfile
operator|->
name|state
operator|.
name|skipping
expr_stmt|;
block|}
comment|/* Invalidate any controlling macro.  */
name|ifs
operator|->
name|mi_cmacro
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* #endif pops the if stack and resets pfile->state.skipping.  */
end_comment

begin_function
specifier|static
name|void
name|do_endif
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|cpp_buffer
modifier|*
name|buffer
init|=
name|pfile
operator|->
name|buffer
decl_stmt|;
name|struct
name|if_stack
modifier|*
name|ifs
init|=
name|buffer
operator|->
name|if_stack
decl_stmt|;
if|if
condition|(
name|ifs
operator|==
name|NULL
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"#endif without #if"
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Only check EOL if was not originally skipping.  */
if|if
condition|(
operator|!
name|ifs
operator|->
name|was_skipping
condition|)
name|check_eol
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
comment|/* If potential control macro, we go back outside again.  */
if|if
condition|(
name|ifs
operator|->
name|next
operator|==
literal|0
operator|&&
name|ifs
operator|->
name|mi_cmacro
condition|)
block|{
name|pfile
operator|->
name|mi_valid
operator|=
name|true
expr_stmt|;
name|pfile
operator|->
name|mi_cmacro
operator|=
name|ifs
operator|->
name|mi_cmacro
expr_stmt|;
block|}
name|buffer
operator|->
name|if_stack
operator|=
name|ifs
operator|->
name|next
expr_stmt|;
name|pfile
operator|->
name|state
operator|.
name|skipping
operator|=
name|ifs
operator|->
name|was_skipping
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|pfile
operator|->
name|buffer_ob
argument_list|,
name|ifs
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Push an if_stack entry for a preprocessor conditional, and set    pfile->state.skipping to SKIP.  If TYPE indicates the conditional    is #if or #ifndef, CMACRO is a potentially controlling macro, and    we need to check here that we are at the top of the file.  */
end_comment

begin_function
specifier|static
name|void
name|push_conditional
parameter_list|(
name|pfile
parameter_list|,
name|skip
parameter_list|,
name|type
parameter_list|,
name|cmacro
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|int
name|skip
decl_stmt|;
name|int
name|type
decl_stmt|;
specifier|const
name|cpp_hashnode
modifier|*
name|cmacro
decl_stmt|;
block|{
name|struct
name|if_stack
modifier|*
name|ifs
decl_stmt|;
name|cpp_buffer
modifier|*
name|buffer
init|=
name|pfile
operator|->
name|buffer
decl_stmt|;
name|ifs
operator|=
name|xobnew
argument_list|(
operator|&
name|pfile
operator|->
name|buffer_ob
argument_list|,
expr|struct
name|if_stack
argument_list|)
expr_stmt|;
name|ifs
operator|->
name|line
operator|=
name|pfile
operator|->
name|directive_line
expr_stmt|;
name|ifs
operator|->
name|next
operator|=
name|buffer
operator|->
name|if_stack
expr_stmt|;
name|ifs
operator|->
name|skip_elses
operator|=
name|pfile
operator|->
name|state
operator|.
name|skipping
operator|||
operator|!
name|skip
expr_stmt|;
name|ifs
operator|->
name|was_skipping
operator|=
name|pfile
operator|->
name|state
operator|.
name|skipping
expr_stmt|;
name|ifs
operator|->
name|type
operator|=
name|type
expr_stmt|;
comment|/* This condition is effectively a test for top-of-file.  */
if|if
condition|(
name|pfile
operator|->
name|mi_valid
operator|&&
name|pfile
operator|->
name|mi_cmacro
operator|==
literal|0
condition|)
name|ifs
operator|->
name|mi_cmacro
operator|=
name|cmacro
expr_stmt|;
else|else
name|ifs
operator|->
name|mi_cmacro
operator|=
literal|0
expr_stmt|;
name|pfile
operator|->
name|state
operator|.
name|skipping
operator|=
name|skip
expr_stmt|;
name|buffer
operator|->
name|if_stack
operator|=
name|ifs
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read the tokens of the answer into the macro pool, in a directive    of type TYPE.  Only commit the memory if we intend it as permanent    storage, i.e. the #assert case.  Returns 0 on success, and sets    ANSWERP to point to the answer.  */
end_comment

begin_function
specifier|static
name|int
name|parse_answer
parameter_list|(
name|pfile
parameter_list|,
name|answerp
parameter_list|,
name|type
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|struct
name|answer
modifier|*
modifier|*
name|answerp
decl_stmt|;
name|int
name|type
decl_stmt|;
block|{
specifier|const
name|cpp_token
modifier|*
name|paren
decl_stmt|;
name|struct
name|answer
modifier|*
name|answer
decl_stmt|;
name|unsigned
name|int
name|acount
decl_stmt|;
comment|/* In a conditional, it is legal to not have an open paren.  We      should save the following token in this case.  */
name|paren
operator|=
name|cpp_get_token
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
comment|/* If not a paren, see if we're OK.  */
if|if
condition|(
name|paren
operator|->
name|type
operator|!=
name|CPP_OPEN_PAREN
condition|)
block|{
comment|/* In a conditional no answer is a test for any answer.  It          could be followed by any token.  */
if|if
condition|(
name|type
operator|==
name|T_IF
condition|)
block|{
name|_cpp_backup_tokens
argument_list|(
name|pfile
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* #unassert with no answer is valid - it removes all answers.  */
if|if
condition|(
name|type
operator|==
name|T_UNASSERT
operator|&&
name|paren
operator|->
name|type
operator|==
name|CPP_EOF
condition|)
return|return
literal|0
return|;
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"missing '(' after predicate"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
for|for
control|(
name|acount
operator|=
literal|0
init|;
condition|;
name|acount
operator|++
control|)
block|{
name|size_t
name|room_needed
decl_stmt|;
specifier|const
name|cpp_token
modifier|*
name|token
init|=
name|cpp_get_token
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
name|cpp_token
modifier|*
name|dest
decl_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_CLOSE_PAREN
condition|)
break|break;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_EOF
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"missing ')' to complete answer"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* struct answer includes the space for one token.  */
name|room_needed
operator|=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|answer
argument_list|)
operator|+
name|acount
operator|*
sizeof|sizeof
argument_list|(
name|cpp_token
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|BUFF_ROOM
argument_list|(
name|pfile
operator|->
name|a_buff
argument_list|)
operator|<
name|room_needed
condition|)
name|_cpp_extend_buff
argument_list|(
name|pfile
argument_list|,
operator|&
name|pfile
operator|->
name|a_buff
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|answer
argument_list|)
argument_list|)
expr_stmt|;
name|dest
operator|=
operator|&
operator|(
operator|(
expr|struct
name|answer
operator|*
operator|)
name|BUFF_FRONT
argument_list|(
name|pfile
operator|->
name|a_buff
argument_list|)
operator|)
operator|->
name|first
index|[
name|acount
index|]
expr_stmt|;
operator|*
name|dest
operator|=
operator|*
name|token
expr_stmt|;
comment|/* Drop whitespace at start, for answer equivalence purposes.  */
if|if
condition|(
name|acount
operator|==
literal|0
condition|)
name|dest
operator|->
name|flags
operator|&=
operator|~
name|PREV_WHITE
expr_stmt|;
block|}
if|if
condition|(
name|acount
operator|==
literal|0
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"predicate's answer is empty"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|answer
operator|=
operator|(
expr|struct
name|answer
operator|*
operator|)
name|BUFF_FRONT
argument_list|(
name|pfile
operator|->
name|a_buff
argument_list|)
expr_stmt|;
name|answer
operator|->
name|count
operator|=
name|acount
expr_stmt|;
name|answer
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
operator|*
name|answerp
operator|=
name|answer
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Parses an assertion directive of type TYPE, returning a pointer to    the hash node of the predicate, or 0 on error.  If an answer was    supplied, it is placed in ANSWERP, otherwise it is set to 0.  */
end_comment

begin_function
specifier|static
name|cpp_hashnode
modifier|*
name|parse_assertion
parameter_list|(
name|pfile
parameter_list|,
name|answerp
parameter_list|,
name|type
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|struct
name|answer
modifier|*
modifier|*
name|answerp
decl_stmt|;
name|int
name|type
decl_stmt|;
block|{
name|cpp_hashnode
modifier|*
name|result
init|=
literal|0
decl_stmt|;
specifier|const
name|cpp_token
modifier|*
name|predicate
decl_stmt|;
comment|/* We don't expand predicates or answers.  */
name|pfile
operator|->
name|state
operator|.
name|prevent_expansion
operator|++
expr_stmt|;
operator|*
name|answerp
operator|=
literal|0
expr_stmt|;
name|predicate
operator|=
name|cpp_get_token
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|predicate
operator|->
name|type
operator|==
name|CPP_EOF
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"assertion without predicate"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|predicate
operator|->
name|type
operator|!=
name|CPP_NAME
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"predicate must be an identifier"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|parse_answer
argument_list|(
name|pfile
argument_list|,
name|answerp
argument_list|,
name|type
argument_list|)
operator|==
literal|0
condition|)
block|{
name|unsigned
name|int
name|len
init|=
name|NODE_LEN
argument_list|(
name|predicate
operator|->
name|val
operator|.
name|node
argument_list|)
decl_stmt|;
name|unsigned
name|char
modifier|*
name|sym
init|=
name|alloca
argument_list|(
name|len
operator|+
literal|1
argument_list|)
decl_stmt|;
comment|/* Prefix '#' to get it out of macro namespace.  */
name|sym
index|[
literal|0
index|]
operator|=
literal|'#'
expr_stmt|;
name|memcpy
argument_list|(
name|sym
operator|+
literal|1
argument_list|,
name|NODE_NAME
argument_list|(
name|predicate
operator|->
name|val
operator|.
name|node
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|result
operator|=
name|cpp_lookup
argument_list|(
name|pfile
argument_list|,
name|sym
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|pfile
operator|->
name|state
operator|.
name|prevent_expansion
operator|--
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Returns a pointer to the pointer to CANDIDATE in the answer chain,    or a pointer to NULL if the answer is not in the chain.  */
end_comment

begin_function
specifier|static
name|struct
name|answer
modifier|*
modifier|*
name|find_answer
parameter_list|(
name|node
parameter_list|,
name|candidate
parameter_list|)
name|cpp_hashnode
modifier|*
name|node
decl_stmt|;
specifier|const
name|struct
name|answer
modifier|*
name|candidate
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|struct
name|answer
modifier|*
modifier|*
name|result
decl_stmt|;
for|for
control|(
name|result
operator|=
operator|&
name|node
operator|->
name|value
operator|.
name|answers
init|;
operator|*
name|result
condition|;
name|result
operator|=
operator|&
operator|(
operator|*
name|result
operator|)
operator|->
name|next
control|)
block|{
name|struct
name|answer
modifier|*
name|answer
init|=
operator|*
name|result
decl_stmt|;
if|if
condition|(
name|answer
operator|->
name|count
operator|==
name|candidate
operator|->
name|count
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|answer
operator|->
name|count
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|_cpp_equiv_tokens
argument_list|(
operator|&
name|answer
operator|->
name|first
index|[
name|i
index|]
argument_list|,
operator|&
name|candidate
operator|->
name|first
index|[
name|i
index|]
argument_list|)
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|answer
operator|->
name|count
condition|)
break|break;
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Test an assertion within a preprocessor conditional.  Returns    non-zero on failure, zero on success.  On success, the result of    the test is written into VALUE.  */
end_comment

begin_function
name|int
name|_cpp_test_assertion
parameter_list|(
name|pfile
parameter_list|,
name|value
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|int
modifier|*
name|value
decl_stmt|;
block|{
name|struct
name|answer
modifier|*
name|answer
decl_stmt|;
name|cpp_hashnode
modifier|*
name|node
decl_stmt|;
name|node
operator|=
name|parse_assertion
argument_list|(
name|pfile
argument_list|,
operator|&
name|answer
argument_list|,
name|T_IF
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
condition|)
operator|*
name|value
operator|=
operator|(
name|node
operator|->
name|type
operator|==
name|NT_ASSERTION
operator|&&
operator|(
name|answer
operator|==
literal|0
operator|||
operator|*
name|find_answer
argument_list|(
name|node
argument_list|,
name|answer
argument_list|)
operator|!=
literal|0
operator|)
operator|)
expr_stmt|;
comment|/* We don't commit the memory for the answer - it's temporary only.  */
return|return
name|node
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Handle #assert.  */
end_comment

begin_function
specifier|static
name|void
name|do_assert
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|struct
name|answer
modifier|*
name|new_answer
decl_stmt|;
name|cpp_hashnode
modifier|*
name|node
decl_stmt|;
name|node
operator|=
name|parse_assertion
argument_list|(
name|pfile
argument_list|,
operator|&
name|new_answer
argument_list|,
name|T_ASSERT
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
condition|)
block|{
comment|/* Place the new answer in the answer list.  First check there          is not a duplicate.  */
name|new_answer
operator|->
name|next
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|type
operator|==
name|NT_ASSERTION
condition|)
block|{
if|if
condition|(
operator|*
name|find_answer
argument_list|(
name|node
argument_list|,
name|new_answer
argument_list|)
condition|)
block|{
name|cpp_warning
argument_list|(
name|pfile
argument_list|,
literal|"\"%s\" re-asserted"
argument_list|,
name|NODE_NAME
argument_list|(
name|node
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|new_answer
operator|->
name|next
operator|=
name|node
operator|->
name|value
operator|.
name|answers
expr_stmt|;
block|}
name|node
operator|->
name|type
operator|=
name|NT_ASSERTION
expr_stmt|;
name|node
operator|->
name|value
operator|.
name|answers
operator|=
name|new_answer
expr_stmt|;
name|BUFF_FRONT
argument_list|(
name|pfile
operator|->
name|a_buff
argument_list|)
operator|+=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|answer
argument_list|)
operator|+
operator|(
name|new_answer
operator|->
name|count
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|cpp_token
argument_list|)
operator|)
expr_stmt|;
name|check_eol
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Handle #unassert.  */
end_comment

begin_function
specifier|static
name|void
name|do_unassert
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|cpp_hashnode
modifier|*
name|node
decl_stmt|;
name|struct
name|answer
modifier|*
name|answer
decl_stmt|;
name|node
operator|=
name|parse_assertion
argument_list|(
name|pfile
argument_list|,
operator|&
name|answer
argument_list|,
name|T_UNASSERT
argument_list|)
expr_stmt|;
comment|/* It isn't an error to #unassert something that isn't asserted.  */
if|if
condition|(
name|node
operator|&&
name|node
operator|->
name|type
operator|==
name|NT_ASSERTION
condition|)
block|{
if|if
condition|(
name|answer
condition|)
block|{
name|struct
name|answer
modifier|*
modifier|*
name|p
init|=
name|find_answer
argument_list|(
name|node
argument_list|,
name|answer
argument_list|)
decl_stmt|,
modifier|*
name|temp
decl_stmt|;
comment|/* Remove the answer from the list.  */
name|temp
operator|=
operator|*
name|p
expr_stmt|;
if|if
condition|(
name|temp
condition|)
operator|*
name|p
operator|=
name|temp
operator|->
name|next
expr_stmt|;
comment|/* Did we free the last answer?  */
if|if
condition|(
name|node
operator|->
name|value
operator|.
name|answers
operator|==
literal|0
condition|)
name|node
operator|->
name|type
operator|=
name|NT_VOID
expr_stmt|;
name|check_eol
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
else|else
name|_cpp_free_definition
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
comment|/* We don't commit the memory for the answer - it's temporary only.  */
block|}
end_function

begin_comment
comment|/* These are for -D, -U, -A.  */
end_comment

begin_comment
comment|/* Process the string STR as if it appeared as the body of a #define.    If STR is just an identifier, define it with value 1.    If STR has anything after the identifier, then it should    be identifier=definition.  */
end_comment

begin_function
name|void
name|cpp_define
parameter_list|(
name|pfile
parameter_list|,
name|str
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|size_t
name|count
decl_stmt|;
comment|/* Copy the entire option so we can modify it.       Change the first "=" in the string to a space.  If there is none,      tack " 1" on the end.  */
name|count
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|count
operator|+
literal|3
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
name|str
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|str
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|buf
index|[
name|p
operator|-
name|str
index|]
operator|=
literal|' '
expr_stmt|;
else|else
block|{
name|buf
index|[
name|count
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
name|buf
index|[
name|count
operator|++
index|]
operator|=
literal|'1'
expr_stmt|;
block|}
name|buf
index|[
name|count
index|]
operator|=
literal|'\0'
expr_stmt|;
name|run_directive
argument_list|(
name|pfile
argument_list|,
name|T_DEFINE
argument_list|,
name|buf
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Slight variant of the above for use by initialize_builtins.  */
end_comment

begin_function
name|void
name|_cpp_define_builtin
parameter_list|(
name|pfile
parameter_list|,
name|str
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|run_directive
argument_list|(
name|pfile
argument_list|,
name|T_DEFINE
argument_list|,
name|str
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Process MACRO as if it appeared as the body of an #undef.  */
end_comment

begin_function
name|void
name|cpp_undef
parameter_list|(
name|pfile
parameter_list|,
name|macro
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
specifier|const
name|char
modifier|*
name|macro
decl_stmt|;
block|{
name|run_directive
argument_list|(
name|pfile
argument_list|,
name|T_UNDEF
argument_list|,
name|macro
argument_list|,
name|strlen
argument_list|(
name|macro
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Process the string STR as if it appeared as the body of a #assert.  */
end_comment

begin_function
name|void
name|cpp_assert
parameter_list|(
name|pfile
parameter_list|,
name|str
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|handle_assertion
argument_list|(
name|pfile
argument_list|,
name|str
argument_list|,
name|T_ASSERT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Process STR as if it appeared as the body of an #unassert.  */
end_comment

begin_function
name|void
name|cpp_unassert
parameter_list|(
name|pfile
parameter_list|,
name|str
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|handle_assertion
argument_list|(
name|pfile
argument_list|,
name|str
argument_list|,
name|T_UNASSERT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Common code for cpp_assert (-A) and cpp_unassert (-A-).  */
end_comment

begin_function
specifier|static
name|void
name|handle_assertion
parameter_list|(
name|pfile
parameter_list|,
name|str
parameter_list|,
name|type
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|type
decl_stmt|;
block|{
name|size_t
name|count
init|=
name|strlen
argument_list|(
name|str
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
init|=
name|strchr
argument_list|(
name|str
argument_list|,
literal|'='
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
condition|)
block|{
comment|/* Copy the entire option so we can modify it.  Change the first 	 "=" in the string to a '(', and tack a ')' on the end.  */
name|char
modifier|*
name|buf
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|count
operator|+
literal|2
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
name|str
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|buf
index|[
name|p
operator|-
name|str
index|]
operator|=
literal|'('
expr_stmt|;
name|buf
index|[
name|count
operator|++
index|]
operator|=
literal|')'
expr_stmt|;
name|buf
index|[
name|count
index|]
operator|=
literal|'\0'
expr_stmt|;
name|str
operator|=
name|buf
expr_stmt|;
block|}
name|run_directive
argument_list|(
name|pfile
argument_list|,
name|type
argument_list|,
name|str
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The number of errors for a given reader.  */
end_comment

begin_function
name|unsigned
name|int
name|cpp_errors
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
return|return
name|pfile
operator|->
name|errors
return|;
block|}
end_function

begin_comment
comment|/* The options structure.  */
end_comment

begin_function
name|cpp_options
modifier|*
name|cpp_get_options
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
return|return
operator|&
name|pfile
operator|->
name|opts
return|;
block|}
end_function

begin_comment
comment|/* The callbacks structure.  */
end_comment

begin_function
name|cpp_callbacks
modifier|*
name|cpp_get_callbacks
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
return|return
operator|&
name|pfile
operator|->
name|cb
return|;
block|}
end_function

begin_comment
comment|/* The line map set.  */
end_comment

begin_function
specifier|const
name|struct
name|line_maps
modifier|*
name|cpp_get_line_maps
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
return|return
operator|&
name|pfile
operator|->
name|line_maps
return|;
block|}
end_function

begin_comment
comment|/* Copy the given callbacks structure to our own.  */
end_comment

begin_function
name|void
name|cpp_set_callbacks
parameter_list|(
name|pfile
parameter_list|,
name|cb
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|cpp_callbacks
modifier|*
name|cb
decl_stmt|;
block|{
name|pfile
operator|->
name|cb
operator|=
operator|*
name|cb
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Push a new buffer on the buffer stack.  Returns the new buffer; it    doesn't fail.  It does not generate a file change call back; that    is the responsibility of the caller.  */
end_comment

begin_function
name|cpp_buffer
modifier|*
name|cpp_push_buffer
parameter_list|(
name|pfile
parameter_list|,
name|buffer
parameter_list|,
name|len
parameter_list|,
name|from_stage3
parameter_list|,
name|return_at_eof
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
specifier|const
name|U_CHAR
modifier|*
name|buffer
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|from_stage3
decl_stmt|;
name|int
name|return_at_eof
decl_stmt|;
block|{
name|cpp_buffer
modifier|*
name|new
init|=
name|xobnew
argument_list|(
operator|&
name|pfile
operator|->
name|buffer_ob
argument_list|,
name|cpp_buffer
argument_list|)
decl_stmt|;
comment|/* Clears, amongst other things, if_stack and mi_cmacro.  */
name|memset
argument_list|(
name|new
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cpp_buffer
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|line_base
operator|=
name|new
operator|->
name|buf
operator|=
name|new
operator|->
name|cur
operator|=
name|buffer
expr_stmt|;
name|new
operator|->
name|rlimit
operator|=
name|buffer
operator|+
name|len
expr_stmt|;
name|new
operator|->
name|from_stage3
operator|=
name|from_stage3
expr_stmt|;
name|new
operator|->
name|prev
operator|=
name|pfile
operator|->
name|buffer
expr_stmt|;
name|new
operator|->
name|return_at_eof
operator|=
name|return_at_eof
expr_stmt|;
name|new
operator|->
name|saved_flags
operator|=
name|BOL
expr_stmt|;
name|pfile
operator|->
name|buffer
operator|=
name|new
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_comment
comment|/* If called from do_line, pops a single buffer.  Otherwise pops all    buffers until a real file is reached.  Generates appropriate    call-backs.  */
end_comment

begin_function
name|void
name|_cpp_pop_buffer
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|cpp_buffer
modifier|*
name|buffer
init|=
name|pfile
operator|->
name|buffer
decl_stmt|;
name|struct
name|if_stack
modifier|*
name|ifs
decl_stmt|;
name|bool
name|pushed
init|=
name|false
decl_stmt|;
comment|/* Walk back up the conditional stack till we reach its level at      entry to this file, issuing error messages.  */
for|for
control|(
name|ifs
operator|=
name|buffer
operator|->
name|if_stack
init|;
name|ifs
condition|;
name|ifs
operator|=
name|ifs
operator|->
name|next
control|)
name|cpp_error_with_line
argument_list|(
name|pfile
argument_list|,
name|ifs
operator|->
name|line
argument_list|,
literal|0
argument_list|,
literal|"unterminated #%s"
argument_list|,
name|dtable
index|[
name|ifs
operator|->
name|type
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
comment|/* In case of a missing #endif.  */
name|pfile
operator|->
name|state
operator|.
name|skipping
operator|=
literal|0
expr_stmt|;
comment|/* Update the reader's buffer before _cpp_do_file_change.  */
name|pfile
operator|->
name|buffer
operator|=
name|buffer
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|buffer
operator|->
name|inc
condition|)
name|pushed
operator|=
name|_cpp_pop_file_buffer
argument_list|(
name|pfile
argument_list|,
name|buffer
operator|->
name|inc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pushed
condition|)
name|obstack_free
argument_list|(
operator|&
name|pfile
operator|->
name|buffer_ob
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Enter all recognised directives in the hash table.  */
end_comment

begin_function
name|void
name|_cpp_init_directives
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|cpp_hashnode
modifier|*
name|node
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|unsigned
name|int
operator|)
name|N_DIRECTIVES
condition|;
name|i
operator|++
control|)
block|{
name|node
operator|=
name|cpp_lookup
argument_list|(
name|pfile
argument_list|,
name|dtable
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|dtable
index|[
name|i
index|]
operator|.
name|length
argument_list|)
expr_stmt|;
name|node
operator|->
name|directive_index
operator|=
name|i
operator|+
literal|1
expr_stmt|;
block|}
block|}
end_function

end_unit

