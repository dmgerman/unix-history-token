begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* CPP Library.    Copyright (C) 1986, 87, 89, 92-97, 1998 Free Software Foundation, Inc.    Contributed by Per Bothner, 1994-95.    Based on CCCP program by Paul Rubin, June 1986    Adapted to ANSI C, Richard Stallman, Jan 1987  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|STDC_VALUE
end_ifndef

begin_define
define|#
directive|define
name|STDC_VALUE
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_TIMES_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/times.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_RESOURCE_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"gansidecl.h"
end_include

begin_include
include|#
directive|include
file|"cpplib.h"
end_include

begin_include
include|#
directive|include
file|"cpphash.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|GET_ENVIRONMENT
end_ifndef

begin_define
define|#
directive|define
name|GET_ENVIRONMENT
parameter_list|(
name|ENV_VALUE
parameter_list|,
name|ENV_NAME
parameter_list|)
value|ENV_VALUE = getenv (ENV_NAME)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|update_path
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|MIN
end_undef

begin_undef
undef|#
directive|undef
name|MAX
end_undef

begin_define
define|#
directive|define
name|MIN
parameter_list|(
name|X
parameter_list|,
name|Y
parameter_list|)
value|((X)< (Y) ? (X) : (Y))
end_define

begin_define
define|#
directive|define
name|MAX
parameter_list|(
name|X
parameter_list|,
name|Y
parameter_list|)
value|((X)> (Y) ? (X) : (Y))
end_define

begin_comment
comment|/* Find the largest host integer type and set its size and type.    Watch out: on some crazy hosts `long' is shorter than `int'.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HOST_WIDE_INT
end_ifndef

begin_if
if|#
directive|if
name|HAVE_INTTYPES_H
end_if

begin_include
include|#
directive|include
file|<inttypes.h>
end_include

begin_define
define|#
directive|define
name|HOST_WIDE_INT
value|intmax_t
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
operator|(
name|HOST_BITS_PER_LONG
operator|<=
name|HOST_BITS_PER_INT
expr|\
operator|&&
name|HOST_BITS_PER_LONGLONG
operator|<=
name|HOST_BITS_PER_INT
operator|)
end_if

begin_define
define|#
directive|define
name|HOST_WIDE_INT
value|int
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
operator|(
name|HOST_BITS_PER_LONGLONG
operator|<=
name|HOST_BITS_PER_LONG
expr|\
operator|||
operator|!
operator|(
name|defined
name|LONG_LONG_MAX
operator|||
name|defined
name|LLONG_MAX
operator|)
operator|)
end_if

begin_define
define|#
directive|define
name|HOST_WIDE_INT
value|long
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|HOST_WIDE_INT
value|long long
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|S_ISREG
end_ifndef

begin_define
define|#
directive|define
name|S_ISREG
parameter_list|(
name|m
parameter_list|)
value|(((m)& S_IFMT) == S_IFREG)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|S_ISDIR
end_ifndef

begin_define
define|#
directive|define
name|S_ISDIR
parameter_list|(
name|m
parameter_list|)
value|(((m)& S_IFMT) == S_IFDIR)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* By default, colon separates directories in a path.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PATH_SEPARATOR
end_ifndef

begin_define
define|#
directive|define
name|PATH_SEPARATOR
value|':'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|STANDARD_INCLUDE_DIR
end_ifndef

begin_define
define|#
directive|define
name|STANDARD_INCLUDE_DIR
value|"/usr/include"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|INCLUDE_LEN_FUDGE
end_ifndef

begin_define
define|#
directive|define
name|INCLUDE_LEN_FUDGE
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Symbols to predefine.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CPP_PREDEFINES
end_ifdef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|predefs
init|=
name|CPP_PREDEFINES
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|char
modifier|*
name|predefs
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* We let tm.h override the types used here, to handle trivial differences    such as the choice of unsigned int or long unsigned int for size_t.    When machines start needing nontrivial differences in the size type,    it would be best to do something here to figure out automatically    from other information what type to use.  */
end_comment

begin_comment
comment|/* The string value for __SIZE_TYPE__.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SIZE_TYPE
end_ifndef

begin_define
define|#
directive|define
name|SIZE_TYPE
value|"long unsigned int"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The string value for __PTRDIFF_TYPE__.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PTRDIFF_TYPE
end_ifndef

begin_define
define|#
directive|define
name|PTRDIFF_TYPE
value|"long int"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The string value for __WCHAR_TYPE__.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|WCHAR_TYPE
end_ifndef

begin_define
define|#
directive|define
name|WCHAR_TYPE
value|"int"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CPP_WCHAR_TYPE
parameter_list|(
name|PFILE
parameter_list|)
define|\
value|(CPP_OPTIONS (PFILE)->cplusplus ? "__wchar_t" : WCHAR_TYPE)
end_define

begin_comment
comment|/* The string value for __USER_LABEL_PREFIX__ */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|USER_LABEL_PREFIX
end_ifndef

begin_define
define|#
directive|define
name|USER_LABEL_PREFIX
value|""
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The string value for __REGISTER_PREFIX__ */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|REGISTER_PREFIX
end_ifndef

begin_define
define|#
directive|define
name|REGISTER_PREFIX
value|""
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* In the definition of a #assert name, this structure forms    a list of the individual values asserted.    Each value is itself a list of "tokens".    These are strings that are compared by name.  */
end_comment

begin_struct
struct|struct
name|tokenlist_list
block|{
name|struct
name|tokenlist_list
modifier|*
name|next
decl_stmt|;
name|struct
name|arglist
modifier|*
name|tokens
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|assertion_hashnode
block|{
name|struct
name|assertion_hashnode
modifier|*
name|next
decl_stmt|;
comment|/* double links for easy deletion */
name|struct
name|assertion_hashnode
modifier|*
name|prev
decl_stmt|;
comment|/* also, a back pointer to this node's hash      chain is kept, in case the node is the head      of the chain and gets deleted.  */
name|struct
name|assertion_hashnode
modifier|*
modifier|*
name|bucket_hdr
decl_stmt|;
name|int
name|length
decl_stmt|;
comment|/* length of token, for quick comparison */
name|U_CHAR
modifier|*
name|name
decl_stmt|;
comment|/* the actual name */
comment|/* List of token-sequences.  */
name|struct
name|tokenlist_list
modifier|*
name|value
decl_stmt|;
block|}
struct|;
end_struct

begin_escape
end_escape

begin_define
define|#
directive|define
name|SKIP_WHITE_SPACE
parameter_list|(
name|p
parameter_list|)
value|do { while (is_hor_space[*p]) p++; } while (0)
end_define

begin_define
define|#
directive|define
name|SKIP_ALL_WHITE_SPACE
parameter_list|(
name|p
parameter_list|)
value|do { while (is_space[*p]) p++; } while (0)
end_define

begin_define
define|#
directive|define
name|PEEKN
parameter_list|(
name|N
parameter_list|)
value|(CPP_BUFFER (pfile)->rlimit - CPP_BUFFER (pfile)->cur>= (N) ? CPP_BUFFER (pfile)->cur[N] : EOF)
end_define

begin_define
define|#
directive|define
name|FORWARD
parameter_list|(
name|N
parameter_list|)
value|CPP_FORWARD (CPP_BUFFER (pfile), (N))
end_define

begin_define
define|#
directive|define
name|GETC
parameter_list|()
value|CPP_BUF_GET (CPP_BUFFER (pfile))
end_define

begin_define
define|#
directive|define
name|PEEKC
parameter_list|()
value|CPP_BUF_PEEK (CPP_BUFFER (pfile))
end_define

begin_comment
comment|/* CPP_IS_MACRO_BUFFER is true if the buffer contains macro expansion.    (Note that it is false while we're expanding marco *arguments*.) */
end_comment

begin_define
define|#
directive|define
name|CPP_IS_MACRO_BUFFER
parameter_list|(
name|PBUF
parameter_list|)
value|((PBUF)->cleanup == macro_cleanup)
end_define

begin_comment
comment|/* Move all backslash-newline pairs out of embarrassing places.    Exchange all such pairs following BP    with any potentially-embarrassing characters that follow them.    Potentially-embarrassing characters are / and *    (because a backslash-newline inside a comment delimiter    would cause it not to be recognized).  */
end_comment

begin_define
define|#
directive|define
name|NEWLINE_FIX
define|\
value|do {while (PEEKC() == '\\'&& PEEKN(1) == '\n') FORWARD(2); } while(0)
end_define

begin_comment
comment|/* Same, but assume we've already read the potential '\\' into C.  */
end_comment

begin_define
define|#
directive|define
name|NEWLINE_FIX1
parameter_list|(
name|C
parameter_list|)
value|do { \     while ((C) == '\\'&& PEEKC() == '\n') { FORWARD(1); (C) = GETC(); }\   } while(0)
end_define

begin_struct
struct|struct
name|cpp_pending
block|{
name|struct
name|cpp_pending
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|cmd
decl_stmt|;
name|char
modifier|*
name|arg
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Forward declarations.  */
end_comment

begin_function_decl
name|char
modifier|*
name|xmalloc
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|void
name|cpp_hash_cleanup
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|my_strerror
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_import
name|PROTO
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|int
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|append_include_chain
name|PROTO
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
expr|struct
name|file_name_list
operator|*
operator|,
expr|struct
name|file_name_list
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|make_assertion
name|PROTO
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|char
operator|*
operator|,
name|U_CHAR
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|path_include
name|PROTO
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|initialize_builtins
name|PROTO
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|initialize_char_syntax
name|PROTO
argument_list|(
operator|(
expr|struct
name|cpp_options
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void trigraph_pcp ();
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|finclude
name|PROTO
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|int
operator|,
name|char
operator|*
operator|,
name|int
operator|,
expr|struct
name|file_name_list
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|validate_else
name|PROTO
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|comp_def_part
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|U_CHAR
operator|*
operator|,
name|int
operator|,
name|U_CHAR
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|abort
end_ifdef

begin_function_decl
specifier|extern
name|void
name|fancy_abort
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|lookup_import
name|PROTO
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|char
operator|*
operator|,
expr|struct
name|file_name_list
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|redundant_include_p
name|PROTO
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_system_include
name|PROTO
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|file_name_map
modifier|*
name|read_name_map
name|PROTO
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|read_filename_string
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|open_include_file
name|PROTO
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|char
operator|*
operator|,
expr|struct
name|file_name_list
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|check_macro_name
name|PROTO
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|U_CHAR
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|compare_defs
name|PROTO
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|DEFINITION
operator|*
operator|,
name|DEFINITION
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|compare_token_lists
name|PROTO
argument_list|(
operator|(
expr|struct
name|arglist
operator|*
operator|,
expr|struct
name|arglist
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|HOST_WIDE_INT
name|eval_if_expression
name|PROTO
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|U_CHAR
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|change_newlines
name|PROTO
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|arglist
modifier|*
name|read_token_list
name|PROTO
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_token_list
name|PROTO
argument_list|(
operator|(
expr|struct
name|arglist
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|safe_read
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|push_macro_expansion
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|U_CHAR
operator|*
operator|,
name|int
operator|,
name|HASHNODE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cpp_pending
modifier|*
name|nreverse_pending
name|PARAMS
argument_list|(
operator|(
expr|struct
name|cpp_pending
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|char
modifier|*
name|xrealloc
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|char
modifier|*
name|xcalloc
name|PROTO
argument_list|(
operator|(
name|unsigned
operator|,
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|savestring
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|conditional_skip
name|PROTO
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|int
operator|,
expr|enum
name|node_type
operator|,
name|U_CHAR
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|skip_if_group
name|PROTO
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|parse_name
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_help
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last arg to output_line_command.  */
end_comment

begin_enum
enum|enum
name|file_change_code
block|{
name|same_file
block|,
name|enter_file
block|,
name|leave_file
block|}
enum|;
end_enum

begin_comment
comment|/* External declarations.  */
end_comment

begin_decl_stmt
specifier|extern
name|HOST_WIDE_INT
name|cpp_parse_expr
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|version_string
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|struct
name|tm
modifier|*
name|localtime
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_struct
struct|struct
name|file_name_list
block|{
name|struct
name|file_name_list
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
comment|/* If the following is nonzero, it is a macro name.        Don't include the file again if that macro is defined.  */
name|U_CHAR
modifier|*
name|control_macro
decl_stmt|;
comment|/* If the following is nonzero, it is a C-language system include        directory.  */
name|int
name|c_system_include_path
decl_stmt|;
comment|/* Mapping of file names for this directory.  */
name|struct
name|file_name_map
modifier|*
name|name_map
decl_stmt|;
comment|/* Non-zero if name_map is valid.  */
name|int
name|got_name_map
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* If a buffer's dir field is SELF_DIR_DUMMY, it means the file was found    via the same directory as the file that #included it.  */
end_comment

begin_define
define|#
directive|define
name|SELF_DIR_DUMMY
value|((struct file_name_list *) (~0))
end_define

begin_comment
comment|/* #include "file" looks in source file dir, then stack.  */
end_comment

begin_comment
comment|/* #include<file> just looks in the stack.  */
end_comment

begin_comment
comment|/* -I directories are added to the end, then the defaults are added.  */
end_comment

begin_comment
comment|/* The */
end_comment

begin_struct
specifier|static
struct|struct
name|default_include
block|{
name|char
modifier|*
name|fname
decl_stmt|;
comment|/* The name of the directory.  */
name|char
modifier|*
name|component
decl_stmt|;
comment|/* The component containing the directory */
name|int
name|cplusplus
decl_stmt|;
comment|/* Only look here if we're compiling C++.  */
name|int
name|cxx_aware
decl_stmt|;
comment|/* Includes in this directory don't need to 				   be wrapped in extern "C" when compiling 				   C++.  */
block|}
name|include_defaults_array
index|[]
ifdef|#
directive|ifdef
name|INCLUDE_DEFAULTS
init|=
name|INCLUDE_DEFAULTS
struct|;
end_struct

begin_else
else|#
directive|else
end_else

begin_expr_stmt
operator|=
block|{
comment|/* Pick up GNU C++ specific include files.  */
block|{
name|GPLUSPLUS_INCLUDE_DIR
block|,
literal|"G++"
block|,
literal|1
block|,
literal|1
block|}
block|,
block|{
name|OLD_GPLUSPLUS_INCLUDE_DIR
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|}
block|,
ifdef|#
directive|ifdef
name|CROSS_COMPILE
comment|/* This is the dir for fixincludes.  Put it just before        the files that we fix.  */
block|{
name|GCC_INCLUDE_DIR
block|,
literal|"GCC"
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* For cross-compilation, this dir name is generated        automatically in Makefile.in.  */
block|{
name|CROSS_INCLUDE_DIR
block|,
literal|"GCC"
block|,
literal|0
block|,
literal|0
block|}
block|,
ifdef|#
directive|ifdef
name|TOOL_INCLUDE_DIR
comment|/* This is another place that the target system's headers might be.  */
block|{
name|TOOL_INCLUDE_DIR
block|,
literal|"BINUTILS"
block|,
literal|0
block|,
literal|1
block|}
block|,
endif|#
directive|endif
else|#
directive|else
comment|/* not CROSS_COMPILE */
ifdef|#
directive|ifdef
name|LOCAL_INCLUDE_DIR
comment|/* This should be /usr/local/include and should come before        the fixincludes-fixed header files.  */
block|{
name|LOCAL_INCLUDE_DIR
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TOOL_INCLUDE_DIR
comment|/* This is here ahead of GCC_INCLUDE_DIR because assert.h goes here.        Likewise, behind LOCAL_INCLUDE_DIR, where glibc puts its assert.h.  */
block|{
name|TOOL_INCLUDE_DIR
block|,
literal|"BINUTILS"
block|,
literal|0
block|,
literal|1
block|}
block|,
endif|#
directive|endif
comment|/* This is the dir for fixincludes.  Put it just before        the files that we fix.  */
block|{
name|GCC_INCLUDE_DIR
block|,
literal|"GCC"
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Some systems have an extra dir of include files.  */
ifdef|#
directive|ifdef
name|SYSTEM_INCLUDE_DIR
block|{
name|SYSTEM_INCLUDE_DIR
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
endif|#
directive|endif
ifndef|#
directive|ifndef
name|STANDARD_INCLUDE_COMPONENT
define|#
directive|define
name|STANDARD_INCLUDE_COMPONENT
value|0
endif|#
directive|endif
block|{
name|STANDARD_INCLUDE_DIR
block|,
name|STANDARD_INCLUDE_COMPONENT
block|,
literal|0
block|,
literal|0
block|}
block|,
endif|#
directive|endif
comment|/* not CROSS_COMPILE */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* no INCLUDE_DEFAULTS */
end_comment

begin_comment
comment|/* `struct directive' defines one #-directive, including how to handle it.  */
end_comment

begin_struct
struct|struct
name|directive
block|{
name|int
name|length
decl_stmt|;
comment|/* Length of name */
name|int
argument_list|(
argument|*func
argument_list|)
comment|/* Function to handle directive */
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
expr|struct
name|directive
operator|*
operator|,
name|U_CHAR
operator|*
operator|,
name|U_CHAR
operator|*
operator|)
argument_list|)
expr_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Name of directive */
name|enum
name|node_type
name|type
decl_stmt|;
comment|/* Code which describes which directive.  */
name|char
name|command_reads_line
decl_stmt|;
comment|/* One if rest of line is read by func.  */
block|}
struct|;
end_struct

begin_comment
comment|/* These functions are declared to return int instead of void since they    are going to be placed in a table and some old compilers have trouble with    pointers to functions returning void.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|do_define
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
expr|struct
name|directive
operator|*
operator|,
name|U_CHAR
operator|*
operator|,
name|U_CHAR
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_line
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
expr|struct
name|directive
operator|*
operator|,
name|U_CHAR
operator|*
operator|,
name|U_CHAR
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_include
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
expr|struct
name|directive
operator|*
operator|,
name|U_CHAR
operator|*
operator|,
name|U_CHAR
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_undef
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
expr|struct
name|directive
operator|*
operator|,
name|U_CHAR
operator|*
operator|,
name|U_CHAR
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_error
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
expr|struct
name|directive
operator|*
operator|,
name|U_CHAR
operator|*
operator|,
name|U_CHAR
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_pragma
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
expr|struct
name|directive
operator|*
operator|,
name|U_CHAR
operator|*
operator|,
name|U_CHAR
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_ident
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
expr|struct
name|directive
operator|*
operator|,
name|U_CHAR
operator|*
operator|,
name|U_CHAR
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_if
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
expr|struct
name|directive
operator|*
operator|,
name|U_CHAR
operator|*
operator|,
name|U_CHAR
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_xifdef
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
expr|struct
name|directive
operator|*
operator|,
name|U_CHAR
operator|*
operator|,
name|U_CHAR
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_else
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
expr|struct
name|directive
operator|*
operator|,
name|U_CHAR
operator|*
operator|,
name|U_CHAR
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_elif
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
expr|struct
name|directive
operator|*
operator|,
name|U_CHAR
operator|*
operator|,
name|U_CHAR
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_endif
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
expr|struct
name|directive
operator|*
operator|,
name|U_CHAR
operator|*
operator|,
name|U_CHAR
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SCCS_DIRECTIVE
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|do_sccs
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
expr|struct
name|directive
operator|*
operator|,
name|U_CHAR
operator|*
operator|,
name|U_CHAR
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|do_once
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
expr|struct
name|directive
operator|*
operator|,
name|U_CHAR
operator|*
operator|,
name|U_CHAR
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_assert
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
expr|struct
name|directive
operator|*
operator|,
name|U_CHAR
operator|*
operator|,
name|U_CHAR
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_unassert
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
expr|struct
name|directive
operator|*
operator|,
name|U_CHAR
operator|*
operator|,
name|U_CHAR
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_warning
name|PARAMS
argument_list|(
operator|(
name|cpp_reader
operator|*
operator|,
expr|struct
name|directive
operator|*
operator|,
name|U_CHAR
operator|*
operator|,
name|U_CHAR
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|IS_INCLUDE_DIRECTIVE_TYPE
parameter_list|(
name|t
parameter_list|)
define|\
value|((int) T_INCLUDE<= (int) (t)&& (int) (t)<= (int) T_IMPORT)
end_define

begin_comment
comment|/* Here is the actual list of #-directives, most-often-used first.    The initialize_builtins function assumes #define is the very first.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|directive
name|directive_table
index|[]
init|=
block|{
block|{
literal|6
block|,
name|do_define
block|,
literal|"define"
block|,
name|T_DEFINE
block|}
block|,
block|{
literal|5
block|,
name|do_xifdef
block|,
literal|"ifdef"
block|,
name|T_IFDEF
block|,
literal|1
block|}
block|,
block|{
literal|6
block|,
name|do_xifdef
block|,
literal|"ifndef"
block|,
name|T_IFNDEF
block|,
literal|1
block|}
block|,
block|{
literal|7
block|,
name|do_include
block|,
literal|"include"
block|,
name|T_INCLUDE
block|,
literal|1
block|}
block|,
block|{
literal|12
block|,
name|do_include
block|,
literal|"include_next"
block|,
name|T_INCLUDE_NEXT
block|,
literal|1
block|}
block|,
block|{
literal|6
block|,
name|do_include
block|,
literal|"import"
block|,
name|T_IMPORT
block|,
literal|1
block|}
block|,
block|{
literal|5
block|,
name|do_endif
block|,
literal|"endif"
block|,
name|T_ENDIF
block|,
literal|1
block|}
block|,
block|{
literal|4
block|,
name|do_else
block|,
literal|"else"
block|,
name|T_ELSE
block|,
literal|1
block|}
block|,
block|{
literal|2
block|,
name|do_if
block|,
literal|"if"
block|,
name|T_IF
block|,
literal|1
block|}
block|,
block|{
literal|4
block|,
name|do_elif
block|,
literal|"elif"
block|,
name|T_ELIF
block|,
literal|1
block|}
block|,
block|{
literal|5
block|,
name|do_undef
block|,
literal|"undef"
block|,
name|T_UNDEF
block|}
block|,
block|{
literal|5
block|,
name|do_error
block|,
literal|"error"
block|,
name|T_ERROR
block|}
block|,
block|{
literal|7
block|,
name|do_warning
block|,
literal|"warning"
block|,
name|T_WARNING
block|}
block|,
block|{
literal|6
block|,
name|do_pragma
block|,
literal|"pragma"
block|,
name|T_PRAGMA
block|}
block|,
block|{
literal|4
block|,
name|do_line
block|,
literal|"line"
block|,
name|T_LINE
block|,
literal|1
block|}
block|,
block|{
literal|5
block|,
name|do_ident
block|,
literal|"ident"
block|,
name|T_IDENT
block|,
literal|1
block|}
block|,
ifdef|#
directive|ifdef
name|SCCS_DIRECTIVE
block|{
literal|4
block|,
name|do_sccs
block|,
literal|"sccs"
block|,
name|T_SCCS
block|}
block|,
endif|#
directive|endif
block|{
literal|6
block|,
name|do_assert
block|,
literal|"assert"
block|,
name|T_ASSERT
block|,
literal|1
block|}
block|,
block|{
literal|8
block|,
name|do_unassert
block|,
literal|"unassert"
block|,
name|T_UNASSERT
block|,
literal|1
block|}
block|,
block|{
operator|-
literal|1
block|,
literal|0
block|,
literal|""
block|,
name|T_UNUSED
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* table to tell if char can be part of a C identifier.  */
end_comment

begin_decl_stmt
name|U_CHAR
name|is_idchar
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* table to tell if char can be first char of a c identifier.  */
end_comment

begin_decl_stmt
name|U_CHAR
name|is_idstart
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* table to tell if c is horizontal space.  */
end_comment

begin_decl_stmt
name|U_CHAR
name|is_hor_space
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* table to tell if c is horizontal or vertical space.  */
end_comment

begin_decl_stmt
specifier|static
name|U_CHAR
name|is_space
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize syntactic classifications of characters.  */
end_comment

begin_function
specifier|static
name|void
name|initialize_char_syntax
parameter_list|(
name|opts
parameter_list|)
name|struct
name|cpp_options
modifier|*
name|opts
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/*    * Set up is_idchar and is_idstart tables.  These should be    * faster than saying (is_alpha (c) || c == '_'), etc.    * Set up these things before calling any routines tthat    * refer to them.    */
for|for
control|(
name|i
operator|=
literal|'a'
init|;
name|i
operator|<=
literal|'z'
condition|;
name|i
operator|++
control|)
block|{
name|is_idchar
index|[
name|i
operator|-
literal|'a'
operator|+
literal|'A'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idchar
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|is_idstart
index|[
name|i
operator|-
literal|'a'
operator|+
literal|'A'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idstart
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|'0'
init|;
name|i
operator|<=
literal|'9'
condition|;
name|i
operator|++
control|)
name|is_idchar
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|is_idchar
index|[
literal|'_'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idstart
index|[
literal|'_'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idchar
index|[
literal|'$'
index|]
operator|=
name|opts
operator|->
name|dollars_in_ident
expr_stmt|;
name|is_idstart
index|[
literal|'$'
index|]
operator|=
name|opts
operator|->
name|dollars_in_ident
expr_stmt|;
comment|/* horizontal space table */
name|is_hor_space
index|[
literal|' '
index|]
operator|=
literal|1
expr_stmt|;
name|is_hor_space
index|[
literal|'\t'
index|]
operator|=
literal|1
expr_stmt|;
name|is_hor_space
index|[
literal|'\v'
index|]
operator|=
literal|1
expr_stmt|;
name|is_hor_space
index|[
literal|'\f'
index|]
operator|=
literal|1
expr_stmt|;
name|is_hor_space
index|[
literal|'\r'
index|]
operator|=
literal|1
expr_stmt|;
name|is_space
index|[
literal|' '
index|]
operator|=
literal|1
expr_stmt|;
name|is_space
index|[
literal|'\t'
index|]
operator|=
literal|1
expr_stmt|;
name|is_space
index|[
literal|'\v'
index|]
operator|=
literal|1
expr_stmt|;
name|is_space
index|[
literal|'\f'
index|]
operator|=
literal|1
expr_stmt|;
name|is_space
index|[
literal|'\n'
index|]
operator|=
literal|1
expr_stmt|;
name|is_space
index|[
literal|'\r'
index|]
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Place into PFILE a quoted string representing the string SRC.    Caller must reserve enough space in pfile->token_buffer.  */
end_comment

begin_function
specifier|static
name|void
name|quote_string
parameter_list|(
name|pfile
parameter_list|,
name|src
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|char
modifier|*
name|src
decl_stmt|;
block|{
name|U_CHAR
name|c
decl_stmt|;
name|CPP_PUTC_Q
argument_list|(
name|pfile
argument_list|,
literal|'\"'
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
switch|switch
condition|(
operator|(
name|c
operator|=
operator|*
name|src
operator|++
operator|)
condition|)
block|{
default|default:
if|if
condition|(
name|ISPRINT
argument_list|(
name|c
argument_list|)
condition|)
name|CPP_PUTC_Q
argument_list|(
name|pfile
argument_list|,
name|c
argument_list|)
expr_stmt|;
else|else
block|{
name|sprintf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|CPP_PWRITTEN
argument_list|(
name|pfile
argument_list|)
argument_list|,
literal|"\\%03o"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|CPP_ADJUST_WRITTEN
argument_list|(
name|pfile
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'\"'
case|:
case|case
literal|'\\'
case|:
name|CPP_PUTC_Q
argument_list|(
name|pfile
argument_list|,
literal|'\\'
argument_list|)
expr_stmt|;
name|CPP_PUTC_Q
argument_list|(
name|pfile
argument_list|,
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\0'
case|:
name|CPP_PUTC_Q
argument_list|(
name|pfile
argument_list|,
literal|'\"'
argument_list|)
expr_stmt|;
name|CPP_NUL_TERMINATE_Q
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_comment
comment|/* Re-allocates PFILE->token_buffer so it will hold at least N more chars.  */
end_comment

begin_function
name|void
name|cpp_grow_buffer
parameter_list|(
name|pfile
parameter_list|,
name|n
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|long
name|n
decl_stmt|;
block|{
name|long
name|old_written
init|=
name|CPP_WRITTEN
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
name|pfile
operator|->
name|token_buffer_size
operator|=
name|n
operator|+
literal|2
operator|*
name|pfile
operator|->
name|token_buffer_size
expr_stmt|;
name|pfile
operator|->
name|token_buffer
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xrealloc
argument_list|(
name|pfile
operator|->
name|token_buffer
argument_list|,
name|pfile
operator|->
name|token_buffer_size
argument_list|)
expr_stmt|;
name|CPP_SET_WRITTEN
argument_list|(
name|pfile
argument_list|,
name|old_written
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * process a given definition string, for initialization  * If STR is just an identifier, define it with value 1.  * If STR has anything after the identifier, then it should  * be identifier=definition.  */
end_comment

begin_function
name|void
name|cpp_define
parameter_list|(
name|pfile
parameter_list|,
name|str
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|U_CHAR
modifier|*
name|str
decl_stmt|;
block|{
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|buf
operator|=
name|str
expr_stmt|;
name|p
operator|=
name|str
expr_stmt|;
if|if
condition|(
operator|!
name|is_idstart
index|[
operator|*
name|p
index|]
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"malformed option `-D %s'"
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|is_idchar
index|[
operator|*
operator|++
name|p
index|]
condition|)
empty_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
block|{
name|buf
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|alloca
argument_list|(
name|p
operator|-
name|buf
operator|+
literal|4
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
literal|" 1"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|!=
literal|'='
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"malformed option `-D %s'"
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|U_CHAR
modifier|*
name|q
decl_stmt|;
comment|/* Copy the entire option so we can modify it.  */
name|buf
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|alloca
argument_list|(
literal|2
operator|*
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|buf
argument_list|,
name|str
argument_list|,
name|p
operator|-
name|str
argument_list|)
expr_stmt|;
comment|/* Change the = to a space.  */
name|buf
index|[
name|p
operator|-
name|str
index|]
operator|=
literal|' '
expr_stmt|;
comment|/* Scan for any backslash-newline and remove it.  */
name|p
operator|++
expr_stmt|;
name|q
operator|=
operator|&
name|buf
index|[
name|p
operator|-
name|str
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\\'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|p
operator|+=
literal|2
expr_stmt|;
else|else
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
operator|*
name|q
operator|=
literal|0
expr_stmt|;
block|}
name|do_define
argument_list|(
name|pfile
argument_list|,
name|NULL
argument_list|,
name|buf
argument_list|,
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Process the string STR as if it appeared as the body of a #assert.    OPTION is the option name for which STR was the argument.  */
end_comment

begin_function
specifier|static
name|void
name|make_assertion
parameter_list|(
name|pfile
parameter_list|,
name|option
parameter_list|,
name|str
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|char
modifier|*
name|option
decl_stmt|;
name|U_CHAR
modifier|*
name|str
decl_stmt|;
block|{
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
comment|/* Copy the entire option so we can modify it.  */
name|buf
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|str
argument_list|)
expr_stmt|;
comment|/* Scan for any backslash-newline and remove it.  */
name|p
operator|=
name|q
operator|=
name|buf
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
if|#
directive|if
literal|0
block|if (*p == '\\'&& p[1] == '\n')       p += 2;     else
endif|#
directive|endif
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
operator|*
name|q
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
if|if
condition|(
operator|!
name|is_idstart
index|[
operator|*
name|p
index|]
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"malformed option `%s %s'"
argument_list|,
name|option
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|is_idchar
index|[
operator|*
operator|++
name|p
index|]
condition|)
empty_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|p
operator|==
literal|0
operator|||
operator|*
name|p
operator|==
literal|'('
operator|)
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"malformed option `%s %s'"
argument_list|,
name|option
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|cpp_push_buffer
argument_list|(
name|pfile
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|do_assert
argument_list|(
name|pfile
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cpp_pop_buffer
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Append a chain of `struct file_name_list's    to the end of the main include chain.    FIRST is the beginning of the chain to append, and LAST is the end.  */
end_comment

begin_function
specifier|static
name|void
name|append_include_chain
parameter_list|(
name|pfile
parameter_list|,
name|first
parameter_list|,
name|last
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|struct
name|file_name_list
modifier|*
name|first
decl_stmt|,
decl|*
name|last
decl_stmt|;
end_function

begin_block
block|{
name|struct
name|cpp_options
modifier|*
name|opts
init|=
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
name|struct
name|file_name_list
modifier|*
name|dir
decl_stmt|;
if|if
condition|(
operator|!
name|first
operator|||
operator|!
name|last
condition|)
return|return;
if|if
condition|(
name|opts
operator|->
name|include
operator|==
literal|0
condition|)
name|opts
operator|->
name|include
operator|=
name|first
expr_stmt|;
else|else
name|opts
operator|->
name|last_include
operator|->
name|next
operator|=
name|first
expr_stmt|;
if|if
condition|(
name|opts
operator|->
name|first_bracket_include
operator|==
literal|0
condition|)
name|opts
operator|->
name|first_bracket_include
operator|=
name|first
expr_stmt|;
for|for
control|(
name|dir
operator|=
name|first
init|;
condition|;
name|dir
operator|=
name|dir
operator|->
name|next
control|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|dir
operator|->
name|fname
argument_list|)
operator|+
name|INCLUDE_LEN_FUDGE
decl_stmt|;
if|if
condition|(
name|len
operator|>
name|pfile
operator|->
name|max_include_len
condition|)
name|pfile
operator|->
name|max_include_len
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|dir
operator|==
name|last
condition|)
break|break;
block|}
name|last
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|opts
operator|->
name|last_include
operator|=
name|last
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Add output to `deps_buffer' for the -M switch.    STRING points to the text to be output.    SPACER is ':' for targets, ' ' for dependencies, zero for text    to be inserted literally.  */
end_comment

begin_function
specifier|static
name|void
name|deps_output
parameter_list|(
name|pfile
parameter_list|,
name|string
parameter_list|,
name|spacer
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|spacer
decl_stmt|;
block|{
name|int
name|size
init|=
name|strlen
argument_list|(
name|string
argument_list|)
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
return|return;
ifndef|#
directive|ifndef
name|MAX_OUTPUT_COLUMNS
define|#
directive|define
name|MAX_OUTPUT_COLUMNS
value|72
endif|#
directive|endif
if|if
condition|(
name|spacer
operator|&&
name|pfile
operator|->
name|deps_column
operator|>
literal|0
operator|&&
operator|(
name|pfile
operator|->
name|deps_column
operator|+
name|size
operator|)
operator|>
name|MAX_OUTPUT_COLUMNS
condition|)
block|{
name|deps_output
argument_list|(
name|pfile
argument_list|,
literal|" \\\n  "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|deps_column
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|pfile
operator|->
name|deps_size
operator|+
name|size
operator|+
literal|8
operator|>
name|pfile
operator|->
name|deps_allocated_size
condition|)
block|{
name|pfile
operator|->
name|deps_allocated_size
operator|=
operator|(
name|pfile
operator|->
name|deps_size
operator|+
name|size
operator|+
literal|50
operator|)
operator|*
literal|2
expr_stmt|;
name|pfile
operator|->
name|deps_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|pfile
operator|->
name|deps_buffer
argument_list|,
name|pfile
operator|->
name|deps_allocated_size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|spacer
operator|==
literal|' '
operator|&&
name|pfile
operator|->
name|deps_column
operator|>
literal|0
condition|)
name|pfile
operator|->
name|deps_buffer
index|[
name|pfile
operator|->
name|deps_size
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
name|bcopy
argument_list|(
name|string
argument_list|,
operator|&
name|pfile
operator|->
name|deps_buffer
index|[
name|pfile
operator|->
name|deps_size
index|]
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|deps_size
operator|+=
name|size
expr_stmt|;
name|pfile
operator|->
name|deps_column
operator|+=
name|size
expr_stmt|;
if|if
condition|(
name|spacer
operator|==
literal|':'
condition|)
name|pfile
operator|->
name|deps_buffer
index|[
name|pfile
operator|->
name|deps_size
operator|++
index|]
operator|=
literal|':'
expr_stmt|;
name|pfile
operator|->
name|deps_buffer
index|[
name|pfile
operator|->
name|deps_size
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a colon-separated list of file names PATH,    add all the names to the search path for include files.  */
end_comment

begin_function
specifier|static
name|void
name|path_include
parameter_list|(
name|pfile
parameter_list|,
name|path
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|path
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
while|while
condition|(
literal|1
condition|)
block|{
name|char
modifier|*
name|q
init|=
name|p
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|file_name_list
modifier|*
name|dirtmp
decl_stmt|;
comment|/* Find the end of this name.  */
while|while
condition|(
operator|*
name|q
operator|!=
literal|0
operator|&&
operator|*
name|q
operator|!=
name|PATH_SEPARATOR
condition|)
name|q
operator|++
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|q
condition|)
block|{
comment|/* An empty name in the path stands for the current directory.  */
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|name
index|[
literal|0
index|]
operator|=
literal|'.'
expr_stmt|;
name|name
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Otherwise use the directory that is named.  */
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|q
operator|-
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|p
argument_list|,
name|name
argument_list|,
name|q
operator|-
name|p
argument_list|)
expr_stmt|;
name|name
index|[
name|q
operator|-
name|p
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|dirtmp
operator|=
operator|(
expr|struct
name|file_name_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|file_name_list
argument_list|)
argument_list|)
expr_stmt|;
name|dirtmp
operator|->
name|next
operator|=
literal|0
expr_stmt|;
comment|/* New one goes on the end */
name|dirtmp
operator|->
name|control_macro
operator|=
literal|0
expr_stmt|;
name|dirtmp
operator|->
name|c_system_include_path
operator|=
literal|0
expr_stmt|;
name|dirtmp
operator|->
name|fname
operator|=
name|name
expr_stmt|;
name|dirtmp
operator|->
name|got_name_map
operator|=
literal|0
expr_stmt|;
name|append_include_chain
argument_list|(
name|pfile
argument_list|,
name|dirtmp
argument_list|,
name|dirtmp
argument_list|)
expr_stmt|;
comment|/* Advance past this name.  */
name|p
operator|=
name|q
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
break|break;
comment|/* Skip the colon.  */
name|p
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|cpp_options_init
parameter_list|(
name|opts
parameter_list|)
name|cpp_options
modifier|*
name|opts
decl_stmt|;
block|{
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|opts
argument_list|,
sizeof|sizeof
expr|*
name|opts
argument_list|)
expr_stmt|;
name|opts
operator|->
name|in_fname
operator|=
name|NULL
expr_stmt|;
name|opts
operator|->
name|out_fname
operator|=
name|NULL
expr_stmt|;
comment|/* Initialize is_idchar to allow $.  */
name|opts
operator|->
name|dollars_in_ident
operator|=
literal|1
expr_stmt|;
name|initialize_char_syntax
argument_list|(
name|opts
argument_list|)
expr_stmt|;
name|opts
operator|->
name|no_line_commands
operator|=
literal|0
expr_stmt|;
name|opts
operator|->
name|no_trigraphs
operator|=
literal|1
expr_stmt|;
name|opts
operator|->
name|put_out_comments
operator|=
literal|0
expr_stmt|;
name|opts
operator|->
name|print_include_names
operator|=
literal|0
expr_stmt|;
name|opts
operator|->
name|dump_macros
operator|=
name|dump_none
expr_stmt|;
name|opts
operator|->
name|no_output
operator|=
literal|0
expr_stmt|;
name|opts
operator|->
name|remap
operator|=
literal|0
expr_stmt|;
name|opts
operator|->
name|cplusplus
operator|=
literal|0
expr_stmt|;
name|opts
operator|->
name|cplusplus_comments
operator|=
literal|1
expr_stmt|;
name|opts
operator|->
name|verbose
operator|=
literal|0
expr_stmt|;
name|opts
operator|->
name|objc
operator|=
literal|0
expr_stmt|;
name|opts
operator|->
name|lang_asm
operator|=
literal|0
expr_stmt|;
name|opts
operator|->
name|for_lint
operator|=
literal|0
expr_stmt|;
name|opts
operator|->
name|chill
operator|=
literal|0
expr_stmt|;
name|opts
operator|->
name|pedantic_errors
operator|=
literal|0
expr_stmt|;
name|opts
operator|->
name|inhibit_warnings
operator|=
literal|0
expr_stmt|;
name|opts
operator|->
name|warn_comments
operator|=
literal|0
expr_stmt|;
name|opts
operator|->
name|warn_import
operator|=
literal|1
expr_stmt|;
name|opts
operator|->
name|warnings_are_errors
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|enum
name|cpp_token
name|null_underflow
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
name|CPP_EOF
return|;
block|}
end_function

begin_function
name|int
name|null_cleanup
parameter_list|(
name|pbuf
parameter_list|,
name|pfile
parameter_list|)
name|cpp_buffer
modifier|*
name|pbuf
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|cpp_reader
modifier|*
name|pfile
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|macro_cleanup
parameter_list|(
name|pbuf
parameter_list|,
name|pfile
parameter_list|)
name|cpp_buffer
modifier|*
name|pbuf
decl_stmt|;
name|cpp_reader
modifier|*
name|pfile
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|HASHNODE
modifier|*
name|macro
init|=
operator|(
name|HASHNODE
operator|*
operator|)
name|pbuf
operator|->
name|data
decl_stmt|;
if|if
condition|(
name|macro
operator|->
name|type
operator|==
name|T_DISABLED
condition|)
name|macro
operator|->
name|type
operator|=
name|T_MACRO
expr_stmt|;
if|if
condition|(
name|macro
operator|->
name|type
operator|!=
name|T_MACRO
operator|||
name|pbuf
operator|->
name|buf
operator|!=
name|macro
operator|->
name|value
operator|.
name|defn
operator|->
name|expansion
condition|)
name|free
argument_list|(
name|pbuf
operator|->
name|buf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|file_cleanup
parameter_list|(
name|pbuf
parameter_list|,
name|pfile
parameter_list|)
name|cpp_buffer
modifier|*
name|pbuf
decl_stmt|;
name|cpp_reader
modifier|*
name|pfile
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|pbuf
operator|->
name|buf
condition|)
block|{
name|free
argument_list|(
name|pbuf
operator|->
name|buf
argument_list|)
expr_stmt|;
name|pbuf
operator|->
name|buf
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Assuming we have read '/'.    If this is the start of a comment (followed by '*' or '/'),    skip to the end of the comment, and return ' '.    Return EOF if we reached the end of file before the end of the comment.    If not the start of a comment, return '/'.  */
end_comment

begin_function
specifier|static
name|int
name|skip_comment
parameter_list|(
name|pfile
parameter_list|,
name|linep
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|long
modifier|*
name|linep
decl_stmt|;
block|{
name|int
name|c
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|PEEKC
argument_list|()
operator|==
literal|'\\'
operator|&&
name|PEEKN
argument_list|(
literal|1
argument_list|)
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|linep
condition|)
operator|(
operator|*
name|linep
operator|)
operator|++
expr_stmt|;
name|FORWARD
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|PEEKC
argument_list|()
operator|==
literal|'*'
condition|)
block|{
name|FORWARD
argument_list|(
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|prev_c
init|=
name|c
decl_stmt|;
name|c
operator|=
name|GETC
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
return|return
name|EOF
return|;
while|while
condition|(
name|c
operator|==
literal|'\\'
operator|&&
name|PEEKC
argument_list|()
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|linep
condition|)
operator|(
operator|*
name|linep
operator|)
operator|++
expr_stmt|;
name|FORWARD
argument_list|(
literal|1
argument_list|)
operator|,
name|c
operator|=
name|GETC
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|prev_c
operator|==
literal|'*'
operator|&&
name|c
operator|==
literal|'/'
condition|)
return|return
literal|' '
return|;
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|&&
name|linep
condition|)
operator|(
operator|*
name|linep
operator|)
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|PEEKC
argument_list|()
operator|==
literal|'/'
operator|&&
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|cplusplus_comments
condition|)
block|{
name|FORWARD
argument_list|(
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|GETC
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
return|return
literal|' '
return|;
comment|/* Allow // to be terminated by EOF.  */
while|while
condition|(
name|c
operator|==
literal|'\\'
operator|&&
name|PEEKC
argument_list|()
operator|==
literal|'\n'
condition|)
block|{
name|FORWARD
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|c
operator|=
name|GETC
argument_list|()
expr_stmt|;
if|if
condition|(
name|linep
condition|)
operator|(
operator|*
name|linep
operator|)
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
comment|/* Don't consider final '\n' to be part of comment.  */
name|FORWARD
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
literal|' '
return|;
block|}
block|}
block|}
else|else
return|return
literal|'/'
return|;
block|}
end_function

begin_comment
comment|/* Skip whitespace \-newline and comments.  Does not macro-expand.  */
end_comment

begin_function
name|void
name|cpp_skip_hspace
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|c
init|=
name|PEEKC
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
return|return;
comment|/* FIXME */
if|if
condition|(
name|is_hor_space
index|[
name|c
index|]
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|==
literal|'\f'
operator|||
name|c
operator|==
literal|'\v'
operator|)
operator|&&
name|CPP_PEDANTIC
argument_list|(
name|pfile
argument_list|)
condition|)
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"%s in preprocessing directive"
argument_list|,
name|c
operator|==
literal|'\f'
condition|?
literal|"formfeed"
else|:
literal|"vertical tab"
argument_list|)
expr_stmt|;
name|FORWARD
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'/'
condition|)
block|{
name|FORWARD
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|c
operator|=
name|skip_comment
argument_list|(
name|pfile
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'/'
condition|)
name|FORWARD
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
operator|||
name|c
operator|==
literal|'/'
condition|)
return|return;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\\'
operator|&&
name|PEEKN
argument_list|(
literal|1
argument_list|)
operator|==
literal|'\n'
condition|)
block|{
name|FORWARD
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'@'
operator|&&
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|->
name|has_escapes
operator|&&
name|is_hor_space
index|[
name|PEEKN
argument_list|(
literal|1
argument_list|)
index|]
condition|)
name|FORWARD
argument_list|(
literal|2
argument_list|)
expr_stmt|;
else|else
return|return;
block|}
block|}
end_function

begin_comment
comment|/* Read the rest of the current line.    The line is appended to PFILE's output buffer.  */
end_comment

begin_function
specifier|static
name|void
name|copy_rest_of_line
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|struct
name|cpp_options
modifier|*
name|opts
init|=
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|c
init|=
name|GETC
argument_list|()
decl_stmt|;
name|int
name|nextc
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|EOF
case|:
goto|goto
name|end_directive
goto|;
case|case
literal|'\\'
case|:
if|if
condition|(
name|PEEKC
argument_list|()
operator|==
literal|'\n'
condition|)
block|{
name|FORWARD
argument_list|(
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
case|case
literal|'\''
case|:
case|case
literal|'\"'
case|:
goto|goto
name|scan_directive_token
goto|;
break|break;
case|case
literal|'/'
case|:
name|nextc
operator|=
name|PEEKC
argument_list|()
expr_stmt|;
if|if
condition|(
name|nextc
operator|==
literal|'*'
operator|||
operator|(
name|opts
operator|->
name|cplusplus_comments
operator|&&
name|nextc
operator|==
literal|'/'
operator|)
condition|)
goto|goto
name|scan_directive_token
goto|;
break|break;
case|case
literal|'\f'
case|:
case|case
literal|'\v'
case|:
if|if
condition|(
name|CPP_PEDANTIC
argument_list|(
name|pfile
argument_list|)
condition|)
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"%s in preprocessing directive"
argument_list|,
name|c
operator|==
literal|'\f'
condition|?
literal|"formfeed"
else|:
literal|"vertical tab"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
name|FORWARD
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|end_directive
goto|;
name|scan_directive_token
label|:
name|FORWARD
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|cpp_get_token
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|CPP_PUTC
argument_list|(
name|pfile
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
name|end_directive
label|:
empty_stmt|;
name|CPP_NUL_TERMINATE
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|skip_rest_of_line
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|long
name|old
init|=
name|CPP_WRITTEN
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
name|copy_rest_of_line
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|CPP_SET_WRITTEN
argument_list|(
name|pfile
argument_list|,
name|old
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle a possible # directive.    '#' has already been read.  */
end_comment

begin_function
name|int
name|handle_directive
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
specifier|register
name|struct
name|directive
modifier|*
name|kt
decl_stmt|;
name|int
name|ident_length
decl_stmt|;
name|long
name|after_ident
decl_stmt|;
name|U_CHAR
modifier|*
name|ident
decl_stmt|,
modifier|*
name|line_end
decl_stmt|;
name|long
name|old_written
init|=
name|CPP_WRITTEN
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
name|cpp_skip_hspace
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|c
operator|=
name|PEEKC
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
block|{
comment|/* Handle # followed by a line number.  */
if|if
condition|(
name|CPP_PEDANTIC
argument_list|(
name|pfile
argument_list|)
condition|)
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"`#' followed by integer"
argument_list|)
expr_stmt|;
name|do_line
argument_list|(
name|pfile
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|done_a_directive
goto|;
block|}
comment|/* Now find the directive name.  */
name|CPP_PUTC
argument_list|(
name|pfile
argument_list|,
literal|'#'
argument_list|)
expr_stmt|;
name|parse_name
argument_list|(
name|pfile
argument_list|,
name|GETC
argument_list|()
argument_list|)
expr_stmt|;
name|ident
operator|=
name|pfile
operator|->
name|token_buffer
operator|+
name|old_written
operator|+
literal|1
expr_stmt|;
name|ident_length
operator|=
name|CPP_PWRITTEN
argument_list|(
name|pfile
argument_list|)
operator|-
name|ident
expr_stmt|;
if|if
condition|(
name|ident_length
operator|==
literal|0
operator|&&
name|PEEKC
argument_list|()
operator|==
literal|'\n'
condition|)
block|{
comment|/* A line of just `#' becomes blank.  */
goto|goto
name|done_a_directive
goto|;
block|}
if|#
directive|if
literal|0
block|if (ident_length == 0 || !is_idstart[*ident]) {     U_CHAR *p = ident;     while (is_idchar[*p]) {       if (*p< '0' || *p> '9') 	break;       p++;     }
comment|/* Avoid error for `###' and similar cases unless -pedantic.  */
block|if (p == ident) {       while (*p == '#' || is_hor_space[*p]) p++;       if (*p == '\n') { 	if (pedantic&& !lang_asm) 	  cpp_warning (pfile, "invalid preprocessor directive"); 	return 0;       }     }      if (!lang_asm)       cpp_error (pfile, "invalid preprocessor directive name");      return 0;   }
endif|#
directive|endif
comment|/*    * Decode the keyword and call the appropriate expansion    * routine, after moving the input pointer up to the next line.    */
for|for
control|(
name|kt
operator|=
name|directive_table
init|;
condition|;
name|kt
operator|++
control|)
block|{
if|if
condition|(
name|kt
operator|->
name|length
operator|<=
literal|0
condition|)
goto|goto
name|not_a_directive
goto|;
if|if
condition|(
name|kt
operator|->
name|length
operator|==
name|ident_length
operator|&&
operator|!
name|strncmp
argument_list|(
name|kt
operator|->
name|name
argument_list|,
name|ident
argument_list|,
name|ident_length
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|kt
operator|->
name|command_reads_line
condition|)
name|after_ident
operator|=
literal|0
expr_stmt|;
else|else
block|{
comment|/* Nonzero means do not delete comments within the directive.          #define needs this when -traditional.  */
name|int
name|comments
init|=
name|CPP_TRADITIONAL
argument_list|(
name|pfile
argument_list|)
operator|&&
name|kt
operator|->
name|type
operator|==
name|T_DEFINE
decl_stmt|;
name|int
name|save_put_out_comments
init|=
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|put_out_comments
decl_stmt|;
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|put_out_comments
operator|=
name|comments
expr_stmt|;
name|after_ident
operator|=
name|CPP_WRITTEN
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|copy_rest_of_line
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|put_out_comments
operator|=
name|save_put_out_comments
expr_stmt|;
block|}
comment|/* We may want to pass through #define, #pragma, and #include.      Other directives may create output, but we don't want the directive      itself out, so we pop it now.  For example conditionals may emit      #failed ... #endfailed stuff.  But note that popping the buffer      means the parameters to kt->func may point after pfile->limit      so these parameters are invalid as soon as something gets appended      to the token_buffer.  */
name|line_end
operator|=
name|CPP_PWRITTEN
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|kt
operator|->
name|type
operator|==
name|T_DEFINE
operator|||
name|kt
operator|->
name|type
operator|==
name|T_PRAGMA
operator|||
operator|(
name|IS_INCLUDE_DIRECTIVE_TYPE
argument_list|(
name|kt
operator|->
name|type
argument_list|)
operator|&&
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|dump_includes
operator|)
operator|)
condition|)
name|CPP_SET_WRITTEN
argument_list|(
name|pfile
argument_list|,
name|old_written
argument_list|)
expr_stmt|;
call|(
modifier|*
name|kt
operator|->
name|func
call|)
argument_list|(
name|pfile
argument_list|,
name|kt
argument_list|,
name|pfile
operator|->
name|token_buffer
operator|+
name|after_ident
argument_list|,
name|line_end
argument_list|)
expr_stmt|;
if|if
condition|(
name|kt
operator|->
name|type
operator|==
name|T_DEFINE
condition|)
block|{
if|if
condition|(
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|dump_macros
operator|==
name|dump_names
condition|)
block|{
comment|/* Skip "#define". */
name|U_CHAR
modifier|*
name|p
init|=
name|pfile
operator|->
name|token_buffer
operator|+
name|old_written
operator|+
literal|7
decl_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|p
argument_list|)
expr_stmt|;
while|while
condition|(
name|is_idchar
index|[
operator|*
name|p
index|]
condition|)
name|p
operator|++
expr_stmt|;
name|pfile
operator|->
name|limit
operator|=
name|p
expr_stmt|;
name|CPP_PUTC
argument_list|(
name|pfile
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|dump_macros
operator|!=
name|dump_definitions
condition|)
name|CPP_SET_WRITTEN
argument_list|(
name|pfile
argument_list|,
name|old_written
argument_list|)
expr_stmt|;
block|}
name|done_a_directive
label|:
return|return
literal|1
return|;
name|not_a_directive
label|:
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Pass a directive through to the output file.    BUF points to the contents of the directive, as a contiguous string.    LIMIT points to the first character past the end of the directive.    KEYWORD is the keyword-table entry for the directive.  */
end_comment

begin_function
specifier|static
name|void
name|pass_thru_directive
parameter_list|(
name|buf
parameter_list|,
name|limit
parameter_list|,
name|pfile
parameter_list|,
name|keyword
parameter_list|)
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
decl|*
name|limit
decl_stmt|;
end_function

begin_decl_stmt
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|directive
modifier|*
name|keyword
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|unsigned
name|keyword_length
init|=
name|keyword
operator|->
name|length
decl_stmt|;
name|CPP_RESERVE
argument_list|(
name|pfile
argument_list|,
literal|1
operator|+
name|keyword_length
operator|+
operator|(
name|limit
operator|-
name|buf
operator|)
argument_list|)
expr_stmt|;
name|CPP_PUTC_Q
argument_list|(
name|pfile
argument_list|,
literal|'#'
argument_list|)
expr_stmt|;
name|CPP_PUTS_Q
argument_list|(
name|pfile
argument_list|,
name|keyword
operator|->
name|name
argument_list|,
name|keyword_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|limit
operator|!=
name|buf
operator|&&
name|buf
index|[
literal|0
index|]
operator|!=
literal|' '
condition|)
name|CPP_PUTC_Q
argument_list|(
name|pfile
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|CPP_PUTS_Q
argument_list|(
name|pfile
argument_list|,
name|buf
argument_list|,
name|limit
operator|-
name|buf
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|CPP_PUTS_Q (pfile, '\n');
comment|/* Count the line we have just made in the output,      to get in sync properly.  */
block|pfile->lineno++;
endif|#
directive|endif
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* The arglist structure is built by do_define to tell    collect_definition where the argument names begin.  That    is, for a define like "#define f(x,y,z) foo+x-bar*y", the arglist    would contain pointers to the strings x, y, and z.    Collect_definition would then build a DEFINITION node,    with reflist nodes pointing to the places x, y, and z had    appeared.  So the arglist is just convenience data passed    between these two routines.  It is not kept around after    the current #define has been processed and entered into the    hash table.  */
end_comment

begin_struct
struct|struct
name|arglist
block|{
name|struct
name|arglist
modifier|*
name|next
decl_stmt|;
name|U_CHAR
modifier|*
name|name
decl_stmt|;
name|int
name|length
decl_stmt|;
name|int
name|argno
decl_stmt|;
name|char
name|rest_args
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Read a replacement list for a macro with parameters.    Build the DEFINITION structure.    Reads characters of text starting at BUF until END.    ARGLIST specifies the formal parameters to look for    in the text of the definition; NARGS is the number of args    in that list, or -1 for a macro name that wants no argument list.    MACRONAME is the macro name itself (so we can avoid recursive expansion)    and NAMELEN is its length in characters.        Note that comments, backslash-newlines, and leading white space    have already been deleted from the argument.  */
end_comment

begin_function
specifier|static
name|DEFINITION
modifier|*
name|collect_expansion
parameter_list|(
name|pfile
parameter_list|,
name|buf
parameter_list|,
name|limit
parameter_list|,
name|nargs
parameter_list|,
name|arglist
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
decl|*
name|limit
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|nargs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|arglist
modifier|*
name|arglist
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|DEFINITION
modifier|*
name|defn
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|p
decl_stmt|,
modifier|*
name|lastp
decl_stmt|,
modifier|*
name|exp_p
decl_stmt|;
name|struct
name|reflist
modifier|*
name|endpat
init|=
name|NULL
decl_stmt|;
comment|/* Pointer to first nonspace after last ## seen.  */
name|U_CHAR
modifier|*
name|concat
init|=
literal|0
decl_stmt|;
comment|/* Pointer to first nonspace after last single-# seen.  */
name|U_CHAR
modifier|*
name|stringify
init|=
literal|0
decl_stmt|;
name|int
name|maxsize
decl_stmt|;
name|int
name|expected_delimiter
init|=
literal|'\0'
decl_stmt|;
comment|/* Scan thru the replacement list, ignoring comments and quoted      strings, picking up on the macro calls.  It does a linear search      thru the arg list on every potential symbol.  Profiling might say      that something smarter should happen.  */
if|if
condition|(
name|limit
operator|<
name|buf
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Find the beginning of the trailing whitespace.  */
name|p
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|limit
operator|&&
name|is_space
index|[
name|limit
index|[
operator|-
literal|1
index|]
index|]
condition|)
name|limit
operator|--
expr_stmt|;
comment|/* Allocate space for the text in the macro definition.      Leading and trailing whitespace chars need 2 bytes each.      Each other input char may or may not need 1 byte,      so this is an upper bound.  The extra 5 are for invented      leading and trailing newline-marker and final null.  */
name|maxsize
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|DEFINITION
argument_list|)
operator|+
operator|(
name|limit
operator|-
name|p
operator|)
operator|+
literal|5
operator|)
expr_stmt|;
comment|/* Occurrences of '@' get doubled, so allocate extra space for them.  */
while|while
condition|(
name|p
operator|<
name|limit
condition|)
if|if
condition|(
operator|*
name|p
operator|++
operator|==
literal|'@'
condition|)
name|maxsize
operator|++
expr_stmt|;
name|defn
operator|=
operator|(
name|DEFINITION
operator|*
operator|)
name|xcalloc
argument_list|(
literal|1
argument_list|,
name|maxsize
argument_list|)
expr_stmt|;
name|defn
operator|->
name|nargs
operator|=
name|nargs
expr_stmt|;
name|exp_p
operator|=
name|defn
operator|->
name|expansion
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|defn
operator|+
sizeof|sizeof
argument_list|(
name|DEFINITION
argument_list|)
expr_stmt|;
name|lastp
operator|=
name|exp_p
expr_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
comment|/* Add one initial space escape-marker to prevent accidental      token-pasting (often removed by macroexpand).  */
operator|*
name|exp_p
operator|++
operator|=
literal|'@'
expr_stmt|;
operator|*
name|exp_p
operator|++
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|limit
operator|-
name|p
operator|>=
literal|2
operator|&&
name|p
index|[
literal|0
index|]
operator|==
literal|'#'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'#'
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"`##' at start of macro definition"
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
block|}
comment|/* Process the main body of the definition.  */
while|while
condition|(
name|p
operator|<
name|limit
condition|)
block|{
name|int
name|skipped_arg
init|=
literal|0
decl_stmt|;
specifier|register
name|U_CHAR
name|c
init|=
operator|*
name|p
operator|++
decl_stmt|;
operator|*
name|exp_p
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
operator|!
name|CPP_TRADITIONAL
argument_list|(
name|pfile
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\''
case|:
case|case
literal|'\"'
case|:
if|if
condition|(
name|expected_delimiter
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|expected_delimiter
condition|)
name|expected_delimiter
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
name|expected_delimiter
operator|=
name|c
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
if|if
condition|(
name|p
operator|<
name|limit
operator|&&
name|expected_delimiter
condition|)
block|{
comment|/* In a string, backslash goes through 	     and makes next char ordinary.  */
operator|*
name|exp_p
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'@'
case|:
comment|/* An '@' in a string or character constant stands for itself, 	   and does not need to be escaped.  */
if|if
condition|(
operator|!
name|expected_delimiter
condition|)
operator|*
name|exp_p
operator|++
operator|=
name|c
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
comment|/* # is ordinary inside a string.  */
if|if
condition|(
name|expected_delimiter
condition|)
break|break;
if|if
condition|(
name|p
operator|<
name|limit
operator|&&
operator|*
name|p
operator|==
literal|'#'
condition|)
block|{
comment|/* ##: concatenate preceding and following tokens.  */
comment|/* Take out the first #, discard preceding whitespace.  */
name|exp_p
operator|--
expr_stmt|;
while|while
condition|(
name|exp_p
operator|>
name|lastp
operator|&&
name|is_hor_space
index|[
name|exp_p
index|[
operator|-
literal|1
index|]
index|]
condition|)
operator|--
name|exp_p
expr_stmt|;
comment|/* Skip the second #.  */
name|p
operator|++
expr_stmt|;
comment|/* Discard following whitespace.  */
name|SKIP_WHITE_SPACE
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|concat
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|limit
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"`##' at end of macro definition"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nargs
operator|>=
literal|0
condition|)
block|{
comment|/* Single #: stringify following argument ref. 	     Don't leave the # in the expansion.  */
name|exp_p
operator|--
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|limit
operator|||
operator|!
name|is_idstart
index|[
operator|*
name|p
index|]
operator|||
operator|(
operator|*
name|p
operator|==
literal|'L'
operator|&&
name|p
operator|+
literal|1
operator|<
name|limit
operator|&&
operator|(
name|p
index|[
literal|1
index|]
operator|==
literal|'\''
operator|||
name|p
index|[
literal|1
index|]
operator|==
literal|'"'
operator|)
operator|)
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"`#' operator is not followed by a macro argument name"
argument_list|)
expr_stmt|;
else|else
name|stringify
operator|=
name|p
expr_stmt|;
block|}
break|break;
block|}
block|}
else|else
block|{
comment|/* In -traditional mode, recognize arguments inside strings and 	 character constants, and ignore special properties of #. 	 Arguments inside strings are considered "stringified", but no 	 extra quote marks are supplied.  */
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\''
case|:
case|case
literal|'\"'
case|:
if|if
condition|(
name|expected_delimiter
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|expected_delimiter
condition|)
name|expected_delimiter
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
name|expected_delimiter
operator|=
name|c
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
comment|/* Backslash quotes delimiters and itself, but not macro args.  */
if|if
condition|(
name|expected_delimiter
operator|!=
literal|0
operator|&&
name|p
operator|<
name|limit
operator|&&
operator|(
operator|*
name|p
operator|==
name|expected_delimiter
operator|||
operator|*
name|p
operator|==
literal|'\\'
operator|)
condition|)
block|{
operator|*
name|exp_p
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
literal|'/'
case|:
if|if
condition|(
name|expected_delimiter
operator|!=
literal|'\0'
condition|)
comment|/* No comments inside strings.  */
break|break;
if|if
condition|(
operator|*
name|p
operator|==
literal|'*'
condition|)
block|{
comment|/* If we find a comment that wasn't removed by handle_directive, 	     this must be -traditional.  So replace the comment with 	     nothing at all.  */
name|exp_p
operator|--
expr_stmt|;
name|p
operator|+=
literal|1
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|limit
operator|&&
operator|!
operator|(
name|p
index|[
operator|-
literal|2
index|]
operator|==
literal|'*'
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'/'
operator|)
condition|)
name|p
operator|++
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Mark this as a concatenation-point, as if it had been ##.  */
block|concat = p;
endif|#
directive|endif
block|}
break|break;
block|}
block|}
comment|/* Handle the start of a symbol.  */
if|if
condition|(
name|is_idchar
index|[
name|c
index|]
operator|&&
name|nargs
operator|>
literal|0
condition|)
block|{
name|U_CHAR
modifier|*
name|id_beg
init|=
name|p
operator|-
literal|1
decl_stmt|;
name|int
name|id_len
decl_stmt|;
operator|--
name|exp_p
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|limit
operator|&&
name|is_idchar
index|[
operator|*
name|p
index|]
condition|)
name|p
operator|++
expr_stmt|;
name|id_len
operator|=
name|p
operator|-
name|id_beg
expr_stmt|;
if|if
condition|(
name|is_idstart
index|[
name|c
index|]
operator|&&
operator|!
operator|(
name|id_len
operator|==
literal|1
operator|&&
name|c
operator|==
literal|'L'
operator|&&
operator|(
operator|*
name|p
operator|==
literal|'\''
operator|||
operator|*
name|p
operator|==
literal|'"'
operator|)
operator|)
condition|)
block|{
specifier|register
name|struct
name|arglist
modifier|*
name|arg
decl_stmt|;
for|for
control|(
name|arg
operator|=
name|arglist
init|;
name|arg
operator|!=
name|NULL
condition|;
name|arg
operator|=
name|arg
operator|->
name|next
control|)
block|{
name|struct
name|reflist
modifier|*
name|tpat
decl_stmt|;
if|if
condition|(
name|arg
operator|->
name|name
index|[
literal|0
index|]
operator|==
name|c
operator|&&
name|arg
operator|->
name|length
operator|==
name|id_len
operator|&&
name|strncmp
argument_list|(
name|arg
operator|->
name|name
argument_list|,
name|id_beg
argument_list|,
name|id_len
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|expected_delimiter
operator|&&
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|warn_stringify
condition|)
block|{
if|if
condition|(
name|CPP_TRADITIONAL
argument_list|(
name|pfile
argument_list|)
condition|)
block|{
name|cpp_warning
argument_list|(
name|pfile
argument_list|,
literal|"macro argument `%.*s' is stringified."
argument_list|,
name|id_len
argument_list|,
name|arg
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cpp_warning
argument_list|(
name|pfile
argument_list|,
literal|"macro arg `%.*s' would be stringified with -traditional."
argument_list|,
name|id_len
argument_list|,
name|arg
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If ANSI, don't actually substitute inside a string.  */
if|if
condition|(
operator|!
name|CPP_TRADITIONAL
argument_list|(
name|pfile
argument_list|)
operator|&&
name|expected_delimiter
condition|)
break|break;
comment|/* make a pat node for this arg and append it to the end of 	       the pat list */
name|tpat
operator|=
operator|(
expr|struct
name|reflist
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|reflist
argument_list|)
argument_list|)
expr_stmt|;
name|tpat
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|tpat
operator|->
name|raw_before
operator|=
name|concat
operator|==
name|id_beg
expr_stmt|;
name|tpat
operator|->
name|raw_after
operator|=
literal|0
expr_stmt|;
name|tpat
operator|->
name|rest_args
operator|=
name|arg
operator|->
name|rest_args
expr_stmt|;
name|tpat
operator|->
name|stringify
operator|=
operator|(
name|CPP_TRADITIONAL
argument_list|(
name|pfile
argument_list|)
condition|?
name|expected_delimiter
operator|!=
literal|'\0'
else|:
name|stringify
operator|==
name|id_beg
operator|)
expr_stmt|;
if|if
condition|(
name|endpat
operator|==
name|NULL
condition|)
name|defn
operator|->
name|pattern
operator|=
name|tpat
expr_stmt|;
else|else
name|endpat
operator|->
name|next
operator|=
name|tpat
expr_stmt|;
name|endpat
operator|=
name|tpat
expr_stmt|;
name|tpat
operator|->
name|argno
operator|=
name|arg
operator|->
name|argno
expr_stmt|;
name|tpat
operator|->
name|nchars
operator|=
name|exp_p
operator|-
name|lastp
expr_stmt|;
block|{
specifier|register
name|U_CHAR
modifier|*
name|p1
init|=
name|p
decl_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|p1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
operator|+
literal|2
operator|<=
name|limit
operator|&&
name|p1
index|[
literal|0
index|]
operator|==
literal|'#'
operator|&&
name|p1
index|[
literal|1
index|]
operator|==
literal|'#'
condition|)
name|tpat
operator|->
name|raw_after
operator|=
literal|1
expr_stmt|;
block|}
name|lastp
operator|=
name|exp_p
expr_stmt|;
comment|/* place to start copying from next time */
name|skipped_arg
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* If this was not a macro arg, copy it into the expansion.  */
if|if
condition|(
operator|!
name|skipped_arg
condition|)
block|{
specifier|register
name|U_CHAR
modifier|*
name|lim1
init|=
name|p
decl_stmt|;
name|p
operator|=
name|id_beg
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|lim1
condition|)
operator|*
name|exp_p
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|stringify
operator|==
name|id_beg
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"`#' operator should be followed by a macro argument name"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|CPP_TRADITIONAL
argument_list|(
name|pfile
argument_list|)
operator|&&
name|expected_delimiter
operator|==
literal|0
condition|)
block|{
comment|/* If ANSI, put in a "@ " marker to prevent token pasting.          But not if "inside a string" (which in ANSI mode          happens only for -D option).  */
operator|*
name|exp_p
operator|++
operator|=
literal|'@'
expr_stmt|;
operator|*
name|exp_p
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
operator|*
name|exp_p
operator|=
literal|'\0'
expr_stmt|;
name|defn
operator|->
name|length
operator|=
name|exp_p
operator|-
name|defn
operator|->
name|expansion
expr_stmt|;
comment|/* Crash now if we overrun the allocated size.  */
if|if
condition|(
name|defn
operator|->
name|length
operator|+
literal|1
operator|>
name|maxsize
condition|)
name|abort
argument_list|()
expr_stmt|;
if|#
directive|if
literal|0
comment|/* This isn't worth the time it takes.  */
comment|/* give back excess storage */
block|defn->expansion = (U_CHAR *) xrealloc (defn->expansion, defn->length + 1);
endif|#
directive|endif
return|return
name|defn
return|;
block|}
end_block

begin_comment
comment|/*  * special extension string that can be added to the last macro argument to   * allow it to absorb the "rest" of the arguments when expanded.  Ex:  * 		#define wow(a, b...)		process (b, a, b)  *		{ wow (1, 2, 3); }	->	{ process (2, 3, 1, 2, 3); }  *		{ wow (one, two); }	->	{ process (two, one, two); }  * if this "rest_arg" is used with the concat token '##' and if it is not  * supplied then the token attached to with ## will not be outputted.  Ex:  * 		#define wow (a, b...)		process (b ## , a, ## b)  *		{ wow (1, 2); }		->	{ process (2, 1, 2); }  *		{ wow (one); }		->	{ process (one); {  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|rest_extension
index|[]
init|=
literal|"..."
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|REST_EXTENSION_LENGTH
value|(sizeof (rest_extension) - 1)
end_define

begin_comment
comment|/* Create a DEFINITION node from a #define directive.  Arguments are     as for do_define.  */
end_comment

begin_function
specifier|static
name|MACRODEF
name|create_definition
parameter_list|(
name|buf
parameter_list|,
name|limit
parameter_list|,
name|pfile
parameter_list|,
name|predefinition
parameter_list|)
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
decl|*
name|limit
decl_stmt|;
end_function

begin_decl_stmt
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|predefinition
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|U_CHAR
modifier|*
name|bp
decl_stmt|;
comment|/* temp ptr into input buffer */
name|U_CHAR
modifier|*
name|symname
decl_stmt|;
comment|/* remember where symbol name starts */
name|int
name|sym_length
decl_stmt|;
comment|/* and how long it is */
name|int
name|rest_args
init|=
literal|0
decl_stmt|;
name|long
name|line
decl_stmt|,
name|col
decl_stmt|;
name|char
modifier|*
name|file
init|=
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
condition|?
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|->
name|nominal_fname
else|:
literal|""
decl_stmt|;
name|DEFINITION
modifier|*
name|defn
decl_stmt|;
name|int
name|arglengths
init|=
literal|0
decl_stmt|;
comment|/* Accumulate lengths of arg names 				   plus number of args.  */
name|MACRODEF
name|mdef
decl_stmt|;
name|cpp_buf_line_and_col
argument_list|(
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
argument_list|,
operator|&
name|line
argument_list|,
operator|&
name|col
argument_list|)
expr_stmt|;
name|bp
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|is_hor_space
index|[
operator|*
name|bp
index|]
condition|)
name|bp
operator|++
expr_stmt|;
name|symname
operator|=
name|bp
expr_stmt|;
comment|/* remember where it starts */
name|sym_length
operator|=
name|check_macro_name
argument_list|(
name|pfile
argument_list|,
name|bp
argument_list|,
literal|"macro"
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|sym_length
expr_stmt|;
comment|/* Lossage will occur if identifiers or control keywords are broken      across lines using backslash.  This is not the right place to take      care of that.  */
if|if
condition|(
operator|*
name|bp
operator|==
literal|'('
condition|)
block|{
name|struct
name|arglist
modifier|*
name|arg_ptrs
init|=
name|NULL
decl_stmt|;
name|int
name|argno
init|=
literal|0
decl_stmt|;
name|bp
operator|++
expr_stmt|;
comment|/* skip '(' */
name|SKIP_WHITE_SPACE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* Loop over macro argument names.  */
while|while
condition|(
operator|*
name|bp
operator|!=
literal|')'
condition|)
block|{
name|struct
name|arglist
modifier|*
name|temp
decl_stmt|;
name|temp
operator|=
operator|(
expr|struct
name|arglist
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|->
name|name
operator|=
name|bp
expr_stmt|;
name|temp
operator|->
name|next
operator|=
name|arg_ptrs
expr_stmt|;
name|temp
operator|->
name|argno
operator|=
name|argno
operator|++
expr_stmt|;
name|temp
operator|->
name|rest_args
operator|=
literal|0
expr_stmt|;
name|arg_ptrs
operator|=
name|temp
expr_stmt|;
if|if
condition|(
name|rest_args
condition|)
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"another parameter follows `%s'"
argument_list|,
name|rest_extension
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_idstart
index|[
operator|*
name|bp
index|]
condition|)
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"invalid character in macro parameter name"
argument_list|)
expr_stmt|;
comment|/* Find the end of the arg name.  */
while|while
condition|(
name|is_idchar
index|[
operator|*
name|bp
index|]
condition|)
block|{
name|bp
operator|++
expr_stmt|;
comment|/* do we have a "special" rest-args extension here? */
if|if
condition|(
name|limit
operator|-
name|bp
operator|>
name|REST_EXTENSION_LENGTH
operator|&&
name|strncmp
argument_list|(
name|rest_extension
argument_list|,
name|bp
argument_list|,
name|REST_EXTENSION_LENGTH
argument_list|)
operator|==
literal|0
condition|)
block|{
name|rest_args
operator|=
literal|1
expr_stmt|;
name|temp
operator|->
name|rest_args
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|temp
operator|->
name|length
operator|=
name|bp
operator|-
name|temp
operator|->
name|name
expr_stmt|;
if|if
condition|(
name|rest_args
operator|==
literal|1
condition|)
name|bp
operator|+=
name|REST_EXTENSION_LENGTH
expr_stmt|;
name|arglengths
operator|+=
name|temp
operator|->
name|length
operator|+
literal|2
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|->
name|length
operator|==
literal|0
operator|||
operator|(
operator|*
name|bp
operator|!=
literal|','
operator|&&
operator|*
name|bp
operator|!=
literal|')'
operator|)
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"badly punctuated parameter list in `#define'"
argument_list|)
expr_stmt|;
goto|goto
name|nope
goto|;
block|}
if|if
condition|(
operator|*
name|bp
operator|==
literal|','
condition|)
block|{
name|bp
operator|++
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|>=
name|limit
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"unterminated parameter list in `#define'"
argument_list|)
expr_stmt|;
goto|goto
name|nope
goto|;
block|}
block|{
name|struct
name|arglist
modifier|*
name|otemp
decl_stmt|;
for|for
control|(
name|otemp
operator|=
name|temp
operator|->
name|next
init|;
name|otemp
operator|!=
name|NULL
condition|;
name|otemp
operator|=
name|otemp
operator|->
name|next
control|)
if|if
condition|(
name|temp
operator|->
name|length
operator|==
name|otemp
operator|->
name|length
operator|&&
name|strncmp
argument_list|(
name|temp
operator|->
name|name
argument_list|,
name|otemp
operator|->
name|name
argument_list|,
name|temp
operator|->
name|length
argument_list|)
operator|==
literal|0
condition|)
block|{
name|U_CHAR
modifier|*
name|name
decl_stmt|;
name|name
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|alloca
argument_list|(
name|temp
operator|->
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|name
argument_list|,
name|temp
operator|->
name|name
argument_list|,
name|temp
operator|->
name|length
argument_list|)
expr_stmt|;
name|name
index|[
name|temp
operator|->
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"duplicate argument name `%s' in `#define'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
goto|goto
name|nope
goto|;
block|}
block|}
block|}
operator|++
name|bp
expr_stmt|;
comment|/* skip paren */
name|SKIP_WHITE_SPACE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* now everything from bp before limit is the definition.  */
name|defn
operator|=
name|collect_expansion
argument_list|(
name|pfile
argument_list|,
name|bp
argument_list|,
name|limit
argument_list|,
name|argno
argument_list|,
name|arg_ptrs
argument_list|)
expr_stmt|;
name|defn
operator|->
name|rest_args
operator|=
name|rest_args
expr_stmt|;
comment|/* Now set defn->args.argnames to the result of concatenating        the argument names in reverse order        with comma-space between them.  */
name|defn
operator|->
name|args
operator|.
name|argnames
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xmalloc
argument_list|(
name|arglengths
operator|+
literal|1
argument_list|)
expr_stmt|;
block|{
name|struct
name|arglist
modifier|*
name|temp
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|temp
operator|=
name|arg_ptrs
init|;
name|temp
condition|;
name|temp
operator|=
name|temp
operator|->
name|next
control|)
block|{
name|bcopy
argument_list|(
name|temp
operator|->
name|name
argument_list|,
operator|&
name|defn
operator|->
name|args
operator|.
name|argnames
index|[
name|i
index|]
argument_list|,
name|temp
operator|->
name|length
argument_list|)
expr_stmt|;
name|i
operator|+=
name|temp
operator|->
name|length
expr_stmt|;
if|if
condition|(
name|temp
operator|->
name|next
operator|!=
literal|0
condition|)
block|{
name|defn
operator|->
name|args
operator|.
name|argnames
index|[
name|i
operator|++
index|]
operator|=
literal|','
expr_stmt|;
name|defn
operator|->
name|args
operator|.
name|argnames
index|[
name|i
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
block|}
block|}
name|defn
operator|->
name|args
operator|.
name|argnames
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Simple expansion or empty definition.  */
if|if
condition|(
name|bp
operator|<
name|limit
condition|)
block|{
if|if
condition|(
name|is_hor_space
index|[
operator|*
name|bp
index|]
condition|)
block|{
name|bp
operator|++
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
operator|*
name|bp
condition|)
block|{
case|case
literal|'!'
case|:
case|case
literal|'"'
case|:
case|case
literal|'#'
case|:
case|case
literal|'%'
case|:
case|case
literal|'&'
case|:
case|case
literal|'\''
case|:
case|case
literal|')'
case|:
case|case
literal|'*'
case|:
case|case
literal|'+'
case|:
case|case
literal|','
case|:
case|case
literal|'-'
case|:
case|case
literal|'.'
case|:
case|case
literal|'/'
case|:
case|case
literal|':'
case|:
case|case
literal|';'
case|:
case|case
literal|'<'
case|:
case|case
literal|'='
case|:
case|case
literal|'>'
case|:
case|case
literal|'?'
case|:
case|case
literal|'['
case|:
case|case
literal|'\\'
case|:
case|case
literal|']'
case|:
case|case
literal|'^'
case|:
case|case
literal|'{'
case|:
case|case
literal|'|'
case|:
case|case
literal|'}'
case|:
case|case
literal|'~'
case|:
name|cpp_warning
argument_list|(
name|pfile
argument_list|,
literal|"missing white space after `#define %.*s'"
argument_list|,
name|sym_length
argument_list|,
name|symname
argument_list|)
expr_stmt|;
break|break;
default|default:
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"missing white space after `#define %.*s'"
argument_list|,
name|sym_length
argument_list|,
name|symname
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* now everything from bp before limit is the definition.  */
name|defn
operator|=
name|collect_expansion
argument_list|(
name|pfile
argument_list|,
name|bp
argument_list|,
name|limit
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|defn
operator|->
name|args
operator|.
name|argnames
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
literal|""
expr_stmt|;
block|}
name|defn
operator|->
name|line
operator|=
name|line
expr_stmt|;
name|defn
operator|->
name|file
operator|=
name|file
expr_stmt|;
comment|/* OP is null if this is a predefinition */
name|defn
operator|->
name|predefined
operator|=
name|predefinition
expr_stmt|;
name|mdef
operator|.
name|defn
operator|=
name|defn
expr_stmt|;
name|mdef
operator|.
name|symnam
operator|=
name|symname
expr_stmt|;
name|mdef
operator|.
name|symlen
operator|=
name|sym_length
expr_stmt|;
return|return
name|mdef
return|;
name|nope
label|:
name|mdef
operator|.
name|defn
operator|=
literal|0
expr_stmt|;
return|return
name|mdef
return|;
block|}
end_block

begin_comment
comment|/* Check a purported macro name SYMNAME, and yield its length.    USAGE is the kind of name this is intended for.  */
end_comment

begin_function
specifier|static
name|int
name|check_macro_name
parameter_list|(
name|pfile
parameter_list|,
name|symname
parameter_list|,
name|usage
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|U_CHAR
modifier|*
name|symname
decl_stmt|;
name|char
modifier|*
name|usage
decl_stmt|;
block|{
name|U_CHAR
modifier|*
name|p
decl_stmt|;
name|int
name|sym_length
decl_stmt|;
for|for
control|(
name|p
operator|=
name|symname
init|;
name|is_idchar
index|[
operator|*
name|p
index|]
condition|;
name|p
operator|++
control|)
empty_stmt|;
name|sym_length
operator|=
name|p
operator|-
name|symname
expr_stmt|;
if|if
condition|(
name|sym_length
operator|==
literal|0
operator|||
operator|(
name|sym_length
operator|==
literal|1
operator|&&
operator|*
name|symname
operator|==
literal|'L'
operator|&&
operator|(
operator|*
name|p
operator|==
literal|'\''
operator|||
operator|*
name|p
operator|==
literal|'"'
operator|)
operator|)
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"invalid %s name"
argument_list|,
name|usage
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|is_idstart
index|[
operator|*
name|symname
index|]
condition|)
block|{
name|U_CHAR
modifier|*
name|msg
decl_stmt|;
comment|/* what pain...  */
name|msg
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|alloca
argument_list|(
name|sym_length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|symname
argument_list|,
name|msg
argument_list|,
name|sym_length
argument_list|)
expr_stmt|;
name|msg
index|[
name|sym_length
index|]
operator|=
literal|0
expr_stmt|;
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"invalid %s name `%s'"
argument_list|,
name|usage
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|symname
argument_list|,
literal|"defined"
argument_list|,
literal|7
argument_list|)
operator|&&
name|sym_length
operator|==
literal|7
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"invalid %s name `defined'"
argument_list|,
name|usage
argument_list|)
expr_stmt|;
block|}
return|return
name|sym_length
return|;
block|}
end_function

begin_comment
comment|/* Return zero if two DEFINITIONs are isomorphic.  */
end_comment

begin_function
specifier|static
name|int
name|compare_defs
parameter_list|(
name|pfile
parameter_list|,
name|d1
parameter_list|,
name|d2
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|DEFINITION
modifier|*
name|d1
decl_stmt|,
decl|*
name|d2
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|struct
name|reflist
modifier|*
name|a1
decl_stmt|,
modifier|*
name|a2
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|p1
init|=
name|d1
operator|->
name|expansion
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|p2
init|=
name|d2
operator|->
name|expansion
decl_stmt|;
name|int
name|first
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|d1
operator|->
name|nargs
operator|!=
name|d2
operator|->
name|nargs
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|CPP_PEDANTIC
argument_list|(
name|pfile
argument_list|)
operator|&&
name|strcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|d1
operator|->
name|args
operator|.
name|argnames
argument_list|,
operator|(
name|char
operator|*
operator|)
name|d2
operator|->
name|args
operator|.
name|argnames
argument_list|)
condition|)
return|return
literal|1
return|;
for|for
control|(
name|a1
operator|=
name|d1
operator|->
name|pattern
operator|,
name|a2
operator|=
name|d2
operator|->
name|pattern
init|;
name|a1
operator|&&
name|a2
condition|;
name|a1
operator|=
name|a1
operator|->
name|next
operator|,
name|a2
operator|=
name|a2
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|a1
operator|->
name|nchars
operator|==
name|a2
operator|->
name|nchars
operator|&&
operator|!
name|strncmp
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|,
name|a1
operator|->
name|nchars
argument_list|)
operator|)
operator|||
operator|!
name|comp_def_part
argument_list|(
name|first
argument_list|,
name|p1
argument_list|,
name|a1
operator|->
name|nchars
argument_list|,
name|p2
argument_list|,
name|a2
operator|->
name|nchars
argument_list|,
literal|0
argument_list|)
operator|)
operator|||
name|a1
operator|->
name|argno
operator|!=
name|a2
operator|->
name|argno
operator|||
name|a1
operator|->
name|stringify
operator|!=
name|a2
operator|->
name|stringify
operator|||
name|a1
operator|->
name|raw_before
operator|!=
name|a2
operator|->
name|raw_before
operator|||
name|a1
operator|->
name|raw_after
operator|!=
name|a2
operator|->
name|raw_after
condition|)
return|return
literal|1
return|;
name|first
operator|=
literal|0
expr_stmt|;
name|p1
operator|+=
name|a1
operator|->
name|nchars
expr_stmt|;
name|p2
operator|+=
name|a2
operator|->
name|nchars
expr_stmt|;
block|}
if|if
condition|(
name|a1
operator|!=
name|a2
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|comp_def_part
argument_list|(
name|first
argument_list|,
name|p1
argument_list|,
name|d1
operator|->
name|length
operator|-
operator|(
name|p1
operator|-
name|d1
operator|->
name|expansion
operator|)
argument_list|,
name|p2
argument_list|,
name|d2
operator|->
name|length
operator|-
operator|(
name|p2
operator|-
name|d2
operator|->
name|expansion
operator|)
argument_list|,
literal|1
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Return 1 if two parts of two macro definitions are effectively different.    One of the parts starts at BEG1 and has LEN1 chars;    the other has LEN2 chars at BEG2.    Any sequence of whitespace matches any other sequence of whitespace.    FIRST means these parts are the first of a macro definition;     so ignore leading whitespace entirely.    LAST means these parts are the last of a macro definition;     so ignore trailing whitespace entirely.  */
end_comment

begin_function
specifier|static
name|int
name|comp_def_part
parameter_list|(
name|first
parameter_list|,
name|beg1
parameter_list|,
name|len1
parameter_list|,
name|beg2
parameter_list|,
name|len2
parameter_list|,
name|last
parameter_list|)
name|int
name|first
decl_stmt|;
name|U_CHAR
modifier|*
name|beg1
decl_stmt|,
decl|*
name|beg2
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|len1
decl_stmt|,
name|len2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|last
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|U_CHAR
modifier|*
name|end1
init|=
name|beg1
operator|+
name|len1
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|end2
init|=
name|beg2
operator|+
name|len2
decl_stmt|;
if|if
condition|(
name|first
condition|)
block|{
while|while
condition|(
name|beg1
operator|!=
name|end1
operator|&&
name|is_space
index|[
operator|*
name|beg1
index|]
condition|)
name|beg1
operator|++
expr_stmt|;
while|while
condition|(
name|beg2
operator|!=
name|end2
operator|&&
name|is_space
index|[
operator|*
name|beg2
index|]
condition|)
name|beg2
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|last
condition|)
block|{
while|while
condition|(
name|beg1
operator|!=
name|end1
operator|&&
name|is_space
index|[
name|end1
index|[
operator|-
literal|1
index|]
index|]
condition|)
name|end1
operator|--
expr_stmt|;
while|while
condition|(
name|beg2
operator|!=
name|end2
operator|&&
name|is_space
index|[
name|end2
index|[
operator|-
literal|1
index|]
index|]
condition|)
name|end2
operator|--
expr_stmt|;
block|}
while|while
condition|(
name|beg1
operator|!=
name|end1
operator|&&
name|beg2
operator|!=
name|end2
condition|)
block|{
if|if
condition|(
name|is_space
index|[
operator|*
name|beg1
index|]
operator|&&
name|is_space
index|[
operator|*
name|beg2
index|]
condition|)
block|{
while|while
condition|(
name|beg1
operator|!=
name|end1
operator|&&
name|is_space
index|[
operator|*
name|beg1
index|]
condition|)
name|beg1
operator|++
expr_stmt|;
while|while
condition|(
name|beg2
operator|!=
name|end2
operator|&&
name|is_space
index|[
operator|*
name|beg2
index|]
condition|)
name|beg2
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|beg1
operator|==
operator|*
name|beg2
condition|)
block|{
name|beg1
operator|++
expr_stmt|;
name|beg2
operator|++
expr_stmt|;
block|}
else|else
break|break;
block|}
return|return
operator|(
name|beg1
operator|!=
name|end1
operator|)
operator|||
operator|(
name|beg2
operator|!=
name|end2
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Process a #define command. BUF points to the contents of the #define command, as a contiguous string. LIMIT points to the first character past the end of the definition. KEYWORD is the keyword-table entry for #define, or NULL for a "predefined" macro.  */
end_comment

begin_function
specifier|static
name|int
name|do_define
parameter_list|(
name|pfile
parameter_list|,
name|keyword
parameter_list|,
name|buf
parameter_list|,
name|limit
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|struct
name|directive
modifier|*
name|keyword
decl_stmt|;
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
decl|*
name|limit
decl_stmt|;
end_function

begin_block
block|{
name|int
name|hashcode
decl_stmt|;
name|MACRODEF
name|mdef
decl_stmt|;
name|HASHNODE
modifier|*
name|hp
decl_stmt|;
if|#
directive|if
literal|0
comment|/* If this is a precompiler run (with -pcp) pass thru #define commands.  */
block|if (pcp_outfile&& keyword)     pass_thru_directive (buf, limit, pfile, keyword);
endif|#
directive|endif
name|mdef
operator|=
name|create_definition
argument_list|(
name|buf
argument_list|,
name|limit
argument_list|,
name|pfile
argument_list|,
name|keyword
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mdef
operator|.
name|defn
operator|==
literal|0
condition|)
goto|goto
name|nope
goto|;
name|hashcode
operator|=
name|hashf
argument_list|(
name|mdef
operator|.
name|symnam
argument_list|,
name|mdef
operator|.
name|symlen
argument_list|,
name|HASHSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hp
operator|=
name|cpp_lookup
argument_list|(
name|pfile
argument_list|,
name|mdef
operator|.
name|symnam
argument_list|,
name|mdef
operator|.
name|symlen
argument_list|,
name|hashcode
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|int
name|ok
init|=
literal|0
decl_stmt|;
comment|/* Redefining a precompiled key is ok.  */
if|if
condition|(
name|hp
operator|->
name|type
operator|==
name|T_PCSTRING
condition|)
name|ok
operator|=
literal|1
expr_stmt|;
comment|/* Redefining a macro is ok if the definitions are the same.  */
elseif|else
if|if
condition|(
name|hp
operator|->
name|type
operator|==
name|T_MACRO
condition|)
name|ok
operator|=
operator|!
name|compare_defs
argument_list|(
name|pfile
argument_list|,
name|mdef
operator|.
name|defn
argument_list|,
name|hp
operator|->
name|value
operator|.
name|defn
argument_list|)
expr_stmt|;
comment|/* Redefining a constant is ok with -D.  */
elseif|else
if|if
condition|(
name|hp
operator|->
name|type
operator|==
name|T_CONST
condition|)
name|ok
operator|=
operator|!
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|done_initializing
expr_stmt|;
comment|/* Print the warning if it's not ok.  */
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|U_CHAR
modifier|*
name|msg
decl_stmt|;
comment|/* what pain...  */
comment|/* If we are passing through #define and #undef directives, do 	     that for this re-definition now.  */
if|if
condition|(
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|debug_output
operator|&&
name|keyword
condition|)
name|pass_thru_directive
argument_list|(
name|buf
argument_list|,
name|limit
argument_list|,
name|pfile
argument_list|,
name|keyword
argument_list|)
expr_stmt|;
name|msg
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|alloca
argument_list|(
name|mdef
operator|.
name|symlen
operator|+
literal|22
argument_list|)
expr_stmt|;
operator|*
name|msg
operator|=
literal|'`'
expr_stmt|;
name|bcopy
argument_list|(
name|mdef
operator|.
name|symnam
argument_list|,
name|msg
operator|+
literal|1
argument_list|,
name|mdef
operator|.
name|symlen
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|msg
operator|+
name|mdef
operator|.
name|symlen
operator|+
literal|1
operator|)
argument_list|,
literal|"' redefined"
argument_list|)
expr_stmt|;
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|type
operator|==
name|T_MACRO
condition|)
name|cpp_pedwarn_with_file_and_line
argument_list|(
name|pfile
argument_list|,
name|hp
operator|->
name|value
operator|.
name|defn
operator|->
name|file
argument_list|,
name|hp
operator|->
name|value
operator|.
name|defn
operator|->
name|line
argument_list|,
literal|"this is the location of the previous definition"
argument_list|)
expr_stmt|;
block|}
comment|/* Replace the old definition.  */
name|hp
operator|->
name|type
operator|=
name|T_MACRO
expr_stmt|;
name|hp
operator|->
name|value
operator|.
name|defn
operator|=
name|mdef
operator|.
name|defn
expr_stmt|;
block|}
else|else
block|{
comment|/* If we are passing through #define and #undef directives, do 	 that for this new definition now.  */
if|if
condition|(
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|debug_output
operator|&&
name|keyword
condition|)
name|pass_thru_directive
argument_list|(
name|buf
argument_list|,
name|limit
argument_list|,
name|pfile
argument_list|,
name|keyword
argument_list|)
expr_stmt|;
name|install
argument_list|(
name|mdef
operator|.
name|symnam
argument_list|,
name|mdef
operator|.
name|symlen
argument_list|,
name|T_MACRO
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|mdef
operator|.
name|defn
argument_list|,
name|hashcode
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
name|nope
label|:
return|return
literal|1
return|;
block|}
end_block

begin_comment
comment|/* This structure represents one parsed argument in a macro call.    `raw' points to the argument text as written (`raw_length' is its length).    `expanded' points to the argument's macro-expansion    (its length is `expand_length').    `stringified_length' is the length the argument would have    if stringified.    `use_count' is the number of times this macro arg is substituted    into the macro.  If the actual use count exceeds 10,     the value stored is 10.  */
end_comment

begin_comment
comment|/* raw and expanded are relative to ARG_BASE */
end_comment

begin_define
define|#
directive|define
name|ARG_BASE
value|((pfile)->token_buffer)
end_define

begin_struct
struct|struct
name|argdata
block|{
comment|/* Strings relative to pfile->token_buffer */
name|long
name|raw
decl_stmt|,
name|expanded
decl_stmt|,
name|stringified
decl_stmt|;
name|int
name|raw_length
decl_stmt|,
name|expand_length
decl_stmt|;
name|int
name|stringified_length
decl_stmt|;
name|char
name|newlines
decl_stmt|;
name|char
name|use_count
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Allocate a new cpp_buffer for PFILE, and push it on the input buffer stack.    If BUFFER != NULL, then use the LENGTH characters in BUFFER    as the new input buffer.    Return the new buffer, or NULL on failure.  */
end_comment

begin_function
name|cpp_buffer
modifier|*
name|cpp_push_buffer
parameter_list|(
name|pfile
parameter_list|,
name|buffer
parameter_list|,
name|length
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|U_CHAR
modifier|*
name|buffer
decl_stmt|;
name|long
name|length
decl_stmt|;
block|{
specifier|register
name|cpp_buffer
modifier|*
name|buf
init|=
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
if|if
condition|(
name|buf
operator|==
name|pfile
operator|->
name|buffer_stack
condition|)
block|{
name|cpp_fatal
argument_list|(
name|pfile
argument_list|,
literal|"%s: macro or `#include' recursion too deep"
argument_list|,
name|buf
operator|->
name|fname
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|buf
operator|--
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|cpp_buffer
argument_list|)
argument_list|)
expr_stmt|;
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|=
name|buf
expr_stmt|;
name|buf
operator|->
name|if_stack
operator|=
name|pfile
operator|->
name|if_stack
expr_stmt|;
name|buf
operator|->
name|cleanup
operator|=
name|null_cleanup
expr_stmt|;
name|buf
operator|->
name|underflow
operator|=
name|null_underflow
expr_stmt|;
name|buf
operator|->
name|buf
operator|=
name|buf
operator|->
name|cur
operator|=
name|buffer
expr_stmt|;
name|buf
operator|->
name|alimit
operator|=
name|buf
operator|->
name|rlimit
operator|=
name|buffer
operator|+
name|length
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_function
name|cpp_buffer
modifier|*
name|cpp_pop_buffer
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|cpp_buffer
modifier|*
name|buf
init|=
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
call|(
modifier|*
name|buf
operator|->
name|cleanup
call|)
argument_list|(
name|buf
argument_list|,
name|pfile
argument_list|)
expr_stmt|;
return|return
operator|++
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Scan until CPP_BUFFER (PFILE) is exhausted into PFILE->token_buffer.    Pop the buffer when done.  */
end_comment

begin_function
name|void
name|cpp_scan_buffer
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|cpp_buffer
modifier|*
name|buffer
init|=
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|enum
name|cpp_token
name|token
init|=
name|cpp_get_token
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
if|if
condition|(
name|token
operator|==
name|CPP_EOF
condition|)
comment|/* Should not happen ...  */
break|break;
if|if
condition|(
name|token
operator|==
name|CPP_POP
operator|&&
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|==
name|buffer
condition|)
block|{
name|cpp_pop_buffer
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Rescan a string (which may have escape marks) into pfile's buffer.  * Place the result in pfile->token_buffer.  *  * The input is copied before it is scanned, so it is safe to pass  * it something from the token_buffer that will get overwritten  * (because it follows CPP_WRITTEN).  This is used by do_include.  */
end_comment

begin_function
specifier|static
name|void
name|cpp_expand_to_buffer
parameter_list|(
name|pfile
parameter_list|,
name|buf
parameter_list|,
name|length
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|U_CHAR
modifier|*
name|buf
decl_stmt|;
name|int
name|length
decl_stmt|;
block|{
specifier|register
name|cpp_buffer
modifier|*
name|ip
decl_stmt|;
if|#
directive|if
literal|0
block|cpp_buffer obuf;
endif|#
directive|endif
name|U_CHAR
modifier|*
name|limit
init|=
name|buf
operator|+
name|length
decl_stmt|;
name|U_CHAR
modifier|*
name|buf1
decl_stmt|;
if|#
directive|if
literal|0
block|int odepth = indepth;
endif|#
directive|endif
if|if
condition|(
name|length
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Set up the input on the input stack.  */
name|buf1
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|alloca
argument_list|(
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
block|{
specifier|register
name|U_CHAR
modifier|*
name|p1
init|=
name|buf
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|p2
init|=
name|buf1
decl_stmt|;
while|while
condition|(
name|p1
operator|!=
name|limit
condition|)
operator|*
name|p2
operator|++
operator|=
operator|*
name|p1
operator|++
expr_stmt|;
block|}
name|buf1
index|[
name|length
index|]
operator|=
literal|0
expr_stmt|;
name|ip
operator|=
name|cpp_push_buffer
argument_list|(
name|pfile
argument_list|,
name|buf1
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|==
name|NULL
condition|)
return|return;
name|ip
operator|->
name|has_escapes
operator|=
literal|1
expr_stmt|;
if|#
directive|if
literal|0
block|ip->lineno = obuf.lineno = 1;
endif|#
directive|endif
comment|/* Scan the input, create the output.  */
name|cpp_scan_buffer
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (indepth != odepth)     abort ();
endif|#
directive|endif
name|CPP_NUL_TERMINATE
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|adjust_position
parameter_list|(
name|buf
parameter_list|,
name|limit
parameter_list|,
name|linep
parameter_list|,
name|colp
parameter_list|)
name|U_CHAR
modifier|*
name|buf
decl_stmt|;
name|U_CHAR
modifier|*
name|limit
decl_stmt|;
name|long
modifier|*
name|linep
decl_stmt|;
name|long
modifier|*
name|colp
decl_stmt|;
block|{
while|while
condition|(
name|buf
operator|<
name|limit
condition|)
block|{
name|U_CHAR
name|ch
init|=
operator|*
name|buf
operator|++
decl_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'\n'
condition|)
operator|(
operator|*
name|linep
operator|)
operator|++
operator|,
operator|(
operator|*
name|colp
operator|)
operator|=
literal|1
expr_stmt|;
else|else
operator|(
operator|*
name|colp
operator|)
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Move line_base forward, updating lineno and colno.  */
end_comment

begin_function
specifier|static
name|void
name|update_position
parameter_list|(
name|pbuf
parameter_list|)
specifier|register
name|cpp_buffer
modifier|*
name|pbuf
decl_stmt|;
block|{
name|unsigned
name|char
modifier|*
name|old_pos
init|=
name|pbuf
operator|->
name|buf
operator|+
name|pbuf
operator|->
name|line_base
decl_stmt|;
name|unsigned
name|char
modifier|*
name|new_pos
init|=
name|pbuf
operator|->
name|cur
decl_stmt|;
specifier|register
name|struct
name|parse_marker
modifier|*
name|mark
decl_stmt|;
for|for
control|(
name|mark
operator|=
name|pbuf
operator|->
name|marks
init|;
name|mark
operator|!=
name|NULL
condition|;
name|mark
operator|=
name|mark
operator|->
name|next
control|)
block|{
if|if
condition|(
name|pbuf
operator|->
name|buf
operator|+
name|mark
operator|->
name|position
operator|<
name|new_pos
condition|)
name|new_pos
operator|=
name|pbuf
operator|->
name|buf
operator|+
name|mark
operator|->
name|position
expr_stmt|;
block|}
name|pbuf
operator|->
name|line_base
operator|+=
name|new_pos
operator|-
name|old_pos
expr_stmt|;
name|adjust_position
argument_list|(
name|old_pos
argument_list|,
name|new_pos
argument_list|,
operator|&
name|pbuf
operator|->
name|lineno
argument_list|,
operator|&
name|pbuf
operator|->
name|colno
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cpp_buf_line_and_col
parameter_list|(
name|pbuf
parameter_list|,
name|linep
parameter_list|,
name|colp
parameter_list|)
specifier|register
name|cpp_buffer
modifier|*
name|pbuf
decl_stmt|;
name|long
modifier|*
name|linep
decl_stmt|,
decl|*
name|colp
decl_stmt|;
end_function

begin_block
block|{
name|long
name|dummy
decl_stmt|;
if|if
condition|(
name|colp
operator|==
name|NULL
condition|)
name|colp
operator|=
operator|&
name|dummy
expr_stmt|;
if|if
condition|(
name|pbuf
condition|)
block|{
operator|*
name|linep
operator|=
name|pbuf
operator|->
name|lineno
expr_stmt|;
operator|*
name|colp
operator|=
name|pbuf
operator|->
name|colno
expr_stmt|;
name|adjust_position
argument_list|(
name|pbuf
operator|->
name|buf
operator|+
name|pbuf
operator|->
name|line_base
argument_list|,
name|pbuf
operator|->
name|cur
argument_list|,
name|linep
argument_list|,
name|colp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|linep
operator|=
literal|0
expr_stmt|;
operator|*
name|colp
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Return the cpp_buffer that corresponds to a file (not a macro).  */
end_comment

begin_function
name|cpp_buffer
modifier|*
name|cpp_file_buffer
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|cpp_buffer
modifier|*
name|ip
init|=
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|ip
operator|!=
name|CPP_NULL_BUFFER
argument_list|(
name|pfile
argument_list|)
condition|;
name|ip
operator|=
name|CPP_PREV_BUFFER
argument_list|(
name|ip
argument_list|)
control|)
if|if
condition|(
name|ip
operator|->
name|fname
operator|!=
name|NULL
condition|)
return|return
name|ip
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|long
name|count_newlines
parameter_list|(
name|buf
parameter_list|,
name|limit
parameter_list|)
specifier|register
name|U_CHAR
modifier|*
name|buf
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|limit
decl_stmt|;
block|{
specifier|register
name|long
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|buf
operator|<
name|limit
condition|)
block|{
name|U_CHAR
name|ch
init|=
operator|*
name|buf
operator|++
decl_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'\n'
condition|)
name|count
operator|++
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/*  * write out a #line command, for instance, after an #include file.  * If CONDITIONAL is nonzero, we can omit the #line if it would  * appear to be a no-op, and we can output a few newlines instead  * if we want to increase the line number by a small amount.  * FILE_CHANGE says whether we are entering a file, leaving, or neither.  */
end_comment

begin_function
specifier|static
name|void
name|output_line_command
parameter_list|(
name|pfile
parameter_list|,
name|conditional
parameter_list|,
name|file_change
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|int
name|conditional
decl_stmt|;
name|enum
name|file_change_code
name|file_change
decl_stmt|;
block|{
name|long
name|line
decl_stmt|,
name|col
decl_stmt|;
name|cpp_buffer
modifier|*
name|ip
init|=
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
if|if
condition|(
name|ip
operator|->
name|fname
operator|==
name|NULL
condition|)
return|return;
name|update_position
argument_list|(
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|no_line_commands
operator|||
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|no_output
condition|)
return|return;
name|line
operator|=
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|->
name|lineno
expr_stmt|;
name|col
operator|=
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|->
name|colno
expr_stmt|;
name|adjust_position
argument_list|(
name|CPP_LINE_BASE
argument_list|(
name|ip
argument_list|)
argument_list|,
name|ip
operator|->
name|cur
argument_list|,
operator|&
name|line
argument_list|,
operator|&
name|col
argument_list|)
expr_stmt|;
if|if
condition|(
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|no_line_commands
condition|)
return|return;
if|if
condition|(
name|conditional
condition|)
block|{
if|if
condition|(
name|line
operator|==
name|pfile
operator|->
name|lineno
condition|)
return|return;
comment|/* If the inherited line number is a little too small,        output some newlines instead of a #line command.  */
if|if
condition|(
name|line
operator|>
name|pfile
operator|->
name|lineno
operator|&&
name|line
operator|<
name|pfile
operator|->
name|lineno
operator|+
literal|8
condition|)
block|{
name|CPP_RESERVE
argument_list|(
name|pfile
argument_list|,
literal|20
argument_list|)
expr_stmt|;
while|while
condition|(
name|line
operator|>
name|pfile
operator|->
name|lineno
condition|)
block|{
name|CPP_PUTC_Q
argument_list|(
name|pfile
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|lineno
operator|++
expr_stmt|;
block|}
return|return;
block|}
block|}
if|#
directive|if
literal|0
comment|/* Don't output a line number of 0 if we can help it.  */
block|if (ip->lineno == 0&& ip->bufp - ip->buf< ip->length&& *ip->bufp == '\n') {     ip->lineno++;     ip->bufp++;   }
endif|#
directive|endif
name|CPP_RESERVE
argument_list|(
name|pfile
argument_list|,
literal|4
operator|*
name|strlen
argument_list|(
name|ip
operator|->
name|nominal_fname
argument_list|)
operator|+
literal|50
argument_list|)
expr_stmt|;
block|{
ifdef|#
directive|ifdef
name|OUTPUT_LINE_COMMANDS
specifier|static
name|char
name|sharp_line
index|[]
init|=
literal|"#line "
decl_stmt|;
else|#
directive|else
specifier|static
name|char
name|sharp_line
index|[]
init|=
literal|"# "
decl_stmt|;
endif|#
directive|endif
name|CPP_PUTS_Q
argument_list|(
name|pfile
argument_list|,
name|sharp_line
argument_list|,
sizeof|sizeof
argument_list|(
name|sharp_line
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|CPP_PWRITTEN
argument_list|(
name|pfile
argument_list|)
argument_list|,
literal|"%ld "
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|CPP_ADJUST_WRITTEN
argument_list|(
name|pfile
argument_list|,
name|strlen
argument_list|(
name|CPP_PWRITTEN
argument_list|(
name|pfile
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|quote_string
argument_list|(
name|pfile
argument_list|,
name|ip
operator|->
name|nominal_fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|file_change
operator|!=
name|same_file
condition|)
block|{
name|CPP_PUTC_Q
argument_list|(
name|pfile
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|CPP_PUTC_Q
argument_list|(
name|pfile
argument_list|,
name|file_change
operator|==
name|enter_file
condition|?
literal|'1'
else|:
literal|'2'
argument_list|)
expr_stmt|;
block|}
comment|/* Tell cc1 if following text comes from a system header file.  */
if|if
condition|(
name|ip
operator|->
name|system_header_p
condition|)
block|{
name|CPP_PUTC_Q
argument_list|(
name|pfile
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|CPP_PUTC_Q
argument_list|(
name|pfile
argument_list|,
literal|'3'
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|NO_IMPLICIT_EXTERN_C
comment|/* Tell cc1plus if following text should be treated as C.  */
if|if
condition|(
name|ip
operator|->
name|system_header_p
operator|==
literal|2
operator|&&
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|cplusplus
condition|)
block|{
name|CPP_PUTC_Q
argument_list|(
name|pfile
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|CPP_PUTC_Q
argument_list|(
name|pfile
argument_list|,
literal|'4'
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|CPP_PUTC_Q
argument_list|(
name|pfile
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|lineno
operator|=
name|line
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Parse a macro argument and append the info on PFILE's token_buffer.  * REST_ARGS means to absorb the rest of the args.  * Return nonzero to indicate a syntax error.  */
end_comment

begin_function
specifier|static
name|enum
name|cpp_token
name|macarg
parameter_list|(
name|pfile
parameter_list|,
name|rest_args
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|int
name|rest_args
decl_stmt|;
block|{
name|int
name|paren
init|=
literal|0
decl_stmt|;
name|enum
name|cpp_token
name|token
decl_stmt|;
name|char
name|save_put_out_comments
init|=
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|put_out_comments
decl_stmt|;
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|put_out_comments
operator|=
literal|0
expr_stmt|;
comment|/* Try to parse as much of the argument as exists at this      input stack level.  */
name|pfile
operator|->
name|no_macro_expand
operator|++
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|token
operator|=
name|cpp_get_token
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|token
condition|)
block|{
case|case
name|CPP_EOF
case|:
goto|goto
name|done
goto|;
case|case
name|CPP_POP
case|:
comment|/* If we've hit end of file, it's an error (reported by caller). 	     Ditto if it's the end of cpp_expand_to_buffer text. 	     If we've hit end of macro, just continue.  */
if|if
condition|(
operator|!
name|CPP_IS_MACRO_BUFFER
argument_list|(
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
argument_list|)
condition|)
goto|goto
name|done
goto|;
break|break;
case|case
name|CPP_LPAREN
case|:
name|paren
operator|++
expr_stmt|;
break|break;
case|case
name|CPP_RPAREN
case|:
if|if
condition|(
operator|--
name|paren
operator|<
literal|0
condition|)
goto|goto
name|found
goto|;
break|break;
case|case
name|CPP_COMMA
case|:
comment|/* if we've returned to lowest level and 	     we aren't absorbing all args */
if|if
condition|(
name|paren
operator|==
literal|0
operator|&&
name|rest_args
operator|==
literal|0
condition|)
goto|goto
name|found
goto|;
break|break;
name|found
label|:
comment|/* Remove ',' or ')' from argument buffer.  */
name|CPP_ADJUST_WRITTEN
argument_list|(
name|pfile
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
default|default:
empty_stmt|;
block|}
block|}
name|done
label|:
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|put_out_comments
operator|=
name|save_put_out_comments
expr_stmt|;
name|pfile
operator|->
name|no_macro_expand
operator|--
expr_stmt|;
return|return
name|token
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Turn newlines to spaces in the string of length LENGTH at START,    except inside of string constants.    The string is copied into itself with its beginning staying fixed.  */
end_comment

begin_function
specifier|static
name|int
name|change_newlines
parameter_list|(
name|start
parameter_list|,
name|length
parameter_list|)
name|U_CHAR
modifier|*
name|start
decl_stmt|;
name|int
name|length
decl_stmt|;
block|{
specifier|register
name|U_CHAR
modifier|*
name|ibp
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|obp
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|limit
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|ibp
operator|=
name|start
expr_stmt|;
name|limit
operator|=
name|start
operator|+
name|length
expr_stmt|;
name|obp
operator|=
name|start
expr_stmt|;
while|while
condition|(
name|ibp
operator|<
name|limit
condition|)
block|{
operator|*
name|obp
operator|++
operator|=
name|c
operator|=
operator|*
name|ibp
operator|++
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\''
case|:
case|case
literal|'\"'
case|:
comment|/* Notice and skip strings, so that we don't delete newlines in them.  */
block|{
name|int
name|quotec
init|=
name|c
decl_stmt|;
while|while
condition|(
name|ibp
operator|<
name|limit
condition|)
block|{
operator|*
name|obp
operator|++
operator|=
name|c
operator|=
operator|*
name|ibp
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|quotec
condition|)
break|break;
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|&&
name|quotec
operator|==
literal|'\''
condition|)
break|break;
block|}
block|}
break|break;
block|}
block|}
return|return
name|obp
operator|-
name|start
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|struct
name|tm
modifier|*
name|timestamp
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|pfile
operator|->
name|timebuf
condition|)
block|{
name|time_t
name|t
init|=
name|time
argument_list|(
operator|(
name|time_t
operator|*
operator|)
literal|0
argument_list|)
decl_stmt|;
name|pfile
operator|->
name|timebuf
operator|=
name|localtime
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
block|}
return|return
name|pfile
operator|->
name|timebuf
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
modifier|*
name|monthnames
index|[]
init|=
block|{
literal|"Jan"
block|,
literal|"Feb"
block|,
literal|"Mar"
block|,
literal|"Apr"
block|,
literal|"May"
block|,
literal|"Jun"
block|,
literal|"Jul"
block|,
literal|"Aug"
block|,
literal|"Sep"
block|,
literal|"Oct"
block|,
literal|"Nov"
block|,
literal|"Dec"
block|, 			    }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * expand things like __FILE__.  Place the expansion into the output  * buffer *without* rescanning.  */
end_comment

begin_function
specifier|static
name|void
name|special_symbol
parameter_list|(
name|hp
parameter_list|,
name|pfile
parameter_list|)
name|HASHNODE
modifier|*
name|hp
decl_stmt|;
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|true_indepth
decl_stmt|;
name|cpp_buffer
modifier|*
name|ip
init|=
name|NULL
decl_stmt|;
name|struct
name|tm
modifier|*
name|timebuf
decl_stmt|;
name|int
name|paren
init|=
literal|0
decl_stmt|;
comment|/* For special `defined' keyword */
if|#
directive|if
literal|0
block|if (pcp_outfile&& pcp_inside_if&& hp->type != T_SPEC_DEFINED&& hp->type != T_CONST)     cpp_error (pfile, 	       "Predefined macro `%s' used inside `#if' during precompilation", 	       hp->name);
endif|#
directive|endif
for|for
control|(
name|ip
operator|=
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
init|;
condition|;
name|ip
operator|=
name|CPP_PREV_BUFFER
argument_list|(
name|ip
argument_list|)
control|)
block|{
if|if
condition|(
name|ip
operator|==
name|CPP_NULL_BUFFER
argument_list|(
name|pfile
argument_list|)
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"cccp error: not in any file?!"
argument_list|)
expr_stmt|;
return|return;
comment|/* the show must go on */
block|}
if|if
condition|(
name|ip
operator|->
name|fname
operator|!=
name|NULL
condition|)
break|break;
block|}
switch|switch
condition|(
name|hp
operator|->
name|type
condition|)
block|{
case|case
name|T_FILE
case|:
case|case
name|T_BASE_FILE
case|:
block|{
name|char
modifier|*
name|string
decl_stmt|;
if|if
condition|(
name|hp
operator|->
name|type
operator|==
name|T_BASE_FILE
condition|)
block|{
while|while
condition|(
name|CPP_PREV_BUFFER
argument_list|(
name|ip
argument_list|)
operator|!=
name|CPP_NULL_BUFFER
argument_list|(
name|pfile
argument_list|)
condition|)
name|ip
operator|=
name|CPP_PREV_BUFFER
argument_list|(
name|ip
argument_list|)
expr_stmt|;
block|}
name|string
operator|=
name|ip
operator|->
name|nominal_fname
expr_stmt|;
if|if
condition|(
operator|!
name|string
condition|)
name|string
operator|=
literal|""
expr_stmt|;
name|CPP_RESERVE
argument_list|(
name|pfile
argument_list|,
literal|3
operator|+
literal|4
operator|*
name|strlen
argument_list|(
name|string
argument_list|)
argument_list|)
expr_stmt|;
name|quote_string
argument_list|(
name|pfile
argument_list|,
name|string
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|T_INCLUDE_LEVEL
case|:
name|true_indepth
operator|=
literal|0
expr_stmt|;
name|ip
operator|=
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|ip
operator|!=
name|CPP_NULL_BUFFER
argument_list|(
name|pfile
argument_list|)
condition|;
name|ip
operator|=
name|CPP_PREV_BUFFER
argument_list|(
name|ip
argument_list|)
control|)
if|if
condition|(
name|ip
operator|->
name|fname
operator|!=
name|NULL
condition|)
name|true_indepth
operator|++
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|8
argument_list|)
expr_stmt|;
comment|/* Eight bytes ought to be more than enough */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
name|true_indepth
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_VERSION
case|:
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|3
operator|+
name|strlen
argument_list|(
name|version_string
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"\"%s\""
argument_list|,
name|version_string
argument_list|)
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|NO_BUILTIN_SIZE_TYPE
case|case
name|T_SIZE_TYPE
case|:
name|buf
operator|=
name|SIZE_TYPE
expr_stmt|;
break|break;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_BUILTIN_PTRDIFF_TYPE
case|case
name|T_PTRDIFF_TYPE
case|:
name|buf
operator|=
name|PTRDIFF_TYPE
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|T_WCHAR_TYPE
case|:
name|buf
operator|=
name|CPP_WCHAR_TYPE
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_USER_LABEL_PREFIX_TYPE
case|:
name|buf
operator|=
name|USER_LABEL_PREFIX
expr_stmt|;
break|break;
case|case
name|T_REGISTER_PREFIX_TYPE
case|:
name|buf
operator|=
name|REGISTER_PREFIX
expr_stmt|;
break|break;
case|case
name|T_CONST
case|:
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|4
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
name|hp
operator|->
name|value
operator|.
name|ival
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|STDC_0_IN_SYSTEM_HEADERS
if|if
condition|(
name|ip
operator|->
name|system_header_p
operator|&&
name|hp
operator|->
name|length
operator|==
literal|8
operator|&&
name|bcmp
argument_list|(
name|hp
operator|->
name|name
argument_list|,
literal|"__STDC__"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|cpp_lookup
argument_list|(
name|pfile
argument_list|,
operator|(
name|U_CHAR
operator|*
operator|)
literal|"__STRICT_ANSI__"
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
literal|0
block|if (pcp_inside_if&& pcp_outfile)
comment|/* Output a precondition for this macro use */
block|fprintf (pcp_outfile, "#define %s %d\n", hp->name, hp->value.ival);
endif|#
directive|endif
break|break;
case|case
name|T_SPECLINE
case|:
block|{
name|long
name|line
init|=
name|ip
operator|->
name|lineno
decl_stmt|;
name|long
name|col
init|=
name|ip
operator|->
name|colno
decl_stmt|;
name|adjust_position
argument_list|(
name|CPP_LINE_BASE
argument_list|(
name|ip
argument_list|)
argument_list|,
name|ip
operator|->
name|cur
argument_list|,
operator|&
name|line
argument_list|,
operator|&
name|col
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%ld"
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|T_DATE
case|:
case|case
name|T_TIME
case|:
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|timebuf
operator|=
name|timestamp
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|type
operator|==
name|T_DATE
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"\"%s %2d %4d\""
argument_list|,
name|monthnames
index|[
name|timebuf
operator|->
name|tm_mon
index|]
argument_list|,
name|timebuf
operator|->
name|tm_mday
argument_list|,
name|timebuf
operator|->
name|tm_year
operator|+
literal|1900
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"\"%02d:%02d:%02d\""
argument_list|,
name|timebuf
operator|->
name|tm_hour
argument_list|,
name|timebuf
operator|->
name|tm_min
argument_list|,
name|timebuf
operator|->
name|tm_sec
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_SPEC_DEFINED
case|:
name|buf
operator|=
literal|" 0 "
expr_stmt|;
comment|/* Assume symbol is not defined */
name|ip
operator|=
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|ip
operator|->
name|cur
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ip
operator|->
name|cur
operator|==
literal|'('
condition|)
block|{
name|paren
operator|++
expr_stmt|;
name|ip
operator|->
name|cur
operator|++
expr_stmt|;
comment|/* Skip over the paren */
name|SKIP_WHITE_SPACE
argument_list|(
name|ip
operator|->
name|cur
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|is_idstart
index|[
operator|*
name|ip
operator|->
name|cur
index|]
condition|)
goto|goto
name|oops
goto|;
if|if
condition|(
name|ip
operator|->
name|cur
index|[
literal|0
index|]
operator|==
literal|'L'
operator|&&
operator|(
name|ip
operator|->
name|cur
index|[
literal|1
index|]
operator|==
literal|'\''
operator|||
name|ip
operator|->
name|cur
index|[
literal|1
index|]
operator|==
literal|'"'
operator|)
condition|)
goto|goto
name|oops
goto|;
if|if
condition|(
operator|(
name|hp
operator|=
name|cpp_lookup
argument_list|(
name|pfile
argument_list|,
name|ip
operator|->
name|cur
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
operator|)
condition|)
block|{
if|#
directive|if
literal|0
block|if (pcp_outfile&& pcp_inside_if&& (hp->type == T_CONST 		  || (hp->type == T_MACRO&& hp->value.defn->predefined)))
comment|/* Output a precondition for this macro use.  */
block|fprintf (pcp_outfile, "#define %s\n", hp->name);
endif|#
directive|endif
name|buf
operator|=
literal|" 1 "
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|else 	if (pcp_outfile&& pcp_inside_if) 	  {
comment|/* Output a precondition for this macro use */
block|U_CHAR *cp = ip->bufp; 	    fprintf (pcp_outfile, "#undef "); 	    while (is_idchar[*cp])
comment|/* Ick! */
block|fputc (*cp++, pcp_outfile); 	    putc ('\n', pcp_outfile); 	  }
endif|#
directive|endif
while|while
condition|(
name|is_idchar
index|[
operator|*
name|ip
operator|->
name|cur
index|]
condition|)
operator|++
name|ip
operator|->
name|cur
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|ip
operator|->
name|cur
argument_list|)
expr_stmt|;
if|if
condition|(
name|paren
condition|)
block|{
if|if
condition|(
operator|*
name|ip
operator|->
name|cur
operator|!=
literal|')'
condition|)
goto|goto
name|oops
goto|;
operator|++
name|ip
operator|->
name|cur
expr_stmt|;
block|}
break|break;
name|oops
label|:
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"`defined' without an identifier"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"cccp error: invalid special hash type"
argument_list|)
expr_stmt|;
comment|/* time for gdb */
name|abort
argument_list|()
expr_stmt|;
block|}
name|len
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|CPP_RESERVE
argument_list|(
name|pfile
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|CPP_PUTS_Q
argument_list|(
name|pfile
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|CPP_NUL_TERMINATE_Q
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Write out a #define command for the special named MACRO_NAME    to PFILE's token_buffer.  */
end_comment

begin_function
specifier|static
name|void
name|dump_special_to_buffer
parameter_list|(
name|pfile
parameter_list|,
name|macro_name
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|char
modifier|*
name|macro_name
decl_stmt|;
block|{
specifier|static
name|char
name|define_directive
index|[]
init|=
literal|"#define "
decl_stmt|;
name|int
name|macro_name_length
init|=
name|strlen
argument_list|(
name|macro_name
argument_list|)
decl_stmt|;
name|output_line_command
argument_list|(
name|pfile
argument_list|,
literal|0
argument_list|,
name|same_file
argument_list|)
expr_stmt|;
name|CPP_RESERVE
argument_list|(
name|pfile
argument_list|,
sizeof|sizeof
argument_list|(
name|define_directive
argument_list|)
operator|+
name|macro_name_length
argument_list|)
expr_stmt|;
name|CPP_PUTS_Q
argument_list|(
name|pfile
argument_list|,
name|define_directive
argument_list|,
sizeof|sizeof
argument_list|(
name|define_directive
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|CPP_PUTS_Q
argument_list|(
name|pfile
argument_list|,
name|macro_name
argument_list|,
name|macro_name_length
argument_list|)
expr_stmt|;
name|CPP_PUTC_Q
argument_list|(
name|pfile
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|cpp_expand_to_buffer
argument_list|(
name|pfile
argument_list|,
name|macro_name
argument_list|,
name|macro_name_length
argument_list|)
expr_stmt|;
name|CPP_PUTC
argument_list|(
name|pfile
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize the built-in macros.  */
end_comment

begin_function
specifier|static
name|void
name|initialize_builtins
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|install
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|)
literal|"__LINE__"
argument_list|,
operator|-
literal|1
argument_list|,
name|T_SPECLINE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|install
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|)
literal|"__DATE__"
argument_list|,
operator|-
literal|1
argument_list|,
name|T_DATE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|install
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|)
literal|"__FILE__"
argument_list|,
operator|-
literal|1
argument_list|,
name|T_FILE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|install
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|)
literal|"__BASE_FILE__"
argument_list|,
operator|-
literal|1
argument_list|,
name|T_BASE_FILE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|install
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|)
literal|"__INCLUDE_LEVEL__"
argument_list|,
operator|-
literal|1
argument_list|,
name|T_INCLUDE_LEVEL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|install
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|)
literal|"__VERSION__"
argument_list|,
operator|-
literal|1
argument_list|,
name|T_VERSION
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_BUILTIN_SIZE_TYPE
name|install
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|)
literal|"__SIZE_TYPE__"
argument_list|,
operator|-
literal|1
argument_list|,
name|T_SIZE_TYPE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_BUILTIN_PTRDIFF_TYPE
name|install
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|)
literal|"__PTRDIFF_TYPE__ "
argument_list|,
operator|-
literal|1
argument_list|,
name|T_PTRDIFF_TYPE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|install
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|)
literal|"__WCHAR_TYPE__"
argument_list|,
operator|-
literal|1
argument_list|,
name|T_WCHAR_TYPE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|install
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|)
literal|"__USER_LABEL_PREFIX__"
argument_list|,
operator|-
literal|1
argument_list|,
name|T_USER_LABEL_PREFIX_TYPE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|install
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|)
literal|"__REGISTER_PREFIX__"
argument_list|,
operator|-
literal|1
argument_list|,
name|T_REGISTER_PREFIX_TYPE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|install
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|)
literal|"__TIME__"
argument_list|,
operator|-
literal|1
argument_list|,
name|T_TIME
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CPP_TRADITIONAL
argument_list|(
name|pfile
argument_list|)
condition|)
name|install
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|)
literal|"__STDC__"
argument_list|,
operator|-
literal|1
argument_list|,
name|T_CONST
argument_list|,
name|STDC_VALUE
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|objc
condition|)
name|install
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|)
literal|"__OBJC__"
argument_list|,
operator|-
literal|1
argument_list|,
name|T_CONST
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/*  This is supplied using a -D by the compiler driver     so that it is present only when truly compiling with GNU C.  */
comment|/*  install ("__GNUC__", -1, T_CONST, 2, 0, -1);  */
if|if
condition|(
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|debug_output
condition|)
block|{
name|dump_special_to_buffer
argument_list|(
name|pfile
argument_list|,
literal|"__BASE_FILE__"
argument_list|)
expr_stmt|;
name|dump_special_to_buffer
argument_list|(
name|pfile
argument_list|,
literal|"__VERSION__"
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_BUILTIN_SIZE_TYPE
name|dump_special_to_buffer
argument_list|(
name|pfile
argument_list|,
literal|"__SIZE_TYPE__"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_BUILTIN_PTRDIFF_TYPE
name|dump_special_to_buffer
argument_list|(
name|pfile
argument_list|,
literal|"__PTRDIFF_TYPE__"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dump_special_to_buffer
argument_list|(
name|pfile
argument_list|,
literal|"__WCHAR_TYPE__"
argument_list|)
expr_stmt|;
name|dump_special_to_buffer
argument_list|(
name|pfile
argument_list|,
literal|"__DATE__"
argument_list|)
expr_stmt|;
name|dump_special_to_buffer
argument_list|(
name|pfile
argument_list|,
literal|"__TIME__"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CPP_TRADITIONAL
argument_list|(
name|pfile
argument_list|)
condition|)
name|dump_special_to_buffer
argument_list|(
name|pfile
argument_list|,
literal|"__STDC__"
argument_list|)
expr_stmt|;
if|if
condition|(
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|objc
condition|)
name|dump_special_to_buffer
argument_list|(
name|pfile
argument_list|,
literal|"__OBJC__"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 iff a token ending in C1 followed directly by a token C2    could cause mis-tokenization.  */
end_comment

begin_function
specifier|static
name|int
name|unsafe_chars
parameter_list|(
name|c1
parameter_list|,
name|c2
parameter_list|)
name|int
name|c1
decl_stmt|,
name|c2
decl_stmt|;
block|{
switch|switch
condition|(
name|c1
condition|)
block|{
case|case
literal|'+'
case|:
case|case
literal|'-'
case|:
if|if
condition|(
name|c2
operator|==
name|c1
operator|||
name|c2
operator|==
literal|'='
condition|)
return|return
literal|1
return|;
goto|goto
name|letter
goto|;
case|case
literal|'.'
case|:
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
case|case
literal|'e'
case|:
case|case
literal|'E'
case|:
case|case
literal|'p'
case|:
case|case
literal|'P'
case|:
if|if
condition|(
name|c2
operator|==
literal|'-'
operator|||
name|c2
operator|==
literal|'+'
condition|)
return|return
literal|1
return|;
comment|/* could extend a pre-processing number */
goto|goto
name|letter
goto|;
case|case
literal|'L'
case|:
if|if
condition|(
name|c2
operator|==
literal|'\''
operator|||
name|c2
operator|==
literal|'\"'
condition|)
return|return
literal|1
return|;
comment|/* Could turn into L"xxx" or L'xxx'.  */
goto|goto
name|letter
goto|;
name|letter
label|:
case|case
literal|'_'
case|:
case|case
literal|'a'
case|:
case|case
literal|'b'
case|:
case|case
literal|'c'
case|:
case|case
literal|'d'
case|:
case|case
literal|'f'
case|:
case|case
literal|'g'
case|:
case|case
literal|'h'
case|:
case|case
literal|'i'
case|:
case|case
literal|'j'
case|:
case|case
literal|'k'
case|:
case|case
literal|'l'
case|:
case|case
literal|'m'
case|:
case|case
literal|'n'
case|:
case|case
literal|'o'
case|:
case|case
literal|'q'
case|:
case|case
literal|'r'
case|:
case|case
literal|'s'
case|:
case|case
literal|'t'
case|:
case|case
literal|'u'
case|:
case|case
literal|'v'
case|:
case|case
literal|'w'
case|:
case|case
literal|'x'
case|:
case|case
literal|'y'
case|:
case|case
literal|'z'
case|:
case|case
literal|'A'
case|:
case|case
literal|'B'
case|:
case|case
literal|'C'
case|:
case|case
literal|'D'
case|:
case|case
literal|'F'
case|:
case|case
literal|'G'
case|:
case|case
literal|'H'
case|:
case|case
literal|'I'
case|:
case|case
literal|'J'
case|:
case|case
literal|'K'
case|:
case|case
literal|'M'
case|:
case|case
literal|'N'
case|:
case|case
literal|'O'
case|:
case|case
literal|'Q'
case|:
case|case
literal|'R'
case|:
case|case
literal|'S'
case|:
case|case
literal|'T'
case|:
case|case
literal|'U'
case|:
case|case
literal|'V'
case|:
case|case
literal|'W'
case|:
case|case
literal|'X'
case|:
case|case
literal|'Y'
case|:
case|case
literal|'Z'
case|:
comment|/* We're in the middle of either a name or a pre-processing number.  */
return|return
operator|(
name|is_idchar
index|[
name|c2
index|]
operator|||
name|c2
operator|==
literal|'.'
operator|)
return|;
case|case
literal|'<'
case|:
case|case
literal|'>'
case|:
case|case
literal|'!'
case|:
case|case
literal|'%'
case|:
case|case
literal|'#'
case|:
case|case
literal|':'
case|:
case|case
literal|'^'
case|:
case|case
literal|'&'
case|:
case|case
literal|'|'
case|:
case|case
literal|'*'
case|:
case|case
literal|'/'
case|:
case|case
literal|'='
case|:
return|return
operator|(
name|c2
operator|==
name|c1
operator|||
name|c2
operator|==
literal|'='
operator|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Expand a macro call.    HP points to the symbol that is the macro being called.    Put the result of expansion onto the input stack    so that subsequent input by our caller will use it.     If macro wants arguments, caller has already verified that    an argument list follows; arguments come from the input stack.  */
end_comment

begin_function
specifier|static
name|void
name|macroexpand
parameter_list|(
name|pfile
parameter_list|,
name|hp
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|HASHNODE
modifier|*
name|hp
decl_stmt|;
block|{
name|int
name|nargs
decl_stmt|;
name|DEFINITION
modifier|*
name|defn
init|=
name|hp
operator|->
name|value
operator|.
name|defn
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|xbuf
decl_stmt|;
name|long
name|start_line
decl_stmt|,
name|start_column
decl_stmt|;
name|int
name|xbuf_len
decl_stmt|;
name|struct
name|argdata
modifier|*
name|args
decl_stmt|;
name|long
name|old_written
init|=
name|CPP_WRITTEN
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
if|#
directive|if
literal|0
block|int start_line = instack[indepth].lineno;
endif|#
directive|endif
name|int
name|rest_args
decl_stmt|,
name|rest_zero
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|#
directive|if
literal|0
block|CHECK_DEPTH (return;);
endif|#
directive|endif
if|#
directive|if
literal|0
comment|/* This macro is being used inside a #if, which means it must be */
comment|/* recorded as a precondition.  */
block|if (pcp_inside_if&& pcp_outfile&& defn->predefined)     dump_single_macro (hp, pcp_outfile);
endif|#
directive|endif
name|pfile
operator|->
name|output_escapes
operator|++
expr_stmt|;
name|cpp_buf_line_and_col
argument_list|(
name|cpp_file_buffer
argument_list|(
name|pfile
argument_list|)
argument_list|,
operator|&
name|start_line
argument_list|,
operator|&
name|start_column
argument_list|)
expr_stmt|;
name|nargs
operator|=
name|defn
operator|->
name|nargs
expr_stmt|;
if|if
condition|(
name|nargs
operator|>=
literal|0
condition|)
block|{
name|enum
name|cpp_token
name|token
decl_stmt|;
name|args
operator|=
operator|(
expr|struct
name|argdata
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|nargs
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|argdata
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nargs
condition|;
name|i
operator|++
control|)
block|{
name|args
index|[
name|i
index|]
operator|.
name|raw
operator|=
name|args
index|[
name|i
index|]
operator|.
name|expanded
operator|=
literal|0
expr_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|raw_length
operator|=
literal|0
expr_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|expand_length
operator|=
name|args
index|[
name|i
index|]
operator|.
name|stringified_length
operator|=
operator|-
literal|1
expr_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|use_count
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Parse all the macro args that are supplied.  I counts them. 	 The first NARGS args are stored in ARGS. 	 The rest are discarded.  If rest_args is set then we assume 	 macarg absorbed the rest of the args.  */
name|i
operator|=
literal|0
expr_stmt|;
name|rest_args
operator|=
literal|0
expr_stmt|;
name|rest_args
operator|=
literal|0
expr_stmt|;
name|FORWARD
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Discard the open-parenthesis before the first arg.  */
do|do
block|{
if|if
condition|(
name|rest_args
condition|)
continue|continue;
if|if
condition|(
name|i
operator|<
name|nargs
operator|||
operator|(
name|nargs
operator|==
literal|0
operator|&&
name|i
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* if we are working on last arg which absorbs rest of args... */
if|if
condition|(
name|i
operator|==
name|nargs
operator|-
literal|1
operator|&&
name|defn
operator|->
name|rest_args
condition|)
name|rest_args
operator|=
literal|1
expr_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|raw
operator|=
name|CPP_WRITTEN
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|token
operator|=
name|macarg
argument_list|(
name|pfile
argument_list|,
name|rest_args
argument_list|)
expr_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|raw_length
operator|=
name|CPP_WRITTEN
argument_list|(
name|pfile
argument_list|)
operator|-
name|args
index|[
name|i
index|]
operator|.
name|raw
expr_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|newlines
operator|=
literal|0
expr_stmt|;
comment|/* FIXME */
block|}
else|else
name|token
operator|=
name|macarg
argument_list|(
name|pfile
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|CPP_EOF
operator|||
name|token
operator|==
name|CPP_POP
condition|)
block|{
name|cpp_error_with_line
argument_list|(
name|pfile
argument_list|,
name|start_line
argument_list|,
name|start_column
argument_list|,
literal|"unterminated macro call"
argument_list|)
expr_stmt|;
return|return;
block|}
name|i
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|token
operator|==
name|CPP_COMMA
condition|)
do|;
comment|/* If we got one arg but it was just whitespace, call that 0 args.  */
if|if
condition|(
name|i
operator|==
literal|1
condition|)
block|{
specifier|register
name|U_CHAR
modifier|*
name|bp
init|=
name|ARG_BASE
operator|+
name|args
index|[
literal|0
index|]
operator|.
name|raw
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|lim
init|=
name|bp
operator|+
name|args
index|[
literal|0
index|]
operator|.
name|raw_length
decl_stmt|;
comment|/* cpp.texi says for foo ( ) we provide one argument. 	     However, if foo wants just 0 arguments, treat this as 0.  */
if|if
condition|(
name|nargs
operator|==
literal|0
condition|)
while|while
condition|(
name|bp
operator|!=
name|lim
operator|&&
name|is_space
index|[
operator|*
name|bp
index|]
condition|)
name|bp
operator|++
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|lim
condition|)
name|i
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Don't output an error message if we have already output one for 	 a parse error above.  */
name|rest_zero
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nargs
operator|==
literal|0
operator|&&
name|i
operator|>
literal|0
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"arguments given to macro `%s'"
argument_list|,
name|hp
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|<
name|nargs
condition|)
block|{
comment|/* traditional C allows foo() if foo wants one argument.  */
if|if
condition|(
name|nargs
operator|==
literal|1
operator|&&
name|i
operator|==
literal|0
operator|&&
name|CPP_TRADITIONAL
argument_list|(
name|pfile
argument_list|)
condition|)
empty_stmt|;
comment|/* the rest args token is allowed to absorb 0 tokens */
elseif|else
if|if
condition|(
name|i
operator|==
name|nargs
operator|-
literal|1
operator|&&
name|defn
operator|->
name|rest_args
condition|)
name|rest_zero
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"macro `%s' used without args"
argument_list|,
name|hp
operator|->
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
literal|1
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"macro `%s' used with just one arg"
argument_list|,
name|hp
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"macro `%s' used with only %d args"
argument_list|,
name|hp
operator|->
name|name
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|>
name|nargs
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"macro `%s' used with too many (%d) args"
argument_list|,
name|hp
operator|->
name|name
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If macro wants zero args, we parsed the arglist for checking only.      Read directly from the macro definition.  */
if|if
condition|(
name|nargs
operator|<=
literal|0
condition|)
block|{
name|xbuf
operator|=
name|defn
operator|->
name|expansion
expr_stmt|;
name|xbuf_len
operator|=
name|defn
operator|->
name|length
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|U_CHAR
modifier|*
name|exp
init|=
name|defn
operator|->
name|expansion
decl_stmt|;
specifier|register
name|int
name|offset
decl_stmt|;
comment|/* offset in expansion, 				   copied a piece at a time */
specifier|register
name|int
name|totlen
decl_stmt|;
comment|/* total amount of exp buffer filled so far */
specifier|register
name|struct
name|reflist
modifier|*
name|ap
decl_stmt|,
modifier|*
name|last_ap
decl_stmt|;
comment|/* Macro really takes args.  Compute the expansion of this call.  */
comment|/* Compute length in characters of the macro's expansion. 	 Also count number of times each arg is used.  */
name|xbuf_len
operator|=
name|defn
operator|->
name|length
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|defn
operator|->
name|pattern
init|;
name|ap
operator|!=
name|NULL
condition|;
name|ap
operator|=
name|ap
operator|->
name|next
control|)
block|{
if|if
condition|(
name|ap
operator|->
name|stringify
condition|)
block|{
specifier|register
name|struct
name|argdata
modifier|*
name|arg
init|=
operator|&
name|args
index|[
name|ap
operator|->
name|argno
index|]
decl_stmt|;
comment|/* Stringify if it hasn't already been */
if|if
condition|(
name|arg
operator|->
name|stringified_length
operator|<
literal|0
condition|)
block|{
name|int
name|arglen
init|=
name|arg
operator|->
name|raw_length
decl_stmt|;
name|int
name|escaped
init|=
literal|0
decl_stmt|;
name|int
name|in_string
init|=
literal|0
decl_stmt|;
name|int
name|c
decl_stmt|;
comment|/* Initially need_space is -1.  Otherwise, 1 means the 		     previous character was a space, but we suppressed it; 		     0 means the previous character was a non-space.  */
name|int
name|need_space
init|=
operator|-
literal|1
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|arg
operator|->
name|stringified
operator|=
name|CPP_WRITTEN
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CPP_TRADITIONAL
argument_list|(
name|pfile
argument_list|)
condition|)
name|CPP_PUTC
argument_list|(
name|pfile
argument_list|,
literal|'\"'
argument_list|)
expr_stmt|;
comment|/* insert beginning quote */
for|for
control|(
init|;
name|i
operator|<
name|arglen
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
operator|(
name|ARG_BASE
operator|+
name|arg
operator|->
name|raw
operator|)
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|in_string
condition|)
block|{
comment|/* Internal sequences of whitespace are replaced by 			     one space except within an string or char token.*/
if|if
condition|(
name|is_space
index|[
name|c
index|]
condition|)
block|{
if|if
condition|(
name|CPP_WRITTEN
argument_list|(
name|pfile
argument_list|)
operator|>
name|arg
operator|->
name|stringified
operator|&&
operator|(
name|CPP_PWRITTEN
argument_list|(
name|pfile
argument_list|)
operator|)
index|[
operator|-
literal|1
index|]
operator|==
literal|'@'
condition|)
block|{
comment|/* "@ " escape markers are removed */
name|CPP_ADJUST_WRITTEN
argument_list|(
name|pfile
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|need_space
operator|==
literal|0
condition|)
name|need_space
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|need_space
operator|>
literal|0
condition|)
name|CPP_PUTC
argument_list|(
name|pfile
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|need_space
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|escaped
condition|)
name|escaped
operator|=
literal|0
expr_stmt|;
else|else
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
name|escaped
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|in_string
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|in_string
condition|)
name|in_string
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\"'
operator|||
name|c
operator|==
literal|'\''
condition|)
name|in_string
operator|=
name|c
expr_stmt|;
block|}
comment|/* Escape these chars */
if|if
condition|(
name|c
operator|==
literal|'\"'
operator|||
operator|(
name|in_string
operator|&&
name|c
operator|==
literal|'\\'
operator|)
condition|)
name|CPP_PUTC
argument_list|(
name|pfile
argument_list|,
literal|'\\'
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISPRINT
argument_list|(
name|c
argument_list|)
condition|)
name|CPP_PUTC
argument_list|(
name|pfile
argument_list|,
name|c
argument_list|)
expr_stmt|;
else|else
block|{
name|CPP_RESERVE
argument_list|(
name|pfile
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|CPP_PWRITTEN
argument_list|(
name|pfile
argument_list|)
argument_list|,
literal|"\\%03o"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|c
argument_list|)
expr_stmt|;
name|CPP_ADJUST_WRITTEN
argument_list|(
name|pfile
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|CPP_TRADITIONAL
argument_list|(
name|pfile
argument_list|)
condition|)
name|CPP_PUTC
argument_list|(
name|pfile
argument_list|,
literal|'\"'
argument_list|)
expr_stmt|;
comment|/* insert ending quote */
name|arg
operator|->
name|stringified_length
operator|=
name|CPP_WRITTEN
argument_list|(
name|pfile
argument_list|)
operator|-
name|arg
operator|->
name|stringified
expr_stmt|;
block|}
name|xbuf_len
operator|+=
name|args
index|[
name|ap
operator|->
name|argno
index|]
operator|.
name|stringified_length
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ap
operator|->
name|raw_before
operator|||
name|ap
operator|->
name|raw_after
operator|||
name|CPP_TRADITIONAL
argument_list|(
name|pfile
argument_list|)
condition|)
comment|/* Add 4 for two newline-space markers to prevent 	       token concatenation.  */
name|xbuf_len
operator|+=
name|args
index|[
name|ap
operator|->
name|argno
index|]
operator|.
name|raw_length
operator|+
literal|4
expr_stmt|;
else|else
block|{
comment|/* We have an ordinary (expanded) occurrence of the arg. 		 So compute its expansion, if we have not already.  */
if|if
condition|(
name|args
index|[
name|ap
operator|->
name|argno
index|]
operator|.
name|expand_length
operator|<
literal|0
condition|)
block|{
name|args
index|[
name|ap
operator|->
name|argno
index|]
operator|.
name|expanded
operator|=
name|CPP_WRITTEN
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|cpp_expand_to_buffer
argument_list|(
name|pfile
argument_list|,
name|ARG_BASE
operator|+
name|args
index|[
name|ap
operator|->
name|argno
index|]
operator|.
name|raw
argument_list|,
name|args
index|[
name|ap
operator|->
name|argno
index|]
operator|.
name|raw_length
argument_list|)
expr_stmt|;
name|args
index|[
name|ap
operator|->
name|argno
index|]
operator|.
name|expand_length
operator|=
name|CPP_WRITTEN
argument_list|(
name|pfile
argument_list|)
operator|-
name|args
index|[
name|ap
operator|->
name|argno
index|]
operator|.
name|expanded
expr_stmt|;
block|}
comment|/* Add 4 for two newline-space markers to prevent 		 token concatenation.  */
name|xbuf_len
operator|+=
name|args
index|[
name|ap
operator|->
name|argno
index|]
operator|.
name|expand_length
operator|+
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|args
index|[
name|ap
operator|->
name|argno
index|]
operator|.
name|use_count
operator|<
literal|10
condition|)
name|args
index|[
name|ap
operator|->
name|argno
index|]
operator|.
name|use_count
operator|++
expr_stmt|;
block|}
name|xbuf
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xmalloc
argument_list|(
name|xbuf_len
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Generate in XBUF the complete expansion 	 with arguments substituted in. 	 TOTLEN is the total size generated so far. 	 OFFSET is the index in the definition 	 of where we are copying from.  */
name|offset
operator|=
name|totlen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|last_ap
operator|=
name|NULL
operator|,
name|ap
operator|=
name|defn
operator|->
name|pattern
init|;
name|ap
operator|!=
name|NULL
condition|;
name|last_ap
operator|=
name|ap
operator|,
name|ap
operator|=
name|ap
operator|->
name|next
control|)
block|{
specifier|register
name|struct
name|argdata
modifier|*
name|arg
init|=
operator|&
name|args
index|[
name|ap
operator|->
name|argno
index|]
decl_stmt|;
name|int
name|count_before
init|=
name|totlen
decl_stmt|;
comment|/* Add chars to XBUF.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ap
operator|->
name|nchars
condition|;
name|i
operator|++
operator|,
name|offset
operator|++
control|)
name|xbuf
index|[
name|totlen
operator|++
index|]
operator|=
name|exp
index|[
name|offset
index|]
expr_stmt|;
comment|/* If followed by an empty rest arg with concatenation, 	     delete the last run of nonwhite chars.  */
if|if
condition|(
name|rest_zero
operator|&&
name|totlen
operator|>
name|count_before
operator|&&
operator|(
operator|(
name|ap
operator|->
name|rest_args
operator|&&
name|ap
operator|->
name|raw_before
operator|)
operator|||
operator|(
name|last_ap
operator|!=
name|NULL
operator|&&
name|last_ap
operator|->
name|rest_args
operator|&&
name|last_ap
operator|->
name|raw_after
operator|)
operator|)
condition|)
block|{
comment|/* Delete final whitespace.  */
while|while
condition|(
name|totlen
operator|>
name|count_before
operator|&&
name|is_space
index|[
name|xbuf
index|[
name|totlen
operator|-
literal|1
index|]
index|]
condition|)
name|totlen
operator|--
expr_stmt|;
comment|/* Delete the nonwhites before them.  */
while|while
condition|(
name|totlen
operator|>
name|count_before
operator|&&
operator|!
name|is_space
index|[
name|xbuf
index|[
name|totlen
operator|-
literal|1
index|]
index|]
condition|)
name|totlen
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|ap
operator|->
name|stringify
operator|!=
literal|0
condition|)
block|{
name|bcopy
argument_list|(
name|ARG_BASE
operator|+
name|arg
operator|->
name|stringified
argument_list|,
name|xbuf
operator|+
name|totlen
argument_list|,
name|arg
operator|->
name|stringified_length
argument_list|)
expr_stmt|;
name|totlen
operator|+=
name|arg
operator|->
name|stringified_length
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ap
operator|->
name|raw_before
operator|||
name|ap
operator|->
name|raw_after
operator|||
name|CPP_TRADITIONAL
argument_list|(
name|pfile
argument_list|)
condition|)
block|{
name|U_CHAR
modifier|*
name|p1
init|=
name|ARG_BASE
operator|+
name|arg
operator|->
name|raw
decl_stmt|;
name|U_CHAR
modifier|*
name|l1
init|=
name|p1
operator|+
name|arg
operator|->
name|raw_length
decl_stmt|;
if|if
condition|(
name|ap
operator|->
name|raw_before
condition|)
block|{
while|while
condition|(
name|p1
operator|!=
name|l1
operator|&&
name|is_space
index|[
operator|*
name|p1
index|]
condition|)
name|p1
operator|++
expr_stmt|;
while|while
condition|(
name|p1
operator|!=
name|l1
operator|&&
name|is_idchar
index|[
operator|*
name|p1
index|]
condition|)
name|xbuf
index|[
name|totlen
operator|++
index|]
operator|=
operator|*
name|p1
operator|++
expr_stmt|;
comment|/* Delete any no-reexpansion marker that follows 		     an identifier at the beginning of the argument 		     if the argument is concatenated with what precedes it.  */
if|if
condition|(
name|p1
index|[
literal|0
index|]
operator|==
literal|'@'
operator|&&
name|p1
index|[
literal|1
index|]
operator|==
literal|'-'
condition|)
name|p1
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|ap
operator|->
name|raw_after
condition|)
block|{
comment|/* Arg is concatenated after: delete trailing whitespace, 		     whitespace markers, and no-reexpansion markers.  */
while|while
condition|(
name|p1
operator|!=
name|l1
condition|)
block|{
if|if
condition|(
name|is_space
index|[
name|l1
index|[
operator|-
literal|1
index|]
index|]
condition|)
name|l1
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
name|l1
index|[
operator|-
literal|1
index|]
operator|==
literal|'-'
condition|)
block|{
name|U_CHAR
modifier|*
name|p2
init|=
name|l1
operator|-
literal|1
decl_stmt|;
comment|/* If a `-' is preceded by an odd number of newlines then it 			     and the last newline are a no-reexpansion marker.  */
while|while
condition|(
name|p2
operator|!=
name|p1
operator|&&
name|p2
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|p2
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|l1
operator|-
literal|1
operator|-
name|p2
operator|)
operator|&
literal|1
condition|)
block|{
name|l1
operator|-=
literal|2
expr_stmt|;
block|}
else|else
break|break;
block|}
else|else
break|break;
block|}
block|}
name|bcopy
argument_list|(
name|p1
argument_list|,
name|xbuf
operator|+
name|totlen
argument_list|,
name|l1
operator|-
name|p1
argument_list|)
expr_stmt|;
name|totlen
operator|+=
name|l1
operator|-
name|p1
expr_stmt|;
block|}
else|else
block|{
name|U_CHAR
modifier|*
name|expanded
init|=
name|ARG_BASE
operator|+
name|arg
operator|->
name|expanded
decl_stmt|;
if|if
condition|(
operator|!
name|ap
operator|->
name|raw_before
operator|&&
name|totlen
operator|>
literal|0
operator|&&
name|arg
operator|->
name|expand_length
operator|&&
operator|!
name|CPP_TRADITIONAL
argument_list|(
name|pfile
argument_list|)
operator|&&
name|unsafe_chars
argument_list|(
name|xbuf
index|[
name|totlen
operator|-
literal|1
index|]
argument_list|,
name|expanded
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|xbuf
index|[
name|totlen
operator|++
index|]
operator|=
literal|'@'
expr_stmt|;
name|xbuf
index|[
name|totlen
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|expanded
argument_list|,
name|xbuf
operator|+
name|totlen
argument_list|,
name|arg
operator|->
name|expand_length
argument_list|)
expr_stmt|;
name|totlen
operator|+=
name|arg
operator|->
name|expand_length
expr_stmt|;
if|if
condition|(
operator|!
name|ap
operator|->
name|raw_after
operator|&&
name|totlen
operator|>
literal|0
operator|&&
name|offset
operator|<
name|defn
operator|->
name|length
operator|&&
operator|!
name|CPP_TRADITIONAL
argument_list|(
name|pfile
argument_list|)
operator|&&
name|unsafe_chars
argument_list|(
name|xbuf
index|[
name|totlen
operator|-
literal|1
index|]
argument_list|,
name|exp
index|[
name|offset
index|]
argument_list|)
condition|)
block|{
name|xbuf
index|[
name|totlen
operator|++
index|]
operator|=
literal|'@'
expr_stmt|;
name|xbuf
index|[
name|totlen
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
block|}
comment|/* If a macro argument with newlines is used multiple times, 		 then only expand the newlines once.  This avoids creating 		 output lines which don't correspond to any input line, 		 which confuses gdb and gcov.  */
if|if
condition|(
name|arg
operator|->
name|use_count
operator|>
literal|1
operator|&&
name|arg
operator|->
name|newlines
operator|>
literal|0
condition|)
block|{
comment|/* Don't bother doing change_newlines for subsequent 		     uses of arg.  */
name|arg
operator|->
name|use_count
operator|=
literal|1
expr_stmt|;
name|arg
operator|->
name|expand_length
operator|=
name|change_newlines
argument_list|(
name|expanded
argument_list|,
name|arg
operator|->
name|expand_length
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|totlen
operator|>
name|xbuf_len
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* if there is anything left of the definition 	 after handling the arg list, copy that in too.  */
for|for
control|(
name|i
operator|=
name|offset
init|;
name|i
operator|<
name|defn
operator|->
name|length
condition|;
name|i
operator|++
control|)
block|{
comment|/* if we've reached the end of the macro */
if|if
condition|(
name|exp
index|[
name|i
index|]
operator|==
literal|')'
condition|)
name|rest_zero
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|rest_zero
operator|&&
name|last_ap
operator|!=
name|NULL
operator|&&
name|last_ap
operator|->
name|rest_args
operator|&&
name|last_ap
operator|->
name|raw_after
operator|)
condition|)
name|xbuf
index|[
name|totlen
operator|++
index|]
operator|=
name|exp
index|[
name|i
index|]
expr_stmt|;
block|}
name|xbuf
index|[
name|totlen
index|]
operator|=
literal|0
expr_stmt|;
name|xbuf_len
operator|=
name|totlen
expr_stmt|;
block|}
name|pfile
operator|->
name|output_escapes
operator|--
expr_stmt|;
comment|/* Now put the expansion on the input stack      so our caller will commence reading from it.  */
name|push_macro_expansion
argument_list|(
name|pfile
argument_list|,
name|xbuf
argument_list|,
name|xbuf_len
argument_list|,
name|hp
argument_list|)
expr_stmt|;
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|->
name|has_escapes
operator|=
literal|1
expr_stmt|;
comment|/* Pop the space we've used in the token_buffer for argument expansion.  */
name|CPP_SET_WRITTEN
argument_list|(
name|pfile
argument_list|,
name|old_written
argument_list|)
expr_stmt|;
comment|/* Recursive macro use sometimes works traditionally.      #define foo(x,y) bar (x (y,0), y)      foo (foo, baz)  */
if|if
condition|(
operator|!
name|CPP_TRADITIONAL
argument_list|(
name|pfile
argument_list|)
condition|)
name|hp
operator|->
name|type
operator|=
name|T_DISABLED
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|push_macro_expansion
parameter_list|(
name|pfile
parameter_list|,
name|xbuf
parameter_list|,
name|xbuf_len
parameter_list|,
name|hp
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|xbuf
decl_stmt|;
name|int
name|xbuf_len
decl_stmt|;
name|HASHNODE
modifier|*
name|hp
decl_stmt|;
block|{
specifier|register
name|cpp_buffer
modifier|*
name|mbuf
init|=
name|cpp_push_buffer
argument_list|(
name|pfile
argument_list|,
name|xbuf
argument_list|,
name|xbuf_len
argument_list|)
decl_stmt|;
if|if
condition|(
name|mbuf
operator|==
name|NULL
condition|)
return|return;
name|mbuf
operator|->
name|cleanup
operator|=
name|macro_cleanup
expr_stmt|;
name|mbuf
operator|->
name|data
operator|=
name|hp
expr_stmt|;
comment|/* The first chars of the expansion should be a "@ " added by      collect_expansion.  This is to prevent accidental token-pasting      between the text preceding the macro invocation, and the macro      expansion text.       We would like to avoid adding unneeded spaces (for the sake of      tools that use cpp, such as imake).  In some common cases we can      tell that it is safe to omit the space.       The character before the macro invocation cannot have been an      idchar (or else it would have been pasted with the idchars of      the macro name).  Therefore, if the first non-space character      of the expansion is an idchar, we do not need the extra space      to prevent token pasting.       Also, we don't need the extra space if the first char is '(',      or some other (less common) characters.  */
if|if
condition|(
name|xbuf
index|[
literal|0
index|]
operator|==
literal|'@'
operator|&&
name|xbuf
index|[
literal|1
index|]
operator|==
literal|' '
operator|&&
operator|(
name|is_idchar
index|[
name|xbuf
index|[
literal|2
index|]
index|]
operator|||
name|xbuf
index|[
literal|2
index|]
operator|==
literal|'('
operator|||
name|xbuf
index|[
literal|2
index|]
operator|==
literal|'\''
operator|||
name|xbuf
index|[
literal|2
index|]
operator|==
literal|'\"'
operator|)
condition|)
name|mbuf
operator|->
name|cur
operator|+=
literal|2
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Like cpp_get_token, except that it does not read past end-of-line.    Also, horizontal space is skipped, and macros are popped.  */
end_comment

begin_function
specifier|static
name|enum
name|cpp_token
name|get_directive_token
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|long
name|old_written
init|=
name|CPP_WRITTEN
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
name|enum
name|cpp_token
name|token
decl_stmt|;
name|cpp_skip_hspace
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|PEEKC
argument_list|()
operator|==
literal|'\n'
condition|)
return|return
name|CPP_VSPACE
return|;
name|token
operator|=
name|cpp_get_token
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|token
condition|)
block|{
case|case
name|CPP_POP
case|:
if|if
condition|(
operator|!
name|CPP_IS_MACRO_BUFFER
argument_list|(
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
argument_list|)
condition|)
return|return
name|token
return|;
comment|/* ... else fall though ...  */
case|case
name|CPP_HSPACE
case|:
case|case
name|CPP_COMMENT
case|:
name|CPP_SET_WRITTEN
argument_list|(
name|pfile
argument_list|,
name|old_written
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
name|token
return|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Handle #include and #import.    This function expects to see "fname" or<fname> on the input.     The input is normally in part of the output_buffer following    CPP_WRITTEN, and will get overwritten by output_line_command.    I.e. in input file specification has been popped by handle_directive.    This is safe.  */
end_comment

begin_function
specifier|static
name|int
name|do_include
parameter_list|(
name|pfile
parameter_list|,
name|keyword
parameter_list|,
name|unused1
parameter_list|,
name|unused2
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|struct
name|directive
modifier|*
name|keyword
decl_stmt|;
name|U_CHAR
modifier|*
name|unused1
name|ATTRIBUTE_UNUSED
decl_stmt|,
decl|*
name|unused2
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_function

begin_block
block|{
name|int
name|importing
init|=
operator|(
name|keyword
operator|->
name|type
operator|==
name|T_IMPORT
operator|)
decl_stmt|;
name|int
name|skip_dirs
init|=
operator|(
name|keyword
operator|->
name|type
operator|==
name|T_INCLUDE_NEXT
operator|)
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
comment|/* Dynamically allocated fname buffer */
name|char
modifier|*
name|pcftry
decl_stmt|;
name|U_CHAR
modifier|*
name|fbeg
decl_stmt|,
modifier|*
name|fend
decl_stmt|;
comment|/* Beginning and end of fname */
name|enum
name|cpp_token
name|token
decl_stmt|;
comment|/* Chain of dirs to search */
name|struct
name|file_name_list
modifier|*
name|search_start
init|=
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|include
decl_stmt|;
name|struct
name|file_name_list
name|dsp
index|[
literal|1
index|]
decl_stmt|;
comment|/* First in chain, if #include "..." */
name|struct
name|file_name_list
modifier|*
name|searchptr
init|=
literal|0
decl_stmt|;
name|long
name|old_written
init|=
name|CPP_WRITTEN
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
name|int
name|flen
decl_stmt|;
name|int
name|f
decl_stmt|;
comment|/* file number */
name|int
name|angle_brackets
init|=
literal|0
decl_stmt|;
comment|/* 0 for "...", 1 for<...> */
name|char
modifier|*
name|pcfbuf
decl_stmt|;
if|#
directive|if
literal|0
block|int pcf = -1;   char *pcfbuflimit;
endif|#
directive|endif
name|int
name|pcfnum
decl_stmt|;
name|f
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* JF we iz paranoid! */
if|if
condition|(
name|CPP_PEDANTIC
argument_list|(
name|pfile
argument_list|)
operator|&&
operator|!
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|->
name|system_header_p
condition|)
block|{
if|if
condition|(
name|importing
condition|)
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"ANSI C does not allow `#import'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|skip_dirs
condition|)
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"ANSI C does not allow `#include_next'"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|importing
operator|&&
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|warn_import
operator|&&
operator|!
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|inhibit_warnings
operator|&&
operator|!
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|->
name|system_header_p
operator|&&
operator|!
name|pfile
operator|->
name|import_warning
condition|)
block|{
name|pfile
operator|->
name|import_warning
operator|=
literal|1
expr_stmt|;
name|cpp_warning
argument_list|(
name|pfile
argument_list|,
literal|"using `#import' is not recommended"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"The fact that a certain header file need not be processed more than once\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"should be indicated in the header file, not where it is used.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"The best way to do this is with a conditional of this form:\n\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  #ifndef _FOO_H_INCLUDED\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  #define _FOO_H_INCLUDED\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  ...<real contents of file> ...\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  #endif /* Not _FOO_H_INCLUDED */\n\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Then users can use `#include' any number of times.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"GNU C automatically avoids processing the file more than once\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"when it is equipped with such a conditional.\n"
argument_list|)
expr_stmt|;
block|}
name|pfile
operator|->
name|parsing_include_directive
operator|++
expr_stmt|;
name|token
operator|=
name|get_directive_token
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|parsing_include_directive
operator|--
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|CPP_STRING
condition|)
block|{
comment|/* FIXME - check no trailing garbage */
name|fbeg
operator|=
name|pfile
operator|->
name|token_buffer
operator|+
name|old_written
operator|+
literal|1
expr_stmt|;
name|fend
operator|=
name|CPP_PWRITTEN
argument_list|(
name|pfile
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|fbeg
index|[
operator|-
literal|1
index|]
operator|==
literal|'<'
condition|)
block|{
name|angle_brackets
operator|=
literal|1
expr_stmt|;
comment|/* If -I-, start with the first -I dir after the -I-.  */
if|if
condition|(
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|first_bracket_include
condition|)
name|search_start
operator|=
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|first_bracket_include
expr_stmt|;
block|}
comment|/* If -I- was specified, don't search current dir, only spec'd ones.  */
elseif|else
if|if
condition|(
operator|!
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|ignore_srcdir
condition|)
block|{
name|cpp_buffer
modifier|*
name|fp
init|=
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
comment|/* We have "filename".  Figure out directory this source 	     file is coming from and put it on the front of the list.  */
for|for
control|(
init|;
name|fp
operator|!=
name|CPP_NULL_BUFFER
argument_list|(
name|pfile
argument_list|)
condition|;
name|fp
operator|=
name|CPP_PREV_BUFFER
argument_list|(
name|fp
argument_list|)
control|)
block|{
name|int
name|n
decl_stmt|;
name|char
modifier|*
name|ep
decl_stmt|,
modifier|*
name|nam
decl_stmt|;
if|if
condition|(
operator|(
name|nam
operator|=
name|fp
operator|->
name|nominal_fname
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* Found a named file.  Figure out dir of the file, 		     and put it in front of the search list.  */
name|dsp
index|[
literal|0
index|]
operator|.
name|next
operator|=
name|search_start
expr_stmt|;
name|search_start
operator|=
name|dsp
expr_stmt|;
ifndef|#
directive|ifndef
name|VMS
name|ep
operator|=
name|rindex
argument_list|(
name|nam
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* VMS */
name|ep
operator|=
name|rindex
argument_list|(
name|nam
argument_list|,
literal|']'
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|==
name|NULL
condition|)
name|ep
operator|=
name|rindex
argument_list|(
name|nam
argument_list|,
literal|'>'
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|==
name|NULL
condition|)
name|ep
operator|=
name|rindex
argument_list|(
name|nam
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|!=
name|NULL
condition|)
name|ep
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* VMS */
if|if
condition|(
name|ep
operator|!=
name|NULL
condition|)
block|{
name|n
operator|=
name|ep
operator|-
name|nam
expr_stmt|;
name|dsp
index|[
literal|0
index|]
operator|.
name|fname
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|n
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|dsp
index|[
literal|0
index|]
operator|.
name|fname
argument_list|,
name|nam
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|dsp
index|[
literal|0
index|]
operator|.
name|fname
index|[
name|n
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|n
operator|+
name|INCLUDE_LEN_FUDGE
operator|>
name|pfile
operator|->
name|max_include_len
condition|)
name|pfile
operator|->
name|max_include_len
operator|=
name|n
operator|+
name|INCLUDE_LEN_FUDGE
expr_stmt|;
block|}
else|else
block|{
name|dsp
index|[
literal|0
index|]
operator|.
name|fname
operator|=
literal|0
expr_stmt|;
comment|/* Current directory */
block|}
name|dsp
index|[
literal|0
index|]
operator|.
name|got_name_map
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|VMS
elseif|else
if|if
condition|(
name|token
operator|==
name|CPP_NAME
condition|)
block|{
comment|/*        * Support '#include xyz' like VAX-C to allow for easy use of all the        * decwindow include files. It defaults to '#include<xyz.h>' (so the        * code from case '<' is repeated here) and generates a warning.        */
name|cpp_warning
argument_list|(
name|pfile
argument_list|,
literal|"VAX-C-style include specification found, use '#include<filename.h>' !"
argument_list|)
expr_stmt|;
name|angle_brackets
operator|=
literal|1
expr_stmt|;
comment|/* If -I-, start with the first -I dir after the -I-.  */
if|if
condition|(
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|first_bracket_include
condition|)
name|search_start
operator|=
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|first_bracket_include
expr_stmt|;
name|fbeg
operator|=
name|pfile
operator|->
name|token_buffer
operator|+
name|old_written
expr_stmt|;
name|fend
operator|=
name|CPP_PWRITTEN
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
else|else
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"`#%s' expects \"FILENAME\" or<FILENAME>"
argument_list|,
name|keyword
operator|->
name|name
argument_list|)
expr_stmt|;
name|CPP_SET_WRITTEN
argument_list|(
name|pfile
argument_list|,
name|old_written
argument_list|)
expr_stmt|;
name|skip_rest_of_line
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|fend
operator|=
literal|0
expr_stmt|;
name|token
operator|=
name|get_directive_token
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|CPP_VSPACE
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"junk at end of `#include'"
argument_list|)
expr_stmt|;
while|while
condition|(
name|token
operator|!=
name|CPP_VSPACE
operator|&&
name|token
operator|!=
name|CPP_EOF
operator|&&
name|token
operator|!=
name|CPP_POP
condition|)
name|token
operator|=
name|get_directive_token
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
comment|/* For #include_next, skip in the search path      past the dir in which the containing file was found.  */
if|if
condition|(
name|skip_dirs
condition|)
block|{
name|cpp_buffer
modifier|*
name|fp
init|=
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|fp
operator|!=
name|CPP_NULL_BUFFER
argument_list|(
name|pfile
argument_list|)
condition|;
name|fp
operator|=
name|CPP_PREV_BUFFER
argument_list|(
name|fp
argument_list|)
control|)
if|if
condition|(
name|fp
operator|->
name|fname
operator|!=
name|NULL
condition|)
block|{
comment|/* fp->dir is null if the containing file was specified with 	       an absolute file name.  In that case, don't skip anything.  */
if|if
condition|(
name|fp
operator|->
name|dir
operator|==
name|SELF_DIR_DUMMY
condition|)
name|search_start
operator|=
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|include
expr_stmt|;
elseif|else
if|if
condition|(
name|fp
operator|->
name|dir
condition|)
name|search_start
operator|=
name|fp
operator|->
name|dir
operator|->
name|next
expr_stmt|;
break|break;
block|}
block|}
name|CPP_SET_WRITTEN
argument_list|(
name|pfile
argument_list|,
name|old_written
argument_list|)
expr_stmt|;
name|flen
operator|=
name|fend
operator|-
name|fbeg
expr_stmt|;
if|if
condition|(
name|flen
operator|==
literal|0
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"empty file name in `#%s'"
argument_list|,
name|keyword
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Allocate this permanently, because it gets stored in the definitions      of macros.  */
name|fname
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|pfile
operator|->
name|max_include_len
operator|+
name|flen
operator|+
literal|4
argument_list|)
expr_stmt|;
comment|/* + 2 above for slash and terminating null.  */
comment|/* + 2 added for '.h' on VMS (to support '#include filename') */
comment|/* If specified file name is absolute, just open it.  */
if|if
condition|(
operator|*
name|fbeg
operator|==
literal|'/'
condition|)
block|{
name|strncpy
argument_list|(
name|fname
argument_list|,
name|fbeg
argument_list|,
name|flen
argument_list|)
expr_stmt|;
name|fname
index|[
name|flen
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|redundant_include_p
argument_list|(
name|pfile
argument_list|,
name|fname
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|importing
condition|)
name|f
operator|=
name|lookup_import
argument_list|(
name|pfile
argument_list|,
name|fname
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
else|else
name|f
operator|=
name|open_include_file
argument_list|(
name|pfile
argument_list|,
name|fname
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
operator|-
literal|2
condition|)
return|return
literal|0
return|;
comment|/* Already included this file */
block|}
else|else
block|{
comment|/* Search directory path, trying to open the file.        Copy each filename tried into FNAME.  */
for|for
control|(
name|searchptr
operator|=
name|search_start
init|;
name|searchptr
condition|;
name|searchptr
operator|=
name|searchptr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|searchptr
operator|->
name|fname
condition|)
block|{
comment|/* The empty string in a search path is ignored. 	   This makes it possible to turn off entirely 	   a standard piece of the list.  */
if|if
condition|(
name|searchptr
operator|->
name|fname
index|[
literal|0
index|]
operator|==
literal|0
condition|)
continue|continue;
name|strcpy
argument_list|(
name|fname
argument_list|,
name|searchptr
operator|->
name|fname
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|fname
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|fname
index|[
name|strlen
argument_list|(
name|fname
argument_list|)
operator|+
name|flen
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|fname
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|strncat
argument_list|(
name|fname
argument_list|,
name|fbeg
argument_list|,
name|flen
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VMS
comment|/* Change this 1/2 Unix 1/2 VMS file specification into a          full VMS file specification */
if|if
condition|(
name|searchptr
operator|->
name|fname
operator|&&
operator|(
name|searchptr
operator|->
name|fname
index|[
literal|0
index|]
operator|!=
literal|0
operator|)
condition|)
block|{
comment|/* Fix up the filename */
name|hack_vms_include_specification
argument_list|(
name|fname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This is a normal VMS filespec, so use it unchanged.  */
name|strncpy
argument_list|(
name|fname
argument_list|,
name|fbeg
argument_list|,
name|flen
argument_list|)
expr_stmt|;
name|fname
index|[
name|flen
index|]
operator|=
literal|0
expr_stmt|;
comment|/* if it's '#include filename', add the missing .h */
if|if
condition|(
name|index
argument_list|(
name|fname
argument_list|,
literal|'.'
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|strcat
argument_list|(
name|fname
argument_list|,
literal|".h"
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* VMS */
comment|/* ??? There are currently 3 separate mechanisms for avoiding processing 	 of redundant include files: #import, #pragma once, and 	 redundant_include_p.  It would be nice if they were unified.  */
if|if
condition|(
name|redundant_include_p
argument_list|(
name|pfile
argument_list|,
name|fname
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|importing
condition|)
name|f
operator|=
name|lookup_import
argument_list|(
name|pfile
argument_list|,
name|fname
argument_list|,
name|searchptr
argument_list|)
expr_stmt|;
else|else
name|f
operator|=
name|open_include_file
argument_list|(
name|pfile
argument_list|,
name|fname
argument_list|,
name|searchptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
operator|-
literal|2
condition|)
return|return
literal|0
return|;
comment|/* Already included this file */
ifdef|#
directive|ifdef
name|EACCES
elseif|else
if|if
condition|(
name|f
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EACCES
condition|)
name|cpp_warning
argument_list|(
name|pfile
argument_list|,
literal|"Header file %s exists, but is not readable"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|f
operator|>=
literal|0
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|f
operator|<
literal|0
condition|)
block|{
comment|/* A file that was not found.  */
name|strncpy
argument_list|(
name|fname
argument_list|,
name|fbeg
argument_list|,
name|flen
argument_list|)
expr_stmt|;
name|fname
index|[
name|flen
index|]
operator|=
literal|0
expr_stmt|;
comment|/* If generating dependencies and -MG was specified, we assume missing 	 files are leaf files, living in the same directory as the source file 	 or other similar place; these missing files may be generated from 	 other files and may not exist yet (eg: y.tab.h).  */
if|if
condition|(
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|print_deps_missing_files
operator|&&
name|CPP_PRINT_DEPS
argument_list|(
name|pfile
argument_list|)
operator|>
operator|(
name|angle_brackets
operator|||
operator|(
name|pfile
operator|->
name|system_include_depth
operator|>
literal|0
operator|)
operator|)
condition|)
block|{
comment|/* If it was requested as a system header file, 	     then assume it belongs in the first place to look for such.  */
if|if
condition|(
name|angle_brackets
condition|)
block|{
for|for
control|(
name|searchptr
operator|=
name|search_start
init|;
name|searchptr
condition|;
name|searchptr
operator|=
name|searchptr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|searchptr
operator|->
name|fname
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|searchptr
operator|->
name|fname
index|[
literal|0
index|]
operator|==
literal|0
condition|)
continue|continue;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|searchptr
operator|->
name|fname
argument_list|)
operator|+
name|strlen
argument_list|(
name|fname
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|searchptr
operator|->
name|fname
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|p
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|p
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|deps_output
argument_list|(
name|pfile
argument_list|,
name|p
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
comment|/* Otherwise, omit the directory, as if the file existed 		 in the directory with the source.  */
name|deps_output
argument_list|(
name|pfile
argument_list|,
name|fname
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If -M was specified, and this header file won't be added to the 	 dependency list, then don't count this as an error, because we can 	 still produce correct output.  Otherwise, we can't produce correct 	 output, because there may be dependencies we need inside the missing 	 file, and we don't know what directory this missing file exists in.*/
elseif|else
if|if
condition|(
name|CPP_PRINT_DEPS
argument_list|(
name|pfile
argument_list|)
operator|&&
operator|(
name|CPP_PRINT_DEPS
argument_list|(
name|pfile
argument_list|)
operator|<=
operator|(
name|angle_brackets
operator|||
operator|(
name|pfile
operator|->
name|system_include_depth
operator|>
literal|0
operator|)
operator|)
operator|)
condition|)
name|cpp_warning
argument_list|(
name|pfile
argument_list|,
literal|"No include path in which to find %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|search_start
condition|)
name|cpp_error_from_errno
argument_list|(
name|pfile
argument_list|,
name|fname
argument_list|)
expr_stmt|;
else|else
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"No include path in which to find %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Check to see if this include file is a once-only include file.        If so, give up.  */
name|struct
name|file_name_list
modifier|*
name|ptr
decl_stmt|;
for|for
control|(
name|ptr
operator|=
name|pfile
operator|->
name|dont_repeat_files
init|;
name|ptr
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ptr
operator|->
name|fname
argument_list|,
name|fname
argument_list|)
condition|)
block|{
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* This file was once'd.  */
block|}
block|}
for|for
control|(
name|ptr
operator|=
name|pfile
operator|->
name|all_include_files
init|;
name|ptr
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ptr
operator|->
name|fname
argument_list|,
name|fname
argument_list|)
condition|)
break|break;
comment|/* This file was included before.  */
block|}
if|if
condition|(
name|ptr
operator|==
literal|0
condition|)
block|{
comment|/* This is the first time for this file.  */
comment|/* Add it to list of files included.  */
name|ptr
operator|=
operator|(
expr|struct
name|file_name_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|file_name_list
argument_list|)
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|control_macro
operator|=
literal|0
expr_stmt|;
name|ptr
operator|->
name|c_system_include_path
operator|=
literal|0
expr_stmt|;
name|ptr
operator|->
name|next
operator|=
name|pfile
operator|->
name|all_include_files
expr_stmt|;
name|pfile
operator|->
name|all_include_files
operator|=
name|ptr
expr_stmt|;
name|ptr
operator|->
name|fname
operator|=
name|savestring
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|got_name_map
operator|=
literal|0
expr_stmt|;
comment|/* For -M, add this file to the dependencies.  */
if|if
condition|(
name|CPP_PRINT_DEPS
argument_list|(
name|pfile
argument_list|)
operator|>
operator|(
name|angle_brackets
operator|||
operator|(
name|pfile
operator|->
name|system_include_depth
operator|>
literal|0
operator|)
operator|)
condition|)
name|deps_output
argument_list|(
name|pfile
argument_list|,
name|fname
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
block|}
comment|/* Handle -H option.  */
if|if
condition|(
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|print_include_names
condition|)
block|{
name|cpp_buffer
modifier|*
name|buf
init|=
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
while|while
condition|(
operator|(
name|buf
operator|=
name|CPP_PREV_BUFFER
argument_list|(
name|buf
argument_list|)
operator|)
operator|!=
name|CPP_NULL_BUFFER
argument_list|(
name|pfile
argument_list|)
condition|)
name|putc
argument_list|(
literal|'.'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|angle_brackets
condition|)
name|pfile
operator|->
name|system_include_depth
operator|++
expr_stmt|;
comment|/* Actually process the file.  */
comment|/* Record file on "seen" list for #import.  */
name|add_import
argument_list|(
name|pfile
argument_list|,
name|f
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|pcftry
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|fname
argument_list|)
operator|+
literal|30
argument_list|)
expr_stmt|;
name|pcfbuf
operator|=
literal|0
expr_stmt|;
name|pcfnum
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|0
block|if (!no_precomp)       { 	struct stat stat_f;  	fstat (f,&stat_f);  	do { 	  sprintf (pcftry, "%s%d", fname, pcfnum++);  	  pcf = open (pcftry, O_RDONLY, 0666); 	  if (pcf != -1) 	    { 	      struct stat s;  	      fstat (pcf,&s); 	      if (bcmp ((char *)&stat_f.st_ino, (char *)&s.st_ino, 			sizeof (s.st_ino)) 		  || stat_f.st_dev != s.st_dev) 		{ 		  pcfbuf = check_precompiled (pcf, fname,&pcfbuflimit);
comment|/* Don't need it any more.  */
block|close (pcf); 		} 	      else 		{
comment|/* Don't need it at all.  */
block|close (pcf); 		  break; 		} 	    } 	} while (pcf != -1&& !pcfbuf);       }
endif|#
directive|endif
comment|/* Actually process the file */
if|if
condition|(
name|cpp_push_buffer
argument_list|(
name|pfile
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|finclude
argument_list|(
name|pfile
argument_list|,
name|f
argument_list|,
name|fname
argument_list|,
name|is_system_include
argument_list|(
name|pfile
argument_list|,
name|fname
argument_list|)
argument_list|,
name|searchptr
operator|!=
name|dsp
condition|?
name|searchptr
else|:
name|SELF_DIR_DUMMY
argument_list|)
condition|)
block|{
name|output_line_command
argument_list|(
name|pfile
argument_list|,
literal|0
argument_list|,
name|enter_file
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|only_seen_white
operator|=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|angle_brackets
condition|)
name|pfile
operator|->
name|system_include_depth
operator|--
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Return nonzero if there is no need to include file NAME    because it has already been included and it contains a conditional    to make a repeated include do nothing.  */
end_comment

begin_function
specifier|static
name|int
name|redundant_include_p
parameter_list|(
name|pfile
parameter_list|,
name|name
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|file_name_list
modifier|*
name|l
init|=
name|pfile
operator|->
name|all_include_files
decl_stmt|;
for|for
control|(
init|;
name|l
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|l
operator|->
name|fname
argument_list|)
operator|&&
name|l
operator|->
name|control_macro
operator|&&
name|cpp_lookup
argument_list|(
name|pfile
argument_list|,
name|l
operator|->
name|control_macro
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if the given FILENAME is an absolute pathname which    designates a file within one of the known "system" include file    directories.  We assume here that if the given FILENAME looks like    it is the name of a file which resides either directly in a "system"    include file directory, or within any subdirectory thereof, then the    given file must be a "system" include file.  This function tells us    if we should suppress pedantic errors/warnings for the given FILENAME.     The value is 2 if the file is a C-language system header file    for which C++ should (on most systems) assume `extern "C"'.  */
end_comment

begin_function
specifier|static
name|int
name|is_system_include
parameter_list|(
name|pfile
parameter_list|,
name|filename
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
specifier|register
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|struct
name|file_name_list
modifier|*
name|searchptr
decl_stmt|;
for|for
control|(
name|searchptr
operator|=
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|first_system_include
init|;
name|searchptr
condition|;
name|searchptr
operator|=
name|searchptr
operator|->
name|next
control|)
if|if
condition|(
name|searchptr
operator|->
name|fname
condition|)
block|{
specifier|register
name|char
modifier|*
name|sys_dir
init|=
name|searchptr
operator|->
name|fname
decl_stmt|;
specifier|register
name|unsigned
name|length
init|=
name|strlen
argument_list|(
name|sys_dir
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|sys_dir
argument_list|,
name|filename
argument_list|,
name|length
argument_list|)
operator|&&
name|filename
index|[
name|length
index|]
operator|==
literal|'/'
condition|)
block|{
if|if
condition|(
name|searchptr
operator|->
name|c_system_include_path
condition|)
return|return
literal|2
return|;
else|else
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Install a name in the assertion hash table.  *  * If LEN is>= 0, it is the length of the name.  * Otherwise, compute the length by scanning the entire name.  *  * If HASH is>= 0, it is the precomputed hash code.  * Otherwise, compute the hash code.  */
end_comment

begin_function
specifier|static
name|ASSERTION_HASHNODE
modifier|*
name|assertion_install
parameter_list|(
name|pfile
parameter_list|,
name|name
parameter_list|,
name|len
parameter_list|,
name|hash
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|U_CHAR
modifier|*
name|name
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|hash
decl_stmt|;
block|{
specifier|register
name|ASSERTION_HASHNODE
modifier|*
name|hp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|bucket
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|i
operator|=
sizeof|sizeof
argument_list|(
name|ASSERTION_HASHNODE
argument_list|)
operator|+
name|len
operator|+
literal|1
expr_stmt|;
name|hp
operator|=
operator|(
name|ASSERTION_HASHNODE
operator|*
operator|)
name|xmalloc
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|bucket
operator|=
name|hash
expr_stmt|;
name|hp
operator|->
name|bucket_hdr
operator|=
operator|&
name|pfile
operator|->
name|assertion_hashtab
index|[
name|bucket
index|]
expr_stmt|;
name|hp
operator|->
name|next
operator|=
name|pfile
operator|->
name|assertion_hashtab
index|[
name|bucket
index|]
expr_stmt|;
name|pfile
operator|->
name|assertion_hashtab
index|[
name|bucket
index|]
operator|=
name|hp
expr_stmt|;
name|hp
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|next
operator|!=
name|NULL
condition|)
name|hp
operator|->
name|next
operator|->
name|prev
operator|=
name|hp
expr_stmt|;
name|hp
operator|->
name|length
operator|=
name|len
expr_stmt|;
name|hp
operator|->
name|value
operator|=
literal|0
expr_stmt|;
name|hp
operator|->
name|name
operator|=
operator|(
operator|(
name|U_CHAR
operator|*
operator|)
name|hp
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|ASSERTION_HASHNODE
argument_list|)
expr_stmt|;
name|p
operator|=
name|hp
operator|->
name|name
expr_stmt|;
name|q
operator|=
name|name
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
operator|*
name|q
operator|++
expr_stmt|;
name|hp
operator|->
name|name
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|hp
return|;
block|}
end_function

begin_comment
comment|/*  * find the most recent hash node for name "name" (ending with first  * non-identifier char) installed by install  *  * If LEN is>= 0, it is the length of the name.  * Otherwise, compute the length by scanning the entire name.  *  * If HASH is>= 0, it is the precomputed hash code.  * Otherwise, compute the hash code.  */
end_comment

begin_function
specifier|static
name|ASSERTION_HASHNODE
modifier|*
name|assertion_lookup
parameter_list|(
name|pfile
parameter_list|,
name|name
parameter_list|,
name|len
parameter_list|,
name|hash
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|U_CHAR
modifier|*
name|name
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|hash
decl_stmt|;
block|{
specifier|register
name|ASSERTION_HASHNODE
modifier|*
name|bucket
decl_stmt|;
name|bucket
operator|=
name|pfile
operator|->
name|assertion_hashtab
index|[
name|hash
index|]
expr_stmt|;
while|while
condition|(
name|bucket
condition|)
block|{
if|if
condition|(
name|bucket
operator|->
name|length
operator|==
name|len
operator|&&
name|strncmp
argument_list|(
name|bucket
operator|->
name|name
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
return|return
name|bucket
return|;
name|bucket
operator|=
name|bucket
operator|->
name|next
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|delete_assertion
parameter_list|(
name|hp
parameter_list|)
name|ASSERTION_HASHNODE
modifier|*
name|hp
decl_stmt|;
block|{
name|struct
name|tokenlist_list
modifier|*
name|tail
decl_stmt|;
if|if
condition|(
name|hp
operator|->
name|prev
operator|!=
name|NULL
condition|)
name|hp
operator|->
name|prev
operator|->
name|next
operator|=
name|hp
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|next
operator|!=
name|NULL
condition|)
name|hp
operator|->
name|next
operator|->
name|prev
operator|=
name|hp
operator|->
name|prev
expr_stmt|;
for|for
control|(
name|tail
operator|=
name|hp
operator|->
name|value
init|;
name|tail
condition|;
control|)
block|{
name|struct
name|tokenlist_list
modifier|*
name|next
init|=
name|tail
operator|->
name|next
decl_stmt|;
name|free_token_list
argument_list|(
name|tail
operator|->
name|tokens
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tail
argument_list|)
expr_stmt|;
name|tail
operator|=
name|next
expr_stmt|;
block|}
comment|/* Make sure that the bucket chain header that      the deleted guy was on points to the right thing afterwards.  */
if|if
condition|(
name|hp
operator|==
operator|*
name|hp
operator|->
name|bucket_hdr
condition|)
operator|*
name|hp
operator|->
name|bucket_hdr
operator|=
name|hp
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|hp
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Convert a character string literal into a nul-terminated string.    The input string is [IN ... LIMIT).    The result is placed in RESULT.  RESULT can be the same as IN.    The value returned in the end of the string written to RESULT,    or NULL on error.  */
end_comment

begin_function
specifier|static
name|U_CHAR
modifier|*
name|convert_string
parameter_list|(
name|pfile
parameter_list|,
name|result
parameter_list|,
name|in
parameter_list|,
name|limit
parameter_list|,
name|handle_escapes
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|result
decl_stmt|,
decl|*
name|in
decl_stmt|,
modifier|*
name|limit
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|handle_escapes
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|U_CHAR
name|c
decl_stmt|;
name|c
operator|=
operator|*
name|in
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'\"'
condition|)
return|return
name|NULL
return|;
while|while
condition|(
name|in
operator|<
name|limit
condition|)
block|{
name|U_CHAR
name|c
init|=
operator|*
name|in
operator|++
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\0'
case|:
return|return
name|NULL
return|;
case|case
literal|'\"'
case|:
name|limit
operator|=
name|in
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
if|if
condition|(
name|handle_escapes
condition|)
block|{
name|char
modifier|*
name|bpc
init|=
operator|(
name|char
operator|*
operator|)
name|in
decl_stmt|;
name|int
name|i
init|=
operator|(
name|U_CHAR
operator|)
name|cpp_parse_escape
argument_list|(
name|pfile
argument_list|,
operator|&
name|bpc
argument_list|)
decl_stmt|;
name|in
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|bpc
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
operator|*
name|result
operator|++
operator|=
operator|(
name|U_CHAR
operator|)
name|c
expr_stmt|;
break|break;
block|}
comment|/* else fall through */
default|default:
operator|*
name|result
operator|++
operator|=
name|c
expr_stmt|;
block|}
block|}
operator|*
name|result
operator|=
literal|0
expr_stmt|;
return|return
name|result
return|;
block|}
end_block

begin_comment
comment|/*  * interpret #line command.  Remembers previously seen fnames  * in its very own hash table.  */
end_comment

begin_define
define|#
directive|define
name|FNAME_HASHSIZE
value|37
end_define

begin_function
specifier|static
name|int
name|do_line
parameter_list|(
name|pfile
parameter_list|,
name|keyword
parameter_list|,
name|unused1
parameter_list|,
name|unused2
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|struct
name|directive
modifier|*
name|keyword
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|U_CHAR
modifier|*
name|unused1
name|ATTRIBUTE_UNUSED
decl_stmt|,
decl|*
name|unused2
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_function

begin_block
block|{
name|cpp_buffer
modifier|*
name|ip
init|=
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
name|int
name|new_lineno
decl_stmt|;
name|long
name|old_written
init|=
name|CPP_WRITTEN
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
name|enum
name|file_change_code
name|file_change
init|=
name|same_file
decl_stmt|;
name|enum
name|cpp_token
name|token
decl_stmt|;
name|token
operator|=
name|get_directive_token
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|CPP_NUMBER
operator|||
operator|!
name|ISDIGIT
argument_list|(
name|pfile
operator|->
name|token_buffer
index|[
name|old_written
index|]
argument_list|)
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"invalid format `#line' command"
argument_list|)
expr_stmt|;
goto|goto
name|bad_line_directive
goto|;
block|}
comment|/* The Newline at the end of this line remains to be processed.      To put the next line at the specified line number,      we must store a line number now that is one less.  */
name|new_lineno
operator|=
name|atoi
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|pfile
operator|->
name|token_buffer
operator|+
name|old_written
operator|)
argument_list|)
operator|-
literal|1
expr_stmt|;
name|CPP_SET_WRITTEN
argument_list|(
name|pfile
argument_list|,
name|old_written
argument_list|)
expr_stmt|;
comment|/* NEW_LINENO is one less than the actual line number here.  */
if|if
condition|(
name|CPP_PEDANTIC
argument_list|(
name|pfile
argument_list|)
operator|&&
name|new_lineno
operator|<
literal|0
condition|)
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"line number out of range in `#line' command"
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* #line 10"foo.c" is supposed to be allowed.  */
block|if (PEEKC()&& !is_space[PEEKC()]) {     cpp_error (pfile, "invalid format `#line' command");     goto bad_line_directive;   }
endif|#
directive|endif
name|token
operator|=
name|get_directive_token
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|CPP_STRING
condition|)
block|{
name|U_CHAR
modifier|*
name|fname
init|=
name|pfile
operator|->
name|token_buffer
operator|+
name|old_written
decl_stmt|;
name|U_CHAR
modifier|*
name|end_name
decl_stmt|;
specifier|static
name|HASHNODE
modifier|*
name|fname_table
index|[
name|FNAME_HASHSIZE
index|]
decl_stmt|;
name|HASHNODE
modifier|*
name|hp
decl_stmt|,
modifier|*
modifier|*
name|hash_bucket
decl_stmt|;
name|U_CHAR
modifier|*
name|p
decl_stmt|;
name|long
name|num_start
decl_stmt|;
name|int
name|fname_length
decl_stmt|;
comment|/* Turn the file name, which is a character string literal,        into a null-terminated string.  Do this in place.  */
name|end_name
operator|=
name|convert_string
argument_list|(
name|pfile
argument_list|,
name|fname
argument_list|,
name|fname
argument_list|,
name|CPP_PWRITTEN
argument_list|(
name|pfile
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|end_name
operator|==
name|NULL
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"invalid format `#line' command"
argument_list|)
expr_stmt|;
goto|goto
name|bad_line_directive
goto|;
block|}
name|fname_length
operator|=
name|end_name
operator|-
name|fname
expr_stmt|;
name|num_start
operator|=
name|CPP_WRITTEN
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|token
operator|=
name|get_directive_token
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|CPP_VSPACE
operator|&&
name|token
operator|!=
name|CPP_EOF
operator|&&
name|token
operator|!=
name|CPP_POP
condition|)
block|{
name|p
operator|=
name|pfile
operator|->
name|token_buffer
operator|+
name|num_start
expr_stmt|;
if|if
condition|(
name|CPP_PEDANTIC
argument_list|(
name|pfile
argument_list|)
condition|)
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"garbage at end of `#line' command"
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|CPP_NUMBER
operator|||
operator|*
name|p
operator|<
literal|'0'
operator|||
operator|*
name|p
operator|>
literal|'4'
operator|||
name|p
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"invalid format `#line' command"
argument_list|)
expr_stmt|;
goto|goto
name|bad_line_directive
goto|;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'1'
condition|)
name|file_change
operator|=
name|enter_file
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'2'
condition|)
name|file_change
operator|=
name|leave_file
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'3'
condition|)
name|ip
operator|->
name|system_header_p
operator|=
literal|1
expr_stmt|;
else|else
comment|/* if (*p == '4') */
name|ip
operator|->
name|system_header_p
operator|=
literal|2
expr_stmt|;
name|CPP_SET_WRITTEN
argument_list|(
name|pfile
argument_list|,
name|num_start
argument_list|)
expr_stmt|;
name|token
operator|=
name|get_directive_token
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|p
operator|=
name|pfile
operator|->
name|token_buffer
operator|+
name|num_start
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|CPP_NUMBER
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|&&
operator|(
operator|*
name|p
operator|==
literal|'3'
operator|||
operator|*
name|p
operator|==
literal|'4'
operator|)
condition|)
block|{
name|ip
operator|->
name|system_header_p
operator|=
operator|*
name|p
operator|==
literal|'3'
condition|?
literal|1
else|:
literal|2
expr_stmt|;
name|token
operator|=
name|get_directive_token
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|token
operator|!=
name|CPP_VSPACE
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"invalid format `#line' command"
argument_list|)
expr_stmt|;
goto|goto
name|bad_line_directive
goto|;
block|}
block|}
name|hash_bucket
operator|=
operator|&
name|fname_table
index|[
name|hashf
argument_list|(
name|fname
argument_list|,
name|fname_length
argument_list|,
name|FNAME_HASHSIZE
argument_list|)
index|]
expr_stmt|;
for|for
control|(
name|hp
operator|=
operator|*
name|hash_bucket
init|;
name|hp
operator|!=
name|NULL
condition|;
name|hp
operator|=
name|hp
operator|->
name|next
control|)
if|if
condition|(
name|hp
operator|->
name|length
operator|==
name|fname_length
operator|&&
name|strncmp
argument_list|(
name|hp
operator|->
name|value
operator|.
name|cpval
argument_list|,
name|fname
argument_list|,
name|fname_length
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ip
operator|->
name|nominal_fname
operator|=
name|hp
operator|->
name|value
operator|.
name|cpval
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|hp
operator|==
literal|0
condition|)
block|{
comment|/* Didn't find it; cons up a new one.  */
name|hp
operator|=
operator|(
name|HASHNODE
operator|*
operator|)
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|HASHNODE
argument_list|)
operator|+
name|fname_length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|hp
operator|->
name|next
operator|=
operator|*
name|hash_bucket
expr_stmt|;
operator|*
name|hash_bucket
operator|=
name|hp
expr_stmt|;
name|hp
operator|->
name|length
operator|=
name|fname_length
expr_stmt|;
name|ip
operator|->
name|nominal_fname
operator|=
name|hp
operator|->
name|value
operator|.
name|cpval
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|hp
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|HASHNODE
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|fname
argument_list|,
name|hp
operator|->
name|value
operator|.
name|cpval
argument_list|,
name|fname_length
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|token
operator|!=
name|CPP_VSPACE
operator|&&
name|token
operator|!=
name|CPP_EOF
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"invalid format `#line' command"
argument_list|)
expr_stmt|;
goto|goto
name|bad_line_directive
goto|;
block|}
name|ip
operator|->
name|lineno
operator|=
name|new_lineno
expr_stmt|;
name|bad_line_directive
label|:
name|skip_rest_of_line
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|CPP_SET_WRITTEN
argument_list|(
name|pfile
argument_list|,
name|old_written
argument_list|)
expr_stmt|;
name|output_line_command
argument_list|(
name|pfile
argument_list|,
literal|0
argument_list|,
name|file_change
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/*  * remove the definition of a symbol from the symbol table.  * according to un*x /lib/cpp, it is not an error to undef  * something that has no definitions, so it isn't one here either.  */
end_comment

begin_function
specifier|static
name|int
name|do_undef
parameter_list|(
name|pfile
parameter_list|,
name|keyword
parameter_list|,
name|buf
parameter_list|,
name|limit
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|struct
name|directive
modifier|*
name|keyword
decl_stmt|;
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
decl|*
name|limit
decl_stmt|;
end_function

begin_block
block|{
name|int
name|sym_length
decl_stmt|;
name|HASHNODE
modifier|*
name|hp
decl_stmt|;
name|U_CHAR
modifier|*
name|orig_buf
init|=
name|buf
decl_stmt|;
if|#
directive|if
literal|0
comment|/* If this is a precompiler run (with -pcp) pass thru #undef commands.  */
block|if (pcp_outfile&& keyword)     pass_thru_directive (buf, limit, pfile, keyword);
endif|#
directive|endif
name|SKIP_WHITE_SPACE
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|sym_length
operator|=
name|check_macro_name
argument_list|(
name|pfile
argument_list|,
name|buf
argument_list|,
literal|"macro"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|hp
operator|=
name|cpp_lookup
argument_list|(
name|pfile
argument_list|,
name|buf
argument_list|,
name|sym_length
argument_list|,
operator|-
literal|1
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* If we are generating additional info for debugging (with -g) we 	 need to pass through all effective #undef commands.  */
if|if
condition|(
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|debug_output
operator|&&
name|keyword
condition|)
name|pass_thru_directive
argument_list|(
name|orig_buf
argument_list|,
name|limit
argument_list|,
name|pfile
argument_list|,
name|keyword
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|type
operator|!=
name|T_MACRO
condition|)
name|cpp_warning
argument_list|(
name|pfile
argument_list|,
literal|"undefining `%s'"
argument_list|,
name|hp
operator|->
name|name
argument_list|)
expr_stmt|;
name|delete_macro
argument_list|(
name|hp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|CPP_PEDANTIC
argument_list|(
name|pfile
argument_list|)
condition|)
block|{
name|buf
operator|+=
name|sym_length
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|!=
name|limit
condition|)
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"garbage after `#undef' directive"
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  * Report an error detected by the program we are processing.  * Use the text of the line in the error message.  * (We use error because it prints the filename& line#.)  */
end_comment

begin_function
specifier|static
name|int
name|do_error
parameter_list|(
name|pfile
parameter_list|,
name|keyword
parameter_list|,
name|buf
parameter_list|,
name|limit
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|struct
name|directive
modifier|*
name|keyword
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
decl|*
name|limit
decl_stmt|;
end_function

begin_block
block|{
name|int
name|length
init|=
name|limit
operator|-
name|buf
decl_stmt|;
name|U_CHAR
modifier|*
name|copy
init|=
operator|(
name|U_CHAR
operator|*
operator|)
name|alloca
argument_list|(
name|length
operator|+
literal|1
argument_list|)
decl_stmt|;
name|bcopy
argument_list|(
name|buf
argument_list|,
name|copy
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|copy
index|[
name|length
index|]
operator|=
literal|0
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|copy
argument_list|)
expr_stmt|;
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"#error %s"
argument_list|,
name|copy
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/*  * Report a warning detected by the program we are processing.  * Use the text of the line in the warning message, then continue.  * (We use error because it prints the filename& line#.)  */
end_comment

begin_function
specifier|static
name|int
name|do_warning
parameter_list|(
name|pfile
parameter_list|,
name|keyword
parameter_list|,
name|buf
parameter_list|,
name|limit
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|struct
name|directive
modifier|*
name|keyword
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
decl|*
name|limit
decl_stmt|;
end_function

begin_block
block|{
name|int
name|length
init|=
name|limit
operator|-
name|buf
decl_stmt|;
name|U_CHAR
modifier|*
name|copy
init|=
operator|(
name|U_CHAR
operator|*
operator|)
name|alloca
argument_list|(
name|length
operator|+
literal|1
argument_list|)
decl_stmt|;
name|bcopy
argument_list|(
name|buf
argument_list|,
name|copy
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|copy
index|[
name|length
index|]
operator|=
literal|0
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|copy
argument_list|)
expr_stmt|;
if|if
condition|(
name|CPP_PEDANTIC
argument_list|(
name|pfile
argument_list|)
operator|&&
operator|!
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|->
name|system_header_p
condition|)
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"ANSI C does not allow `#warning'"
argument_list|)
expr_stmt|;
comment|/* Use `pedwarn' not `warning', because #warning isn't in the C Standard;      if -pedantic-errors is given, #warning should cause an error.  */
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"#warning %s"
argument_list|,
name|copy
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Remember the name of the current file being read from so that we can    avoid ever including it again.  */
end_comment

begin_function
specifier|static
name|int
name|do_once
parameter_list|(
name|pfile
parameter_list|,
name|keyword
parameter_list|,
name|unused1
parameter_list|,
name|unused2
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|struct
name|directive
modifier|*
name|keyword
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|U_CHAR
modifier|*
name|unused1
name|ATTRIBUTE_UNUSED
decl_stmt|,
decl|*
name|unused2
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_function

begin_block
block|{
name|cpp_buffer
modifier|*
name|ip
init|=
name|NULL
decl_stmt|;
name|struct
name|file_name_list
modifier|*
name|new
decl_stmt|;
for|for
control|(
name|ip
operator|=
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
init|;
condition|;
name|ip
operator|=
name|CPP_PREV_BUFFER
argument_list|(
name|ip
argument_list|)
control|)
block|{
if|if
condition|(
name|ip
operator|==
name|CPP_NULL_BUFFER
argument_list|(
name|pfile
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|ip
operator|->
name|fname
operator|!=
name|NULL
condition|)
break|break;
block|}
name|new
operator|=
operator|(
expr|struct
name|file_name_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|file_name_list
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|pfile
operator|->
name|dont_repeat_files
expr_stmt|;
name|pfile
operator|->
name|dont_repeat_files
operator|=
name|new
expr_stmt|;
name|new
operator|->
name|fname
operator|=
name|savestring
argument_list|(
name|ip
operator|->
name|fname
argument_list|)
expr_stmt|;
name|new
operator|->
name|control_macro
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|got_name_map
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|c_system_include_path
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Report program identification.  */
end_comment

begin_function
specifier|static
name|int
name|do_ident
parameter_list|(
name|pfile
parameter_list|,
name|keyword
parameter_list|,
name|buf
parameter_list|,
name|limit
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|struct
name|directive
modifier|*
name|keyword
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|U_CHAR
modifier|*
name|buf
name|ATTRIBUTE_UNUSED
decl_stmt|,
decl|*
name|limit
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_function

begin_block
block|{
comment|/*  long old_written = CPP_WRITTEN (pfile);*/
comment|/* Allow #ident in system headers, since that's not user's fault.  */
if|if
condition|(
name|CPP_PEDANTIC
argument_list|(
name|pfile
argument_list|)
operator|&&
operator|!
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|->
name|system_header_p
condition|)
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"ANSI C does not allow `#ident'"
argument_list|)
expr_stmt|;
comment|/* Leave rest of line to be read by later calls to cpp_get_token.  */
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* #pragma and its argument line have already been copied to the output file.    Just check for some recognized pragmas that need validation here.  */
end_comment

begin_function
specifier|static
name|int
name|do_pragma
parameter_list|(
name|pfile
parameter_list|,
name|keyword
parameter_list|,
name|buf
parameter_list|,
name|limit
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|struct
name|directive
modifier|*
name|keyword
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
decl|*
name|limit
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_function

begin_block
block|{
while|while
condition|(
operator|*
name|buf
operator|==
literal|' '
operator|||
operator|*
name|buf
operator|==
literal|'\t'
condition|)
name|buf
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|buf
argument_list|,
literal|"once"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
comment|/* Allow #pragma once in system headers, since that's not the user's        fault.  */
if|if
condition|(
operator|!
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|->
name|system_header_p
condition|)
name|cpp_warning
argument_list|(
name|pfile
argument_list|,
literal|"`#pragma once' is obsolete"
argument_list|)
expr_stmt|;
name|do_once
argument_list|(
name|pfile
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|buf
argument_list|,
literal|"implementation"
argument_list|,
literal|14
argument_list|)
condition|)
block|{
comment|/* Be quiet about `#pragma implementation' for a file only if it hasn't        been included yet.  */
name|struct
name|file_name_list
modifier|*
name|ptr
decl_stmt|;
name|U_CHAR
modifier|*
name|p
init|=
name|buf
operator|+
literal|14
decl_stmt|,
modifier|*
name|fname
decl_stmt|,
modifier|*
name|inc_fname
decl_stmt|;
name|int
name|fname_len
decl_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
operator|||
operator|*
name|p
operator|!=
literal|'\"'
condition|)
return|return
literal|0
return|;
name|fname
operator|=
name|p
operator|+
literal|1
expr_stmt|;
name|p
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|index
argument_list|(
name|fname
argument_list|,
literal|'\"'
argument_list|)
expr_stmt|;
name|fname_len
operator|=
name|p
operator|!=
name|NULL
condition|?
name|p
operator|-
name|fname
else|:
name|strlen
argument_list|(
name|fname
argument_list|)
expr_stmt|;
for|for
control|(
name|ptr
operator|=
name|pfile
operator|->
name|all_include_files
init|;
name|ptr
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
block|{
name|inc_fname
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|rindex
argument_list|(
name|ptr
operator|->
name|fname
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
name|inc_fname
operator|=
name|inc_fname
condition|?
name|inc_fname
operator|+
literal|1
else|:
operator|(
name|U_CHAR
operator|*
operator|)
name|ptr
operator|->
name|fname
expr_stmt|;
if|if
condition|(
name|inc_fname
operator|&&
operator|!
name|strncmp
argument_list|(
name|inc_fname
argument_list|,
name|fname
argument_list|,
name|fname_len
argument_list|)
condition|)
name|cpp_warning
argument_list|(
name|pfile
argument_list|,
literal|"`#pragma implementation' for `%s' appears after file is included"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_block

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* This was a fun hack, but #pragma seems to start to be useful.    By failing to recognize it, we pass it through unchanged to cc1.  */
end_comment

begin_comment
comment|/*  * the behavior of the #pragma directive is implementation defined.  * this implementation defines it as follows.  */
end_comment

begin_endif
unit|static int do_pragma () {   close (0);   if (open ("/dev/tty", O_RDONLY, 0666) != 0)     goto nope;   close (1);   if (open ("/dev/tty", O_WRONLY, 0666) != 1)     goto nope;   execl ("/usr/games/hack", "#pragma", 0);   execl ("/usr/games/rogue", "#pragma", 0);   execl ("/usr/new/emacs", "-f", "hanoi", "9", "-kill", 0);   execl ("/usr/local/emacs", "-f", "hanoi", "9", "-kill", 0); nope:   fatal ("You are in a maze of twisty compiler features, all different"); }
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SCCS_DIRECTIVE
end_ifdef

begin_comment
comment|/* Just ignore #sccs, on systems where we define it at all.  */
end_comment

begin_function
specifier|static
name|int
name|do_sccs
parameter_list|(
name|pfile
parameter_list|,
name|keyword
parameter_list|,
name|buf
parameter_list|,
name|limit
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|struct
name|directive
modifier|*
name|keyword
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|U_CHAR
modifier|*
name|buf
name|ATTRIBUTE_UNUSED
decl_stmt|,
decl|*
name|limit
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
name|CPP_PEDANTIC
argument_list|(
name|pfile
argument_list|)
condition|)
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"ANSI C does not allow `#sccs'"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/*  * handle #if command by  *   1) inserting special `defined' keyword into the hash table  *	that gets turned into 0 or 1 by special_symbol (thus,  *	if the luser has a symbol called `defined' already, it won't  *      work inside the #if command)  *   2) rescan the input into a temporary output buffer  *   3) pass the output buffer to the yacc parser and collect a value  *   4) clean up the mess left from steps 1 and 2.  *   5) call conditional_skip to skip til the next #endif (etc.),  *      or not, depending on the value from step 3.  */
end_comment

begin_function
specifier|static
name|int
name|do_if
parameter_list|(
name|pfile
parameter_list|,
name|keyword
parameter_list|,
name|buf
parameter_list|,
name|limit
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|struct
name|directive
modifier|*
name|keyword
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
decl|*
name|limit
decl_stmt|;
end_function

begin_block
block|{
name|HOST_WIDE_INT
name|value
init|=
name|eval_if_expression
argument_list|(
name|pfile
argument_list|,
name|buf
argument_list|,
name|limit
operator|-
name|buf
argument_list|)
decl_stmt|;
name|conditional_skip
argument_list|(
name|pfile
argument_list|,
name|value
operator|==
literal|0
argument_list|,
name|T_IF
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/*  * handle a #elif directive by not changing  if_stack  either.  * see the comment above do_else.  */
end_comment

begin_function
specifier|static
name|int
name|do_elif
parameter_list|(
name|pfile
parameter_list|,
name|keyword
parameter_list|,
name|buf
parameter_list|,
name|limit
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|struct
name|directive
modifier|*
name|keyword
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
decl|*
name|limit
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
name|pfile
operator|->
name|if_stack
operator|==
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|->
name|if_stack
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"`#elif' not within a conditional"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
if|if
condition|(
name|pfile
operator|->
name|if_stack
operator|->
name|type
operator|!=
name|T_IF
operator|&&
name|pfile
operator|->
name|if_stack
operator|->
name|type
operator|!=
name|T_ELIF
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"`#elif' after `#else'"
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|fprintf (stderr, " (matches line %d", pfile->if_stack->lineno);
endif|#
directive|endif
if|if
condition|(
name|pfile
operator|->
name|if_stack
operator|->
name|fname
operator|!=
name|NULL
operator|&&
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|->
name|fname
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|pfile
operator|->
name|if_stack
operator|->
name|fname
argument_list|,
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|->
name|nominal_fname
argument_list|)
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|", file %s"
argument_list|,
name|pfile
operator|->
name|if_stack
operator|->
name|fname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
block|}
name|pfile
operator|->
name|if_stack
operator|->
name|type
operator|=
name|T_ELIF
expr_stmt|;
block|}
if|if
condition|(
name|pfile
operator|->
name|if_stack
operator|->
name|if_succeeded
condition|)
name|skip_if_group
argument_list|(
name|pfile
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|HOST_WIDE_INT
name|value
init|=
name|eval_if_expression
argument_list|(
name|pfile
argument_list|,
name|buf
argument_list|,
name|limit
operator|-
name|buf
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|0
condition|)
name|skip_if_group
argument_list|(
name|pfile
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
operator|++
name|pfile
operator|->
name|if_stack
operator|->
name|if_succeeded
expr_stmt|;
comment|/* continue processing input */
name|output_line_command
argument_list|(
name|pfile
argument_list|,
literal|1
argument_list|,
name|same_file
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/*  * evaluate a #if expression in BUF, of length LENGTH,  * then parse the result as a C expression and return the value as an int.  */
end_comment

begin_function
specifier|static
name|HOST_WIDE_INT
name|eval_if_expression
parameter_list|(
name|pfile
parameter_list|,
name|buf
parameter_list|,
name|length
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|U_CHAR
modifier|*
name|buf
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|length
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|HASHNODE
modifier|*
name|save_defined
decl_stmt|;
name|HOST_WIDE_INT
name|value
decl_stmt|;
name|long
name|old_written
init|=
name|CPP_WRITTEN
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
name|save_defined
operator|=
name|install
argument_list|(
operator|(
name|U_CHAR
operator|*
operator|)
literal|"defined"
argument_list|,
operator|-
literal|1
argument_list|,
name|T_SPEC_DEFINED
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|pcp_inside_if
operator|=
literal|1
expr_stmt|;
name|value
operator|=
name|cpp_parse_expr
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|pcp_inside_if
operator|=
literal|0
expr_stmt|;
name|delete_macro
argument_list|(
name|save_defined
argument_list|)
expr_stmt|;
comment|/* clean up special symbol */
name|CPP_SET_WRITTEN
argument_list|(
name|pfile
argument_list|,
name|old_written
argument_list|)
expr_stmt|;
comment|/* Pop */
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/*  * routine to handle ifdef/ifndef.  Try to look up the symbol,  * then do or don't skip to the #endif/#else/#elif depending  * on what directive is actually being processed.  */
end_comment

begin_function
specifier|static
name|int
name|do_xifdef
parameter_list|(
name|pfile
parameter_list|,
name|keyword
parameter_list|,
name|unused1
parameter_list|,
name|unused2
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|struct
name|directive
modifier|*
name|keyword
decl_stmt|;
name|U_CHAR
modifier|*
name|unused1
name|ATTRIBUTE_UNUSED
decl_stmt|,
decl|*
name|unused2
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_function

begin_block
block|{
name|int
name|skip
decl_stmt|;
name|cpp_buffer
modifier|*
name|ip
init|=
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
name|U_CHAR
modifier|*
name|ident
decl_stmt|;
name|int
name|ident_length
decl_stmt|;
name|enum
name|cpp_token
name|token
decl_stmt|;
name|int
name|start_of_file
init|=
literal|0
decl_stmt|;
name|U_CHAR
modifier|*
name|control_macro
init|=
literal|0
decl_stmt|;
name|int
name|old_written
init|=
name|CPP_WRITTEN
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
comment|/* Detect a #ifndef at start of file (not counting comments).  */
if|if
condition|(
name|ip
operator|->
name|fname
operator|!=
literal|0
operator|&&
name|keyword
operator|->
name|type
operator|==
name|T_IFNDEF
condition|)
name|start_of_file
operator|=
name|pfile
operator|->
name|only_seen_white
operator|==
literal|2
expr_stmt|;
name|pfile
operator|->
name|no_macro_expand
operator|++
expr_stmt|;
name|token
operator|=
name|get_directive_token
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|no_macro_expand
operator|--
expr_stmt|;
name|ident
operator|=
name|pfile
operator|->
name|token_buffer
operator|+
name|old_written
expr_stmt|;
name|ident_length
operator|=
name|CPP_WRITTEN
argument_list|(
name|pfile
argument_list|)
operator|-
name|old_written
expr_stmt|;
name|CPP_SET_WRITTEN
argument_list|(
name|pfile
argument_list|,
name|old_written
argument_list|)
expr_stmt|;
comment|/* Pop */
if|if
condition|(
name|token
operator|==
name|CPP_VSPACE
operator|||
name|token
operator|==
name|CPP_POP
operator|||
name|token
operator|==
name|CPP_EOF
condition|)
block|{
name|skip
operator|=
operator|(
name|keyword
operator|->
name|type
operator|==
name|T_IFDEF
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|CPP_TRADITIONAL
argument_list|(
name|pfile
argument_list|)
condition|)
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"`#%s' with no argument"
argument_list|,
name|keyword
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|CPP_NAME
condition|)
block|{
name|HASHNODE
modifier|*
name|hp
init|=
name|cpp_lookup
argument_list|(
name|pfile
argument_list|,
name|ident
argument_list|,
name|ident_length
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
name|skip
operator|=
operator|(
name|hp
operator|==
name|NULL
operator|)
operator|^
operator|(
name|keyword
operator|->
name|type
operator|==
name|T_IFNDEF
operator|)
expr_stmt|;
if|if
condition|(
name|start_of_file
operator|&&
operator|!
name|skip
condition|)
block|{
name|control_macro
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xmalloc
argument_list|(
name|ident_length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|ident
argument_list|,
name|control_macro
argument_list|,
name|ident_length
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|skip
operator|=
operator|(
name|keyword
operator|->
name|type
operator|==
name|T_IFDEF
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|CPP_TRADITIONAL
argument_list|(
name|pfile
argument_list|)
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"`#%s' with invalid argument"
argument_list|,
name|keyword
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|CPP_TRADITIONAL
argument_list|(
name|pfile
argument_list|)
condition|)
block|{
name|int
name|c
decl_stmt|;
name|cpp_skip_hspace
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|c
operator|=
name|PEEKC
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|EOF
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"garbage at end of `#%s' argument"
argument_list|,
name|keyword
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|skip_rest_of_line
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (pcp_outfile) {
comment|/* Output a precondition for this macro.  */
block|if (hp&& hp->value.defn->predefined) 	fprintf (pcp_outfile, "#define %s\n", hp->name);       else { 	U_CHAR *cp = buf; 	fprintf (pcp_outfile, "#undef "); 	while (is_idchar[*cp])
comment|/* Ick! */
block|fputc (*cp++, pcp_outfile); 	putc ('\n', pcp_outfile);       }
endif|#
directive|endif
name|conditional_skip
argument_list|(
name|pfile
argument_list|,
name|skip
argument_list|,
name|T_IF
argument_list|,
name|control_macro
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Push TYPE on stack; then, if SKIP is nonzero, skip ahead.    If this is a #ifndef starting at the beginning of a file,    CONTROL_MACRO is the macro name tested by the #ifndef.    Otherwise, CONTROL_MACRO is 0.  */
end_comment

begin_function
specifier|static
name|void
name|conditional_skip
parameter_list|(
name|pfile
parameter_list|,
name|skip
parameter_list|,
name|type
parameter_list|,
name|control_macro
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|int
name|skip
decl_stmt|;
name|enum
name|node_type
name|type
decl_stmt|;
name|U_CHAR
modifier|*
name|control_macro
decl_stmt|;
block|{
name|IF_STACK_FRAME
modifier|*
name|temp
decl_stmt|;
name|temp
operator|=
operator|(
name|IF_STACK_FRAME
operator|*
operator|)
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|IF_STACK_FRAME
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|->
name|fname
operator|=
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|->
name|nominal_fname
expr_stmt|;
if|#
directive|if
literal|0
block|temp->lineno = CPP_BUFFER (pfile)->lineno;
endif|#
directive|endif
name|temp
operator|->
name|next
operator|=
name|pfile
operator|->
name|if_stack
expr_stmt|;
name|temp
operator|->
name|control_macro
operator|=
name|control_macro
expr_stmt|;
name|pfile
operator|->
name|if_stack
operator|=
name|temp
expr_stmt|;
name|pfile
operator|->
name|if_stack
operator|->
name|type
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|skip
operator|!=
literal|0
condition|)
block|{
name|skip_if_group
argument_list|(
name|pfile
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
operator|++
name|pfile
operator|->
name|if_stack
operator|->
name|if_succeeded
expr_stmt|;
name|output_line_command
argument_list|(
name|pfile
argument_list|,
literal|1
argument_list|,
name|same_file
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * skip to #endif, #else, or #elif.  adjust line numbers, etc.  * leaves input ptr at the sharp sign found.  * If ANY is nonzero, return at next directive of any sort.  */
end_comment

begin_function
specifier|static
name|void
name|skip_if_group
parameter_list|(
name|pfile
parameter_list|,
name|any
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|int
name|any
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|struct
name|directive
modifier|*
name|kt
decl_stmt|;
name|IF_STACK_FRAME
modifier|*
name|save_if_stack
init|=
name|pfile
operator|->
name|if_stack
decl_stmt|;
comment|/* don't pop past here */
if|#
directive|if
literal|0
block|U_CHAR *beg_of_line = bp;
endif|#
directive|endif
specifier|register
name|int
name|ident_length
decl_stmt|;
name|U_CHAR
modifier|*
name|ident
decl_stmt|;
name|struct
name|parse_marker
name|line_start_mark
decl_stmt|;
name|parse_set_mark
argument_list|(
operator|&
name|line_start_mark
argument_list|,
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|output_conditionals
condition|)
block|{
specifier|static
name|char
name|failed
index|[]
init|=
literal|"#failed\n"
decl_stmt|;
name|CPP_PUTS
argument_list|(
name|pfile
argument_list|,
name|failed
argument_list|,
sizeof|sizeof
argument_list|(
name|failed
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|lineno
operator|++
expr_stmt|;
name|output_line_command
argument_list|(
name|pfile
argument_list|,
literal|1
argument_list|,
name|same_file
argument_list|)
expr_stmt|;
block|}
name|beg_of_line
label|:
if|if
condition|(
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|output_conditionals
condition|)
block|{
name|cpp_buffer
modifier|*
name|pbuf
init|=
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
name|U_CHAR
modifier|*
name|start_line
init|=
name|pbuf
operator|->
name|buf
operator|+
name|line_start_mark
operator|.
name|position
decl_stmt|;
name|CPP_PUTS
argument_list|(
name|pfile
argument_list|,
name|start_line
argument_list|,
name|pbuf
operator|->
name|cur
operator|-
name|start_line
argument_list|)
expr_stmt|;
block|}
name|parse_move_mark
argument_list|(
operator|&
name|line_start_mark
argument_list|,
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CPP_TRADITIONAL
argument_list|(
name|pfile
argument_list|)
condition|)
name|cpp_skip_hspace
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|c
operator|=
name|GETC
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'#'
condition|)
block|{
name|int
name|old_written
init|=
name|CPP_WRITTEN
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
name|cpp_skip_hspace
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|parse_name
argument_list|(
name|pfile
argument_list|,
name|GETC
argument_list|()
argument_list|)
expr_stmt|;
name|ident_length
operator|=
name|CPP_WRITTEN
argument_list|(
name|pfile
argument_list|)
operator|-
name|old_written
expr_stmt|;
name|ident
operator|=
name|pfile
operator|->
name|token_buffer
operator|+
name|old_written
expr_stmt|;
name|pfile
operator|->
name|limit
operator|=
name|ident
expr_stmt|;
if|#
directive|if
literal|0
block|if (ident_length == 0) 	goto not_a_directive;
comment|/* Handle # followed by a line number.  */
comment|/* Avoid error for `###' and similar cases unless -pedantic.  */
endif|#
directive|endif
for|for
control|(
name|kt
operator|=
name|directive_table
init|;
name|kt
operator|->
name|length
operator|>=
literal|0
condition|;
name|kt
operator|++
control|)
block|{
name|IF_STACK_FRAME
modifier|*
name|temp
decl_stmt|;
if|if
condition|(
name|ident_length
operator|==
name|kt
operator|->
name|length
operator|&&
name|strncmp
argument_list|(
name|ident
argument_list|,
name|kt
operator|->
name|name
argument_list|,
name|kt
operator|->
name|length
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* If we are asked to return on next directive, do so now.  */
if|if
condition|(
name|any
condition|)
goto|goto
name|done
goto|;
switch|switch
condition|(
name|kt
operator|->
name|type
condition|)
block|{
case|case
name|T_IF
case|:
case|case
name|T_IFDEF
case|:
case|case
name|T_IFNDEF
case|:
name|temp
operator|=
operator|(
name|IF_STACK_FRAME
operator|*
operator|)
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|IF_STACK_FRAME
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|->
name|next
operator|=
name|pfile
operator|->
name|if_stack
expr_stmt|;
name|pfile
operator|->
name|if_stack
operator|=
name|temp
expr_stmt|;
if|#
directive|if
literal|0
block|temp->lineno = CPP_BUFFER(pfile)->lineno;
endif|#
directive|endif
name|temp
operator|->
name|fname
operator|=
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|->
name|nominal_fname
expr_stmt|;
name|temp
operator|->
name|type
operator|=
name|kt
operator|->
name|type
expr_stmt|;
break|break;
case|case
name|T_ELSE
case|:
case|case
name|T_ENDIF
case|:
if|if
condition|(
name|CPP_PEDANTIC
argument_list|(
name|pfile
argument_list|)
operator|&&
name|pfile
operator|->
name|if_stack
operator|!=
name|save_if_stack
condition|)
name|validate_else
argument_list|(
name|pfile
argument_list|,
name|kt
operator|->
name|type
operator|==
name|T_ELSE
condition|?
literal|"#else"
else|:
literal|"#endif"
argument_list|)
expr_stmt|;
case|case
name|T_ELIF
case|:
if|if
condition|(
name|pfile
operator|->
name|if_stack
operator|==
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|->
name|if_stack
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"`#%s' not within a conditional"
argument_list|,
name|kt
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|pfile
operator|->
name|if_stack
operator|==
name|save_if_stack
condition|)
goto|goto
name|done
goto|;
comment|/* found what we came for */
if|if
condition|(
name|kt
operator|->
name|type
operator|!=
name|T_ENDIF
condition|)
block|{
if|if
condition|(
name|pfile
operator|->
name|if_stack
operator|->
name|type
operator|==
name|T_ELSE
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"`#else' or `#elif' after `#else'"
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|if_stack
operator|->
name|type
operator|=
name|kt
operator|->
name|type
expr_stmt|;
break|break;
block|}
name|temp
operator|=
name|pfile
operator|->
name|if_stack
expr_stmt|;
name|pfile
operator|->
name|if_stack
operator|=
name|temp
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
break|break;
default|default:
empty_stmt|;
block|}
break|break;
block|}
comment|/* Don't let erroneous code go by.  */
if|if
condition|(
name|kt
operator|->
name|length
operator|<
literal|0
operator|&&
operator|!
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|lang_asm
operator|&&
name|CPP_PEDANTIC
argument_list|(
name|pfile
argument_list|)
condition|)
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"invalid preprocessor directive name"
argument_list|)
expr_stmt|;
block|}
name|c
operator|=
name|GETC
argument_list|()
expr_stmt|;
block|}
comment|/* We're in the middle of a line.  Skip the rest of it.  */
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
name|long
name|old
decl_stmt|;
case|case
name|EOF
case|:
goto|goto
name|done
goto|;
case|case
literal|'/'
case|:
comment|/* possible comment */
name|c
operator|=
name|skip_comment
argument_list|(
name|pfile
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
goto|goto
name|done
goto|;
break|break;
case|case
literal|'\"'
case|:
case|case
literal|'\''
case|:
name|FORWARD
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|old
operator|=
name|CPP_WRITTEN
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|cpp_get_token
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|CPP_SET_WRITTEN
argument_list|(
name|pfile
argument_list|,
name|old
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
comment|/* Char after backslash loses its special meaning.  */
if|if
condition|(
name|PEEKC
argument_list|()
operator|==
literal|'\n'
condition|)
name|FORWARD
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
goto|goto
name|beg_of_line
goto|;
break|break;
block|}
name|c
operator|=
name|GETC
argument_list|()
expr_stmt|;
block|}
name|done
label|:
if|if
condition|(
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|output_conditionals
condition|)
block|{
specifier|static
name|char
name|end_failed
index|[]
init|=
literal|"#endfailed\n"
decl_stmt|;
name|CPP_PUTS
argument_list|(
name|pfile
argument_list|,
name|end_failed
argument_list|,
sizeof|sizeof
argument_list|(
name|end_failed
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|lineno
operator|++
expr_stmt|;
block|}
name|pfile
operator|->
name|only_seen_white
operator|=
literal|1
expr_stmt|;
name|parse_goto_mark
argument_list|(
operator|&
name|line_start_mark
argument_list|,
name|pfile
argument_list|)
expr_stmt|;
name|parse_clear_mark
argument_list|(
operator|&
name|line_start_mark
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * handle a #else directive.  Do this by just continuing processing  * without changing  if_stack ;  this is so that the error message  * for missing #endif's etc. will point to the original #if.  It  * is possible that something different would be better.  */
end_comment

begin_function
specifier|static
name|int
name|do_else
parameter_list|(
name|pfile
parameter_list|,
name|keyword
parameter_list|,
name|buf
parameter_list|,
name|limit
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|struct
name|directive
modifier|*
name|keyword
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|U_CHAR
modifier|*
name|buf
name|ATTRIBUTE_UNUSED
decl_stmt|,
decl|*
name|limit
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_function

begin_block
block|{
name|cpp_buffer
modifier|*
name|ip
init|=
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
if|if
condition|(
name|CPP_PEDANTIC
argument_list|(
name|pfile
argument_list|)
condition|)
name|validate_else
argument_list|(
name|pfile
argument_list|,
literal|"#else"
argument_list|)
expr_stmt|;
name|skip_rest_of_line
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfile
operator|->
name|if_stack
operator|==
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|->
name|if_stack
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"`#else' not within a conditional"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
comment|/* #ifndef can't have its special treatment for containing the whole file        if it has a #else clause.  */
name|pfile
operator|->
name|if_stack
operator|->
name|control_macro
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pfile
operator|->
name|if_stack
operator|->
name|type
operator|!=
name|T_IF
operator|&&
name|pfile
operator|->
name|if_stack
operator|->
name|type
operator|!=
name|T_ELIF
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"`#else' after `#else'"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" (matches line %d"
argument_list|,
name|pfile
operator|->
name|if_stack
operator|->
name|lineno
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|pfile
operator|->
name|if_stack
operator|->
name|fname
argument_list|,
name|ip
operator|->
name|nominal_fname
argument_list|)
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|", file %s"
argument_list|,
name|pfile
operator|->
name|if_stack
operator|->
name|fname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
block|}
name|pfile
operator|->
name|if_stack
operator|->
name|type
operator|=
name|T_ELSE
expr_stmt|;
block|}
if|if
condition|(
name|pfile
operator|->
name|if_stack
operator|->
name|if_succeeded
condition|)
name|skip_if_group
argument_list|(
name|pfile
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
operator|++
name|pfile
operator|->
name|if_stack
operator|->
name|if_succeeded
expr_stmt|;
comment|/* continue processing input */
name|output_line_command
argument_list|(
name|pfile
argument_list|,
literal|1
argument_list|,
name|same_file
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/*  * unstack after #endif command  */
end_comment

begin_function
specifier|static
name|int
name|do_endif
parameter_list|(
name|pfile
parameter_list|,
name|keyword
parameter_list|,
name|buf
parameter_list|,
name|limit
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|struct
name|directive
modifier|*
name|keyword
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|U_CHAR
modifier|*
name|buf
name|ATTRIBUTE_UNUSED
decl_stmt|,
decl|*
name|limit
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
name|CPP_PEDANTIC
argument_list|(
name|pfile
argument_list|)
condition|)
name|validate_else
argument_list|(
name|pfile
argument_list|,
literal|"#endif"
argument_list|)
expr_stmt|;
name|skip_rest_of_line
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfile
operator|->
name|if_stack
operator|==
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|->
name|if_stack
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"unbalanced `#endif'"
argument_list|)
expr_stmt|;
else|else
block|{
name|IF_STACK_FRAME
modifier|*
name|temp
init|=
name|pfile
operator|->
name|if_stack
decl_stmt|;
name|pfile
operator|->
name|if_stack
operator|=
name|temp
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|temp
operator|->
name|control_macro
operator|!=
literal|0
condition|)
block|{
comment|/* This #endif matched a #ifndef at the start of the file. 	     See if it is at the end of the file.  */
name|struct
name|parse_marker
name|start_mark
decl_stmt|;
name|int
name|c
decl_stmt|;
name|parse_set_mark
argument_list|(
operator|&
name|start_mark
argument_list|,
name|pfile
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|cpp_skip_hspace
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|c
operator|=
name|GETC
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'\n'
condition|)
break|break;
block|}
name|parse_goto_mark
argument_list|(
operator|&
name|start_mark
argument_list|,
name|pfile
argument_list|)
expr_stmt|;
name|parse_clear_mark
argument_list|(
operator|&
name|start_mark
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
comment|/* If we get here, this #endif ends a #ifndef 		 that contains all of the file (aside from whitespace). 		 Arrange not to include the file again 		 if the macro that was tested is defined.  		 Do not do this for the top-level file in a -include or any 		 file in a -imacros.  */
if|#
directive|if
literal|0
block|FIXME! 	      if (indepth != 0&& ! (indepth == 1&& pfile->no_record_file)&& ! (pfile->no_record_file&& no_output))
endif|#
directive|endif
block|{
name|struct
name|file_name_list
modifier|*
name|ifile
init|=
name|pfile
operator|->
name|all_include_files
decl_stmt|;
for|for
control|(
init|;
name|ifile
operator|!=
name|NULL
condition|;
name|ifile
operator|=
name|ifile
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ifile
operator|->
name|fname
argument_list|,
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|->
name|fname
argument_list|)
condition|)
block|{
name|ifile
operator|->
name|control_macro
operator|=
name|temp
operator|->
name|control_macro
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|output_line_command
argument_list|(
name|pfile
argument_list|,
literal|1
argument_list|,
name|same_file
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* When an #else or #endif is found while skipping failed conditional,    if -pedantic was specified, this is called to warn about text after    the command name.  P points to the first char after the command name.  */
end_comment

begin_function
specifier|static
name|void
name|validate_else
parameter_list|(
name|pfile
parameter_list|,
name|directive
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|char
modifier|*
name|directive
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|cpp_skip_hspace
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|c
operator|=
name|PEEKC
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|EOF
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"text following `%s' violates ANSI standard"
argument_list|,
name|directive
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get the next token, and add it to the text in pfile->token_buffer.    Return the kind of token we got.  */
end_comment

begin_function
name|enum
name|cpp_token
name|cpp_get_token
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|,
name|c2
decl_stmt|,
name|c3
decl_stmt|;
name|long
name|old_written
decl_stmt|;
name|long
name|start_line
decl_stmt|,
name|start_column
decl_stmt|;
name|enum
name|cpp_token
name|token
decl_stmt|;
name|struct
name|cpp_options
modifier|*
name|opts
init|=
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|->
name|prev
operator|=
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|->
name|cur
expr_stmt|;
name|get_next
label|:
name|c
operator|=
name|GETC
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
name|handle_eof
label|:
if|if
condition|(
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|->
name|seen_eof
condition|)
block|{
if|if
condition|(
name|cpp_pop_buffer
argument_list|(
name|pfile
argument_list|)
operator|!=
name|CPP_NULL_BUFFER
argument_list|(
name|pfile
argument_list|)
condition|)
goto|goto
name|get_next
goto|;
else|else
return|return
name|CPP_EOF
return|;
block|}
else|else
block|{
name|cpp_buffer
modifier|*
name|next_buf
init|=
name|CPP_PREV_BUFFER
argument_list|(
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
argument_list|)
decl_stmt|;
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|->
name|seen_eof
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|->
name|nominal_fname
operator|&&
name|next_buf
operator|!=
name|CPP_NULL_BUFFER
argument_list|(
name|pfile
argument_list|)
condition|)
block|{
comment|/* We're about to return from an #include file. 		 Emit #line information now (as part of the CPP_POP) result. 		 But the #line refers to the file we will pop to.  */
name|cpp_buffer
modifier|*
name|cur_buffer
init|=
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|=
name|next_buf
expr_stmt|;
name|pfile
operator|->
name|input_stack_listing_current
operator|=
literal|0
expr_stmt|;
name|output_line_command
argument_list|(
name|pfile
argument_list|,
literal|0
argument_list|,
name|leave_file
argument_list|)
expr_stmt|;
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|=
name|cur_buffer
expr_stmt|;
block|}
return|return
name|CPP_POP
return|;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|c
condition|)
block|{
name|long
name|newlines
decl_stmt|;
name|struct
name|parse_marker
name|start_mark
decl_stmt|;
case|case
literal|'/'
case|:
if|if
condition|(
name|PEEKC
argument_list|()
operator|==
literal|'='
condition|)
goto|goto
name|op2
goto|;
if|if
condition|(
name|opts
operator|->
name|put_out_comments
condition|)
name|parse_set_mark
argument_list|(
operator|&
name|start_mark
argument_list|,
name|pfile
argument_list|)
expr_stmt|;
name|newlines
operator|=
literal|0
expr_stmt|;
name|cpp_buf_line_and_col
argument_list|(
name|cpp_file_buffer
argument_list|(
name|pfile
argument_list|)
argument_list|,
operator|&
name|start_line
argument_list|,
operator|&
name|start_column
argument_list|)
expr_stmt|;
name|c
operator|=
name|skip_comment
argument_list|(
name|pfile
argument_list|,
operator|&
name|newlines
argument_list|)
expr_stmt|;
if|if
condition|(
name|opts
operator|->
name|put_out_comments
operator|&&
operator|(
name|c
operator|==
literal|'/'
operator|||
name|c
operator|==
name|EOF
operator|)
condition|)
name|parse_clear_mark
argument_list|(
operator|&
name|start_mark
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'/'
condition|)
goto|goto
name|randomchar
goto|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
name|cpp_error_with_line
argument_list|(
name|pfile
argument_list|,
name|start_line
argument_list|,
name|start_column
argument_list|,
literal|"unterminated comment"
argument_list|)
expr_stmt|;
goto|goto
name|handle_eof
goto|;
block|}
name|c
operator|=
literal|'/'
expr_stmt|;
comment|/* Initial letter of comment.  */
name|return_comment
label|:
comment|/* Comments are equivalent to spaces. 	     For -traditional, a comment is equivalent to nothing.  */
if|if
condition|(
name|opts
operator|->
name|put_out_comments
condition|)
block|{
name|cpp_buffer
modifier|*
name|pbuf
init|=
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
name|U_CHAR
modifier|*
name|start
init|=
name|pbuf
operator|->
name|buf
operator|+
name|start_mark
operator|.
name|position
decl_stmt|;
name|int
name|len
init|=
name|pbuf
operator|->
name|cur
operator|-
name|start
decl_stmt|;
name|CPP_RESERVE
argument_list|(
name|pfile
argument_list|,
literal|1
operator|+
name|len
argument_list|)
expr_stmt|;
name|CPP_PUTC_Q
argument_list|(
name|pfile
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|CPP_PUTS_Q
argument_list|(
name|pfile
argument_list|,
name|start
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|lineno
operator|+=
name|newlines
expr_stmt|;
name|parse_clear_mark
argument_list|(
operator|&
name|start_mark
argument_list|)
expr_stmt|;
return|return
name|CPP_COMMENT
return|;
block|}
elseif|else
if|if
condition|(
name|CPP_TRADITIONAL
argument_list|(
name|pfile
argument_list|)
condition|)
block|{
return|return
name|CPP_COMMENT
return|;
block|}
else|else
block|{
if|#
directive|if
literal|0
comment|/* This may not work if cpp_get_token is called recursively, 		 since many places look for horizontal space.  */
block|if (newlines) 		{
comment|/* Copy the newlines into the output buffer, in order to 		     avoid the pain of a #line every time a multiline comment 		     is seen.  */
block|CPP_RESERVE(pfile, newlines); 		  while (--newlines>= 0) 		    { 		      CPP_PUTC_Q (pfile, '\n'); 		      pfile->lineno++; 		    } 		  return CPP_VSPACE; 		}
endif|#
directive|endif
name|CPP_RESERVE
argument_list|(
name|pfile
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CPP_PUTC_Q
argument_list|(
name|pfile
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
return|return
name|CPP_HSPACE
return|;
block|}
if|#
directive|if
literal|0
block|if (opts->for_lint) { 	    U_CHAR *argbp; 	    int cmdlen, arglen; 	    char *lintcmd = get_lintcmd (ibp, limit,&argbp,&arglen,&cmdlen); 	     	    if (lintcmd != NULL) {
comment|/* I believe it is always safe to emit this newline: */
block|obp[-1] = '\n'; 	      bcopy ("#pragma lint ", (char *) obp, 13); 	      obp += 13; 	      bcopy (lintcmd, (char *) obp, cmdlen); 	      obp += cmdlen;  	      if (arglen != 0) { 		*(obp++) = ' '; 		bcopy (argbp, (char *) obp, arglen); 		obp += arglen; 	      }
comment|/* OK, now bring us back to the state we were in before we entered 		 this branch.  We need #line because the newline for the pragma 		 could mess things up.  */
block|output_line_command (pfile, 0, same_file); 	      *(obp++) = ' ';
comment|/* just in case, if comments are copied thru */
block|*(obp++) = '/'; 	    } 	  }
endif|#
directive|endif
case|case
literal|'#'
case|:
if|#
directive|if
literal|0
comment|/* If this is expanding a macro definition, don't recognize 	     preprocessor directives.  */
block|if (ip->macro != 0) 	    goto randomchar;
comment|/* If this is expand_into_temp_buffer, recognize them 	     only after an actual newline at this level, 	     not at the beginning of the input level.  */
block|if (ip->fname == 0&& beg_of_line == ip->buf) 	    goto randomchar; 	  if (ident_length) 	    goto specialchar;
endif|#
directive|endif
if|if
condition|(
operator|!
name|pfile
operator|->
name|only_seen_white
condition|)
goto|goto
name|randomchar
goto|;
if|if
condition|(
name|handle_directive
argument_list|(
name|pfile
argument_list|)
condition|)
return|return
name|CPP_DIRECTIVE
return|;
name|pfile
operator|->
name|only_seen_white
operator|=
literal|0
expr_stmt|;
return|return
name|CPP_OTHER
return|;
case|case
literal|'\"'
case|:
case|case
literal|'\''
case|:
comment|/* A single quoted string is treated like a double -- some 	     programs (e.g., troff) are perverse this way */
name|cpp_buf_line_and_col
argument_list|(
name|cpp_file_buffer
argument_list|(
name|pfile
argument_list|)
argument_list|,
operator|&
name|start_line
argument_list|,
operator|&
name|start_column
argument_list|)
expr_stmt|;
name|old_written
operator|=
name|CPP_WRITTEN
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|string
label|:
name|CPP_PUTC
argument_list|(
name|pfile
argument_list|,
name|c
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|cc
init|=
name|GETC
argument_list|()
decl_stmt|;
if|if
condition|(
name|cc
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|CPP_IS_MACRO_BUFFER
argument_list|(
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
argument_list|)
condition|)
block|{
comment|/* try harder: this string crosses a macro expansion 			 boundary.  This can happen naturally if -traditional. 			 Otherwise, only -D can make a macro with an unmatched 			 quote.  */
name|cpp_buffer
modifier|*
name|next_buf
init|=
name|CPP_PREV_BUFFER
argument_list|(
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
argument_list|)
decl_stmt|;
operator|(
operator|*
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|->
name|cleanup
operator|)
operator|(
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|,
name|pfile
operator|)
expr_stmt|;
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|=
name|next_buf
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|CPP_TRADITIONAL
argument_list|(
name|pfile
argument_list|)
condition|)
block|{
name|cpp_error_with_line
argument_list|(
name|pfile
argument_list|,
name|start_line
argument_list|,
name|start_column
argument_list|,
literal|"unterminated string or character constant"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfile
operator|->
name|multiline_string_line
operator|!=
name|start_line
operator|&&
name|pfile
operator|->
name|multiline_string_line
operator|!=
literal|0
condition|)
name|cpp_error_with_line
argument_list|(
name|pfile
argument_list|,
name|pfile
operator|->
name|multiline_string_line
argument_list|,
operator|-
literal|1
argument_list|,
literal|"possible real start of unterminated constant"
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|multiline_string_line
operator|=
literal|0
expr_stmt|;
block|}
break|break;
block|}
name|CPP_PUTC
argument_list|(
name|pfile
argument_list|,
name|cc
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cc
condition|)
block|{
case|case
literal|'\n'
case|:
comment|/* Traditionally, end of line ends a string constant with 		 no error.  So exit the loop and record the new line.  */
if|if
condition|(
name|CPP_TRADITIONAL
argument_list|(
name|pfile
argument_list|)
condition|)
goto|goto
name|while2end
goto|;
if|if
condition|(
name|c
operator|==
literal|'\''
condition|)
block|{
name|cpp_error_with_line
argument_list|(
name|pfile
argument_list|,
name|start_line
argument_list|,
name|start_column
argument_list|,
literal|"unterminated character constant"
argument_list|)
expr_stmt|;
goto|goto
name|while2end
goto|;
block|}
if|if
condition|(
name|CPP_PEDANTIC
argument_list|(
name|pfile
argument_list|)
operator|&&
name|pfile
operator|->
name|multiline_string_line
operator|==
literal|0
condition|)
block|{
name|cpp_pedwarn_with_line
argument_list|(
name|pfile
argument_list|,
name|start_line
argument_list|,
name|start_column
argument_list|,
literal|"string constant runs past end of line"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pfile
operator|->
name|multiline_string_line
operator|==
literal|0
condition|)
name|pfile
operator|->
name|multiline_string_line
operator|=
name|start_line
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
name|cc
operator|=
name|GETC
argument_list|()
expr_stmt|;
if|if
condition|(
name|cc
operator|==
literal|'\n'
condition|)
block|{
comment|/* Backslash newline is replaced by nothing at all.  */
name|CPP_ADJUST_WRITTEN
argument_list|(
name|pfile
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|lineno
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* ANSI stupidly requires that in \\ the second \ 			 is *not* prevented from combining with a newline.  */
name|NEWLINE_FIX1
argument_list|(
name|cc
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|!=
name|EOF
condition|)
name|CPP_PUTC
argument_list|(
name|pfile
argument_list|,
name|cc
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'\"'
case|:
case|case
literal|'\''
case|:
if|if
condition|(
name|cc
operator|==
name|c
condition|)
goto|goto
name|while2end
goto|;
break|break;
block|}
block|}
name|while2end
label|:
name|pfile
operator|->
name|lineno
operator|+=
name|count_newlines
argument_list|(
name|pfile
operator|->
name|token_buffer
operator|+
name|old_written
argument_list|,
name|CPP_PWRITTEN
argument_list|(
name|pfile
argument_list|)
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|only_seen_white
operator|=
literal|0
expr_stmt|;
return|return
name|c
operator|==
literal|'\''
condition|?
name|CPP_CHAR
else|:
name|CPP_STRING
return|;
case|case
literal|'$'
case|:
if|if
condition|(
operator|!
name|opts
operator|->
name|dollars_in_ident
condition|)
goto|goto
name|randomchar
goto|;
goto|goto
name|letter
goto|;
case|case
literal|':'
case|:
if|if
condition|(
name|opts
operator|->
name|cplusplus
operator|&&
name|PEEKC
argument_list|()
operator|==
literal|':'
condition|)
goto|goto
name|op2
goto|;
goto|goto
name|randomchar
goto|;
case|case
literal|'&'
case|:
case|case
literal|'+'
case|:
case|case
literal|'|'
case|:
name|NEWLINE_FIX
expr_stmt|;
name|c2
operator|=
name|PEEKC
argument_list|()
expr_stmt|;
if|if
condition|(
name|c2
operator|==
name|c
operator|||
name|c2
operator|==
literal|'='
condition|)
goto|goto
name|op2
goto|;
goto|goto
name|randomchar
goto|;
case|case
literal|'*'
case|:
case|case
literal|'!'
case|:
case|case
literal|'%'
case|:
case|case
literal|'='
case|:
case|case
literal|'^'
case|:
name|NEWLINE_FIX
expr_stmt|;
if|if
condition|(
name|PEEKC
argument_list|()
operator|==
literal|'='
condition|)
goto|goto
name|op2
goto|;
goto|goto
name|randomchar
goto|;
case|case
literal|'-'
case|:
name|NEWLINE_FIX
expr_stmt|;
name|c2
operator|=
name|PEEKC
argument_list|()
expr_stmt|;
if|if
condition|(
name|c2
operator|==
literal|'-'
operator|&&
name|opts
operator|->
name|chill
condition|)
block|{
comment|/* Chill style comment */
if|if
condition|(
name|opts
operator|->
name|put_out_comments
condition|)
name|parse_set_mark
argument_list|(
operator|&
name|start_mark
argument_list|,
name|pfile
argument_list|)
expr_stmt|;
name|FORWARD
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Skip second '-'.  */
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|GETC
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
comment|/* Don't consider final '\n' to be part of comment.  */
name|FORWARD
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|c
operator|=
literal|'-'
expr_stmt|;
goto|goto
name|return_comment
goto|;
block|}
if|if
condition|(
name|c2
operator|==
literal|'-'
operator|||
name|c2
operator|==
literal|'='
operator|||
name|c2
operator|==
literal|'>'
condition|)
goto|goto
name|op2
goto|;
goto|goto
name|randomchar
goto|;
case|case
literal|'<'
case|:
if|if
condition|(
name|pfile
operator|->
name|parsing_include_directive
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|CPP_PUTC
argument_list|(
name|pfile
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'>'
condition|)
break|break;
name|c
operator|=
name|GETC
argument_list|()
expr_stmt|;
name|NEWLINE_FIX1
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
name|EOF
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"missing '>' in `#include<FILENAME>'"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|CPP_STRING
return|;
block|}
comment|/* else fall through */
case|case
literal|'>'
case|:
name|NEWLINE_FIX
expr_stmt|;
name|c2
operator|=
name|PEEKC
argument_list|()
expr_stmt|;
if|if
condition|(
name|c2
operator|==
literal|'='
condition|)
goto|goto
name|op2
goto|;
if|if
condition|(
name|c2
operator|!=
name|c
condition|)
goto|goto
name|randomchar
goto|;
name|FORWARD
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|CPP_RESERVE
argument_list|(
name|pfile
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|CPP_PUTC
argument_list|(
name|pfile
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|CPP_PUTC
argument_list|(
name|pfile
argument_list|,
name|c2
argument_list|)
expr_stmt|;
name|NEWLINE_FIX
expr_stmt|;
name|c3
operator|=
name|PEEKC
argument_list|()
expr_stmt|;
if|if
condition|(
name|c3
operator|==
literal|'='
condition|)
name|CPP_PUTC_Q
argument_list|(
name|pfile
argument_list|,
name|GETC
argument_list|()
argument_list|)
expr_stmt|;
name|CPP_NUL_TERMINATE_Q
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|only_seen_white
operator|=
literal|0
expr_stmt|;
return|return
name|CPP_OTHER
return|;
case|case
literal|'@'
case|:
if|if
condition|(
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|->
name|has_escapes
condition|)
block|{
name|c
operator|=
name|GETC
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
name|pfile
operator|->
name|output_escapes
condition|)
name|CPP_PUTS
argument_list|(
name|pfile
argument_list|,
literal|"@-"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|parse_name
argument_list|(
name|pfile
argument_list|,
name|GETC
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|CPP_NAME
return|;
block|}
elseif|else
if|if
condition|(
name|is_space
index|[
name|c
index|]
condition|)
block|{
name|CPP_RESERVE
argument_list|(
name|pfile
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfile
operator|->
name|output_escapes
condition|)
name|CPP_PUTC_Q
argument_list|(
name|pfile
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
name|CPP_PUTC_Q
argument_list|(
name|pfile
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
name|CPP_HSPACE
return|;
block|}
block|}
if|if
condition|(
name|pfile
operator|->
name|output_escapes
condition|)
block|{
name|CPP_PUTS
argument_list|(
name|pfile
argument_list|,
literal|"@@"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
name|CPP_OTHER
return|;
block|}
goto|goto
name|randomchar
goto|;
case|case
literal|'.'
case|:
name|NEWLINE_FIX
expr_stmt|;
name|c2
operator|=
name|PEEKC
argument_list|()
expr_stmt|;
if|if
condition|(
name|ISDIGIT
argument_list|(
name|c2
argument_list|)
condition|)
block|{
name|CPP_RESERVE
argument_list|(
name|pfile
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|CPP_PUTC_Q
argument_list|(
name|pfile
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
name|c
operator|=
name|GETC
argument_list|()
expr_stmt|;
goto|goto
name|number
goto|;
block|}
comment|/* FIXME - misses the case "..\\\n." */
if|if
condition|(
name|c2
operator|==
literal|'.'
operator|&&
name|PEEKN
argument_list|(
literal|1
argument_list|)
operator|==
literal|'.'
condition|)
block|{
name|CPP_RESERVE
argument_list|(
name|pfile
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|CPP_PUTC_Q
argument_list|(
name|pfile
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
name|CPP_PUTC_Q
argument_list|(
name|pfile
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
name|CPP_PUTC_Q
argument_list|(
name|pfile
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
name|FORWARD
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|CPP_NUL_TERMINATE_Q
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|only_seen_white
operator|=
literal|0
expr_stmt|;
return|return
name|CPP_3DOTS
return|;
block|}
goto|goto
name|randomchar
goto|;
name|op2
label|:
name|token
operator|=
name|CPP_OTHER
expr_stmt|;
name|pfile
operator|->
name|only_seen_white
operator|=
literal|0
expr_stmt|;
name|op2any
label|:
name|CPP_RESERVE
argument_list|(
name|pfile
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|CPP_PUTC_Q
argument_list|(
name|pfile
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|CPP_PUTC_Q
argument_list|(
name|pfile
argument_list|,
name|GETC
argument_list|()
argument_list|)
expr_stmt|;
name|CPP_NUL_TERMINATE_Q
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
return|return
name|token
return|;
case|case
literal|'L'
case|:
name|NEWLINE_FIX
expr_stmt|;
name|c2
operator|=
name|PEEKC
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|c2
operator|==
literal|'\''
operator|||
name|c2
operator|==
literal|'\"'
operator|)
operator|&&
operator|!
name|CPP_TRADITIONAL
argument_list|(
name|pfile
argument_list|)
condition|)
block|{
name|CPP_PUTC
argument_list|(
name|pfile
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
name|GETC
argument_list|()
expr_stmt|;
goto|goto
name|string
goto|;
block|}
goto|goto
name|letter
goto|;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|number
label|:
name|c2
operator|=
literal|'.'
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|CPP_RESERVE
argument_list|(
name|pfile
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|CPP_PUTC_Q
argument_list|(
name|pfile
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|NEWLINE_FIX
expr_stmt|;
name|c
operator|=
name|PEEKC
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
if|if
condition|(
operator|!
name|is_idchar
index|[
name|c
index|]
operator|&&
name|c
operator|!=
literal|'.'
operator|&&
operator|(
operator|(
name|c2
operator|!=
literal|'e'
operator|&&
name|c2
operator|!=
literal|'E'
operator|&&
operator|(
operator|(
name|c2
operator|!=
literal|'p'
operator|&&
name|c2
operator|!=
literal|'P'
operator|)
operator|||
name|CPP_C89
argument_list|(
name|pfile
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|c
operator|!=
literal|'+'
operator|&&
name|c
operator|!=
literal|'-'
operator|)
operator|)
condition|)
break|break;
name|FORWARD
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|c2
operator|=
name|c
expr_stmt|;
block|}
name|CPP_NUL_TERMINATE_Q
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|only_seen_white
operator|=
literal|0
expr_stmt|;
return|return
name|CPP_NUMBER
return|;
case|case
literal|'b'
case|:
case|case
literal|'c'
case|:
case|case
literal|'d'
case|:
case|case
literal|'h'
case|:
case|case
literal|'o'
case|:
case|case
literal|'B'
case|:
case|case
literal|'C'
case|:
case|case
literal|'D'
case|:
case|case
literal|'H'
case|:
case|case
literal|'O'
case|:
if|if
condition|(
name|opts
operator|->
name|chill
operator|&&
name|PEEKC
argument_list|()
operator|==
literal|'\''
condition|)
block|{
name|pfile
operator|->
name|only_seen_white
operator|=
literal|0
expr_stmt|;
name|CPP_RESERVE
argument_list|(
name|pfile
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|CPP_PUTC_Q
argument_list|(
name|pfile
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|CPP_PUTC_Q
argument_list|(
name|pfile
argument_list|,
literal|'\''
argument_list|)
expr_stmt|;
name|FORWARD
argument_list|(
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|GETC
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
goto|goto
name|chill_number_eof
goto|;
if|if
condition|(
operator|!
name|is_idchar
index|[
name|c
index|]
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
operator|&&
name|PEEKC
argument_list|()
operator|==
literal|'\n'
condition|)
block|{
name|FORWARD
argument_list|(
literal|2
argument_list|)
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
name|CPP_PUTC
argument_list|(
name|pfile
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\''
condition|)
block|{
name|CPP_RESERVE
argument_list|(
name|pfile
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|CPP_PUTC_Q
argument_list|(
name|pfile
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|CPP_NUL_TERMINATE_Q
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
return|return
name|CPP_STRING
return|;
block|}
else|else
block|{
name|FORWARD
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|chill_number_eof
label|:
name|CPP_NUL_TERMINATE
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
return|return
name|CPP_NUMBER
return|;
block|}
block|}
else|else
goto|goto
name|letter
goto|;
case|case
literal|'_'
case|:
case|case
literal|'a'
case|:
case|case
literal|'e'
case|:
case|case
literal|'f'
case|:
case|case
literal|'g'
case|:
case|case
literal|'i'
case|:
case|case
literal|'j'
case|:
case|case
literal|'k'
case|:
case|case
literal|'l'
case|:
case|case
literal|'m'
case|:
case|case
literal|'n'
case|:
case|case
literal|'p'
case|:
case|case
literal|'q'
case|:
case|case
literal|'r'
case|:
case|case
literal|'s'
case|:
case|case
literal|'t'
case|:
case|case
literal|'u'
case|:
case|case
literal|'v'
case|:
case|case
literal|'w'
case|:
case|case
literal|'x'
case|:
case|case
literal|'y'
case|:
case|case
literal|'z'
case|:
case|case
literal|'A'
case|:
case|case
literal|'E'
case|:
case|case
literal|'F'
case|:
case|case
literal|'G'
case|:
case|case
literal|'I'
case|:
case|case
literal|'J'
case|:
case|case
literal|'K'
case|:
case|case
literal|'M'
case|:
case|case
literal|'N'
case|:
case|case
literal|'P'
case|:
case|case
literal|'Q'
case|:
case|case
literal|'R'
case|:
case|case
literal|'S'
case|:
case|case
literal|'T'
case|:
case|case
literal|'U'
case|:
case|case
literal|'V'
case|:
case|case
literal|'W'
case|:
case|case
literal|'X'
case|:
case|case
literal|'Y'
case|:
case|case
literal|'Z'
case|:
name|letter
label|:
block|{
name|HASHNODE
modifier|*
name|hp
decl_stmt|;
name|unsigned
name|char
modifier|*
name|ident
decl_stmt|;
name|int
name|before_name_written
init|=
name|CPP_WRITTEN
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
name|int
name|ident_len
decl_stmt|;
name|parse_name
argument_list|(
name|pfile
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|only_seen_white
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pfile
operator|->
name|no_macro_expand
condition|)
return|return
name|CPP_NAME
return|;
name|ident
operator|=
name|pfile
operator|->
name|token_buffer
operator|+
name|before_name_written
expr_stmt|;
name|ident_len
operator|=
name|CPP_PWRITTEN
argument_list|(
name|pfile
argument_list|)
operator|-
name|ident
expr_stmt|;
name|hp
operator|=
name|cpp_lookup
argument_list|(
name|pfile
argument_list|,
name|ident
argument_list|,
name|ident_len
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hp
condition|)
return|return
name|CPP_NAME
return|;
if|if
condition|(
name|hp
operator|->
name|type
operator|==
name|T_DISABLED
condition|)
block|{
if|if
condition|(
name|pfile
operator|->
name|output_escapes
condition|)
block|{
comment|/* Return "@-IDENT", followed by '\0'.  */
name|int
name|i
decl_stmt|;
name|CPP_RESERVE
argument_list|(
name|pfile
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|ident
operator|=
name|pfile
operator|->
name|token_buffer
operator|+
name|before_name_written
expr_stmt|;
name|CPP_ADJUST_WRITTEN
argument_list|(
name|pfile
argument_list|,
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|ident_len
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|ident
index|[
name|i
operator|+
literal|2
index|]
operator|=
name|ident
index|[
name|i
index|]
expr_stmt|;
name|ident
index|[
literal|0
index|]
operator|=
literal|'@'
expr_stmt|;
name|ident
index|[
literal|1
index|]
operator|=
literal|'-'
expr_stmt|;
block|}
return|return
name|CPP_NAME
return|;
block|}
comment|/* If macro wants an arglist, verify that a '(' follows. 	       first skip all whitespace, copying it to the output 	       after the macro name.  Then, if there is no '(', 	       decide this is not a macro call and leave things that way.  */
if|if
condition|(
name|hp
operator|->
name|type
operator|==
name|T_MACRO
operator|&&
name|hp
operator|->
name|value
operator|.
name|defn
operator|->
name|nargs
operator|>=
literal|0
condition|)
block|{
name|struct
name|parse_marker
name|macro_mark
decl_stmt|;
name|int
name|is_macro_call
decl_stmt|;
while|while
condition|(
name|CPP_IS_MACRO_BUFFER
argument_list|(
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
argument_list|)
condition|)
block|{
name|cpp_buffer
modifier|*
name|next_buf
decl_stmt|;
name|cpp_skip_hspace
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|PEEKC
argument_list|()
operator|!=
name|EOF
condition|)
break|break;
name|next_buf
operator|=
name|CPP_PREV_BUFFER
argument_list|(
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|->
name|cleanup
operator|)
operator|(
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|,
name|pfile
operator|)
expr_stmt|;
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|=
name|next_buf
expr_stmt|;
block|}
name|parse_set_mark
argument_list|(
operator|&
name|macro_mark
argument_list|,
name|pfile
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|cpp_skip_hspace
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|c
operator|=
name|PEEKC
argument_list|()
expr_stmt|;
name|is_macro_call
operator|=
name|c
operator|==
literal|'('
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'\n'
condition|)
break|break;
name|FORWARD
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|is_macro_call
condition|)
name|parse_goto_mark
argument_list|(
operator|&
name|macro_mark
argument_list|,
name|pfile
argument_list|)
expr_stmt|;
name|parse_clear_mark
argument_list|(
operator|&
name|macro_mark
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_macro_call
condition|)
return|return
name|CPP_NAME
return|;
block|}
comment|/* This is now known to be a macro call.  */
comment|/* it might not actually be a macro.  */
if|if
condition|(
name|hp
operator|->
name|type
operator|!=
name|T_MACRO
condition|)
block|{
name|int
name|xbuf_len
decl_stmt|;
name|U_CHAR
modifier|*
name|xbuf
decl_stmt|;
name|CPP_SET_WRITTEN
argument_list|(
name|pfile
argument_list|,
name|before_name_written
argument_list|)
expr_stmt|;
name|special_symbol
argument_list|(
name|hp
argument_list|,
name|pfile
argument_list|)
expr_stmt|;
name|xbuf_len
operator|=
name|CPP_WRITTEN
argument_list|(
name|pfile
argument_list|)
operator|-
name|before_name_written
expr_stmt|;
name|xbuf
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xmalloc
argument_list|(
name|xbuf_len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|CPP_SET_WRITTEN
argument_list|(
name|pfile
argument_list|,
name|before_name_written
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|CPP_PWRITTEN
argument_list|(
name|pfile
argument_list|)
argument_list|,
name|xbuf
argument_list|,
name|xbuf_len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|push_macro_expansion
argument_list|(
name|pfile
argument_list|,
name|xbuf
argument_list|,
name|xbuf_len
argument_list|,
name|hp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Expand the macro, reading arguments as needed, 		   and push the expansion on the input stack.  */
name|macroexpand
argument_list|(
name|pfile
argument_list|,
name|hp
argument_list|)
expr_stmt|;
name|CPP_SET_WRITTEN
argument_list|(
name|pfile
argument_list|,
name|before_name_written
argument_list|)
expr_stmt|;
block|}
comment|/* An extra "@ " is added to the end of a macro expansion 	       to prevent accidental token pasting.  We prefer to avoid 	       unneeded extra spaces (for the sake of cpp-using tools like 	       imake).  Here we remove the space if it is safe to do so.  */
if|if
condition|(
name|pfile
operator|->
name|buffer
operator|->
name|rlimit
operator|-
name|pfile
operator|->
name|buffer
operator|->
name|cur
operator|>=
literal|3
operator|&&
name|pfile
operator|->
name|buffer
operator|->
name|rlimit
index|[
operator|-
literal|2
index|]
operator|==
literal|'@'
operator|&&
name|pfile
operator|->
name|buffer
operator|->
name|rlimit
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
block|{
name|int
name|c1
init|=
name|pfile
operator|->
name|buffer
operator|->
name|rlimit
index|[
operator|-
literal|3
index|]
decl_stmt|;
name|int
name|c2
init|=
name|CPP_BUF_PEEK
argument_list|(
name|CPP_PREV_BUFFER
argument_list|(
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|c2
operator|==
name|EOF
operator|||
operator|!
name|unsafe_chars
argument_list|(
name|c1
argument_list|,
name|c2
argument_list|)
condition|)
name|pfile
operator|->
name|buffer
operator|->
name|rlimit
operator|-=
literal|2
expr_stmt|;
block|}
block|}
goto|goto
name|get_next
goto|;
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\v'
case|:
case|case
literal|'\r'
case|:
for|for
control|(
init|;
condition|;
control|)
block|{
name|CPP_PUTC
argument_list|(
name|pfile
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
name|PEEKC
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
operator|||
operator|!
name|is_hor_space
index|[
name|c
index|]
condition|)
break|break;
name|FORWARD
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|CPP_HSPACE
return|;
case|case
literal|'\\'
case|:
name|c2
operator|=
name|PEEKC
argument_list|()
expr_stmt|;
if|if
condition|(
name|c2
operator|!=
literal|'\n'
condition|)
goto|goto
name|randomchar
goto|;
name|token
operator|=
name|CPP_HSPACE
expr_stmt|;
goto|goto
name|op2any
goto|;
case|case
literal|'\n'
case|:
name|CPP_PUTC
argument_list|(
name|pfile
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfile
operator|->
name|only_seen_white
operator|==
literal|0
condition|)
name|pfile
operator|->
name|only_seen_white
operator|=
literal|1
expr_stmt|;
name|pfile
operator|->
name|lineno
operator|++
expr_stmt|;
name|output_line_command
argument_list|(
name|pfile
argument_list|,
literal|1
argument_list|,
name|same_file
argument_list|)
expr_stmt|;
return|return
name|CPP_VSPACE
return|;
case|case
literal|'('
case|:
name|token
operator|=
name|CPP_LPAREN
expr_stmt|;
goto|goto
name|char1
goto|;
case|case
literal|')'
case|:
name|token
operator|=
name|CPP_RPAREN
expr_stmt|;
goto|goto
name|char1
goto|;
case|case
literal|'{'
case|:
name|token
operator|=
name|CPP_LBRACE
expr_stmt|;
goto|goto
name|char1
goto|;
case|case
literal|'}'
case|:
name|token
operator|=
name|CPP_RBRACE
expr_stmt|;
goto|goto
name|char1
goto|;
case|case
literal|','
case|:
name|token
operator|=
name|CPP_COMMA
expr_stmt|;
goto|goto
name|char1
goto|;
case|case
literal|';'
case|:
name|token
operator|=
name|CPP_SEMICOLON
expr_stmt|;
goto|goto
name|char1
goto|;
name|randomchar
label|:
default|default:
name|token
operator|=
name|CPP_OTHER
expr_stmt|;
name|char1
label|:
name|pfile
operator|->
name|only_seen_white
operator|=
literal|0
expr_stmt|;
name|CPP_PUTC
argument_list|(
name|pfile
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
name|token
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Like cpp_get_token, but skip spaces and comments.  */
end_comment

begin_function
name|enum
name|cpp_token
name|cpp_get_non_space_token
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|int
name|old_written
init|=
name|CPP_WRITTEN
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|enum
name|cpp_token
name|token
init|=
name|cpp_get_token
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
if|if
condition|(
name|token
operator|!=
name|CPP_COMMENT
operator|&&
name|token
operator|!=
name|CPP_POP
operator|&&
name|token
operator|!=
name|CPP_HSPACE
operator|&&
name|token
operator|!=
name|CPP_VSPACE
condition|)
return|return
name|token
return|;
name|CPP_SET_WRITTEN
argument_list|(
name|pfile
argument_list|,
name|old_written
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Parse an identifier starting with C.  */
end_comment

begin_function
specifier|static
name|int
name|parse_name
parameter_list|(
name|pfile
parameter_list|,
name|c
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|int
name|c
decl_stmt|;
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|is_idchar
index|[
name|c
index|]
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
operator|&&
name|PEEKC
argument_list|()
operator|==
literal|'\n'
condition|)
block|{
name|FORWARD
argument_list|(
literal|2
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|FORWARD
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|c
operator|==
literal|'$'
operator|&&
name|CPP_PEDANTIC
argument_list|(
name|pfile
argument_list|)
condition|)
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"`$' in identifier"
argument_list|)
expr_stmt|;
name|CPP_RESERVE
argument_list|(
name|pfile
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* One more for final NUL.  */
name|CPP_PUTC_Q
argument_list|(
name|pfile
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
name|GETC
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
block|}
name|CPP_NUL_TERMINATE_Q
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Maintain and search list of included files, for #import.  */
end_comment

begin_comment
comment|/* Hash a file name for import_hash_table.  */
end_comment

begin_function
specifier|static
name|int
name|import_hash
parameter_list|(
name|f
parameter_list|)
name|char
modifier|*
name|f
decl_stmt|;
block|{
name|int
name|val
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|f
condition|)
name|val
operator|+=
operator|*
name|f
operator|++
expr_stmt|;
return|return
operator|(
name|val
operator|%
name|IMPORT_HASH_SIZE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Search for file FILENAME in import_hash_table.    Return -2 if found, either a matching name or a matching inode.    Otherwise, open the file and return a file descriptor if successful    or -1 if unsuccessful.  */
end_comment

begin_function
specifier|static
name|int
name|lookup_import
parameter_list|(
name|pfile
parameter_list|,
name|filename
parameter_list|,
name|searchptr
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|struct
name|file_name_list
modifier|*
name|searchptr
decl_stmt|;
block|{
name|struct
name|import_file
modifier|*
name|i
decl_stmt|;
name|int
name|h
decl_stmt|;
name|int
name|hashval
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|hashval
operator|=
name|import_hash
argument_list|(
name|filename
argument_list|)
expr_stmt|;
comment|/* Attempt to find file in list of already included files */
name|i
operator|=
name|pfile
operator|->
name|import_hash_table
index|[
name|hashval
index|]
expr_stmt|;
while|while
condition|(
name|i
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|filename
argument_list|,
name|i
operator|->
name|name
argument_list|)
condition|)
return|return
operator|-
literal|2
return|;
comment|/* return found */
name|i
operator|=
name|i
operator|->
name|next
expr_stmt|;
block|}
comment|/* Open it and try a match on inode/dev */
name|fd
operator|=
name|open_include_file
argument_list|(
name|pfile
argument_list|,
name|filename
argument_list|,
name|searchptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
return|return
name|fd
return|;
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|sb
argument_list|)
expr_stmt|;
for|for
control|(
name|h
operator|=
literal|0
init|;
name|h
operator|<
name|IMPORT_HASH_SIZE
condition|;
name|h
operator|++
control|)
block|{
name|i
operator|=
name|pfile
operator|->
name|import_hash_table
index|[
name|h
index|]
expr_stmt|;
while|while
condition|(
name|i
condition|)
block|{
comment|/* Compare the inode and the device. 	 Supposedly on some systems the inode is not a scalar.  */
if|if
condition|(
operator|!
name|bcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|i
operator|->
name|inode
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sb
operator|.
name|st_ino
argument_list|,
sizeof|sizeof
argument_list|(
name|sb
operator|.
name|st_ino
argument_list|)
argument_list|)
operator|&&
name|i
operator|->
name|dev
operator|==
name|sb
operator|.
name|st_dev
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|-
literal|2
return|;
comment|/* return found */
block|}
name|i
operator|=
name|i
operator|->
name|next
expr_stmt|;
block|}
block|}
return|return
name|fd
return|;
comment|/* Not found, return open file */
block|}
end_function

begin_comment
comment|/* Add the file FNAME, open on descriptor FD, to import_hash_table.  */
end_comment

begin_function
specifier|static
name|void
name|add_import
parameter_list|(
name|pfile
parameter_list|,
name|fd
parameter_list|,
name|fname
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
block|{
name|struct
name|import_file
modifier|*
name|i
decl_stmt|;
name|int
name|hashval
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|hashval
operator|=
name|import_hash
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|sb
argument_list|)
expr_stmt|;
name|i
operator|=
operator|(
expr|struct
name|import_file
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|import_file
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|->
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|fname
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|i
operator|->
name|name
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|sb
operator|.
name|st_ino
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|i
operator|->
name|inode
argument_list|,
sizeof|sizeof
argument_list|(
name|sb
operator|.
name|st_ino
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|->
name|dev
operator|=
name|sb
operator|.
name|st_dev
expr_stmt|;
name|i
operator|->
name|next
operator|=
name|pfile
operator|->
name|import_hash_table
index|[
name|hashval
index|]
expr_stmt|;
name|pfile
operator|->
name|import_hash_table
index|[
name|hashval
index|]
operator|=
name|i
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The file_name_map structure holds a mapping of file names for a    particular directory.  This mapping is read from the file named    FILE_NAME_MAP_FILE in that directory.  Such a file can be used to    map filenames on a file system with severe filename restrictions,    such as DOS.  The format of the file name map file is just a series    of lines with two tokens on each line.  The first token is the name    to map, and the second token is the actual name to use.  */
end_comment

begin_struct
struct|struct
name|file_name_map
block|{
name|struct
name|file_name_map
modifier|*
name|map_next
decl_stmt|;
name|char
modifier|*
name|map_from
decl_stmt|;
name|char
modifier|*
name|map_to
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|FILE_NAME_MAP_FILE
value|"header.gcc"
end_define

begin_comment
comment|/* Read a space delimited string of unlimited length from a stdio    file.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|read_filename_string
parameter_list|(
name|ch
parameter_list|,
name|f
parameter_list|)
name|int
name|ch
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
block|{
name|char
modifier|*
name|alloc
decl_stmt|,
modifier|*
name|set
decl_stmt|;
name|int
name|len
decl_stmt|;
name|len
operator|=
literal|20
expr_stmt|;
name|set
operator|=
name|alloc
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_space
index|[
name|ch
index|]
condition|)
block|{
operator|*
name|set
operator|++
operator|=
name|ch
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getc
argument_list|(
name|f
argument_list|)
operator|)
operator|!=
name|EOF
operator|&&
operator|!
name|is_space
index|[
name|ch
index|]
condition|)
block|{
if|if
condition|(
name|set
operator|-
name|alloc
operator|==
name|len
condition|)
block|{
name|len
operator|*=
literal|2
expr_stmt|;
name|alloc
operator|=
name|xrealloc
argument_list|(
name|alloc
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|set
operator|=
name|alloc
operator|+
name|len
operator|/
literal|2
expr_stmt|;
block|}
operator|*
name|set
operator|++
operator|=
name|ch
expr_stmt|;
block|}
block|}
operator|*
name|set
operator|=
literal|'\0'
expr_stmt|;
name|ungetc
argument_list|(
name|ch
argument_list|,
name|f
argument_list|)
expr_stmt|;
return|return
name|alloc
return|;
block|}
end_function

begin_comment
comment|/* This structure holds a linked list of file name maps, one per directory.  */
end_comment

begin_struct
struct|struct
name|file_name_map_list
block|{
name|struct
name|file_name_map_list
modifier|*
name|map_list_next
decl_stmt|;
name|char
modifier|*
name|map_list_name
decl_stmt|;
name|struct
name|file_name_map
modifier|*
name|map_list_map
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Read the file name map file for DIRNAME.  */
end_comment

begin_function
specifier|static
name|struct
name|file_name_map
modifier|*
name|read_name_map
parameter_list|(
name|pfile
parameter_list|,
name|dirname
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|char
modifier|*
name|dirname
decl_stmt|;
block|{
specifier|register
name|struct
name|file_name_map_list
modifier|*
name|map_list_ptr
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
for|for
control|(
name|map_list_ptr
operator|=
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|map_list
init|;
name|map_list_ptr
condition|;
name|map_list_ptr
operator|=
name|map_list_ptr
operator|->
name|map_list_next
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|map_list_ptr
operator|->
name|map_list_name
argument_list|,
name|dirname
argument_list|)
condition|)
return|return
name|map_list_ptr
operator|->
name|map_list_map
return|;
name|map_list_ptr
operator|=
operator|(
operator|(
expr|struct
name|file_name_map_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|file_name_map_list
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|map_list_ptr
operator|->
name|map_list_name
operator|=
name|savestring
argument_list|(
name|dirname
argument_list|)
expr_stmt|;
name|map_list_ptr
operator|->
name|map_list_map
operator|=
name|NULL
expr_stmt|;
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|dirname
argument_list|)
operator|+
name|strlen
argument_list|(
name|FILE_NAME_MAP_FILE
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|name
argument_list|,
name|dirname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|dirname
condition|)
name|strcat
argument_list|(
name|name
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|name
argument_list|,
name|FILE_NAME_MAP_FILE
argument_list|)
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|name
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|f
condition|)
name|map_list_ptr
operator|->
name|map_list_map
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|int
name|ch
decl_stmt|;
name|int
name|dirlen
init|=
name|strlen
argument_list|(
name|dirname
argument_list|)
decl_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getc
argument_list|(
name|f
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
name|char
modifier|*
name|from
decl_stmt|,
modifier|*
name|to
decl_stmt|;
name|struct
name|file_name_map
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
name|is_space
index|[
name|ch
index|]
condition|)
continue|continue;
name|from
operator|=
name|read_filename_string
argument_list|(
name|ch
argument_list|,
name|f
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getc
argument_list|(
name|f
argument_list|)
operator|)
operator|!=
name|EOF
operator|&&
name|is_hor_space
index|[
name|ch
index|]
condition|)
empty_stmt|;
name|to
operator|=
name|read_filename_string
argument_list|(
name|ch
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|(
operator|(
expr|struct
name|file_name_map
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|file_name_map
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|ptr
operator|->
name|map_from
operator|=
name|from
expr_stmt|;
comment|/* Make the real filename absolute.  */
if|if
condition|(
operator|*
name|to
operator|==
literal|'/'
condition|)
name|ptr
operator|->
name|map_to
operator|=
name|to
expr_stmt|;
else|else
block|{
name|ptr
operator|->
name|map_to
operator|=
name|xmalloc
argument_list|(
name|dirlen
operator|+
name|strlen
argument_list|(
name|to
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|ptr
operator|->
name|map_to
argument_list|,
name|dirname
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|map_to
index|[
name|dirlen
index|]
operator|=
literal|'/'
expr_stmt|;
name|strcpy
argument_list|(
name|ptr
operator|->
name|map_to
operator|+
name|dirlen
operator|+
literal|1
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|to
argument_list|)
expr_stmt|;
block|}
name|ptr
operator|->
name|map_next
operator|=
name|map_list_ptr
operator|->
name|map_list_map
expr_stmt|;
name|map_list_ptr
operator|->
name|map_list_map
operator|=
name|ptr
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getc
argument_list|(
name|f
argument_list|)
operator|)
operator|!=
literal|'\n'
condition|)
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
break|break;
block|}
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
name|map_list_ptr
operator|->
name|map_list_next
operator|=
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|map_list
expr_stmt|;
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|map_list
operator|=
name|map_list_ptr
expr_stmt|;
return|return
name|map_list_ptr
operator|->
name|map_list_map
return|;
block|}
end_function

begin_comment
comment|/* Try to open include file FILENAME.  SEARCHPTR is the directory    being tried from the include file search path.  This function maps    filenames on file systems based on information read by    read_name_map.  */
end_comment

begin_function
specifier|static
name|int
name|open_include_file
parameter_list|(
name|pfile
parameter_list|,
name|filename
parameter_list|,
name|searchptr
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|struct
name|file_name_list
modifier|*
name|searchptr
decl_stmt|;
block|{
if|if
condition|(
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|remap
condition|)
block|{
specifier|register
name|struct
name|file_name_map
modifier|*
name|map
decl_stmt|;
specifier|register
name|char
modifier|*
name|from
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|dir
decl_stmt|;
if|if
condition|(
name|searchptr
operator|&&
operator|!
name|searchptr
operator|->
name|got_name_map
condition|)
block|{
name|searchptr
operator|->
name|name_map
operator|=
name|read_name_map
argument_list|(
name|pfile
argument_list|,
name|searchptr
operator|->
name|fname
condition|?
name|searchptr
operator|->
name|fname
else|:
literal|"."
argument_list|)
expr_stmt|;
name|searchptr
operator|->
name|got_name_map
operator|=
literal|1
expr_stmt|;
block|}
comment|/* First check the mapping for the directory we are using.  */
if|if
condition|(
name|searchptr
operator|&&
name|searchptr
operator|->
name|name_map
condition|)
block|{
name|from
operator|=
name|filename
expr_stmt|;
if|if
condition|(
name|searchptr
operator|->
name|fname
condition|)
name|from
operator|+=
name|strlen
argument_list|(
name|searchptr
operator|->
name|fname
argument_list|)
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|map
operator|=
name|searchptr
operator|->
name|name_map
init|;
name|map
condition|;
name|map
operator|=
name|map
operator|->
name|map_next
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|map
operator|->
name|map_from
argument_list|,
name|from
argument_list|)
condition|)
block|{
comment|/* Found a match.  */
return|return
name|open
argument_list|(
name|map
operator|->
name|map_to
argument_list|,
name|O_RDONLY
argument_list|,
literal|0666
argument_list|)
return|;
block|}
block|}
block|}
comment|/* Try to find a mapping file for the particular directory we are 	 looking in.  Thus #include<sys/types.h> will look up sys/types.h 	 in /usr/include/header.gcc and look up types.h in 	 /usr/include/sys/header.gcc.  */
name|p
operator|=
name|rindex
argument_list|(
name|filename
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
name|p
operator|=
name|filename
expr_stmt|;
if|if
condition|(
name|searchptr
operator|&&
name|searchptr
operator|->
name|fname
operator|&&
name|strlen
argument_list|(
name|searchptr
operator|->
name|fname
argument_list|)
operator|==
name|p
operator|-
name|filename
operator|&&
operator|!
name|strncmp
argument_list|(
name|searchptr
operator|->
name|fname
argument_list|,
name|filename
argument_list|,
name|p
operator|-
name|filename
argument_list|)
condition|)
block|{
comment|/* FILENAME is in SEARCHPTR, which we've already checked.  */
return|return
name|open
argument_list|(
name|filename
argument_list|,
name|O_RDONLY
argument_list|,
literal|0666
argument_list|)
return|;
block|}
if|if
condition|(
name|p
operator|==
name|filename
condition|)
block|{
name|dir
operator|=
literal|"."
expr_stmt|;
name|from
operator|=
name|filename
expr_stmt|;
block|}
else|else
block|{
name|dir
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|p
operator|-
name|filename
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|filename
argument_list|,
name|dir
argument_list|,
name|p
operator|-
name|filename
argument_list|)
expr_stmt|;
name|dir
index|[
name|p
operator|-
name|filename
index|]
operator|=
literal|'\0'
expr_stmt|;
name|from
operator|=
name|p
operator|+
literal|1
expr_stmt|;
block|}
for|for
control|(
name|map
operator|=
name|read_name_map
argument_list|(
name|pfile
argument_list|,
name|dir
argument_list|)
init|;
name|map
condition|;
name|map
operator|=
name|map
operator|->
name|map_next
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|map
operator|->
name|map_from
argument_list|,
name|from
argument_list|)
condition|)
return|return
name|open
argument_list|(
name|map
operator|->
name|map_to
argument_list|,
name|O_RDONLY
argument_list|,
literal|0666
argument_list|)
return|;
block|}
return|return
name|open
argument_list|(
name|filename
argument_list|,
name|O_RDONLY
argument_list|,
literal|0666
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Process the contents of include file FNAME, already open on descriptor F,    with output to OP.    SYSTEM_HEADER_P is 1 if this file resides in any one of the known    "system" include directories (as decided by the `is_system_include'    function above).    DIRPTR is the link in the dir path through which this file was found,    or 0 if the file name was absolute or via the current directory.    Return 1 on success, 0 on failure.     The caller is responsible for the cpp_push_buffer.  */
end_comment

begin_function
specifier|static
name|int
name|finclude
parameter_list|(
name|pfile
parameter_list|,
name|f
parameter_list|,
name|fname
parameter_list|,
name|system_header_p
parameter_list|,
name|dirptr
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|int
name|f
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
name|int
name|system_header_p
decl_stmt|;
name|struct
name|file_name_list
modifier|*
name|dirptr
decl_stmt|;
block|{
name|struct
name|stat
name|st
decl_stmt|;
name|size_t
name|st_size
decl_stmt|;
name|long
name|i
decl_stmt|;
name|int
name|length
decl_stmt|;
name|cpp_buffer
modifier|*
name|fp
decl_stmt|;
comment|/* For input stack frame */
if|#
directive|if
literal|0
block|int missing_newline = 0;
endif|#
directive|endif
if|if
condition|(
name|fstat
argument_list|(
name|f
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
block|{
name|cpp_perror_with_name
argument_list|(
name|pfile
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|cpp_pop_buffer
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|fp
operator|=
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|fp
operator|->
name|nominal_fname
operator|=
name|fp
operator|->
name|fname
operator|=
name|fname
expr_stmt|;
if|#
directive|if
literal|0
block|fp->length = 0;
endif|#
directive|endif
name|fp
operator|->
name|dir
operator|=
name|dirptr
expr_stmt|;
name|fp
operator|->
name|system_header_p
operator|=
name|system_header_p
expr_stmt|;
name|fp
operator|->
name|lineno
operator|=
literal|1
expr_stmt|;
name|fp
operator|->
name|colno
operator|=
literal|1
expr_stmt|;
name|fp
operator|->
name|cleanup
operator|=
name|file_cleanup
expr_stmt|;
if|if
condition|(
name|S_ISREG
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|st_size
operator|=
operator|(
name|size_t
operator|)
name|st
operator|.
name|st_size
expr_stmt|;
if|if
condition|(
name|st_size
operator|!=
name|st
operator|.
name|st_size
operator|||
name|st_size
operator|+
literal|2
operator|<
name|st_size
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"file `%s' too large"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|fp
operator|->
name|buf
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xmalloc
argument_list|(
name|st_size
operator|+
literal|2
argument_list|)
expr_stmt|;
name|fp
operator|->
name|alimit
operator|=
name|fp
operator|->
name|buf
operator|+
name|st_size
operator|+
literal|2
expr_stmt|;
name|fp
operator|->
name|cur
operator|=
name|fp
operator|->
name|buf
expr_stmt|;
comment|/* Read the file contents, knowing that st_size is an upper bound        on the number of bytes we can read.  */
name|length
operator|=
name|safe_read
argument_list|(
name|f
argument_list|,
name|fp
operator|->
name|buf
argument_list|,
name|st_size
argument_list|)
expr_stmt|;
name|fp
operator|->
name|rlimit
operator|=
name|fp
operator|->
name|buf
operator|+
name|length
expr_stmt|;
if|if
condition|(
name|length
operator|<
literal|0
condition|)
goto|goto
name|nope
goto|;
block|}
elseif|else
if|if
condition|(
name|S_ISDIR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"directory `%s' specified in #include"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
comment|/* Cannot count its file size before reading.        First read the entire file into heap and        copy them into buffer on stack.  */
name|int
name|bsize
init|=
literal|2000
decl_stmt|;
name|st_size
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|buf
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xmalloc
argument_list|(
name|bsize
operator|+
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|i
operator|=
name|safe_read
argument_list|(
name|f
argument_list|,
name|fp
operator|->
name|buf
operator|+
name|st_size
argument_list|,
name|bsize
operator|-
name|st_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
goto|goto
name|nope
goto|;
comment|/* error! */
name|st_size
operator|+=
name|i
expr_stmt|;
if|if
condition|(
name|st_size
operator|!=
name|bsize
condition|)
break|break;
comment|/* End of file */
name|bsize
operator|*=
literal|2
expr_stmt|;
name|fp
operator|->
name|buf
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xrealloc
argument_list|(
name|fp
operator|->
name|buf
argument_list|,
name|bsize
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
name|fp
operator|->
name|cur
operator|=
name|fp
operator|->
name|buf
expr_stmt|;
name|length
operator|=
name|st_size
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|length
operator|>
literal|0
operator|&&
name|fp
operator|->
name|buf
index|[
name|length
operator|-
literal|1
index|]
operator|!=
literal|'\n'
operator|)
comment|/* Backslash-newline at end is not good enough.  */
operator|||
operator|(
name|length
operator|>
literal|1
operator|&&
name|fp
operator|->
name|buf
index|[
name|length
operator|-
literal|2
index|]
operator|==
literal|'\\'
operator|)
condition|)
block|{
name|fp
operator|->
name|buf
index|[
name|length
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
if|#
directive|if
literal|0
block|missing_newline = 1;
endif|#
directive|endif
block|}
name|fp
operator|->
name|buf
index|[
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
name|fp
operator|->
name|rlimit
operator|=
name|fp
operator|->
name|buf
operator|+
name|length
expr_stmt|;
comment|/* Close descriptor now, so nesting does not use lots of descriptors.  */
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
comment|/* Must do this before calling trigraph_pcp, so that the correct file name      will be printed in warning messages.  */
name|pfile
operator|->
name|input_stack_listing_current
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|0
block|if (!no_trigraphs)     trigraph_pcp (fp);
endif|#
directive|endif
if|#
directive|if
literal|0
block|rescan (op, 0);    if (missing_newline)     fp->lineno--;    if (CPP_PEDANTIC (pfile)&& missing_newline)     pedwarn ("file does not end in newline");    indepth--;   input_file_stack_tick++;   free (fp->buf);
endif|#
directive|endif
return|return
literal|1
return|;
name|nope
label|:
name|cpp_perror_with_name
argument_list|(
name|pfile
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fp
operator|->
name|buf
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* This is called after options have been processed.  * Check options for consistency, and setup for processing input  * from the file named FNAME.  (Use standard input if FNAME==NULL.)  * Return 1 on success, 0 on failure.  */
end_comment

begin_function
name|int
name|cpp_start_read
parameter_list|(
name|pfile
parameter_list|,
name|fname
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
block|{
name|struct
name|cpp_options
modifier|*
name|opts
init|=
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
name|struct
name|cpp_pending
modifier|*
name|pend
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|f
decl_stmt|;
name|cpp_buffer
modifier|*
name|fp
decl_stmt|;
comment|/* The code looks at the defaults through this pointer, rather than through      the constant structure above.  This pointer gets changed if an environment      variable specifies other defaults.  */
name|struct
name|default_include
modifier|*
name|include_defaults
init|=
name|include_defaults_array
decl_stmt|;
comment|/* Add dirs from CPATH after dirs from -I.  */
comment|/* There seems to be confusion about what CPATH should do,      so for the moment it is not documented.  */
comment|/* Some people say that CPATH should replace the standard include dirs,      but that seems pointless: it comes before them, so it overrides them      anyway.  */
name|GET_ENVIRONMENT
argument_list|(
name|p
argument_list|,
literal|"CPATH"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
literal|0
operator|&&
operator|!
name|opts
operator|->
name|no_standard_includes
condition|)
name|path_include
argument_list|(
name|pfile
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* Now that dollars_in_ident is known, initialize is_idchar.  */
name|initialize_char_syntax
argument_list|(
name|opts
argument_list|)
expr_stmt|;
comment|/* Do partial setup of input buffer for the sake of generating      early #line directives (when -g is in effect).  */
name|fp
operator|=
name|cpp_push_buffer
argument_list|(
name|pfile
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fp
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|opts
operator|->
name|in_fname
operator|==
name|NULL
condition|)
name|opts
operator|->
name|in_fname
operator|=
literal|""
expr_stmt|;
name|fp
operator|->
name|nominal_fname
operator|=
name|fp
operator|->
name|fname
operator|=
name|opts
operator|->
name|in_fname
expr_stmt|;
name|fp
operator|->
name|lineno
operator|=
literal|0
expr_stmt|;
comment|/* Install __LINE__, etc.  Must follow initialize_char_syntax      and option processing.  */
name|initialize_builtins
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
comment|/* Do standard #defines and assertions      that identify system and machine type.  */
if|if
condition|(
operator|!
name|opts
operator|->
name|inhibit_predefs
condition|)
block|{
name|char
modifier|*
name|p
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|predefs
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|predefs
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
name|char
modifier|*
name|q
decl_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
comment|/* Handle -D options.  */
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'D'
condition|)
block|{
name|q
operator|=
operator|&
name|p
index|[
literal|2
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|' '
operator|&&
operator|*
name|p
operator|!=
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|0
condition|)
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|opts
operator|->
name|debug_output
condition|)
name|output_line_command
argument_list|(
name|pfile
argument_list|,
literal|0
argument_list|,
name|same_file
argument_list|)
expr_stmt|;
name|cpp_define
argument_list|(
name|pfile
argument_list|,
name|q
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'A'
condition|)
block|{
comment|/* Handle -A options (assertions).  */
name|char
modifier|*
name|assertion
decl_stmt|;
name|char
modifier|*
name|past_name
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
name|char
modifier|*
name|past_value
decl_stmt|;
name|char
modifier|*
name|termination
decl_stmt|;
name|int
name|save_char
decl_stmt|;
name|assertion
operator|=
operator|&
name|p
index|[
literal|2
index|]
expr_stmt|;
name|past_name
operator|=
name|assertion
expr_stmt|;
comment|/* Locate end of name.  */
while|while
condition|(
operator|*
name|past_name
operator|&&
operator|*
name|past_name
operator|!=
literal|' '
operator|&&
operator|*
name|past_name
operator|!=
literal|'\t'
operator|&&
operator|*
name|past_name
operator|!=
literal|'('
condition|)
name|past_name
operator|++
expr_stmt|;
comment|/* Locate `(' at start of value.  */
name|value
operator|=
name|past_name
expr_stmt|;
while|while
condition|(
operator|*
name|value
operator|&&
operator|(
operator|*
name|value
operator|==
literal|' '
operator|||
operator|*
name|value
operator|==
literal|'\t'
operator|)
condition|)
name|value
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|value
operator|++
operator|!=
literal|'('
condition|)
name|abort
argument_list|()
expr_stmt|;
while|while
condition|(
operator|*
name|value
operator|&&
operator|(
operator|*
name|value
operator|==
literal|' '
operator|||
operator|*
name|value
operator|==
literal|'\t'
operator|)
condition|)
name|value
operator|++
expr_stmt|;
name|past_value
operator|=
name|value
expr_stmt|;
comment|/* Locate end of value.  */
while|while
condition|(
operator|*
name|past_value
operator|&&
operator|*
name|past_value
operator|!=
literal|' '
operator|&&
operator|*
name|past_value
operator|!=
literal|'\t'
operator|&&
operator|*
name|past_value
operator|!=
literal|')'
condition|)
name|past_value
operator|++
expr_stmt|;
name|termination
operator|=
name|past_value
expr_stmt|;
while|while
condition|(
operator|*
name|termination
operator|&&
operator|(
operator|*
name|termination
operator|==
literal|' '
operator|||
operator|*
name|termination
operator|==
literal|'\t'
operator|)
condition|)
name|termination
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|termination
operator|++
operator|!=
literal|')'
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|termination
operator|&&
operator|*
name|termination
operator|!=
literal|' '
operator|&&
operator|*
name|termination
operator|!=
literal|'\t'
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Temporarily null-terminate the value.  */
name|save_char
operator|=
operator|*
name|termination
expr_stmt|;
operator|*
name|termination
operator|=
literal|'\0'
expr_stmt|;
comment|/* Install the assertion.  */
name|make_assertion
argument_list|(
name|pfile
argument_list|,
literal|"-A"
argument_list|,
name|assertion
argument_list|)
expr_stmt|;
operator|*
name|termination
operator|=
operator|(
name|char
operator|)
name|save_char
expr_stmt|;
name|p
operator|=
name|termination
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
block|}
else|else
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/* Now handle the command line options.  */
comment|/* Do -U's, -D's and -A's in the order they were seen.  */
comment|/* First reverse the list.  */
name|opts
operator|->
name|pending
operator|=
name|nreverse_pending
argument_list|(
name|opts
operator|->
name|pending
argument_list|)
expr_stmt|;
for|for
control|(
name|pend
operator|=
name|opts
operator|->
name|pending
init|;
name|pend
condition|;
name|pend
operator|=
name|pend
operator|->
name|next
control|)
block|{
if|if
condition|(
name|pend
operator|->
name|cmd
operator|!=
name|NULL
operator|&&
name|pend
operator|->
name|cmd
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
switch|switch
condition|(
name|pend
operator|->
name|cmd
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'U'
case|:
if|if
condition|(
name|opts
operator|->
name|debug_output
condition|)
name|output_line_command
argument_list|(
name|pfile
argument_list|,
literal|0
argument_list|,
name|same_file
argument_list|)
expr_stmt|;
name|do_undef
argument_list|(
name|pfile
argument_list|,
name|NULL
argument_list|,
name|pend
operator|->
name|arg
argument_list|,
name|pend
operator|->
name|arg
operator|+
name|strlen
argument_list|(
name|pend
operator|->
name|arg
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
if|if
condition|(
name|opts
operator|->
name|debug_output
condition|)
name|output_line_command
argument_list|(
name|pfile
argument_list|,
literal|0
argument_list|,
name|same_file
argument_list|)
expr_stmt|;
name|cpp_define
argument_list|(
name|pfile
argument_list|,
name|pend
operator|->
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
name|make_assertion
argument_list|(
name|pfile
argument_list|,
literal|"-A"
argument_list|,
name|pend
operator|->
name|arg
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|opts
operator|->
name|done_initializing
operator|=
literal|1
expr_stmt|;
block|{
comment|/* Read the appropriate environment variable and if it exists        replace include_defaults with the listed path.  */
name|char
modifier|*
name|epath
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
operator|(
name|opts
operator|->
name|objc
operator|<<
literal|1
operator|)
operator|+
name|opts
operator|->
name|cplusplus
condition|)
block|{
case|case
literal|0
case|:
name|GET_ENVIRONMENT
argument_list|(
name|epath
argument_list|,
literal|"C_INCLUDE_PATH"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|GET_ENVIRONMENT
argument_list|(
name|epath
argument_list|,
literal|"CPLUS_INCLUDE_PATH"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|GET_ENVIRONMENT
argument_list|(
name|epath
argument_list|,
literal|"OBJC_INCLUDE_PATH"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|GET_ENVIRONMENT
argument_list|(
name|epath
argument_list|,
literal|"OBJCPLUS_INCLUDE_PATH"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* If the environment var for this language is set,        add to the default list of include directories.  */
if|if
condition|(
name|epath
condition|)
block|{
name|char
modifier|*
name|nstore
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|epath
argument_list|)
operator|+
literal|2
argument_list|)
decl_stmt|;
name|int
name|num_dirs
decl_stmt|;
name|char
modifier|*
name|startp
decl_stmt|,
modifier|*
name|endp
decl_stmt|;
for|for
control|(
name|num_dirs
operator|=
literal|1
operator|,
name|startp
operator|=
name|epath
init|;
operator|*
name|startp
condition|;
name|startp
operator|++
control|)
if|if
condition|(
operator|*
name|startp
operator|==
name|PATH_SEPARATOR
condition|)
name|num_dirs
operator|++
expr_stmt|;
name|include_defaults
operator|=
operator|(
expr|struct
name|default_include
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|num_dirs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|default_include
argument_list|)
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|include_defaults_array
argument_list|)
argument_list|)
expr_stmt|;
name|startp
operator|=
name|endp
operator|=
name|epath
expr_stmt|;
name|num_dirs
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Handle cases like c:/usr/lib:d:/gcc/lib */
if|if
condition|(
operator|(
operator|*
name|endp
operator|==
name|PATH_SEPARATOR
operator|)
operator|||
operator|*
name|endp
operator|==
literal|0
condition|)
block|{
name|strncpy
argument_list|(
name|nstore
argument_list|,
name|startp
argument_list|,
name|endp
operator|-
name|startp
argument_list|)
expr_stmt|;
if|if
condition|(
name|endp
operator|==
name|startp
condition|)
name|strcpy
argument_list|(
name|nstore
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
else|else
name|nstore
index|[
name|endp
operator|-
name|startp
index|]
operator|=
literal|'\0'
expr_stmt|;
name|include_defaults
index|[
name|num_dirs
index|]
operator|.
name|fname
operator|=
name|savestring
argument_list|(
name|nstore
argument_list|)
expr_stmt|;
name|include_defaults
index|[
name|num_dirs
index|]
operator|.
name|component
operator|=
literal|0
expr_stmt|;
name|include_defaults
index|[
name|num_dirs
index|]
operator|.
name|cplusplus
operator|=
name|opts
operator|->
name|cplusplus
expr_stmt|;
name|include_defaults
index|[
name|num_dirs
index|]
operator|.
name|cxx_aware
operator|=
literal|1
expr_stmt|;
name|num_dirs
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|endp
operator|==
literal|'\0'
condition|)
break|break;
name|endp
operator|=
name|startp
operator|=
name|endp
operator|+
literal|1
expr_stmt|;
block|}
else|else
name|endp
operator|++
expr_stmt|;
block|}
comment|/* Put the usual defaults back in at the end.  */
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|include_defaults_array
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|include_defaults
index|[
name|num_dirs
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|include_defaults_array
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|append_include_chain
argument_list|(
name|pfile
argument_list|,
name|opts
operator|->
name|before_system
argument_list|,
name|opts
operator|->
name|last_before_system
argument_list|)
expr_stmt|;
name|opts
operator|->
name|first_system_include
operator|=
name|opts
operator|->
name|before_system
expr_stmt|;
comment|/* Unless -fnostdinc,      tack on the standard include file dirs to the specified list */
if|if
condition|(
operator|!
name|opts
operator|->
name|no_standard_includes
condition|)
block|{
name|struct
name|default_include
modifier|*
name|p
init|=
name|include_defaults
decl_stmt|;
name|char
modifier|*
name|specd_prefix
init|=
name|opts
operator|->
name|include_prefix
decl_stmt|;
name|char
modifier|*
name|default_prefix
init|=
name|savestring
argument_list|(
name|GCC_INCLUDE_DIR
argument_list|)
decl_stmt|;
name|int
name|default_len
init|=
literal|0
decl_stmt|;
comment|/* Remove the `include' from /usr/local/lib/gcc.../include.  */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|default_prefix
operator|+
name|strlen
argument_list|(
name|default_prefix
argument_list|)
operator|-
literal|8
argument_list|,
literal|"/include"
argument_list|)
condition|)
block|{
name|default_len
operator|=
name|strlen
argument_list|(
name|default_prefix
argument_list|)
operator|-
literal|7
expr_stmt|;
name|default_prefix
index|[
name|default_len
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Search "translated" versions of GNU directories.        These have /usr/local/lib/gcc... replaced by specd_prefix.  */
if|if
condition|(
name|specd_prefix
operator|!=
literal|0
operator|&&
name|default_len
operator|!=
literal|0
condition|)
for|for
control|(
name|p
operator|=
name|include_defaults
init|;
name|p
operator|->
name|fname
condition|;
name|p
operator|++
control|)
block|{
comment|/* Some standard dirs are only for C++.  */
if|if
condition|(
operator|!
name|p
operator|->
name|cplusplus
operator|||
operator|(
name|opts
operator|->
name|cplusplus
operator|&&
operator|!
name|opts
operator|->
name|no_standard_cplusplus_includes
operator|)
condition|)
block|{
comment|/* Does this dir start with the prefix?  */
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|p
operator|->
name|fname
argument_list|,
name|default_prefix
argument_list|,
name|default_len
argument_list|)
condition|)
block|{
comment|/* Yes; change prefix and add to search list.  */
name|struct
name|file_name_list
modifier|*
name|new
init|=
operator|(
expr|struct
name|file_name_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|file_name_list
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|this_len
init|=
name|strlen
argument_list|(
name|specd_prefix
argument_list|)
operator|+
name|strlen
argument_list|(
name|p
operator|->
name|fname
argument_list|)
operator|-
name|default_len
decl_stmt|;
name|char
modifier|*
name|str
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|this_len
operator|+
literal|1
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|str
argument_list|,
name|specd_prefix
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|str
argument_list|,
name|p
operator|->
name|fname
operator|+
name|default_len
argument_list|)
expr_stmt|;
name|new
operator|->
name|fname
operator|=
name|str
expr_stmt|;
name|new
operator|->
name|control_macro
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|c_system_include_path
operator|=
operator|!
name|p
operator|->
name|cxx_aware
expr_stmt|;
name|new
operator|->
name|got_name_map
operator|=
literal|0
expr_stmt|;
name|append_include_chain
argument_list|(
name|pfile
argument_list|,
name|new
argument_list|,
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|opts
operator|->
name|first_system_include
operator|==
literal|0
condition|)
name|opts
operator|->
name|first_system_include
operator|=
name|new
expr_stmt|;
block|}
block|}
block|}
comment|/* Search ordinary names for GNU include directories.  */
for|for
control|(
name|p
operator|=
name|include_defaults
init|;
name|p
operator|->
name|fname
condition|;
name|p
operator|++
control|)
block|{
comment|/* Some standard dirs are only for C++.  */
if|if
condition|(
operator|!
name|p
operator|->
name|cplusplus
operator|||
operator|(
name|opts
operator|->
name|cplusplus
operator|&&
operator|!
name|opts
operator|->
name|no_standard_cplusplus_includes
operator|)
condition|)
block|{
name|struct
name|file_name_list
modifier|*
name|new
init|=
operator|(
expr|struct
name|file_name_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|file_name_list
argument_list|)
argument_list|)
decl_stmt|;
name|new
operator|->
name|control_macro
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|c_system_include_path
operator|=
operator|!
name|p
operator|->
name|cxx_aware
expr_stmt|;
name|new
operator|->
name|fname
operator|=
name|update_path
argument_list|(
name|p
operator|->
name|fname
argument_list|,
name|p
operator|->
name|component
argument_list|)
expr_stmt|;
name|new
operator|->
name|got_name_map
operator|=
literal|0
expr_stmt|;
name|append_include_chain
argument_list|(
name|pfile
argument_list|,
name|new
argument_list|,
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|opts
operator|->
name|first_system_include
operator|==
literal|0
condition|)
name|opts
operator|->
name|first_system_include
operator|=
name|new
expr_stmt|;
block|}
block|}
block|}
comment|/* Tack the after_include chain at the end of the include chain.  */
name|append_include_chain
argument_list|(
name|pfile
argument_list|,
name|opts
operator|->
name|after_include
argument_list|,
name|opts
operator|->
name|last_after_include
argument_list|)
expr_stmt|;
if|if
condition|(
name|opts
operator|->
name|first_system_include
operator|==
literal|0
condition|)
name|opts
operator|->
name|first_system_include
operator|=
name|opts
operator|->
name|after_include
expr_stmt|;
comment|/* With -v, print the list of dirs to search.  */
if|if
condition|(
name|opts
operator|->
name|verbose
condition|)
block|{
name|struct
name|file_name_list
modifier|*
name|p
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"#include \"...\" search starts here:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|opts
operator|->
name|include
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|==
name|opts
operator|->
name|first_bracket_include
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"#include<...> search starts here:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %s\n"
argument_list|,
name|p
operator|->
name|fname
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"End of search list.\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Scan the -imacros files before the main input.      Much like #including them, but with no_output set      so that only their macro definitions matter.  */
name|opts
operator|->
name|no_output
operator|++
expr_stmt|;
name|pfile
operator|->
name|no_record_file
operator|++
expr_stmt|;
for|for
control|(
name|pend
operator|=
name|opts
operator|->
name|pending
init|;
name|pend
condition|;
name|pend
operator|=
name|pend
operator|->
name|next
control|)
block|{
if|if
condition|(
name|pend
operator|->
name|cmd
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|pend
operator|->
name|cmd
argument_list|,
literal|"-imacros"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|fd
init|=
name|open
argument_list|(
name|pend
operator|->
name|arg
argument_list|,
name|O_RDONLY
argument_list|,
literal|0666
argument_list|)
decl_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|cpp_perror_with_name
argument_list|(
name|pfile
argument_list|,
name|pend
operator|->
name|arg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|cpp_push_buffer
argument_list|(
name|pfile
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
name|finclude
argument_list|(
name|pfile
argument_list|,
name|fd
argument_list|,
name|pend
operator|->
name|arg
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|cpp_scan_buffer
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
block|}
name|opts
operator|->
name|no_output
operator|--
expr_stmt|;
name|pfile
operator|->
name|no_record_file
operator|--
expr_stmt|;
comment|/* Copy the entire contents of the main input file into      the stacked input buffer previously allocated for it.  */
if|if
condition|(
name|fname
operator|==
name|NULL
operator|||
operator|*
name|fname
operator|==
literal|0
condition|)
block|{
name|fname
operator|=
literal|""
expr_stmt|;
name|f
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|f
operator|=
name|open
argument_list|(
name|fname
argument_list|,
name|O_RDONLY
argument_list|,
literal|0666
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|cpp_pfatal_with_name
argument_list|(
name|pfile
argument_list|,
name|fname
argument_list|)
expr_stmt|;
comment|/* -MG doesn't select the form of output and must be specified with one of      -M or -MM.  -MG doesn't make sense with -MD or -MMD since they don't      inhibit compilation.  */
if|if
condition|(
name|opts
operator|->
name|print_deps_missing_files
operator|&&
operator|(
name|opts
operator|->
name|print_deps
operator|==
literal|0
operator|||
operator|!
name|opts
operator|->
name|no_output
operator|)
condition|)
block|{
name|cpp_fatal
argument_list|(
name|pfile
argument_list|,
literal|"-MG must be specified with one of -M or -MM"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Either of two environment variables can specify output of deps.      Its value is either "OUTPUT_FILE" or "OUTPUT_FILE DEPS_TARGET",      where OUTPUT_FILE is the file to write deps info to      and DEPS_TARGET is the target to mention in the deps.  */
if|if
condition|(
name|opts
operator|->
name|print_deps
operator|==
literal|0
operator|&&
operator|(
name|getenv
argument_list|(
literal|"SUNPRO_DEPENDENCIES"
argument_list|)
operator|!=
literal|0
operator|||
name|getenv
argument_list|(
literal|"DEPENDENCIES_OUTPUT"
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|char
modifier|*
name|spec
init|=
name|getenv
argument_list|(
literal|"DEPENDENCIES_OUTPUT"
argument_list|)
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|output_file
decl_stmt|;
if|if
condition|(
name|spec
operator|==
literal|0
condition|)
block|{
name|spec
operator|=
name|getenv
argument_list|(
literal|"SUNPRO_DEPENDENCIES"
argument_list|)
expr_stmt|;
name|opts
operator|->
name|print_deps
operator|=
literal|2
expr_stmt|;
block|}
else|else
name|opts
operator|->
name|print_deps
operator|=
literal|1
expr_stmt|;
name|s
operator|=
name|spec
expr_stmt|;
comment|/* Find the space before the DEPS_TARGET, if there is one.  */
comment|/* This should use index.  (mrs) */
while|while
condition|(
operator|*
name|s
operator|!=
literal|0
operator|&&
operator|*
name|s
operator|!=
literal|' '
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|0
condition|)
block|{
name|opts
operator|->
name|deps_target
operator|=
name|s
operator|+
literal|1
expr_stmt|;
name|output_file
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|s
operator|-
name|spec
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|spec
argument_list|,
name|output_file
argument_list|,
name|s
operator|-
name|spec
argument_list|)
expr_stmt|;
name|output_file
index|[
name|s
operator|-
name|spec
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|opts
operator|->
name|deps_target
operator|=
literal|0
expr_stmt|;
name|output_file
operator|=
name|spec
expr_stmt|;
block|}
name|opts
operator|->
name|deps_file
operator|=
name|output_file
expr_stmt|;
name|opts
operator|->
name|print_deps_append
operator|=
literal|1
expr_stmt|;
block|}
comment|/* For -M, print the expected object file name      as the target of this Make-rule.  */
if|if
condition|(
name|opts
operator|->
name|print_deps
condition|)
block|{
name|pfile
operator|->
name|deps_allocated_size
operator|=
literal|200
expr_stmt|;
name|pfile
operator|->
name|deps_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|pfile
operator|->
name|deps_allocated_size
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|deps_buffer
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|pfile
operator|->
name|deps_size
operator|=
literal|0
expr_stmt|;
name|pfile
operator|->
name|deps_column
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|opts
operator|->
name|deps_target
condition|)
name|deps_output
argument_list|(
name|pfile
argument_list|,
name|opts
operator|->
name|deps_target
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|opts
operator|->
name|in_fname
operator|==
literal|0
condition|)
name|deps_output
argument_list|(
name|pfile
argument_list|,
literal|"-"
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|,
modifier|*
name|r
decl_stmt|;
name|int
name|len
decl_stmt|,
name|x
decl_stmt|;
specifier|static
name|char
modifier|*
name|known_suffixes
index|[]
init|=
block|{
literal|".c"
block|,
literal|".C"
block|,
literal|".s"
block|,
literal|".S"
block|,
literal|".m"
block|,
literal|".cc"
block|,
literal|".cxx"
block|,
literal|".cpp"
block|,
literal|".cp"
block|,
literal|".c++"
block|,
literal|0
block|}
decl_stmt|;
comment|/* Discard all directory prefixes from filename.  */
if|if
condition|(
operator|(
name|q
operator|=
name|rindex
argument_list|(
name|opts
operator|->
name|in_fname
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
ifdef|#
directive|ifdef
name|DIR_SEPARATOR
operator|&&
operator|(
name|q
operator|=
name|rindex
argument_list|(
name|opts
operator|->
name|in_fname
argument_list|,
name|DIR_SEPARATOR
argument_list|)
operator|)
operator|!=
name|NULL
endif|#
directive|endif
condition|)
operator|++
name|q
expr_stmt|;
else|else
name|q
operator|=
name|opts
operator|->
name|in_fname
expr_stmt|;
comment|/* Copy remainder to mungable area.  */
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|q
argument_list|)
operator|+
literal|8
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|q
argument_list|)
expr_stmt|;
comment|/* Output P, but remove known suffixes.  */
name|len
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|q
operator|=
name|p
operator|+
name|len
expr_stmt|;
comment|/* Point to the filename suffix.  */
name|r
operator|=
name|rindex
argument_list|(
name|p
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
comment|/* Compare against the known suffixes.  */
name|x
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|known_suffixes
index|[
name|x
index|]
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|known_suffixes
index|[
name|x
index|]
argument_list|,
name|r
argument_list|,
name|q
operator|-
name|r
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Make q point to the bit we're going to overwrite 		     with an object suffix.  */
name|q
operator|=
name|r
expr_stmt|;
break|break;
block|}
name|x
operator|++
expr_stmt|;
block|}
comment|/* Supply our own suffix.  */
ifndef|#
directive|ifndef
name|VMS
name|strcpy
argument_list|(
name|q
argument_list|,
literal|".o"
argument_list|)
expr_stmt|;
else|#
directive|else
name|strcpy
argument_list|(
name|q
argument_list|,
literal|".obj"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|deps_output
argument_list|(
name|pfile
argument_list|,
name|p
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
name|deps_output
argument_list|(
name|pfile
argument_list|,
name|opts
operator|->
name|in_fname
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
block|}
block|}
if|#
directive|if
literal|0
comment|/* Make sure data ends with a newline.  And put a null after it.  */
block|if ((fp->length> 0&& fp->buf[fp->length - 1] != '\n')
comment|/* Backslash-newline at end is not good enough.  */
block||| (fp->length> 1&& fp->buf[fp->length - 2] == '\\')) {     fp->buf[fp->length++] = '\n';     missing_newline = 1;   }   fp->buf[fp->length] = '\0';
comment|/* Unless inhibited, convert trigraphs in the input.  */
block|if (!no_trigraphs)     trigraph_pcp (fp);
endif|#
directive|endif
comment|/* Scan the -include files before the main input.    We push these in reverse order, so that the first one is handled first.  */
name|pfile
operator|->
name|no_record_file
operator|++
expr_stmt|;
name|opts
operator|->
name|pending
operator|=
name|nreverse_pending
argument_list|(
name|opts
operator|->
name|pending
argument_list|)
expr_stmt|;
for|for
control|(
name|pend
operator|=
name|opts
operator|->
name|pending
init|;
name|pend
condition|;
name|pend
operator|=
name|pend
operator|->
name|next
control|)
block|{
if|if
condition|(
name|pend
operator|->
name|cmd
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|pend
operator|->
name|cmd
argument_list|,
literal|"-include"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|fd
init|=
name|open
argument_list|(
name|pend
operator|->
name|arg
argument_list|,
name|O_RDONLY
argument_list|,
literal|0666
argument_list|)
decl_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|cpp_perror_with_name
argument_list|(
name|pfile
argument_list|,
name|pend
operator|->
name|arg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|cpp_push_buffer
argument_list|(
name|pfile
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
name|finclude
argument_list|(
name|pfile
argument_list|,
name|fd
argument_list|,
name|pend
operator|->
name|arg
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
block|}
block|}
name|pfile
operator|->
name|no_record_file
operator|--
expr_stmt|;
comment|/* Free the pending list.  */
for|for
control|(
name|pend
operator|=
name|opts
operator|->
name|pending
init|;
name|pend
condition|;
control|)
block|{
name|struct
name|cpp_pending
modifier|*
name|next
init|=
name|pend
operator|->
name|next
decl_stmt|;
name|free
argument_list|(
name|pend
argument_list|)
expr_stmt|;
name|pend
operator|=
name|next
expr_stmt|;
block|}
name|opts
operator|->
name|pending
operator|=
name|NULL
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Scan the input, processing macros and directives.  */
block|rescan (&outbuf, 0);    if (missing_newline)     fp->lineno--;    if (CPP_PEDANTIC (pfile)&& missing_newline)     pedwarn ("file does not end in newline");
endif|#
directive|endif
if|if
condition|(
name|finclude
argument_list|(
name|pfile
argument_list|,
name|f
argument_list|,
name|fname
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|)
condition|)
name|output_line_command
argument_list|(
name|pfile
argument_list|,
literal|0
argument_list|,
name|same_file
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|cpp_reader_init
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pfile
argument_list|,
sizeof|sizeof
argument_list|(
name|cpp_reader
argument_list|)
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|get_token
operator|=
name|cpp_get_token
expr_stmt|;
name|pfile
operator|->
name|token_buffer_size
operator|=
literal|200
expr_stmt|;
name|pfile
operator|->
name|token_buffer
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xmalloc
argument_list|(
name|pfile
operator|->
name|token_buffer_size
argument_list|)
expr_stmt|;
name|CPP_SET_WRITTEN
argument_list|(
name|pfile
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|system_include_depth
operator|=
literal|0
expr_stmt|;
name|pfile
operator|->
name|dont_repeat_files
operator|=
literal|0
expr_stmt|;
name|pfile
operator|->
name|all_include_files
operator|=
literal|0
expr_stmt|;
name|pfile
operator|->
name|max_include_len
operator|=
literal|0
expr_stmt|;
name|pfile
operator|->
name|timebuf
operator|=
name|NULL
expr_stmt|;
name|pfile
operator|->
name|only_seen_white
operator|=
literal|1
expr_stmt|;
name|pfile
operator|->
name|buffer
operator|=
name|CPP_NULL_BUFFER
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|cpp_pending
modifier|*
name|nreverse_pending
parameter_list|(
name|list
parameter_list|)
name|struct
name|cpp_pending
modifier|*
name|list
decl_stmt|;
block|{
specifier|register
name|struct
name|cpp_pending
modifier|*
name|prev
init|=
literal|0
decl_stmt|,
modifier|*
name|next
decl_stmt|,
modifier|*
name|pend
decl_stmt|;
for|for
control|(
name|pend
operator|=
name|list
init|;
name|pend
condition|;
name|pend
operator|=
name|next
control|)
block|{
name|next
operator|=
name|pend
operator|->
name|next
expr_stmt|;
name|pend
operator|->
name|next
operator|=
name|prev
expr_stmt|;
name|prev
operator|=
name|pend
expr_stmt|;
block|}
return|return
name|prev
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|push_pending
parameter_list|(
name|pfile
parameter_list|,
name|cmd
parameter_list|,
name|arg
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|char
modifier|*
name|cmd
decl_stmt|;
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|cpp_pending
modifier|*
name|pend
init|=
operator|(
expr|struct
name|cpp_pending
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|cpp_pending
argument_list|)
argument_list|)
decl_stmt|;
name|pend
operator|->
name|cmd
operator|=
name|cmd
expr_stmt|;
name|pend
operator|->
name|arg
operator|=
name|arg
expr_stmt|;
name|pend
operator|->
name|next
operator|=
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|pending
expr_stmt|;
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|pending
operator|=
name|pend
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|print_help
parameter_list|()
block|{
name|printf
argument_list|(
literal|"Usage: %s [switches] input output\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Switches:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -include<file>           Include the contents of<file> before other files\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -imacros<file>           Accept definition of marcos in<file>\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -iprefix<path>           Specify<path> as a prefix for next two options\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -iwithprefix<dir>        Add<dir> to the end of the system include paths\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -iwithprefixbefore<dir>  Add<dir> to the end of the main include paths\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -isystem<dir>            Add<dir> to the start of the system include paths\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -idirafter<dir>          Add<dir> to the end of the system include paths\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -I<dir>                  Add<dir> to the end of the main include paths\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -nostdinc                 Do not search the system include directories\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -nostdinc++               Do not search the system include directories for C++\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -o<file>                 Put output into<file>\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -pedantic                 Issue all warnings demanded by strict ANSI C\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -traditional              Follow K&R pre-processor behaviour\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -trigraphs                Support ANSI C trigraphs\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -lang-c                   Assume that the input sources are in C\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -lang-c89                 Assume that the input sources are in C89\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -lang-c++                 Assume that the input sources are in C++\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -lang-objc                Assume that the input sources are in ObjectiveC\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -lang-objc++              Assume that the input sources are in ObjectiveC++\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -lang-asm                 Assume that the input sources are in assembler\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -lang-chill               Assume that the input sources are in Chill\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -+                        Allow parsing of C++ style features\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -w                        Inhibit warning messages\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -Wtrigraphs               Warn if trigraphs are encountered\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -Wno-trigraphs            Do not warn about trigraphs\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -Wcomment{s}              Warn if one comment starts inside another\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -Wno-comment{s}           Do not warn about comments\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -Wtraditional             Warn if a macro argument is/would be turned into\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"                             a string if -tradtional is specified\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -Wno-traditional          Do not warn about stringification\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -Wundef                   Warn if an undefined macro is used by #if\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -Wno-undef                Do not warn about testing udefined macros\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -Wimport                  Warn about the use of the #import directive\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -Wno-import               Do not warn about the use of #import\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -Werror                   Treat all warnings as errors\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -Wno-error                Do not treat warnings as errors\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -Wall                     Enable all preprocessor warnings\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -M                        Generate make dependencies\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -MM                       As -M, but ignore system header files\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -MD                       As -M, but put output in a .d file\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -MMD                      As -MD, but ignore system header files\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -MG                       Treat missing header file as generated files\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -g                        Include #define and #undef directives in the output\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -D<macro>                 Define a<macro> with string '1' as its value\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -D<macro>=<val>           Define a<macro> with<val> as its value\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -A<question> (<answer>)   Assert the<answer> to<question>\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -U<macro>                 Undefine<macro> \n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -u or -undef              Do not predefine any macros\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -v                        Display the version number\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -H                        Print the name of header files as they are used\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -C                        Do not discard comments\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -dM                       Display a list of macro definitions active at end\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -dD                       Preserve macro definitions in output\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -dN                       As -dD except that only the names are preserved\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -dI                       Include #include directives in the output\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -ifoutput                 Describe skipped code blocks in output \n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -P                        Do not generate #line directives\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -$                        Do not include '$' in identifiers\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -remap                    Remap file names when including files.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  -h or --help              Display this information\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Handle one command-line option in (argc, argv).    Can be called multiple times, to handle multiple sets of options.    Returns number of strings consumed.  */
end_comment

begin_function
name|int
name|cpp_handle_option
parameter_list|(
name|pfile
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|struct
name|cpp_options
modifier|*
name|opts
init|=
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|!=
literal|'-'
condition|)
block|{
if|if
condition|(
name|opts
operator|->
name|out_fname
operator|!=
name|NULL
condition|)
block|{
name|print_help
argument_list|()
expr_stmt|;
name|cpp_fatal
argument_list|(
name|pfile
argument_list|,
literal|"Too many arguments"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opts
operator|->
name|in_fname
operator|!=
name|NULL
condition|)
name|opts
operator|->
name|out_fname
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
else|else
name|opts
operator|->
name|in_fname
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
condition|)
block|{
name|missing_filename
label|:
name|cpp_fatal
argument_list|(
name|pfile
argument_list|,
literal|"Filename missing after `%s' option"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
name|argc
return|;
name|missing_dirname
label|:
name|cpp_fatal
argument_list|(
name|pfile
argument_list|,
literal|"Directory name missing after `%s' option"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
name|argc
return|;
case|case
literal|'i'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-include"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-imacros"
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
goto|goto
name|missing_filename
goto|;
else|else
name|push_pending
argument_list|(
name|pfile
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
name|argv
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
operator|,
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-iprefix"
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
goto|goto
name|missing_filename
goto|;
else|else
name|opts
operator|->
name|include_prefix
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-ifoutput"
argument_list|)
condition|)
block|{
name|opts
operator|->
name|output_conditionals
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-isystem"
argument_list|)
condition|)
block|{
name|struct
name|file_name_list
modifier|*
name|dirtmp
decl_stmt|;
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
goto|goto
name|missing_filename
goto|;
name|dirtmp
operator|=
operator|(
expr|struct
name|file_name_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|file_name_list
argument_list|)
argument_list|)
expr_stmt|;
name|dirtmp
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|dirtmp
operator|->
name|control_macro
operator|=
literal|0
expr_stmt|;
name|dirtmp
operator|->
name|c_system_include_path
operator|=
literal|1
expr_stmt|;
name|dirtmp
operator|->
name|fname
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|argv
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|dirtmp
operator|->
name|fname
argument_list|,
name|argv
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
name|dirtmp
operator|->
name|got_name_map
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|opts
operator|->
name|before_system
operator|==
literal|0
condition|)
name|opts
operator|->
name|before_system
operator|=
name|dirtmp
expr_stmt|;
else|else
name|opts
operator|->
name|last_before_system
operator|->
name|next
operator|=
name|dirtmp
expr_stmt|;
name|opts
operator|->
name|last_before_system
operator|=
name|dirtmp
expr_stmt|;
comment|/* Tail follows the last one */
block|}
comment|/* Add directory to end of path for includes, 	 with the default prefix at the front of its name.  */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-iwithprefix"
argument_list|)
condition|)
block|{
name|struct
name|file_name_list
modifier|*
name|dirtmp
decl_stmt|;
name|char
modifier|*
name|prefix
decl_stmt|;
if|if
condition|(
name|opts
operator|->
name|include_prefix
operator|!=
literal|0
condition|)
name|prefix
operator|=
name|opts
operator|->
name|include_prefix
expr_stmt|;
else|else
block|{
name|prefix
operator|=
name|savestring
argument_list|(
name|GCC_INCLUDE_DIR
argument_list|)
expr_stmt|;
comment|/* Remove the `include' from /usr/local/lib/gcc.../include.  */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|prefix
operator|+
name|strlen
argument_list|(
name|prefix
argument_list|)
operator|-
literal|8
argument_list|,
literal|"/include"
argument_list|)
condition|)
name|prefix
index|[
name|strlen
argument_list|(
name|prefix
argument_list|)
operator|-
literal|7
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|dirtmp
operator|=
operator|(
expr|struct
name|file_name_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|file_name_list
argument_list|)
argument_list|)
expr_stmt|;
name|dirtmp
operator|->
name|next
operator|=
literal|0
expr_stmt|;
comment|/* New one goes on the end */
name|dirtmp
operator|->
name|control_macro
operator|=
literal|0
expr_stmt|;
name|dirtmp
operator|->
name|c_system_include_path
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
goto|goto
name|missing_dirname
goto|;
name|dirtmp
operator|->
name|fname
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|argv
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
operator|+
name|strlen
argument_list|(
name|prefix
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|dirtmp
operator|->
name|fname
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|dirtmp
operator|->
name|fname
argument_list|,
name|argv
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
name|dirtmp
operator|->
name|got_name_map
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|opts
operator|->
name|after_include
operator|==
literal|0
condition|)
name|opts
operator|->
name|after_include
operator|=
name|dirtmp
expr_stmt|;
else|else
name|opts
operator|->
name|last_after_include
operator|->
name|next
operator|=
name|dirtmp
expr_stmt|;
name|opts
operator|->
name|last_after_include
operator|=
name|dirtmp
expr_stmt|;
comment|/* Tail follows the last one */
block|}
comment|/* Add directory to main path for includes, 	 with the default prefix at the front of its name.  */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-iwithprefixbefore"
argument_list|)
condition|)
block|{
name|struct
name|file_name_list
modifier|*
name|dirtmp
decl_stmt|;
name|char
modifier|*
name|prefix
decl_stmt|;
if|if
condition|(
name|opts
operator|->
name|include_prefix
operator|!=
literal|0
condition|)
name|prefix
operator|=
name|opts
operator|->
name|include_prefix
expr_stmt|;
else|else
block|{
name|prefix
operator|=
name|savestring
argument_list|(
name|GCC_INCLUDE_DIR
argument_list|)
expr_stmt|;
comment|/* Remove the `include' from /usr/local/lib/gcc.../include.  */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|prefix
operator|+
name|strlen
argument_list|(
name|prefix
argument_list|)
operator|-
literal|8
argument_list|,
literal|"/include"
argument_list|)
condition|)
name|prefix
index|[
name|strlen
argument_list|(
name|prefix
argument_list|)
operator|-
literal|7
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|dirtmp
operator|=
operator|(
expr|struct
name|file_name_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|file_name_list
argument_list|)
argument_list|)
expr_stmt|;
name|dirtmp
operator|->
name|next
operator|=
literal|0
expr_stmt|;
comment|/* New one goes on the end */
name|dirtmp
operator|->
name|control_macro
operator|=
literal|0
expr_stmt|;
name|dirtmp
operator|->
name|c_system_include_path
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
goto|goto
name|missing_dirname
goto|;
name|dirtmp
operator|->
name|fname
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|argv
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
operator|+
name|strlen
argument_list|(
name|prefix
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|dirtmp
operator|->
name|fname
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|dirtmp
operator|->
name|fname
argument_list|,
name|argv
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
name|dirtmp
operator|->
name|got_name_map
operator|=
literal|0
expr_stmt|;
name|append_include_chain
argument_list|(
name|pfile
argument_list|,
name|dirtmp
argument_list|,
name|dirtmp
argument_list|)
expr_stmt|;
block|}
comment|/* Add directory to end of path for includes.  */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-idirafter"
argument_list|)
condition|)
block|{
name|struct
name|file_name_list
modifier|*
name|dirtmp
decl_stmt|;
name|dirtmp
operator|=
operator|(
expr|struct
name|file_name_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|file_name_list
argument_list|)
argument_list|)
expr_stmt|;
name|dirtmp
operator|->
name|next
operator|=
literal|0
expr_stmt|;
comment|/* New one goes on the end */
name|dirtmp
operator|->
name|control_macro
operator|=
literal|0
expr_stmt|;
name|dirtmp
operator|->
name|c_system_include_path
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
goto|goto
name|missing_dirname
goto|;
else|else
name|dirtmp
operator|->
name|fname
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
name|dirtmp
operator|->
name|got_name_map
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|opts
operator|->
name|after_include
operator|==
literal|0
condition|)
name|opts
operator|->
name|after_include
operator|=
name|dirtmp
expr_stmt|;
else|else
name|opts
operator|->
name|last_after_include
operator|->
name|next
operator|=
name|dirtmp
expr_stmt|;
name|opts
operator|->
name|last_after_include
operator|=
name|dirtmp
expr_stmt|;
comment|/* Tail follows the last one */
block|}
break|break;
case|case
literal|'o'
case|:
if|if
condition|(
name|opts
operator|->
name|out_fname
operator|!=
name|NULL
condition|)
block|{
name|cpp_fatal
argument_list|(
name|pfile
argument_list|,
literal|"Output filename specified twice"
argument_list|)
expr_stmt|;
return|return
name|argc
return|;
block|}
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
goto|goto
name|missing_filename
goto|;
name|opts
operator|->
name|out_fname
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|opts
operator|->
name|out_fname
argument_list|,
literal|"-"
argument_list|)
condition|)
name|opts
operator|->
name|out_fname
operator|=
literal|""
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-pedantic"
argument_list|)
condition|)
name|CPP_PEDANTIC
argument_list|(
name|pfile
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-pedantic-errors"
argument_list|)
condition|)
block|{
name|CPP_PEDANTIC
argument_list|(
name|pfile
argument_list|)
operator|=
literal|1
expr_stmt|;
name|opts
operator|->
name|pedantic_errors
operator|=
literal|1
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|else if (!strcmp (argv[i], "-pcp")) { 	char *pcp_fname = argv[++i]; 	pcp_outfile = ((pcp_fname[0] != '-' || pcp_fname[1] != '\0') 		       ? fopen (pcp_fname, "w") 		       : fdopen (dup (fileno (stdout)), "w")); 	if (pcp_outfile == 0) 	  cpp_pfatal_with_name (pfile, pcp_fname); 	no_precomp = 1;       }
endif|#
directive|endif
break|break;
case|case
literal|'t'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-traditional"
argument_list|)
condition|)
block|{
name|opts
operator|->
name|traditional
operator|=
literal|1
expr_stmt|;
name|opts
operator|->
name|cplusplus_comments
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-trigraphs"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|opts
operator|->
name|chill
condition|)
name|opts
operator|->
name|no_trigraphs
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
literal|'l'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-lang-c"
argument_list|)
condition|)
name|opts
operator|->
name|cplusplus
operator|=
literal|0
operator|,
name|opts
operator|->
name|cplusplus_comments
operator|=
literal|1
operator|,
name|opts
operator|->
name|c89
operator|=
literal|0
operator|,
name|opts
operator|->
name|objc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-lang-c89"
argument_list|)
condition|)
name|opts
operator|->
name|cplusplus
operator|=
literal|0
operator|,
name|opts
operator|->
name|cplusplus_comments
operator|=
literal|0
operator|,
name|opts
operator|->
name|c89
operator|=
literal|1
operator|,
name|opts
operator|->
name|objc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-lang-c++"
argument_list|)
condition|)
name|opts
operator|->
name|cplusplus
operator|=
literal|1
operator|,
name|opts
operator|->
name|cplusplus_comments
operator|=
literal|1
operator|,
name|opts
operator|->
name|c89
operator|=
literal|0
operator|,
name|opts
operator|->
name|objc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-lang-objc"
argument_list|)
condition|)
name|opts
operator|->
name|cplusplus
operator|=
literal|0
operator|,
name|opts
operator|->
name|cplusplus_comments
operator|=
literal|1
operator|,
name|opts
operator|->
name|c89
operator|=
literal|0
operator|,
name|opts
operator|->
name|objc
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-lang-objc++"
argument_list|)
condition|)
name|opts
operator|->
name|cplusplus
operator|=
literal|1
operator|,
name|opts
operator|->
name|cplusplus_comments
operator|=
literal|1
operator|,
name|opts
operator|->
name|c89
operator|=
literal|0
operator|,
name|opts
operator|->
name|objc
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-lang-asm"
argument_list|)
condition|)
name|opts
operator|->
name|lang_asm
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-lint"
argument_list|)
condition|)
name|opts
operator|->
name|for_lint
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-lang-chill"
argument_list|)
condition|)
name|opts
operator|->
name|objc
operator|=
literal|0
operator|,
name|opts
operator|->
name|cplusplus
operator|=
literal|0
operator|,
name|opts
operator|->
name|chill
operator|=
literal|1
operator|,
name|opts
operator|->
name|traditional
operator|=
literal|1
operator|,
name|opts
operator|->
name|no_trigraphs
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
name|opts
operator|->
name|cplusplus
operator|=
literal|1
operator|,
name|opts
operator|->
name|cplusplus_comments
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|opts
operator|->
name|inhibit_warnings
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wtrigraphs"
argument_list|)
condition|)
name|opts
operator|->
name|warn_trigraphs
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wno-trigraphs"
argument_list|)
condition|)
name|opts
operator|->
name|warn_trigraphs
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wcomment"
argument_list|)
condition|)
name|opts
operator|->
name|warn_comments
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wno-comment"
argument_list|)
condition|)
name|opts
operator|->
name|warn_comments
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wcomments"
argument_list|)
condition|)
name|opts
operator|->
name|warn_comments
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wno-comments"
argument_list|)
condition|)
name|opts
operator|->
name|warn_comments
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wtraditional"
argument_list|)
condition|)
name|opts
operator|->
name|warn_stringify
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wno-traditional"
argument_list|)
condition|)
name|opts
operator|->
name|warn_stringify
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wundef"
argument_list|)
condition|)
name|opts
operator|->
name|warn_undef
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wno-undef"
argument_list|)
condition|)
name|opts
operator|->
name|warn_undef
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wimport"
argument_list|)
condition|)
name|opts
operator|->
name|warn_import
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wno-import"
argument_list|)
condition|)
name|opts
operator|->
name|warn_import
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Werror"
argument_list|)
condition|)
name|opts
operator|->
name|warnings_are_errors
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wno-error"
argument_list|)
condition|)
name|opts
operator|->
name|warnings_are_errors
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wall"
argument_list|)
condition|)
block|{
name|opts
operator|->
name|warn_trigraphs
operator|=
literal|1
expr_stmt|;
name|opts
operator|->
name|warn_comments
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|'M'
case|:
comment|/* The style of the choices here is a bit mixed. 	 The chosen scheme is a hybrid of keeping all options in one string 	 and specifying each option in a separate argument: 	 -M|-MM|-MD file|-MMD file [-MG].  An alternative is: 	 -M|-MM|-MD file|-MMD file|-MG|-MMG; or more concisely: 	 -M[M][G][D file].  This is awkward to handle in specs, and is not 	 as extensible.  */
comment|/* ??? -MG must be specified in addition to one of -M or -MM. 	 This can be relaxed in the future without breaking anything. 	 The converse isn't true.  */
comment|/* -MG isn't valid with -MD or -MMD.  This is checked for later.  */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-MG"
argument_list|)
condition|)
block|{
name|opts
operator|->
name|print_deps_missing_files
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-M"
argument_list|)
condition|)
name|opts
operator|->
name|print_deps
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-MM"
argument_list|)
condition|)
name|opts
operator|->
name|print_deps
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-MD"
argument_list|)
condition|)
name|opts
operator|->
name|print_deps
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-MMD"
argument_list|)
condition|)
name|opts
operator|->
name|print_deps
operator|=
literal|1
expr_stmt|;
comment|/* For -MD and -MMD options, write deps on file named by next arg.  */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-MD"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-MMD"
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
goto|goto
name|missing_filename
goto|;
name|opts
operator|->
name|deps_file
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
block|}
else|else
block|{
comment|/* For -M and -MM, write deps on standard output 	     and suppress the usual output.  */
name|opts
operator|->
name|no_output
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|'d'
case|:
block|{
name|char
modifier|*
name|p
init|=
name|argv
index|[
name|i
index|]
operator|+
literal|2
decl_stmt|;
name|char
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Arg to -d specifies what parts of macros to dump */
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'M'
case|:
name|opts
operator|->
name|dump_macros
operator|=
name|dump_only
expr_stmt|;
name|opts
operator|->
name|no_output
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|opts
operator|->
name|dump_macros
operator|=
name|dump_names
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|opts
operator|->
name|dump_macros
operator|=
name|dump_definitions
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
name|opts
operator|->
name|dump_includes
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
break|break;
case|case
literal|'g'
case|:
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
operator|==
literal|'3'
condition|)
name|opts
operator|->
name|debug_output
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"--help"
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|i
return|;
name|print_help
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"GNU CPP version %s"
argument_list|,
name|version_string
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TARGET_VERSION
name|TARGET_VERSION
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|opts
operator|->
name|verbose
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
name|opts
operator|->
name|print_include_names
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
operator|!=
literal|0
condition|)
name|push_pending
argument_list|(
name|pfile
argument_list|,
literal|"-D"
argument_list|,
name|argv
index|[
name|i
index|]
operator|+
literal|2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
block|{
name|cpp_fatal
argument_list|(
name|pfile
argument_list|,
literal|"Macro name missing after -D option"
argument_list|)
expr_stmt|;
return|return
name|argc
return|;
block|}
else|else
name|i
operator|++
operator|,
name|push_pending
argument_list|(
name|pfile
argument_list|,
literal|"-D"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
block|{
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
operator|!=
literal|0
condition|)
name|p
operator|=
name|argv
index|[
name|i
index|]
operator|+
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
block|{
name|cpp_fatal
argument_list|(
name|pfile
argument_list|,
literal|"Assertion missing after -A option"
argument_list|)
expr_stmt|;
return|return
name|argc
return|;
block|}
else|else
name|p
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-"
argument_list|)
condition|)
block|{
name|struct
name|cpp_pending
modifier|*
modifier|*
name|ptr
decl_stmt|;
comment|/* -A- eliminates all predefined macros and assertions. 	     Let's include also any that were specified earlier 	     on the command line.  That way we can get rid of any 	     that were passed automatically in from GCC.  */
name|opts
operator|->
name|inhibit_predefs
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|ptr
operator|=
operator|&
name|opts
operator|->
name|pending
init|;
operator|*
name|ptr
operator|!=
name|NULL
condition|;
control|)
block|{
name|struct
name|cpp_pending
modifier|*
name|pend
init|=
operator|*
name|ptr
decl_stmt|;
if|if
condition|(
name|pend
operator|->
name|cmd
operator|&&
name|pend
operator|->
name|cmd
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
operator|(
name|pend
operator|->
name|cmd
index|[
literal|1
index|]
operator|==
literal|'D'
operator|||
name|pend
operator|->
name|cmd
index|[
literal|1
index|]
operator|==
literal|'A'
operator|)
condition|)
block|{
operator|*
name|ptr
operator|=
name|pend
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|pend
argument_list|)
expr_stmt|;
block|}
else|else
name|ptr
operator|=
operator|&
name|pend
operator|->
name|next
expr_stmt|;
block|}
block|}
else|else
block|{
name|push_pending
argument_list|(
name|pfile
argument_list|,
literal|"-A"
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'U'
case|:
comment|/* JF #undef something */
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
operator|!=
literal|0
condition|)
name|push_pending
argument_list|(
name|pfile
argument_list|,
literal|"-U"
argument_list|,
name|argv
index|[
name|i
index|]
operator|+
literal|2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
block|{
name|cpp_fatal
argument_list|(
name|pfile
argument_list|,
literal|"Macro name missing after -U option"
argument_list|)
expr_stmt|;
return|return
name|argc
return|;
block|}
else|else
name|push_pending
argument_list|(
name|pfile
argument_list|,
literal|"-U"
argument_list|,
name|argv
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
operator|,
name|i
operator|++
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|opts
operator|->
name|put_out_comments
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
comment|/* -E comes from cc -E; ignore it.  */
break|break;
case|case
literal|'P'
case|:
name|opts
operator|->
name|no_line_commands
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'$'
case|:
comment|/* Don't include $ in identifiers.  */
name|opts
operator|->
name|dollars_in_ident
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
comment|/* Add directory to path for includes.  */
block|{
name|struct
name|file_name_list
modifier|*
name|dirtmp
decl_stmt|;
if|if
condition|(
operator|!
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|ignore_srcdir
operator|&&
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
operator|+
literal|2
argument_list|,
literal|"-"
argument_list|)
condition|)
block|{
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|ignore_srcdir
operator|=
literal|1
expr_stmt|;
comment|/* Don't use any preceding -I directories for #include<...>.  */
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|first_bracket_include
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|dirtmp
operator|=
operator|(
expr|struct
name|file_name_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|file_name_list
argument_list|)
argument_list|)
expr_stmt|;
name|dirtmp
operator|->
name|next
operator|=
literal|0
expr_stmt|;
comment|/* New one goes on the end */
name|dirtmp
operator|->
name|control_macro
operator|=
literal|0
expr_stmt|;
name|dirtmp
operator|->
name|c_system_include_path
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
operator|!=
literal|0
condition|)
name|dirtmp
operator|->
name|fname
operator|=
name|argv
index|[
name|i
index|]
operator|+
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
goto|goto
name|missing_dirname
goto|;
else|else
name|dirtmp
operator|->
name|fname
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
name|dirtmp
operator|->
name|got_name_map
operator|=
literal|0
expr_stmt|;
name|append_include_chain
argument_list|(
name|pfile
argument_list|,
name|dirtmp
argument_list|,
name|dirtmp
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'n'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-nostdinc"
argument_list|)
condition|)
comment|/* -nostdinc causes no default include directories. 	   You must specify all include-file directories with -I.  */
name|opts
operator|->
name|no_standard_includes
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-nostdinc++"
argument_list|)
condition|)
comment|/* -nostdinc++ causes no default C++-specific include directories. */
name|opts
operator|->
name|no_standard_cplusplus_includes
operator|=
literal|1
expr_stmt|;
if|#
directive|if
literal|0
block|else if (!strcmp (argv[i], "-noprecomp")) 	no_precomp = 1;
endif|#
directive|endif
break|break;
case|case
literal|'r'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-remap"
argument_list|)
condition|)
name|opts
operator|->
name|remap
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
comment|/* Sun compiler passes undocumented switch "-undef". 	 Let's assume it means to inhibit the predefined symbols.  */
name|opts
operator|->
name|inhibit_predefs
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'\0'
case|:
comment|/* JF handle '-' as file name meaning stdin or stdout */
if|if
condition|(
name|opts
operator|->
name|in_fname
operator|==
name|NULL
condition|)
block|{
name|opts
operator|->
name|in_fname
operator|=
literal|""
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|opts
operator|->
name|out_fname
operator|==
name|NULL
condition|)
block|{
name|opts
operator|->
name|out_fname
operator|=
literal|""
expr_stmt|;
break|break;
block|}
comment|/* else fall through into error */
default|default:
return|return
name|i
return|;
block|}
block|}
return|return
name|i
operator|+
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Handle command-line options in (argc, argv).    Can be called multiple times, to handle multiple sets of options.    Returns if an unrecognized option is seen.    Returns number of strings consumed.  */
end_comment

begin_function
name|int
name|cpp_handle_options
parameter_list|(
name|pfile
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|strings_processed
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|+=
name|strings_processed
control|)
block|{
name|strings_processed
operator|=
name|cpp_handle_option
argument_list|(
name|pfile
argument_list|,
name|argc
operator|-
name|i
argument_list|,
name|argv
operator|+
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|strings_processed
operator|==
literal|0
condition|)
break|break;
block|}
return|return
name|i
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|cpp_finish
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|struct
name|cpp_options
modifier|*
name|opts
init|=
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
if|if
condition|(
name|opts
operator|->
name|print_deps
condition|)
block|{
comment|/* Stream on which to print the dependency information.  */
name|FILE
modifier|*
name|deps_stream
decl_stmt|;
comment|/* Don't actually write the deps file if compilation has failed.  */
if|if
condition|(
name|pfile
operator|->
name|errors
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|deps_mode
init|=
name|opts
operator|->
name|print_deps_append
condition|?
literal|"a"
else|:
literal|"w"
decl_stmt|;
if|if
condition|(
name|opts
operator|->
name|deps_file
operator|==
literal|0
condition|)
name|deps_stream
operator|=
name|stdout
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|deps_stream
operator|=
name|fopen
argument_list|(
name|opts
operator|->
name|deps_file
argument_list|,
name|deps_mode
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|cpp_pfatal_with_name
argument_list|(
name|pfile
argument_list|,
name|opts
operator|->
name|deps_file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|pfile
operator|->
name|deps_buffer
argument_list|,
name|deps_stream
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|deps_stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|opts
operator|->
name|deps_file
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|deps_stream
argument_list|)
operator|||
name|fclose
argument_list|(
name|deps_stream
argument_list|)
operator|!=
literal|0
condition|)
name|cpp_fatal
argument_list|(
name|pfile
argument_list|,
literal|"I/O error on output"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Free resources used by PFILE.    This is the cpp_reader 'finalizer' or 'destructor' (in C++ terminology).  */
end_comment

begin_function
name|void
name|cpp_cleanup
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
while|while
condition|(
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|!=
name|CPP_NULL_BUFFER
argument_list|(
name|pfile
argument_list|)
condition|)
name|cpp_pop_buffer
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfile
operator|->
name|token_buffer
condition|)
block|{
name|free
argument_list|(
name|pfile
operator|->
name|token_buffer
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|token_buffer
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|pfile
operator|->
name|deps_buffer
condition|)
block|{
name|free
argument_list|(
name|pfile
operator|->
name|deps_buffer
argument_list|)
expr_stmt|;
name|pfile
operator|->
name|deps_buffer
operator|=
name|NULL
expr_stmt|;
name|pfile
operator|->
name|deps_allocated_size
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
name|pfile
operator|->
name|if_stack
condition|)
block|{
name|IF_STACK_FRAME
modifier|*
name|temp
init|=
name|pfile
operator|->
name|if_stack
decl_stmt|;
name|pfile
operator|->
name|if_stack
operator|=
name|temp
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|pfile
operator|->
name|dont_repeat_files
condition|)
block|{
name|struct
name|file_name_list
modifier|*
name|temp
init|=
name|pfile
operator|->
name|dont_repeat_files
decl_stmt|;
name|pfile
operator|->
name|dont_repeat_files
operator|=
name|temp
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|temp
operator|->
name|fname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|pfile
operator|->
name|all_include_files
condition|)
block|{
name|struct
name|file_name_list
modifier|*
name|temp
init|=
name|pfile
operator|->
name|all_include_files
decl_stmt|;
name|pfile
operator|->
name|all_include_files
operator|=
name|temp
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|temp
operator|->
name|fname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|IMPORT_HASH_SIZE
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
block|{
specifier|register
name|struct
name|import_file
modifier|*
name|imp
init|=
name|pfile
operator|->
name|import_hash_table
index|[
name|i
index|]
decl_stmt|;
while|while
condition|(
name|imp
condition|)
block|{
name|struct
name|import_file
modifier|*
name|next
init|=
name|imp
operator|->
name|next
decl_stmt|;
name|free
argument_list|(
name|imp
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|imp
argument_list|)
expr_stmt|;
name|imp
operator|=
name|next
expr_stmt|;
block|}
name|pfile
operator|->
name|import_hash_table
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|ASSERTION_HASHSIZE
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
block|{
while|while
condition|(
name|pfile
operator|->
name|assertion_hashtab
index|[
name|i
index|]
condition|)
name|delete_assertion
argument_list|(
name|pfile
operator|->
name|assertion_hashtab
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|cpp_hash_cleanup
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|int
name|do_assert
parameter_list|(
name|pfile
parameter_list|,
name|keyword
parameter_list|,
name|buf
parameter_list|,
name|limit
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|struct
name|directive
modifier|*
name|keyword
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|U_CHAR
modifier|*
name|buf
name|ATTRIBUTE_UNUSED
decl_stmt|,
decl|*
name|limit
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_function

begin_block
block|{
name|long
name|symstart
decl_stmt|;
comment|/* remember where symbol name starts */
name|int
name|c
decl_stmt|;
name|int
name|sym_length
decl_stmt|;
comment|/* and how long it is */
name|struct
name|arglist
modifier|*
name|tokens
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|CPP_PEDANTIC
argument_list|(
name|pfile
argument_list|)
operator|&&
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|done_initializing
operator|&&
operator|!
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|->
name|system_header_p
condition|)
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"ANSI C does not allow `#assert'"
argument_list|)
expr_stmt|;
name|cpp_skip_hspace
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|symstart
operator|=
name|CPP_WRITTEN
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
comment|/* remember where it starts */
name|parse_name
argument_list|(
name|pfile
argument_list|,
name|GETC
argument_list|()
argument_list|)
expr_stmt|;
name|sym_length
operator|=
name|check_macro_name
argument_list|(
name|pfile
argument_list|,
name|pfile
operator|->
name|token_buffer
operator|+
name|symstart
argument_list|,
literal|"assertion"
argument_list|)
expr_stmt|;
name|cpp_skip_hspace
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|PEEKC
argument_list|()
operator|!=
literal|'('
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"missing token-sequence in `#assert'"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|{
name|int
name|error_flag
init|=
literal|0
decl_stmt|;
name|tokens
operator|=
name|read_token_list
argument_list|(
name|pfile
argument_list|,
operator|&
name|error_flag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error_flag
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
name|tokens
operator|==
literal|0
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"empty token-sequence in `#assert'"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|cpp_skip_hspace
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|c
operator|=
name|PEEKC
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|EOF
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"junk at end of `#assert'"
argument_list|)
expr_stmt|;
name|skip_rest_of_line
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
comment|/* If this name isn't already an assertion name, make it one.      Error if it was already in use in some other way.  */
block|{
name|ASSERTION_HASHNODE
modifier|*
name|hp
decl_stmt|;
name|U_CHAR
modifier|*
name|symname
init|=
name|pfile
operator|->
name|token_buffer
operator|+
name|symstart
decl_stmt|;
name|int
name|hashcode
init|=
name|hashf
argument_list|(
name|symname
argument_list|,
name|sym_length
argument_list|,
name|ASSERTION_HASHSIZE
argument_list|)
decl_stmt|;
name|struct
name|tokenlist_list
modifier|*
name|value
init|=
operator|(
expr|struct
name|tokenlist_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|tokenlist_list
argument_list|)
argument_list|)
decl_stmt|;
name|hp
operator|=
name|assertion_lookup
argument_list|(
name|pfile
argument_list|,
name|symname
argument_list|,
name|sym_length
argument_list|,
name|hashcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|sym_length
operator|==
literal|7
operator|&&
operator|!
name|strncmp
argument_list|(
name|symname
argument_list|,
literal|"defined"
argument_list|,
name|sym_length
argument_list|)
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"`defined' redefined as assertion"
argument_list|)
expr_stmt|;
name|hp
operator|=
name|assertion_install
argument_list|(
name|pfile
argument_list|,
name|symname
argument_list|,
name|sym_length
argument_list|,
name|hashcode
argument_list|)
expr_stmt|;
block|}
comment|/* Add the spec'd token-sequence to the list of such.  */
name|value
operator|->
name|tokens
operator|=
name|tokens
expr_stmt|;
name|value
operator|->
name|next
operator|=
name|hp
operator|->
name|value
expr_stmt|;
name|hp
operator|->
name|value
operator|=
name|value
expr_stmt|;
block|}
name|CPP_SET_WRITTEN
argument_list|(
name|pfile
argument_list|,
name|symstart
argument_list|)
expr_stmt|;
comment|/* Pop */
return|return
literal|0
return|;
name|error
label|:
name|CPP_SET_WRITTEN
argument_list|(
name|pfile
argument_list|,
name|symstart
argument_list|)
expr_stmt|;
comment|/* Pop */
name|skip_rest_of_line
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_block

begin_escape
end_escape

begin_function
specifier|static
name|int
name|do_unassert
parameter_list|(
name|pfile
parameter_list|,
name|keyword
parameter_list|,
name|buf
parameter_list|,
name|limit
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|struct
name|directive
modifier|*
name|keyword
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|U_CHAR
modifier|*
name|buf
name|ATTRIBUTE_UNUSED
decl_stmt|,
decl|*
name|limit
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_function

begin_block
block|{
name|long
name|symstart
decl_stmt|;
comment|/* remember where symbol name starts */
name|int
name|sym_length
decl_stmt|;
comment|/* and how long it is */
name|int
name|c
decl_stmt|;
name|struct
name|arglist
modifier|*
name|tokens
init|=
name|NULL
decl_stmt|;
name|int
name|tokens_specified
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|CPP_PEDANTIC
argument_list|(
name|pfile
argument_list|)
operator|&&
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|done_initializing
operator|&&
operator|!
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|->
name|system_header_p
condition|)
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"ANSI C does not allow `#unassert'"
argument_list|)
expr_stmt|;
name|cpp_skip_hspace
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|symstart
operator|=
name|CPP_WRITTEN
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
comment|/* remember where it starts */
name|parse_name
argument_list|(
name|pfile
argument_list|,
name|GETC
argument_list|()
argument_list|)
expr_stmt|;
name|sym_length
operator|=
name|check_macro_name
argument_list|(
name|pfile
argument_list|,
name|pfile
operator|->
name|token_buffer
operator|+
name|symstart
argument_list|,
literal|"assertion"
argument_list|)
expr_stmt|;
name|cpp_skip_hspace
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|PEEKC
argument_list|()
operator|==
literal|'('
condition|)
block|{
name|int
name|error_flag
init|=
literal|0
decl_stmt|;
name|tokens
operator|=
name|read_token_list
argument_list|(
name|pfile
argument_list|,
operator|&
name|error_flag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error_flag
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
name|tokens
operator|==
literal|0
condition|)
block|{
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"empty token list in `#unassert'"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|tokens_specified
operator|=
literal|1
expr_stmt|;
block|}
name|cpp_skip_hspace
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|c
operator|=
name|PEEKC
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|EOF
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"junk at end of `#unassert'"
argument_list|)
expr_stmt|;
name|skip_rest_of_line
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|{
name|ASSERTION_HASHNODE
modifier|*
name|hp
decl_stmt|;
name|U_CHAR
modifier|*
name|symname
init|=
name|pfile
operator|->
name|token_buffer
operator|+
name|symstart
decl_stmt|;
name|int
name|hashcode
init|=
name|hashf
argument_list|(
name|symname
argument_list|,
name|sym_length
argument_list|,
name|ASSERTION_HASHSIZE
argument_list|)
decl_stmt|;
name|struct
name|tokenlist_list
modifier|*
name|tail
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
name|hp
operator|=
name|assertion_lookup
argument_list|(
name|pfile
argument_list|,
name|symname
argument_list|,
name|sym_length
argument_list|,
name|hashcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
comment|/* If no token list was specified, then eliminate this assertion        entirely.  */
if|if
condition|(
operator|!
name|tokens_specified
condition|)
name|delete_assertion
argument_list|(
name|hp
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* If a list of tokens was given, then delete any matching list.  */
name|tail
operator|=
name|hp
operator|->
name|value
expr_stmt|;
name|prev
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|tail
condition|)
block|{
name|struct
name|tokenlist_list
modifier|*
name|next
init|=
name|tail
operator|->
name|next
decl_stmt|;
if|if
condition|(
name|compare_token_lists
argument_list|(
name|tail
operator|->
name|tokens
argument_list|,
name|tokens
argument_list|)
condition|)
block|{
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|next
operator|=
name|next
expr_stmt|;
else|else
name|hp
operator|->
name|value
operator|=
name|tail
operator|->
name|next
expr_stmt|;
name|free_token_list
argument_list|(
name|tail
operator|->
name|tokens
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tail
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|prev
operator|=
name|tail
expr_stmt|;
block|}
name|tail
operator|=
name|next
expr_stmt|;
block|}
block|}
block|}
name|CPP_SET_WRITTEN
argument_list|(
name|pfile
argument_list|,
name|symstart
argument_list|)
expr_stmt|;
comment|/* Pop */
return|return
literal|0
return|;
name|error
label|:
name|CPP_SET_WRITTEN
argument_list|(
name|pfile
argument_list|,
name|symstart
argument_list|)
expr_stmt|;
comment|/* Pop */
name|skip_rest_of_line
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Test whether there is an assertion named NAME    and optionally whether it has an asserted token list TOKENS.    NAME is not null terminated; its length is SYM_LENGTH.    If TOKENS_SPECIFIED is 0, then don't check for any token list.  */
end_comment

begin_function
name|int
name|check_assertion
parameter_list|(
name|pfile
parameter_list|,
name|name
parameter_list|,
name|sym_length
parameter_list|,
name|tokens_specified
parameter_list|,
name|tokens
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|U_CHAR
modifier|*
name|name
decl_stmt|;
name|int
name|sym_length
decl_stmt|;
name|int
name|tokens_specified
decl_stmt|;
name|struct
name|arglist
modifier|*
name|tokens
decl_stmt|;
block|{
name|ASSERTION_HASHNODE
modifier|*
name|hp
decl_stmt|;
name|int
name|hashcode
init|=
name|hashf
argument_list|(
name|name
argument_list|,
name|sym_length
argument_list|,
name|ASSERTION_HASHSIZE
argument_list|)
decl_stmt|;
if|if
condition|(
name|CPP_PEDANTIC
argument_list|(
name|pfile
argument_list|)
operator|&&
operator|!
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
operator|->
name|system_header_p
condition|)
name|cpp_pedwarn
argument_list|(
name|pfile
argument_list|,
literal|"ANSI C does not allow testing assertions"
argument_list|)
expr_stmt|;
name|hp
operator|=
name|assertion_lookup
argument_list|(
name|pfile
argument_list|,
name|name
argument_list|,
name|sym_length
argument_list|,
name|hashcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
comment|/* It is not an assertion; just return false.  */
return|return
literal|0
return|;
comment|/* If no token list was specified, then value is 1.  */
if|if
condition|(
operator|!
name|tokens_specified
condition|)
return|return
literal|1
return|;
block|{
name|struct
name|tokenlist_list
modifier|*
name|tail
decl_stmt|;
name|tail
operator|=
name|hp
operator|->
name|value
expr_stmt|;
comment|/* If a list of tokens was given,        then succeed if the assertion records a matching list.  */
while|while
condition|(
name|tail
condition|)
block|{
if|if
condition|(
name|compare_token_lists
argument_list|(
name|tail
operator|->
name|tokens
argument_list|,
name|tokens
argument_list|)
condition|)
return|return
literal|1
return|;
name|tail
operator|=
name|tail
operator|->
name|next
expr_stmt|;
block|}
comment|/* Fail if the assertion has no matching list.  */
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Compare two lists of tokens for equality including order of tokens.  */
end_comment

begin_function
specifier|static
name|int
name|compare_token_lists
parameter_list|(
name|l1
parameter_list|,
name|l2
parameter_list|)
name|struct
name|arglist
modifier|*
name|l1
decl_stmt|,
decl|*
name|l2
decl_stmt|;
end_function

begin_block
block|{
while|while
condition|(
name|l1
operator|&&
name|l2
condition|)
block|{
if|if
condition|(
name|l1
operator|->
name|length
operator|!=
name|l2
operator|->
name|length
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|l1
operator|->
name|name
argument_list|,
name|l2
operator|->
name|name
argument_list|,
name|l1
operator|->
name|length
argument_list|)
condition|)
return|return
literal|0
return|;
name|l1
operator|=
name|l1
operator|->
name|next
expr_stmt|;
name|l2
operator|=
name|l2
operator|->
name|next
expr_stmt|;
block|}
comment|/* Succeed if both lists end at the same time.  */
return|return
name|l1
operator|==
name|l2
return|;
block|}
end_block

begin_escape
end_escape

begin_function
name|struct
name|arglist
modifier|*
name|reverse_token_list
parameter_list|(
name|tokens
parameter_list|)
name|struct
name|arglist
modifier|*
name|tokens
decl_stmt|;
block|{
specifier|register
name|struct
name|arglist
modifier|*
name|prev
init|=
literal|0
decl_stmt|,
modifier|*
name|this
decl_stmt|,
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|this
operator|=
name|tokens
init|;
name|this
condition|;
name|this
operator|=
name|next
control|)
block|{
name|next
operator|=
name|this
operator|->
name|next
expr_stmt|;
name|this
operator|->
name|next
operator|=
name|prev
expr_stmt|;
name|prev
operator|=
name|this
expr_stmt|;
block|}
return|return
name|prev
return|;
block|}
end_function

begin_comment
comment|/* Read a space-separated list of tokens ending in a close parenthesis.    Return a list of strings, in the order they were written.    (In case of error, return 0 and store -1 in *ERROR_FLAG.) */
end_comment

begin_function
specifier|static
name|struct
name|arglist
modifier|*
name|read_token_list
parameter_list|(
name|pfile
parameter_list|,
name|error_flag
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|int
modifier|*
name|error_flag
decl_stmt|;
block|{
name|struct
name|arglist
modifier|*
name|token_ptrs
init|=
literal|0
decl_stmt|;
name|int
name|depth
init|=
literal|1
decl_stmt|;
name|int
name|length
decl_stmt|;
operator|*
name|error_flag
operator|=
literal|0
expr_stmt|;
name|FORWARD
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Skip '(' */
comment|/* Loop over the assertion value tokens.  */
while|while
condition|(
name|depth
operator|>
literal|0
condition|)
block|{
name|struct
name|arglist
modifier|*
name|temp
decl_stmt|;
name|long
name|name_written
init|=
name|CPP_WRITTEN
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
name|int
name|c
decl_stmt|;
name|cpp_skip_hspace
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|c
operator|=
name|GETC
argument_list|()
expr_stmt|;
comment|/* Find the end of the token.  */
if|if
condition|(
name|c
operator|==
literal|'('
condition|)
block|{
name|CPP_PUTC
argument_list|(
name|pfile
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|depth
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|')'
condition|)
block|{
name|depth
operator|--
expr_stmt|;
if|if
condition|(
name|depth
operator|==
literal|0
condition|)
break|break;
name|CPP_PUTC
argument_list|(
name|pfile
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'"'
operator|||
name|c
operator|==
literal|'\''
condition|)
block|{
name|FORWARD
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|cpp_get_token
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
break|break;
else|else
block|{
while|while
condition|(
name|c
operator|!=
name|EOF
operator|&&
operator|!
name|is_space
index|[
name|c
index|]
operator|&&
name|c
operator|!=
literal|'('
operator|&&
name|c
operator|!=
literal|')'
operator|&&
name|c
operator|!=
literal|'"'
operator|&&
name|c
operator|!=
literal|'\''
condition|)
block|{
name|CPP_PUTC
argument_list|(
name|pfile
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
name|GETC
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|!=
name|EOF
condition|)
name|FORWARD
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|length
operator|=
name|CPP_WRITTEN
argument_list|(
name|pfile
argument_list|)
operator|-
name|name_written
expr_stmt|;
name|temp
operator|=
operator|(
expr|struct
name|arglist
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|arglist
argument_list|)
operator|+
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|temp
operator|->
name|name
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
operator|(
name|temp
operator|+
literal|1
operator|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|pfile
operator|->
name|token_buffer
operator|+
name|name_written
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|temp
operator|->
name|name
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|temp
operator|->
name|name
index|[
name|length
index|]
operator|=
literal|0
expr_stmt|;
name|temp
operator|->
name|next
operator|=
name|token_ptrs
expr_stmt|;
name|token_ptrs
operator|=
name|temp
expr_stmt|;
name|temp
operator|->
name|length
operator|=
name|length
expr_stmt|;
name|CPP_ADJUST_WRITTEN
argument_list|(
name|pfile
argument_list|,
operator|-
name|length
argument_list|)
expr_stmt|;
comment|/* pop */
if|if
condition|(
name|c
operator|==
name|EOF
operator|||
name|c
operator|==
literal|'\n'
condition|)
block|{
comment|/* FIXME */
name|cpp_error
argument_list|(
name|pfile
argument_list|,
literal|"unterminated token sequence following  `#' operator"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/* We accumulated the names in reverse order.      Now reverse them to get the proper order.  */
return|return
name|reverse_token_list
argument_list|(
name|token_ptrs
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_token_list
parameter_list|(
name|tokens
parameter_list|)
name|struct
name|arglist
modifier|*
name|tokens
decl_stmt|;
block|{
while|while
condition|(
name|tokens
condition|)
block|{
name|struct
name|arglist
modifier|*
name|next
init|=
name|tokens
operator|->
name|next
decl_stmt|;
name|free
argument_list|(
name|tokens
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tokens
argument_list|)
expr_stmt|;
name|tokens
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read LEN bytes at PTR from descriptor DESC, for file FILENAME,    retrying if necessary.  If MAX_READ_LEN is defined, read at most    that bytes at a time.  Return a negative value if an error occurs,    otherwise return the actual number of bytes read,    which must be LEN unless end-of-file was reached.  */
end_comment

begin_function
specifier|static
name|int
name|safe_read
parameter_list|(
name|desc
parameter_list|,
name|ptr
parameter_list|,
name|len
parameter_list|)
name|int
name|desc
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|int
name|left
decl_stmt|,
name|rcount
decl_stmt|,
name|nchars
decl_stmt|;
name|left
operator|=
name|len
expr_stmt|;
while|while
condition|(
name|left
operator|>
literal|0
condition|)
block|{
name|rcount
operator|=
name|left
expr_stmt|;
ifdef|#
directive|ifdef
name|MAX_READ_LEN
if|if
condition|(
name|rcount
operator|>
name|MAX_READ_LEN
condition|)
name|rcount
operator|=
name|MAX_READ_LEN
expr_stmt|;
endif|#
directive|endif
name|nchars
operator|=
name|read
argument_list|(
name|desc
argument_list|,
name|ptr
argument_list|,
name|rcount
argument_list|)
expr_stmt|;
if|if
condition|(
name|nchars
operator|<
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|EINTR
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
continue|continue;
endif|#
directive|endif
return|return
name|nchars
return|;
block|}
if|if
condition|(
name|nchars
operator|==
literal|0
condition|)
break|break;
name|ptr
operator|+=
name|nchars
expr_stmt|;
name|left
operator|-=
name|nchars
expr_stmt|;
block|}
return|return
name|len
operator|-
name|left
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|xcalloc
parameter_list|(
name|number
parameter_list|,
name|size
parameter_list|)
name|unsigned
name|number
decl_stmt|,
name|size
decl_stmt|;
block|{
specifier|register
name|unsigned
name|total
init|=
name|number
operator|*
name|size
decl_stmt|;
specifier|register
name|char
modifier|*
name|ptr
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|total
argument_list|)
decl_stmt|;
name|bzero
argument_list|(
name|ptr
argument_list|,
name|total
argument_list|)
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|savestring
parameter_list|(
name|input
parameter_list|)
name|char
modifier|*
name|input
decl_stmt|;
block|{
name|unsigned
name|size
init|=
name|strlen
argument_list|(
name|input
argument_list|)
decl_stmt|;
name|char
modifier|*
name|output
init|=
name|xmalloc
argument_list|(
name|size
operator|+
literal|1
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|output
argument_list|,
name|input
argument_list|)
expr_stmt|;
return|return
name|output
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Initialize PMARK to remember the current position of PFILE.  */
end_comment

begin_function
name|void
name|parse_set_mark
parameter_list|(
name|pmark
parameter_list|,
name|pfile
parameter_list|)
name|struct
name|parse_marker
modifier|*
name|pmark
decl_stmt|;
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|cpp_buffer
modifier|*
name|pbuf
init|=
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
name|pmark
operator|->
name|next
operator|=
name|pbuf
operator|->
name|marks
expr_stmt|;
name|pbuf
operator|->
name|marks
operator|=
name|pmark
expr_stmt|;
name|pmark
operator|->
name|buf
operator|=
name|pbuf
expr_stmt|;
name|pmark
operator|->
name|position
operator|=
name|pbuf
operator|->
name|cur
operator|-
name|pbuf
operator|->
name|buf
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Cleanup PMARK - we no longer need it.  */
end_comment

begin_function
name|void
name|parse_clear_mark
parameter_list|(
name|pmark
parameter_list|)
name|struct
name|parse_marker
modifier|*
name|pmark
decl_stmt|;
block|{
name|struct
name|parse_marker
modifier|*
modifier|*
name|pp
init|=
operator|&
name|pmark
operator|->
name|buf
operator|->
name|marks
decl_stmt|;
for|for
control|(
init|;
condition|;
name|pp
operator|=
operator|&
operator|(
operator|*
name|pp
operator|)
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|*
name|pp
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|pp
operator|==
name|pmark
condition|)
break|break;
block|}
operator|*
name|pp
operator|=
name|pmark
operator|->
name|next
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Backup the current position of PFILE to that saved in PMARK.  */
end_comment

begin_function
name|void
name|parse_goto_mark
parameter_list|(
name|pmark
parameter_list|,
name|pfile
parameter_list|)
name|struct
name|parse_marker
modifier|*
name|pmark
decl_stmt|;
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|cpp_buffer
modifier|*
name|pbuf
init|=
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
if|if
condition|(
name|pbuf
operator|!=
name|pmark
operator|->
name|buf
condition|)
name|cpp_fatal
argument_list|(
name|pfile
argument_list|,
literal|"internal error %s"
argument_list|,
literal|"parse_goto_mark"
argument_list|)
expr_stmt|;
name|pbuf
operator|->
name|cur
operator|=
name|pbuf
operator|->
name|buf
operator|+
name|pmark
operator|->
name|position
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Reset PMARK to point to the current position of PFILE.  (Same    as parse_clear_mark (PMARK), parse_set_mark (PMARK, PFILE) but faster.  */
end_comment

begin_function
name|void
name|parse_move_mark
parameter_list|(
name|pmark
parameter_list|,
name|pfile
parameter_list|)
name|struct
name|parse_marker
modifier|*
name|pmark
decl_stmt|;
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|cpp_buffer
modifier|*
name|pbuf
init|=
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
if|if
condition|(
name|pbuf
operator|!=
name|pmark
operator|->
name|buf
condition|)
name|cpp_fatal
argument_list|(
name|pfile
argument_list|,
literal|"internal error %s"
argument_list|,
literal|"parse_move_mark"
argument_list|)
expr_stmt|;
name|pmark
operator|->
name|position
operator|=
name|pbuf
operator|->
name|cur
operator|-
name|pbuf
operator|->
name|buf
expr_stmt|;
block|}
end_function

begin_function
name|int
name|cpp_read_check_assertion
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|int
name|name_start
init|=
name|CPP_WRITTEN
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
name|int
name|name_length
decl_stmt|,
name|name_written
decl_stmt|;
name|int
name|result
decl_stmt|;
name|FORWARD
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Skip '#' */
name|cpp_skip_hspace
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|parse_name
argument_list|(
name|pfile
argument_list|,
name|GETC
argument_list|()
argument_list|)
expr_stmt|;
name|name_written
operator|=
name|CPP_WRITTEN
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|name_length
operator|=
name|name_written
operator|-
name|name_start
expr_stmt|;
name|cpp_skip_hspace
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|CPP_BUF_PEEK
argument_list|(
name|CPP_BUFFER
argument_list|(
name|pfile
argument_list|)
argument_list|)
operator|==
literal|'('
condition|)
block|{
name|int
name|error_flag
decl_stmt|;
name|struct
name|arglist
modifier|*
name|token_ptrs
init|=
name|read_token_list
argument_list|(
name|pfile
argument_list|,
operator|&
name|error_flag
argument_list|)
decl_stmt|;
name|result
operator|=
name|check_assertion
argument_list|(
name|pfile
argument_list|,
name|pfile
operator|->
name|token_buffer
operator|+
name|name_start
argument_list|,
name|name_length
argument_list|,
literal|1
argument_list|,
name|token_ptrs
argument_list|)
expr_stmt|;
block|}
else|else
name|result
operator|=
name|check_assertion
argument_list|(
name|pfile
argument_list|,
name|pfile
operator|->
name|token_buffer
operator|+
name|name_start
argument_list|,
name|name_length
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|CPP_ADJUST_WRITTEN
argument_list|(
name|pfile
argument_list|,
operator|-
name|name_length
argument_list|)
expr_stmt|;
comment|/* pop */
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|cpp_print_file_and_line
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
block|{
name|cpp_buffer
modifier|*
name|ip
init|=
name|cpp_file_buffer
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
if|if
condition|(
name|ip
operator|!=
name|NULL
condition|)
block|{
name|long
name|line
decl_stmt|,
name|col
decl_stmt|;
name|cpp_buf_line_and_col
argument_list|(
name|ip
argument_list|,
operator|&
name|line
argument_list|,
operator|&
name|col
argument_list|)
expr_stmt|;
name|cpp_file_line_for_message
argument_list|(
name|pfile
argument_list|,
name|ip
operator|->
name|nominal_fname
argument_list|,
name|line
argument_list|,
name|pfile
operator|->
name|show_column
condition|?
name|col
else|:
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|v_cpp_error
parameter_list|(
name|pfile
parameter_list|,
name|msg
parameter_list|,
name|ap
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
block|{
name|cpp_print_containing_files
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|cpp_print_file_and_line
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|v_cpp_message
argument_list|(
name|pfile
argument_list|,
literal|1
argument_list|,
name|msg
argument_list|,
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|void
name|cpp_error
name|VPROTO
argument_list|(
operator|(
name|cpp_reader
operator|*
name|pfile
operator|,
specifier|const
name|char
operator|*
name|msg
operator|,
operator|...
operator|)
argument_list|)
block|{
ifndef|#
directive|ifndef
name|__STDC__
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
endif|#
directive|endif
name|va_list
name|ap
decl_stmt|;
name|VA_START
argument_list|(
name|ap
argument_list|,
name|msg
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|__STDC__
name|pfile
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|cpp_reader
operator|*
argument_list|)
expr_stmt|;
name|msg
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|v_cpp_error
argument_list|(
name|pfile
argument_list|,
name|msg
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Print error message but don't count it.  */
end_comment

begin_function
specifier|static
name|void
name|v_cpp_warning
parameter_list|(
name|pfile
parameter_list|,
name|msg
parameter_list|,
name|ap
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
block|{
if|if
condition|(
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|inhibit_warnings
condition|)
return|return;
if|if
condition|(
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|warnings_are_errors
condition|)
name|pfile
operator|->
name|errors
operator|++
expr_stmt|;
name|cpp_print_containing_files
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|cpp_print_file_and_line
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|v_cpp_message
argument_list|(
name|pfile
argument_list|,
literal|0
argument_list|,
name|msg
argument_list|,
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|void
name|cpp_warning
name|VPROTO
argument_list|(
operator|(
name|cpp_reader
operator|*
name|pfile
operator|,
specifier|const
name|char
operator|*
name|msg
operator|,
operator|...
operator|)
argument_list|)
block|{
ifndef|#
directive|ifndef
name|__STDC__
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
endif|#
directive|endif
name|va_list
name|ap
decl_stmt|;
name|VA_START
argument_list|(
name|ap
argument_list|,
name|msg
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|__STDC__
name|pfile
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|cpp_reader
operator|*
argument_list|)
expr_stmt|;
name|msg
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|v_cpp_warning
argument_list|(
name|pfile
argument_list|,
name|msg
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Print an error message and maybe count it.  */
end_comment

begin_decl_stmt
name|void
name|cpp_pedwarn
name|VPROTO
argument_list|(
operator|(
name|cpp_reader
operator|*
name|pfile
operator|,
specifier|const
name|char
operator|*
name|msg
operator|,
operator|...
operator|)
argument_list|)
block|{
ifndef|#
directive|ifndef
name|__STDC__
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
endif|#
directive|endif
name|va_list
name|ap
decl_stmt|;
name|VA_START
argument_list|(
name|ap
argument_list|,
name|msg
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|__STDC__
name|pfile
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|cpp_reader
operator|*
argument_list|)
expr_stmt|;
name|msg
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|pedantic_errors
condition|)
name|v_cpp_error
argument_list|(
name|pfile
argument_list|,
name|msg
argument_list|,
name|ap
argument_list|)
expr_stmt|;
else|else
name|v_cpp_warning
argument_list|(
name|pfile
argument_list|,
name|msg
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_function
specifier|static
name|void
name|v_cpp_error_with_line
parameter_list|(
name|pfile
parameter_list|,
name|line
parameter_list|,
name|column
parameter_list|,
name|msg
parameter_list|,
name|ap
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|int
name|line
decl_stmt|;
name|int
name|column
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
block|{
name|cpp_buffer
modifier|*
name|ip
init|=
name|cpp_file_buffer
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
name|cpp_print_containing_files
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|!=
name|NULL
condition|)
name|cpp_file_line_for_message
argument_list|(
name|pfile
argument_list|,
name|ip
operator|->
name|nominal_fname
argument_list|,
name|line
argument_list|,
name|column
argument_list|)
expr_stmt|;
name|v_cpp_message
argument_list|(
name|pfile
argument_list|,
literal|1
argument_list|,
name|msg
argument_list|,
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|void
name|cpp_error_with_line
name|VPROTO
argument_list|(
operator|(
name|cpp_reader
operator|*
name|pfile
operator|,
name|int
name|line
operator|,
name|int
name|column
operator|,
specifier|const
name|char
operator|*
name|msg
operator|,
operator|...
operator|)
argument_list|)
block|{
ifndef|#
directive|ifndef
name|__STDC__
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|int
name|line
decl_stmt|;
name|int
name|column
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
endif|#
directive|endif
name|va_list
name|ap
decl_stmt|;
name|VA_START
argument_list|(
name|ap
argument_list|,
name|msg
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|__STDC__
name|pfile
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|cpp_reader
operator|*
argument_list|)
expr_stmt|;
name|line
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|column
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|msg
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|v_cpp_error_with_line
argument_list|(
name|pfile
argument_list|,
name|line
argument_list|,
name|column
argument_list|,
name|msg
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_function
specifier|static
name|void
name|v_cpp_warning_with_line
parameter_list|(
name|pfile
parameter_list|,
name|line
parameter_list|,
name|column
parameter_list|,
name|msg
parameter_list|,
name|ap
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|int
name|line
decl_stmt|;
name|int
name|column
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
block|{
name|cpp_buffer
modifier|*
name|ip
decl_stmt|;
if|if
condition|(
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|inhibit_warnings
condition|)
return|return;
if|if
condition|(
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|warnings_are_errors
condition|)
name|pfile
operator|->
name|errors
operator|++
expr_stmt|;
name|cpp_print_containing_files
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|ip
operator|=
name|cpp_file_buffer
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|!=
name|NULL
condition|)
name|cpp_file_line_for_message
argument_list|(
name|pfile
argument_list|,
name|ip
operator|->
name|nominal_fname
argument_list|,
name|line
argument_list|,
name|column
argument_list|)
expr_stmt|;
name|v_cpp_message
argument_list|(
name|pfile
argument_list|,
literal|0
argument_list|,
name|msg
argument_list|,
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_ifndef
unit|static void cpp_warning_with_line VPROTO ((cpp_reader * pfile, int line, int column, const char *msg, ...)) {
ifndef|#
directive|ifndef
name|__STDC__
end_ifndef

begin_endif
unit|cpp_reader *pfile;   int line;   int column;   const char *msg;
endif|#
directive|endif
end_endif

begin_ifndef
unit|va_list ap;      VA_START (ap, msg);
ifndef|#
directive|ifndef
name|__STDC__
end_ifndef

begin_endif
unit|pfile = va_arg (ap, cpp_reader *);   line = va_arg (ap, int);   column = va_arg (ap, int);   msg = va_arg (ap, const char *);
endif|#
directive|endif
end_endif

begin_endif
unit|v_cpp_warning_with_line (pfile, line, column, msg, ap);   va_end(ap); }
endif|#
directive|endif
end_endif

begin_decl_stmt
name|void
name|cpp_pedwarn_with_line
name|VPROTO
argument_list|(
operator|(
name|cpp_reader
operator|*
name|pfile
operator|,
name|int
name|line
operator|,
name|int
name|column
operator|,
specifier|const
name|char
operator|*
name|msg
operator|,
operator|...
operator|)
argument_list|)
block|{
ifndef|#
directive|ifndef
name|__STDC__
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|int
name|line
decl_stmt|;
name|int
name|column
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
endif|#
directive|endif
name|va_list
name|ap
decl_stmt|;
name|VA_START
argument_list|(
name|ap
argument_list|,
name|msg
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|__STDC__
name|pfile
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|cpp_reader
operator|*
argument_list|)
expr_stmt|;
name|line
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|column
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|msg
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|pedantic_errors
condition|)
name|v_cpp_error_with_line
argument_list|(
name|pfile
argument_list|,
name|column
argument_list|,
name|line
argument_list|,
name|msg
argument_list|,
name|ap
argument_list|)
expr_stmt|;
else|else
name|v_cpp_warning_with_line
argument_list|(
name|pfile
argument_list|,
name|line
argument_list|,
name|column
argument_list|,
name|msg
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Report a warning (or an error if pedantic_errors)    giving specified file name and line number, not current.  */
end_comment

begin_decl_stmt
name|void
name|cpp_pedwarn_with_file_and_line
name|VPROTO
argument_list|(
operator|(
name|cpp_reader
operator|*
name|pfile
operator|,
name|char
operator|*
name|file
operator|,
name|int
name|line
operator|,
specifier|const
name|char
operator|*
name|msg
operator|,
operator|...
operator|)
argument_list|)
block|{
ifndef|#
directive|ifndef
name|__STDC__
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
endif|#
directive|endif
name|va_list
name|ap
decl_stmt|;
name|VA_START
argument_list|(
name|ap
argument_list|,
name|msg
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|__STDC__
name|pfile
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|cpp_reader
operator|*
argument_list|)
expr_stmt|;
name|file
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|line
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|msg
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|pedantic_errors
operator|&&
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|inhibit_warnings
condition|)
return|return;
if|if
condition|(
name|file
operator|!=
name|NULL
condition|)
name|cpp_file_line_for_message
argument_list|(
name|pfile
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|v_cpp_message
argument_list|(
name|pfile
argument_list|,
name|CPP_OPTIONS
argument_list|(
name|pfile
argument_list|)
operator|->
name|pedantic_errors
argument_list|,
name|msg
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* my_strerror - return the descriptive text associated with an    `errno' code.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|my_strerror
parameter_list|(
name|errnum
parameter_list|)
name|int
name|errnum
decl_stmt|;
block|{
name|char
modifier|*
name|result
decl_stmt|;
ifndef|#
directive|ifndef
name|VMS
ifndef|#
directive|ifndef
name|HAVE_STRERROR
name|result
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
operator|(
name|errnum
operator|<
name|sys_nerr
operator|)
condition|?
name|sys_errlist
index|[
name|errnum
index|]
else|:
literal|0
operator|)
expr_stmt|;
else|#
directive|else
name|result
operator|=
name|strerror
argument_list|(
name|errnum
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
comment|/* VMS */
comment|/* VAXCRTL's strerror() takes an optional second argument, which only      matters when the first argument is EVMSERR.  However, it's simplest      just to pass it unconditionally.  `vaxc$errno' is declared in<errno.h>, and maintained by the library in parallel with `errno'.      We assume that caller's `errnum' either matches the last setting of      `errno' by the library or else does not have the value `EVMSERR'.  */
name|result
operator|=
name|strerror
argument_list|(
name|errnum
argument_list|,
name|vaxc$errno
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|result
condition|)
name|result
operator|=
literal|"undocumented I/O error"
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Error including a message from `errno'.  */
end_comment

begin_function
name|void
name|cpp_error_from_errno
parameter_list|(
name|pfile
parameter_list|,
name|name
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|cpp_message_from_errno
argument_list|(
name|pfile
argument_list|,
literal|1
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cpp_message_from_errno
parameter_list|(
name|pfile
parameter_list|,
name|is_error
parameter_list|,
name|name
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
name|int
name|is_error
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|e
init|=
name|errno
decl_stmt|;
name|cpp_buffer
modifier|*
name|ip
init|=
name|cpp_file_buffer
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
name|cpp_print_containing_files
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|!=
name|NULL
condition|)
name|cpp_file_line_for_message
argument_list|(
name|pfile
argument_list|,
name|ip
operator|->
name|nominal_fname
argument_list|,
name|ip
operator|->
name|lineno
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|cpp_message
argument_list|(
name|pfile
argument_list|,
name|is_error
argument_list|,
literal|"%s: %s"
argument_list|,
name|name
argument_list|,
name|my_strerror
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cpp_perror_with_name
parameter_list|(
name|pfile
parameter_list|,
name|name
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|cpp_message
argument_list|(
name|pfile
argument_list|,
literal|1
argument_list|,
literal|"%s: %s: %s"
argument_list|,
name|progname
argument_list|,
name|name
argument_list|,
name|my_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* TODO:  * No pre-compiled header file support.  *  * Possibly different enum token codes for each C/C++ token.  *  * Should clean up remaining directives to that do_XXX functions  *   only take two arguments and all have command_reads_line.  *  * Find and cleanup remaining uses of static variables,  *  * Support for trigraphs.  *  * Support -dM flag (dump_all_macros).  *  * Support for_lint flag.  */
end_comment

end_unit

