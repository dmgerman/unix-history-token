begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Type based alias analysis.    Copyright (C) 2004, 2005, 2006 Free Software Foundation, Inc.    Contributed by Kenneth Zadeck<zadeck@naturalbridge.com>  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* This pass determines which types in the program contain only    instances that are completely encapsulated by the compilation unit.    Those types that are encapsulated must also pass the further    requirement that there be no bad operations on any instances of    those types.     A great deal of freedom in compilation is allowed for the instances    of those types that pass these conditions. */
end_comment

begin_comment
comment|/* The code in this module is called by the ipa pass manager. It    should be one of the later passes since its information is used by    the rest of the compilation. */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"tree-inline.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"pointer-set.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"ipa-utils.h"
end_include

begin_include
include|#
directive|include
file|"ipa-type-escape.h"
end_include

begin_include
include|#
directive|include
file|"c-common.h"
end_include

begin_include
include|#
directive|include
file|"tree-gimple.h"
end_include

begin_include
include|#
directive|include
file|"cgraph.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_comment
comment|/* Some of the aliasing is called very early, before this phase is    called.  To assure that this is not a problem, we keep track of if    this phase has been run.  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|initialized
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This bitmap contains the set of local vars that are the lhs of    calls to mallocs.  These variables, when seen on the rhs as part of    a cast, the cast are not marked as doing bad things to the type    even though they are generally of the form     "foo = (type_of_foo)void_temp". */
end_comment

begin_decl_stmt
specifier|static
name|bitmap
name|results_of_malloc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Scratch bitmap for avoiding work. */
end_comment

begin_decl_stmt
specifier|static
name|bitmap
name|been_there_done_that
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bitmap
name|bitmap_tmp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* There are two levels of escape that types can undergo.     EXPOSED_PARAMETER - some instance of the variable is    passed by value into an externally visible function or some    instance of the variable is passed out of an externally visible    function as a return value.  In this case any of the fields of the    variable that are pointer types end up having their types marked as    FULL_ESCAPE.     FULL_ESCAPE - when bad things happen to good types. One of the    following things happens to the type: (a) either an instance of the    variable has its address passed to an externally visible function,    (b) the address is taken and some bad cast happens to the address    or (c) explicit arithmetic is done to the address. */
end_comment

begin_enum
enum|enum
name|escape_t
block|{
name|EXPOSED_PARAMETER
block|,
name|FULL_ESCAPE
block|}
enum|;
end_enum

begin_comment
comment|/* The following two bit vectors global_types_* correspond to    previous cases above.  During the analysis phase, a bit is set in    one of these vectors if an operation of the offending class is    discovered to happen on the associated type.  */
end_comment

begin_decl_stmt
specifier|static
name|bitmap
name|global_types_exposed_parameter
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bitmap
name|global_types_full_escape
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* All of the types seen in this compilation unit. */
end_comment

begin_decl_stmt
specifier|static
name|bitmap
name|global_types_seen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Reverse map to take a canon uid and map it to a canon type.  Uid's    are never manipulated unless they are associated with a canon    type.  */
end_comment

begin_decl_stmt
specifier|static
name|splay_tree
name|uid_to_canon_type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Internal structure of type mapping code.  This maps a canon type    name to its canon type.  */
end_comment

begin_decl_stmt
specifier|static
name|splay_tree
name|all_canon_types
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Map from type clones to the single canon type.  */
end_comment

begin_decl_stmt
specifier|static
name|splay_tree
name|type_to_canon_type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A splay tree of bitmaps.  An element X in the splay tree has a bit    set in its bitmap at TYPE_UID (TYPE_MAIN_VARIANT (Y)) if there was    an operation in the program of the form "&X.Y".  */
end_comment

begin_decl_stmt
specifier|static
name|splay_tree
name|uid_to_addressof_down_map
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A splay tree of bitmaps.  An element Y in the splay tree has a bit    set in its bitmap at TYPE_UID (TYPE_MAIN_VARIANT (X)) if there was    an operation in the program of the form "&X.Y".  */
end_comment

begin_decl_stmt
specifier|static
name|splay_tree
name|uid_to_addressof_up_map
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Tree to hold the subtype maps used to mark subtypes of escaped    types.  */
end_comment

begin_decl_stmt
specifier|static
name|splay_tree
name|uid_to_subtype_map
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Records tree nodes seen in cgraph_create_edges.  Simply using    walk_tree_without_duplicates doesn't guarantee each node is visited    once because it gets a new htab upon each recursive call from    scan_for_refs.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|pointer_set_t
modifier|*
name|visited_nodes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bitmap_obstack
name|ipa_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Get the name of TYPE or return the string "<UNNAMED>".  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|get_name_of_type
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|tree
name|name
init|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
comment|/* Unnamed type, do what you like here.  */
return|return
operator|(
name|char
operator|*
operator|)
literal|"<UNNAMED>"
return|;
comment|/* It will be a TYPE_DECL in the case of a typedef, otherwise, an      identifier_node */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
comment|/*  Each DECL has a DECL_NAME field which contains an 	  IDENTIFIER_NODE.  (Some decls, most often labels, may have 	  zero as the DECL_NAME).  */
if|if
condition|(
name|DECL_NAME
argument_list|(
name|name
argument_list|)
condition|)
return|return
operator|(
name|char
operator|*
operator|)
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|name
argument_list|)
argument_list|)
return|;
else|else
comment|/* Unnamed type, do what you like here.  */
return|return
operator|(
name|char
operator|*
operator|)
literal|"<UNNAMED>"
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
return|return
operator|(
name|char
operator|*
operator|)
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
return|;
else|else
return|return
operator|(
name|char
operator|*
operator|)
literal|"<UNNAMED>"
return|;
block|}
end_function

begin_struct
struct|struct
name|type_brand_s
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|seq
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Splay tree comparison function on type_brand_s structures.  */
end_comment

begin_function
specifier|static
name|int
name|compare_type_brand
parameter_list|(
name|splay_tree_key
name|sk1
parameter_list|,
name|splay_tree_key
name|sk2
parameter_list|)
block|{
name|struct
name|type_brand_s
modifier|*
name|k1
init|=
operator|(
expr|struct
name|type_brand_s
operator|*
operator|)
name|sk1
decl_stmt|;
name|struct
name|type_brand_s
modifier|*
name|k2
init|=
operator|(
expr|struct
name|type_brand_s
operator|*
operator|)
name|sk2
decl_stmt|;
name|int
name|value
init|=
name|strcmp
argument_list|(
name|k1
operator|->
name|name
argument_list|,
name|k2
operator|->
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|0
condition|)
return|return
name|k2
operator|->
name|seq
operator|-
name|k1
operator|->
name|seq
return|;
else|else
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/* All of the "unique_type" code is a hack to get around the sleazy    implementation used to compile more than file.  Currently gcc does    not get rid of multiple instances of the same type that have been    collected from different compilation units.  */
end_comment

begin_comment
comment|/* This is a trivial algorithm for removing duplicate types.  This    would not work for any language that used structural equivalence as    the basis of its type system.  */
end_comment

begin_comment
comment|/* Return either TYPE if this is first time TYPE has been seen an    compatible TYPE that has already been processed.  */
end_comment

begin_function
specifier|static
name|tree
name|discover_unique_type
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|struct
name|type_brand_s
modifier|*
name|brand
init|=
name|XNEW
argument_list|(
expr|struct
name|type_brand_s
argument_list|)
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|splay_tree_node
name|result
decl_stmt|;
name|brand
operator|->
name|name
operator|=
name|get_name_of_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|brand
operator|->
name|seq
operator|=
name|i
operator|++
expr_stmt|;
name|result
operator|=
name|splay_tree_lookup
argument_list|(
name|all_canon_types
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|brand
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
block|{
comment|/* Create an alias since this is just the same as 	     other_type.  */
name|tree
name|other_type
init|=
operator|(
name|tree
operator|)
name|result
operator|->
name|value
decl_stmt|;
if|if
condition|(
name|lang_hooks
operator|.
name|types_compatible_p
argument_list|(
name|type
argument_list|,
name|other_type
argument_list|)
operator|==
literal|1
condition|)
block|{
name|free
argument_list|(
name|brand
argument_list|)
expr_stmt|;
comment|/* Insert this new type as an alias for other_type.  */
name|splay_tree_insert
argument_list|(
name|type_to_canon_type
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|type
argument_list|,
operator|(
name|splay_tree_value
operator|)
name|other_type
argument_list|)
expr_stmt|;
return|return
name|other_type
return|;
block|}
comment|/* Not compatible, look for next instance with same name.  */
block|}
else|else
block|{
comment|/* No more instances, create new one since this is the first 	     time we saw this type.  */
name|brand
operator|->
name|seq
operator|=
name|i
operator|++
expr_stmt|;
comment|/* Insert the new brand.  */
name|splay_tree_insert
argument_list|(
name|all_canon_types
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|brand
argument_list|,
operator|(
name|splay_tree_value
operator|)
name|type
argument_list|)
expr_stmt|;
comment|/* Insert this new type as an alias for itself.  */
name|splay_tree_insert
argument_list|(
name|type_to_canon_type
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|type
argument_list|,
operator|(
name|splay_tree_value
operator|)
name|type
argument_list|)
expr_stmt|;
comment|/* Insert the uid for reverse lookup; */
name|splay_tree_insert
argument_list|(
name|uid_to_canon_type
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|TYPE_UID
argument_list|(
name|type
argument_list|)
argument_list|,
operator|(
name|splay_tree_value
operator|)
name|type
argument_list|)
expr_stmt|;
name|bitmap_set_bit
argument_list|(
name|global_types_seen
argument_list|,
name|TYPE_UID
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Return true if TYPE is one of the type classes that we are willing    to analyze.  This skips the goofy types like arrays of pointers to    methods. */
end_comment

begin_function
specifier|static
name|bool
name|type_to_consider
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
comment|/* Strip the *'s off.  */
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
while|while
condition|(
name|POINTER_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|BOOLEAN_TYPE
case|:
case|case
name|COMPLEX_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
case|case
name|INTEGER_TYPE
case|:
case|case
name|QUAL_UNION_TYPE
case|:
case|case
name|REAL_TYPE
case|:
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|VECTOR_TYPE
case|:
case|case
name|VOID_TYPE
case|:
return|return
name|true
return|;
default|default:
return|return
name|false
return|;
block|}
block|}
end_function

begin_comment
comment|/* Get the canon type of TYPE.  If SEE_THRU_PTRS is true, remove all    the POINTER_TOs and if SEE_THRU_ARRAYS is true, remove all of the    ARRAY_OFs and POINTER_TOs.  */
end_comment

begin_function
specifier|static
name|tree
name|get_canon_type
parameter_list|(
name|tree
name|type
parameter_list|,
name|bool
name|see_thru_ptrs
parameter_list|,
name|bool
name|see_thru_arrays
parameter_list|)
block|{
name|splay_tree_node
name|result
decl_stmt|;
comment|/* Strip the *'s off.  */
if|if
condition|(
operator|!
name|type
operator|||
operator|!
name|type_to_consider
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|NULL
return|;
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|see_thru_arrays
condition|)
while|while
condition|(
name|POINTER_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|see_thru_ptrs
condition|)
while|while
condition|(
name|POINTER_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|splay_tree_lookup
argument_list|(
name|type_to_canon_type
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
return|return
name|discover_unique_type
argument_list|(
name|type
argument_list|)
return|;
else|else
return|return
operator|(
name|tree
operator|)
name|result
operator|->
name|value
return|;
block|}
end_function

begin_comment
comment|/* Same as GET_CANON_TYPE, except return the TYPE_ID rather than the    TYPE.  */
end_comment

begin_function
specifier|static
name|int
name|get_canon_type_uid
parameter_list|(
name|tree
name|type
parameter_list|,
name|bool
name|see_thru_ptrs
parameter_list|,
name|bool
name|see_thru_arrays
parameter_list|)
block|{
name|type
operator|=
name|get_canon_type
argument_list|(
name|type
argument_list|,
name|see_thru_ptrs
argument_list|,
name|see_thru_arrays
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
condition|)
return|return
name|TYPE_UID
argument_list|(
name|type
argument_list|)
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 0 if TYPE is a record or union type.  Return a positive    number if TYPE is a pointer to a record or union.  The number is    the number of pointer types stripped to get to the record or union    type.  Return -1 if TYPE is none of the above.  */
end_comment

begin_function
name|int
name|ipa_type_escape_star_count_of_interesting_type
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
comment|/* Strip the *'s off.  */
if|if
condition|(
operator|!
name|type
condition|)
return|return
operator|-
literal|1
return|;
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
while|while
condition|(
name|POINTER_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
comment|/* We are interested in records, and unions only.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|QUAL_UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
condition|)
return|return
name|count
return|;
else|else
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return 0 if TYPE is a record or union type.  Return a positive    number if TYPE is a pointer to a record or union.  The number is    the number of pointer types stripped to get to the record or union    type.  Return -1 if TYPE is none of the above.  */
end_comment

begin_function
name|int
name|ipa_type_escape_star_count_of_interesting_or_array_type
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
comment|/* Strip the *'s off.  */
if|if
condition|(
operator|!
name|type
condition|)
return|return
operator|-
literal|1
return|;
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
while|while
condition|(
name|POINTER_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
comment|/* We are interested in records, and unions only.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|QUAL_UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
condition|)
return|return
name|count
return|;
else|else
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return true if the record, or union TYPE passed in escapes this    compilation unit. Note that all of the pointer-to's are removed    before testing since these may not be correct.  */
end_comment

begin_function
name|bool
name|ipa_type_escape_type_contained_p
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
if|if
condition|(
operator|!
name|initialized
condition|)
return|return
name|false
return|;
return|return
operator|!
name|bitmap_bit_p
argument_list|(
name|global_types_full_escape
argument_list|,
name|get_canon_type_uid
argument_list|(
name|type
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if a modification to a field of type FIELD_TYPE cannot    clobber a record of RECORD_TYPE.  */
end_comment

begin_function
name|bool
name|ipa_type_escape_field_does_not_clobber_p
parameter_list|(
name|tree
name|record_type
parameter_list|,
name|tree
name|field_type
parameter_list|)
block|{
name|splay_tree_node
name|result
decl_stmt|;
name|int
name|uid
decl_stmt|;
if|if
condition|(
operator|!
name|initialized
condition|)
return|return
name|false
return|;
comment|/* Strip off all of the pointer tos on the record type.  Strip the      same number of pointer tos from the field type.  If the field      type has fewer, it could not have been aliased. */
name|record_type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|record_type
argument_list|)
expr_stmt|;
name|field_type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|field_type
argument_list|)
expr_stmt|;
while|while
condition|(
name|POINTER_TYPE_P
argument_list|(
name|record_type
argument_list|)
condition|)
block|{
name|record_type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|record_type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|field_type
argument_list|)
condition|)
name|field_type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|field_type
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
comment|/* However, if field_type is a union, this quick test is not 	   correct since one of the variants of the union may be a 	   pointer to type and we cannot see across that here.  So we 	   just strip the remaining pointer tos off the record type 	   and fall thru to the more precise code.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field_type
argument_list|)
operator|==
name|QUAL_UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|field_type
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
while|while
condition|(
name|POINTER_TYPE_P
argument_list|(
name|record_type
argument_list|)
condition|)
name|record_type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|record_type
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
return|return
name|true
return|;
block|}
name|record_type
operator|=
name|get_canon_type
argument_list|(
name|record_type
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/* The record type must be contained.  The field type may      escape.  */
if|if
condition|(
operator|!
name|ipa_type_escape_type_contained_p
argument_list|(
name|record_type
argument_list|)
condition|)
return|return
name|false
return|;
name|uid
operator|=
name|TYPE_UID
argument_list|(
name|record_type
argument_list|)
expr_stmt|;
name|result
operator|=
name|splay_tree_lookup
argument_list|(
name|uid_to_addressof_down_map
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|uid
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
block|{
name|bitmap
name|field_type_map
init|=
operator|(
name|bitmap
operator|)
name|result
operator|->
name|value
decl_stmt|;
name|uid
operator|=
name|get_canon_type_uid
argument_list|(
name|field_type
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/* If the bit is there, the address was taken. If not, it 	 wasn't.  */
return|return
operator|!
name|bitmap_bit_p
argument_list|(
name|field_type_map
argument_list|,
name|uid
argument_list|)
return|;
block|}
else|else
comment|/* No bitmap means no addresses were taken.  */
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Add TYPE to the suspect type set. Return true if the bit needed to    be marked.  */
end_comment

begin_function
specifier|static
name|tree
name|mark_type
parameter_list|(
name|tree
name|type
parameter_list|,
name|enum
name|escape_t
name|escape_status
parameter_list|)
block|{
name|bitmap
name|map
init|=
name|NULL
decl_stmt|;
name|int
name|uid
decl_stmt|;
name|type
operator|=
name|get_canon_type
argument_list|(
name|type
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|type
condition|)
return|return
name|NULL
return|;
switch|switch
condition|(
name|escape_status
condition|)
block|{
case|case
name|EXPOSED_PARAMETER
case|:
name|map
operator|=
name|global_types_exposed_parameter
expr_stmt|;
break|break;
case|case
name|FULL_ESCAPE
case|:
name|map
operator|=
name|global_types_full_escape
expr_stmt|;
break|break;
block|}
name|uid
operator|=
name|TYPE_UID
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitmap_bit_p
argument_list|(
name|map
argument_list|,
name|uid
argument_list|)
condition|)
return|return
name|type
return|;
else|else
block|{
name|bitmap_set_bit
argument_list|(
name|map
argument_list|,
name|uid
argument_list|)
expr_stmt|;
if|if
condition|(
name|escape_status
operator|==
name|FULL_ESCAPE
condition|)
block|{
comment|/* Efficiency hack. When things are bad, do not mess around 	     with this type anymore.  */
name|bitmap_set_bit
argument_list|(
name|global_types_exposed_parameter
argument_list|,
name|uid
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Add interesting TYPE to the suspect type set. If the set is    EXPOSED_PARAMETER and the TYPE is a pointer type, the set is    changed to FULL_ESCAPE.  */
end_comment

begin_function
specifier|static
name|void
name|mark_interesting_type
parameter_list|(
name|tree
name|type
parameter_list|,
name|enum
name|escape_t
name|escape_status
parameter_list|)
block|{
if|if
condition|(
operator|!
name|type
condition|)
return|return;
if|if
condition|(
name|ipa_type_escape_star_count_of_interesting_type
argument_list|(
name|type
argument_list|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|escape_status
operator|==
name|EXPOSED_PARAMETER
operator|)
operator|&&
name|POINTER_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
comment|/* EXPOSED_PARAMETERs are only structs or unions are passed by 	   value.  Anything passed by reference to an external 	   function fully exposes the type.  */
name|mark_type
argument_list|(
name|type
argument_list|,
name|FULL_ESCAPE
argument_list|)
expr_stmt|;
else|else
name|mark_type
argument_list|(
name|type
argument_list|,
name|escape_status
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return true if PARENT is supertype of CHILD.  Both types must be    known to be structures or unions. */
end_comment

begin_function
specifier|static
name|bool
name|parent_type_p
parameter_list|(
name|tree
name|parent
parameter_list|,
name|tree
name|child
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|tree
name|binfo
decl_stmt|,
name|base_binfo
decl_stmt|;
if|if
condition|(
name|TYPE_BINFO
argument_list|(
name|parent
argument_list|)
condition|)
for|for
control|(
name|binfo
operator|=
name|TYPE_BINFO
argument_list|(
name|parent
argument_list|)
operator|,
name|i
operator|=
literal|0
init|;
name|BINFO_BASE_ITERATE
argument_list|(
name|binfo
argument_list|,
name|i
argument_list|,
name|base_binfo
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|binfotype
init|=
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|binfotype
operator|==
name|child
condition|)
return|return
name|true
return|;
elseif|else
if|if
condition|(
name|parent_type_p
argument_list|(
name|binfotype
argument_list|,
name|child
argument_list|)
condition|)
return|return
name|true
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parent
argument_list|)
operator|==
name|UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|parent
argument_list|)
operator|==
name|QUAL_UNION_TYPE
condition|)
block|{
name|tree
name|field
decl_stmt|;
comment|/* Search all of the variants in the union to see if one of them 	 is the child.  */
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|parent
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
block|{
name|tree
name|field_type
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
continue|continue;
name|field_type
operator|=
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
expr_stmt|;
if|if
condition|(
name|field_type
operator|==
name|child
condition|)
return|return
name|true
return|;
block|}
comment|/* If we did not find it, recursively ask the variants if one of 	 their children is the child type.  */
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|parent
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
block|{
name|tree
name|field_type
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
continue|continue;
name|field_type
operator|=
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field_type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|field_type
argument_list|)
operator|==
name|QUAL_UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|field_type
argument_list|)
operator|==
name|UNION_TYPE
condition|)
if|if
condition|(
name|parent_type_p
argument_list|(
name|field_type
argument_list|,
name|child
argument_list|)
condition|)
return|return
name|true
return|;
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parent
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
block|{
name|tree
name|field
decl_stmt|;
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|parent
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
block|{
name|tree
name|field_type
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
continue|continue;
name|field_type
operator|=
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
expr_stmt|;
if|if
condition|(
name|field_type
operator|==
name|child
condition|)
return|return
name|true
return|;
comment|/* You can only cast to the first field so if it does not 	     match, quit.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field_type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|field_type
argument_list|)
operator|==
name|QUAL_UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|field_type
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
if|if
condition|(
name|parent_type_p
argument_list|(
name|field_type
argument_list|,
name|child
argument_list|)
condition|)
return|return
name|true
return|;
else|else
break|break;
block|}
block|}
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Return the number of pointer tos for TYPE and return TYPE with all    of these stripped off.  */
end_comment

begin_function
specifier|static
name|int
name|count_stars
parameter_list|(
name|tree
modifier|*
name|type_ptr
parameter_list|)
block|{
name|tree
name|type
init|=
operator|*
name|type_ptr
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
while|while
condition|(
name|POINTER_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
operator|*
name|type_ptr
operator|=
name|type
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_enum
enum|enum
name|cast_type
block|{
name|CT_UP
block|,
name|CT_DOWN
block|,
name|CT_SIDEWAYS
block|,
name|CT_USELESS
block|}
enum|;
end_enum

begin_comment
comment|/* Check the cast FROM_TYPE to TO_TYPE.  This function requires that    the two types have already passed the    ipa_type_escape_star_count_of_interesting_type test.  */
end_comment

begin_function
specifier|static
name|enum
name|cast_type
name|check_cast_type
parameter_list|(
name|tree
name|to_type
parameter_list|,
name|tree
name|from_type
parameter_list|)
block|{
name|int
name|to_stars
init|=
name|count_stars
argument_list|(
operator|&
name|to_type
argument_list|)
decl_stmt|;
name|int
name|from_stars
init|=
name|count_stars
argument_list|(
operator|&
name|from_type
argument_list|)
decl_stmt|;
if|if
condition|(
name|to_stars
operator|!=
name|from_stars
condition|)
return|return
name|CT_SIDEWAYS
return|;
if|if
condition|(
name|to_type
operator|==
name|from_type
condition|)
return|return
name|CT_USELESS
return|;
if|if
condition|(
name|parent_type_p
argument_list|(
name|to_type
argument_list|,
name|from_type
argument_list|)
condition|)
return|return
name|CT_UP
return|;
if|if
condition|(
name|parent_type_p
argument_list|(
name|from_type
argument_list|,
name|to_type
argument_list|)
condition|)
return|return
name|CT_DOWN
return|;
return|return
name|CT_SIDEWAYS
return|;
block|}
end_function

begin_comment
comment|/* Check a cast FROM this variable, TO_TYPE.  Mark the escaping types    if appropriate.  */
end_comment

begin_function
specifier|static
name|void
name|check_cast
parameter_list|(
name|tree
name|to_type
parameter_list|,
name|tree
name|from
parameter_list|)
block|{
name|tree
name|from_type
init|=
name|get_canon_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|from
argument_list|)
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
decl_stmt|;
name|bool
name|to_interesting_type
decl_stmt|,
name|from_interesting_type
decl_stmt|;
name|to_type
operator|=
name|get_canon_type
argument_list|(
name|to_type
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|from_type
operator|||
operator|!
name|to_type
operator|||
name|from_type
operator|==
name|to_type
condition|)
return|return;
name|to_interesting_type
operator|=
name|ipa_type_escape_star_count_of_interesting_type
argument_list|(
name|to_type
argument_list|)
operator|>=
literal|0
expr_stmt|;
name|from_interesting_type
operator|=
name|ipa_type_escape_star_count_of_interesting_type
argument_list|(
name|from_type
argument_list|)
operator|>=
literal|0
expr_stmt|;
if|if
condition|(
name|to_interesting_type
condition|)
if|if
condition|(
name|from_interesting_type
condition|)
block|{
comment|/* Both types are interesting. This can be one of four types 	   of cast: useless, up, down, or sideways.  We do not care 	   about up or useless.  Sideways casts are always bad and 	   both sides get marked as escaping.  Downcasts are not 	   interesting here because if type is marked as escaping, all 	   of its subtypes escape.  */
switch|switch
condition|(
name|check_cast_type
argument_list|(
name|to_type
argument_list|,
name|from_type
argument_list|)
condition|)
block|{
case|case
name|CT_UP
case|:
case|case
name|CT_USELESS
case|:
case|case
name|CT_DOWN
case|:
break|break;
case|case
name|CT_SIDEWAYS
case|:
name|mark_type
argument_list|(
name|to_type
argument_list|,
name|FULL_ESCAPE
argument_list|)
expr_stmt|;
name|mark_type
argument_list|(
name|from_type
argument_list|,
name|FULL_ESCAPE
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* If this is a cast from the local that is a result from a 	   call to malloc, do not mark the cast as bad.  */
if|if
condition|(
name|DECL_P
argument_list|(
name|from
argument_list|)
operator|&&
operator|!
name|bitmap_bit_p
argument_list|(
name|results_of_malloc
argument_list|,
name|DECL_UID
argument_list|(
name|from
argument_list|)
argument_list|)
condition|)
name|mark_type
argument_list|(
name|to_type
argument_list|,
name|FULL_ESCAPE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|from_interesting_type
condition|)
name|mark_type
argument_list|(
name|from_type
argument_list|,
name|FULL_ESCAPE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Register the parameter and return types of function FN.  The type    ESCAPES if the function is visible outside of the compilation    unit.  */
end_comment

begin_function
specifier|static
name|void
name|check_function_parameter_and_return_types
parameter_list|(
name|tree
name|fn
parameter_list|,
name|bool
name|escapes
parameter_list|)
block|{
name|tree
name|arg
decl_stmt|;
if|if
condition|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
condition|)
block|{
for|for
control|(
name|arg
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
init|;
name|arg
operator|&&
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
operator|!=
name|void_type_node
condition|;
name|arg
operator|=
name|TREE_CHAIN
argument_list|(
name|arg
argument_list|)
control|)
block|{
name|tree
name|type
init|=
name|get_canon_type
argument_list|(
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|escapes
condition|)
name|mark_interesting_type
argument_list|(
name|type
argument_list|,
name|EXPOSED_PARAMETER
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* FIXME - According to Geoff Keating, we should never have to 	 do this; the front ends should always process the arg list 	 from the TYPE_ARG_LIST. However, Geoff is wrong, this code 	 does seem to be live.  */
for|for
control|(
name|arg
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|fn
argument_list|)
init|;
name|arg
condition|;
name|arg
operator|=
name|TREE_CHAIN
argument_list|(
name|arg
argument_list|)
control|)
block|{
name|tree
name|type
init|=
name|get_canon_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|escapes
condition|)
name|mark_interesting_type
argument_list|(
name|type
argument_list|,
name|EXPOSED_PARAMETER
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|escapes
condition|)
block|{
name|tree
name|type
init|=
name|get_canon_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
argument_list|)
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
decl_stmt|;
name|mark_interesting_type
argument_list|(
name|type
argument_list|,
name|EXPOSED_PARAMETER
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return true if the variable T is the right kind of static variable to    perform compilation unit scope escape analysis.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|has_proper_scope_for_analysis
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
comment|/* If the variable has the "used" attribute, treat it as if it had a      been touched by the devil.  */
name|tree
name|type
init|=
name|get_canon_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|type
condition|)
return|return;
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"used"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
block|{
name|mark_interesting_type
argument_list|(
name|type
argument_list|,
name|FULL_ESCAPE
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Do not want to do anything with volatile except mark any      function that uses one to be not const or pure.  */
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|t
argument_list|)
condition|)
return|return;
comment|/* Do not care about a local automatic that is not static.  */
if|if
condition|(
operator|!
name|TREE_STATIC
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|t
argument_list|)
condition|)
return|return;
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|t
argument_list|)
operator|||
name|TREE_PUBLIC
argument_list|(
name|t
argument_list|)
condition|)
block|{
comment|/* If the front end set the variable to be READONLY and 	 constant, we can allow this variable in pure or const 	 functions but the scope is too large for our analysis to set 	 these bits ourselves.  */
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|t
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
operator|&&
name|is_gimple_min_invariant
argument_list|(
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
empty_stmt|;
comment|/* Read of a constant, do not change the function state.  */
else|else
block|{
comment|/* The type escapes for all public and externs. */
name|mark_interesting_type
argument_list|(
name|type
argument_list|,
name|FULL_ESCAPE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* If T is a VAR_DECL for a static that we are interested in, add the    uid to the bitmap.  */
end_comment

begin_function
specifier|static
name|void
name|check_operand
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
if|if
condition|(
operator|!
name|t
condition|)
return|return;
comment|/* This is an assignment from a function, register the types as      escaping.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|check_function_parameter_and_return_types
argument_list|(
name|t
argument_list|,
name|true
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|has_proper_scope_for_analysis
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Examine tree T for references.   */
end_comment

begin_function
specifier|static
name|void
name|check_tree
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|EXC_PTR_EXPR
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FILTER_EXPR
operator|)
condition|)
return|return;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|REALPART_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|IMAGPART_EXPR
operator|||
name|handled_component_p
argument_list|(
name|t
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|ARRAY_REF
condition|)
name|check_operand
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|INDIRECT_REF_P
argument_list|(
name|t
argument_list|)
condition|)
comment|/*  || TREE_CODE (t) == MEM_REF) */
name|check_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SSA_VAR_P
argument_list|(
name|t
argument_list|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FUNCTION_DECL
operator|)
condition|)
name|check_operand
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create an address_of edge FROM_TYPE.TO_TYPE.  */
end_comment

begin_function
specifier|static
name|void
name|mark_interesting_addressof
parameter_list|(
name|tree
name|to_type
parameter_list|,
name|tree
name|from_type
parameter_list|)
block|{
name|int
name|from_uid
decl_stmt|;
name|int
name|to_uid
decl_stmt|;
name|bitmap
name|type_map
decl_stmt|;
name|splay_tree_node
name|result
decl_stmt|;
name|from_type
operator|=
name|get_canon_type
argument_list|(
name|from_type
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|to_type
operator|=
name|get_canon_type
argument_list|(
name|to_type
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|from_type
operator|||
operator|!
name|to_type
condition|)
return|return;
name|from_uid
operator|=
name|TYPE_UID
argument_list|(
name|from_type
argument_list|)
expr_stmt|;
name|to_uid
operator|=
name|TYPE_UID
argument_list|(
name|to_type
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|ipa_type_escape_star_count_of_interesting_type
argument_list|(
name|from_type
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* Process the Y into X map pointer.  */
name|result
operator|=
name|splay_tree_lookup
argument_list|(
name|uid_to_addressof_down_map
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|from_uid
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
name|type_map
operator|=
operator|(
name|bitmap
operator|)
name|result
operator|->
name|value
expr_stmt|;
else|else
block|{
name|type_map
operator|=
name|BITMAP_ALLOC
argument_list|(
operator|&
name|ipa_obstack
argument_list|)
expr_stmt|;
name|splay_tree_insert
argument_list|(
name|uid_to_addressof_down_map
argument_list|,
name|from_uid
argument_list|,
operator|(
name|splay_tree_value
operator|)
name|type_map
argument_list|)
expr_stmt|;
block|}
name|bitmap_set_bit
argument_list|(
name|type_map
argument_list|,
name|TYPE_UID
argument_list|(
name|to_type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Process the X into Y reverse map pointer.  */
name|result
operator|=
name|splay_tree_lookup
argument_list|(
name|uid_to_addressof_up_map
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|to_uid
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
name|type_map
operator|=
operator|(
name|bitmap
operator|)
name|result
operator|->
name|value
expr_stmt|;
else|else
block|{
name|type_map
operator|=
name|BITMAP_ALLOC
argument_list|(
operator|&
name|ipa_obstack
argument_list|)
expr_stmt|;
name|splay_tree_insert
argument_list|(
name|uid_to_addressof_up_map
argument_list|,
name|to_uid
argument_list|,
operator|(
name|splay_tree_value
operator|)
name|type_map
argument_list|)
expr_stmt|;
block|}
name|bitmap_set_bit
argument_list|(
name|type_map
argument_list|,
name|TYPE_UID
argument_list|(
name|to_type
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Scan tree T to see if there are any addresses taken in within T.  */
end_comment

begin_function
specifier|static
name|void
name|look_for_address_of
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
block|{
name|tree
name|x
init|=
name|get_base_var
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|tree
name|cref
init|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* If we have an expression of the form "&a.b.c.d", mark a.b, 	 b.c and c.d. as having its address taken.  */
name|tree
name|fielddecl
init|=
name|NULL_TREE
decl_stmt|;
while|while
condition|(
name|cref
operator|!=
name|x
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cref
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
block|{
name|fielddecl
operator|=
name|TREE_OPERAND
argument_list|(
name|cref
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mark_interesting_addressof
argument_list|(
name|TREE_TYPE
argument_list|(
name|fielddecl
argument_list|)
argument_list|,
name|DECL_FIELD_CONTEXT
argument_list|(
name|fielddecl
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cref
argument_list|)
operator|==
name|ARRAY_REF
condition|)
name|get_canon_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|cref
argument_list|)
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|cref
operator|=
name|TREE_OPERAND
argument_list|(
name|cref
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|has_proper_scope_for_analysis
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Scan tree T to see if there are any casts within it.    LHS Is the LHS of the expression involving the cast.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|look_for_casts
argument_list|(
name|tree
name|lhs
name|__attribute__
argument_list|(
operator|(
name|unused
operator|)
argument_list|)
argument_list|,
name|tree
name|t
argument_list|)
block|{
if|if
condition|(
name|is_gimple_cast
argument_list|(
name|t
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|VIEW_CONVERT_EXPR
condition|)
block|{
name|tree
name|castfromvar
init|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|check_cast
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|castfromvar
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|COMPONENT_REF
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|INDIRECT_REF
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|BIT_FIELD_REF
condition|)
block|{
name|tree
name|base
init|=
name|get_base_address
argument_list|(
name|t
argument_list|)
decl_stmt|;
while|while
condition|(
name|t
operator|!=
name|base
condition|)
block|{
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|VIEW_CONVERT_EXPR
condition|)
block|{
comment|/* This may be some part of a component ref. 		 IE it may be a.b.VIEW_CONVERT_EXPR<weird_type>(c).d, AFAIK. 		 castfromref will give you a.b.c, not a. */
name|tree
name|castfromref
init|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|check_cast
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|castfromref
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
name|get_canon_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_decl_stmt

begin_comment
comment|/* Check to see if T is a read or address of operation on a static var    we are interested in analyzing.  */
end_comment

begin_function
specifier|static
name|void
name|check_rhs_var
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|look_for_address_of
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|check_tree
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check to see if T is an assignment to a static var we are    interested in analyzing.  */
end_comment

begin_function
specifier|static
name|void
name|check_lhs_var
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|check_tree
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is a scaled down version of get_asm_expr_operands from    tree_ssa_operands.c.  The version there runs much later and assumes    that aliasing information is already available. Here we are just    trying to find if the set of inputs and outputs contain references    or address of operations to local.  FN is the function being    analyzed and STMT is the actual asm statement.  */
end_comment

begin_function
specifier|static
name|void
name|get_asm_expr_operands
parameter_list|(
name|tree
name|stmt
parameter_list|)
block|{
name|int
name|noutputs
init|=
name|list_length
argument_list|(
name|ASM_OUTPUTS
argument_list|(
name|stmt
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|oconstraints
init|=
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|noutputs
operator|)
operator|*
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|tree
name|link
decl_stmt|;
specifier|const
name|char
modifier|*
name|constraint
decl_stmt|;
name|bool
name|allows_mem
decl_stmt|,
name|allows_reg
decl_stmt|,
name|is_inout
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|link
operator|=
name|ASM_OUTPUTS
argument_list|(
name|stmt
argument_list|)
init|;
name|link
condition|;
operator|++
name|i
operator|,
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
block|{
name|oconstraints
index|[
name|i
index|]
operator|=
name|constraint
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|parse_output_constraint
argument_list|(
operator|&
name|constraint
argument_list|,
name|i
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|allows_mem
argument_list|,
operator|&
name|allows_reg
argument_list|,
operator|&
name|is_inout
argument_list|)
expr_stmt|;
name|check_lhs_var
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|link
operator|=
name|ASM_INPUTS
argument_list|(
name|stmt
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
block|{
name|constraint
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|parse_input_constraint
argument_list|(
operator|&
name|constraint
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|noutputs
argument_list|,
literal|0
argument_list|,
name|oconstraints
argument_list|,
operator|&
name|allows_mem
argument_list|,
operator|&
name|allows_reg
argument_list|)
expr_stmt|;
name|check_rhs_var
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* There is no code here to check for asm memory clobbers.  The      casual maintainer might think that such code would be necessary,      but that appears to be wrong.  In other parts of the compiler,      the asm memory clobbers are assumed to only clobber variables      that are addressable.  All types with addressable instances are      assumed to already escape.  So, we are protected here.  */
block|}
end_function

begin_comment
comment|/* Check the parameters of a function call to CALL_EXPR to mark the    types that pass across the function boundary.  Also check to see if    this is either an indirect call, a call outside the compilation    unit.  */
end_comment

begin_function
specifier|static
name|bool
name|check_call
parameter_list|(
name|tree
name|call_expr
parameter_list|)
block|{
name|int
name|flags
init|=
name|call_expr_flags
argument_list|(
name|call_expr
argument_list|)
decl_stmt|;
name|tree
name|operand_list
init|=
name|TREE_OPERAND
argument_list|(
name|call_expr
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|operand
decl_stmt|;
name|tree
name|callee_t
init|=
name|get_callee_fndecl
argument_list|(
name|call_expr
argument_list|)
decl_stmt|;
name|tree
name|argument
decl_stmt|;
name|struct
name|cgraph_node
modifier|*
name|callee
decl_stmt|;
name|enum
name|availability
name|avail
init|=
name|AVAIL_NOT_AVAILABLE
decl_stmt|;
for|for
control|(
name|operand
operator|=
name|operand_list
init|;
name|operand
operator|!=
name|NULL_TREE
condition|;
name|operand
operator|=
name|TREE_CHAIN
argument_list|(
name|operand
argument_list|)
control|)
block|{
name|tree
name|argument
init|=
name|TREE_VALUE
argument_list|(
name|operand
argument_list|)
decl_stmt|;
name|check_rhs_var
argument_list|(
name|argument
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|callee_t
condition|)
block|{
name|tree
name|arg_type
decl_stmt|;
name|tree
name|last_arg_type
init|=
name|NULL
decl_stmt|;
name|callee
operator|=
name|cgraph_node
argument_list|(
name|callee_t
argument_list|)
expr_stmt|;
name|avail
operator|=
name|cgraph_function_body_availability
argument_list|(
name|callee
argument_list|)
expr_stmt|;
comment|/* Check that there are no implicit casts in the passing of 	 parameters.  */
if|if
condition|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|callee_t
argument_list|)
argument_list|)
condition|)
block|{
name|operand
operator|=
name|operand_list
expr_stmt|;
for|for
control|(
name|arg_type
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|callee_t
argument_list|)
argument_list|)
init|;
name|arg_type
operator|&&
name|TREE_VALUE
argument_list|(
name|arg_type
argument_list|)
operator|!=
name|void_type_node
condition|;
name|arg_type
operator|=
name|TREE_CHAIN
argument_list|(
name|arg_type
argument_list|)
control|)
block|{
if|if
condition|(
name|operand
condition|)
block|{
name|argument
operator|=
name|TREE_VALUE
argument_list|(
name|operand
argument_list|)
expr_stmt|;
name|last_arg_type
operator|=
name|TREE_VALUE
argument_list|(
name|arg_type
argument_list|)
expr_stmt|;
name|check_cast
argument_list|(
name|last_arg_type
argument_list|,
name|argument
argument_list|)
expr_stmt|;
name|operand
operator|=
name|TREE_CHAIN
argument_list|(
name|operand
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* The code reaches here for some unfortunate 		   builtin functions that do not have a list of 		   argument types.  */
break|break;
block|}
block|}
else|else
block|{
comment|/* FIXME - According to Geoff Keating, we should never 	     have to do this; the front ends should always process 	     the arg list from the TYPE_ARG_LIST. */
name|operand
operator|=
name|operand_list
expr_stmt|;
for|for
control|(
name|arg_type
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|callee_t
argument_list|)
init|;
name|arg_type
condition|;
name|arg_type
operator|=
name|TREE_CHAIN
argument_list|(
name|arg_type
argument_list|)
control|)
block|{
if|if
condition|(
name|operand
condition|)
block|{
name|argument
operator|=
name|TREE_VALUE
argument_list|(
name|operand
argument_list|)
expr_stmt|;
name|last_arg_type
operator|=
name|TREE_TYPE
argument_list|(
name|arg_type
argument_list|)
expr_stmt|;
name|check_cast
argument_list|(
name|last_arg_type
argument_list|,
name|argument
argument_list|)
expr_stmt|;
name|operand
operator|=
name|TREE_CHAIN
argument_list|(
name|operand
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* The code reaches here for some unfortunate 		   builtin functions that do not have a list of 		   argument types.  */
break|break;
block|}
block|}
comment|/* In the case where we have a var_args function, we need to 	 check the remaining parameters against the last argument.  */
name|arg_type
operator|=
name|last_arg_type
expr_stmt|;
for|for
control|(
init|;
name|operand
operator|!=
name|NULL_TREE
condition|;
name|operand
operator|=
name|TREE_CHAIN
argument_list|(
name|operand
argument_list|)
control|)
block|{
name|argument
operator|=
name|TREE_VALUE
argument_list|(
name|operand
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg_type
condition|)
name|check_cast
argument_list|(
name|arg_type
argument_list|,
name|argument
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* The code reaches here for some unfortunate 		 builtin functions that do not have a list of 		 argument types.  Most of these functions have 		 been marked as having their parameters not 		 escape, but for the rest, the type is doomed.  */
name|tree
name|type
init|=
name|get_canon_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|argument
argument_list|)
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
decl_stmt|;
name|mark_interesting_type
argument_list|(
name|type
argument_list|,
name|FULL_ESCAPE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* The callee is either unknown (indirect call) or there is just no      scannable code for it (external call) .  We look to see if there      are any bits available for the callee (such as by declaration or      because it is builtin) and process solely on the basis of those      bits. */
if|if
condition|(
name|avail
operator|==
name|AVAIL_NOT_AVAILABLE
operator|||
name|avail
operator|==
name|AVAIL_OVERWRITABLE
condition|)
block|{
comment|/* If this is a direct call to an external function, mark all of 	 the parameter and return types.  */
for|for
control|(
name|operand
operator|=
name|operand_list
init|;
name|operand
operator|!=
name|NULL_TREE
condition|;
name|operand
operator|=
name|TREE_CHAIN
argument_list|(
name|operand
argument_list|)
control|)
block|{
name|tree
name|type
init|=
name|get_canon_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|operand
argument_list|)
argument_list|)
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
decl_stmt|;
name|mark_interesting_type
argument_list|(
name|type
argument_list|,
name|EXPOSED_PARAMETER
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|callee_t
condition|)
block|{
name|tree
name|type
init|=
name|get_canon_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|callee_t
argument_list|)
argument_list|)
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
decl_stmt|;
name|mark_interesting_type
argument_list|(
name|type
argument_list|,
name|EXPOSED_PARAMETER
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|flags
operator|&
name|ECF_MALLOC
operator|)
return|;
block|}
end_function

begin_comment
comment|/* CODE is the operation on OP0 and OP1.  OP0 is the operand that we    *know* is a pointer type.  OP1 may be a pointer type.  */
end_comment

begin_function
specifier|static
name|bool
name|okay_pointer_operation
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|op0
parameter_list|,
name|tree
name|op1
parameter_list|)
block|{
name|tree
name|op0type
init|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|op1type
init|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|op1type
argument_list|)
condition|)
return|return
name|false
return|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|MULT_EXPR
case|:
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
comment|/* TODO: Handle multiples of op0 size as well */
if|if
condition|(
name|operand_equal_p
argument_list|(
name|size_in_bytes
argument_list|(
name|op0type
argument_list|)
argument_list|,
name|op1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* fallthrough */
default|default:
return|return
name|false
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* TP is the part of the tree currently under the microscope.    WALK_SUBTREES is part of the walk_tree api but is unused here.    DATA is cgraph_node of the function being walked.  */
end_comment

begin_comment
comment|/* FIXME: When this is converted to run over SSA form, this code    should be converted to use the operand scanner.  */
end_comment

begin_function
specifier|static
name|tree
name|scan_for_refs
parameter_list|(
name|tree
modifier|*
name|tp
parameter_list|,
name|int
modifier|*
name|walk_subtrees
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|cgraph_node
modifier|*
name|fn
init|=
name|data
decl_stmt|;
name|tree
name|t
init|=
operator|*
name|tp
decl_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|VAR_DECL
case|:
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
condition|)
name|walk_tree
argument_list|(
operator|&
name|DECL_INITIAL
argument_list|(
name|t
argument_list|)
argument_list|,
name|scan_for_refs
argument_list|,
name|fn
argument_list|,
name|visited_nodes
argument_list|)
expr_stmt|;
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|MODIFY_EXPR
case|:
block|{
comment|/* First look on the lhs and see what variable is stored to */
name|tree
name|lhs
init|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|rhs
init|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|check_lhs_var
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
name|check_cast
argument_list|(
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
comment|/* For the purposes of figuring out what the cast affects */
comment|/* Next check the operands on the rhs to see if they are ok. */
switch|switch
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|tcc_binary
case|:
block|{
name|tree
name|op0
init|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|type0
init|=
name|get_canon_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
decl_stmt|;
name|tree
name|op1
init|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|type1
init|=
name|get_canon_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
decl_stmt|;
comment|/* If this is pointer arithmetic of any bad sort, then  		 we need to mark the types as bad.  For binary  		 operations, no binary operator we currently support  		 is always "safe" in regard to what it would do to  		 pointers for purposes of determining which types  		 escape, except operations of the size of the type.  		 It is possible that min and max under the right set  		 of circumstances and if the moon is in the correct  		 place could be safe, but it is hard to see how this  		 is worth the effort.  */
if|if
condition|(
name|type0
operator|&&
name|POINTER_TYPE_P
argument_list|(
name|type0
argument_list|)
operator|&&
operator|!
name|okay_pointer_operation
argument_list|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
condition|)
name|mark_interesting_type
argument_list|(
name|type0
argument_list|,
name|FULL_ESCAPE
argument_list|)
expr_stmt|;
if|if
condition|(
name|type1
operator|&&
name|POINTER_TYPE_P
argument_list|(
name|type1
argument_list|)
operator|&&
operator|!
name|okay_pointer_operation
argument_list|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
argument_list|,
name|op1
argument_list|,
name|op0
argument_list|)
condition|)
name|mark_interesting_type
argument_list|(
name|type1
argument_list|,
name|FULL_ESCAPE
argument_list|)
expr_stmt|;
name|look_for_casts
argument_list|(
name|lhs
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|look_for_casts
argument_list|(
name|lhs
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|check_rhs_var
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|check_rhs_var
argument_list|(
name|op1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|tcc_unary
case|:
block|{
name|tree
name|op0
init|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|type0
init|=
name|get_canon_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
decl_stmt|;
comment|/* For unary operations, if the operation is NEGATE or 		 ABS on a pointer, this is also considered pointer 		 arithmetic and thus, bad for business.  */
if|if
condition|(
name|type0
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|NEGATE_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|ABS_EXPR
operator|)
operator|&&
name|POINTER_TYPE_P
argument_list|(
name|type0
argument_list|)
condition|)
block|{
name|mark_interesting_type
argument_list|(
name|type0
argument_list|,
name|FULL_ESCAPE
argument_list|)
expr_stmt|;
block|}
name|check_rhs_var
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|look_for_casts
argument_list|(
name|lhs
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|look_for_casts
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|tcc_reference
case|:
name|look_for_casts
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
name|check_rhs_var
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
break|break;
case|case
name|tcc_declaration
case|:
name|check_rhs_var
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
break|break;
case|case
name|tcc_expression
case|:
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
condition|)
block|{
case|case
name|ADDR_EXPR
case|:
name|look_for_casts
argument_list|(
name|lhs
argument_list|,
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|check_rhs_var
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
break|break;
case|case
name|CALL_EXPR
case|:
comment|/* If this is a call to malloc, squirrel away the 		   result so we do mark the resulting cast as being 		   bad.  */
if|if
condition|(
name|check_call
argument_list|(
name|rhs
argument_list|)
condition|)
name|bitmap_set_bit
argument_list|(
name|results_of_malloc
argument_list|,
name|DECL_UID
argument_list|(
name|lhs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
default|default:
break|break;
block|}
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|ADDR_EXPR
case|:
comment|/* This case is here to find addresses on rhs of constructors in 	 decl_initial of static variables. */
name|check_rhs_var
argument_list|(
name|t
argument_list|)
expr_stmt|;
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|CALL_EXPR
case|:
name|check_call
argument_list|(
name|t
argument_list|)
expr_stmt|;
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ASM_EXPR
case|:
name|get_asm_expr_operands
argument_list|(
name|t
argument_list|)
expr_stmt|;
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* The init routine for analyzing global static variable usage.  See    comments at top for description.  */
end_comment

begin_function
specifier|static
name|void
name|ipa_init
parameter_list|(
name|void
parameter_list|)
block|{
name|bitmap_obstack_initialize
argument_list|(
operator|&
name|ipa_obstack
argument_list|)
expr_stmt|;
name|global_types_exposed_parameter
operator|=
name|BITMAP_ALLOC
argument_list|(
operator|&
name|ipa_obstack
argument_list|)
expr_stmt|;
name|global_types_full_escape
operator|=
name|BITMAP_ALLOC
argument_list|(
operator|&
name|ipa_obstack
argument_list|)
expr_stmt|;
name|global_types_seen
operator|=
name|BITMAP_ALLOC
argument_list|(
operator|&
name|ipa_obstack
argument_list|)
expr_stmt|;
name|results_of_malloc
operator|=
name|BITMAP_ALLOC
argument_list|(
operator|&
name|ipa_obstack
argument_list|)
expr_stmt|;
name|uid_to_canon_type
operator|=
name|splay_tree_new
argument_list|(
name|splay_tree_compare_ints
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|all_canon_types
operator|=
name|splay_tree_new
argument_list|(
name|compare_type_brand
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|type_to_canon_type
operator|=
name|splay_tree_new
argument_list|(
name|splay_tree_compare_pointers
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|uid_to_subtype_map
operator|=
name|splay_tree_new
argument_list|(
name|splay_tree_compare_ints
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|uid_to_addressof_down_map
operator|=
name|splay_tree_new
argument_list|(
name|splay_tree_compare_ints
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|uid_to_addressof_up_map
operator|=
name|splay_tree_new
argument_list|(
name|splay_tree_compare_ints
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* There are some shared nodes, in particular the initializers on      static declarations.  We do not need to scan them more than once      since all we would be interested in are the addressof      operations.  */
name|visited_nodes
operator|=
name|pointer_set_create
argument_list|()
expr_stmt|;
name|initialized
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check out the rhs of a static or global initialization VNODE to see    if any of them contain addressof operations.  Note that some of    these variables may  not even be referenced in the code in this    compilation unit but their right hand sides may contain references    to variables defined within this unit.  */
end_comment

begin_function
specifier|static
name|void
name|analyze_variable
parameter_list|(
name|struct
name|cgraph_varpool_node
modifier|*
name|vnode
parameter_list|)
block|{
name|tree
name|global
init|=
name|vnode
operator|->
name|decl
decl_stmt|;
name|tree
name|type
init|=
name|get_canon_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|global
argument_list|)
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
decl_stmt|;
comment|/* If this variable has exposure beyond the compilation unit, add      its type to the global types.  */
if|if
condition|(
name|vnode
operator|->
name|externally_visible
condition|)
name|mark_interesting_type
argument_list|(
name|type
argument_list|,
name|FULL_ESCAPE
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|global
argument_list|)
operator|==
name|VAR_DECL
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|global
argument_list|)
condition|)
name|walk_tree
argument_list|(
operator|&
name|DECL_INITIAL
argument_list|(
name|global
argument_list|)
argument_list|,
name|scan_for_refs
argument_list|,
name|NULL
argument_list|,
name|visited_nodes
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is the main routine for finding the reference patterns for    global variables within a function FN.  */
end_comment

begin_function
specifier|static
name|void
name|analyze_function
parameter_list|(
name|struct
name|cgraph_node
modifier|*
name|fn
parameter_list|)
block|{
name|tree
name|decl
init|=
name|fn
operator|->
name|decl
decl_stmt|;
name|check_function_parameter_and_return_types
argument_list|(
name|decl
argument_list|,
name|fn
operator|->
name|local
operator|.
name|externally_visible
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n local analysis of %s"
argument_list|,
name|cgraph_node_name
argument_list|(
name|fn
argument_list|)
argument_list|)
expr_stmt|;
block|{
name|struct
name|function
modifier|*
name|this_cfun
init|=
name|DECL_STRUCT_FUNCTION
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|basic_block
name|this_block
decl_stmt|;
name|FOR_EACH_BB_FN
argument_list|(
argument|this_block
argument_list|,
argument|this_cfun
argument_list|)
block|{
name|block_stmt_iterator
name|bsi
decl_stmt|;
for|for
control|(
name|bsi
operator|=
name|bsi_start
argument_list|(
name|this_block
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
name|walk_tree
argument_list|(
name|bsi_stmt_ptr
argument_list|(
name|bsi
argument_list|)
argument_list|,
name|scan_for_refs
argument_list|,
name|fn
argument_list|,
name|visited_nodes
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* There may be const decls with interesting right hand sides.  */
if|if
condition|(
name|DECL_STRUCT_FUNCTION
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|tree
name|step
decl_stmt|;
for|for
control|(
name|step
operator|=
name|DECL_STRUCT_FUNCTION
argument_list|(
name|decl
argument_list|)
operator|->
name|unexpanded_var_list
init|;
name|step
condition|;
name|step
operator|=
name|TREE_CHAIN
argument_list|(
name|step
argument_list|)
control|)
block|{
name|tree
name|var
init|=
name|TREE_VALUE
argument_list|(
name|step
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|var
argument_list|)
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
name|var
argument_list|)
condition|)
name|walk_tree
argument_list|(
operator|&
name|DECL_INITIAL
argument_list|(
name|var
argument_list|)
argument_list|,
name|scan_for_refs
argument_list|,
name|fn
argument_list|,
name|visited_nodes
argument_list|)
expr_stmt|;
name|get_canon_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|var
argument_list|)
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Convert a type_UID into a type.  */
end_comment

begin_function
specifier|static
name|tree
name|type_for_uid
parameter_list|(
name|int
name|uid
parameter_list|)
block|{
name|splay_tree_node
name|result
init|=
name|splay_tree_lookup
argument_list|(
name|uid_to_canon_type
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|uid
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
condition|)
return|return
operator|(
name|tree
operator|)
name|result
operator|->
name|value
return|;
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Return the a bitmap with the subtypes of the type for UID.  If it    does not exist, return either NULL or a new bitmap depending on the    value of CREATE.  */
end_comment

begin_function
specifier|static
name|bitmap
name|subtype_map_for_uid
parameter_list|(
name|int
name|uid
parameter_list|,
name|bool
name|create
parameter_list|)
block|{
name|splay_tree_node
name|result
init|=
name|splay_tree_lookup
argument_list|(
name|uid_to_subtype_map
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|uid
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
condition|)
return|return
operator|(
name|bitmap
operator|)
name|result
operator|->
name|value
return|;
elseif|else
if|if
condition|(
name|create
condition|)
block|{
name|bitmap
name|subtype_map
init|=
name|BITMAP_ALLOC
argument_list|(
operator|&
name|ipa_obstack
argument_list|)
decl_stmt|;
name|splay_tree_insert
argument_list|(
name|uid_to_subtype_map
argument_list|,
name|uid
argument_list|,
operator|(
name|splay_tree_value
operator|)
name|subtype_map
argument_list|)
expr_stmt|;
return|return
name|subtype_map
return|;
block|}
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Mark all of the supertypes and field types of TYPE as being seen.    Also accumulate the subtypes for each type so that    close_types_full_escape can mark a subtype as escaping if the    supertype escapes.  */
end_comment

begin_function
specifier|static
name|void
name|close_type_seen
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|tree
name|field
decl_stmt|;
name|int
name|i
decl_stmt|,
name|uid
decl_stmt|;
name|tree
name|binfo
decl_stmt|,
name|base_binfo
decl_stmt|;
comment|/* See thru all pointer tos and array ofs. */
name|type
operator|=
name|get_canon_type
argument_list|(
name|type
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|type
condition|)
return|return;
name|uid
operator|=
name|TYPE_UID
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitmap_bit_p
argument_list|(
name|been_there_done_that
argument_list|,
name|uid
argument_list|)
condition|)
return|return;
name|bitmap_set_bit
argument_list|(
name|been_there_done_that
argument_list|,
name|uid
argument_list|)
expr_stmt|;
comment|/* If we are doing a language with a type hierarchy, mark all of      the superclasses.  */
if|if
condition|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
condition|)
for|for
control|(
name|binfo
operator|=
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
operator|,
name|i
operator|=
literal|0
init|;
name|BINFO_BASE_ITERATE
argument_list|(
name|binfo
argument_list|,
name|i
argument_list|,
name|base_binfo
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|binfo_type
init|=
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
decl_stmt|;
name|bitmap
name|subtype_map
init|=
name|subtype_map_for_uid
argument_list|(
name|TYPE_UID
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|binfo_type
argument_list|)
argument_list|)
argument_list|,
name|true
argument_list|)
decl_stmt|;
name|bitmap_set_bit
argument_list|(
name|subtype_map
argument_list|,
name|uid
argument_list|)
expr_stmt|;
name|close_type_seen
argument_list|(
name|get_canon_type
argument_list|(
name|binfo_type
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If the field is a struct or union type, mark all of the      subfields.  */
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
block|{
name|tree
name|field_type
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
continue|continue;
name|field_type
operator|=
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
expr_stmt|;
if|if
condition|(
name|ipa_type_escape_star_count_of_interesting_or_array_type
argument_list|(
name|field_type
argument_list|)
operator|>=
literal|0
condition|)
name|close_type_seen
argument_list|(
name|get_canon_type
argument_list|(
name|field_type
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Take a TYPE that has been passed by value to an external function    and mark all of the fields that have pointer types as escaping. For    any of the non pointer types that are structures or unions,    recurse.  TYPE is never a pointer type.  */
end_comment

begin_function
specifier|static
name|void
name|close_type_exposed_parameter
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|tree
name|field
decl_stmt|;
name|int
name|uid
decl_stmt|;
name|type
operator|=
name|get_canon_type
argument_list|(
name|type
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|type
condition|)
return|return;
name|uid
operator|=
name|TYPE_UID
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|POINTER_TYPE_P
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitmap_bit_p
argument_list|(
name|been_there_done_that
argument_list|,
name|uid
argument_list|)
condition|)
return|return;
name|bitmap_set_bit
argument_list|(
name|been_there_done_that
argument_list|,
name|uid
argument_list|)
expr_stmt|;
comment|/* If the field is a struct or union type, mark all of the      subfields.  */
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
block|{
name|tree
name|field_type
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
continue|continue;
name|field_type
operator|=
name|get_canon_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|mark_interesting_type
argument_list|(
name|field_type
argument_list|,
name|EXPOSED_PARAMETER
argument_list|)
expr_stmt|;
comment|/* Only recurse for non pointer types of structures and unions.  */
if|if
condition|(
name|ipa_type_escape_star_count_of_interesting_type
argument_list|(
name|field_type
argument_list|)
operator|==
literal|0
condition|)
name|close_type_exposed_parameter
argument_list|(
name|field_type
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The next function handles the case where a type fully escapes.    This means that not only does the type itself escape,      a) the type of every field recursively escapes    b) the type of every subtype escapes as well as the super as well    as all of the pointer to types for each field.     Note that pointer to types are not marked as escaping.  If the    pointed to type escapes, the pointer to type also escapes.     Take a TYPE that has had the address taken for an instance of it    and mark all of the types for its fields as having their addresses    taken. */
end_comment

begin_function
specifier|static
name|void
name|close_type_full_escape
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|tree
name|field
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|int
name|uid
decl_stmt|;
name|tree
name|binfo
decl_stmt|,
name|base_binfo
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|bitmap
name|subtype_map
decl_stmt|;
name|splay_tree_node
name|address_result
decl_stmt|;
comment|/* Strip off any pointer or array types.  */
name|type
operator|=
name|get_canon_type
argument_list|(
name|type
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|type
condition|)
return|return;
name|uid
operator|=
name|TYPE_UID
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitmap_bit_p
argument_list|(
name|been_there_done_that
argument_list|,
name|uid
argument_list|)
condition|)
return|return;
name|bitmap_set_bit
argument_list|(
name|been_there_done_that
argument_list|,
name|uid
argument_list|)
expr_stmt|;
name|subtype_map
operator|=
name|subtype_map_for_uid
argument_list|(
name|uid
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* If we are doing a language with a type hierarchy, mark all of      the superclasses.  */
if|if
condition|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
condition|)
for|for
control|(
name|binfo
operator|=
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
operator|,
name|i
operator|=
literal|0
init|;
name|BINFO_BASE_ITERATE
argument_list|(
name|binfo
argument_list|,
name|i
argument_list|,
name|base_binfo
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|binfotype
init|=
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
decl_stmt|;
name|binfotype
operator|=
name|mark_type
argument_list|(
name|binfotype
argument_list|,
name|FULL_ESCAPE
argument_list|)
expr_stmt|;
name|close_type_full_escape
argument_list|(
name|binfotype
argument_list|)
expr_stmt|;
block|}
comment|/* Mark as escaped any types that have been down casted to      this type. */
if|if
condition|(
name|subtype_map
condition|)
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|subtype_map
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
block|{
name|tree
name|subtype
init|=
name|type_for_uid
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|subtype
operator|=
name|mark_type
argument_list|(
name|subtype
argument_list|,
name|FULL_ESCAPE
argument_list|)
expr_stmt|;
name|close_type_full_escape
argument_list|(
name|subtype
argument_list|)
expr_stmt|;
block|}
comment|/* If the field is a struct or union type, mark all of the      subfields.  */
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
block|{
name|tree
name|field_type
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
continue|continue;
name|field_type
operator|=
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
expr_stmt|;
if|if
condition|(
name|ipa_type_escape_star_count_of_interesting_or_array_type
argument_list|(
name|field_type
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|field_type
operator|=
name|mark_type
argument_list|(
name|field_type
argument_list|,
name|FULL_ESCAPE
argument_list|)
expr_stmt|;
name|close_type_full_escape
argument_list|(
name|field_type
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* For all of the types A that contain this type B and were part of      an expression like "&...A.B...", mark the A's as escaping.  */
name|address_result
operator|=
name|splay_tree_lookup
argument_list|(
name|uid_to_addressof_up_map
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|uid
argument_list|)
expr_stmt|;
if|if
condition|(
name|address_result
condition|)
block|{
name|bitmap
name|containing_classes
init|=
operator|(
name|bitmap
operator|)
name|address_result
operator|->
name|value
decl_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|containing_classes
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
block|{
name|close_type_full_escape
argument_list|(
name|type_for_uid
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Transitively close the addressof bitmap for the type with UID.    This means that if we had a.b and b.c, a would have both b and c in    its maps.  */
end_comment

begin_function
specifier|static
name|bitmap
name|close_addressof_down
parameter_list|(
name|int
name|uid
parameter_list|)
block|{
name|bitmap_iterator
name|bi
decl_stmt|;
name|splay_tree_node
name|result
init|=
name|splay_tree_lookup
argument_list|(
name|uid_to_addressof_down_map
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|uid
argument_list|)
decl_stmt|;
name|bitmap
name|map
init|=
name|NULL
decl_stmt|;
name|bitmap
name|new_map
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
name|result
condition|)
name|map
operator|=
operator|(
name|bitmap
operator|)
name|result
operator|->
name|value
expr_stmt|;
else|else
return|return
name|NULL
return|;
if|if
condition|(
name|bitmap_bit_p
argument_list|(
name|been_there_done_that
argument_list|,
name|uid
argument_list|)
condition|)
return|return
name|map
return|;
name|bitmap_set_bit
argument_list|(
name|been_there_done_that
argument_list|,
name|uid
argument_list|)
expr_stmt|;
comment|/* If the type escapes, get rid of the addressof map, it will not be      needed.  */
if|if
condition|(
name|bitmap_bit_p
argument_list|(
name|global_types_full_escape
argument_list|,
name|uid
argument_list|)
condition|)
block|{
name|BITMAP_FREE
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|splay_tree_remove
argument_list|(
name|uid_to_addressof_down_map
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|uid
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* The new_map will have all of the bits for the enclosed fields and      will have the unique id version of the old map.  */
name|new_map
operator|=
name|BITMAP_ALLOC
argument_list|(
operator|&
name|ipa_obstack
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|map
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
block|{
name|bitmap
name|submap
init|=
name|close_addressof_down
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|bitmap_set_bit
argument_list|(
name|new_map
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|submap
condition|)
name|bitmap_ior_into
argument_list|(
name|new_map
argument_list|,
name|submap
argument_list|)
expr_stmt|;
block|}
name|result
operator|->
name|value
operator|=
operator|(
name|splay_tree_value
operator|)
name|new_map
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|map
argument_list|)
expr_stmt|;
return|return
name|new_map
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The main entry point for type escape analysis.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|type_escape_execute
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cgraph_node
modifier|*
name|node
decl_stmt|;
name|struct
name|cgraph_varpool_node
modifier|*
name|vnode
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|splay_tree_node
name|result
decl_stmt|;
name|ipa_init
argument_list|()
expr_stmt|;
comment|/* Process all of the variables first.  */
for|for
control|(
name|vnode
operator|=
name|cgraph_varpool_nodes_queue
init|;
name|vnode
condition|;
name|vnode
operator|=
name|vnode
operator|->
name|next_needed
control|)
name|analyze_variable
argument_list|(
name|vnode
argument_list|)
expr_stmt|;
comment|/* Process all of the functions. next       We do not want to process any of the clones so we check that this      is a master clone.  However, we do need to process any      AVAIL_OVERWRITABLE functions (these are never clones) because      they may cause a type variable to escape.     */
for|for
control|(
name|node
operator|=
name|cgraph_nodes
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
if|if
condition|(
name|node
operator|->
name|analyzed
operator|&&
operator|(
name|cgraph_is_master_clone
argument_list|(
name|node
argument_list|)
operator|||
operator|(
name|cgraph_function_body_availability
argument_list|(
name|node
argument_list|)
operator|==
name|AVAIL_OVERWRITABLE
operator|)
operator|)
condition|)
name|analyze_function
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|pointer_set_destroy
argument_list|(
name|visited_nodes
argument_list|)
expr_stmt|;
name|visited_nodes
operator|=
name|NULL
expr_stmt|;
comment|/* Do all of the closures to discover which types escape the      compilation unit.  */
name|been_there_done_that
operator|=
name|BITMAP_ALLOC
argument_list|(
operator|&
name|ipa_obstack
argument_list|)
expr_stmt|;
name|bitmap_tmp
operator|=
name|BITMAP_ALLOC
argument_list|(
operator|&
name|ipa_obstack
argument_list|)
expr_stmt|;
comment|/* Examine the types that we have directly seen in scanning the code      and add to that any contained types or superclasses.  */
name|bitmap_copy
argument_list|(
name|bitmap_tmp
argument_list|,
name|global_types_seen
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|bitmap_tmp
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
block|{
name|tree
name|type
init|=
name|type_for_uid
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|/* Only look at records and unions and pointer tos.  */
if|if
condition|(
name|ipa_type_escape_star_count_of_interesting_or_array_type
argument_list|(
name|type
argument_list|)
operator|>=
literal|0
condition|)
name|close_type_seen
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
name|bitmap_clear
argument_list|(
name|been_there_done_that
argument_list|)
expr_stmt|;
comment|/* Examine all of the types passed by value and mark any enclosed      pointer types as escaping.  */
name|bitmap_copy
argument_list|(
name|bitmap_tmp
argument_list|,
name|global_types_exposed_parameter
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|bitmap_tmp
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
block|{
name|close_type_exposed_parameter
argument_list|(
name|type_for_uid
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|bitmap_clear
argument_list|(
name|been_there_done_that
argument_list|)
expr_stmt|;
comment|/* Close the types for escape.  If something escapes, then any      enclosed types escape as well as any subtypes.  */
name|bitmap_copy
argument_list|(
name|bitmap_tmp
argument_list|,
name|global_types_full_escape
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|bitmap_tmp
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
block|{
name|close_type_full_escape
argument_list|(
name|type_for_uid
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|bitmap_clear
argument_list|(
name|been_there_done_that
argument_list|)
expr_stmt|;
comment|/* Before this pass, the uid_to_addressof_down_map for type X      contained an entry for Y if there had been an operation of the      form&X.Y.  This step adds all of the fields contained within Y      (recursively) to X's map.  */
name|result
operator|=
name|splay_tree_min
argument_list|(
name|uid_to_addressof_down_map
argument_list|)
expr_stmt|;
while|while
condition|(
name|result
condition|)
block|{
name|int
name|uid
init|=
name|result
operator|->
name|key
decl_stmt|;
comment|/* Close the addressof map, i.e. copy all of the transitive 	 substructures up to this level.  */
name|close_addressof_down
argument_list|(
name|uid
argument_list|)
expr_stmt|;
name|result
operator|=
name|splay_tree_successor
argument_list|(
name|uid_to_addressof_down_map
argument_list|,
name|uid
argument_list|)
expr_stmt|;
block|}
comment|/* Do not need the array types and pointer types in the persistent      data structures.  */
name|result
operator|=
name|splay_tree_min
argument_list|(
name|all_canon_types
argument_list|)
expr_stmt|;
while|while
condition|(
name|result
condition|)
block|{
name|tree
name|type
init|=
operator|(
name|tree
operator|)
name|result
operator|->
name|value
decl_stmt|;
name|tree
name|key
init|=
operator|(
name|tree
operator|)
name|result
operator|->
name|key
decl_stmt|;
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|splay_tree_remove
argument_list|(
name|all_canon_types
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|result
operator|->
name|key
argument_list|)
expr_stmt|;
name|splay_tree_remove
argument_list|(
name|type_to_canon_type
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|type
argument_list|)
expr_stmt|;
name|splay_tree_remove
argument_list|(
name|uid_to_canon_type
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|TYPE_UID
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|bitmap_clear_bit
argument_list|(
name|global_types_seen
argument_list|,
name|TYPE_UID
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|splay_tree_successor
argument_list|(
name|all_canon_types
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|key
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dump_file
condition|)
block|{
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|global_types_seen
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
block|{
comment|/* The pointer types are in the global_types_full_escape 	     bitmap but not in the backwards map.  They also contain 	     no useful information since they are not marked.  */
name|tree
name|type
init|=
name|type_for_uid
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"type %d "
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitmap_bit_p
argument_list|(
name|global_types_full_escape
argument_list|,
name|i
argument_list|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|" escaped\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|" contained\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Get rid of uid_to_addressof_up_map and its bitmaps.  */
name|result
operator|=
name|splay_tree_min
argument_list|(
name|uid_to_addressof_up_map
argument_list|)
expr_stmt|;
while|while
condition|(
name|result
condition|)
block|{
name|int
name|uid
init|=
operator|(
name|int
operator|)
name|result
operator|->
name|key
decl_stmt|;
name|bitmap
name|bm
init|=
operator|(
name|bitmap
operator|)
name|result
operator|->
name|value
decl_stmt|;
name|BITMAP_FREE
argument_list|(
name|bm
argument_list|)
expr_stmt|;
name|splay_tree_remove
argument_list|(
name|uid_to_addressof_up_map
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|uid
argument_list|)
expr_stmt|;
name|result
operator|=
name|splay_tree_successor
argument_list|(
name|uid_to_addressof_up_map
argument_list|,
name|uid
argument_list|)
expr_stmt|;
block|}
comment|/* Get rid of the subtype map.  */
name|result
operator|=
name|splay_tree_min
argument_list|(
name|uid_to_subtype_map
argument_list|)
expr_stmt|;
while|while
condition|(
name|result
condition|)
block|{
name|bitmap
name|b
init|=
operator|(
name|bitmap
operator|)
name|result
operator|->
name|value
decl_stmt|;
name|BITMAP_FREE
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|splay_tree_remove
argument_list|(
name|uid_to_subtype_map
argument_list|,
name|result
operator|->
name|key
argument_list|)
expr_stmt|;
name|result
operator|=
name|splay_tree_min
argument_list|(
name|uid_to_subtype_map
argument_list|)
expr_stmt|;
block|}
name|splay_tree_delete
argument_list|(
name|uid_to_subtype_map
argument_list|)
expr_stmt|;
name|uid_to_subtype_map
operator|=
name|NULL
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|global_types_exposed_parameter
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|been_there_done_that
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|bitmap_tmp
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|results_of_malloc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|gate_type_escape_vars
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|flag_unit_at_a_time
operator|!=
literal|0
operator|&&
name|flag_ipa_type_escape
comment|/* Don't bother doing anything if the program has errors.  */
operator|&&
operator|!
operator|(
name|errorcount
operator|||
name|sorrycount
operator|)
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_ipa_type_escape
init|=
block|{
literal|"type-escape-var"
block|,
comment|/* name */
name|gate_type_escape_vars
block|,
comment|/* gate */
name|type_escape_execute
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
name|TV_IPA_TYPE_ESCAPE
block|,
comment|/* tv_id */
literal|0
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
literal|0
block|,
comment|/* todo_flags_finish */
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

end_unit

