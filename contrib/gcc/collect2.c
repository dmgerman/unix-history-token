begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Collect static initialization info into data structures that can be    traversed by C++ initialization and finalization routines.    Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000    Free Software Foundation, Inc.    Contributed by Chris Smith (csmith@convex.com).    Heavily modified by Michael Meissner (meissner@cygnus.com),    Per Bothner (bothner@cygnus.com), and John Gilmore (gnu@cygnus.com).  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* Build tables of static constructors and destructors and run ld.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|vfork
end_ifdef

begin_comment
comment|/* Autoconf may define this to fork for us. */
end_comment

begin_define
define|#
directive|define
name|VFORK_STRING
value|"fork"
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|VFORK_STRING
value|"vfork"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_VFORK_H
end_ifdef

begin_include
include|#
directive|include
file|<vfork.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_define
define|#
directive|define
name|vfork
parameter_list|()
value|(decc$$alloc_vfork_blocks()>= 0 ? \                lib$get_current_invo_context(decc$$get_vfork_jmpbuf()) : -1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VMS */
end_comment

begin_define
define|#
directive|define
name|COLLECT
end_define

begin_include
include|#
directive|include
file|"collect2.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"intl.h"
end_include

begin_comment
comment|/* Obstack allocation and deallocation routines.  */
end_comment

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|make_temp_file
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* On certain systems, we have code that works by scanning the object file    directly.  But this code uses system-specific header files and library    functions, so turn it off in a cross-compiler.  Likewise, the names of    the utilities are not correct for a cross-compiler; we have to hope that    cross-versions are in the proper directories.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CROSS_COMPILE
end_ifdef

begin_undef
undef|#
directive|undef
name|SUNOS4_SHARED_LIBRARIES
end_undef

begin_undef
undef|#
directive|undef
name|OBJECT_FORMAT_COFF
end_undef

begin_undef
undef|#
directive|undef
name|OBJECT_FORMAT_ROSE
end_undef

begin_undef
undef|#
directive|undef
name|MD_EXEC_PREFIX
end_undef

begin_undef
undef|#
directive|undef
name|REAL_LD_FILE_NAME
end_undef

begin_undef
undef|#
directive|undef
name|REAL_NM_FILE_NAME
end_undef

begin_undef
undef|#
directive|undef
name|REAL_STRIP_FILE_NAME
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* If we cannot use a special method, use the ordinary one:    run nm to find what symbols are present.    In a cross-compiler, this means you need a cross nm,    but that is not quite as unpleasant as special headers.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|OBJECT_FORMAT_COFF
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|OBJECT_FORMAT_ROSE
argument_list|)
end_if

begin_define
define|#
directive|define
name|OBJECT_FORMAT_NONE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|OBJECT_FORMAT_COFF
end_ifdef

begin_include
include|#
directive|include
file|<a.out.h>
end_include

begin_include
include|#
directive|include
file|<ar.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|UMAX
end_ifdef

begin_include
include|#
directive|include
file|<sgs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Many versions of ldfcn.h define these.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|FREAD
end_ifdef

begin_undef
undef|#
directive|undef
name|FREAD
end_undef

begin_undef
undef|#
directive|undef
name|FWRITE
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<ldfcn.h>
end_include

begin_comment
comment|/* Some systems have an ISCOFF macro, but others do not.  In some cases    the macro may be wrong.  MY_ISCOFF is defined in tm.h files for machines    that either do not have an ISCOFF macro in /usr/include or for those     where it is wrong.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MY_ISCOFF
end_ifndef

begin_define
define|#
directive|define
name|MY_ISCOFF
parameter_list|(
name|X
parameter_list|)
value|ISCOFF (X)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJECT_FORMAT_COFF */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OBJECT_FORMAT_ROSE
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|_OSF_SOURCE
end_ifdef

begin_define
define|#
directive|define
name|USE_MMAP
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|USE_MMAP
end_ifdef

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<mach_o_format.h>
end_include

begin_include
include|#
directive|include
file|<mach_o_header.h>
end_include

begin_include
include|#
directive|include
file|<mach_o_vals.h>
end_include

begin_include
include|#
directive|include
file|<mach_o_types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJECT_FORMAT_ROSE */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OBJECT_FORMAT_NONE
end_ifdef

begin_comment
comment|/* Default flags to pass to nm.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NM_FLAGS
end_ifndef

begin_define
define|#
directive|define
name|NM_FLAGS
value|"-n"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJECT_FORMAT_NONE */
end_comment

begin_comment
comment|/* Some systems use __main in a way incompatible with its use in gcc, in these    cases use the macros NAME__MAIN to give a quoted symbol and SYMBOL__MAIN to    give the same symbol without quotes for an alternative entry point.  You    must define both, or neither.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NAME__MAIN
end_ifndef

begin_define
define|#
directive|define
name|NAME__MAIN
value|"__main"
end_define

begin_define
define|#
directive|define
name|SYMBOL__MAIN
value|__main
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This must match tree.h.  */
end_comment

begin_define
define|#
directive|define
name|DEFAULT_INIT_PRIORITY
value|65535
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|LDD_SUFFIX
argument_list|)
operator|||
name|SUNOS4_SHARED_LIBRARIES
end_if

begin_define
define|#
directive|define
name|SCAN_LIBRARIES
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|USE_COLLECT2
end_ifdef

begin_decl_stmt
name|int
name|do_collecting
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|do_collecting
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Linked lists of constructor and destructor names.  */
end_comment

begin_struct
struct|struct
name|id
block|{
name|struct
name|id
modifier|*
name|next
decl_stmt|;
name|int
name|sequence
decl_stmt|;
name|char
name|name
index|[
literal|1
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|head
block|{
name|struct
name|id
modifier|*
name|first
decl_stmt|;
name|struct
name|id
modifier|*
name|last
decl_stmt|;
name|int
name|number
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Enumeration giving which pass this is for scanning the program file.  */
end_comment

begin_enum
enum|enum
name|pass
block|{
name|PASS_FIRST
block|,
comment|/* without constructors */
name|PASS_OBJ
block|,
comment|/* individual objects */
name|PASS_LIB
block|,
comment|/* looking for shared libraries */
name|PASS_SECOND
comment|/* with constructors linked in */
block|}
enum|;
end_enum

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|version_string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|vflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if -v */
end_comment

begin_decl_stmt
specifier|static
name|int
name|rflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if -r */
end_comment

begin_decl_stmt
specifier|static
name|int
name|strip_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if -s */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|COLLECT_EXPORT_LIST
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|export_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if -bE */
end_comment

begin_decl_stmt
specifier|static
name|int
name|aix64_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if -b64 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|debug
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if -debug */
end_comment

begin_decl_stmt
specifier|static
name|int
name|shared_obj
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if -shared */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|c_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*<xxx>.c for constructor/destructor list.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|o_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*<xxx>.o for constructor/destructor list.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|COLLECT_EXPORT_LIST
end_ifdef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|export_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*<xxx>.x for AIX export list.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|import_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*<xxx>.p for AIX import list.  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
modifier|*
name|ldout
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* File for ld errors.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|output_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Output file for ld.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|nm_file_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pathname of nm */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|LDD_SUFFIX
end_ifdef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ldd_file_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pathname of ldd (or equivalent) */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|char
modifier|*
name|strip_file_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pathname of strip */
end_comment

begin_decl_stmt
name|char
modifier|*
name|c_file_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pathname of gcc */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|initname
decl_stmt|,
modifier|*
name|fininame
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* names of init and fini funcs */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|head
name|constructors
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of constructors found */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|head
name|destructors
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of destructors found */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|COLLECT_EXPORT_LIST
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|head
name|exports
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of exported symbols */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|head
name|imports
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of imported symbols */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|head
name|undefined
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of undefined symbols */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|head
name|frame_tables
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of frame unwind info tables */
end_comment

begin_decl_stmt
name|struct
name|obstack
name|temporary_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|obstack
name|permanent_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|temporary_firstobj
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Holds the return value of pexecute.  */
end_comment

begin_decl_stmt
name|int
name|pexecute_pid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Defined in the automatically-generated underscore.c.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|prepends_underscore
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|FILE
modifier|*
name|fdopen
parameter_list|()
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|GET_ENV_PATH_LIST
end_ifndef

begin_define
define|#
directive|define
name|GET_ENV_PATH_LIST
parameter_list|(
name|VAR
parameter_list|,
name|NAME
parameter_list|)
value|do { (VAR) = getenv (NAME); } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Structure to hold all the directories in which to search for files to    execute.  */
end_comment

begin_struct
struct|struct
name|prefix_list
block|{
name|char
modifier|*
name|prefix
decl_stmt|;
comment|/* String to prepend to the path.  */
name|struct
name|prefix_list
modifier|*
name|next
decl_stmt|;
comment|/* Next in linked list.  */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|path_prefix
block|{
name|struct
name|prefix_list
modifier|*
name|plist
decl_stmt|;
comment|/* List of prefixes to try */
name|int
name|max_len
decl_stmt|;
comment|/* Max length of a prefix in PLIST */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Name of this list (used in config stuff) */
block|}
struct|;
end_struct

begin_ifdef
ifdef|#
directive|ifdef
name|COLLECT_EXPORT_LIST
end_ifdef

begin_comment
comment|/* Lists to keep libraries to be scanned for global constructors/destructors. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|head
name|libs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of libraries */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|path_prefix
name|cmdline_lib_dirs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* directories specified with -L */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|path_prefix
name|libpath_lib_dirs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* directories in LIBPATH */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|path_prefix
modifier|*
name|libpaths
index|[
literal|3
index|]
init|=
block|{
operator|&
name|cmdline_lib_dirs
block|,
operator|&
name|libpath_lib_dirs
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|libexts
index|[
literal|3
index|]
init|=
block|{
literal|"a"
block|,
literal|"so"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* possible library extentions */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|void
name|error
name|PVPROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
name|ATTRIBUTE_PRINTF_1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|fatal
name|PVPROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
name|ATTRIBUTE_PRINTF_1
name|ATTRIBUTE_NORETURN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|fatal_perror
name|PVPROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
name|ATTRIBUTE_PRINTF_1
name|ATTRIBUTE_NORETURN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|my_strerror
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|my_strsignal
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|handler
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_ctor_dtor
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|find_a_file
name|PROTO
argument_list|(
operator|(
expr|struct
name|path_prefix
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_prefix
name|PROTO
argument_list|(
operator|(
expr|struct
name|path_prefix
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|prefix_from_env
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
expr|struct
name|path_prefix
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|prefix_from_string
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
expr|struct
name|path_prefix
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_wait
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fork_execute
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|maybe_unlink
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_to_list
name|PROTO
argument_list|(
operator|(
expr|struct
name|head
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|extract_init_priority
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sort_ids
name|PROTO
argument_list|(
operator|(
expr|struct
name|head
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_list
name|PROTO
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|char
operator|*
operator|,
expr|struct
name|id
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|COLLECT_EXPORT_LIST
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|dump_list
name|PROTO
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|char
operator|*
operator|,
expr|struct
name|id
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void dump_prefix_list	PROTO((FILE *, char *, struct prefix_list *));
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|write_list_with_asm
name|PROTO
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|char
operator|*
operator|,
expr|struct
name|id
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_c_file
name|PROTO
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|scan_prog_file
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
expr|enum
name|pass
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SCAN_LIBRARIES
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|scan_libraries
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|COLLECT_EXPORT_LIST
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|is_in_list
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
expr|struct
name|id
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_export_file
name|PROTO
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_import_file
name|PROTO
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|resolve_lib_name
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|use_import_list
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ignore_library
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|NO_DUP2
end_ifdef

begin_function
name|int
name|dup2
parameter_list|(
name|oldfd
parameter_list|,
name|newfd
parameter_list|)
name|int
name|oldfd
decl_stmt|;
name|int
name|newfd
decl_stmt|;
block|{
name|int
name|fdtmp
index|[
literal|256
index|]
decl_stmt|;
name|int
name|fdx
init|=
literal|0
decl_stmt|;
name|int
name|fd
decl_stmt|;
if|if
condition|(
name|oldfd
operator|==
name|newfd
condition|)
return|return
name|oldfd
return|;
name|close
argument_list|(
name|newfd
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|fd
operator|=
name|dup
argument_list|(
name|oldfd
argument_list|)
operator|)
operator|!=
name|newfd
operator|&&
name|fd
operator|>=
literal|0
condition|)
comment|/* good enough for low fd's */
name|fdtmp
index|[
name|fdx
operator|++
index|]
operator|=
name|fd
expr_stmt|;
while|while
condition|(
name|fdx
operator|>
literal|0
condition|)
name|close
argument_list|(
name|fdtmp
index|[
operator|--
name|fdx
index|]
argument_list|)
expr_stmt|;
return|return
name|fd
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|char
modifier|*
name|my_strerror
parameter_list|(
name|e
parameter_list|)
name|int
name|e
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|HAVE_STRERROR
return|return
name|strerror
argument_list|(
name|e
argument_list|)
return|;
else|#
directive|else
if|if
condition|(
operator|!
name|e
condition|)
return|return
literal|""
return|;
if|if
condition|(
name|e
operator|>
literal|0
operator|&&
name|e
operator|<
name|sys_nerr
condition|)
return|return
name|sys_errlist
index|[
name|e
index|]
return|;
return|return
literal|"errno = ?"
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|my_strsignal
parameter_list|(
name|s
parameter_list|)
name|int
name|s
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|HAVE_STRSIGNAL
return|return
name|strsignal
argument_list|(
name|s
argument_list|)
return|;
else|#
directive|else
if|if
condition|(
name|s
operator|>=
literal|0
operator|&&
name|s
operator|<
name|NSIG
condition|)
block|{
ifdef|#
directive|ifdef
name|NO_SYS_SIGLIST
specifier|static
name|char
name|buffer
index|[
literal|30
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"Unknown signal %d"
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
name|buffer
return|;
else|#
directive|else
return|return
name|sys_siglist
index|[
name|s
index|]
return|;
endif|#
directive|endif
block|}
else|else
return|return
name|NULL
return|;
endif|#
directive|endif
comment|/* HAVE_STRSIGNAL */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Delete tempfiles and exit function.  */
end_comment

begin_function
name|void
name|collect_exit
parameter_list|(
name|status
parameter_list|)
name|int
name|status
decl_stmt|;
block|{
if|if
condition|(
name|c_file
operator|!=
literal|0
operator|&&
name|c_file
index|[
literal|0
index|]
condition|)
name|maybe_unlink
argument_list|(
name|c_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|o_file
operator|!=
literal|0
operator|&&
name|o_file
index|[
literal|0
index|]
condition|)
name|maybe_unlink
argument_list|(
name|o_file
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COLLECT_EXPORT_LIST
if|if
condition|(
name|export_file
operator|!=
literal|0
operator|&&
name|export_file
index|[
literal|0
index|]
condition|)
name|maybe_unlink
argument_list|(
name|export_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|import_file
operator|!=
literal|0
operator|&&
name|import_file
index|[
literal|0
index|]
condition|)
name|maybe_unlink
argument_list|(
name|import_file
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ldout
operator|!=
literal|0
operator|&&
name|ldout
index|[
literal|0
index|]
condition|)
block|{
name|dump_file
argument_list|(
name|ldout
argument_list|)
expr_stmt|;
name|maybe_unlink
argument_list|(
name|ldout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|!=
literal|0
operator|&&
name|output_file
operator|!=
literal|0
operator|&&
name|output_file
index|[
literal|0
index|]
condition|)
name|maybe_unlink
argument_list|(
name|output_file
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Notify user of a non-error.  */
end_comment

begin_decl_stmt
name|void
name|notice
name|VPROTO
argument_list|(
operator|(
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
name|char
modifier|*
name|msgid
decl_stmt|;
endif|#
directive|endif
name|va_list
name|ap
decl_stmt|;
name|VA_START
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
name|msgid
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
name|msgid
argument_list|)
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Die when sys call fails.  */
end_comment

begin_decl_stmt
name|void
name|fatal_perror
name|VPROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
endif|#
directive|endif
name|int
name|e
init|=
name|errno
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|VA_START
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
name|msgid
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"collect2: "
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
name|msgid
argument_list|)
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|": %s\n"
argument_list|,
name|my_strerror
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|collect_exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Just die.  */
end_comment

begin_decl_stmt
name|void
name|fatal
name|VPROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
endif|#
directive|endif
name|va_list
name|ap
decl_stmt|;
name|VA_START
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
name|msgid
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"collect2: "
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
name|msgid
argument_list|)
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|collect_exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Write error message.  */
end_comment

begin_decl_stmt
name|void
name|error
name|VPROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|msgid
operator|,
operator|...
operator|)
argument_list|)
block|{
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
endif|#
directive|endif
name|va_list
name|ap
decl_stmt|;
name|VA_START
argument_list|(
name|ap
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
name|msgid
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"collect2: "
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
name|msgid
argument_list|)
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* In case obstack is linked in, and abort is defined to fancy_abort,    provide a default entry.  */
end_comment

begin_function
name|void
name|fancy_abort
parameter_list|()
block|{
name|fatal
argument_list|(
literal|"internal error"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|handler
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
if|if
condition|(
name|c_file
operator|!=
literal|0
operator|&&
name|c_file
index|[
literal|0
index|]
condition|)
name|maybe_unlink
argument_list|(
name|c_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|o_file
operator|!=
literal|0
operator|&&
name|o_file
index|[
literal|0
index|]
condition|)
name|maybe_unlink
argument_list|(
name|o_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|ldout
operator|!=
literal|0
operator|&&
name|ldout
index|[
literal|0
index|]
condition|)
name|maybe_unlink
argument_list|(
name|ldout
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COLLECT_EXPORT_LIST
if|if
condition|(
name|export_file
operator|!=
literal|0
operator|&&
name|export_file
index|[
literal|0
index|]
condition|)
name|maybe_unlink
argument_list|(
name|export_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|import_file
operator|!=
literal|0
operator|&&
name|import_file
index|[
literal|0
index|]
condition|)
name|maybe_unlink
argument_list|(
name|import_file
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|signal
argument_list|(
name|signo
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|signo
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|PTR
name|xcalloc
parameter_list|(
name|size1
parameter_list|,
name|size2
parameter_list|)
name|size_t
name|size1
decl_stmt|,
name|size2
decl_stmt|;
block|{
name|PTR
name|ptr
init|=
operator|(
name|PTR
operator|)
name|calloc
argument_list|(
name|size1
argument_list|,
name|size2
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ptr
condition|)
name|fatal
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
name|PTR
name|xmalloc
parameter_list|(
name|size
parameter_list|)
name|size_t
name|size
decl_stmt|;
block|{
name|PTR
name|ptr
init|=
operator|(
name|PTR
operator|)
name|malloc
argument_list|(
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ptr
condition|)
name|fatal
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
name|PTR
name|xrealloc
parameter_list|(
name|old
parameter_list|,
name|size
parameter_list|)
name|PTR
name|old
decl_stmt|;
name|size_t
name|size
decl_stmt|;
block|{
specifier|register
name|PTR
name|ptr
decl_stmt|;
if|if
condition|(
name|old
condition|)
name|ptr
operator|=
operator|(
name|PTR
operator|)
name|realloc
argument_list|(
name|old
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
name|ptr
operator|=
operator|(
name|PTR
operator|)
name|malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"virtual memory exhausted"
argument_list|)
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
name|int
name|file_exists
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
return|return
name|access
argument_list|(
name|name
argument_list|,
name|R_OK
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Make a copy of a string INPUT with size SIZE.  */
end_comment

begin_function
name|char
modifier|*
name|xstrdup
parameter_list|(
name|input
parameter_list|)
specifier|const
name|char
modifier|*
name|input
decl_stmt|;
block|{
specifier|register
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|input
argument_list|)
operator|+
literal|1
decl_stmt|;
specifier|register
name|char
modifier|*
name|output
init|=
name|xmalloc
argument_list|(
name|len
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|output
argument_list|,
name|input
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|output
return|;
block|}
end_function

begin_comment
comment|/* Parse a reasonable subset of shell quoting syntax.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|extract_string
parameter_list|(
name|pp
parameter_list|)
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
block|{
name|char
modifier|*
name|p
init|=
operator|*
name|pp
decl_stmt|;
name|int
name|backquote
init|=
literal|0
decl_stmt|;
name|int
name|inside
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
name|c
init|=
operator|*
name|p
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
break|break;
operator|++
name|p
expr_stmt|;
if|if
condition|(
name|backquote
condition|)
name|obstack_1grow
argument_list|(
operator|&
name|temporary_obstack
argument_list|,
name|c
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|inside
operator|&&
name|c
operator|==
literal|' '
condition|)
break|break;
elseif|else
if|if
condition|(
operator|!
name|inside
operator|&&
name|c
operator|==
literal|'\\'
condition|)
name|backquote
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\''
condition|)
name|inside
operator|=
operator|!
name|inside
expr_stmt|;
else|else
name|obstack_1grow
argument_list|(
operator|&
name|temporary_obstack
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
name|obstack_1grow
argument_list|(
operator|&
name|temporary_obstack
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
operator|*
name|pp
operator|=
name|p
expr_stmt|;
return|return
name|obstack_finish
argument_list|(
operator|&
name|temporary_obstack
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|dump_file
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|FILE
modifier|*
name|stream
init|=
name|fopen
argument_list|(
name|name
argument_list|,
literal|"r"
argument_list|)
decl_stmt|;
name|int
name|no_demangle
init|=
operator|!
operator|!
name|getenv
argument_list|(
literal|"COLLECT_NO_DEMANGLE"
argument_list|)
decl_stmt|;
if|if
condition|(
name|stream
operator|==
literal|0
condition|)
return|return;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|c
decl_stmt|;
while|while
condition|(
name|c
operator|=
name|getc
argument_list|(
name|stream
argument_list|)
operator|,
name|c
operator|!=
name|EOF
operator|&&
operator|(
name|ISALNUM
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'_'
operator|||
name|c
operator|==
literal|'$'
operator|||
name|c
operator|==
literal|'.'
operator|)
condition|)
name|obstack_1grow
argument_list|(
operator|&
name|temporary_obstack
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|obstack_object_size
argument_list|(
operator|&
name|temporary_obstack
argument_list|)
operator|>
literal|0
condition|)
block|{
name|char
modifier|*
name|word
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|result
decl_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|temporary_obstack
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
name|word
operator|=
name|obstack_finish
argument_list|(
operator|&
name|temporary_obstack
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|word
operator|==
literal|'.'
condition|)
operator|++
name|word
operator|,
name|putc
argument_list|(
literal|'.'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|p
operator|=
name|word
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'_'
operator|&&
name|prepends_underscore
condition|)
operator|++
name|p
expr_stmt|;
if|if
condition|(
name|no_demangle
condition|)
name|result
operator|=
literal|0
expr_stmt|;
else|else
name|result
operator|=
name|cplus_demangle
argument_list|(
name|p
argument_list|,
name|DMGL_PARAMS
operator||
name|DMGL_ANSI
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
block|{
name|int
name|diff
decl_stmt|;
name|fputs
argument_list|(
name|result
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|diff
operator|=
name|strlen
argument_list|(
name|word
argument_list|)
operator|-
name|strlen
argument_list|(
name|result
argument_list|)
expr_stmt|;
while|while
condition|(
name|diff
operator|>
literal|0
condition|)
operator|--
name|diff
operator|,
name|putc
argument_list|(
literal|' '
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
while|while
condition|(
name|diff
operator|<
literal|0
operator|&&
name|c
operator|==
literal|' '
condition|)
operator|++
name|diff
operator|,
name|c
operator|=
name|getc
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
else|else
name|fputs
argument_list|(
name|word
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|temporary_obstack
argument_list|,
name|temporary_firstobj
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
name|putc
argument_list|(
name|c
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Decide whether the given symbol is:    a constructor (1), a destructor (2), or neither (0).  */
end_comment

begin_function
specifier|static
name|int
name|is_ctor_dtor
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
struct|struct
name|names
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|int
name|two_underscores
decl_stmt|;
block|}
struct|;
specifier|register
name|struct
name|names
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|ch
decl_stmt|;
specifier|register
name|char
modifier|*
name|orig_s
init|=
name|s
decl_stmt|;
specifier|static
name|struct
name|names
name|special
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|NO_DOLLAR_IN_LABEL
ifdef|#
directive|ifdef
name|NO_DOT_IN_LABEL
block|{
literal|"GLOBAL__I_"
block|,
sizeof|sizeof
argument_list|(
literal|"GLOBAL__I_"
argument_list|)
operator|-
literal|1
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"GLOBAL__D_"
block|,
sizeof|sizeof
argument_list|(
literal|"GLOBAL__D_"
argument_list|)
operator|-
literal|1
block|,
literal|2
block|,
literal|0
block|}
block|,
block|{
literal|"GLOBAL__F_"
block|,
sizeof|sizeof
argument_list|(
literal|"GLOBAL__F_"
argument_list|)
operator|-
literal|1
block|,
literal|5
block|,
literal|0
block|}
block|,
else|#
directive|else
block|{
literal|"GLOBAL_.I."
block|,
sizeof|sizeof
argument_list|(
literal|"GLOBAL_.I."
argument_list|)
operator|-
literal|1
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"GLOBAL_.D."
block|,
sizeof|sizeof
argument_list|(
literal|"GLOBAL_.D."
argument_list|)
operator|-
literal|1
block|,
literal|2
block|,
literal|0
block|}
block|,
block|{
literal|"GLOBAL_.F."
block|,
sizeof|sizeof
argument_list|(
literal|"GLOBAL_.F."
argument_list|)
operator|-
literal|1
block|,
literal|5
block|,
literal|0
block|}
block|,
endif|#
directive|endif
else|#
directive|else
block|{
literal|"GLOBAL_$I$"
block|,
sizeof|sizeof
argument_list|(
literal|"GLOBAL_$I$"
argument_list|)
operator|-
literal|1
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"GLOBAL_$D$"
block|,
sizeof|sizeof
argument_list|(
literal|"GLOBAL_$D$"
argument_list|)
operator|-
literal|1
block|,
literal|2
block|,
literal|0
block|}
block|,
block|{
literal|"GLOBAL_$F$"
block|,
sizeof|sizeof
argument_list|(
literal|"GLOBAL_$F$"
argument_list|)
operator|-
literal|1
block|,
literal|5
block|,
literal|0
block|}
block|,
endif|#
directive|endif
block|{
literal|"GLOBAL__FI_"
block|,
sizeof|sizeof
argument_list|(
literal|"GLOBAL__FI_"
argument_list|)
operator|-
literal|1
block|,
literal|3
block|,
literal|0
block|}
block|,
block|{
literal|"GLOBAL__FD_"
block|,
sizeof|sizeof
argument_list|(
literal|"GLOBAL__FD_"
argument_list|)
operator|-
literal|1
block|,
literal|4
block|,
literal|0
block|}
block|,
ifdef|#
directive|ifdef
name|CFRONT_LOSSAGE
comment|/* Do not collect cfront initialization functions. 			 cfront has its own linker procedure to collect them; 			 if collect2 gets them too, they get collected twice 			 when the cfront procedure is run and the compiler used 			 for linking happens to be GCC.  */
block|{
literal|"sti__"
block|,
sizeof|sizeof
argument_list|(
literal|"sti__"
argument_list|)
operator|-
literal|1
block|,
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|"std__"
block|,
sizeof|sizeof
argument_list|(
literal|"std__"
argument_list|)
operator|-
literal|1
block|,
literal|2
block|,
literal|1
block|}
block|,
endif|#
directive|endif
comment|/* CFRONT_LOSSAGE */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
operator|*
name|s
operator|)
operator|==
literal|'_'
condition|)
operator|++
name|s
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|orig_s
condition|)
return|return
literal|0
return|;
for|for
control|(
name|p
operator|=
operator|&
name|special
index|[
literal|0
index|]
init|;
name|p
operator|->
name|len
operator|>
literal|0
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|ch
operator|==
name|p
operator|->
name|name
index|[
literal|0
index|]
operator|&&
operator|(
operator|!
name|p
operator|->
name|two_underscores
operator|||
operator|(
operator|(
name|s
operator|-
name|orig_s
operator|)
operator|>=
literal|2
operator|)
operator|)
operator|&&
name|strncmp
argument_list|(
name|s
argument_list|,
name|p
operator|->
name|name
argument_list|,
name|p
operator|->
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|p
operator|->
name|ret
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Routine to add variables to the environment.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_PUTENV
end_ifndef

begin_function
name|int
name|putenv
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|VMS
comment|/* nor about VMS */
specifier|extern
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
name|char
modifier|*
modifier|*
name|old_environ
init|=
name|environ
decl_stmt|;
name|char
modifier|*
modifier|*
name|envp
decl_stmt|;
name|int
name|num_envs
init|=
literal|0
decl_stmt|;
name|int
name|name_len
init|=
literal|1
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|str
decl_stmt|;
name|int
name|ch
decl_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|'\0'
operator|&&
name|ch
operator|!=
literal|'='
condition|)
name|name_len
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|ch
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Search for replacing an existing environment variable, and      count the number of total environment variables.  */
for|for
control|(
name|envp
operator|=
name|old_environ
init|;
operator|*
name|envp
condition|;
name|envp
operator|++
control|)
block|{
name|num_envs
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|str
argument_list|,
operator|*
name|envp
argument_list|,
name|name_len
argument_list|)
condition|)
block|{
operator|*
name|envp
operator|=
name|str
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/* Add a new environment variable */
name|environ
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
operator|(
name|num_envs
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
operator|*
name|environ
operator|=
name|str
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|old_environ
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|environ
operator|+
literal|1
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
operator|(
name|num_envs
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* VMS */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_PUTENV */
end_comment

begin_escape
end_escape

begin_comment
comment|/* By default, colon separates directories in a path.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PATH_SEPARATOR
end_ifndef

begin_define
define|#
directive|define
name|PATH_SEPARATOR
value|':'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* We maintain two prefix lists: one from COMPILER_PATH environment variable    and one from the PATH variable.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|path_prefix
name|cpath
decl_stmt|,
name|path
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|CROSS_COMPILE
end_ifdef

begin_comment
comment|/* This is the name of the target machine.  We use it to form the name    of the files to execute.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|target_machine
init|=
name|TARGET_MACHINE
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Search for NAME using prefix list PPREFIX.  We only look for executable    files.      Return 0 if not found, otherwise return its name, allocated with malloc.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|find_a_file
parameter_list|(
name|pprefix
parameter_list|,
name|name
parameter_list|)
name|struct
name|path_prefix
modifier|*
name|pprefix
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|char
modifier|*
name|temp
decl_stmt|;
name|struct
name|prefix_list
modifier|*
name|pl
decl_stmt|;
name|int
name|len
init|=
name|pprefix
operator|->
name|max_len
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Looking for '%s'\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EXECUTABLE_SUFFIX
name|len
operator|+=
name|strlen
argument_list|(
name|EXECUTABLE_SUFFIX
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|temp
operator|=
name|xmalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
comment|/* Determine the filename to execute (special case for absolute paths).  */
if|if
condition|(
operator|*
name|name
operator|==
literal|'/'
ifdef|#
directive|ifdef
name|HAVE_DOS_BASED_FILE_SYSTEM
operator|||
operator|(
operator|*
name|name
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|':'
operator|)
endif|#
directive|endif
condition|)
block|{
if|if
condition|(
name|access
argument_list|(
name|name
argument_list|,
name|X_OK
argument_list|)
operator|==
literal|0
condition|)
block|{
name|strcpy
argument_list|(
name|temp
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  - found: absolute path\n"
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
ifdef|#
directive|ifdef
name|EXECUTABLE_SUFFIX
comment|/* Some systems have a suffix for executable files. 	   So try appending that.  */
name|strcpy
argument_list|(
name|temp
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp
argument_list|,
name|EXECUTABLE_SUFFIX
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|temp
argument_list|,
name|X_OK
argument_list|)
operator|==
literal|0
condition|)
return|return
name|temp
return|;
endif|#
directive|endif
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  - failed to locate using absolute path\n"
argument_list|)
expr_stmt|;
block|}
else|else
for|for
control|(
name|pl
operator|=
name|pprefix
operator|->
name|plist
init|;
name|pl
condition|;
name|pl
operator|=
name|pl
operator|->
name|next
control|)
block|{
name|strcpy
argument_list|(
name|temp
argument_list|,
name|pl
operator|->
name|prefix
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|temp
argument_list|,
name|X_OK
argument_list|)
operator|==
literal|0
condition|)
return|return
name|temp
return|;
ifdef|#
directive|ifdef
name|EXECUTABLE_SUFFIX
comment|/* Some systems have a suffix for executable files. 	   So try appending that.  */
name|strcat
argument_list|(
name|temp
argument_list|,
name|EXECUTABLE_SUFFIX
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|temp
argument_list|,
name|X_OK
argument_list|)
operator|==
literal|0
condition|)
return|return
name|temp
return|;
endif|#
directive|endif
block|}
if|if
condition|(
name|debug
operator|&&
name|pprefix
operator|->
name|plist
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  - failed: no entries in prefix list\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Add an entry for PREFIX to prefix list PPREFIX.  */
end_comment

begin_function
specifier|static
name|void
name|add_prefix
parameter_list|(
name|pprefix
parameter_list|,
name|prefix
parameter_list|)
name|struct
name|path_prefix
modifier|*
name|pprefix
decl_stmt|;
name|char
modifier|*
name|prefix
decl_stmt|;
block|{
name|struct
name|prefix_list
modifier|*
name|pl
decl_stmt|,
modifier|*
modifier|*
name|prev
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|pprefix
operator|->
name|plist
condition|)
block|{
for|for
control|(
name|pl
operator|=
name|pprefix
operator|->
name|plist
init|;
name|pl
operator|->
name|next
condition|;
name|pl
operator|=
name|pl
operator|->
name|next
control|)
empty_stmt|;
name|prev
operator|=
operator|&
name|pl
operator|->
name|next
expr_stmt|;
block|}
else|else
name|prev
operator|=
operator|&
name|pprefix
operator|->
name|plist
expr_stmt|;
comment|/* Keep track of the longest prefix */
name|len
operator|=
name|strlen
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|pprefix
operator|->
name|max_len
condition|)
name|pprefix
operator|->
name|max_len
operator|=
name|len
expr_stmt|;
name|pl
operator|=
operator|(
expr|struct
name|prefix_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|prefix_list
argument_list|)
argument_list|)
expr_stmt|;
name|pl
operator|->
name|prefix
operator|=
name|xstrdup
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|prev
condition|)
name|pl
operator|->
name|next
operator|=
operator|*
name|prev
expr_stmt|;
else|else
name|pl
operator|->
name|next
operator|=
operator|(
expr|struct
name|prefix_list
operator|*
operator|)
literal|0
expr_stmt|;
operator|*
name|prev
operator|=
name|pl
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Take the value of the environment variable ENV, break it into a path, and    add of the entries to PPREFIX.  */
end_comment

begin_function
specifier|static
name|void
name|prefix_from_env
parameter_list|(
name|env
parameter_list|,
name|pprefix
parameter_list|)
name|char
modifier|*
name|env
decl_stmt|;
name|struct
name|path_prefix
modifier|*
name|pprefix
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|GET_ENV_PATH_LIST
argument_list|(
name|p
argument_list|,
name|env
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|prefix_from_string
argument_list|(
name|p
argument_list|,
name|pprefix
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|prefix_from_string
parameter_list|(
name|p
parameter_list|,
name|pprefix
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
name|struct
name|path_prefix
modifier|*
name|pprefix
decl_stmt|;
block|{
name|char
modifier|*
name|startp
decl_stmt|,
modifier|*
name|endp
decl_stmt|;
name|char
modifier|*
name|nstore
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
literal|3
argument_list|)
decl_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Convert string '%s' into prefixes, separator = '%c'\n"
argument_list|,
name|p
argument_list|,
name|PATH_SEPARATOR
argument_list|)
expr_stmt|;
name|startp
operator|=
name|endp
operator|=
name|p
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|*
name|endp
operator|==
name|PATH_SEPARATOR
operator|||
operator|*
name|endp
operator|==
literal|0
condition|)
block|{
name|strncpy
argument_list|(
name|nstore
argument_list|,
name|startp
argument_list|,
name|endp
operator|-
name|startp
argument_list|)
expr_stmt|;
if|if
condition|(
name|endp
operator|==
name|startp
condition|)
block|{
name|strcpy
argument_list|(
name|nstore
argument_list|,
literal|"./"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|endp
index|[
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
block|{
name|nstore
index|[
name|endp
operator|-
name|startp
index|]
operator|=
literal|'/'
expr_stmt|;
name|nstore
index|[
name|endp
operator|-
name|startp
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|nstore
index|[
name|endp
operator|-
name|startp
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  - add prefix: %s\n"
argument_list|,
name|nstore
argument_list|)
expr_stmt|;
name|add_prefix
argument_list|(
name|pprefix
argument_list|,
name|nstore
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|endp
operator|==
literal|0
condition|)
break|break;
name|endp
operator|=
name|startp
operator|=
name|endp
operator|+
literal|1
expr_stmt|;
block|}
else|else
name|endp
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Main program.  */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|char
modifier|*
name|ld_suffix
init|=
literal|"ld"
decl_stmt|;
name|char
modifier|*
name|full_ld_suffix
init|=
name|ld_suffix
decl_stmt|;
name|char
modifier|*
name|real_ld_suffix
init|=
literal|"real-ld"
decl_stmt|;
name|char
modifier|*
name|collect_ld_suffix
init|=
literal|"collect-ld"
decl_stmt|;
name|char
modifier|*
name|nm_suffix
init|=
literal|"nm"
decl_stmt|;
name|char
modifier|*
name|full_nm_suffix
init|=
name|nm_suffix
decl_stmt|;
name|char
modifier|*
name|gnm_suffix
init|=
literal|"gnm"
decl_stmt|;
name|char
modifier|*
name|full_gnm_suffix
init|=
name|gnm_suffix
decl_stmt|;
ifdef|#
directive|ifdef
name|LDD_SUFFIX
name|char
modifier|*
name|ldd_suffix
init|=
name|LDD_SUFFIX
decl_stmt|;
name|char
modifier|*
name|full_ldd_suffix
init|=
name|ldd_suffix
decl_stmt|;
endif|#
directive|endif
name|char
modifier|*
name|strip_suffix
init|=
literal|"strip"
decl_stmt|;
name|char
modifier|*
name|full_strip_suffix
init|=
name|strip_suffix
decl_stmt|;
name|char
modifier|*
name|gstrip_suffix
init|=
literal|"gstrip"
decl_stmt|;
name|char
modifier|*
name|full_gstrip_suffix
init|=
name|gstrip_suffix
decl_stmt|;
name|char
modifier|*
name|arg
decl_stmt|;
name|FILE
modifier|*
name|outf
decl_stmt|;
ifdef|#
directive|ifdef
name|COLLECT_EXPORT_LIST
name|FILE
modifier|*
name|exportf
decl_stmt|;
name|FILE
modifier|*
name|importf
decl_stmt|;
endif|#
directive|endif
name|char
modifier|*
name|ld_file_name
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
modifier|*
name|c_argv
decl_stmt|;
name|char
modifier|*
modifier|*
name|c_ptr
decl_stmt|;
name|char
modifier|*
modifier|*
name|ld1_argv
decl_stmt|;
name|char
modifier|*
modifier|*
name|ld1
decl_stmt|;
name|char
modifier|*
modifier|*
name|ld2_argv
decl_stmt|;
name|char
modifier|*
modifier|*
name|ld2
decl_stmt|;
name|char
modifier|*
modifier|*
name|object_lst
decl_stmt|;
name|char
modifier|*
modifier|*
name|object
decl_stmt|;
name|int
name|first_file
decl_stmt|;
name|int
name|num_c_args
init|=
name|argc
operator|+
literal|9
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|COLLECT2_HOST_INITIALIZATION
argument_list|)
comment|/* Perform system dependant initialization, if neccessary.  */
name|COLLECT2_HOST_INITIALIZATION
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_LC_MESSAGES
name|setlocale
argument_list|(
name|LC_MESSAGES
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|bindtextdomain
argument_list|(
name|PACKAGE
argument_list|,
name|localedir
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|textdomain
argument_list|(
name|PACKAGE
argument_list|)
expr_stmt|;
comment|/* Do not invoke xcalloc before this point, since locale needs to be      set first, in case a diagnostic is issued.  */
name|ld1
operator|=
name|ld1_argv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|,
name|argc
operator|+
literal|3
argument_list|)
expr_stmt|;
name|ld2
operator|=
name|ld2_argv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|,
name|argc
operator|+
literal|6
argument_list|)
expr_stmt|;
name|object
operator|=
name|object_lst
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|,
name|argc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|debug
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* Parse command line early for instances of -debug.  This allows      the debug flag to be set before functions like find_a_file()      are called.  */
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|argv
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-debug"
argument_list|)
condition|)
name|debug
operator|=
literal|1
expr_stmt|;
name|vflag
operator|=
name|debug
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|DEFAULT_A_OUT_NAME
name|output_file
operator|=
literal|"a.out"
expr_stmt|;
else|#
directive|else
name|output_file
operator|=
name|DEFAULT_A_OUT_NAME
expr_stmt|;
endif|#
directive|endif
name|obstack_begin
argument_list|(
operator|&
name|temporary_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|obstack_begin
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|temporary_firstobj
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|temporary_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|current_demangling_style
operator|=
name|gnu_demangling
expr_stmt|;
name|p
operator|=
name|getenv
argument_list|(
literal|"COLLECT_GCC_OPTIONS"
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|&&
operator|*
name|p
condition|)
block|{
name|char
modifier|*
name|q
init|=
name|extract_string
argument_list|(
operator|&
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|q
operator|==
literal|'-'
operator|&&
operator|(
name|q
index|[
literal|1
index|]
operator|==
literal|'m'
operator|||
name|q
index|[
literal|1
index|]
operator|==
literal|'f'
operator|)
condition|)
name|num_c_args
operator|++
expr_stmt|;
block|}
name|obstack_free
argument_list|(
operator|&
name|temporary_obstack
argument_list|,
name|temporary_firstobj
argument_list|)
expr_stmt|;
operator|++
name|num_c_args
expr_stmt|;
name|c_ptr
operator|=
name|c_argv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|,
name|num_c_args
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
name|fatal
argument_list|(
literal|"no arguments"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGQUIT
if|if
condition|(
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|handler
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|handler
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGALRM
if|if
condition|(
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|handler
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGHUP
if|if
condition|(
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|handler
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|signal
argument_list|(
name|SIGSEGV
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGSEGV
argument_list|,
name|handler
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGBUS
if|if
condition|(
name|signal
argument_list|(
name|SIGBUS
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGBUS
argument_list|,
name|handler
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Extract COMPILER_PATH and PATH into our prefix list.  */
name|prefix_from_env
argument_list|(
literal|"COMPILER_PATH"
argument_list|,
operator|&
name|cpath
argument_list|)
expr_stmt|;
name|prefix_from_env
argument_list|(
literal|"PATH"
argument_list|,
operator|&
name|path
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CROSS_COMPILE
comment|/* If we look for a program in the compiler directories, we just use      the short name, since these directories are already system-specific.      But it we look for a program in the system directories, we need to      qualify the program name with the target machine.  */
name|full_ld_suffix
operator|=
name|xcalloc
argument_list|(
name|strlen
argument_list|(
name|ld_suffix
argument_list|)
operator|+
name|strlen
argument_list|(
name|target_machine
argument_list|)
operator|+
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|full_ld_suffix
argument_list|,
name|target_machine
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|full_ld_suffix
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|full_ld_suffix
argument_list|,
name|ld_suffix
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|full_gld_suffix     = xcalloc (strlen (gld_suffix) + strlen (target_machine) + 2, 1);   strcpy (full_gld_suffix, target_machine);   strcat (full_gld_suffix, "-");   strcat (full_gld_suffix, gld_suffix);
endif|#
directive|endif
name|full_nm_suffix
operator|=
name|xcalloc
argument_list|(
name|strlen
argument_list|(
name|nm_suffix
argument_list|)
operator|+
name|strlen
argument_list|(
name|target_machine
argument_list|)
operator|+
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|full_nm_suffix
argument_list|,
name|target_machine
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|full_nm_suffix
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|full_nm_suffix
argument_list|,
name|nm_suffix
argument_list|)
expr_stmt|;
name|full_gnm_suffix
operator|=
name|xcalloc
argument_list|(
name|strlen
argument_list|(
name|gnm_suffix
argument_list|)
operator|+
name|strlen
argument_list|(
name|target_machine
argument_list|)
operator|+
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|full_gnm_suffix
argument_list|,
name|target_machine
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|full_gnm_suffix
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|full_gnm_suffix
argument_list|,
name|gnm_suffix
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LDD_SUFFIX
name|full_ldd_suffix
operator|=
name|xcalloc
argument_list|(
name|strlen
argument_list|(
name|ldd_suffix
argument_list|)
operator|+
name|strlen
argument_list|(
name|target_machine
argument_list|)
operator|+
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|full_ldd_suffix
argument_list|,
name|target_machine
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|full_ldd_suffix
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|full_ldd_suffix
argument_list|,
name|ldd_suffix
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|full_strip_suffix
operator|=
name|xcalloc
argument_list|(
name|strlen
argument_list|(
name|strip_suffix
argument_list|)
operator|+
name|strlen
argument_list|(
name|target_machine
argument_list|)
operator|+
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|full_strip_suffix
argument_list|,
name|target_machine
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|full_strip_suffix
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|full_strip_suffix
argument_list|,
name|strip_suffix
argument_list|)
expr_stmt|;
name|full_gstrip_suffix
operator|=
name|xcalloc
argument_list|(
name|strlen
argument_list|(
name|gstrip_suffix
argument_list|)
operator|+
name|strlen
argument_list|(
name|target_machine
argument_list|)
operator|+
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|full_gstrip_suffix
argument_list|,
name|target_machine
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|full_gstrip_suffix
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|full_gstrip_suffix
argument_list|,
name|gstrip_suffix
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CROSS_COMPILE */
comment|/* Try to discover a valid linker/nm/strip to use.  */
comment|/* Maybe we know the right file to use (if not cross).  */
name|ld_file_name
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEFAULT_LINKER
if|if
condition|(
name|access
argument_list|(
name|DEFAULT_LINKER
argument_list|,
name|X_OK
argument_list|)
operator|==
literal|0
condition|)
name|ld_file_name
operator|=
name|DEFAULT_LINKER
expr_stmt|;
if|if
condition|(
name|ld_file_name
operator|==
literal|0
condition|)
endif|#
directive|endif
ifdef|#
directive|ifdef
name|REAL_LD_FILE_NAME
name|ld_file_name
operator|=
name|find_a_file
argument_list|(
operator|&
name|path
argument_list|,
name|REAL_LD_FILE_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|ld_file_name
operator|==
literal|0
condition|)
endif|#
directive|endif
comment|/* Search the (target-specific) compiler dirs for ld'.  */
name|ld_file_name
operator|=
name|find_a_file
argument_list|(
operator|&
name|cpath
argument_list|,
name|real_ld_suffix
argument_list|)
expr_stmt|;
comment|/* Likewise for `collect-ld'.  */
if|if
condition|(
name|ld_file_name
operator|==
literal|0
condition|)
name|ld_file_name
operator|=
name|find_a_file
argument_list|(
operator|&
name|cpath
argument_list|,
name|collect_ld_suffix
argument_list|)
expr_stmt|;
comment|/* Search the compiler directories for `ld'.  We have protection against      recursive calls in find_a_file.  */
if|if
condition|(
name|ld_file_name
operator|==
literal|0
condition|)
name|ld_file_name
operator|=
name|find_a_file
argument_list|(
operator|&
name|cpath
argument_list|,
name|ld_suffix
argument_list|)
expr_stmt|;
comment|/* Search the ordinary system bin directories      for `ld' (if native linking) or `TARGET-ld' (if cross).  */
if|if
condition|(
name|ld_file_name
operator|==
literal|0
condition|)
name|ld_file_name
operator|=
name|find_a_file
argument_list|(
operator|&
name|path
argument_list|,
name|full_ld_suffix
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|REAL_NM_FILE_NAME
name|nm_file_name
operator|=
name|find_a_file
argument_list|(
operator|&
name|path
argument_list|,
name|REAL_NM_FILE_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|nm_file_name
operator|==
literal|0
condition|)
endif|#
directive|endif
name|nm_file_name
operator|=
name|find_a_file
argument_list|(
operator|&
name|cpath
argument_list|,
name|gnm_suffix
argument_list|)
expr_stmt|;
if|if
condition|(
name|nm_file_name
operator|==
literal|0
condition|)
name|nm_file_name
operator|=
name|find_a_file
argument_list|(
operator|&
name|path
argument_list|,
name|full_gnm_suffix
argument_list|)
expr_stmt|;
if|if
condition|(
name|nm_file_name
operator|==
literal|0
condition|)
name|nm_file_name
operator|=
name|find_a_file
argument_list|(
operator|&
name|cpath
argument_list|,
name|nm_suffix
argument_list|)
expr_stmt|;
if|if
condition|(
name|nm_file_name
operator|==
literal|0
condition|)
name|nm_file_name
operator|=
name|find_a_file
argument_list|(
operator|&
name|path
argument_list|,
name|full_nm_suffix
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LDD_SUFFIX
name|ldd_file_name
operator|=
name|find_a_file
argument_list|(
operator|&
name|cpath
argument_list|,
name|ldd_suffix
argument_list|)
expr_stmt|;
if|if
condition|(
name|ldd_file_name
operator|==
literal|0
condition|)
name|ldd_file_name
operator|=
name|find_a_file
argument_list|(
operator|&
name|path
argument_list|,
name|full_ldd_suffix
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|REAL_STRIP_FILE_NAME
name|strip_file_name
operator|=
name|find_a_file
argument_list|(
operator|&
name|path
argument_list|,
name|REAL_STRIP_FILE_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|strip_file_name
operator|==
literal|0
condition|)
endif|#
directive|endif
name|strip_file_name
operator|=
name|find_a_file
argument_list|(
operator|&
name|cpath
argument_list|,
name|gstrip_suffix
argument_list|)
expr_stmt|;
if|if
condition|(
name|strip_file_name
operator|==
literal|0
condition|)
name|strip_file_name
operator|=
name|find_a_file
argument_list|(
operator|&
name|path
argument_list|,
name|full_gstrip_suffix
argument_list|)
expr_stmt|;
if|if
condition|(
name|strip_file_name
operator|==
literal|0
condition|)
name|strip_file_name
operator|=
name|find_a_file
argument_list|(
operator|&
name|cpath
argument_list|,
name|strip_suffix
argument_list|)
expr_stmt|;
if|if
condition|(
name|strip_file_name
operator|==
literal|0
condition|)
name|strip_file_name
operator|=
name|find_a_file
argument_list|(
operator|&
name|path
argument_list|,
name|full_strip_suffix
argument_list|)
expr_stmt|;
comment|/* Determine the full path name of the C compiler to use.  */
name|c_file_name
operator|=
name|getenv
argument_list|(
literal|"COLLECT_GCC"
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_file_name
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|CROSS_COMPILE
name|c_file_name
operator|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
literal|"gcc-"
argument_list|)
operator|+
name|strlen
argument_list|(
name|target_machine
argument_list|)
operator|+
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|c_file_name
argument_list|,
name|target_machine
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|c_file_name
argument_list|,
literal|"-gcc"
argument_list|)
expr_stmt|;
else|#
directive|else
name|c_file_name
operator|=
literal|"gcc"
expr_stmt|;
endif|#
directive|endif
block|}
name|p
operator|=
name|find_a_file
argument_list|(
operator|&
name|cpath
argument_list|,
name|c_file_name
argument_list|)
expr_stmt|;
comment|/* Here it should be safe to use the system search path since we should have      already qualified the name of the compiler when it is needed.  */
if|if
condition|(
name|p
operator|==
literal|0
condition|)
name|p
operator|=
name|find_a_file
argument_list|(
operator|&
name|path
argument_list|,
name|c_file_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|c_file_name
operator|=
name|p
expr_stmt|;
operator|*
name|ld1
operator|++
operator|=
operator|*
name|ld2
operator|++
operator|=
name|ld_file_name
expr_stmt|;
comment|/* Make temp file names.  */
name|c_file
operator|=
name|make_temp_file
argument_list|(
literal|".c"
argument_list|)
expr_stmt|;
name|o_file
operator|=
name|make_temp_file
argument_list|(
literal|".o"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COLLECT_EXPORT_LIST
name|export_file
operator|=
name|make_temp_file
argument_list|(
literal|".x"
argument_list|)
expr_stmt|;
name|import_file
operator|=
name|make_temp_file
argument_list|(
literal|".p"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ldout
operator|=
name|make_temp_file
argument_list|(
literal|".ld"
argument_list|)
expr_stmt|;
operator|*
name|c_ptr
operator|++
operator|=
name|c_file_name
expr_stmt|;
operator|*
name|c_ptr
operator|++
operator|=
literal|"-x"
expr_stmt|;
operator|*
name|c_ptr
operator|++
operator|=
literal|"c"
expr_stmt|;
operator|*
name|c_ptr
operator|++
operator|=
literal|"-c"
expr_stmt|;
operator|*
name|c_ptr
operator|++
operator|=
literal|"-o"
expr_stmt|;
operator|*
name|c_ptr
operator|++
operator|=
name|o_file
expr_stmt|;
ifdef|#
directive|ifdef
name|COLLECT_EXPORT_LIST
comment|/* Generate a list of directories from LIBPATH.  */
name|prefix_from_env
argument_list|(
literal|"LIBPATH"
argument_list|,
operator|&
name|libpath_lib_dirs
argument_list|)
expr_stmt|;
comment|/* Add to this list also two standard directories where      AIX loader always searches for libraries.  */
name|add_prefix
argument_list|(
operator|&
name|libpath_lib_dirs
argument_list|,
literal|"/lib"
argument_list|)
expr_stmt|;
name|add_prefix
argument_list|(
operator|&
name|libpath_lib_dirs
argument_list|,
literal|"/usr/lib"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Get any options that the upper GCC wants to pass to the sub-GCC.         AIX support needs to know if -shared has been specified before      parsing commandline arguments.  */
name|p
operator|=
name|getenv
argument_list|(
literal|"COLLECT_GCC_OPTIONS"
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|&&
operator|*
name|p
condition|)
block|{
name|char
modifier|*
name|q
init|=
name|extract_string
argument_list|(
operator|&
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|q
operator|==
literal|'-'
operator|&&
operator|(
name|q
index|[
literal|1
index|]
operator|==
literal|'m'
operator|||
name|q
index|[
literal|1
index|]
operator|==
literal|'f'
operator|)
condition|)
operator|*
name|c_ptr
operator|++
operator|=
name|obstack_copy0
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
name|q
argument_list|,
name|strlen
argument_list|(
name|q
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|q
argument_list|,
literal|"-EL"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|q
argument_list|,
literal|"-EB"
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|c_ptr
operator|++
operator|=
name|obstack_copy0
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
name|q
argument_list|,
name|strlen
argument_list|(
name|q
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|q
argument_list|,
literal|"-shared"
argument_list|,
sizeof|sizeof
argument_list|(
literal|"-shared"
argument_list|)
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|shared_obj
operator|=
literal|1
expr_stmt|;
block|}
name|obstack_free
argument_list|(
operator|&
name|temporary_obstack
argument_list|,
name|temporary_firstobj
argument_list|)
expr_stmt|;
operator|*
name|c_ptr
operator|++
operator|=
literal|"-fno-exceptions"
expr_stmt|;
comment|/* !!! When GCC calls collect2,      it does not know whether it is calling collect2 or ld.      So collect2 cannot meaningfully understand any options      except those ld understands.      If you propose to make GCC pass some other option,      just imagine what will happen if ld is really ld!!!  */
comment|/* Parse arguments.  Remember output file spec, pass the rest to ld.  */
comment|/* After the first file, put in the c++ rt0.  */
name|first_file
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|arg
operator|=
operator|*
operator|++
name|argv
operator|)
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
block|{
operator|*
name|ld1
operator|++
operator|=
operator|*
name|ld2
operator|++
operator|=
name|arg
expr_stmt|;
if|if
condition|(
name|arg
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
switch|switch
condition|(
name|arg
index|[
literal|1
index|]
condition|)
block|{
ifdef|#
directive|ifdef
name|COLLECT_EXPORT_LIST
comment|/* We want to disable automatic exports on AIX when user 	       explicitly puts an export list in command line */
case|case
literal|'b'
case|:
if|if
condition|(
name|arg
index|[
literal|2
index|]
operator|==
literal|'E'
operator|||
name|strncmp
argument_list|(
operator|&
name|arg
index|[
literal|2
index|]
argument_list|,
literal|"export"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
name|export_flag
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|arg
index|[
literal|2
index|]
operator|==
literal|'6'
operator|&&
name|arg
index|[
literal|3
index|]
operator|==
literal|'4'
condition|)
name|aix64_flag
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'d'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"-debug"
argument_list|)
condition|)
block|{
comment|/* Already parsed.  */
name|ld1
operator|--
expr_stmt|;
name|ld2
operator|--
expr_stmt|;
block|}
break|break;
case|case
literal|'l'
case|:
if|if
condition|(
name|first_file
condition|)
block|{
comment|/* place o_file BEFORE this argument! */
name|first_file
operator|=
literal|0
expr_stmt|;
name|ld2
operator|--
expr_stmt|;
operator|*
name|ld2
operator|++
operator|=
name|o_file
expr_stmt|;
operator|*
name|ld2
operator|++
operator|=
name|arg
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|COLLECT_EXPORT_LIST
block|{
comment|/* Resolving full library name.  */
name|char
modifier|*
name|s
init|=
name|resolve_lib_name
argument_list|(
name|arg
operator|+
literal|2
argument_list|)
decl_stmt|;
comment|/* If we will use an import list for this library, 		   we should exclude it from ld args.  */
if|if
condition|(
name|use_import_list
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|ld1
operator|--
expr_stmt|;
name|ld2
operator|--
expr_stmt|;
block|}
comment|/* Saving a full library name.  */
name|add_to_list
argument_list|(
operator|&
name|libs
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
ifdef|#
directive|ifdef
name|COLLECT_EXPORT_LIST
comment|/* Saving directories where to search for libraries.  */
case|case
literal|'L'
case|:
name|add_prefix
argument_list|(
operator|&
name|cmdline_lib_dirs
argument_list|,
name|arg
operator|+
literal|2
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'o'
case|:
if|if
condition|(
name|arg
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
name|output_file
operator|=
operator|*
name|ld1
operator|++
operator|=
operator|*
name|ld2
operator|++
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
else|else
name|output_file
operator|=
operator|&
name|arg
index|[
literal|2
index|]
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
if|if
condition|(
name|arg
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
name|rflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|arg
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|&&
name|do_collecting
condition|)
block|{
comment|/* We must strip after the nm run, otherwise C++ linking 		     will not work.  Thus we strip in the second ld run, or 		     else with strip if there is no second ld run.  */
name|strip_flag
operator|=
literal|1
expr_stmt|;
name|ld1
operator|--
expr_stmt|;
block|}
break|break;
case|case
literal|'v'
case|:
if|if
condition|(
name|arg
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
name|vflag
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|p
operator|=
name|rindex
argument_list|(
name|arg
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
operator|&&
operator|(
name|strcmp
argument_list|(
name|p
argument_list|,
literal|".o"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|p
argument_list|,
literal|".a"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|p
argument_list|,
literal|".so"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|first_file
condition|)
block|{
name|first_file
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'o'
condition|)
operator|*
name|ld2
operator|++
operator|=
name|o_file
expr_stmt|;
else|else
block|{
comment|/* place o_file BEFORE this argument! */
name|ld2
operator|--
expr_stmt|;
operator|*
name|ld2
operator|++
operator|=
name|o_file
expr_stmt|;
operator|*
name|ld2
operator|++
operator|=
name|arg
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'o'
condition|)
operator|*
name|object
operator|++
operator|=
name|arg
expr_stmt|;
ifdef|#
directive|ifdef
name|COLLECT_EXPORT_LIST
comment|/* libraries can be specified directly, i.e. without -l flag.  */
else|else
block|{
comment|/* If we will use an import list for this library, 		 we should exclude it from ld args.  */
if|if
condition|(
name|use_import_list
argument_list|(
name|arg
argument_list|)
condition|)
block|{
name|ld1
operator|--
expr_stmt|;
name|ld2
operator|--
expr_stmt|;
block|}
comment|/* Saving a full library name.  */
name|add_to_list
argument_list|(
operator|&
name|libs
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
ifdef|#
directive|ifdef
name|COLLECT_EXPORT_LIST
comment|/* This is added only for debugging purposes.  */
if|if
condition|(
name|debug
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"List of libraries:\n"
argument_list|)
expr_stmt|;
name|dump_list
argument_list|(
name|stderr
argument_list|,
literal|"\t"
argument_list|,
name|libs
operator|.
name|first
argument_list|)
expr_stmt|;
block|}
comment|/* The AIX linker will discard static constructors in object files if      nothing else in the file is referenced, so look at them first.  */
block|{
name|char
modifier|*
modifier|*
name|export_object_lst
init|=
name|object_lst
decl_stmt|;
while|while
condition|(
name|export_object_lst
operator|<
name|object
condition|)
name|scan_prog_file
argument_list|(
operator|*
name|export_object_lst
operator|++
argument_list|,
name|PASS_OBJ
argument_list|)
expr_stmt|;
block|}
block|{
name|struct
name|id
modifier|*
name|list
init|=
name|libs
operator|.
name|first
decl_stmt|;
for|for
control|(
init|;
name|list
condition|;
name|list
operator|=
name|list
operator|->
name|next
control|)
name|scan_prog_file
argument_list|(
name|list
operator|->
name|name
argument_list|,
name|PASS_FIRST
argument_list|)
expr_stmt|;
block|}
block|{
name|char
modifier|*
name|buf1
init|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|export_file
argument_list|)
operator|+
literal|5
argument_list|)
decl_stmt|;
name|char
modifier|*
name|buf2
init|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|import_file
argument_list|)
operator|+
literal|5
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|buf1
argument_list|,
literal|"-bE:%s"
argument_list|,
name|export_file
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf2
argument_list|,
literal|"-bI:%s"
argument_list|,
name|import_file
argument_list|)
expr_stmt|;
operator|*
name|ld1
operator|++
operator|=
name|buf1
expr_stmt|;
operator|*
name|ld2
operator|++
operator|=
name|buf1
expr_stmt|;
operator|*
name|ld1
operator|++
operator|=
name|buf2
expr_stmt|;
operator|*
name|ld2
operator|++
operator|=
name|buf2
expr_stmt|;
name|exportf
operator|=
name|fopen
argument_list|(
name|export_file
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|exportf
operator|==
operator|(
name|FILE
operator|*
operator|)
literal|0
condition|)
name|fatal_perror
argument_list|(
literal|"fopen %s"
argument_list|,
name|export_file
argument_list|)
expr_stmt|;
name|write_export_file
argument_list|(
name|exportf
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|exportf
argument_list|)
condition|)
name|fatal_perror
argument_list|(
literal|"fclose %s"
argument_list|,
name|export_file
argument_list|)
expr_stmt|;
name|importf
operator|=
name|fopen
argument_list|(
name|import_file
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|importf
operator|==
operator|(
name|FILE
operator|*
operator|)
literal|0
condition|)
name|fatal_perror
argument_list|(
literal|"%s"
argument_list|,
name|import_file
argument_list|)
expr_stmt|;
name|write_import_file
argument_list|(
name|importf
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|importf
argument_list|)
condition|)
name|fatal_perror
argument_list|(
literal|"fclose %s"
argument_list|,
name|import_file
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
operator|*
name|c_ptr
operator|++
operator|=
name|c_file
expr_stmt|;
operator|*
name|object
operator|=
operator|*
name|c_ptr
operator|=
operator|*
name|ld1
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
if|if
condition|(
name|vflag
condition|)
block|{
name|notice
argument_list|(
literal|"collect2 version %s"
argument_list|,
name|version_string
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TARGET_VERSION
name|TARGET_VERSION
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|debug
condition|)
block|{
name|char
modifier|*
name|ptr
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ld_file_name        = %s\n"
argument_list|,
operator|(
name|ld_file_name
condition|?
name|ld_file_name
else|:
literal|"not found"
operator|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"c_file_name         = %s\n"
argument_list|,
operator|(
name|c_file_name
condition|?
name|c_file_name
else|:
literal|"not found"
operator|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"nm_file_name        = %s\n"
argument_list|,
operator|(
name|nm_file_name
condition|?
name|nm_file_name
else|:
literal|"not found"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LDD_SUFFIX
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ldd_file_name       = %s\n"
argument_list|,
operator|(
name|ldd_file_name
condition|?
name|ldd_file_name
else|:
literal|"not found"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"strip_file_name     = %s\n"
argument_list|,
operator|(
name|strip_file_name
condition|?
name|strip_file_name
else|:
literal|"not found"
operator|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"c_file              = %s\n"
argument_list|,
operator|(
name|c_file
condition|?
name|c_file
else|:
literal|"not found"
operator|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"o_file              = %s\n"
argument_list|,
operator|(
name|o_file
condition|?
name|o_file
else|:
literal|"not found"
operator|)
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|getenv
argument_list|(
literal|"COLLECT_GCC_OPTIONS"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"COLLECT_GCC_OPTIONS = %s\n"
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|getenv
argument_list|(
literal|"COLLECT_GCC"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"COLLECT_GCC         = %s\n"
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|getenv
argument_list|(
literal|"COMPILER_PATH"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"COMPILER_PATH       = %s\n"
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|getenv
argument_list|(
literal|"LIBRARY_PATH"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"LIBRARY_PATH        = %s\n"
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Load the program, searching all libraries and attempting to provide      undefined symbols from repository information.  */
comment|/* On AIX we do this later.  */
ifndef|#
directive|ifndef
name|COLLECT_EXPORT_LIST
name|do_tlink
argument_list|(
name|ld1_argv
argument_list|,
name|object_lst
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If -r or they will be run via some other method, do not build the      constructor or destructor list, just return now.  */
if|if
condition|(
name|rflag
ifndef|#
directive|ifndef
name|COLLECT_EXPORT_LIST
operator|||
operator|!
name|do_collecting
endif|#
directive|endif
condition|)
block|{
ifdef|#
directive|ifdef
name|COLLECT_EXPORT_LIST
comment|/* Do the link we avoided above if we are exiting.  */
name|do_tlink
argument_list|(
name|ld1_argv
argument_list|,
name|object_lst
argument_list|)
expr_stmt|;
comment|/* But make sure we delete the export file we may have created.  */
if|if
condition|(
name|export_file
operator|!=
literal|0
operator|&&
name|export_file
index|[
literal|0
index|]
condition|)
name|maybe_unlink
argument_list|(
name|export_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|import_file
operator|!=
literal|0
operator|&&
name|import_file
index|[
literal|0
index|]
condition|)
name|maybe_unlink
argument_list|(
name|import_file
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|maybe_unlink
argument_list|(
name|c_file
argument_list|)
expr_stmt|;
name|maybe_unlink
argument_list|(
name|o_file
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Examine the namelist with nm and search it for static constructors      and destructors to call.      Write the constructor and destructor tables to a .s file and reload.  */
comment|/* On AIX we already done scanning for global constructors/destructors.  */
ifndef|#
directive|ifndef
name|COLLECT_EXPORT_LIST
name|scan_prog_file
argument_list|(
name|output_file
argument_list|,
name|PASS_FIRST
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SCAN_LIBRARIES
name|scan_libraries
argument_list|(
name|output_file
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|debug
condition|)
block|{
name|notice
argument_list|(
literal|"%d constructor(s) found\n"
argument_list|,
name|constructors
operator|.
name|number
argument_list|)
expr_stmt|;
name|notice
argument_list|(
literal|"%d destructor(s)  found\n"
argument_list|,
name|destructors
operator|.
name|number
argument_list|)
expr_stmt|;
name|notice
argument_list|(
literal|"%d frame table(s) found\n"
argument_list|,
name|frame_tables
operator|.
name|number
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|constructors
operator|.
name|number
operator|==
literal|0
operator|&&
name|destructors
operator|.
name|number
operator|==
literal|0
operator|&&
name|frame_tables
operator|.
name|number
operator|==
literal|0
if|#
directive|if
name|defined
argument_list|(
name|SCAN_LIBRARIES
argument_list|)
operator|||
name|defined
argument_list|(
name|COLLECT_EXPORT_LIST
argument_list|)
comment|/* If we will be running these functions ourselves, we want to emit 	 stubs into the shared library so that we do not have to relink 	 dependent programs when we add static objects.  */
operator|&&
operator|!
name|shared_obj
endif|#
directive|endif
condition|)
block|{
ifdef|#
directive|ifdef
name|COLLECT_EXPORT_LIST
comment|/* Doing tlink without additional code generation */
name|do_tlink
argument_list|(
name|ld1_argv
argument_list|,
name|object_lst
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Strip now if it was requested on the command line.  */
if|if
condition|(
name|strip_flag
condition|)
block|{
name|char
modifier|*
modifier|*
name|strip_argv
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|,
literal|3
argument_list|)
decl_stmt|;
name|strip_argv
index|[
literal|0
index|]
operator|=
name|strip_file_name
expr_stmt|;
name|strip_argv
index|[
literal|1
index|]
operator|=
name|output_file
expr_stmt|;
name|strip_argv
index|[
literal|2
index|]
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
name|fork_execute
argument_list|(
literal|"strip"
argument_list|,
name|strip_argv
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|COLLECT_EXPORT_LIST
name|maybe_unlink
argument_list|(
name|export_file
argument_list|)
expr_stmt|;
name|maybe_unlink
argument_list|(
name|import_file
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|maybe_unlink
argument_list|(
name|c_file
argument_list|)
expr_stmt|;
name|maybe_unlink
argument_list|(
name|o_file
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Sort ctor and dtor lists by priority. */
name|sort_ids
argument_list|(
operator|&
name|constructors
argument_list|)
expr_stmt|;
name|sort_ids
argument_list|(
operator|&
name|destructors
argument_list|)
expr_stmt|;
name|maybe_unlink
argument_list|(
name|output_file
argument_list|)
expr_stmt|;
name|outf
operator|=
name|fopen
argument_list|(
name|c_file
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|outf
operator|==
operator|(
name|FILE
operator|*
operator|)
literal|0
condition|)
name|fatal_perror
argument_list|(
literal|"fopen %s"
argument_list|,
name|c_file
argument_list|)
expr_stmt|;
name|write_c_file
argument_list|(
name|outf
argument_list|,
name|c_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|outf
argument_list|)
condition|)
name|fatal_perror
argument_list|(
literal|"fclose %s"
argument_list|,
name|c_file
argument_list|)
expr_stmt|;
comment|/* Tell the linker that we have initializer and finalizer functions.  */
ifdef|#
directive|ifdef
name|LD_INIT_SWITCH
operator|*
name|ld2
operator|++
operator|=
name|LD_INIT_SWITCH
expr_stmt|;
operator|*
name|ld2
operator|++
operator|=
name|initname
expr_stmt|;
operator|*
name|ld2
operator|++
operator|=
name|LD_FINI_SWITCH
expr_stmt|;
operator|*
name|ld2
operator|++
operator|=
name|fininame
expr_stmt|;
endif|#
directive|endif
operator|*
name|ld2
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|COLLECT_EXPORT_LIST
if|if
condition|(
name|shared_obj
condition|)
block|{
name|add_to_list
argument_list|(
operator|&
name|exports
argument_list|,
name|initname
argument_list|)
expr_stmt|;
name|add_to_list
argument_list|(
operator|&
name|exports
argument_list|,
name|fininame
argument_list|)
expr_stmt|;
name|add_to_list
argument_list|(
operator|&
name|exports
argument_list|,
literal|"_GLOBAL__DI"
argument_list|)
expr_stmt|;
name|add_to_list
argument_list|(
operator|&
name|exports
argument_list|,
literal|"_GLOBAL__DD"
argument_list|)
expr_stmt|;
name|exportf
operator|=
name|fopen
argument_list|(
name|export_file
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|exportf
operator|==
operator|(
name|FILE
operator|*
operator|)
literal|0
condition|)
name|fatal_perror
argument_list|(
literal|"fopen %s"
argument_list|,
name|export_file
argument_list|)
expr_stmt|;
name|write_export_file
argument_list|(
name|exportf
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|exportf
argument_list|)
condition|)
name|fatal_perror
argument_list|(
literal|"fclose %s"
argument_list|,
name|export_file
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|debug
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n========== output_file = %s, c_file = %s\n"
argument_list|,
name|output_file
argument_list|,
name|c_file
argument_list|)
expr_stmt|;
name|write_c_file
argument_list|(
name|stderr
argument_list|,
literal|"stderr"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"========== end of c_file\n\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COLLECT_EXPORT_LIST
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n========== export_file = %s\n"
argument_list|,
name|export_file
argument_list|)
expr_stmt|;
name|write_export_file
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"========== end of export_file\n\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Assemble the constructor and destructor tables.      Link the tables in with the rest of the program.  */
name|fork_execute
argument_list|(
literal|"gcc"
argument_list|,
name|c_argv
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COLLECT_EXPORT_LIST
comment|/* On AIX we must call tlink because of possible templates resolution */
name|do_tlink
argument_list|(
name|ld2_argv
argument_list|,
name|object_lst
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Otherwise, simply call ld because tlink is already done */
name|fork_execute
argument_list|(
literal|"ld"
argument_list|,
name|ld2_argv
argument_list|)
expr_stmt|;
comment|/* Let scan_prog_file do any final mods (OSF/rose needs this for      constructors/destructors in shared libraries.  */
name|scan_prog_file
argument_list|(
name|output_file
argument_list|,
name|PASS_SECOND
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|maybe_unlink
argument_list|(
name|c_file
argument_list|)
expr_stmt|;
name|maybe_unlink
argument_list|(
name|o_file
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COLLECT_EXPORT_LIST
name|maybe_unlink
argument_list|(
name|export_file
argument_list|)
expr_stmt|;
name|maybe_unlink
argument_list|(
name|import_file
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Wait for a process to finish, and exit if a non-zero status is found.  */
end_comment

begin_function
name|int
name|collect_wait
parameter_list|(
name|prog
parameter_list|)
name|char
modifier|*
name|prog
decl_stmt|;
block|{
name|int
name|status
decl_stmt|;
name|pwait
argument_list|(
name|pexecute_pid
argument_list|,
operator|&
name|status
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|int
name|sig
init|=
name|WTERMSIG
argument_list|(
name|status
argument_list|)
decl_stmt|;
name|error
argument_list|(
operator|(
name|status
operator|&
literal|0200
condition|?
literal|"%s terminated with signal %d [%s]"
else|:
literal|"%s terminated with signal %d [%s], core dumped"
operator|)
argument_list|,
name|prog
argument_list|,
name|sig
argument_list|,
name|my_strsignal
argument_list|(
name|sig
argument_list|)
argument_list|)
expr_stmt|;
name|collect_exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|WIFEXITED
argument_list|(
name|status
argument_list|)
condition|)
return|return
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_wait
parameter_list|(
name|prog
parameter_list|)
name|char
modifier|*
name|prog
decl_stmt|;
block|{
name|int
name|ret
init|=
name|collect_wait
argument_list|(
name|prog
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"%s returned %d exit status"
argument_list|,
name|prog
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|collect_exit
argument_list|(
name|ret
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Execute a program, and wait for the reply.  */
end_comment

begin_function
name|void
name|collect_execute
parameter_list|(
name|prog
parameter_list|,
name|argv
parameter_list|,
name|redir
parameter_list|)
name|char
modifier|*
name|prog
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
name|redir
decl_stmt|;
block|{
name|char
modifier|*
name|errmsg_fmt
decl_stmt|;
name|char
modifier|*
name|errmsg_arg
decl_stmt|;
name|int
name|redir_handle
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|stdout_save
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|stderr_save
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|vflag
operator|||
name|debug
condition|)
block|{
name|char
modifier|*
modifier|*
name|p_argv
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
if|if
condition|(
name|argv
index|[
literal|0
index|]
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
else|else
name|notice
argument_list|(
literal|"[cannot find %s]"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
for|for
control|(
name|p_argv
operator|=
operator|&
name|argv
index|[
literal|1
index|]
init|;
operator|(
name|str
operator|=
operator|*
name|p_argv
operator|)
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
condition|;
name|p_argv
operator|++
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
comment|/* If we cannot find a program we need, complain error.  Do this here      since we might not end up needing something that we could not find.  */
if|if
condition|(
name|argv
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"cannot find `%s'"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
if|if
condition|(
name|redir
condition|)
block|{
comment|/* Open response file.  */
name|redir_handle
operator|=
name|open
argument_list|(
name|redir
argument_list|,
name|O_WRONLY
operator||
name|O_TRUNC
operator||
name|O_CREAT
argument_list|)
expr_stmt|;
comment|/* Duplicate the stdout and stderr file handles 	 so they can be restored later.  */
name|stdout_save
operator|=
name|dup
argument_list|(
name|STDOUT_FILENO
argument_list|)
expr_stmt|;
if|if
condition|(
name|stdout_save
operator|==
operator|-
literal|1
condition|)
name|fatal_perror
argument_list|(
literal|"redirecting stdout: %s"
argument_list|,
name|redir
argument_list|)
expr_stmt|;
name|stderr_save
operator|=
name|dup
argument_list|(
name|STDERR_FILENO
argument_list|)
expr_stmt|;
if|if
condition|(
name|stderr_save
operator|==
operator|-
literal|1
condition|)
name|fatal_perror
argument_list|(
literal|"redirecting stdout: %s"
argument_list|,
name|redir
argument_list|)
expr_stmt|;
comment|/* Redirect stdout& stderr to our response file.  */
name|dup2
argument_list|(
name|redir_handle
argument_list|,
name|STDOUT_FILENO
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
name|redir_handle
argument_list|,
name|STDERR_FILENO
argument_list|)
expr_stmt|;
block|}
name|pexecute_pid
operator|=
name|pexecute
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|argv
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|NULL
argument_list|,
operator|&
name|errmsg_fmt
argument_list|,
operator|&
name|errmsg_arg
argument_list|,
operator|(
name|PEXECUTE_FIRST
operator||
name|PEXECUTE_LAST
operator||
name|PEXECUTE_SEARCH
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|redir
condition|)
block|{
comment|/* Restore stdout and stderr to their previous settings.  */
name|dup2
argument_list|(
name|stdout_save
argument_list|,
name|STDOUT_FILENO
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
name|stderr_save
argument_list|,
name|STDERR_FILENO
argument_list|)
expr_stmt|;
comment|/* Close reponse file.  */
name|close
argument_list|(
name|redir_handle
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pexecute_pid
operator|==
operator|-
literal|1
condition|)
name|fatal_perror
argument_list|(
name|errmsg_fmt
argument_list|,
name|errmsg_arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fork_execute
parameter_list|(
name|prog
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
name|prog
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|collect_execute
argument_list|(
name|prog
argument_list|,
name|argv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|do_wait
argument_list|(
name|prog
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Unlink a file unless we are debugging.  */
end_comment

begin_function
specifier|static
name|void
name|maybe_unlink
parameter_list|(
name|file
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|debug
condition|)
name|unlink
argument_list|(
name|file
argument_list|)
expr_stmt|;
else|else
name|notice
argument_list|(
literal|"[Leaving %s]\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|long
name|sequence_number
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Add a name to a linked list.  */
end_comment

begin_function
specifier|static
name|void
name|add_to_list
parameter_list|(
name|head_ptr
parameter_list|,
name|name
parameter_list|)
name|struct
name|head
modifier|*
name|head_ptr
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|id
modifier|*
name|newid
init|=
operator|(
expr|struct
name|id
operator|*
operator|)
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|id
argument_list|)
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|struct
name|id
modifier|*
name|p
decl_stmt|;
name|strcpy
argument_list|(
name|newid
operator|->
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|head_ptr
operator|->
name|first
condition|)
name|head_ptr
operator|->
name|last
operator|->
name|next
operator|=
name|newid
expr_stmt|;
else|else
name|head_ptr
operator|->
name|first
operator|=
name|newid
expr_stmt|;
comment|/* Check for duplicate symbols.  */
for|for
control|(
name|p
operator|=
name|head_ptr
operator|->
name|first
init|;
name|strcmp
argument_list|(
name|name
argument_list|,
name|p
operator|->
name|name
argument_list|)
operator|!=
literal|0
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
empty_stmt|;
if|if
condition|(
name|p
operator|!=
name|newid
condition|)
block|{
name|head_ptr
operator|->
name|last
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|newid
argument_list|)
expr_stmt|;
return|return;
block|}
name|newid
operator|->
name|sequence
operator|=
operator|++
name|sequence_number
expr_stmt|;
name|head_ptr
operator|->
name|last
operator|=
name|newid
expr_stmt|;
name|head_ptr
operator|->
name|number
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Grab the init priority number from an init function name that    looks like "_GLOBAL_.I.12345.foo".  */
end_comment

begin_function
specifier|static
name|int
name|extract_init_priority
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|pos
init|=
literal|0
decl_stmt|,
name|pri
decl_stmt|;
while|while
condition|(
name|name
index|[
name|pos
index|]
operator|==
literal|'_'
condition|)
operator|++
name|pos
expr_stmt|;
name|pos
operator|+=
literal|10
expr_stmt|;
comment|/* strlen ("GLOBAL__X_") */
comment|/* Extract init_p number from ctor/dtor name. */
name|pri
operator|=
name|atoi
argument_list|(
name|name
operator|+
name|pos
argument_list|)
expr_stmt|;
return|return
name|pri
condition|?
name|pri
else|:
name|DEFAULT_INIT_PRIORITY
return|;
block|}
end_function

begin_comment
comment|/* Insertion sort the ids from ctor/dtor list HEAD_PTR in descending order.    ctors will be run from right to left, dtors from left to right.  */
end_comment

begin_function
specifier|static
name|void
name|sort_ids
parameter_list|(
name|head_ptr
parameter_list|)
name|struct
name|head
modifier|*
name|head_ptr
decl_stmt|;
block|{
comment|/* id holds the current element to insert.  id_next holds the next      element to insert.  id_ptr iterates through the already sorted elements      looking for the place to insert id.  */
name|struct
name|id
modifier|*
name|id
decl_stmt|,
modifier|*
name|id_next
decl_stmt|,
modifier|*
modifier|*
name|id_ptr
decl_stmt|;
name|id
operator|=
name|head_ptr
operator|->
name|first
expr_stmt|;
comment|/* We don't have any sorted elements yet.  */
name|head_ptr
operator|->
name|first
operator|=
name|NULL
expr_stmt|;
for|for
control|(
init|;
name|id
condition|;
name|id
operator|=
name|id_next
control|)
block|{
name|id_next
operator|=
name|id
operator|->
name|next
expr_stmt|;
name|id
operator|->
name|sequence
operator|=
name|extract_init_priority
argument_list|(
name|id
operator|->
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|id_ptr
operator|=
operator|&
operator|(
name|head_ptr
operator|->
name|first
operator|)
init|;
condition|;
name|id_ptr
operator|=
operator|&
operator|(
operator|(
operator|*
name|id_ptr
operator|)
operator|->
name|next
operator|)
control|)
if|if
condition|(
operator|*
name|id_ptr
operator|==
name|NULL
comment|/* If the sequence numbers are the same, we put the id from the 	       file later on the command line later in the list.  */
operator|||
name|id
operator|->
name|sequence
operator|>
operator|(
operator|*
name|id_ptr
operator|)
operator|->
name|sequence
comment|/* Hack: do lexical compare, too. 	    || (id->sequence == (*id_ptr)->sequence&& strcmp (id->name, (*id_ptr)->name)> 0) */
condition|)
block|{
name|id
operator|->
name|next
operator|=
operator|*
name|id_ptr
expr_stmt|;
operator|*
name|id_ptr
operator|=
name|id
expr_stmt|;
break|break;
block|}
block|}
comment|/* Now set the sequence numbers properly so write_c_file works.  */
for|for
control|(
name|id
operator|=
name|head_ptr
operator|->
name|first
init|;
name|id
condition|;
name|id
operator|=
name|id
operator|->
name|next
control|)
name|id
operator|->
name|sequence
operator|=
operator|++
name|sequence_number
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write: `prefix', the names on list LIST, `suffix'.  */
end_comment

begin_function
specifier|static
name|void
name|write_list
parameter_list|(
name|stream
parameter_list|,
name|prefix
parameter_list|,
name|list
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|char
modifier|*
name|prefix
decl_stmt|;
name|struct
name|id
modifier|*
name|list
decl_stmt|;
block|{
while|while
condition|(
name|list
condition|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%sx%d,\n"
argument_list|,
name|prefix
argument_list|,
name|list
operator|->
name|sequence
argument_list|)
expr_stmt|;
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|COLLECT_EXPORT_LIST
end_ifdef

begin_comment
comment|/* This function is really used only on AIX, but may be useful.  */
end_comment

begin_function
specifier|static
name|int
name|is_in_list
parameter_list|(
name|prefix
parameter_list|,
name|list
parameter_list|)
name|char
modifier|*
name|prefix
decl_stmt|;
name|struct
name|id
modifier|*
name|list
decl_stmt|;
block|{
while|while
condition|(
name|list
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|prefix
argument_list|,
name|list
operator|->
name|name
argument_list|)
condition|)
return|return
literal|1
return|;
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Added for debugging purpose.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|COLLECT_EXPORT_LIST
end_ifdef

begin_function
specifier|static
name|void
name|dump_list
parameter_list|(
name|stream
parameter_list|,
name|prefix
parameter_list|,
name|list
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|char
modifier|*
name|prefix
decl_stmt|;
name|struct
name|id
modifier|*
name|list
decl_stmt|;
block|{
while|while
condition|(
name|list
condition|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%s%s,\n"
argument_list|,
name|prefix
argument_list|,
name|list
operator|->
name|name
argument_list|)
expr_stmt|;
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void dump_prefix_list (stream, prefix, list)      FILE *stream;      char *prefix;      struct prefix_list *list; {   while (list)     {       fprintf (stream, "%s%s,\n", prefix, list->prefix);       list = list->next;     } }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|write_list_with_asm
parameter_list|(
name|stream
parameter_list|,
name|prefix
parameter_list|,
name|list
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|char
modifier|*
name|prefix
decl_stmt|;
name|struct
name|id
modifier|*
name|list
decl_stmt|;
block|{
while|while
condition|(
name|list
condition|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%sx%d __asm__ (\"%s\");\n"
argument_list|,
name|prefix
argument_list|,
name|list
operator|->
name|sequence
argument_list|,
name|list
operator|->
name|name
argument_list|)
expr_stmt|;
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Write out the constructor and destructor tables statically (for a shared    object), along with the functions to execute them.  */
end_comment

begin_function
specifier|static
name|void
name|write_c_file_stat
parameter_list|(
name|stream
parameter_list|,
name|name
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|char
modifier|*
name|prefix
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|int
name|frames
init|=
operator|(
name|frame_tables
operator|.
name|number
operator|>
literal|0
operator|)
decl_stmt|;
comment|/* Figure out name of output_file, stripping off .so version.  */
name|p
operator|=
name|rindex
argument_list|(
name|output_file
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|output_file
expr_stmt|;
else|else
name|p
operator|++
expr_stmt|;
name|q
operator|=
name|p
expr_stmt|;
while|while
condition|(
name|q
condition|)
block|{
name|q
operator|=
name|index
argument_list|(
name|q
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|==
literal|0
condition|)
block|{
name|q
operator|=
name|p
operator|+
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|q
argument_list|,
literal|".so"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|q
operator|+=
literal|3
expr_stmt|;
break|break;
block|}
else|else
name|q
operator|++
expr_stmt|;
block|}
block|}
comment|/* q points to null at end of the string (or . of the .so version) */
name|prefix
operator|=
name|xmalloc
argument_list|(
name|q
operator|-
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|prefix
argument_list|,
name|p
argument_list|,
name|q
operator|-
name|p
argument_list|)
expr_stmt|;
name|prefix
index|[
name|q
operator|-
name|p
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|q
operator|=
name|prefix
init|;
operator|*
name|q
condition|;
name|q
operator|++
control|)
if|if
condition|(
operator|!
name|ISALNUM
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|q
argument_list|)
condition|)
operator|*
name|q
operator|=
literal|'_'
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|notice
argument_list|(
literal|"\nwrite_c_file - output name is %s, prefix is %s\n"
argument_list|,
name|output_file
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
define|#
directive|define
name|INIT_NAME_FORMAT
value|"_GLOBAL__FI_%s"
name|initname
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|prefix
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|INIT_NAME_FORMAT
argument_list|)
operator|-
literal|2
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|initname
argument_list|,
name|INIT_NAME_FORMAT
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
define|#
directive|define
name|FINI_NAME_FORMAT
value|"_GLOBAL__FD_%s"
name|fininame
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|prefix
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|FINI_NAME_FORMAT
argument_list|)
operator|-
literal|2
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|fininame
argument_list|,
name|FINI_NAME_FORMAT
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
comment|/* Write the tables as C code  */
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"static int count;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"typedef void entry_pt();\n"
argument_list|)
expr_stmt|;
name|write_list_with_asm
argument_list|(
name|stream
argument_list|,
literal|"extern entry_pt "
argument_list|,
name|constructors
operator|.
name|first
argument_list|)
expr_stmt|;
if|if
condition|(
name|frames
condition|)
block|{
name|write_list_with_asm
argument_list|(
name|stream
argument_list|,
literal|"extern void *"
argument_list|,
name|frame_tables
operator|.
name|first
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\tstatic void *frame_table[] = {\n"
argument_list|)
expr_stmt|;
name|write_list
argument_list|(
name|stream
argument_list|,
literal|"\t\t&"
argument_list|,
name|frame_tables
operator|.
name|first
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t0\n};\n"
argument_list|)
expr_stmt|;
comment|/* This must match what's in frame.h.  */
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"struct object {\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"  void *pc_begin;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"  void *pc_end;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"  void *fde_begin;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"  void *fde_array;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"  __SIZE_TYPE__ count;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"  struct object *next;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"};\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"extern void __register_frame_info_table (void *, struct object *);\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"extern void *__deregister_frame_info (void *);\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"static void reg_frame () {\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\tstatic struct object ob;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t__register_frame_info_table (frame_table,&ob);\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t}\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"static void dereg_frame () {\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t__deregister_frame_info (frame_table);\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t}\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"void %s() {\n"
argument_list|,
name|initname
argument_list|)
expr_stmt|;
if|if
condition|(
name|constructors
operator|.
name|number
operator|>
literal|0
operator|||
name|frames
condition|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\tstatic entry_pt *ctors[] = {\n"
argument_list|)
expr_stmt|;
name|write_list
argument_list|(
name|stream
argument_list|,
literal|"\t\t"
argument_list|,
name|constructors
operator|.
name|first
argument_list|)
expr_stmt|;
if|if
condition|(
name|frames
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\treg_frame,\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t};\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\tentry_pt **p;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\tif (count++ != 0) return;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\tp = ctors + %d;\n"
argument_list|,
name|constructors
operator|.
name|number
operator|+
name|frames
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\twhile (p> ctors) (*--p)();\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t++count;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"}\n"
argument_list|)
expr_stmt|;
name|write_list_with_asm
argument_list|(
name|stream
argument_list|,
literal|"extern entry_pt "
argument_list|,
name|destructors
operator|.
name|first
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"void %s() {\n"
argument_list|,
name|fininame
argument_list|)
expr_stmt|;
if|if
condition|(
name|destructors
operator|.
name|number
operator|>
literal|0
operator|||
name|frames
condition|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\tstatic entry_pt *dtors[] = {\n"
argument_list|)
expr_stmt|;
name|write_list
argument_list|(
name|stream
argument_list|,
literal|"\t\t"
argument_list|,
name|destructors
operator|.
name|first
argument_list|)
expr_stmt|;
if|if
condition|(
name|frames
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\tdereg_frame,\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t};\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\tentry_pt **p;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\tif (--count != 0) return;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\tp = dtors;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\twhile (p< dtors + %d) (*p++)();\n"
argument_list|,
name|destructors
operator|.
name|number
operator|+
name|frames
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"}\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|shared_obj
condition|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"void _GLOBAL__DI() {\n\t%s();\n}\n"
argument_list|,
name|initname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"void _GLOBAL__DD() {\n\t%s();\n}\n"
argument_list|,
name|fininame
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Write the constructor/destructor tables.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LD_INIT_SWITCH
end_ifndef

begin_function
specifier|static
name|void
name|write_c_file_glob
parameter_list|(
name|stream
parameter_list|,
name|name
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
comment|/* Write the tables as C code  */
name|int
name|frames
init|=
operator|(
name|frame_tables
operator|.
name|number
operator|>
literal|0
operator|)
decl_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"typedef void entry_pt();\n\n"
argument_list|)
expr_stmt|;
name|write_list_with_asm
argument_list|(
name|stream
argument_list|,
literal|"extern entry_pt "
argument_list|,
name|constructors
operator|.
name|first
argument_list|)
expr_stmt|;
if|if
condition|(
name|frames
condition|)
block|{
name|write_list_with_asm
argument_list|(
name|stream
argument_list|,
literal|"extern void *"
argument_list|,
name|frame_tables
operator|.
name|first
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\tstatic void *frame_table[] = {\n"
argument_list|)
expr_stmt|;
name|write_list
argument_list|(
name|stream
argument_list|,
literal|"\t\t&"
argument_list|,
name|frame_tables
operator|.
name|first
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t0\n};\n"
argument_list|)
expr_stmt|;
comment|/* This must match what's in frame.h.  */
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"struct object {\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"  void *pc_begin;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"  void *pc_end;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"  void *fde_begin;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"  void *fde_array;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"  __SIZE_TYPE__ count;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"  struct object *next;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"};\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"extern void __register_frame_info_table (void *, struct object *);\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"extern void *__deregister_frame_info (void *);\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"static void reg_frame () {\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\tstatic struct object ob;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t__register_frame_info_table (frame_table,&ob);\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t}\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"static void dereg_frame () {\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t__deregister_frame_info (frame_table);\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t}\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\nentry_pt * __CTOR_LIST__[] = {\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t(entry_pt *) %d,\n"
argument_list|,
name|constructors
operator|.
name|number
operator|+
name|frames
argument_list|)
expr_stmt|;
name|write_list
argument_list|(
name|stream
argument_list|,
literal|"\t"
argument_list|,
name|constructors
operator|.
name|first
argument_list|)
expr_stmt|;
if|if
condition|(
name|frames
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\treg_frame,\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t0\n};\n\n"
argument_list|)
expr_stmt|;
name|write_list_with_asm
argument_list|(
name|stream
argument_list|,
literal|"extern entry_pt "
argument_list|,
name|destructors
operator|.
name|first
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\nentry_pt * __DTOR_LIST__[] = {\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t(entry_pt *) %d,\n"
argument_list|,
name|destructors
operator|.
name|number
operator|+
name|frames
argument_list|)
expr_stmt|;
name|write_list
argument_list|(
name|stream
argument_list|,
literal|"\t"
argument_list|,
name|destructors
operator|.
name|first
argument_list|)
expr_stmt|;
if|if
condition|(
name|frames
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\tdereg_frame,\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t0\n};\n\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"extern entry_pt %s;\n"
argument_list|,
name|NAME__MAIN
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"entry_pt *__main_reference = %s;\n\n"
argument_list|,
name|NAME__MAIN
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! LD_INIT_SWITCH */
end_comment

begin_function
specifier|static
name|void
name|write_c_file
parameter_list|(
name|stream
parameter_list|,
name|name
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"#ifdef __cplusplus\nextern \"C\" {\n#endif\n"
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|LD_INIT_SWITCH
if|if
condition|(
operator|!
name|shared_obj
condition|)
name|write_c_file_glob
argument_list|(
name|stream
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|write_c_file_stat
argument_list|(
name|stream
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"#ifdef __cplusplus\n}\n#endif\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|COLLECT_EXPORT_LIST
end_ifdef

begin_function
specifier|static
name|void
name|write_export_file
parameter_list|(
name|stream
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|struct
name|id
modifier|*
name|list
init|=
name|exports
operator|.
name|first
decl_stmt|;
for|for
control|(
init|;
name|list
condition|;
name|list
operator|=
name|list
operator|->
name|next
control|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%s\n"
argument_list|,
name|list
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|write_import_file
parameter_list|(
name|stream
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|struct
name|id
modifier|*
name|list
init|=
name|imports
operator|.
name|first
decl_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%s\n"
argument_list|,
literal|"#! ."
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|list
condition|;
name|list
operator|=
name|list
operator|->
name|next
control|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%s\n"
argument_list|,
name|list
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|OBJECT_FORMAT_NONE
end_ifdef

begin_comment
comment|/* Generic version to scan the name list of the loaded program for    the symbols g++ uses for static constructors and destructors.     The constructor table begins at __CTOR_LIST__ and contains a count    of the number of pointers (or -1 if the constructors are built in a    separate section by the linker), followed by the pointers to the    constructor functions, terminated with a null pointer.  The    destructor table has the same format, and begins at __DTOR_LIST__.  */
end_comment

begin_function
specifier|static
name|void
name|scan_prog_file
parameter_list|(
name|prog_name
parameter_list|,
name|which_pass
parameter_list|)
name|char
modifier|*
name|prog_name
decl_stmt|;
name|enum
name|pass
name|which_pass
decl_stmt|;
block|{
name|void
function_decl|(
modifier|*
name|int_handler
function_decl|)
parameter_list|()
function_decl|;
name|void
function_decl|(
modifier|*
name|quit_handler
function_decl|)
parameter_list|()
function_decl|;
name|char
modifier|*
name|nm_argv
index|[
literal|4
index|]
decl_stmt|;
name|int
name|pid
decl_stmt|;
name|int
name|argc
init|=
literal|0
decl_stmt|;
name|int
name|pipe_fd
index|[
literal|2
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|FILE
modifier|*
name|inf
decl_stmt|;
if|if
condition|(
name|which_pass
operator|==
name|PASS_SECOND
condition|)
return|return;
comment|/* If we do not have an `nm', complain.  */
if|if
condition|(
name|nm_file_name
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"cannot find `nm'"
argument_list|)
expr_stmt|;
name|nm_argv
index|[
name|argc
operator|++
index|]
operator|=
name|nm_file_name
expr_stmt|;
if|if
condition|(
name|NM_FLAGS
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|nm_argv
index|[
name|argc
operator|++
index|]
operator|=
name|NM_FLAGS
expr_stmt|;
name|nm_argv
index|[
name|argc
operator|++
index|]
operator|=
name|prog_name
expr_stmt|;
name|nm_argv
index|[
name|argc
operator|++
index|]
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
if|if
condition|(
name|pipe
argument_list|(
name|pipe_fd
argument_list|)
operator|<
literal|0
condition|)
name|fatal_perror
argument_list|(
literal|"pipe"
argument_list|)
expr_stmt|;
name|inf
operator|=
name|fdopen
argument_list|(
name|pipe_fd
index|[
literal|0
index|]
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|inf
operator|==
operator|(
name|FILE
operator|*
operator|)
literal|0
condition|)
name|fatal_perror
argument_list|(
literal|"fdopen"
argument_list|)
expr_stmt|;
comment|/* Trace if needed.  */
if|if
condition|(
name|vflag
condition|)
block|{
name|char
modifier|*
modifier|*
name|p_argv
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
for|for
control|(
name|p_argv
operator|=
operator|&
name|nm_argv
index|[
literal|0
index|]
init|;
operator|(
name|str
operator|=
operator|*
name|p_argv
operator|)
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
condition|;
name|p_argv
operator|++
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
comment|/* Spawn child nm on pipe */
name|pid
operator|=
name|vfork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
name|fatal_perror
argument_list|(
name|VFORK_STRING
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
comment|/* child context */
block|{
comment|/* setup stdout */
if|if
condition|(
name|dup2
argument_list|(
name|pipe_fd
index|[
literal|1
index|]
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
name|fatal_perror
argument_list|(
literal|"dup2 %d 1"
argument_list|,
name|pipe_fd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|pipe_fd
index|[
literal|0
index|]
argument_list|)
operator|<
literal|0
condition|)
name|fatal_perror
argument_list|(
literal|"close %d"
argument_list|,
name|pipe_fd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|pipe_fd
index|[
literal|1
index|]
argument_list|)
operator|<
literal|0
condition|)
name|fatal_perror
argument_list|(
literal|"close %d"
argument_list|,
name|pipe_fd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|execv
argument_list|(
name|nm_file_name
argument_list|,
name|nm_argv
argument_list|)
expr_stmt|;
name|fatal_perror
argument_list|(
literal|"execvp %s"
argument_list|,
name|nm_file_name
argument_list|)
expr_stmt|;
block|}
comment|/* Parent context from here on.  */
name|int_handler
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGQUIT
name|quit_handler
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|close
argument_list|(
name|pipe_fd
index|[
literal|1
index|]
argument_list|)
operator|<
literal|0
condition|)
name|fatal_perror
argument_list|(
literal|"close %d"
argument_list|,
name|pipe_fd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nnm output with constructors/destructors.\n"
argument_list|)
expr_stmt|;
comment|/* Read each line of nm output.  */
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|inf
argument_list|)
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
block|{
name|int
name|ch
decl_stmt|,
name|ch2
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|end
decl_stmt|;
comment|/* If it contains a constructor or destructor name, add the name 	 to the appropriate list.  */
for|for
control|(
name|p
operator|=
name|buf
init|;
operator|(
name|ch
operator|=
operator|*
name|p
operator|)
operator|!=
literal|'\0'
operator|&&
name|ch
operator|!=
literal|'\n'
operator|&&
name|ch
operator|!=
literal|'_'
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|ch
operator|==
literal|' '
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'U'
operator|&&
name|p
index|[
literal|2
index|]
operator|==
literal|' '
condition|)
break|break;
if|if
condition|(
name|ch
operator|!=
literal|'_'
condition|)
continue|continue;
name|name
operator|=
name|p
expr_stmt|;
comment|/* Find the end of the symbol name. 	 Do not include `|', because Encore nm can tack that on the end.  */
for|for
control|(
name|end
operator|=
name|p
init|;
operator|(
name|ch2
operator|=
operator|*
name|end
operator|)
operator|!=
literal|'\0'
operator|&&
operator|!
name|ISSPACE
argument_list|(
name|ch2
argument_list|)
operator|&&
name|ch2
operator|!=
literal|'|'
condition|;
name|end
operator|++
control|)
continue|continue;
operator|*
name|end
operator|=
literal|'\0'
expr_stmt|;
switch|switch
condition|(
name|is_ctor_dtor
argument_list|(
name|name
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
if|if
condition|(
name|which_pass
operator|!=
name|PASS_LIB
condition|)
name|add_to_list
argument_list|(
operator|&
name|constructors
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
if|if
condition|(
name|which_pass
operator|!=
name|PASS_LIB
condition|)
name|add_to_list
argument_list|(
operator|&
name|destructors
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
if|if
condition|(
name|which_pass
operator|!=
name|PASS_LIB
condition|)
name|fatal
argument_list|(
literal|"init function found in object %s"
argument_list|,
name|prog_name
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|LD_INIT_SWITCH
name|add_to_list
argument_list|(
operator|&
name|constructors
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|4
case|:
if|if
condition|(
name|which_pass
operator|!=
name|PASS_LIB
condition|)
name|fatal
argument_list|(
literal|"fini function found in object %s"
argument_list|,
name|prog_name
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|LD_FINI_SWITCH
name|add_to_list
argument_list|(
operator|&
name|destructors
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|5
case|:
if|if
condition|(
name|which_pass
operator|!=
name|PASS_LIB
condition|)
name|add_to_list
argument_list|(
operator|&
name|frame_tables
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* not a constructor or destructor */
continue|continue;
block|}
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t%s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|inf
argument_list|)
operator|!=
literal|0
condition|)
name|fatal_perror
argument_list|(
literal|"fclose"
argument_list|)
expr_stmt|;
name|do_wait
argument_list|(
name|nm_file_name
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|int_handler
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGQUIT
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|quit_handler
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_if
if|#
directive|if
name|SUNOS4_SHARED_LIBRARIES
end_if

begin_comment
comment|/* Routines to scan the SunOS 4 _DYNAMIC structure to find shared libraries    that the output file depends upon and their initialization/finalization    routines, if any.  */
end_comment

begin_include
include|#
directive|include
file|<a.out.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<link.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_comment
comment|/* pointers to the object file */
end_comment

begin_decl_stmt
name|unsigned
name|object
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* address of memory mapped file */
end_comment

begin_decl_stmt
name|unsigned
name|objsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* size of memory mapped to file */
end_comment

begin_decl_stmt
name|char
modifier|*
name|code
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointer to code segment */
end_comment

begin_decl_stmt
name|char
modifier|*
name|data
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointer to data segment */
end_comment

begin_decl_stmt
name|struct
name|nlist
modifier|*
name|symtab
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointer to symbol table */
end_comment

begin_decl_stmt
name|struct
name|link_dynamic
modifier|*
name|ld
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|link_dynamic_2
modifier|*
name|ld_2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|head
name|libraries
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Map the file indicated by NAME into memory and store its address.  */
end_comment

begin_function
specifier|static
name|void
name|mapfile
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|fp
decl_stmt|;
name|struct
name|stat
name|s
decl_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|open
argument_list|(
name|name
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|"unable to open file '%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|fp
argument_list|,
operator|&
name|s
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|"unable to stat file '%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|objsize
operator|=
name|s
operator|.
name|st_size
expr_stmt|;
name|object
operator|=
operator|(
name|unsigned
operator|)
name|mmap
argument_list|(
literal|0
argument_list|,
name|objsize
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_PRIVATE
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|object
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|"unable to mmap file '%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Helpers for locatelib.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|libname
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|libselect
parameter_list|(
name|d
parameter_list|)
name|struct
name|direct
modifier|*
name|d
decl_stmt|;
block|{
return|return
operator|(
name|strncmp
argument_list|(
name|libname
argument_list|,
name|d
operator|->
name|d_name
argument_list|,
name|strlen
argument_list|(
name|libname
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* If one file has an additional numeric extension past LIBNAME, then put    that one first in the sort.  If both files have additional numeric    extensions, then put the one with the higher number first in the sort.     We must verify that the extension is numeric, because Sun saves the    original versions of patched libraries with a .FCS extension.  Files with    invalid extensions must go last in the sort, so that they will not be used.  */
end_comment

begin_function
specifier|static
name|int
name|libcompare
parameter_list|(
name|d1
parameter_list|,
name|d2
parameter_list|)
name|struct
name|direct
modifier|*
modifier|*
name|d1
decl_stmt|,
decl|*
modifier|*
name|d2
decl_stmt|;
end_function

begin_block
block|{
name|int
name|i1
decl_stmt|,
name|i2
init|=
name|strlen
argument_list|(
name|libname
argument_list|)
decl_stmt|;
name|char
modifier|*
name|e1
init|=
operator|(
operator|*
name|d1
operator|)
operator|->
name|d_name
operator|+
name|i2
decl_stmt|;
name|char
modifier|*
name|e2
init|=
operator|(
operator|*
name|d2
operator|)
operator|->
name|d_name
operator|+
name|i2
decl_stmt|;
while|while
condition|(
operator|*
name|e1
operator|&&
operator|*
name|e2
operator|&&
operator|*
name|e1
operator|==
literal|'.'
operator|&&
operator|*
name|e2
operator|==
literal|'.'
operator|&&
name|e1
index|[
literal|1
index|]
operator|&&
name|ISDIGIT
argument_list|(
name|e1
index|[
literal|1
index|]
argument_list|)
operator|&&
name|e2
index|[
literal|1
index|]
operator|&&
name|ISDIGIT
argument_list|(
name|e2
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
operator|++
name|e1
expr_stmt|;
operator|++
name|e2
expr_stmt|;
name|i1
operator|=
name|strtol
argument_list|(
name|e1
argument_list|,
operator|&
name|e1
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|i2
operator|=
name|strtol
argument_list|(
name|e2
argument_list|,
operator|&
name|e2
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|i1
operator|!=
name|i2
condition|)
return|return
name|i1
operator|-
name|i2
return|;
block|}
if|if
condition|(
operator|*
name|e1
condition|)
block|{
comment|/* It has a valid numeric extension, prefer this one.  */
if|if
condition|(
operator|*
name|e1
operator|==
literal|'.'
operator|&&
name|e1
index|[
literal|1
index|]
operator|&&
name|ISDIGIT
argument_list|(
name|e1
index|[
literal|1
index|]
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* It has a invalid numeric extension, must prefer the other one.  */
else|else
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|e2
condition|)
block|{
comment|/* It has a valid numeric extension, prefer this one.  */
if|if
condition|(
operator|*
name|e2
operator|==
literal|'.'
operator|&&
name|e2
index|[
literal|1
index|]
operator|&&
name|ISDIGIT
argument_list|(
name|e2
index|[
literal|1
index|]
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* It has a invalid numeric extension, must prefer the other one.  */
else|else
return|return
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Given the name NAME of a dynamic dependency, find its pathname and add    it to the list of libraries.  */
end_comment

begin_function
specifier|static
name|void
name|locatelib
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
modifier|*
name|l
decl_stmt|;
specifier|static
name|int
name|cnt
decl_stmt|;
name|char
name|buf
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
if|if
condition|(
name|l
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|ld_rules
decl_stmt|;
name|char
modifier|*
name|ldr
init|=
literal|0
decl_stmt|;
comment|/* counting elements in array, need 1 extra for null */
name|cnt
operator|=
literal|1
expr_stmt|;
name|ld_rules
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|ld_2
operator|->
name|ld_rules
operator|+
name|code
operator|)
expr_stmt|;
if|if
condition|(
name|ld_rules
condition|)
block|{
name|cnt
operator|++
expr_stmt|;
for|for
control|(
init|;
operator|*
name|ld_rules
operator|!=
literal|0
condition|;
name|ld_rules
operator|++
control|)
if|if
condition|(
operator|*
name|ld_rules
operator|==
literal|':'
condition|)
name|cnt
operator|++
expr_stmt|;
name|ld_rules
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|ld_2
operator|->
name|ld_rules
operator|+
name|code
operator|)
expr_stmt|;
name|ldr
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|ld_rules
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|ldr
argument_list|,
name|ld_rules
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|getenv
argument_list|(
literal|"LD_LIBRARY_PATH"
argument_list|)
expr_stmt|;
name|q
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
condition|)
block|{
name|cnt
operator|++
expr_stmt|;
for|for
control|(
name|q
operator|=
name|p
init|;
operator|*
name|q
operator|!=
literal|0
condition|;
name|q
operator|++
control|)
if|if
condition|(
operator|*
name|q
operator|==
literal|':'
condition|)
name|cnt
operator|++
expr_stmt|;
name|q
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|q
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
name|l
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|cnt
operator|+
literal|3
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|pp
operator|=
name|l
expr_stmt|;
if|if
condition|(
name|ldr
condition|)
block|{
operator|*
name|pp
operator|++
operator|=
name|ldr
expr_stmt|;
for|for
control|(
init|;
operator|*
name|ldr
operator|!=
literal|0
condition|;
name|ldr
operator|++
control|)
if|if
condition|(
operator|*
name|ldr
operator|==
literal|':'
condition|)
block|{
operator|*
name|ldr
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|pp
operator|++
operator|=
name|ldr
expr_stmt|;
block|}
block|}
if|if
condition|(
name|q
condition|)
block|{
operator|*
name|pp
operator|++
operator|=
name|q
expr_stmt|;
for|for
control|(
init|;
operator|*
name|q
operator|!=
literal|0
condition|;
name|q
operator|++
control|)
if|if
condition|(
operator|*
name|q
operator|==
literal|':'
condition|)
block|{
operator|*
name|q
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|pp
operator|++
operator|=
name|q
expr_stmt|;
block|}
block|}
comment|/* built in directories are /lib, /usr/lib, and /usr/local/lib */
operator|*
name|pp
operator|++
operator|=
literal|"/lib"
expr_stmt|;
operator|*
name|pp
operator|++
operator|=
literal|"/usr/lib"
expr_stmt|;
operator|*
name|pp
operator|++
operator|=
literal|"/usr/local/lib"
expr_stmt|;
operator|*
name|pp
operator|=
literal|0
expr_stmt|;
block|}
name|libname
operator|=
name|name
expr_stmt|;
for|for
control|(
name|pp
operator|=
name|l
init|;
operator|*
name|pp
operator|!=
literal|0
condition|;
name|pp
operator|++
control|)
block|{
name|struct
name|direct
modifier|*
modifier|*
name|namelist
decl_stmt|;
name|int
name|entries
decl_stmt|;
if|if
condition|(
operator|(
name|entries
operator|=
name|scandir
argument_list|(
operator|*
name|pp
argument_list|,
operator|&
name|namelist
argument_list|,
name|libselect
argument_list|,
name|libcompare
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s/%s"
argument_list|,
operator|*
name|pp
argument_list|,
name|namelist
index|[
name|entries
operator|-
literal|1
index|]
operator|->
name|d_name
argument_list|)
expr_stmt|;
name|add_to_list
argument_list|(
operator|&
name|libraries
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|*
name|pp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|notice
argument_list|(
literal|"not found\n"
argument_list|)
expr_stmt|;
else|else
name|fatal
argument_list|(
literal|"dynamic dependency %s not found"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Scan the _DYNAMIC structure of the output file to find shared libraries    that it depends upon and any constructors or destructors they contain.  */
end_comment

begin_function
specifier|static
name|void
name|scan_libraries
parameter_list|(
name|prog_name
parameter_list|)
name|char
modifier|*
name|prog_name
decl_stmt|;
block|{
name|struct
name|exec
modifier|*
name|header
decl_stmt|;
name|char
modifier|*
name|base
decl_stmt|;
name|struct
name|link_object
modifier|*
name|lo
decl_stmt|;
name|char
name|buff
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|struct
name|id
modifier|*
name|list
decl_stmt|;
name|mapfile
argument_list|(
name|prog_name
argument_list|)
expr_stmt|;
name|header
operator|=
operator|(
expr|struct
name|exec
operator|*
operator|)
name|object
expr_stmt|;
if|if
condition|(
name|N_BADMAG
argument_list|(
operator|*
name|header
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"bad magic number in file '%s'"
argument_list|,
name|prog_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|header
operator|->
name|a_dynamic
operator|==
literal|0
condition|)
return|return;
name|code
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|N_TXTOFF
argument_list|(
operator|*
name|header
argument_list|)
operator|+
operator|(
name|long
operator|)
name|header
operator|)
expr_stmt|;
name|data
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|N_DATOFF
argument_list|(
operator|*
name|header
argument_list|)
operator|+
operator|(
name|long
operator|)
name|header
operator|)
expr_stmt|;
name|symtab
operator|=
operator|(
expr|struct
name|nlist
operator|*
operator|)
operator|(
name|N_SYMOFF
argument_list|(
operator|*
name|header
argument_list|)
operator|+
operator|(
name|long
operator|)
name|header
operator|)
expr_stmt|;
if|if
condition|(
name|header
operator|->
name|a_magic
operator|==
name|ZMAGIC
operator|&&
name|header
operator|->
name|a_entry
operator|==
literal|0x20
condition|)
block|{
comment|/* shared object */
name|ld
operator|=
operator|(
expr|struct
name|link_dynamic
operator|*
operator|)
operator|(
name|symtab
operator|->
name|n_value
operator|+
name|code
operator|)
expr_stmt|;
name|base
operator|=
name|code
expr_stmt|;
block|}
else|else
block|{
comment|/* executable */
name|ld
operator|=
operator|(
expr|struct
name|link_dynamic
operator|*
operator|)
name|data
expr_stmt|;
name|base
operator|=
name|code
operator|-
name|PAGSIZ
expr_stmt|;
block|}
if|if
condition|(
name|debug
condition|)
name|notice
argument_list|(
literal|"dynamic dependencies.\n"
argument_list|)
expr_stmt|;
name|ld_2
operator|=
operator|(
expr|struct
name|link_dynamic_2
operator|*
operator|)
operator|(
operator|(
name|long
operator|)
name|ld
operator|->
name|ld_un
operator|.
name|ld_2
operator|+
operator|(
name|long
operator|)
name|base
operator|)
expr_stmt|;
for|for
control|(
name|lo
operator|=
operator|(
expr|struct
name|link_object
operator|*
operator|)
name|ld_2
operator|->
name|ld_need
init|;
name|lo
condition|;
name|lo
operator|=
operator|(
expr|struct
name|link_object
operator|*
operator|)
name|lo
operator|->
name|lo_next
control|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|lo
operator|=
operator|(
expr|struct
name|link_object
operator|*
operator|)
operator|(
operator|(
name|long
operator|)
name|lo
operator|+
name|code
operator|)
expr_stmt|;
name|name
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|code
operator|+
name|lo
operator|->
name|lo_name
operator|)
expr_stmt|;
if|if
condition|(
name|lo
operator|->
name|lo_library
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t-l%s.%d => "
argument_list|,
name|name
argument_list|,
name|lo
operator|->
name|lo_major
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"lib%s.so.%d.%d"
argument_list|,
name|name
argument_list|,
name|lo
operator|->
name|lo_major
argument_list|,
name|lo
operator|->
name|lo_minor
argument_list|)
expr_stmt|;
name|locatelib
argument_list|(
name|buff
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t%s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|add_to_list
argument_list|(
operator|&
name|libraries
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* now iterate through the library list adding their symbols to      the list.  */
for|for
control|(
name|list
operator|=
name|libraries
operator|.
name|first
init|;
name|list
condition|;
name|list
operator|=
name|list
operator|->
name|next
control|)
name|scan_prog_file
argument_list|(
name|list
operator|->
name|name
argument_list|,
name|PASS_LIB
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* SUNOS4_SHARED_LIBRARIES */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|LDD_SUFFIX
end_ifdef

begin_comment
comment|/* Use the List Dynamic Dependencies program to find shared libraries that    the output file depends upon and their initialization/finalization    routines, if any.  */
end_comment

begin_function
specifier|static
name|void
name|scan_libraries
parameter_list|(
name|prog_name
parameter_list|)
name|char
modifier|*
name|prog_name
decl_stmt|;
block|{
specifier|static
name|struct
name|head
name|libraries
decl_stmt|;
comment|/* list of shared libraries found */
name|struct
name|id
modifier|*
name|list
decl_stmt|;
name|void
function_decl|(
modifier|*
name|int_handler
function_decl|)
parameter_list|()
function_decl|;
name|void
function_decl|(
modifier|*
name|quit_handler
function_decl|)
parameter_list|()
function_decl|;
name|char
modifier|*
name|ldd_argv
index|[
literal|4
index|]
decl_stmt|;
name|int
name|pid
decl_stmt|;
name|int
name|argc
init|=
literal|0
decl_stmt|;
name|int
name|pipe_fd
index|[
literal|2
index|]
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|FILE
modifier|*
name|inf
decl_stmt|;
comment|/* If we do not have an `ldd', complain.  */
if|if
condition|(
name|ldd_file_name
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"cannot find `ldd'"
argument_list|)
expr_stmt|;
return|return;
block|}
name|ldd_argv
index|[
name|argc
operator|++
index|]
operator|=
name|ldd_file_name
expr_stmt|;
name|ldd_argv
index|[
name|argc
operator|++
index|]
operator|=
name|prog_name
expr_stmt|;
name|ldd_argv
index|[
name|argc
operator|++
index|]
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
if|if
condition|(
name|pipe
argument_list|(
name|pipe_fd
argument_list|)
operator|<
literal|0
condition|)
name|fatal_perror
argument_list|(
literal|"pipe"
argument_list|)
expr_stmt|;
name|inf
operator|=
name|fdopen
argument_list|(
name|pipe_fd
index|[
literal|0
index|]
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|inf
operator|==
operator|(
name|FILE
operator|*
operator|)
literal|0
condition|)
name|fatal_perror
argument_list|(
literal|"fdopen"
argument_list|)
expr_stmt|;
comment|/* Trace if needed.  */
if|if
condition|(
name|vflag
condition|)
block|{
name|char
modifier|*
modifier|*
name|p_argv
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
for|for
control|(
name|p_argv
operator|=
operator|&
name|ldd_argv
index|[
literal|0
index|]
init|;
operator|(
name|str
operator|=
operator|*
name|p_argv
operator|)
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
condition|;
name|p_argv
operator|++
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
comment|/* Spawn child ldd on pipe */
name|pid
operator|=
name|vfork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
name|fatal_perror
argument_list|(
name|VFORK_STRING
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
comment|/* child context */
block|{
comment|/* setup stdout */
if|if
condition|(
name|dup2
argument_list|(
name|pipe_fd
index|[
literal|1
index|]
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
name|fatal_perror
argument_list|(
literal|"dup2 %d 1"
argument_list|,
name|pipe_fd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|pipe_fd
index|[
literal|0
index|]
argument_list|)
operator|<
literal|0
condition|)
name|fatal_perror
argument_list|(
literal|"close %d"
argument_list|,
name|pipe_fd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|pipe_fd
index|[
literal|1
index|]
argument_list|)
operator|<
literal|0
condition|)
name|fatal_perror
argument_list|(
literal|"close %d"
argument_list|,
name|pipe_fd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|execv
argument_list|(
name|ldd_file_name
argument_list|,
name|ldd_argv
argument_list|)
expr_stmt|;
name|fatal_perror
argument_list|(
literal|"execv %s"
argument_list|,
name|ldd_file_name
argument_list|)
expr_stmt|;
block|}
comment|/* Parent context from here on.  */
name|int_handler
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGQUIT
name|quit_handler
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|close
argument_list|(
name|pipe_fd
index|[
literal|1
index|]
argument_list|)
operator|<
literal|0
condition|)
name|fatal_perror
argument_list|(
literal|"close %d"
argument_list|,
name|pipe_fd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|notice
argument_list|(
literal|"\nldd output with constructors/destructors.\n"
argument_list|)
expr_stmt|;
comment|/* Read each line of ldd output.  */
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|inf
argument_list|)
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
block|{
name|int
name|ch
decl_stmt|,
name|ch2
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|end
decl_stmt|,
modifier|*
name|p
init|=
name|buf
decl_stmt|;
comment|/* Extract names of libraries and add to list.  */
name|PARSE_LDD_OUTPUT
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
continue|continue;
name|name
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"not found"
argument_list|,
sizeof|sizeof
argument_list|(
literal|"not found"
argument_list|)
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"dynamic dependency %s not found"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* Find the end of the symbol name.  */
for|for
control|(
name|end
operator|=
name|p
init|;
operator|(
name|ch2
operator|=
operator|*
name|end
operator|)
operator|!=
literal|'\0'
operator|&&
name|ch2
operator|!=
literal|'\n'
operator|&&
operator|!
name|ISSPACE
argument_list|(
name|ch2
argument_list|)
operator|&&
name|ch2
operator|!=
literal|'|'
condition|;
name|end
operator|++
control|)
continue|continue;
operator|*
name|end
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|name
argument_list|,
name|R_OK
argument_list|)
operator|==
literal|0
condition|)
name|add_to_list
argument_list|(
operator|&
name|libraries
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|fatal
argument_list|(
literal|"unable to open dynamic dependency '%s'"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t%s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|inf
argument_list|)
operator|!=
literal|0
condition|)
name|fatal_perror
argument_list|(
literal|"fclose"
argument_list|)
expr_stmt|;
name|do_wait
argument_list|(
name|ldd_file_name
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|int_handler
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGQUIT
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|quit_handler
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* now iterate through the library list adding their symbols to      the list.  */
for|for
control|(
name|list
operator|=
name|libraries
operator|.
name|first
init|;
name|list
condition|;
name|list
operator|=
name|list
operator|->
name|next
control|)
name|scan_prog_file
argument_list|(
name|list
operator|->
name|name
argument_list|,
name|PASS_LIB
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LDD_SUFFIX */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SUNOS4_SHARED_LIBRARIES */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJECT_FORMAT_NONE */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  * COFF specific stuff.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OBJECT_FORMAT_COFF
end_ifdef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|EXTENDED_COFF
argument_list|)
end_if

begin_define
define|#
directive|define
name|GCC_SYMBOLS
parameter_list|(
name|X
parameter_list|)
value|(SYMHEADER(X).isymMax + SYMHEADER(X).iextMax)
end_define

begin_define
define|#
directive|define
name|GCC_SYMENT
value|SYMR
end_define

begin_define
define|#
directive|define
name|GCC_OK_SYMBOL
parameter_list|(
name|X
parameter_list|)
value|((X).st == stProc || (X).st == stGlobal)
end_define

begin_define
define|#
directive|define
name|GCC_SYMINC
parameter_list|(
name|X
parameter_list|)
value|(1)
end_define

begin_define
define|#
directive|define
name|GCC_SYMZERO
parameter_list|(
name|X
parameter_list|)
value|(SYMHEADER(X).isymMax)
end_define

begin_define
define|#
directive|define
name|GCC_CHECK_HDR
parameter_list|(
name|X
parameter_list|)
value|(PSYMTAB(X) != 0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|GCC_SYMBOLS
parameter_list|(
name|X
parameter_list|)
value|(HEADER(ldptr).f_nsyms)
end_define

begin_define
define|#
directive|define
name|GCC_SYMENT
value|SYMENT
end_define

begin_define
define|#
directive|define
name|GCC_OK_SYMBOL
parameter_list|(
name|X
parameter_list|)
define|\
value|(((X).n_sclass == C_EXT)&& \       ((X).n_scnum> N_UNDEF)&& \       (((X).n_type& N_TMASK) == (DT_NON<< N_BTSHFT) || \        ((X).n_type& N_TMASK) == (DT_FCN<< N_BTSHFT)))
end_define

begin_define
define|#
directive|define
name|GCC_UNDEF_SYMBOL
parameter_list|(
name|X
parameter_list|)
define|\
value|(((X).n_sclass == C_EXT)&& ((X).n_scnum == N_UNDEF))
end_define

begin_define
define|#
directive|define
name|GCC_SYMINC
parameter_list|(
name|X
parameter_list|)
value|((X).n_numaux+1)
end_define

begin_define
define|#
directive|define
name|GCC_SYMZERO
parameter_list|(
name|X
parameter_list|)
value|0
end_define

begin_define
define|#
directive|define
name|GCC_CHECK_HDR
parameter_list|(
name|X
parameter_list|)
define|\
value|((HEADER (X).f_magic == U802TOCMAGIC&& ! aix64_flag) \       || (HEADER (X).f_magic == 0757&& aix64_flag))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|extern
name|char
modifier|*
name|ldgetname
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* COFF version to scan the name list of the loaded program for    the symbols g++ uses for static constructors and destructors.     The constructor table begins at __CTOR_LIST__ and contains a count    of the number of pointers (or -1 if the constructors are built in a    separate section by the linker), followed by the pointers to the    constructor functions, terminated with a null pointer.  The    destructor table has the same format, and begins at __DTOR_LIST__.  */
end_comment

begin_function
specifier|static
name|void
name|scan_prog_file
parameter_list|(
name|prog_name
parameter_list|,
name|which_pass
parameter_list|)
name|char
modifier|*
name|prog_name
decl_stmt|;
name|enum
name|pass
name|which_pass
decl_stmt|;
block|{
name|LDFILE
modifier|*
name|ldptr
init|=
name|NULL
decl_stmt|;
name|int
name|sym_index
decl_stmt|,
name|sym_count
decl_stmt|;
name|int
name|is_shared
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|COLLECT_EXPORT_LIST
comment|/* Should we generate an import list for given prog_name?  */
name|int
name|import_flag
init|=
operator|(
name|which_pass
operator|==
name|PASS_OBJ
condition|?
literal|0
else|:
name|use_import_list
argument_list|(
name|prog_name
argument_list|)
operator|)
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|which_pass
operator|!=
name|PASS_FIRST
operator|&&
name|which_pass
operator|!=
name|PASS_OBJ
condition|)
return|return;
ifdef|#
directive|ifdef
name|COLLECT_EXPORT_LIST
comment|/* We do not need scanning for some standard C libraries.  */
if|if
condition|(
name|which_pass
operator|==
name|PASS_FIRST
operator|&&
name|ignore_library
argument_list|(
name|prog_name
argument_list|)
condition|)
return|return;
comment|/* On AIX we have a loop, because there is not much difference      between an object and an archive. This trick allows us to      eliminate scan_libraries() function.  */
do|do
block|{
endif|#
directive|endif
if|if
condition|(
operator|(
name|ldptr
operator|=
name|ldopen
argument_list|(
name|prog_name
argument_list|,
name|ldptr
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|MY_ISCOFF
argument_list|(
name|HEADER
argument_list|(
name|ldptr
argument_list|)
operator|.
name|f_magic
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"%s: not a COFF file"
argument_list|,
name|prog_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|GCC_CHECK_HDR
argument_list|(
name|ldptr
argument_list|)
condition|)
block|{
name|sym_count
operator|=
name|GCC_SYMBOLS
argument_list|(
name|ldptr
argument_list|)
expr_stmt|;
name|sym_index
operator|=
name|GCC_SYMZERO
argument_list|(
name|ldptr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COLLECT_EXPORT_LIST
comment|/* Is current archive member a shared object?  */
name|is_shared
operator|=
name|HEADER
argument_list|(
name|ldptr
argument_list|)
operator|.
name|f_flags
operator|&
name|F_SHROBJ
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|sym_index
operator|<
name|sym_count
condition|)
block|{
name|GCC_SYMENT
name|symbol
decl_stmt|;
if|if
condition|(
name|ldtbread
argument_list|(
name|ldptr
argument_list|,
name|sym_index
argument_list|,
operator|&
name|symbol
argument_list|)
operator|<=
literal|0
condition|)
break|break;
name|sym_index
operator|+=
name|GCC_SYMINC
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|GCC_OK_SYMBOL
argument_list|(
name|symbol
argument_list|)
condition|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
operator|(
name|name
operator|=
name|ldgetname
argument_list|(
name|ldptr
argument_list|,
operator|&
name|symbol
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
comment|/* should never happen */
ifdef|#
directive|ifdef
name|XCOFF_DEBUGGING_INFO
comment|/* All AIX function names have a duplicate entry 			 beginning with a dot.  */
if|if
condition|(
operator|*
name|name
operator|==
literal|'.'
condition|)
operator|++
name|name
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|is_ctor_dtor
argument_list|(
name|name
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
if|if
condition|(
operator|!
name|is_shared
condition|)
name|add_to_list
argument_list|(
operator|&
name|constructors
argument_list|,
name|name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COLLECT_EXPORT_LIST
if|if
condition|(
name|which_pass
operator|==
name|PASS_OBJ
condition|)
name|add_to_list
argument_list|(
operator|&
name|exports
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* If this symbol was undefined and we are building 			     an import list, we should add a symbol to this 			     list.  */
elseif|else
if|if
condition|(
name|import_flag
operator|&&
name|is_in_list
argument_list|(
name|name
argument_list|,
name|undefined
operator|.
name|first
argument_list|)
condition|)
name|add_to_list
argument_list|(
operator|&
name|imports
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|2
case|:
if|if
condition|(
operator|!
name|is_shared
condition|)
name|add_to_list
argument_list|(
operator|&
name|destructors
argument_list|,
name|name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COLLECT_EXPORT_LIST
if|if
condition|(
name|which_pass
operator|==
name|PASS_OBJ
condition|)
name|add_to_list
argument_list|(
operator|&
name|exports
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* If this symbol was undefined and we are building 			     an import list, we should add a symbol to this 			     list.  */
elseif|else
if|if
condition|(
name|import_flag
operator|&&
name|is_in_list
argument_list|(
name|name
argument_list|,
name|undefined
operator|.
name|first
argument_list|)
condition|)
name|add_to_list
argument_list|(
operator|&
name|imports
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
ifdef|#
directive|ifdef
name|COLLECT_EXPORT_LIST
case|case
literal|3
case|:
if|if
condition|(
name|is_shared
condition|)
name|add_to_list
argument_list|(
operator|&
name|constructors
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
if|if
condition|(
name|is_shared
condition|)
name|add_to_list
argument_list|(
operator|&
name|destructors
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|5
case|:
if|if
condition|(
operator|!
name|is_shared
condition|)
name|add_to_list
argument_list|(
operator|&
name|frame_tables
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* not a constructor or destructor */
ifdef|#
directive|ifdef
name|COLLECT_EXPORT_LIST
comment|/* If we are building a shared object on AIX we need 			     to explicitly export all global symbols or add 			     them to import list.  */
if|if
condition|(
name|shared_obj
condition|)
block|{
if|if
condition|(
name|which_pass
operator|==
name|PASS_OBJ
operator|&&
operator|(
operator|!
name|export_flag
operator|)
condition|)
name|add_to_list
argument_list|(
operator|&
name|exports
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|is_shared
operator|&&
name|which_pass
operator|==
name|PASS_FIRST
operator|&&
name|import_flag
operator|&&
name|is_in_list
argument_list|(
name|name
argument_list|,
name|undefined
operator|.
name|first
argument_list|)
condition|)
name|add_to_list
argument_list|(
operator|&
name|imports
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
continue|continue;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|EXTENDED_COFF
argument_list|)
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tsec=%d class=%d type=%s%o %s\n"
argument_list|,
name|symbol
operator|.
name|n_scnum
argument_list|,
name|symbol
operator|.
name|n_sclass
argument_list|,
operator|(
name|symbol
operator|.
name|n_type
condition|?
literal|"0"
else|:
literal|""
operator|)
argument_list|,
name|symbol
operator|.
name|n_type
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tiss = %5d, value = %5ld, index = %5d, name = %s\n"
argument_list|,
name|symbol
operator|.
name|iss
argument_list|,
operator|(
name|long
operator|)
name|symbol
operator|.
name|value
argument_list|,
name|symbol
operator|.
name|index
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|COLLECT_EXPORT_LIST
comment|/* If we are building a shared object we should collect 		     information about undefined symbols for later 		     import list generation.  */
elseif|else
if|if
condition|(
name|shared_obj
operator|&&
name|GCC_UNDEF_SYMBOL
argument_list|(
name|symbol
argument_list|)
condition|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
operator|(
name|name
operator|=
name|ldgetname
argument_list|(
name|ldptr
argument_list|,
operator|&
name|symbol
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
comment|/* should never happen */
comment|/* All AIX function names have a duplicate entry 			 beginning with a dot.  */
if|if
condition|(
operator|*
name|name
operator|==
literal|'.'
condition|)
operator|++
name|name
expr_stmt|;
name|add_to_list
argument_list|(
operator|&
name|undefined
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
ifdef|#
directive|ifdef
name|COLLECT_EXPORT_LIST
else|else
block|{
comment|/* If archive contains both 32-bit and 64-bit objects, 		 we want to skip objects in other mode so mismatch normal.  */
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s : magic=%o aix64=%d mismatch\n"
argument_list|,
name|prog_name
argument_list|,
name|HEADER
argument_list|(
name|ldptr
argument_list|)
operator|.
name|f_magic
argument_list|,
name|aix64_flag
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
else|else
block|{
name|fatal
argument_list|(
literal|"%s: cannot open as COFF file"
argument_list|,
name|prog_name
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|COLLECT_EXPORT_LIST
comment|/* On AIX loop continues while there are more members in archive.  */
block|}
do|while
condition|(
name|ldclose
argument_list|(
name|ldptr
argument_list|)
operator|==
name|FAILURE
condition|)
do|;
else|#
directive|else
comment|/* Otherwise we simply close ldptr.  */
operator|(
name|void
operator|)
name|ldclose
argument_list|(
name|ldptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|COLLECT_EXPORT_LIST
end_ifdef

begin_comment
comment|/* Never generate import list (gcc-2.95 branch).  */
end_comment

begin_function
specifier|static
name|int
name|use_import_list
parameter_list|(
name|prog_name
parameter_list|)
name|char
modifier|*
name|prog_name
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Given a library name without "lib" prefix, this function    returns a full library name including a path.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|resolve_lib_name
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|char
modifier|*
name|lib_buf
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|l
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|libpaths
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|libpaths
index|[
name|i
index|]
operator|->
name|max_len
operator|>
name|l
condition|)
name|l
operator|=
name|libpaths
index|[
name|i
index|]
operator|->
name|max_len
expr_stmt|;
name|lib_buf
operator|=
name|xmalloc
argument_list|(
name|l
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|libpaths
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|prefix_list
modifier|*
name|list
init|=
name|libpaths
index|[
name|i
index|]
operator|->
name|plist
decl_stmt|;
for|for
control|(
init|;
name|list
condition|;
name|list
operator|=
name|list
operator|->
name|next
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|libexts
index|[
name|j
index|]
condition|;
name|j
operator|++
control|)
block|{
comment|/* The following lines are needed because path_prefix list                  may contain directories both with trailing '/' and                  without it.  */
name|char
modifier|*
name|p
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|list
operator|->
name|prefix
index|[
name|strlen
argument_list|(
name|list
operator|->
name|prefix
argument_list|)
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
name|p
operator|=
literal|"/"
expr_stmt|;
name|sprintf
argument_list|(
name|lib_buf
argument_list|,
literal|"%s%slib%s.%s"
argument_list|,
name|list
operator|->
name|prefix
argument_list|,
name|p
argument_list|,
name|name
argument_list|,
name|libexts
index|[
name|j
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"searching for: %s\n"
argument_list|,
name|lib_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|file_exists
argument_list|(
name|lib_buf
argument_list|)
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"found: %s\n"
argument_list|,
name|lib_buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|lib_buf
operator|)
return|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"not found\n"
argument_list|)
expr_stmt|;
else|else
name|fatal
argument_list|(
literal|"Library lib%s not found"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Array of standard AIX libraries which should not    be scanned for ctors/dtors.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|aix_std_libs
index|[]
init|=
block|{
literal|"/unix"
block|,
literal|"/lib/libc.a"
block|,
literal|"/lib/libc_r.a"
block|,
literal|"/usr/lib/libc.a"
block|,
literal|"/usr/lib/libc_r.a"
block|,
literal|"/usr/lib/threads/libc.a"
block|,
literal|"/usr/ccs/lib/libc.a"
block|,
literal|"/usr/ccs/lib/libc_r.a"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This function checks the filename and returns 1    if this name matches the location of a standard AIX library. */
end_comment

begin_function
specifier|static
name|int
name|ignore_library
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|p
init|=
operator|&
name|aix_std_libs
index|[
literal|0
index|]
decl_stmt|;
while|while
condition|(
operator|*
name|p
operator|++
operator|!=
name|NULL
condition|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
operator|*
name|p
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJECT_FORMAT_COFF */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  * OSF/rose specific stuff.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OBJECT_FORMAT_ROSE
end_ifdef

begin_comment
comment|/* Union of the various load commands */
end_comment

begin_typedef
typedef|typedef
union|union
name|load_union
block|{
name|ldc_header_t
name|hdr
decl_stmt|;
comment|/* common header */
name|load_cmd_map_command_t
name|map
decl_stmt|;
comment|/* map indexing other load cmds */
name|interpreter_command_t
name|iprtr
decl_stmt|;
comment|/* interpreter pathname */
name|strings_command_t
name|str
decl_stmt|;
comment|/* load commands strings section */
name|region_command_t
name|region
decl_stmt|;
comment|/* region load command */
name|reloc_command_t
name|reloc
decl_stmt|;
comment|/* relocation section */
name|package_command_t
name|pkg
decl_stmt|;
comment|/* package load command */
name|symbols_command_t
name|sym
decl_stmt|;
comment|/* symbol sections */
name|entry_command_t
name|ent
decl_stmt|;
comment|/* program start section */
name|gen_info_command_t
name|info
decl_stmt|;
comment|/* object information */
name|func_table_command_t
name|func
decl_stmt|;
comment|/* function constructors/destructors */
block|}
name|load_union_t
typedef|;
end_typedef

begin_comment
comment|/* Structure to point to load command and data section in memory.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|load_all
block|{
name|load_union_t
modifier|*
name|load
decl_stmt|;
comment|/* load command */
name|char
modifier|*
name|section
decl_stmt|;
comment|/* pointer to section */
block|}
name|load_all_t
typedef|;
end_typedef

begin_comment
comment|/* Structure to contain information about a file mapped into memory.  */
end_comment

begin_struct
struct|struct
name|file_info
block|{
name|char
modifier|*
name|start
decl_stmt|;
comment|/* start of map */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* filename */
name|long
name|size
decl_stmt|;
comment|/* size of the file */
name|long
name|rounded_size
decl_stmt|;
comment|/* size rounded to page boundary */
name|int
name|fd
decl_stmt|;
comment|/* file descriptor */
name|int
name|rw
decl_stmt|;
comment|/* != 0 if opened read/write */
name|int
name|use_mmap
decl_stmt|;
comment|/* != 0 if mmap'ed */
block|}
struct|;
end_struct

begin_function_decl
specifier|extern
name|int
name|decode_mach_o_hdr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|encode_mach_o_hdr
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|add_func_table
name|PROTO
argument_list|(
operator|(
name|mo_header_t
operator|*
operator|,
name|load_all_t
operator|*
operator|,
name|symbol_info_t
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_header
name|PROTO
argument_list|(
operator|(
name|mo_header_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_load_command
name|PROTO
argument_list|(
operator|(
name|load_union_t
operator|*
operator|,
name|size_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|bad_header
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|file_info
modifier|*
name|read_file
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|end_file
name|PROTO
argument_list|(
operator|(
expr|struct
name|file_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* OSF/rose specific version to scan the name list of the loaded    program for the symbols g++ uses for static constructors and    destructors.     The constructor table begins at __CTOR_LIST__ and contains a count    of the number of pointers (or -1 if the constructors are built in a    separate section by the linker), followed by the pointers to the    constructor functions, terminated with a null pointer.  The    destructor table has the same format, and begins at __DTOR_LIST__.  */
end_comment

begin_function
specifier|static
name|void
name|scan_prog_file
parameter_list|(
name|prog_name
parameter_list|,
name|which_pass
parameter_list|)
name|char
modifier|*
name|prog_name
decl_stmt|;
name|enum
name|pass
name|which_pass
decl_stmt|;
block|{
name|char
modifier|*
name|obj
decl_stmt|;
name|mo_header_t
name|hdr
decl_stmt|;
name|load_all_t
modifier|*
name|load_array
decl_stmt|;
name|load_all_t
modifier|*
name|load_end
decl_stmt|;
name|load_all_t
modifier|*
name|load_cmd
decl_stmt|;
name|int
name|symbol_load_cmds
decl_stmt|;
name|off_t
name|offset
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|num_syms
decl_stmt|;
name|int
name|status
decl_stmt|;
name|char
modifier|*
name|str_sect
decl_stmt|;
name|struct
name|file_info
modifier|*
name|obj_file
decl_stmt|;
name|int
name|prog_fd
decl_stmt|;
name|mo_lcid_t
name|cmd_strings
init|=
operator|-
literal|1
decl_stmt|;
name|symbol_info_t
modifier|*
name|main_sym
init|=
literal|0
decl_stmt|;
name|int
name|rw
init|=
operator|(
name|which_pass
operator|!=
name|PASS_FIRST
operator|)
decl_stmt|;
name|prog_fd
operator|=
name|open
argument_list|(
name|prog_name
argument_list|,
operator|(
name|rw
operator|)
condition|?
name|O_RDWR
else|:
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|prog_fd
operator|<
literal|0
condition|)
name|fatal_perror
argument_list|(
literal|"open %s"
argument_list|,
name|prog_name
argument_list|)
expr_stmt|;
name|obj_file
operator|=
name|read_file
argument_list|(
name|prog_name
argument_list|,
name|prog_fd
argument_list|,
name|rw
argument_list|)
expr_stmt|;
name|obj
operator|=
name|obj_file
operator|->
name|start
expr_stmt|;
name|status
operator|=
name|decode_mach_o_hdr
argument_list|(
name|obj
argument_list|,
name|MO_SIZEOF_RAW_HDR
argument_list|,
name|MOH_HEADER_VERSION
argument_list|,
operator|&
name|hdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|MO_HDR_CONV_SUCCESS
condition|)
name|bad_header
argument_list|(
name|status
argument_list|)
expr_stmt|;
comment|/* Do some basic sanity checks.  Note we explicitly use the big endian magic number,      since the hardware will automatically swap bytes for us on loading little endian      integers.  */
ifndef|#
directive|ifndef
name|CROSS_COMPILE
if|if
condition|(
name|hdr
operator|.
name|moh_magic
operator|!=
name|MOH_MAGIC_MSB
operator|||
name|hdr
operator|.
name|moh_header_version
operator|!=
name|MOH_HEADER_VERSION
operator|||
name|hdr
operator|.
name|moh_byte_order
operator|!=
name|OUR_BYTE_ORDER
operator|||
name|hdr
operator|.
name|moh_data_rep_id
operator|!=
name|OUR_DATA_REP_ID
operator|||
name|hdr
operator|.
name|moh_cpu_type
operator|!=
name|OUR_CPU_TYPE
operator|||
name|hdr
operator|.
name|moh_cpu_subtype
operator|!=
name|OUR_CPU_SUBTYPE
operator|||
name|hdr
operator|.
name|moh_vendor_type
operator|!=
name|OUR_VENDOR_TYPE
condition|)
block|{
name|fatal
argument_list|(
literal|"incompatibilities between object file& expected values"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|debug
condition|)
name|print_header
argument_list|(
operator|&
name|hdr
argument_list|)
expr_stmt|;
name|offset
operator|=
name|hdr
operator|.
name|moh_first_cmd_off
expr_stmt|;
name|load_end
operator|=
name|load_array
operator|=
operator|(
name|load_all_t
operator|*
operator|)
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|load_all_t
argument_list|)
argument_list|,
name|hdr
operator|.
name|moh_n_load_cmds
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* Build array of load commands, calculating the offsets */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hdr
operator|.
name|moh_n_load_cmds
condition|;
name|i
operator|++
control|)
block|{
name|load_union_t
modifier|*
name|load_hdr
decl_stmt|;
comment|/* load command header */
name|load_cmd
operator|=
name|load_end
operator|++
expr_stmt|;
name|load_hdr
operator|=
operator|(
name|load_union_t
operator|*
operator|)
operator|(
name|obj
operator|+
name|offset
operator|)
expr_stmt|;
comment|/* If modifying the program file, copy the header.  */
if|if
condition|(
name|rw
condition|)
block|{
name|load_union_t
modifier|*
name|ptr
init|=
operator|(
name|load_union_t
operator|*
operator|)
name|xmalloc
argument_list|(
name|load_hdr
operator|->
name|hdr
operator|.
name|ldci_cmd_size
argument_list|)
decl_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|load_hdr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ptr
argument_list|,
name|load_hdr
operator|->
name|hdr
operator|.
name|ldci_cmd_size
argument_list|)
expr_stmt|;
name|load_hdr
operator|=
name|ptr
expr_stmt|;
comment|/* null out old command map, because we will rewrite at the end.  */
if|if
condition|(
name|ptr
operator|->
name|hdr
operator|.
name|ldci_cmd_type
operator|==
name|LDC_CMD_MAP
condition|)
block|{
name|cmd_strings
operator|=
name|ptr
operator|->
name|map
operator|.
name|lcm_ld_cmd_strings
expr_stmt|;
name|ptr
operator|->
name|hdr
operator|.
name|ldci_cmd_type
operator|=
name|LDC_UNDEFINED
expr_stmt|;
block|}
block|}
name|load_cmd
operator|->
name|load
operator|=
name|load_hdr
expr_stmt|;
if|if
condition|(
name|load_hdr
operator|->
name|hdr
operator|.
name|ldci_section_off
operator|>
literal|0
condition|)
name|load_cmd
operator|->
name|section
operator|=
name|obj
operator|+
name|load_hdr
operator|->
name|hdr
operator|.
name|ldci_section_off
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|print_load_command
argument_list|(
name|load_hdr
argument_list|,
name|offset
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|load_hdr
operator|->
name|hdr
operator|.
name|ldci_cmd_size
expr_stmt|;
block|}
comment|/* If the last command is the load command map and is not undefined,      decrement the count of load commands.  */
if|if
condition|(
name|rw
operator|&&
name|load_end
index|[
operator|-
literal|1
index|]
operator|.
name|load
operator|->
name|hdr
operator|.
name|ldci_cmd_type
operator|==
name|LDC_UNDEFINED
condition|)
block|{
name|load_end
operator|--
expr_stmt|;
name|hdr
operator|.
name|moh_n_load_cmds
operator|--
expr_stmt|;
block|}
comment|/* Go through and process each symbol table section.  */
name|symbol_load_cmds
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|load_cmd
operator|=
name|load_array
init|;
name|load_cmd
operator|<
name|load_end
condition|;
name|load_cmd
operator|++
control|)
block|{
name|load_union_t
modifier|*
name|load_hdr
init|=
name|load_cmd
operator|->
name|load
decl_stmt|;
if|if
condition|(
name|load_hdr
operator|->
name|hdr
operator|.
name|ldci_cmd_type
operator|==
name|LDC_SYMBOLS
condition|)
block|{
name|symbol_load_cmds
operator|++
expr_stmt|;
if|if
condition|(
name|debug
condition|)
block|{
name|char
modifier|*
name|kind
init|=
literal|"unknown"
decl_stmt|;
switch|switch
condition|(
name|load_hdr
operator|->
name|sym
operator|.
name|symc_kind
condition|)
block|{
case|case
name|SYMC_IMPORTS
case|:
name|kind
operator|=
literal|"imports"
expr_stmt|;
break|break;
case|case
name|SYMC_DEFINED_SYMBOLS
case|:
name|kind
operator|=
literal|"defined"
expr_stmt|;
break|break;
case|case
name|SYMC_STABS
case|:
name|kind
operator|=
literal|"stabs"
expr_stmt|;
break|break;
block|}
name|notice
argument_list|(
literal|"\nProcessing symbol table #%d, offset = 0x%.8lx, kind = %s\n"
argument_list|,
name|symbol_load_cmds
argument_list|,
name|load_hdr
operator|->
name|hdr
operator|.
name|ldci_section_off
argument_list|,
name|kind
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|load_hdr
operator|->
name|sym
operator|.
name|symc_kind
operator|!=
name|SYMC_DEFINED_SYMBOLS
condition|)
continue|continue;
name|str_sect
operator|=
name|load_array
index|[
name|load_hdr
operator|->
name|sym
operator|.
name|symc_strings_section
index|]
operator|.
name|section
expr_stmt|;
if|if
condition|(
name|str_sect
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
name|fatal
argument_list|(
literal|"string section missing"
argument_list|)
expr_stmt|;
if|if
condition|(
name|load_cmd
operator|->
name|section
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
name|fatal
argument_list|(
literal|"section pointer missing"
argument_list|)
expr_stmt|;
name|num_syms
operator|=
name|load_hdr
operator|->
name|sym
operator|.
name|symc_nentries
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_syms
condition|;
name|i
operator|++
control|)
block|{
name|symbol_info_t
modifier|*
name|sym
init|=
operator|(
operator|(
name|symbol_info_t
operator|*
operator|)
name|load_cmd
operator|->
name|section
operator|)
operator|+
name|i
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|sym
operator|->
name|si_name
operator|.
name|symbol_name
operator|+
name|str_sect
decl_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|!=
literal|'_'
condition|)
continue|continue;
if|if
condition|(
name|rw
condition|)
block|{
name|char
modifier|*
name|n
init|=
name|name
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
operator|-
name|strlen
argument_list|(
name|NAME__MAIN
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|n
operator|-
name|name
operator|)
operator|<
literal|0
operator|||
name|strcmp
argument_list|(
name|n
argument_list|,
name|NAME__MAIN
argument_list|)
condition|)
continue|continue;
while|while
condition|(
name|n
operator|!=
name|name
condition|)
if|if
condition|(
operator|*
operator|--
name|n
operator|!=
literal|'_'
condition|)
continue|continue;
name|main_sym
operator|=
name|sym
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|is_ctor_dtor
argument_list|(
name|name
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
name|add_to_list
argument_list|(
operator|&
name|constructors
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|add_to_list
argument_list|(
operator|&
name|destructors
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* not a constructor or destructor */
continue|continue;
block|}
block|}
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ttype = 0x%.4x, sc = 0x%.2x, flags = 0x%.8x, name = %.30s\n"
argument_list|,
name|sym
operator|->
name|si_type
argument_list|,
name|sym
operator|->
name|si_sc_type
argument_list|,
name|sym
operator|->
name|si_flags
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|symbol_load_cmds
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"no symbol table found"
argument_list|)
expr_stmt|;
comment|/* Update the program file now, rewrite header and load commands.  At present,      we assume that there is enough space after the last load command to insert      one more.  Since the first section written out is page aligned, and the      number of load commands is small, this is ok for the present.  */
if|if
condition|(
name|rw
condition|)
block|{
name|load_union_t
modifier|*
name|load_map
decl_stmt|;
name|size_t
name|size
decl_stmt|;
if|if
condition|(
name|cmd_strings
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|"no cmd_strings found"
argument_list|)
expr_stmt|;
comment|/* Add __main to initializer list. 	 If we are building a program instead of a shared library, do not 	 do anything, since in the current version, you cannot do mallocs 	 and such in the constructors.  */
if|if
condition|(
name|main_sym
operator|!=
operator|(
name|symbol_info_t
operator|*
operator|)
literal|0
operator|&&
operator|(
operator|(
name|hdr
operator|.
name|moh_flags
operator|&
name|MOH_EXECABLE_F
operator|)
operator|==
literal|0
operator|)
condition|)
name|add_func_table
argument_list|(
operator|&
name|hdr
argument_list|,
name|load_array
argument_list|,
name|main_sym
argument_list|,
name|FNTC_INITIALIZATION
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|notice
argument_list|(
literal|"\nUpdating header and load commands.\n\n"
argument_list|)
expr_stmt|;
name|hdr
operator|.
name|moh_n_load_cmds
operator|++
expr_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
name|load_cmd_map_command_t
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|mo_offset_t
argument_list|)
operator|*
operator|(
name|hdr
operator|.
name|moh_n_load_cmds
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
comment|/* Create new load command map.  */
if|if
condition|(
name|debug
condition|)
name|notice
argument_list|(
literal|"load command map, %d cmds, new size %ld.\n"
argument_list|,
operator|(
name|int
operator|)
name|hdr
operator|.
name|moh_n_load_cmds
argument_list|,
operator|(
name|long
operator|)
name|size
argument_list|)
expr_stmt|;
name|load_map
operator|=
operator|(
name|load_union_t
operator|*
operator|)
name|xcalloc
argument_list|(
literal|1
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|load_map
operator|->
name|map
operator|.
name|ldc_header
operator|.
name|ldci_cmd_type
operator|=
name|LDC_CMD_MAP
expr_stmt|;
name|load_map
operator|->
name|map
operator|.
name|ldc_header
operator|.
name|ldci_cmd_size
operator|=
name|size
expr_stmt|;
name|load_map
operator|->
name|map
operator|.
name|lcm_ld_cmd_strings
operator|=
name|cmd_strings
expr_stmt|;
name|load_map
operator|->
name|map
operator|.
name|lcm_nentries
operator|=
name|hdr
operator|.
name|moh_n_load_cmds
expr_stmt|;
name|load_array
index|[
name|hdr
operator|.
name|moh_n_load_cmds
operator|-
literal|1
index|]
operator|.
name|load
operator|=
name|load_map
expr_stmt|;
name|offset
operator|=
name|hdr
operator|.
name|moh_first_cmd_off
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hdr
operator|.
name|moh_n_load_cmds
condition|;
name|i
operator|++
control|)
block|{
name|load_map
operator|->
name|map
operator|.
name|lcm_map
index|[
name|i
index|]
operator|=
name|offset
expr_stmt|;
if|if
condition|(
name|load_array
index|[
name|i
index|]
operator|.
name|load
operator|->
name|hdr
operator|.
name|ldci_cmd_type
operator|==
name|LDC_CMD_MAP
condition|)
name|hdr
operator|.
name|moh_load_map_cmd_off
operator|=
name|offset
expr_stmt|;
name|offset
operator|+=
name|load_array
index|[
name|i
index|]
operator|.
name|load
operator|->
name|hdr
operator|.
name|ldci_cmd_size
expr_stmt|;
block|}
name|hdr
operator|.
name|moh_sizeofcmds
operator|=
name|offset
operator|-
name|MO_SIZEOF_RAW_HDR
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|print_header
argument_list|(
operator|&
name|hdr
argument_list|)
expr_stmt|;
comment|/* Write header */
name|status
operator|=
name|encode_mach_o_hdr
argument_list|(
operator|&
name|hdr
argument_list|,
name|obj
argument_list|,
name|MO_SIZEOF_RAW_HDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|MO_HDR_CONV_SUCCESS
condition|)
name|bad_header
argument_list|(
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|notice
argument_list|(
literal|"writing load commands.\n\n"
argument_list|)
expr_stmt|;
comment|/* Write load commands */
name|offset
operator|=
name|hdr
operator|.
name|moh_first_cmd_off
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hdr
operator|.
name|moh_n_load_cmds
condition|;
name|i
operator|++
control|)
block|{
name|load_union_t
modifier|*
name|load_hdr
init|=
name|load_array
index|[
name|i
index|]
operator|.
name|load
decl_stmt|;
name|size_t
name|size
init|=
name|load_hdr
operator|->
name|hdr
operator|.
name|ldci_cmd_size
decl_stmt|;
if|if
condition|(
name|debug
condition|)
name|print_load_command
argument_list|(
name|load_hdr
argument_list|,
name|offset
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|load_hdr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|obj
operator|+
name|offset
operator|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|size
expr_stmt|;
block|}
block|}
name|end_file
argument_list|(
name|obj_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|prog_fd
argument_list|)
condition|)
name|fatal_perror
argument_list|(
literal|"close %s"
argument_list|,
name|prog_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add a function table to the load commands to call a function    on initiation or termination of the process.  */
end_comment

begin_function
specifier|static
name|void
name|add_func_table
parameter_list|(
name|hdr_p
parameter_list|,
name|load_array
parameter_list|,
name|sym
parameter_list|,
name|type
parameter_list|)
name|mo_header_t
modifier|*
name|hdr_p
decl_stmt|;
comment|/* pointer to global header */
name|load_all_t
modifier|*
name|load_array
decl_stmt|;
comment|/* array of ptrs to load cmds */
name|symbol_info_t
modifier|*
name|sym
decl_stmt|;
comment|/* pointer to symbol entry */
name|int
name|type
decl_stmt|;
comment|/* fntc_type value */
block|{
comment|/* Add a new load command.  */
name|int
name|num_cmds
init|=
operator|++
name|hdr_p
operator|->
name|moh_n_load_cmds
decl_stmt|;
name|int
name|load_index
init|=
name|num_cmds
operator|-
literal|1
decl_stmt|;
name|size_t
name|size
init|=
sizeof|sizeof
argument_list|(
name|func_table_command_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|mo_addr_t
argument_list|)
decl_stmt|;
name|load_union_t
modifier|*
name|ptr
init|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
name|size
argument_list|)
decl_stmt|;
name|load_all_t
modifier|*
name|load_cmd
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Set the unresolved address bit in the header to force the loader to be      used, since kernel exec does not call the initialization functions.  */
name|hdr_p
operator|->
name|moh_flags
operator||=
name|MOH_UNRESOLVED_F
expr_stmt|;
name|load_cmd
operator|=
operator|&
name|load_array
index|[
name|load_index
index|]
expr_stmt|;
name|load_cmd
operator|->
name|load
operator|=
name|ptr
expr_stmt|;
name|load_cmd
operator|->
name|section
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* Fill in func table load command.  */
name|ptr
operator|->
name|func
operator|.
name|ldc_header
operator|.
name|ldci_cmd_type
operator|=
name|LDC_FUNC_TABLE
expr_stmt|;
name|ptr
operator|->
name|func
operator|.
name|ldc_header
operator|.
name|ldci_cmd_size
operator|=
name|size
expr_stmt|;
name|ptr
operator|->
name|func
operator|.
name|ldc_header
operator|.
name|ldci_section_off
operator|=
literal|0
expr_stmt|;
name|ptr
operator|->
name|func
operator|.
name|ldc_header
operator|.
name|ldci_section_len
operator|=
literal|0
expr_stmt|;
name|ptr
operator|->
name|func
operator|.
name|fntc_type
operator|=
name|type
expr_stmt|;
name|ptr
operator|->
name|func
operator|.
name|fntc_nentries
operator|=
literal|1
expr_stmt|;
comment|/* copy address, turn it from abs. address to (region,offset) if necessary.  */
comment|/* Is the symbol already expressed as (region, offset)?  */
if|if
condition|(
operator|(
name|sym
operator|->
name|si_flags
operator|&
name|SI_ABSOLUTE_VALUE_F
operator|)
operator|==
literal|0
condition|)
block|{
name|ptr
operator|->
name|func
operator|.
name|fntc_entry_loc
index|[
name|i
index|]
operator|.
name|adr_lcid
operator|=
name|sym
operator|->
name|si_value
operator|.
name|def_val
operator|.
name|adr_lcid
expr_stmt|;
name|ptr
operator|->
name|func
operator|.
name|fntc_entry_loc
index|[
name|i
index|]
operator|.
name|adr_sctoff
operator|=
name|sym
operator|->
name|si_value
operator|.
name|def_val
operator|.
name|adr_sctoff
expr_stmt|;
block|}
comment|/* If not, figure out which region it's in.  */
else|else
block|{
name|mo_vm_addr_t
name|addr
init|=
name|sym
operator|->
name|si_value
operator|.
name|abs_val
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|load_index
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|load_array
index|[
name|i
index|]
operator|.
name|load
operator|->
name|hdr
operator|.
name|ldci_cmd_type
operator|==
name|LDC_REGION
condition|)
block|{
name|region_command_t
modifier|*
name|region_ptr
init|=
operator|&
name|load_array
index|[
name|i
index|]
operator|.
name|load
operator|->
name|region
decl_stmt|;
if|if
condition|(
operator|(
name|region_ptr
operator|->
name|regc_flags
operator|&
name|REG_ABS_ADDR_F
operator|)
operator|!=
literal|0
operator|&&
name|addr
operator|>=
name|region_ptr
operator|->
name|regc_addr
operator|.
name|vm_addr
operator|&&
name|addr
operator|<=
name|region_ptr
operator|->
name|regc_addr
operator|.
name|vm_addr
operator|+
name|region_ptr
operator|->
name|regc_vm_size
condition|)
block|{
name|ptr
operator|->
name|func
operator|.
name|fntc_entry_loc
index|[
literal|0
index|]
operator|.
name|adr_lcid
operator|=
name|i
expr_stmt|;
name|ptr
operator|->
name|func
operator|.
name|fntc_entry_loc
index|[
literal|0
index|]
operator|.
name|adr_sctoff
operator|=
name|addr
operator|-
name|region_ptr
operator|->
name|regc_addr
operator|.
name|vm_addr
expr_stmt|;
name|found
operator|++
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
name|fatal
argument_list|(
literal|"could not convert 0x%l.8x into a region"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|debug
condition|)
name|notice
argument_list|(
literal|"%s function, region %d, offset = %ld (0x%.8lx)\n"
argument_list|,
name|type
operator|==
name|FNTC_INITIALIZATION
condition|?
literal|"init"
else|:
literal|"term"
argument_list|,
operator|(
name|int
operator|)
name|ptr
operator|->
name|func
operator|.
name|fntc_entry_loc
index|[
name|i
index|]
operator|.
name|adr_lcid
argument_list|,
operator|(
name|long
operator|)
name|ptr
operator|->
name|func
operator|.
name|fntc_entry_loc
index|[
name|i
index|]
operator|.
name|adr_sctoff
argument_list|,
operator|(
name|long
operator|)
name|ptr
operator|->
name|func
operator|.
name|fntc_entry_loc
index|[
name|i
index|]
operator|.
name|adr_sctoff
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print the global header for an OSF/rose object.  */
end_comment

begin_function
specifier|static
name|void
name|print_header
parameter_list|(
name|hdr_ptr
parameter_list|)
name|mo_header_t
modifier|*
name|hdr_ptr
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nglobal header:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tmoh_magic            = 0x%.8lx\n"
argument_list|,
name|hdr_ptr
operator|->
name|moh_magic
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tmoh_major_version    = %d\n"
argument_list|,
operator|(
name|int
operator|)
name|hdr_ptr
operator|->
name|moh_major_version
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tmoh_minor_version    = %d\n"
argument_list|,
operator|(
name|int
operator|)
name|hdr_ptr
operator|->
name|moh_minor_version
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tmoh_header_version   = %d\n"
argument_list|,
operator|(
name|int
operator|)
name|hdr_ptr
operator|->
name|moh_header_version
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tmoh_max_page_size    = %d\n"
argument_list|,
operator|(
name|int
operator|)
name|hdr_ptr
operator|->
name|moh_max_page_size
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tmoh_byte_order       = %d\n"
argument_list|,
operator|(
name|int
operator|)
name|hdr_ptr
operator|->
name|moh_byte_order
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tmoh_data_rep_id      = %d\n"
argument_list|,
operator|(
name|int
operator|)
name|hdr_ptr
operator|->
name|moh_data_rep_id
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tmoh_cpu_type         = %d\n"
argument_list|,
operator|(
name|int
operator|)
name|hdr_ptr
operator|->
name|moh_cpu_type
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tmoh_cpu_subtype      = %d\n"
argument_list|,
operator|(
name|int
operator|)
name|hdr_ptr
operator|->
name|moh_cpu_subtype
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tmoh_vendor_type      = %d\n"
argument_list|,
operator|(
name|int
operator|)
name|hdr_ptr
operator|->
name|moh_vendor_type
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tmoh_load_map_cmd_off = %d\n"
argument_list|,
operator|(
name|int
operator|)
name|hdr_ptr
operator|->
name|moh_load_map_cmd_off
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tmoh_first_cmd_off    = %d\n"
argument_list|,
operator|(
name|int
operator|)
name|hdr_ptr
operator|->
name|moh_first_cmd_off
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tmoh_sizeofcmds       = %d\n"
argument_list|,
operator|(
name|int
operator|)
name|hdr_ptr
operator|->
name|moh_sizeofcmds
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tmon_n_load_cmds      = %d\n"
argument_list|,
operator|(
name|int
operator|)
name|hdr_ptr
operator|->
name|moh_n_load_cmds
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tmoh_flags            = 0x%.8lx"
argument_list|,
operator|(
name|long
operator|)
name|hdr_ptr
operator|->
name|moh_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr_ptr
operator|->
name|moh_flags
operator|&
name|MOH_RELOCATABLE_F
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|", relocatable"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr_ptr
operator|->
name|moh_flags
operator|&
name|MOH_LINKABLE_F
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|", linkable"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr_ptr
operator|->
name|moh_flags
operator|&
name|MOH_EXECABLE_F
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|", execable"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr_ptr
operator|->
name|moh_flags
operator|&
name|MOH_EXECUTABLE_F
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|", executable"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr_ptr
operator|->
name|moh_flags
operator|&
name|MOH_UNRESOLVED_F
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|", unresolved"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print a short summary of a load command.  */
end_comment

begin_function
specifier|static
name|void
name|print_load_command
parameter_list|(
name|load_hdr
parameter_list|,
name|offset
parameter_list|,
name|number
parameter_list|)
name|load_union_t
modifier|*
name|load_hdr
decl_stmt|;
name|size_t
name|offset
decl_stmt|;
name|int
name|number
decl_stmt|;
block|{
name|mo_long_t
name|type
init|=
name|load_hdr
operator|->
name|hdr
operator|.
name|ldci_cmd_type
decl_stmt|;
name|char
modifier|*
name|type_str
init|=
operator|(
name|char
operator|*
operator|)
literal|0
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|LDC_UNDEFINED
case|:
name|type_str
operator|=
literal|"UNDEFINED"
expr_stmt|;
break|break;
case|case
name|LDC_CMD_MAP
case|:
name|type_str
operator|=
literal|"CMD_MAP"
expr_stmt|;
break|break;
case|case
name|LDC_INTERPRETER
case|:
name|type_str
operator|=
literal|"INTERPRETER"
expr_stmt|;
break|break;
case|case
name|LDC_STRINGS
case|:
name|type_str
operator|=
literal|"STRINGS"
expr_stmt|;
break|break;
case|case
name|LDC_REGION
case|:
name|type_str
operator|=
literal|"REGION"
expr_stmt|;
break|break;
case|case
name|LDC_RELOC
case|:
name|type_str
operator|=
literal|"RELOC"
expr_stmt|;
break|break;
case|case
name|LDC_PACKAGE
case|:
name|type_str
operator|=
literal|"PACKAGE"
expr_stmt|;
break|break;
case|case
name|LDC_SYMBOLS
case|:
name|type_str
operator|=
literal|"SYMBOLS"
expr_stmt|;
break|break;
case|case
name|LDC_ENTRY
case|:
name|type_str
operator|=
literal|"ENTRY"
expr_stmt|;
break|break;
case|case
name|LDC_FUNC_TABLE
case|:
name|type_str
operator|=
literal|"FUNC_TABLE"
expr_stmt|;
break|break;
case|case
name|LDC_GEN_INFO
case|:
name|type_str
operator|=
literal|"GEN_INFO"
expr_stmt|;
break|break;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"cmd %2d, sz: 0x%.2lx, coff: 0x%.3lx, doff: 0x%.6lx, dlen: 0x%.6lx"
argument_list|,
name|number
argument_list|,
operator|(
name|long
operator|)
name|load_hdr
operator|->
name|hdr
operator|.
name|ldci_cmd_size
argument_list|,
operator|(
name|long
operator|)
name|offset
argument_list|,
operator|(
name|long
operator|)
name|load_hdr
operator|->
name|hdr
operator|.
name|ldci_section_off
argument_list|,
operator|(
name|long
operator|)
name|load_hdr
operator|->
name|hdr
operator|.
name|ldci_section_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|type_str
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|", ty: unknown (%ld)\n"
argument_list|,
operator|(
name|long
operator|)
name|type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|!=
name|LDC_REGION
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|", ty: %s\n"
argument_list|,
name|type_str
argument_list|)
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|region
init|=
literal|""
decl_stmt|;
switch|switch
condition|(
name|load_hdr
operator|->
name|region
operator|.
name|regc_usage_type
condition|)
block|{
case|case
name|REG_TEXT_T
case|:
name|region
operator|=
literal|", .text"
expr_stmt|;
break|break;
case|case
name|REG_DATA_T
case|:
name|region
operator|=
literal|", .data"
expr_stmt|;
break|break;
case|case
name|REG_BSS_T
case|:
name|region
operator|=
literal|", .bss"
expr_stmt|;
break|break;
case|case
name|REG_GLUE_T
case|:
name|region
operator|=
literal|", .glue"
expr_stmt|;
break|break;
if|#
directive|if
name|defined
argument_list|(
name|REG_RDATA_T
argument_list|)
operator|&&
name|defined
argument_list|(
name|REG_SDATA_T
argument_list|)
operator|&&
name|defined
argument_list|(
name|REG_SBSS_T
argument_list|)
comment|/*mips*/
case|case
name|REG_RDATA_T
case|:
name|region
operator|=
literal|", .rdata"
expr_stmt|;
break|break;
case|case
name|REG_SDATA_T
case|:
name|region
operator|=
literal|", .sdata"
expr_stmt|;
break|break;
case|case
name|REG_SBSS_T
case|:
name|region
operator|=
literal|", .sbss"
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|", ty: %s, vaddr: 0x%.8lx, vlen: 0x%.6lx%s\n"
argument_list|,
name|type_str
argument_list|,
operator|(
name|long
operator|)
name|load_hdr
operator|->
name|region
operator|.
name|regc_vm_addr
argument_list|,
operator|(
name|long
operator|)
name|load_hdr
operator|->
name|region
operator|.
name|regc_vm_size
argument_list|,
name|region
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Fatal error when {en,de}code_mach_o_header fails.  */
end_comment

begin_function
specifier|static
name|void
name|bad_header
parameter_list|(
name|status
parameter_list|)
name|int
name|status
decl_stmt|;
block|{
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|MO_ERROR_BAD_MAGIC
case|:
name|fatal
argument_list|(
literal|"bad magic number"
argument_list|)
expr_stmt|;
case|case
name|MO_ERROR_BAD_HDR_VERS
case|:
name|fatal
argument_list|(
literal|"bad header version"
argument_list|)
expr_stmt|;
case|case
name|MO_ERROR_BAD_RAW_HDR_VERS
case|:
name|fatal
argument_list|(
literal|"bad raw header version"
argument_list|)
expr_stmt|;
case|case
name|MO_ERROR_BUF2SML
case|:
name|fatal
argument_list|(
literal|"raw header buffer too small"
argument_list|)
expr_stmt|;
case|case
name|MO_ERROR_OLD_RAW_HDR_FILE
case|:
name|fatal
argument_list|(
literal|"old raw header file"
argument_list|)
expr_stmt|;
case|case
name|MO_ERROR_UNSUPPORTED_VERS
case|:
name|fatal
argument_list|(
literal|"unsupported version"
argument_list|)
expr_stmt|;
default|default:
name|fatal
argument_list|(
literal|"unknown {de,en}code_mach_o_hdr return value %d"
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read a file into a memory buffer.  */
end_comment

begin_function
specifier|static
name|struct
name|file_info
modifier|*
name|read_file
parameter_list|(
name|name
parameter_list|,
name|fd
parameter_list|,
name|rw
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
comment|/* filename */
name|int
name|fd
decl_stmt|;
comment|/* file descriptor */
name|int
name|rw
decl_stmt|;
comment|/* read/write */
block|{
name|struct
name|stat
name|stat_pkt
decl_stmt|;
name|struct
name|file_info
modifier|*
name|p
init|=
operator|(
expr|struct
name|file_info
operator|*
operator|)
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|file_info
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_MMAP
specifier|static
name|int
name|page_size
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|stat_pkt
argument_list|)
operator|<
literal|0
condition|)
name|fatal_perror
argument_list|(
literal|"fstat %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|p
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|p
operator|->
name|size
operator|=
name|stat_pkt
operator|.
name|st_size
expr_stmt|;
name|p
operator|->
name|rounded_size
operator|=
name|stat_pkt
operator|.
name|st_size
expr_stmt|;
name|p
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
name|p
operator|->
name|rw
operator|=
name|rw
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_MMAP
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"mmap %s, %s\n"
argument_list|,
name|name
argument_list|,
operator|(
name|rw
operator|)
condition|?
literal|"read/write"
else|:
literal|"read-only"
argument_list|)
expr_stmt|;
if|if
condition|(
name|page_size
operator|==
literal|0
condition|)
name|page_size
operator|=
name|sysconf
argument_list|(
name|_SC_PAGE_SIZE
argument_list|)
expr_stmt|;
name|p
operator|->
name|rounded_size
operator|=
operator|(
operator|(
name|p
operator|->
name|size
operator|+
name|page_size
operator|-
literal|1
operator|)
operator|/
name|page_size
operator|)
operator|*
name|page_size
expr_stmt|;
name|p
operator|->
name|start
operator|=
name|mmap
argument_list|(
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
operator|(
name|rw
operator|)
condition|?
name|p
operator|->
name|rounded_size
else|:
name|p
operator|->
name|size
argument_list|,
operator|(
name|rw
operator|)
condition|?
operator|(
name|PROT_READ
operator||
name|PROT_WRITE
operator|)
else|:
name|PROT_READ
argument_list|,
name|MAP_FILE
operator||
name|MAP_VARIABLE
operator||
name|MAP_SHARED
argument_list|,
name|fd
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|start
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
operator|&&
name|p
operator|->
name|start
operator|!=
operator|(
name|char
operator|*
operator|)
operator|-
literal|1
condition|)
name|p
operator|->
name|use_mmap
operator|=
literal|1
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* USE_MMAP */
block|{
name|long
name|len
decl_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"read %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|p
operator|->
name|use_mmap
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|start
operator|=
name|xmalloc
argument_list|(
name|p
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|fd
argument_list|,
literal|0L
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
name|fatal_perror
argument_list|(
literal|"lseek %s 0"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|len
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|p
operator|->
name|start
argument_list|,
name|p
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
name|fatal_perror
argument_list|(
literal|"read %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|!=
name|p
operator|->
name|size
condition|)
name|fatal
argument_list|(
literal|"read %ld bytes, expected %ld, from %s"
argument_list|,
name|len
argument_list|,
name|p
operator|->
name|size
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Do anything necessary to write a file back from memory.  */
end_comment

begin_function
specifier|static
name|void
name|end_file
parameter_list|(
name|ptr
parameter_list|)
name|struct
name|file_info
modifier|*
name|ptr
decl_stmt|;
comment|/* file information block */
block|{
ifdef|#
directive|ifdef
name|USE_MMAP
if|if
condition|(
name|ptr
operator|->
name|use_mmap
condition|)
block|{
if|if
condition|(
name|ptr
operator|->
name|rw
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"msync %s\n"
argument_list|,
name|ptr
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|msync
argument_list|(
name|ptr
operator|->
name|start
argument_list|,
name|ptr
operator|->
name|rounded_size
argument_list|,
name|MS_ASYNC
argument_list|)
condition|)
name|fatal_perror
argument_list|(
literal|"msync %s"
argument_list|,
name|ptr
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"munmap %s\n"
argument_list|,
name|ptr
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|munmap
argument_list|(
name|ptr
operator|->
name|start
argument_list|,
name|ptr
operator|->
name|size
argument_list|)
condition|)
name|fatal_perror
argument_list|(
literal|"munmap %s"
argument_list|,
name|ptr
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* USE_MMAP */
block|{
if|if
condition|(
name|ptr
operator|->
name|rw
condition|)
block|{
name|long
name|len
decl_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"write %s\n"
argument_list|,
name|ptr
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|ptr
operator|->
name|fd
argument_list|,
literal|0L
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
name|fatal_perror
argument_list|(
literal|"lseek %s 0"
argument_list|,
name|ptr
operator|->
name|name
argument_list|)
expr_stmt|;
name|len
operator|=
name|write
argument_list|(
name|ptr
operator|->
name|fd
argument_list|,
name|ptr
operator|->
name|start
argument_list|,
name|ptr
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
name|fatal_perror
argument_list|(
literal|"write %s"
argument_list|,
name|ptr
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|!=
name|ptr
operator|->
name|size
condition|)
name|fatal
argument_list|(
literal|"wrote %ld bytes, expected %ld, to %s"
argument_list|,
name|len
argument_list|,
name|ptr
operator|->
name|size
argument_list|,
name|ptr
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|ptr
operator|->
name|start
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJECT_FORMAT_ROSE */
end_comment

end_unit

