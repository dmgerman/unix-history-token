begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Collect static initialization info into data structures    that can be traversed by C++ initialization and finalization    routines.     Copyright (C) 1992, 1993, 1994, 1995 Free Software Foundation, Inc.    Contributed by Chris Smith (csmith@convex.com).    Heavily modified by Michael Meissner (meissner@cygnus.com),    Per Bothner (bothner@cygnus.com), and John Gilmore (gnu@cygnus.com).  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* Build tables of static constructors and destructors and run ld. */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|NO_WAIT_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|COLLECT
end_define

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|errno
end_ifndef

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_STRERROR
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|bsd4_4
argument_list|)
end_if

begin_decl_stmt
specifier|extern
specifier|const
name|char
modifier|*
specifier|const
name|sys_errlist
index|[]
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|sys_errlist
index|[]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|int
name|sys_nerr
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_function_decl
name|char
modifier|*
name|strerror
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Obstack allocation and deallocation routines.  */
end_comment

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__STDC__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
specifier|const
argument_list|)
end_if

begin_define
define|#
directive|define
name|const
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_define
define|#
directive|define
name|vfork
value|fork
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Add prototype support.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PROTO
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USE_PROTOTYPES
argument_list|)
condition|?
name|USE_PROTOTYPES
expr|:
name|defined
argument_list|(
name|__STDC__
argument_list|)
end_if

begin_define
define|#
directive|define
name|PROTO
parameter_list|(
name|ARGS
parameter_list|)
value|ARGS
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PROTO
parameter_list|(
name|ARGS
parameter_list|)
value|()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|R_OK
end_ifndef

begin_define
define|#
directive|define
name|R_OK
value|4
end_define

begin_define
define|#
directive|define
name|W_OK
value|2
end_define

begin_define
define|#
directive|define
name|X_OK
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WIFSIGNALED
end_ifndef

begin_define
define|#
directive|define
name|WIFSIGNALED
parameter_list|(
name|S
parameter_list|)
value|(((S)& 0xff) != 0&& ((S)& 0xff) != 0x7f)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WTERMSIG
end_ifndef

begin_define
define|#
directive|define
name|WTERMSIG
parameter_list|(
name|S
parameter_list|)
value|((S)& 0x7f)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WIFEXITED
end_ifndef

begin_define
define|#
directive|define
name|WIFEXITED
parameter_list|(
name|S
parameter_list|)
value|(((S)& 0xff) == 0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WEXITSTATUS
end_ifndef

begin_define
define|#
directive|define
name|WEXITSTATUS
parameter_list|(
name|S
parameter_list|)
value|(((S)& 0xff00)>> 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* On MSDOS, write temp files in current dir    because there's no place else we can expect to use.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__MSDOS__
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|P_tmpdir
end_ifndef

begin_define
define|#
directive|define
name|P_tmpdir
value|"./"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* On certain systems, we have code that works by scanning the object file    directly.  But this code uses system-specific header files and library    functions, so turn it off in a cross-compiler.  Likewise, the names of    the utilities aren't correct for a cross-compiler; we have to hope that    cross-versions are in the proper directories.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CROSS_COMPILE
end_ifdef

begin_undef
undef|#
directive|undef
name|SUNOS4_SHARED_LIBRARIES
end_undef

begin_undef
undef|#
directive|undef
name|OBJECT_FORMAT_COFF
end_undef

begin_undef
undef|#
directive|undef
name|OBJECT_FORMAT_ROSE
end_undef

begin_undef
undef|#
directive|undef
name|MD_EXEC_PREFIX
end_undef

begin_undef
undef|#
directive|undef
name|REAL_LD_FILE_NAME
end_undef

begin_undef
undef|#
directive|undef
name|REAL_NM_FILE_NAME
end_undef

begin_undef
undef|#
directive|undef
name|REAL_STRIP_FILE_NAME
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* If we can't use a special method, use the ordinary one:    run nm to find what symbols are present.    In a cross-compiler, this means you need a cross nm,    but that isn't quite as unpleasant as special headers.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|OBJECT_FORMAT_COFF
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|OBJECT_FORMAT_ROSE
argument_list|)
end_if

begin_define
define|#
directive|define
name|OBJECT_FORMAT_NONE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|OBJECT_FORMAT_COFF
end_ifdef

begin_include
include|#
directive|include
file|<a.out.h>
end_include

begin_include
include|#
directive|include
file|<ar.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|UMAX
end_ifdef

begin_include
include|#
directive|include
file|<sgs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Many versions of ldfcn.h define these.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|FREAD
end_ifdef

begin_undef
undef|#
directive|undef
name|FREAD
end_undef

begin_undef
undef|#
directive|undef
name|FWRITE
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<ldfcn.h>
end_include

begin_comment
comment|/* Some systems have an ISCOFF macro, but others do not.  In some cases    the macro may be wrong.  MY_ISCOFF is defined in tm.h files for machines    that either do not have an ISCOFF macro in /usr/include or for those     where it is wrong.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MY_ISCOFF
end_ifndef

begin_define
define|#
directive|define
name|MY_ISCOFF
parameter_list|(
name|X
parameter_list|)
value|ISCOFF (X)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|XCOFF_DEBUGGING_INFO
end_ifdef

begin_define
define|#
directive|define
name|XCOFF_SCAN_LIBS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJECT_FORMAT_COFF */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OBJECT_FORMAT_ROSE
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|_OSF_SOURCE
end_ifdef

begin_define
define|#
directive|define
name|USE_MMAP
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|USE_MMAP
end_ifdef

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<mach_o_format.h>
end_include

begin_include
include|#
directive|include
file|<mach_o_header.h>
end_include

begin_include
include|#
directive|include
file|<mach_o_vals.h>
end_include

begin_include
include|#
directive|include
file|<mach_o_types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJECT_FORMAT_ROSE */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OBJECT_FORMAT_NONE
end_ifdef

begin_comment
comment|/* Default flags to pass to nm.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NM_FLAGS
end_ifndef

begin_define
define|#
directive|define
name|NM_FLAGS
value|"-p"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJECT_FORMAT_NONE */
end_comment

begin_comment
comment|/* Some systems use __main in a way incompatible with its use in gcc, in these    cases use the macros NAME__MAIN to give a quoted symbol and SYMBOL__MAIN to    give the same symbol without quotes for an alternative entry point.  You    must define both, or neither.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NAME__MAIN
end_ifndef

begin_define
define|#
directive|define
name|NAME__MAIN
value|"__main"
end_define

begin_define
define|#
directive|define
name|SYMBOL__MAIN
value|__main
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|LDD_SUFFIX
argument_list|)
operator|||
name|SUNOS4_SHARED_LIBRARIES
operator|||
name|defined
argument_list|(
name|XCOFF_SCAN_LIBS
argument_list|)
end_if

begin_define
define|#
directive|define
name|SCAN_LIBRARIES
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|USE_COLLECT2
end_ifdef

begin_decl_stmt
name|int
name|do_collecting
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|do_collecting
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Linked lists of constructor and destructor names. */
end_comment

begin_struct
struct|struct
name|id
block|{
name|struct
name|id
modifier|*
name|next
decl_stmt|;
name|int
name|sequence
decl_stmt|;
name|char
name|name
index|[
literal|1
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|head
block|{
name|struct
name|id
modifier|*
name|first
decl_stmt|;
name|struct
name|id
modifier|*
name|last
decl_stmt|;
name|int
name|number
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Enumeration giving which pass this is for scanning the program file.  */
end_comment

begin_enum
enum|enum
name|pass
block|{
name|PASS_FIRST
block|,
comment|/* without constructors */
name|PASS_OBJ
block|,
comment|/* individual objects */
name|PASS_LIB
block|,
comment|/* looking for shared libraries */
name|PASS_SECOND
comment|/* with constructors linked in */
block|}
enum|;
end_enum

begin_ifndef
ifndef|#
directive|ifndef
name|NO_SYS_SIGLIST
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|DONT_DECLARE_SYS_SIGLIST
end_ifndef

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|sys_siglist
index|[]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|version_string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|vflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if -v */
end_comment

begin_decl_stmt
specifier|static
name|int
name|rflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if -r */
end_comment

begin_decl_stmt
specifier|static
name|int
name|strip_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if -s */
end_comment

begin_decl_stmt
name|int
name|debug
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if -debug */
end_comment

begin_decl_stmt
specifier|static
name|int
name|shared_obj
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if -shared */
end_comment

begin_decl_stmt
specifier|static
name|int
name|temp_filename_length
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Length of temp_filename */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|temp_filename
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Base of temp filenames */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|c_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*<xxx>.c for constructor/destructor list. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|o_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*<xxx>.o for constructor/destructor list. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|export_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*<xxx>.x for AIX export list. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|auto_export
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if exporting everything. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|ldout
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* File for ld errors.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|output_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Output file for ld.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|nm_file_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pathname of nm */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ldd_file_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pathname of ldd (or equivalent) */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|strip_file_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pathname of strip */
end_comment

begin_decl_stmt
name|char
modifier|*
name|c_file_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pathname of gcc */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|initname
decl_stmt|,
modifier|*
name|fininame
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* names of init and fini funcs */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|head
name|constructors
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of constructors found */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|head
name|destructors
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of destructors found */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|head
name|exports
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of exported symbols */
end_comment

begin_decl_stmt
name|struct
name|obstack
name|temporary_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|obstack
name|permanent_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|temporary_firstobj
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Defined in the automatically-generated underscore.c.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|prepends_underscore
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|mktemp
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|FILE
modifier|*
name|fdopen
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Structure to hold all the directories in which to search for files to    execute.  */
end_comment

begin_struct
struct|struct
name|prefix_list
block|{
name|char
modifier|*
name|prefix
decl_stmt|;
comment|/* String to prepend to the path. */
name|struct
name|prefix_list
modifier|*
name|next
decl_stmt|;
comment|/* Next in linked list. */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|path_prefix
block|{
name|struct
name|prefix_list
modifier|*
name|plist
decl_stmt|;
comment|/* List of prefixes to try */
name|int
name|max_len
decl_stmt|;
comment|/* Max length of a prefix in PLIST */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Name of this list (used in config stuff) */
block|}
struct|;
end_struct

begin_decl_stmt
name|void
name|collect_exit
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|collect_execute
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|dump_file
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|handler
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_ctor_dtor
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|choose_temp_base
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_in_prefix_list
name|PROTO
argument_list|(
operator|(
expr|struct
name|path_prefix
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|find_a_file
name|PROTO
argument_list|(
operator|(
expr|struct
name|path_prefix
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_prefix
name|PROTO
argument_list|(
operator|(
expr|struct
name|path_prefix
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|prefix_from_env
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
expr|struct
name|path_prefix
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|prefix_from_string
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
expr|struct
name|path_prefix
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_wait
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fork_execute
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|maybe_unlink
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_to_list
name|PROTO
argument_list|(
operator|(
expr|struct
name|head
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_list
name|PROTO
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|char
operator|*
operator|,
expr|struct
name|id
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_list_with_asm
name|PROTO
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|char
operator|*
operator|,
expr|struct
name|id
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_c_file
name|PROTO
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|write_export_file
name|PROTO
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|scan_prog_file
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
expr|enum
name|pass
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|scan_libraries
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|xcalloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|xmalloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|index
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|rindex
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|free
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|NO_DUP2
end_ifdef

begin_function
name|int
name|dup2
parameter_list|(
name|oldfd
parameter_list|,
name|newfd
parameter_list|)
name|int
name|oldfd
decl_stmt|;
name|int
name|newfd
decl_stmt|;
block|{
name|int
name|fdtmp
index|[
literal|256
index|]
decl_stmt|;
name|int
name|fdx
init|=
literal|0
decl_stmt|;
name|int
name|fd
decl_stmt|;
if|if
condition|(
name|oldfd
operator|==
name|newfd
condition|)
return|return
name|oldfd
return|;
name|close
argument_list|(
name|newfd
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|fd
operator|=
name|dup
argument_list|(
name|oldfd
argument_list|)
operator|)
operator|!=
name|newfd
operator|&&
name|fd
operator|>=
literal|0
condition|)
comment|/* good enough for low fd's */
name|fdtmp
index|[
name|fdx
operator|++
index|]
operator|=
name|fd
expr_stmt|;
while|while
condition|(
name|fdx
operator|>
literal|0
condition|)
name|close
argument_list|(
name|fdtmp
index|[
operator|--
name|fdx
index|]
argument_list|)
expr_stmt|;
return|return
name|fd
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|char
modifier|*
name|my_strerror
parameter_list|(
name|e
parameter_list|)
name|int
name|e
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|HAVE_STRERROR
return|return
name|strerror
argument_list|(
name|e
argument_list|)
return|;
else|#
directive|else
specifier|static
name|char
name|buffer
index|[
literal|30
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|e
condition|)
return|return
literal|""
return|;
if|if
condition|(
name|e
operator|>
literal|0
operator|&&
name|e
operator|<
name|sys_nerr
condition|)
return|return
name|sys_errlist
index|[
name|e
index|]
return|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"Unknown error %d"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|buffer
return|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Delete tempfiles and exit function.  */
end_comment

begin_function
name|void
name|collect_exit
parameter_list|(
name|status
parameter_list|)
name|int
name|status
decl_stmt|;
block|{
if|if
condition|(
name|c_file
operator|!=
literal|0
operator|&&
name|c_file
index|[
literal|0
index|]
condition|)
name|maybe_unlink
argument_list|(
name|c_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|o_file
operator|!=
literal|0
operator|&&
name|o_file
index|[
literal|0
index|]
condition|)
name|maybe_unlink
argument_list|(
name|o_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|export_file
operator|!=
literal|0
operator|&&
name|export_file
index|[
literal|0
index|]
condition|)
name|maybe_unlink
argument_list|(
name|export_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|ldout
operator|!=
literal|0
operator|&&
name|ldout
index|[
literal|0
index|]
condition|)
block|{
name|dump_file
argument_list|(
name|ldout
argument_list|)
expr_stmt|;
name|maybe_unlink
argument_list|(
name|ldout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|!=
literal|0
operator|&&
name|output_file
operator|!=
literal|0
operator|&&
name|output_file
index|[
literal|0
index|]
condition|)
name|maybe_unlink
argument_list|(
name|output_file
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Die when sys call fails. */
end_comment

begin_function
name|void
name|fatal_perror
parameter_list|(
name|string
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|,
name|arg3
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|,
decl|*
name|arg1
decl_stmt|,
modifier|*
name|arg2
decl_stmt|,
modifier|*
name|arg3
decl_stmt|;
end_function

begin_block
block|{
name|int
name|e
init|=
name|errno
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"collect2: "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|string
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|": %s\n"
argument_list|,
name|my_strerror
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
name|collect_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Just die. */
end_comment

begin_function
name|void
name|fatal
parameter_list|(
name|string
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|,
name|arg3
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|,
decl|*
name|arg1
decl_stmt|,
modifier|*
name|arg2
decl_stmt|,
modifier|*
name|arg3
decl_stmt|;
end_function

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"collect2: "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|string
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|collect_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Write error message.  */
end_comment

begin_function
name|void
name|error
parameter_list|(
name|string
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|,
name|arg3
parameter_list|,
name|arg4
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|,
decl|*
name|arg1
decl_stmt|,
modifier|*
name|arg2
decl_stmt|,
modifier|*
name|arg3
decl_stmt|,
modifier|*
name|arg4
decl_stmt|;
end_function

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"collect2: "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|string
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|,
name|arg4
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* In case obstack is linked in, and abort is defined to fancy_abort,    provide a default entry.  */
end_comment

begin_function
name|void
name|fancy_abort
parameter_list|()
block|{
name|fatal
argument_list|(
literal|"internal error"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|handler
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
if|if
condition|(
name|c_file
operator|!=
literal|0
operator|&&
name|c_file
index|[
literal|0
index|]
condition|)
name|maybe_unlink
argument_list|(
name|c_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|o_file
operator|!=
literal|0
operator|&&
name|o_file
index|[
literal|0
index|]
condition|)
name|maybe_unlink
argument_list|(
name|o_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|ldout
operator|!=
literal|0
operator|&&
name|ldout
index|[
literal|0
index|]
condition|)
name|maybe_unlink
argument_list|(
name|ldout
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|signo
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|signo
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|char
modifier|*
name|xcalloc
parameter_list|(
name|size1
parameter_list|,
name|size2
parameter_list|)
name|int
name|size1
decl_stmt|,
name|size2
decl_stmt|;
block|{
name|char
modifier|*
name|ptr
init|=
operator|(
name|char
operator|*
operator|)
name|calloc
argument_list|(
name|size1
argument_list|,
name|size2
argument_list|)
decl_stmt|;
if|if
condition|(
name|ptr
condition|)
return|return
name|ptr
return|;
name|fatal
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
literal|0
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|xmalloc
parameter_list|(
name|size
parameter_list|)
name|unsigned
name|size
decl_stmt|;
block|{
name|char
modifier|*
name|ptr
init|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|ptr
condition|)
return|return
name|ptr
return|;
name|fatal
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
literal|0
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|xrealloc
parameter_list|(
name|ptr
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|unsigned
name|size
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|value
init|=
operator|(
name|char
operator|*
operator|)
name|realloc
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"virtual memory exhausted"
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_function
name|int
name|file_exists
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
return|return
name|access
argument_list|(
name|name
argument_list|,
name|R_OK
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Make a copy of a string INPUT with size SIZE.  */
end_comment

begin_function
name|char
modifier|*
name|savestring
parameter_list|(
name|input
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|input
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|char
modifier|*
name|output
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|size
operator|+
literal|1
argument_list|)
decl_stmt|;
name|bcopy
argument_list|(
name|input
argument_list|,
name|output
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|output
index|[
name|size
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|output
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|dump_file
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|FILE
modifier|*
name|stream
init|=
name|fopen
argument_list|(
name|name
argument_list|,
literal|"r"
argument_list|)
decl_stmt|;
name|int
name|no_demangle
init|=
operator|!
operator|!
name|getenv
argument_list|(
literal|"COLLECT_NO_DEMANGLE"
argument_list|)
decl_stmt|;
if|if
condition|(
name|stream
operator|==
literal|0
condition|)
return|return;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|c
decl_stmt|;
while|while
condition|(
name|c
operator|=
name|getc
argument_list|(
name|stream
argument_list|)
operator|,
name|c
operator|!=
name|EOF
operator|&&
operator|(
name|isalnum
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'_'
operator|||
name|c
operator|==
literal|'$'
operator|||
name|c
operator|==
literal|'.'
operator|)
condition|)
name|obstack_1grow
argument_list|(
operator|&
name|temporary_obstack
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|obstack_object_size
argument_list|(
operator|&
name|temporary_obstack
argument_list|)
operator|>
literal|0
condition|)
block|{
name|char
modifier|*
name|word
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|result
decl_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|temporary_obstack
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
name|word
operator|=
name|obstack_finish
argument_list|(
operator|&
name|temporary_obstack
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|word
operator|==
literal|'.'
condition|)
operator|++
name|word
operator|,
name|putc
argument_list|(
literal|'.'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|p
operator|=
name|word
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'_'
operator|&&
name|prepends_underscore
condition|)
operator|++
name|p
expr_stmt|;
if|if
condition|(
name|no_demangle
condition|)
name|result
operator|=
literal|0
expr_stmt|;
else|else
name|result
operator|=
name|cplus_demangle
argument_list|(
name|p
argument_list|,
name|DMGL_PARAMS
operator||
name|DMGL_ANSI
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
block|{
name|int
name|diff
decl_stmt|;
name|fputs
argument_list|(
name|result
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|diff
operator|=
name|strlen
argument_list|(
name|word
argument_list|)
operator|-
name|strlen
argument_list|(
name|result
argument_list|)
expr_stmt|;
while|while
condition|(
name|diff
operator|>
literal|0
condition|)
operator|--
name|diff
operator|,
name|putc
argument_list|(
literal|' '
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
while|while
condition|(
name|diff
operator|<
literal|0
operator|&&
name|c
operator|==
literal|' '
condition|)
operator|++
name|diff
operator|,
name|c
operator|=
name|getc
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
else|else
name|fputs
argument_list|(
name|word
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|temporary_obstack
argument_list|,
name|temporary_firstobj
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
name|putc
argument_list|(
name|c
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Decide whether the given symbol is:    a constructor (1), a destructor (2), or neither (0).  */
end_comment

begin_function
specifier|static
name|int
name|is_ctor_dtor
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
struct|struct
name|names
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|int
name|two_underscores
decl_stmt|;
block|}
struct|;
specifier|register
name|struct
name|names
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|ch
decl_stmt|;
specifier|register
name|char
modifier|*
name|orig_s
init|=
name|s
decl_stmt|;
specifier|static
name|struct
name|names
name|special
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|NO_DOLLAR_IN_LABEL
ifdef|#
directive|ifdef
name|NO_DOT_IN_LABEL
block|{
literal|"GLOBAL__I_"
block|,
sizeof|sizeof
argument_list|(
literal|"GLOBAL__I_"
argument_list|)
operator|-
literal|1
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"GLOBAL__D_"
block|,
sizeof|sizeof
argument_list|(
literal|"GLOBAL__D_"
argument_list|)
operator|-
literal|1
block|,
literal|2
block|,
literal|0
block|}
block|,
else|#
directive|else
block|{
literal|"GLOBAL_.I."
block|,
sizeof|sizeof
argument_list|(
literal|"GLOBAL_.I."
argument_list|)
operator|-
literal|1
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"GLOBAL_.D."
block|,
sizeof|sizeof
argument_list|(
literal|"GLOBAL_.D."
argument_list|)
operator|-
literal|1
block|,
literal|2
block|,
literal|0
block|}
block|,
endif|#
directive|endif
else|#
directive|else
block|{
literal|"GLOBAL_$I$"
block|,
sizeof|sizeof
argument_list|(
literal|"GLOBAL_$I$"
argument_list|)
operator|-
literal|1
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"GLOBAL_$D$"
block|,
sizeof|sizeof
argument_list|(
literal|"GLOBAL_$D$"
argument_list|)
operator|-
literal|1
block|,
literal|2
block|,
literal|0
block|}
block|,
endif|#
directive|endif
block|{
literal|"GLOBAL__FI_"
block|,
sizeof|sizeof
argument_list|(
literal|"GLOBAL__FI_"
argument_list|)
operator|-
literal|1
block|,
literal|3
block|,
literal|0
block|}
block|,
block|{
literal|"GLOBAL__FD_"
block|,
sizeof|sizeof
argument_list|(
literal|"GLOBAL__FD_"
argument_list|)
operator|-
literal|1
block|,
literal|4
block|,
literal|0
block|}
block|,
ifdef|#
directive|ifdef
name|CFRONT_LOSSAGE
comment|/* Don't collect cfront initialization functions. 			 cfront has its own linker procedure to collect them; 			 if collect2 gets them too, they get collected twice 			 when the cfront procedure is run and the compiler used 			 for linking happens to be GCC.  */
block|{
literal|"sti__"
block|,
sizeof|sizeof
argument_list|(
literal|"sti__"
argument_list|)
operator|-
literal|1
block|,
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|"std__"
block|,
sizeof|sizeof
argument_list|(
literal|"std__"
argument_list|)
operator|-
literal|1
block|,
literal|2
block|,
literal|1
block|}
block|,
endif|#
directive|endif
comment|/* CFRONT_LOSSAGE */
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
operator|*
name|s
operator|)
operator|==
literal|'_'
condition|)
operator|++
name|s
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|orig_s
condition|)
return|return
literal|0
return|;
for|for
control|(
name|p
operator|=
operator|&
name|special
index|[
literal|0
index|]
init|;
name|p
operator|->
name|len
operator|>
literal|0
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|ch
operator|==
name|p
operator|->
name|name
index|[
literal|0
index|]
operator|&&
operator|(
operator|!
name|p
operator|->
name|two_underscores
operator|||
operator|(
operator|(
name|s
operator|-
name|orig_s
operator|)
operator|>=
literal|2
operator|)
operator|)
operator|&&
name|strncmp
argument_list|(
name|s
argument_list|,
name|p
operator|->
name|name
argument_list|,
name|p
operator|->
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|p
operator|->
name|ret
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compute a string to use as the base of all temporary file names.    It is substituted for %g.  */
end_comment

begin_function
specifier|static
name|void
name|choose_temp_base
parameter_list|()
block|{
name|char
modifier|*
name|base
init|=
name|getenv
argument_list|(
literal|"TMPDIR"
argument_list|)
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|base
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|P_tmpdir
if|if
condition|(
name|access
argument_list|(
name|P_tmpdir
argument_list|,
name|R_OK
operator||
name|W_OK
argument_list|)
operator|==
literal|0
condition|)
name|base
operator|=
name|P_tmpdir
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|base
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
block|{
if|if
condition|(
name|access
argument_list|(
literal|"/usr/tmp"
argument_list|,
name|R_OK
operator||
name|W_OK
argument_list|)
operator|==
literal|0
condition|)
name|base
operator|=
literal|"/usr/tmp/"
expr_stmt|;
else|else
name|base
operator|=
literal|"/tmp/"
expr_stmt|;
block|}
block|}
name|len
operator|=
name|strlen
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|temp_filename
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
sizeof|sizeof
argument_list|(
literal|"/ccXXXXXX"
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|temp_filename
argument_list|,
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
operator|&&
name|temp_filename
index|[
name|len
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
name|temp_filename
index|[
name|len
operator|++
index|]
operator|=
literal|'/'
expr_stmt|;
name|strcpy
argument_list|(
name|temp_filename
operator|+
name|len
argument_list|,
literal|"ccXXXXXX"
argument_list|)
expr_stmt|;
name|mktemp
argument_list|(
name|temp_filename
argument_list|)
expr_stmt|;
name|temp_filename_length
operator|=
name|strlen
argument_list|(
name|temp_filename
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Routine to add variables to the environment.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_PUTENV
end_ifndef

begin_function
name|int
name|putenv
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|VMS
comment|/* nor about VMS */
specifier|extern
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
name|char
modifier|*
modifier|*
name|old_environ
init|=
name|environ
decl_stmt|;
name|char
modifier|*
modifier|*
name|envp
decl_stmt|;
name|int
name|num_envs
init|=
literal|0
decl_stmt|;
name|int
name|name_len
init|=
literal|1
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|str
decl_stmt|;
name|int
name|ch
decl_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|'\0'
operator|&&
name|ch
operator|!=
literal|'='
condition|)
name|name_len
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|ch
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Search for replacing an existing environment variable, and      count the number of total environment variables.  */
for|for
control|(
name|envp
operator|=
name|old_environ
init|;
operator|*
name|envp
condition|;
name|envp
operator|++
control|)
block|{
name|num_envs
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|str
argument_list|,
operator|*
name|envp
argument_list|,
name|name_len
argument_list|)
condition|)
block|{
operator|*
name|envp
operator|=
name|str
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/* Add a new environment variable */
name|environ
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
operator|(
name|num_envs
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
operator|*
name|environ
operator|=
name|str
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|old_environ
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|environ
operator|+
literal|1
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
operator|(
name|num_envs
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* VMS */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_PUTENV */
end_comment

begin_escape
end_escape

begin_comment
comment|/* By default, colon separates directories in a path.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PATH_SEPARATOR
end_ifndef

begin_define
define|#
directive|define
name|PATH_SEPARATOR
value|':'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* We maintain two prefix lists: one from COMPILER_PATH environment variable    and one from the PATH variable.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|path_prefix
name|cpath
decl_stmt|,
name|path
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|CROSS_COMPILE
end_ifdef

begin_comment
comment|/* This is the name of the target machine.  We use it to form the name    of the files to execute.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|target_machine
init|=
name|TARGET_MACHINE
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Names under which we were executed.  Never return one of those files in our    searches.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|path_prefix
name|our_file_names
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Determine if STRING is in PPREFIX.     This utility is currently only used to look up file names.  Prefix lists    record directory names.  This matters to us because the latter has a     trailing slash, so I've added a flag to handle both.  */
end_comment

begin_function
specifier|static
name|int
name|is_in_prefix_list
parameter_list|(
name|pprefix
parameter_list|,
name|string
parameter_list|,
name|filep
parameter_list|)
name|struct
name|path_prefix
modifier|*
name|pprefix
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|filep
decl_stmt|;
block|{
name|struct
name|prefix_list
modifier|*
name|pl
decl_stmt|;
if|if
condition|(
name|filep
condition|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|string
argument_list|)
decl_stmt|;
for|for
control|(
name|pl
operator|=
name|pprefix
operator|->
name|plist
init|;
name|pl
condition|;
name|pl
operator|=
name|pl
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|pl
operator|->
name|prefix
argument_list|,
name|string
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|pl
operator|->
name|prefix
operator|+
name|len
argument_list|,
literal|"/"
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
block|}
block|}
else|else
block|{
for|for
control|(
name|pl
operator|=
name|pprefix
operator|->
name|plist
init|;
name|pl
condition|;
name|pl
operator|=
name|pl
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|pl
operator|->
name|prefix
argument_list|,
name|string
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Search for NAME using prefix list PPREFIX.  We only look for executable    files.      Return 0 if not found, otherwise return its name, allocated with malloc. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|find_a_file
parameter_list|(
name|pprefix
parameter_list|,
name|name
parameter_list|)
name|struct
name|path_prefix
modifier|*
name|pprefix
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|char
modifier|*
name|temp
decl_stmt|;
name|struct
name|prefix_list
modifier|*
name|pl
decl_stmt|;
name|int
name|len
init|=
name|pprefix
operator|->
name|max_len
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
decl_stmt|;
ifdef|#
directive|ifdef
name|EXECUTABLE_SUFFIX
name|len
operator|+=
name|strlen
argument_list|(
name|EXECUTABLE_SUFFIX
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|temp
operator|=
name|xmalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
comment|/* Determine the filename to execute (special case for absolute paths).  */
if|if
condition|(
operator|*
name|name
operator|==
literal|'/'
condition|)
block|{
if|if
condition|(
name|access
argument_list|(
name|name
argument_list|,
name|X_OK
argument_list|)
operator|==
literal|0
condition|)
block|{
name|strcpy
argument_list|(
name|temp
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
block|}
else|else
for|for
control|(
name|pl
operator|=
name|pprefix
operator|->
name|plist
init|;
name|pl
condition|;
name|pl
operator|=
name|pl
operator|->
name|next
control|)
block|{
name|strcpy
argument_list|(
name|temp
argument_list|,
name|pl
operator|->
name|prefix
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_in_prefix_list
argument_list|(
operator|&
name|our_file_names
argument_list|,
name|temp
argument_list|,
literal|1
argument_list|)
comment|/* This is a kludge, but there seems no way around it.  */
operator|&&
name|strcmp
argument_list|(
name|temp
argument_list|,
literal|"./ld"
argument_list|)
operator|!=
literal|0
operator|&&
name|access
argument_list|(
name|temp
argument_list|,
name|X_OK
argument_list|)
operator|==
literal|0
condition|)
return|return
name|temp
return|;
ifdef|#
directive|ifdef
name|EXECUTABLE_SUFFIX
comment|/* Some systems have a suffix for executable files. 	   So try appending that.  */
name|strcat
argument_list|(
name|temp
argument_list|,
name|EXECUTABLE_SUFFIX
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_in_prefix_list
argument_list|(
operator|&
name|our_file_names
argument_list|,
name|temp
argument_list|,
literal|1
argument_list|)
operator|&&
name|access
argument_list|(
name|temp
argument_list|,
name|X_OK
argument_list|)
operator|==
literal|0
condition|)
return|return
name|temp
return|;
endif|#
directive|endif
block|}
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Add an entry for PREFIX to prefix list PPREFIX.  */
end_comment

begin_function
specifier|static
name|void
name|add_prefix
parameter_list|(
name|pprefix
parameter_list|,
name|prefix
parameter_list|)
name|struct
name|path_prefix
modifier|*
name|pprefix
decl_stmt|;
name|char
modifier|*
name|prefix
decl_stmt|;
block|{
name|struct
name|prefix_list
modifier|*
name|pl
decl_stmt|,
modifier|*
modifier|*
name|prev
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|pprefix
operator|->
name|plist
condition|)
block|{
for|for
control|(
name|pl
operator|=
name|pprefix
operator|->
name|plist
init|;
name|pl
operator|->
name|next
condition|;
name|pl
operator|=
name|pl
operator|->
name|next
control|)
empty_stmt|;
name|prev
operator|=
operator|&
name|pl
operator|->
name|next
expr_stmt|;
block|}
else|else
name|prev
operator|=
operator|&
name|pprefix
operator|->
name|plist
expr_stmt|;
comment|/* Keep track of the longest prefix */
name|len
operator|=
name|strlen
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|pprefix
operator|->
name|max_len
condition|)
name|pprefix
operator|->
name|max_len
operator|=
name|len
expr_stmt|;
name|pl
operator|=
operator|(
expr|struct
name|prefix_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|prefix_list
argument_list|)
argument_list|)
expr_stmt|;
name|pl
operator|->
name|prefix
operator|=
name|savestring
argument_list|(
name|prefix
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|prev
condition|)
name|pl
operator|->
name|next
operator|=
operator|*
name|prev
expr_stmt|;
else|else
name|pl
operator|->
name|next
operator|=
operator|(
expr|struct
name|prefix_list
operator|*
operator|)
literal|0
expr_stmt|;
operator|*
name|prev
operator|=
name|pl
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Take the value of the environment variable ENV, break it into a path, and    add of the entries to PPREFIX.  */
end_comment

begin_function
specifier|static
name|void
name|prefix_from_env
parameter_list|(
name|env
parameter_list|,
name|pprefix
parameter_list|)
name|char
modifier|*
name|env
decl_stmt|;
name|struct
name|path_prefix
modifier|*
name|pprefix
decl_stmt|;
block|{
name|char
modifier|*
name|p
init|=
name|getenv
argument_list|(
name|env
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
condition|)
name|prefix_from_string
argument_list|(
name|p
argument_list|,
name|pprefix
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|prefix_from_string
parameter_list|(
name|p
parameter_list|,
name|pprefix
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
name|struct
name|path_prefix
modifier|*
name|pprefix
decl_stmt|;
block|{
name|char
modifier|*
name|startp
decl_stmt|,
modifier|*
name|endp
decl_stmt|;
name|char
modifier|*
name|nstore
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
literal|3
argument_list|)
decl_stmt|;
name|startp
operator|=
name|endp
operator|=
name|p
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|*
name|endp
operator|==
name|PATH_SEPARATOR
operator|||
operator|*
name|endp
operator|==
literal|0
condition|)
block|{
name|strncpy
argument_list|(
name|nstore
argument_list|,
name|startp
argument_list|,
name|endp
operator|-
name|startp
argument_list|)
expr_stmt|;
if|if
condition|(
name|endp
operator|==
name|startp
condition|)
block|{
name|strcpy
argument_list|(
name|nstore
argument_list|,
literal|"./"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|endp
index|[
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
block|{
name|nstore
index|[
name|endp
operator|-
name|startp
index|]
operator|=
literal|'/'
expr_stmt|;
name|nstore
index|[
name|endp
operator|-
name|startp
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|nstore
index|[
name|endp
operator|-
name|startp
index|]
operator|=
literal|0
expr_stmt|;
name|add_prefix
argument_list|(
name|pprefix
argument_list|,
name|nstore
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|endp
operator|==
literal|0
condition|)
break|break;
name|endp
operator|=
name|startp
operator|=
name|endp
operator|+
literal|1
expr_stmt|;
block|}
else|else
name|endp
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Main program. */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|char
modifier|*
name|ld_suffix
init|=
literal|"ld"
decl_stmt|;
name|char
modifier|*
name|full_ld_suffix
init|=
name|ld_suffix
decl_stmt|;
name|char
modifier|*
name|real_ld_suffix
init|=
literal|"real-ld"
decl_stmt|;
name|char
modifier|*
name|full_real_ld_suffix
init|=
name|real_ld_suffix
decl_stmt|;
name|char
modifier|*
name|collect_ld_suffix
init|=
literal|"collect-ld"
decl_stmt|;
name|char
modifier|*
name|nm_suffix
init|=
literal|"nm"
decl_stmt|;
name|char
modifier|*
name|full_nm_suffix
init|=
name|nm_suffix
decl_stmt|;
name|char
modifier|*
name|gnm_suffix
init|=
literal|"gnm"
decl_stmt|;
name|char
modifier|*
name|full_gnm_suffix
init|=
name|gnm_suffix
decl_stmt|;
ifdef|#
directive|ifdef
name|LDD_SUFFIX
name|char
modifier|*
name|ldd_suffix
init|=
name|LDD_SUFFIX
decl_stmt|;
name|char
modifier|*
name|full_ldd_suffix
init|=
name|ldd_suffix
decl_stmt|;
endif|#
directive|endif
name|char
modifier|*
name|strip_suffix
init|=
literal|"strip"
decl_stmt|;
name|char
modifier|*
name|full_strip_suffix
init|=
name|strip_suffix
decl_stmt|;
name|char
modifier|*
name|gstrip_suffix
init|=
literal|"gstrip"
decl_stmt|;
name|char
modifier|*
name|full_gstrip_suffix
init|=
name|gstrip_suffix
decl_stmt|;
name|char
modifier|*
name|arg
decl_stmt|;
name|FILE
modifier|*
name|outf
decl_stmt|,
modifier|*
name|exportf
decl_stmt|;
name|char
modifier|*
name|ld_file_name
decl_stmt|;
name|char
modifier|*
name|collect_name
decl_stmt|;
name|char
modifier|*
name|collect_names
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
modifier|*
name|c_argv
decl_stmt|;
name|char
modifier|*
modifier|*
name|c_ptr
decl_stmt|;
name|char
modifier|*
modifier|*
name|ld1_argv
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|,
name|argc
operator|+
literal|3
argument_list|)
decl_stmt|;
name|char
modifier|*
modifier|*
name|ld1
init|=
name|ld1_argv
decl_stmt|;
name|char
modifier|*
modifier|*
name|ld2_argv
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|,
name|argc
operator|+
literal|6
argument_list|)
decl_stmt|;
name|char
modifier|*
modifier|*
name|ld2
init|=
name|ld2_argv
decl_stmt|;
name|char
modifier|*
modifier|*
name|object_lst
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|,
name|argc
argument_list|)
decl_stmt|;
name|char
modifier|*
modifier|*
name|object
init|=
name|object_lst
decl_stmt|;
name|int
name|first_file
decl_stmt|;
name|int
name|num_c_args
init|=
name|argc
operator|+
literal|7
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|debug
operator|=
literal|1
expr_stmt|;
name|vflag
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|output_file
operator|=
literal|"a.out"
expr_stmt|;
name|obstack_begin
argument_list|(
operator|&
name|temporary_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|obstack_begin
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|temporary_firstobj
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|temporary_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|current_demangling_style
operator|=
name|gnu_demangling
expr_stmt|;
comment|/* We must check that we do not call ourselves in an infinite      recursion loop. We append the name used for us to the COLLECT_NAMES      environment variable.       In practice, collect will rarely invoke itself.  This can happen now      that we are no longer called gld.  A perfect example is when running      gcc in a build directory that has been installed.  When looking for       ld's, we'll find our installed version and believe that's the real ld.  */
comment|/* We must also append COLLECT_NAME to COLLECT_NAMES to watch for the      previous version of collect (the one that used COLLECT_NAME and only      handled two levels of recursion).  If we don't we may mutually recurse      forever.  This can happen (I think) when bootstrapping the old version      and a new one is installed (rare, but we should handle it).      ??? Hopefully references to COLLECT_NAME can be removed at some point.  */
name|collect_name
operator|=
operator|(
name|char
operator|*
operator|)
name|getenv
argument_list|(
literal|"COLLECT_NAME"
argument_list|)
expr_stmt|;
name|collect_names
operator|=
operator|(
name|char
operator|*
operator|)
name|getenv
argument_list|(
literal|"COLLECT_NAMES"
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
literal|"COLLECT_NAMES="
argument_list|)
operator|+
operator|(
name|collect_name
condition|?
name|strlen
argument_list|(
name|collect_name
argument_list|)
operator|+
literal|1
else|:
literal|0
operator|)
operator|+
operator|(
name|collect_names
condition|?
name|strlen
argument_list|(
name|collect_names
argument_list|)
operator|+
literal|1
else|:
literal|0
operator|)
operator|+
name|strlen
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
literal|"COLLECT_NAMES="
argument_list|)
expr_stmt|;
if|if
condition|(
name|collect_name
operator|!=
literal|0
condition|)
name|sprintf
argument_list|(
name|p
operator|+
name|strlen
argument_list|(
name|p
argument_list|)
argument_list|,
literal|"%s%c"
argument_list|,
name|collect_name
argument_list|,
name|PATH_SEPARATOR
argument_list|)
expr_stmt|;
if|if
condition|(
name|collect_names
operator|!=
literal|0
condition|)
name|sprintf
argument_list|(
name|p
operator|+
name|strlen
argument_list|(
name|p
argument_list|)
argument_list|,
literal|"%s%c"
argument_list|,
name|collect_names
argument_list|,
name|PATH_SEPARATOR
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|p
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|putenv
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|prefix_from_env
argument_list|(
literal|"COLLECT_NAMES"
argument_list|,
operator|&
name|our_file_names
argument_list|)
expr_stmt|;
comment|/* Set environment variable COLLECT_NAME to our name so the previous version      of collect won't find us.  If it does we'll mutually recurse forever.      This can happen when bootstrapping the new version and an old version is      installed.      ??? Hopefully this bit of code can be removed at some point.  */
name|p
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
literal|"COLLECT_NAME="
argument_list|)
operator|+
name|strlen
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"COLLECT_NAME=%s"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|putenv
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|getenv
argument_list|(
literal|"COLLECT_GCC_OPTIONS"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
while|while
condition|(
operator|*
name|p
condition|)
block|{
name|char
modifier|*
name|q
init|=
name|p
decl_stmt|;
while|while
condition|(
operator|*
name|q
operator|&&
operator|*
name|q
operator|!=
literal|' '
condition|)
name|q
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'m'
condition|)
name|num_c_args
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|q
condition|)
name|q
operator|++
expr_stmt|;
name|p
operator|=
name|q
expr_stmt|;
block|}
name|c_ptr
operator|=
name|c_argv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|,
name|num_c_args
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
name|fatal
argument_list|(
literal|"no arguments"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGQUIT
if|if
condition|(
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|handler
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|handler
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGALRM
if|if
condition|(
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|handler
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGHUP
if|if
condition|(
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|handler
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|signal
argument_list|(
name|SIGSEGV
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGSEGV
argument_list|,
name|handler
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGBUS
if|if
condition|(
name|signal
argument_list|(
name|SIGBUS
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGBUS
argument_list|,
name|handler
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Extract COMPILER_PATH and PATH into our prefix list.  */
name|prefix_from_env
argument_list|(
literal|"COMPILER_PATH"
argument_list|,
operator|&
name|cpath
argument_list|)
expr_stmt|;
name|prefix_from_env
argument_list|(
literal|"PATH"
argument_list|,
operator|&
name|path
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CROSS_COMPILE
comment|/* If we look for a program in the compiler directories, we just use      the short name, since these directories are already system-specific.      But it we look for a took in the system directories, we need to      qualify the program name with the target machine.  */
name|full_ld_suffix
operator|=
name|xcalloc
argument_list|(
name|strlen
argument_list|(
name|ld_suffix
argument_list|)
operator|+
name|strlen
argument_list|(
name|target_machine
argument_list|)
operator|+
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|full_ld_suffix
argument_list|,
name|target_machine
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|full_ld_suffix
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|full_ld_suffix
argument_list|,
name|ld_suffix
argument_list|)
expr_stmt|;
name|full_real_ld_suffix
operator|=
name|xcalloc
argument_list|(
name|strlen
argument_list|(
name|real_ld_suffix
argument_list|)
operator|+
name|strlen
argument_list|(
name|target_machine
argument_list|)
operator|+
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|full_real_ld_suffix
argument_list|,
name|target_machine
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|full_real_ld_suffix
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|full_real_ld_suffix
argument_list|,
name|real_ld_suffix
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|full_gld_suffix     = xcalloc (strlen (gld_suffix) + strlen (target_machine) + 2, 1);   strcpy (full_gld_suffix, target_machine);   strcat (full_gld_suffix, "-");   strcat (full_gld_suffix, gld_suffix);
endif|#
directive|endif
name|full_nm_suffix
operator|=
name|xcalloc
argument_list|(
name|strlen
argument_list|(
name|nm_suffix
argument_list|)
operator|+
name|strlen
argument_list|(
name|target_machine
argument_list|)
operator|+
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|full_nm_suffix
argument_list|,
name|target_machine
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|full_nm_suffix
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|full_nm_suffix
argument_list|,
name|nm_suffix
argument_list|)
expr_stmt|;
name|full_gnm_suffix
operator|=
name|xcalloc
argument_list|(
name|strlen
argument_list|(
name|gnm_suffix
argument_list|)
operator|+
name|strlen
argument_list|(
name|target_machine
argument_list|)
operator|+
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|full_gnm_suffix
argument_list|,
name|target_machine
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|full_gnm_suffix
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|full_gnm_suffix
argument_list|,
name|gnm_suffix
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LDD_SUFFIX
name|full_ldd_suffix
operator|=
name|xcalloc
argument_list|(
name|strlen
argument_list|(
name|ldd_suffix
argument_list|)
operator|+
name|strlen
argument_list|(
name|target_machine
argument_list|)
operator|+
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|full_ldd_suffix
argument_list|,
name|target_machine
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|full_ldd_suffix
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|full_ldd_suffix
argument_list|,
name|ldd_suffix
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|full_strip_suffix
operator|=
name|xcalloc
argument_list|(
name|strlen
argument_list|(
name|strip_suffix
argument_list|)
operator|+
name|strlen
argument_list|(
name|target_machine
argument_list|)
operator|+
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|full_strip_suffix
argument_list|,
name|target_machine
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|full_strip_suffix
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|full_strip_suffix
argument_list|,
name|strip_suffix
argument_list|)
expr_stmt|;
name|full_gstrip_suffix
operator|=
name|xcalloc
argument_list|(
name|strlen
argument_list|(
name|gstrip_suffix
argument_list|)
operator|+
name|strlen
argument_list|(
name|target_machine
argument_list|)
operator|+
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|full_gstrip_suffix
argument_list|,
name|target_machine
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|full_gstrip_suffix
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|full_gstrip_suffix
argument_list|,
name|gstrip_suffix
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CROSS_COMPILE */
comment|/* Try to discover a valid linker/nm/strip to use.  */
comment|/* Maybe we know the right file to use (if not cross).  */
ifdef|#
directive|ifdef
name|REAL_LD_FILE_NAME
name|ld_file_name
operator|=
name|find_a_file
argument_list|(
operator|&
name|path
argument_list|,
name|REAL_LD_FILE_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|ld_file_name
operator|==
literal|0
condition|)
endif|#
directive|endif
comment|/* Search the (target-specific) compiler dirs for ld'.  */
name|ld_file_name
operator|=
name|find_a_file
argument_list|(
operator|&
name|cpath
argument_list|,
name|real_ld_suffix
argument_list|)
expr_stmt|;
comment|/* Likewise for `collect-ld'.  */
if|if
condition|(
name|ld_file_name
operator|==
literal|0
condition|)
name|ld_file_name
operator|=
name|find_a_file
argument_list|(
operator|&
name|cpath
argument_list|,
name|collect_ld_suffix
argument_list|)
expr_stmt|;
comment|/* Search the compiler directories for `ld'.  We have protection against      recursive calls in find_a_file.  */
if|if
condition|(
name|ld_file_name
operator|==
literal|0
condition|)
name|ld_file_name
operator|=
name|find_a_file
argument_list|(
operator|&
name|cpath
argument_list|,
name|ld_suffix
argument_list|)
expr_stmt|;
comment|/* Search the ordinary system bin directories      for `ld' (if native linking) or `TARGET-ld' (if cross).  */
if|if
condition|(
name|ld_file_name
operator|==
literal|0
condition|)
name|ld_file_name
operator|=
name|find_a_file
argument_list|(
operator|&
name|path
argument_list|,
name|full_ld_suffix
argument_list|)
expr_stmt|;
comment|/* If we've invoked ourselves, try again with LD_FILE_NAME.  */
if|if
condition|(
name|collect_names
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ld_file_name
operator|!=
literal|0
condition|)
block|{
name|argv
index|[
literal|0
index|]
operator|=
name|ld_file_name
expr_stmt|;
name|execvp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|argv
argument_list|)
expr_stmt|;
block|}
name|fatal
argument_list|(
literal|"cannot find `ld'"
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|REAL_NM_FILE_NAME
name|nm_file_name
operator|=
name|find_a_file
argument_list|(
operator|&
name|path
argument_list|,
name|REAL_NM_FILE_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|nm_file_name
operator|==
literal|0
condition|)
endif|#
directive|endif
name|nm_file_name
operator|=
name|find_a_file
argument_list|(
operator|&
name|cpath
argument_list|,
name|gnm_suffix
argument_list|)
expr_stmt|;
if|if
condition|(
name|nm_file_name
operator|==
literal|0
condition|)
name|nm_file_name
operator|=
name|find_a_file
argument_list|(
operator|&
name|path
argument_list|,
name|full_gnm_suffix
argument_list|)
expr_stmt|;
if|if
condition|(
name|nm_file_name
operator|==
literal|0
condition|)
name|nm_file_name
operator|=
name|find_a_file
argument_list|(
operator|&
name|cpath
argument_list|,
name|nm_suffix
argument_list|)
expr_stmt|;
if|if
condition|(
name|nm_file_name
operator|==
literal|0
condition|)
name|nm_file_name
operator|=
name|find_a_file
argument_list|(
operator|&
name|path
argument_list|,
name|full_nm_suffix
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LDD_SUFFIX
name|ldd_file_name
operator|=
name|find_a_file
argument_list|(
operator|&
name|cpath
argument_list|,
name|ldd_suffix
argument_list|)
expr_stmt|;
if|if
condition|(
name|ldd_file_name
operator|==
literal|0
condition|)
name|ldd_file_name
operator|=
name|find_a_file
argument_list|(
operator|&
name|path
argument_list|,
name|full_ldd_suffix
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|REAL_STRIP_FILE_NAME
name|strip_file_name
operator|=
name|find_a_file
argument_list|(
operator|&
name|path
argument_list|,
name|REAL_STRIP_FILE_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|strip_file_name
operator|==
literal|0
condition|)
endif|#
directive|endif
name|strip_file_name
operator|=
name|find_a_file
argument_list|(
operator|&
name|cpath
argument_list|,
name|gstrip_suffix
argument_list|)
expr_stmt|;
if|if
condition|(
name|strip_file_name
operator|==
literal|0
condition|)
name|strip_file_name
operator|=
name|find_a_file
argument_list|(
operator|&
name|path
argument_list|,
name|full_gstrip_suffix
argument_list|)
expr_stmt|;
if|if
condition|(
name|strip_file_name
operator|==
literal|0
condition|)
name|strip_file_name
operator|=
name|find_a_file
argument_list|(
operator|&
name|cpath
argument_list|,
name|strip_suffix
argument_list|)
expr_stmt|;
if|if
condition|(
name|strip_file_name
operator|==
literal|0
condition|)
name|strip_file_name
operator|=
name|find_a_file
argument_list|(
operator|&
name|path
argument_list|,
name|full_strip_suffix
argument_list|)
expr_stmt|;
comment|/* Determine the full path name of the C compiler to use.  */
name|c_file_name
operator|=
name|getenv
argument_list|(
literal|"COLLECT_GCC"
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_file_name
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|CROSS_COMPILE
name|c_file_name
operator|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
literal|"gcc-"
argument_list|)
operator|+
name|strlen
argument_list|(
name|target_machine
argument_list|)
operator|+
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|c_file_name
argument_list|,
name|target_machine
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|c_file_name
argument_list|,
literal|"-gcc"
argument_list|)
expr_stmt|;
else|#
directive|else
name|c_file_name
operator|=
literal|"gcc"
expr_stmt|;
endif|#
directive|endif
block|}
name|p
operator|=
name|find_a_file
argument_list|(
operator|&
name|cpath
argument_list|,
name|c_file_name
argument_list|)
expr_stmt|;
comment|/* Here it should be safe to use the system search path since we should have      already qualified the name of the compiler when it is needed.  */
if|if
condition|(
name|p
operator|==
literal|0
condition|)
name|p
operator|=
name|find_a_file
argument_list|(
operator|&
name|path
argument_list|,
name|c_file_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|c_file_name
operator|=
name|p
expr_stmt|;
operator|*
name|ld1
operator|++
operator|=
operator|*
name|ld2
operator|++
operator|=
name|ld_file_name
expr_stmt|;
comment|/* Make temp file names. */
name|choose_temp_base
argument_list|()
expr_stmt|;
name|c_file
operator|=
name|xcalloc
argument_list|(
name|temp_filename_length
operator|+
sizeof|sizeof
argument_list|(
literal|".c"
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|o_file
operator|=
name|xcalloc
argument_list|(
name|temp_filename_length
operator|+
sizeof|sizeof
argument_list|(
literal|".o"
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|export_file
operator|=
name|xmalloc
argument_list|(
name|temp_filename_length
operator|+
sizeof|sizeof
argument_list|(
literal|".x"
argument_list|)
argument_list|)
expr_stmt|;
name|ldout
operator|=
name|xmalloc
argument_list|(
name|temp_filename_length
operator|+
sizeof|sizeof
argument_list|(
literal|".ld"
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|ldout
argument_list|,
literal|"%s.ld"
argument_list|,
name|temp_filename
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|c_file
argument_list|,
literal|"%s.c"
argument_list|,
name|temp_filename
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|o_file
argument_list|,
literal|"%s.o"
argument_list|,
name|temp_filename
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|export_file
argument_list|,
literal|"%s.x"
argument_list|,
name|temp_filename
argument_list|)
expr_stmt|;
operator|*
name|c_ptr
operator|++
operator|=
name|c_file_name
expr_stmt|;
operator|*
name|c_ptr
operator|++
operator|=
literal|"-c"
expr_stmt|;
operator|*
name|c_ptr
operator|++
operator|=
literal|"-o"
expr_stmt|;
operator|*
name|c_ptr
operator|++
operator|=
name|o_file
expr_stmt|;
comment|/* !!! When GCC calls collect2,      it does not know whether it is calling collect2 or ld.      So collect2 cannot meaningfully understand any options      except those ld understands.      If you propose to make GCC pass some other option,      just imagine what will happen if ld is really ld!!!  */
comment|/* Parse arguments.  Remember output file spec, pass the rest to ld. */
comment|/* After the first file, put in the c++ rt0.  */
name|first_file
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|arg
operator|=
operator|*
operator|++
name|argv
operator|)
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
block|{
operator|*
name|ld1
operator|++
operator|=
operator|*
name|ld2
operator|++
operator|=
name|arg
expr_stmt|;
if|if
condition|(
name|arg
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
switch|switch
condition|(
name|arg
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'d'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"-debug"
argument_list|)
condition|)
block|{
name|debug
operator|=
literal|1
expr_stmt|;
name|vflag
operator|=
literal|1
expr_stmt|;
name|ld1
operator|--
expr_stmt|;
name|ld2
operator|--
expr_stmt|;
block|}
break|break;
ifdef|#
directive|ifdef
name|COLLECT_EXPORT_LIST
case|case
literal|'b'
case|:
if|if
condition|(
operator|(
operator|!
name|strncmp
argument_list|(
name|arg
argument_list|,
literal|"-bE:"
argument_list|,
literal|4
argument_list|)
operator|||
operator|!
name|strncmp
argument_list|(
name|arg
argument_list|,
literal|"-bexport:"
argument_list|,
literal|9
argument_list|)
operator|)
operator|&&
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"-bexport:/usr/lib/libg.exp"
argument_list|)
condition|)
name|auto_export
operator|=
literal|0
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'l'
case|:
if|if
condition|(
name|first_file
condition|)
block|{
comment|/* place o_file BEFORE this argument! */
name|first_file
operator|=
literal|0
expr_stmt|;
name|ld2
operator|--
expr_stmt|;
operator|*
name|ld2
operator|++
operator|=
name|o_file
expr_stmt|;
operator|*
name|ld2
operator|++
operator|=
name|arg
expr_stmt|;
block|}
break|break;
case|case
literal|'o'
case|:
if|if
condition|(
name|arg
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
name|output_file
operator|=
operator|*
name|ld1
operator|++
operator|=
operator|*
name|ld2
operator|++
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
else|else
name|output_file
operator|=
operator|&
name|arg
index|[
literal|2
index|]
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
if|if
condition|(
name|arg
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
name|rflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|arg
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|&&
name|do_collecting
condition|)
block|{
comment|/* We must strip after the nm run, otherwise C++ linking 		     won't work.  Thus we strip in the second ld run, or 		     else with strip if there is no second ld run.  */
name|strip_flag
operator|=
literal|1
expr_stmt|;
name|ld1
operator|--
expr_stmt|;
block|}
break|break;
case|case
literal|'v'
case|:
if|if
condition|(
name|arg
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
name|vflag
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|p
operator|=
name|rindex
argument_list|(
name|arg
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
operator|&&
operator|(
name|strcmp
argument_list|(
name|p
argument_list|,
literal|".o"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|p
argument_list|,
literal|".a"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|first_file
condition|)
block|{
name|first_file
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'o'
condition|)
operator|*
name|ld2
operator|++
operator|=
name|o_file
expr_stmt|;
else|else
block|{
comment|/* place o_file BEFORE this argument! */
name|ld2
operator|--
expr_stmt|;
operator|*
name|ld2
operator|++
operator|=
name|o_file
expr_stmt|;
operator|*
name|ld2
operator|++
operator|=
name|arg
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'o'
condition|)
operator|*
name|object
operator|++
operator|=
name|arg
expr_stmt|;
block|}
block|}
comment|/* Get any options that the upper GCC wants to pass to the sub-GCC.  */
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|getenv
argument_list|(
literal|"COLLECT_GCC_OPTIONS"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
while|while
condition|(
operator|*
name|p
condition|)
block|{
name|char
modifier|*
name|q
init|=
name|p
decl_stmt|;
while|while
condition|(
operator|*
name|q
operator|&&
operator|*
name|q
operator|!=
literal|' '
condition|)
name|q
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
operator|&&
operator|(
name|p
index|[
literal|1
index|]
operator|==
literal|'m'
operator|||
name|p
index|[
literal|1
index|]
operator|==
literal|'f'
operator|)
condition|)
operator|*
name|c_ptr
operator|++
operator|=
name|savestring
argument_list|(
name|p
argument_list|,
name|q
operator|-
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"-shared"
argument_list|,
sizeof|sizeof
argument_list|(
literal|"shared"
argument_list|)
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|shared_obj
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|q
condition|)
name|q
operator|++
expr_stmt|;
name|p
operator|=
name|q
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|COLLECT_EXPORT_LIST
comment|/* The AIX linker will discard static constructors in object files if      nothing else in the file is referenced, so look at them first.  */
while|while
condition|(
name|object_lst
operator|<
name|object
condition|)
name|scan_prog_file
argument_list|(
operator|*
name|object_lst
operator|++
argument_list|,
name|PASS_OBJ
argument_list|)
expr_stmt|;
block|{
name|char
modifier|*
name|buf
init|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|export_file
argument_list|)
operator|+
literal|5
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"-bE:%s"
argument_list|,
name|export_file
argument_list|)
expr_stmt|;
operator|*
name|ld1
operator|++
operator|=
name|buf
expr_stmt|;
operator|*
name|ld2
operator|++
operator|=
name|buf
expr_stmt|;
name|exportf
operator|=
name|fopen
argument_list|(
name|export_file
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|exportf
operator|==
operator|(
name|FILE
operator|*
operator|)
literal|0
condition|)
name|fatal_perror
argument_list|(
literal|"%s"
argument_list|,
name|export_file
argument_list|)
expr_stmt|;
name|write_export_file
argument_list|(
name|exportf
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|exportf
argument_list|)
condition|)
name|fatal_perror
argument_list|(
literal|"closing %s"
argument_list|,
name|export_file
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
operator|*
name|c_ptr
operator|++
operator|=
name|c_file
expr_stmt|;
operator|*
name|object
operator|=
operator|*
name|c_ptr
operator|=
operator|*
name|ld1
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
if|if
condition|(
name|vflag
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"collect2 version %s"
argument_list|,
name|version_string
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TARGET_VERSION
name|TARGET_VERSION
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|debug
condition|)
block|{
name|char
modifier|*
name|ptr
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ld_file_name        = %s\n"
argument_list|,
operator|(
name|ld_file_name
condition|?
name|ld_file_name
else|:
literal|"not found"
operator|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"c_file_name         = %s\n"
argument_list|,
operator|(
name|c_file_name
condition|?
name|c_file_name
else|:
literal|"not found"
operator|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"nm_file_name        = %s\n"
argument_list|,
operator|(
name|nm_file_name
condition|?
name|nm_file_name
else|:
literal|"not found"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LDD_SUFFIX
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ldd_file_name       = %s\n"
argument_list|,
operator|(
name|ldd_file_name
condition|?
name|ldd_file_name
else|:
literal|"not found"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"strip_file_name     = %s\n"
argument_list|,
operator|(
name|strip_file_name
condition|?
name|strip_file_name
else|:
literal|"not found"
operator|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"c_file              = %s\n"
argument_list|,
operator|(
name|c_file
condition|?
name|c_file
else|:
literal|"not found"
operator|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"o_file              = %s\n"
argument_list|,
operator|(
name|o_file
condition|?
name|o_file
else|:
literal|"not found"
operator|)
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|getenv
argument_list|(
literal|"COLLECT_NAMES"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"COLLECT_NAMES       = %s\n"
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|getenv
argument_list|(
literal|"COLLECT_GCC_OPTIONS"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"COLLECT_GCC_OPTIONS = %s\n"
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|getenv
argument_list|(
literal|"COLLECT_GCC"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"COLLECT_GCC         = %s\n"
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|getenv
argument_list|(
literal|"COMPILER_PATH"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"COMPILER_PATH       = %s\n"
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|getenv
argument_list|(
literal|"LIBRARY_PATH"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"LIBRARY_PATH        = %s\n"
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Load the program, searching all libraries.  */
name|collect_execute
argument_list|(
literal|"ld"
argument_list|,
name|ld1_argv
argument_list|,
name|ldout
argument_list|)
expr_stmt|;
name|do_wait
argument_list|(
literal|"ld"
argument_list|)
expr_stmt|;
name|dump_file
argument_list|(
name|ldout
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|ldout
argument_list|)
expr_stmt|;
comment|/* If -r or they'll be run via some other method, don't build the      constructor or destructor list, just return now. */
if|if
condition|(
name|rflag
operator|||
operator|!
name|do_collecting
condition|)
return|return
literal|0
return|;
comment|/* Examine the namelist with nm and search it for static constructors      and destructors to call.      Write the constructor and destructor tables to a .s file and reload. */
name|scan_prog_file
argument_list|(
name|output_file
argument_list|,
name|PASS_FIRST
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCAN_LIBRARIES
name|scan_libraries
argument_list|(
name|output_file
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|debug
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d constructor(s) found\n"
argument_list|,
name|constructors
operator|.
name|number
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d destructor(s)  found\n"
argument_list|,
name|destructors
operator|.
name|number
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|constructors
operator|.
name|number
operator|==
literal|0
operator|&&
name|destructors
operator|.
name|number
operator|==
literal|0
ifdef|#
directive|ifdef
name|LDD_SUFFIX
comment|/* If we will be running these functions ourselves, we want to emit 	 stubs into the shared library so that we don't have to relink 	 dependent programs when we add static objects.  */
operator|&&
operator|!
name|shared_obj
endif|#
directive|endif
condition|)
block|{
comment|/* Strip now if it was requested on the command line.  */
if|if
condition|(
name|strip_flag
condition|)
block|{
name|char
modifier|*
modifier|*
name|strip_argv
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|,
literal|3
argument_list|)
decl_stmt|;
name|strip_argv
index|[
literal|0
index|]
operator|=
name|strip_file_name
expr_stmt|;
name|strip_argv
index|[
literal|1
index|]
operator|=
name|output_file
expr_stmt|;
name|strip_argv
index|[
literal|2
index|]
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
name|fork_execute
argument_list|(
literal|"strip"
argument_list|,
name|strip_argv
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|COLLECT_EXPORT_LIST
name|maybe_unlink
argument_list|(
name|export_file
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
name|maybe_unlink
argument_list|(
name|output_file
argument_list|)
expr_stmt|;
name|outf
operator|=
name|fopen
argument_list|(
name|c_file
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|outf
operator|==
operator|(
name|FILE
operator|*
operator|)
literal|0
condition|)
name|fatal_perror
argument_list|(
literal|"%s"
argument_list|,
name|c_file
argument_list|)
expr_stmt|;
name|write_c_file
argument_list|(
name|outf
argument_list|,
name|c_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|outf
argument_list|)
condition|)
name|fatal_perror
argument_list|(
literal|"closing %s"
argument_list|,
name|c_file
argument_list|)
expr_stmt|;
comment|/* Tell the linker that we have initializer and finalizer functions.  */
ifdef|#
directive|ifdef
name|LD_INIT_SWITCH
operator|*
name|ld2
operator|++
operator|=
name|LD_INIT_SWITCH
expr_stmt|;
operator|*
name|ld2
operator|++
operator|=
name|initname
expr_stmt|;
operator|*
name|ld2
operator|++
operator|=
name|LD_FINI_SWITCH
expr_stmt|;
operator|*
name|ld2
operator|++
operator|=
name|fininame
expr_stmt|;
endif|#
directive|endif
operator|*
name|ld2
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|COLLECT_EXPORT_LIST
if|if
condition|(
name|shared_obj
condition|)
block|{
name|add_to_list
argument_list|(
operator|&
name|exports
argument_list|,
name|initname
argument_list|)
expr_stmt|;
name|add_to_list
argument_list|(
operator|&
name|exports
argument_list|,
name|fininame
argument_list|)
expr_stmt|;
name|add_to_list
argument_list|(
operator|&
name|exports
argument_list|,
literal|"_GLOBAL__DI"
argument_list|)
expr_stmt|;
name|add_to_list
argument_list|(
operator|&
name|exports
argument_list|,
literal|"_GLOBAL__DD"
argument_list|)
expr_stmt|;
name|exportf
operator|=
name|fopen
argument_list|(
name|export_file
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|exportf
operator|==
operator|(
name|FILE
operator|*
operator|)
literal|0
condition|)
name|fatal_perror
argument_list|(
literal|"%s"
argument_list|,
name|export_file
argument_list|)
expr_stmt|;
name|write_export_file
argument_list|(
name|exportf
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|exportf
argument_list|)
condition|)
name|fatal_perror
argument_list|(
literal|"closing %s"
argument_list|,
name|export_file
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|debug
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n========== output_file = %s, c_file = %s\n"
argument_list|,
name|output_file
argument_list|,
name|c_file
argument_list|)
expr_stmt|;
name|write_c_file
argument_list|(
name|stderr
argument_list|,
literal|"stderr"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"========== end of c_file\n\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COLLECT_EXPORT_LIST
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n========== export_file = %s\n"
argument_list|,
name|export_file
argument_list|)
expr_stmt|;
name|write_export_file
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"========== end of export_file\n\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Assemble the constructor and destructor tables.      Link the tables in with the rest of the program. */
name|fork_execute
argument_list|(
literal|"gcc"
argument_list|,
name|c_argv
argument_list|)
expr_stmt|;
name|fork_execute
argument_list|(
literal|"ld"
argument_list|,
name|ld2_argv
argument_list|)
expr_stmt|;
comment|/* Let scan_prog_file do any final mods (OSF/rose needs this for      constructors/destructors in shared libraries.  */
name|scan_prog_file
argument_list|(
name|output_file
argument_list|,
name|PASS_SECOND
argument_list|)
expr_stmt|;
name|maybe_unlink
argument_list|(
name|c_file
argument_list|)
expr_stmt|;
name|maybe_unlink
argument_list|(
name|o_file
argument_list|)
expr_stmt|;
name|maybe_unlink
argument_list|(
name|export_file
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Wait for a process to finish, and exit if a non-zero status is found. */
end_comment

begin_function
name|int
name|collect_wait
parameter_list|(
name|prog
parameter_list|)
name|char
modifier|*
name|prog
decl_stmt|;
block|{
name|int
name|status
decl_stmt|;
name|wait
argument_list|(
operator|&
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|int
name|sig
init|=
name|WTERMSIG
argument_list|(
name|status
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|NO_SYS_SIGLIST
name|error
argument_list|(
literal|"%s terminated with signal %d %s"
argument_list|,
name|prog
argument_list|,
name|sig
argument_list|,
operator|(
name|status
operator|&
literal|0200
operator|)
condition|?
literal|", core dumped"
else|:
literal|""
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
argument_list|(
literal|"%s terminated with signal %d [%s]%s"
argument_list|,
name|prog
argument_list|,
name|sig
argument_list|,
name|sys_siglist
index|[
name|sig
index|]
argument_list|,
operator|(
name|status
operator|&
literal|0200
operator|)
condition|?
literal|", core dumped"
else|:
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|collect_exit
argument_list|(
literal|127
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|WIFEXITED
argument_list|(
name|status
argument_list|)
condition|)
return|return
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_wait
parameter_list|(
name|prog
parameter_list|)
name|char
modifier|*
name|prog
decl_stmt|;
block|{
name|int
name|ret
init|=
name|collect_wait
argument_list|(
name|prog
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"%s returned %d exit status"
argument_list|,
name|prog
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|collect_exit
argument_list|(
name|ret
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Fork and execute a program, and wait for the reply.  */
end_comment

begin_function
name|void
name|collect_execute
parameter_list|(
name|prog
parameter_list|,
name|argv
parameter_list|,
name|redir
parameter_list|)
name|char
modifier|*
name|prog
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
name|redir
decl_stmt|;
block|{
name|int
name|pid
decl_stmt|;
if|if
condition|(
name|vflag
operator|||
name|debug
condition|)
block|{
name|char
modifier|*
modifier|*
name|p_argv
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
if|if
condition|(
name|argv
index|[
literal|0
index|]
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[cannot find %s]"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
for|for
control|(
name|p_argv
operator|=
operator|&
name|argv
index|[
literal|1
index|]
init|;
operator|(
name|str
operator|=
operator|*
name|p_argv
operator|)
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
condition|;
name|p_argv
operator|++
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
comment|/* If we can't find a program we need, complain error.  Do this here      since we might not end up needing something that we couldn't find.  */
if|if
condition|(
name|argv
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"cannot find `%s'"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|pid
operator|=
name|vfork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|vfork
name|fatal_perror
argument_list|(
literal|"fork"
argument_list|)
expr_stmt|;
else|#
directive|else
name|fatal_perror
argument_list|(
literal|"vfork"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
comment|/* child context */
block|{
if|if
condition|(
name|redir
condition|)
block|{
name|unlink
argument_list|(
name|redir
argument_list|)
expr_stmt|;
if|if
condition|(
name|freopen
argument_list|(
name|redir
argument_list|,
literal|"a"
argument_list|,
name|stdout
argument_list|)
operator|==
name|NULL
condition|)
name|fatal_perror
argument_list|(
literal|"redirecting stdout"
argument_list|)
expr_stmt|;
if|if
condition|(
name|freopen
argument_list|(
name|redir
argument_list|,
literal|"a"
argument_list|,
name|stderr
argument_list|)
operator|==
name|NULL
condition|)
name|fatal_perror
argument_list|(
literal|"redirecting stderr"
argument_list|)
expr_stmt|;
block|}
name|execvp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|fatal_perror
argument_list|(
literal|"executing %s"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|fork_execute
parameter_list|(
name|prog
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
name|prog
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|collect_execute
argument_list|(
name|prog
argument_list|,
name|argv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|do_wait
argument_list|(
name|prog
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Unlink a file unless we are debugging.  */
end_comment

begin_function
specifier|static
name|void
name|maybe_unlink
parameter_list|(
name|file
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|debug
condition|)
name|unlink
argument_list|(
name|file
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[Leaving %s]\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add a name to a linked list.  */
end_comment

begin_function
specifier|static
name|void
name|add_to_list
parameter_list|(
name|head_ptr
parameter_list|,
name|name
parameter_list|)
name|struct
name|head
modifier|*
name|head_ptr
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|id
modifier|*
name|newid
init|=
operator|(
expr|struct
name|id
operator|*
operator|)
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|id
argument_list|)
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|struct
name|id
modifier|*
name|p
decl_stmt|;
specifier|static
name|long
name|sequence_number
init|=
literal|0
decl_stmt|;
name|strcpy
argument_list|(
name|newid
operator|->
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|head_ptr
operator|->
name|first
condition|)
name|head_ptr
operator|->
name|last
operator|->
name|next
operator|=
name|newid
expr_stmt|;
else|else
name|head_ptr
operator|->
name|first
operator|=
name|newid
expr_stmt|;
comment|/* Check for duplicate symbols.  */
for|for
control|(
name|p
operator|=
name|head_ptr
operator|->
name|first
init|;
name|strcmp
argument_list|(
name|name
argument_list|,
name|p
operator|->
name|name
argument_list|)
operator|!=
literal|0
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
empty_stmt|;
if|if
condition|(
name|p
operator|!=
name|newid
condition|)
block|{
name|head_ptr
operator|->
name|last
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|newid
argument_list|)
expr_stmt|;
return|return;
block|}
name|newid
operator|->
name|sequence
operator|=
operator|++
name|sequence_number
expr_stmt|;
name|head_ptr
operator|->
name|last
operator|=
name|newid
expr_stmt|;
name|head_ptr
operator|->
name|number
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write: `prefix', the names on list LIST, `suffix'.  */
end_comment

begin_function
specifier|static
name|void
name|write_list
parameter_list|(
name|stream
parameter_list|,
name|prefix
parameter_list|,
name|list
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|char
modifier|*
name|prefix
decl_stmt|;
name|struct
name|id
modifier|*
name|list
decl_stmt|;
block|{
while|while
condition|(
name|list
condition|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%sx%d,\n"
argument_list|,
name|prefix
argument_list|,
name|list
operator|->
name|sequence
argument_list|)
expr_stmt|;
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|write_list_with_asm
parameter_list|(
name|stream
parameter_list|,
name|prefix
parameter_list|,
name|list
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|char
modifier|*
name|prefix
decl_stmt|;
name|struct
name|id
modifier|*
name|list
decl_stmt|;
block|{
while|while
condition|(
name|list
condition|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%sx%d __asm__ (\"%s\");\n"
argument_list|,
name|prefix
argument_list|,
name|list
operator|->
name|sequence
argument_list|,
name|list
operator|->
name|name
argument_list|)
expr_stmt|;
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Write out the constructor and destructor tables statically (for a shared    object), along with the functions to execute them.  */
end_comment

begin_function
specifier|static
name|void
name|write_c_file_stat
parameter_list|(
name|stream
parameter_list|,
name|name
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|char
modifier|*
name|prefix
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
comment|/* Figure out name of output_file, stripping off .so version.  */
name|p
operator|=
name|rindex
argument_list|(
name|output_file
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|output_file
expr_stmt|;
else|else
name|p
operator|++
expr_stmt|;
name|q
operator|=
name|p
expr_stmt|;
while|while
condition|(
name|q
condition|)
block|{
name|q
operator|=
name|index
argument_list|(
name|q
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|==
literal|0
condition|)
block|{
name|q
operator|=
name|p
operator|+
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|q
argument_list|,
literal|".so"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|q
operator|+=
literal|3
expr_stmt|;
break|break;
block|}
else|else
name|q
operator|++
expr_stmt|;
block|}
block|}
comment|/* q points to null at end of the string (or . of the .so version) */
name|prefix
operator|=
name|xmalloc
argument_list|(
name|q
operator|-
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|prefix
argument_list|,
name|p
argument_list|,
name|q
operator|-
name|p
argument_list|)
expr_stmt|;
name|prefix
index|[
name|q
operator|-
name|p
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|q
operator|=
name|prefix
init|;
operator|*
name|q
condition|;
name|q
operator|++
control|)
if|if
condition|(
operator|!
name|isalnum
argument_list|(
operator|*
name|q
argument_list|)
condition|)
operator|*
name|q
operator|=
literal|'_'
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nwrite_c_file - output name is %s, prefix is %s\n"
argument_list|,
name|output_file
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
define|#
directive|define
name|INIT_NAME_FORMAT
value|"_GLOBAL__FI_%s"
name|initname
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|prefix
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|INIT_NAME_FORMAT
argument_list|)
operator|-
literal|2
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|initname
argument_list|,
name|INIT_NAME_FORMAT
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
define|#
directive|define
name|FINI_NAME_FORMAT
value|"_GLOBAL__FD_%s"
name|fininame
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|prefix
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|FINI_NAME_FORMAT
argument_list|)
operator|-
literal|2
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|fininame
argument_list|,
name|FINI_NAME_FORMAT
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
comment|/* Write the tables as C code  */
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"static int count;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"typedef void entry_pt();\n"
argument_list|)
expr_stmt|;
name|write_list_with_asm
argument_list|(
name|stream
argument_list|,
literal|"extern entry_pt "
argument_list|,
name|constructors
operator|.
name|first
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"void %s() {\n"
argument_list|,
name|initname
argument_list|)
expr_stmt|;
if|if
condition|(
name|constructors
operator|.
name|number
operator|>
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\tstatic entry_pt *ctors[] = {\n"
argument_list|)
expr_stmt|;
name|write_list
argument_list|(
name|stream
argument_list|,
literal|"\t\t"
argument_list|,
name|constructors
operator|.
name|first
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t};\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\tentry_pt **p;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\tif (count++ != 0) return;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\tp = ctors + %d;\n"
argument_list|,
name|constructors
operator|.
name|number
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\twhile (p> ctors) (*--p)();\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t++count;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"}\n"
argument_list|)
expr_stmt|;
name|write_list_with_asm
argument_list|(
name|stream
argument_list|,
literal|"extern entry_pt "
argument_list|,
name|destructors
operator|.
name|first
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"void %s() {\n"
argument_list|,
name|fininame
argument_list|)
expr_stmt|;
if|if
condition|(
name|destructors
operator|.
name|number
operator|>
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\tstatic entry_pt *dtors[] = {\n"
argument_list|)
expr_stmt|;
name|write_list
argument_list|(
name|stream
argument_list|,
literal|"\t\t"
argument_list|,
name|destructors
operator|.
name|first
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t};\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\tentry_pt **p;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\tif (--count != 0) return;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\tp = dtors;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\twhile (p< dtors + %d) (*p++)();\n"
argument_list|,
name|destructors
operator|.
name|number
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"}\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|shared_obj
condition|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"void _GLOBAL__DI() {\n\t%s();\n}\n"
argument_list|,
name|initname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"void _GLOBAL__DD() {\n\t%s();\n}\n"
argument_list|,
name|fininame
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Write the constructor/destructor tables. */
end_comment

begin_function
specifier|static
name|void
name|write_c_file_glob
parameter_list|(
name|stream
parameter_list|,
name|name
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
comment|/* Write the tables as C code  */
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"typedef void entry_pt();\n\n"
argument_list|)
expr_stmt|;
name|write_list_with_asm
argument_list|(
name|stream
argument_list|,
literal|"extern entry_pt "
argument_list|,
name|constructors
operator|.
name|first
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\nentry_pt * __CTOR_LIST__[] = {\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t(entry_pt *) %d,\n"
argument_list|,
name|constructors
operator|.
name|number
argument_list|)
expr_stmt|;
name|write_list
argument_list|(
name|stream
argument_list|,
literal|"\t"
argument_list|,
name|constructors
operator|.
name|first
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t0\n};\n\n"
argument_list|)
expr_stmt|;
name|write_list_with_asm
argument_list|(
name|stream
argument_list|,
literal|"extern entry_pt "
argument_list|,
name|destructors
operator|.
name|first
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\nentry_pt * __DTOR_LIST__[] = {\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t(entry_pt *) %d,\n"
argument_list|,
name|destructors
operator|.
name|number
argument_list|)
expr_stmt|;
name|write_list
argument_list|(
name|stream
argument_list|,
literal|"\t"
argument_list|,
name|destructors
operator|.
name|first
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t0\n};\n\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"extern entry_pt %s;\n"
argument_list|,
name|NAME__MAIN
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"entry_pt *__main_reference = %s;\n\n"
argument_list|,
name|NAME__MAIN
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|write_c_file
parameter_list|(
name|stream
parameter_list|,
name|name
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|LD_INIT_SWITCH
if|if
condition|(
operator|!
name|shared_obj
condition|)
name|write_c_file_glob
argument_list|(
name|stream
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|write_c_file_stat
argument_list|(
name|stream
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|write_export_file
parameter_list|(
name|stream
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|struct
name|id
modifier|*
name|list
init|=
name|exports
operator|.
name|first
decl_stmt|;
for|for
control|(
init|;
name|list
condition|;
name|list
operator|=
name|list
operator|->
name|next
control|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%s\n"
argument_list|,
name|list
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|OBJECT_FORMAT_NONE
end_ifdef

begin_comment
comment|/* Generic version to scan the name list of the loaded program for    the symbols g++ uses for static constructors and destructors.     The constructor table begins at __CTOR_LIST__ and contains a count    of the number of pointers (or -1 if the constructors are built in a    separate section by the linker), followed by the pointers to the    constructor functions, terminated with a null pointer.  The    destructor table has the same format, and begins at __DTOR_LIST__.  */
end_comment

begin_function
specifier|static
name|void
name|scan_prog_file
parameter_list|(
name|prog_name
parameter_list|,
name|which_pass
parameter_list|)
name|char
modifier|*
name|prog_name
decl_stmt|;
name|enum
name|pass
name|which_pass
decl_stmt|;
block|{
name|void
function_decl|(
modifier|*
name|int_handler
function_decl|)
parameter_list|()
function_decl|;
name|void
function_decl|(
modifier|*
name|quit_handler
function_decl|)
parameter_list|()
function_decl|;
name|char
modifier|*
name|nm_argv
index|[
literal|4
index|]
decl_stmt|;
name|int
name|pid
decl_stmt|;
name|int
name|argc
init|=
literal|0
decl_stmt|;
name|int
name|pipe_fd
index|[
literal|2
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|FILE
modifier|*
name|inf
decl_stmt|;
if|if
condition|(
name|which_pass
operator|==
name|PASS_SECOND
condition|)
return|return;
comment|/* If we don't have an `nm', complain.  */
if|if
condition|(
name|nm_file_name
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"cannot find `nm'"
argument_list|)
expr_stmt|;
name|nm_argv
index|[
name|argc
operator|++
index|]
operator|=
name|nm_file_name
expr_stmt|;
if|if
condition|(
name|NM_FLAGS
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|nm_argv
index|[
name|argc
operator|++
index|]
operator|=
name|NM_FLAGS
expr_stmt|;
name|nm_argv
index|[
name|argc
operator|++
index|]
operator|=
name|prog_name
expr_stmt|;
name|nm_argv
index|[
name|argc
operator|++
index|]
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
if|if
condition|(
name|pipe
argument_list|(
name|pipe_fd
argument_list|)
operator|<
literal|0
condition|)
name|fatal_perror
argument_list|(
literal|"pipe"
argument_list|)
expr_stmt|;
name|inf
operator|=
name|fdopen
argument_list|(
name|pipe_fd
index|[
literal|0
index|]
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|inf
operator|==
operator|(
name|FILE
operator|*
operator|)
literal|0
condition|)
name|fatal_perror
argument_list|(
literal|"fdopen"
argument_list|)
expr_stmt|;
comment|/* Trace if needed.  */
if|if
condition|(
name|vflag
condition|)
block|{
name|char
modifier|*
modifier|*
name|p_argv
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
for|for
control|(
name|p_argv
operator|=
operator|&
name|nm_argv
index|[
literal|0
index|]
init|;
operator|(
name|str
operator|=
operator|*
name|p_argv
operator|)
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
condition|;
name|p_argv
operator|++
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
comment|/* Spawn child nm on pipe */
name|pid
operator|=
name|vfork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|vfork
name|fatal_perror
argument_list|(
literal|"fork"
argument_list|)
expr_stmt|;
else|#
directive|else
name|fatal_perror
argument_list|(
literal|"vfork"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
comment|/* child context */
block|{
comment|/* setup stdout */
if|if
condition|(
name|dup2
argument_list|(
name|pipe_fd
index|[
literal|1
index|]
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
name|fatal_perror
argument_list|(
literal|"dup2 (%d, 1)"
argument_list|,
name|pipe_fd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|pipe_fd
index|[
literal|0
index|]
argument_list|)
operator|<
literal|0
condition|)
name|fatal_perror
argument_list|(
literal|"close (%d)"
argument_list|,
name|pipe_fd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|pipe_fd
index|[
literal|1
index|]
argument_list|)
operator|<
literal|0
condition|)
name|fatal_perror
argument_list|(
literal|"close (%d)"
argument_list|,
name|pipe_fd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|execv
argument_list|(
name|nm_file_name
argument_list|,
name|nm_argv
argument_list|)
expr_stmt|;
name|fatal_perror
argument_list|(
literal|"executing %s"
argument_list|,
name|nm_file_name
argument_list|)
expr_stmt|;
block|}
comment|/* Parent context from here on.  */
name|int_handler
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGQUIT
name|quit_handler
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|close
argument_list|(
name|pipe_fd
index|[
literal|1
index|]
argument_list|)
operator|<
literal|0
condition|)
name|fatal_perror
argument_list|(
literal|"close (%d)"
argument_list|,
name|pipe_fd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nnm output with constructors/destructors.\n"
argument_list|)
expr_stmt|;
comment|/* Read each line of nm output.  */
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|inf
argument_list|)
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
block|{
name|int
name|ch
decl_stmt|,
name|ch2
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|end
decl_stmt|;
comment|/* If it contains a constructor or destructor name, add the name 	 to the appropriate list. */
for|for
control|(
name|p
operator|=
name|buf
init|;
operator|(
name|ch
operator|=
operator|*
name|p
operator|)
operator|!=
literal|'\0'
operator|&&
name|ch
operator|!=
literal|'\n'
operator|&&
name|ch
operator|!=
literal|'_'
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|ch
operator|==
literal|' '
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'U'
operator|&&
name|p
index|[
literal|2
index|]
operator|==
literal|' '
condition|)
break|break;
if|if
condition|(
name|ch
operator|!=
literal|'_'
condition|)
continue|continue;
name|name
operator|=
name|p
expr_stmt|;
comment|/* Find the end of the symbol name. 	 Don't include `|', because Encore nm can tack that on the end.  */
for|for
control|(
name|end
operator|=
name|p
init|;
operator|(
name|ch2
operator|=
operator|*
name|end
operator|)
operator|!=
literal|'\0'
operator|&&
operator|!
name|isspace
argument_list|(
name|ch2
argument_list|)
operator|&&
name|ch2
operator|!=
literal|'|'
condition|;
name|end
operator|++
control|)
continue|continue;
operator|*
name|end
operator|=
literal|'\0'
expr_stmt|;
switch|switch
condition|(
name|is_ctor_dtor
argument_list|(
name|name
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
if|if
condition|(
name|which_pass
operator|!=
name|PASS_LIB
condition|)
name|add_to_list
argument_list|(
operator|&
name|constructors
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
if|if
condition|(
name|which_pass
operator|!=
name|PASS_LIB
condition|)
name|add_to_list
argument_list|(
operator|&
name|destructors
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
if|if
condition|(
name|which_pass
operator|!=
name|PASS_LIB
condition|)
name|fatal
argument_list|(
literal|"init function found in object %s"
argument_list|,
name|prog_name
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|LD_INIT_SWITCH
name|add_to_list
argument_list|(
operator|&
name|constructors
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|4
case|:
if|if
condition|(
name|which_pass
operator|!=
name|PASS_LIB
condition|)
name|fatal
argument_list|(
literal|"fini function found in object %s"
argument_list|,
name|prog_name
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|LD_FINI_SWITCH
name|add_to_list
argument_list|(
operator|&
name|destructors
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
default|default:
comment|/* not a constructor or destructor */
continue|continue;
block|}
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t%s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|inf
argument_list|)
operator|!=
literal|0
condition|)
name|fatal_perror
argument_list|(
literal|"fclose of pipe"
argument_list|)
expr_stmt|;
name|do_wait
argument_list|(
name|nm_file_name
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|int_handler
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGQUIT
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|quit_handler
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_if
if|#
directive|if
name|SUNOS4_SHARED_LIBRARIES
end_if

begin_comment
comment|/* Routines to scan the SunOS 4 _DYNAMIC structure to find shared libraries    that the output file depends upon and their initialization/finalization    routines, if any.  */
end_comment

begin_include
include|#
directive|include
file|<a.out.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<link.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_comment
comment|/* pointers to the object file */
end_comment

begin_decl_stmt
name|unsigned
name|object
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* address of memory mapped file */
end_comment

begin_decl_stmt
name|unsigned
name|objsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* size of memory mapped to file */
end_comment

begin_decl_stmt
name|char
modifier|*
name|code
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointer to code segment */
end_comment

begin_decl_stmt
name|char
modifier|*
name|data
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointer to data segment */
end_comment

begin_decl_stmt
name|struct
name|nlist
modifier|*
name|symtab
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointer to symbol table */
end_comment

begin_decl_stmt
name|struct
name|link_dynamic
modifier|*
name|ld
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|link_dynamic_2
modifier|*
name|ld_2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|head
name|libraries
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Map the file indicated by NAME into memory and store its address.  */
end_comment

begin_function
specifier|static
name|void
name|mapfile
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|fp
decl_stmt|;
name|struct
name|stat
name|s
decl_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|open
argument_list|(
name|name
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|"unable to open file '%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|fp
argument_list|,
operator|&
name|s
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|"unable to stat file '%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|objsize
operator|=
name|s
operator|.
name|st_size
expr_stmt|;
name|object
operator|=
operator|(
name|unsigned
operator|)
name|mmap
argument_list|(
literal|0
argument_list|,
name|objsize
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_PRIVATE
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|object
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|"unable to mmap file '%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Helpers for locatelib.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|libname
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|libselect
parameter_list|(
name|d
parameter_list|)
name|struct
name|direct
modifier|*
name|d
decl_stmt|;
block|{
return|return
operator|(
name|strncmp
argument_list|(
name|libname
argument_list|,
name|d
operator|->
name|d_name
argument_list|,
name|strlen
argument_list|(
name|libname
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* If one file has an additional numeric extension past LIBNAME, then put    that one first in the sort.  If both files have additional numeric    extensions, then put the one with the higher number first in the sort.     We must verify that the extension is numeric, because Sun saves the    original versions of patched libraries with a .FCS extension.  Files with    invalid extensions must go last in the sort, so that they won't be used.  */
end_comment

begin_function
specifier|static
name|int
name|libcompare
parameter_list|(
name|d1
parameter_list|,
name|d2
parameter_list|)
name|struct
name|direct
modifier|*
modifier|*
name|d1
decl_stmt|,
decl|*
modifier|*
name|d2
decl_stmt|;
end_function

begin_block
block|{
name|int
name|i1
decl_stmt|,
name|i2
init|=
name|strlen
argument_list|(
name|libname
argument_list|)
decl_stmt|;
name|char
modifier|*
name|e1
init|=
operator|(
operator|*
name|d1
operator|)
operator|->
name|d_name
operator|+
name|i2
decl_stmt|;
name|char
modifier|*
name|e2
init|=
operator|(
operator|*
name|d2
operator|)
operator|->
name|d_name
operator|+
name|i2
decl_stmt|;
while|while
condition|(
operator|*
name|e1
operator|&&
operator|*
name|e2
operator|&&
operator|*
name|e1
operator|==
literal|'.'
operator|&&
operator|*
name|e2
operator|==
literal|'.'
operator|&&
name|e1
index|[
literal|1
index|]
operator|&&
name|isdigit
argument_list|(
name|e1
index|[
literal|1
index|]
argument_list|)
operator|&&
name|e2
index|[
literal|1
index|]
operator|&&
name|isdigit
argument_list|(
name|e2
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
operator|++
name|e1
expr_stmt|;
operator|++
name|e2
expr_stmt|;
name|i1
operator|=
name|strtol
argument_list|(
name|e1
argument_list|,
operator|&
name|e1
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|i2
operator|=
name|strtol
argument_list|(
name|e2
argument_list|,
operator|&
name|e2
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|i1
operator|!=
name|i2
condition|)
return|return
name|i1
operator|-
name|i2
return|;
block|}
if|if
condition|(
operator|*
name|e1
condition|)
block|{
comment|/* It has a valid numeric extension, prefer this one.  */
if|if
condition|(
operator|*
name|e1
operator|==
literal|'.'
operator|&&
name|e1
index|[
literal|1
index|]
operator|&&
name|isdigit
argument_list|(
name|e1
index|[
literal|1
index|]
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* It has a invalid numeric extension, must prefer the other one.  */
else|else
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|e2
condition|)
block|{
comment|/* It has a valid numeric extension, prefer this one.  */
if|if
condition|(
operator|*
name|e2
operator|==
literal|'.'
operator|&&
name|e2
index|[
literal|1
index|]
operator|&&
name|isdigit
argument_list|(
name|e2
index|[
literal|1
index|]
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* It has a invalid numeric extension, must prefer the other one.  */
else|else
return|return
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Given the name NAME of a dynamic dependency, find its pathname and add    it to the list of libraries.  */
end_comment

begin_function
specifier|static
name|void
name|locatelib
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
modifier|*
name|l
decl_stmt|;
specifier|static
name|int
name|cnt
decl_stmt|;
name|char
name|buf
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
if|if
condition|(
name|l
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|ld_rules
decl_stmt|;
name|char
modifier|*
name|ldr
init|=
literal|0
decl_stmt|;
comment|/* counting elements in array, need 1 extra for null */
name|cnt
operator|=
literal|1
expr_stmt|;
name|ld_rules
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|ld_2
operator|->
name|ld_rules
operator|+
name|code
operator|)
expr_stmt|;
if|if
condition|(
name|ld_rules
condition|)
block|{
name|cnt
operator|++
expr_stmt|;
for|for
control|(
init|;
operator|*
name|ld_rules
operator|!=
literal|0
condition|;
name|ld_rules
operator|++
control|)
if|if
condition|(
operator|*
name|ld_rules
operator|==
literal|':'
condition|)
name|cnt
operator|++
expr_stmt|;
name|ld_rules
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|ld_2
operator|->
name|ld_rules
operator|+
name|code
operator|)
expr_stmt|;
name|ldr
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|ld_rules
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|ldr
argument_list|,
name|ld_rules
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|getenv
argument_list|(
literal|"LD_LIBRARY_PATH"
argument_list|)
expr_stmt|;
name|q
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
condition|)
block|{
name|cnt
operator|++
expr_stmt|;
for|for
control|(
name|q
operator|=
name|p
init|;
operator|*
name|q
operator|!=
literal|0
condition|;
name|q
operator|++
control|)
if|if
condition|(
operator|*
name|q
operator|==
literal|':'
condition|)
name|cnt
operator|++
expr_stmt|;
name|q
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|q
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
name|l
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|cnt
operator|+
literal|3
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|pp
operator|=
name|l
expr_stmt|;
if|if
condition|(
name|ldr
condition|)
block|{
operator|*
name|pp
operator|++
operator|=
name|ldr
expr_stmt|;
for|for
control|(
init|;
operator|*
name|ldr
operator|!=
literal|0
condition|;
name|ldr
operator|++
control|)
if|if
condition|(
operator|*
name|ldr
operator|==
literal|':'
condition|)
block|{
operator|*
name|ldr
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|pp
operator|++
operator|=
name|ldr
expr_stmt|;
block|}
block|}
if|if
condition|(
name|q
condition|)
block|{
operator|*
name|pp
operator|++
operator|=
name|q
expr_stmt|;
for|for
control|(
init|;
operator|*
name|q
operator|!=
literal|0
condition|;
name|q
operator|++
control|)
if|if
condition|(
operator|*
name|q
operator|==
literal|':'
condition|)
block|{
operator|*
name|q
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|pp
operator|++
operator|=
name|q
expr_stmt|;
block|}
block|}
comment|/* built in directories are /lib, /usr/lib, and /usr/local/lib */
operator|*
name|pp
operator|++
operator|=
literal|"/lib"
expr_stmt|;
operator|*
name|pp
operator|++
operator|=
literal|"/usr/lib"
expr_stmt|;
operator|*
name|pp
operator|++
operator|=
literal|"/usr/local/lib"
expr_stmt|;
operator|*
name|pp
operator|=
literal|0
expr_stmt|;
block|}
name|libname
operator|=
name|name
expr_stmt|;
for|for
control|(
name|pp
operator|=
name|l
init|;
operator|*
name|pp
operator|!=
literal|0
condition|;
name|pp
operator|++
control|)
block|{
name|struct
name|direct
modifier|*
modifier|*
name|namelist
decl_stmt|;
name|int
name|entries
decl_stmt|;
if|if
condition|(
operator|(
name|entries
operator|=
name|scandir
argument_list|(
operator|*
name|pp
argument_list|,
operator|&
name|namelist
argument_list|,
name|libselect
argument_list|,
name|libcompare
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s/%s"
argument_list|,
operator|*
name|pp
argument_list|,
name|namelist
index|[
name|entries
operator|-
literal|1
index|]
operator|->
name|d_name
argument_list|)
expr_stmt|;
name|add_to_list
argument_list|(
operator|&
name|libraries
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|*
name|pp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"not found\n"
argument_list|)
expr_stmt|;
else|else
name|fatal
argument_list|(
literal|"dynamic dependency %s not found"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Scan the _DYNAMIC structure of the output file to find shared libraries    that it depends upon and any constructors or destructors they contain.  */
end_comment

begin_function
specifier|static
name|void
name|scan_libraries
parameter_list|(
name|prog_name
parameter_list|)
name|char
modifier|*
name|prog_name
decl_stmt|;
block|{
name|struct
name|exec
modifier|*
name|header
decl_stmt|;
name|char
modifier|*
name|base
decl_stmt|;
name|struct
name|link_object
modifier|*
name|lo
decl_stmt|;
name|char
name|buff
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|struct
name|id
modifier|*
name|list
decl_stmt|;
name|mapfile
argument_list|(
name|prog_name
argument_list|)
expr_stmt|;
name|header
operator|=
operator|(
expr|struct
name|exec
operator|*
operator|)
name|object
expr_stmt|;
if|if
condition|(
name|N_BADMAG
argument_list|(
operator|*
name|header
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"bad magic number in file '%s'"
argument_list|,
name|prog_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|header
operator|->
name|a_dynamic
operator|==
literal|0
condition|)
return|return;
name|code
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|N_TXTOFF
argument_list|(
operator|*
name|header
argument_list|)
operator|+
operator|(
name|long
operator|)
name|header
operator|)
expr_stmt|;
name|data
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|N_DATOFF
argument_list|(
operator|*
name|header
argument_list|)
operator|+
operator|(
name|long
operator|)
name|header
operator|)
expr_stmt|;
name|symtab
operator|=
operator|(
expr|struct
name|nlist
operator|*
operator|)
operator|(
name|N_SYMOFF
argument_list|(
operator|*
name|header
argument_list|)
operator|+
operator|(
name|long
operator|)
name|header
operator|)
expr_stmt|;
if|if
condition|(
name|header
operator|->
name|a_magic
operator|==
name|ZMAGIC
operator|&&
name|header
operator|->
name|a_entry
operator|==
literal|0x20
condition|)
block|{
comment|/* shared object */
name|ld
operator|=
operator|(
expr|struct
name|link_dynamic
operator|*
operator|)
operator|(
name|symtab
operator|->
name|n_value
operator|+
name|code
operator|)
expr_stmt|;
name|base
operator|=
name|code
expr_stmt|;
block|}
else|else
block|{
comment|/* executable */
name|ld
operator|=
operator|(
expr|struct
name|link_dynamic
operator|*
operator|)
name|data
expr_stmt|;
name|base
operator|=
name|code
operator|-
name|PAGSIZ
expr_stmt|;
block|}
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"dynamic dependencies.\n"
argument_list|)
expr_stmt|;
name|ld_2
operator|=
operator|(
expr|struct
name|link_dynamic_2
operator|*
operator|)
operator|(
operator|(
name|long
operator|)
name|ld
operator|->
name|ld_un
operator|.
name|ld_2
operator|+
operator|(
name|long
operator|)
name|base
operator|)
expr_stmt|;
for|for
control|(
name|lo
operator|=
operator|(
expr|struct
name|link_object
operator|*
operator|)
name|ld_2
operator|->
name|ld_need
init|;
name|lo
condition|;
name|lo
operator|=
operator|(
expr|struct
name|link_object
operator|*
operator|)
name|lo
operator|->
name|lo_next
control|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|lo
operator|=
operator|(
expr|struct
name|link_object
operator|*
operator|)
operator|(
operator|(
name|long
operator|)
name|lo
operator|+
name|code
operator|)
expr_stmt|;
name|name
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|code
operator|+
name|lo
operator|->
name|lo_name
operator|)
expr_stmt|;
if|if
condition|(
name|lo
operator|->
name|lo_library
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t-l%s.%d => "
argument_list|,
name|name
argument_list|,
name|lo
operator|->
name|lo_major
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"lib%s.so.%d.%d"
argument_list|,
name|name
argument_list|,
name|lo
operator|->
name|lo_major
argument_list|,
name|lo
operator|->
name|lo_minor
argument_list|)
expr_stmt|;
name|locatelib
argument_list|(
name|buff
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t%s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|add_to_list
argument_list|(
operator|&
name|libraries
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* now iterate through the library list adding their symbols to      the list.  */
for|for
control|(
name|list
operator|=
name|libraries
operator|.
name|first
init|;
name|list
condition|;
name|list
operator|=
name|list
operator|->
name|next
control|)
name|scan_prog_file
argument_list|(
name|list
operator|->
name|name
argument_list|,
name|PASS_LIB
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* SUNOS4_SHARED_LIBRARIES */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|LDD_SUFFIX
end_ifdef

begin_comment
comment|/* Use the List Dynamic Dependencies program to find shared libraries that    the output file depends upon and their initialization/finalization    routines, if any.  */
end_comment

begin_function
specifier|static
name|void
name|scan_libraries
parameter_list|(
name|prog_name
parameter_list|)
name|char
modifier|*
name|prog_name
decl_stmt|;
block|{
specifier|static
name|struct
name|head
name|libraries
decl_stmt|;
comment|/* list of shared libraries found */
name|struct
name|id
modifier|*
name|list
decl_stmt|;
name|void
function_decl|(
modifier|*
name|int_handler
function_decl|)
parameter_list|()
function_decl|;
name|void
function_decl|(
modifier|*
name|quit_handler
function_decl|)
parameter_list|()
function_decl|;
name|char
modifier|*
name|ldd_argv
index|[
literal|4
index|]
decl_stmt|;
name|int
name|pid
decl_stmt|;
name|int
name|argc
init|=
literal|0
decl_stmt|;
name|int
name|pipe_fd
index|[
literal|2
index|]
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|FILE
modifier|*
name|inf
decl_stmt|;
comment|/* If we don't have an `ldd', complain.  */
if|if
condition|(
name|ldd_file_name
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"cannot find `ldd'"
argument_list|)
expr_stmt|;
return|return;
block|}
name|ldd_argv
index|[
name|argc
operator|++
index|]
operator|=
name|ldd_file_name
expr_stmt|;
name|ldd_argv
index|[
name|argc
operator|++
index|]
operator|=
name|prog_name
expr_stmt|;
name|ldd_argv
index|[
name|argc
operator|++
index|]
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
if|if
condition|(
name|pipe
argument_list|(
name|pipe_fd
argument_list|)
operator|<
literal|0
condition|)
name|fatal_perror
argument_list|(
literal|"pipe"
argument_list|)
expr_stmt|;
name|inf
operator|=
name|fdopen
argument_list|(
name|pipe_fd
index|[
literal|0
index|]
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|inf
operator|==
operator|(
name|FILE
operator|*
operator|)
literal|0
condition|)
name|fatal_perror
argument_list|(
literal|"fdopen"
argument_list|)
expr_stmt|;
comment|/* Trace if needed.  */
if|if
condition|(
name|vflag
condition|)
block|{
name|char
modifier|*
modifier|*
name|p_argv
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
for|for
control|(
name|p_argv
operator|=
operator|&
name|ldd_argv
index|[
literal|0
index|]
init|;
operator|(
name|str
operator|=
operator|*
name|p_argv
operator|)
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
condition|;
name|p_argv
operator|++
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
comment|/* Spawn child ldd on pipe */
name|pid
operator|=
name|vfork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|vfork
name|fatal_perror
argument_list|(
literal|"fork"
argument_list|)
expr_stmt|;
else|#
directive|else
name|fatal_perror
argument_list|(
literal|"vfork"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
comment|/* child context */
block|{
comment|/* setup stdout */
if|if
condition|(
name|dup2
argument_list|(
name|pipe_fd
index|[
literal|1
index|]
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
name|fatal_perror
argument_list|(
literal|"dup2 (%d, 1)"
argument_list|,
name|pipe_fd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|pipe_fd
index|[
literal|0
index|]
argument_list|)
operator|<
literal|0
condition|)
name|fatal_perror
argument_list|(
literal|"close (%d)"
argument_list|,
name|pipe_fd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|pipe_fd
index|[
literal|1
index|]
argument_list|)
operator|<
literal|0
condition|)
name|fatal_perror
argument_list|(
literal|"close (%d)"
argument_list|,
name|pipe_fd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|execv
argument_list|(
name|ldd_file_name
argument_list|,
name|ldd_argv
argument_list|)
expr_stmt|;
name|fatal_perror
argument_list|(
literal|"executing %s"
argument_list|,
name|ldd_file_name
argument_list|)
expr_stmt|;
block|}
comment|/* Parent context from here on.  */
name|int_handler
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGQUIT
name|quit_handler
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|close
argument_list|(
name|pipe_fd
index|[
literal|1
index|]
argument_list|)
operator|<
literal|0
condition|)
name|fatal_perror
argument_list|(
literal|"close (%d)"
argument_list|,
name|pipe_fd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nldd output with constructors/destructors.\n"
argument_list|)
expr_stmt|;
comment|/* Read each line of ldd output.  */
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|inf
argument_list|)
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
block|{
name|int
name|ch
decl_stmt|,
name|ch2
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|end
decl_stmt|,
modifier|*
name|p
init|=
name|buf
decl_stmt|;
comment|/* Extract names of libraries and add to list. */
name|PARSE_LDD_OUTPUT
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
continue|continue;
name|name
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"not found"
argument_list|,
sizeof|sizeof
argument_list|(
literal|"not found"
argument_list|)
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"dynamic dependency %s not found"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* Find the end of the symbol name. */
for|for
control|(
name|end
operator|=
name|p
init|;
operator|(
name|ch2
operator|=
operator|*
name|end
operator|)
operator|!=
literal|'\0'
operator|&&
name|ch2
operator|!=
literal|'\n'
operator|&&
operator|!
name|isspace
argument_list|(
name|ch2
argument_list|)
operator|&&
name|ch2
operator|!=
literal|'|'
condition|;
name|end
operator|++
control|)
continue|continue;
operator|*
name|end
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|name
argument_list|,
name|R_OK
argument_list|)
operator|==
literal|0
condition|)
name|add_to_list
argument_list|(
operator|&
name|libraries
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|fatal
argument_list|(
literal|"unable to open dynamic dependency '%s'"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t%s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|inf
argument_list|)
operator|!=
literal|0
condition|)
name|fatal_perror
argument_list|(
literal|"fclose of pipe"
argument_list|)
expr_stmt|;
name|do_wait
argument_list|(
name|ldd_file_name
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|int_handler
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGQUIT
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|quit_handler
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* now iterate through the library list adding their symbols to      the list.  */
for|for
control|(
name|list
operator|=
name|libraries
operator|.
name|first
init|;
name|list
condition|;
name|list
operator|=
name|list
operator|->
name|next
control|)
name|scan_prog_file
argument_list|(
name|list
operator|->
name|name
argument_list|,
name|PASS_LIB
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LDD_SUFFIX */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SUNOS4_SHARED_LIBRARIES */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJECT_FORMAT_NONE */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  * COFF specific stuff.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OBJECT_FORMAT_COFF
end_ifdef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|EXTENDED_COFF
argument_list|)
end_if

begin_define
define|#
directive|define
name|GCC_SYMBOLS
parameter_list|(
name|X
parameter_list|)
value|(SYMHEADER(X).isymMax + SYMHEADER(X).iextMax)
end_define

begin_define
define|#
directive|define
name|GCC_SYMENT
value|SYMR
end_define

begin_define
define|#
directive|define
name|GCC_OK_SYMBOL
parameter_list|(
name|X
parameter_list|)
value|((X).st == stProc&& (X).sc == scText)
end_define

begin_define
define|#
directive|define
name|GCC_SYMINC
parameter_list|(
name|X
parameter_list|)
value|(1)
end_define

begin_define
define|#
directive|define
name|GCC_SYMZERO
parameter_list|(
name|X
parameter_list|)
value|(SYMHEADER(X).isymMax)
end_define

begin_define
define|#
directive|define
name|GCC_CHECK_HDR
parameter_list|(
name|X
parameter_list|)
value|(PSYMTAB(X) != 0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|GCC_SYMBOLS
parameter_list|(
name|X
parameter_list|)
value|(HEADER(ldptr).f_nsyms)
end_define

begin_define
define|#
directive|define
name|GCC_SYMENT
value|SYMENT
end_define

begin_define
define|#
directive|define
name|GCC_OK_SYMBOL
parameter_list|(
name|X
parameter_list|)
define|\
value|(((X).n_sclass == C_EXT)&& \         (((X).n_type& N_TMASK) == (DT_NON<< N_BTSHFT) || \          ((X).n_type& N_TMASK) == (DT_FCN<< N_BTSHFT)))
end_define

begin_define
define|#
directive|define
name|GCC_SYMINC
parameter_list|(
name|X
parameter_list|)
value|((X).n_numaux+1)
end_define

begin_define
define|#
directive|define
name|GCC_SYMZERO
parameter_list|(
name|X
parameter_list|)
value|0
end_define

begin_define
define|#
directive|define
name|GCC_CHECK_HDR
parameter_list|(
name|X
parameter_list|)
value|(1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|extern
name|char
modifier|*
name|ldgetname
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* COFF version to scan the name list of the loaded program for    the symbols g++ uses for static constructors and destructors.     The constructor table begins at __CTOR_LIST__ and contains a count    of the number of pointers (or -1 if the constructors are built in a    separate section by the linker), followed by the pointers to the    constructor functions, terminated with a null pointer.  The    destructor table has the same format, and begins at __DTOR_LIST__.  */
end_comment

begin_function
specifier|static
name|void
name|scan_prog_file
parameter_list|(
name|prog_name
parameter_list|,
name|which_pass
parameter_list|)
name|char
modifier|*
name|prog_name
decl_stmt|;
name|enum
name|pass
name|which_pass
decl_stmt|;
block|{
name|LDFILE
modifier|*
name|ldptr
init|=
name|NULL
decl_stmt|;
name|int
name|sym_index
decl_stmt|,
name|sym_count
decl_stmt|;
if|if
condition|(
name|which_pass
operator|!=
name|PASS_FIRST
operator|&&
name|which_pass
operator|!=
name|PASS_OBJ
condition|)
return|return;
if|if
condition|(
operator|(
name|ldptr
operator|=
name|ldopen
argument_list|(
name|prog_name
argument_list|,
name|ldptr
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"%s: can't open as COFF file"
argument_list|,
name|prog_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|MY_ISCOFF
argument_list|(
name|HEADER
argument_list|(
name|ldptr
argument_list|)
operator|.
name|f_magic
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"%s: not a COFF file"
argument_list|,
name|prog_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|GCC_CHECK_HDR
argument_list|(
name|ldptr
argument_list|)
condition|)
block|{
name|sym_count
operator|=
name|GCC_SYMBOLS
argument_list|(
name|ldptr
argument_list|)
expr_stmt|;
name|sym_index
operator|=
name|GCC_SYMZERO
argument_list|(
name|ldptr
argument_list|)
expr_stmt|;
while|while
condition|(
name|sym_index
operator|<
name|sym_count
condition|)
block|{
name|GCC_SYMENT
name|symbol
decl_stmt|;
if|if
condition|(
name|ldtbread
argument_list|(
name|ldptr
argument_list|,
name|sym_index
argument_list|,
operator|&
name|symbol
argument_list|)
operator|<=
literal|0
condition|)
break|break;
name|sym_index
operator|+=
name|GCC_SYMINC
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|GCC_OK_SYMBOL
argument_list|(
name|symbol
argument_list|)
condition|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
operator|(
name|name
operator|=
name|ldgetname
argument_list|(
name|ldptr
argument_list|,
operator|&
name|symbol
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
comment|/* should never happen */
ifdef|#
directive|ifdef
name|XCOFF_DEBUGGING_INFO
comment|/* All AIX function names have a duplicate entry beginning 		 with a dot. */
if|if
condition|(
operator|*
name|name
operator|==
literal|'.'
condition|)
operator|++
name|name
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|is_ctor_dtor
argument_list|(
name|name
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
name|add_to_list
argument_list|(
operator|&
name|constructors
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|which_pass
operator|==
name|PASS_OBJ
condition|)
name|add_to_list
argument_list|(
operator|&
name|exports
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|add_to_list
argument_list|(
operator|&
name|destructors
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|which_pass
operator|==
name|PASS_OBJ
condition|)
name|add_to_list
argument_list|(
operator|&
name|exports
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* not a constructor or destructor */
if|if
condition|(
name|which_pass
operator|==
name|PASS_OBJ
operator|&&
name|auto_export
condition|)
name|add_to_list
argument_list|(
operator|&
name|exports
argument_list|,
name|name
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|EXTENDED_COFF
argument_list|)
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tsec=%d class=%d type=%s%o %s\n"
argument_list|,
name|symbol
operator|.
name|n_scnum
argument_list|,
name|symbol
operator|.
name|n_sclass
argument_list|,
operator|(
name|symbol
operator|.
name|n_type
condition|?
literal|"0"
else|:
literal|""
operator|)
argument_list|,
name|symbol
operator|.
name|n_type
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tiss = %5d, value = %5d, index = %5d, name = %s\n"
argument_list|,
name|symbol
operator|.
name|iss
argument_list|,
name|symbol
operator|.
name|value
argument_list|,
name|symbol
operator|.
name|index
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
operator|(
name|void
operator|)
name|ldclose
argument_list|(
name|ldptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|XCOFF_SCAN_LIBS
end_ifdef

begin_comment
comment|/* Scan imported AIX libraries for GCC static ctors and dtors.    FIXME: it is possible to link an executable without the actual import 	  library by using an "import file" - a text file listing symbols 	  exported by a library.  To support this, we would have to scan 	  import files as well as actual shared binaries to find GCC ctors.    TODO: use memory mapping instead of 'ld' routines, files are already 	 memory mapped, but we could eliminate the extra in-memory copies. 	 Is it worth the effort?  */
end_comment

begin_function
specifier|static
name|void
name|scan_libraries
parameter_list|(
name|prog_name
parameter_list|)
name|char
modifier|*
name|prog_name
decl_stmt|;
block|{
name|LDFILE
modifier|*
name|ldptr
decl_stmt|;
name|SCNHDR
name|ldsh
decl_stmt|;
specifier|static
name|struct
name|path_prefix
name|libpath
decl_stmt|;
comment|/* we should only do this once */
if|if
condition|(
operator|(
name|ldptr
operator|=
name|ldopen
argument_list|(
name|prog_name
argument_list|,
name|ldptr
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"%s: can't open as COFF file"
argument_list|,
name|prog_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|MY_ISCOFF
argument_list|(
name|HEADER
argument_list|(
name|ldptr
argument_list|)
operator|.
name|f_magic
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"%s: not a COFF file"
argument_list|,
name|prog_name
argument_list|)
expr_stmt|;
comment|/* find and read loader section */
if|if
condition|(
name|ldnshread
argument_list|(
name|ldptr
argument_list|,
name|_LOADER
argument_list|,
operator|&
name|ldsh
argument_list|)
condition|)
block|{
name|LDHDR
name|ldh
decl_stmt|;
name|char
modifier|*
name|impbuf
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|FSEEK
argument_list|(
name|ldptr
argument_list|,
name|ldsh
operator|.
name|s_scnptr
argument_list|,
name|BEGINNING
argument_list|)
expr_stmt|;
name|FREAD
argument_list|(
operator|&
name|ldh
argument_list|,
sizeof|sizeof
name|ldh
argument_list|,
literal|1
argument_list|,
name|ldptr
argument_list|)
expr_stmt|;
comment|/* read import library list */
name|impbuf
operator|=
name|alloca
argument_list|(
name|ldh
operator|.
name|l_istlen
argument_list|)
expr_stmt|;
name|FSEEK
argument_list|(
name|ldptr
argument_list|,
name|ldh
operator|.
name|l_impoff
operator|+
name|ldsh
operator|.
name|s_scnptr
argument_list|,
name|BEGINNING
argument_list|)
expr_stmt|;
name|FREAD
argument_list|(
name|impbuf
argument_list|,
name|ldh
operator|.
name|l_istlen
argument_list|,
literal|1
argument_list|,
name|ldptr
argument_list|)
expr_stmt|;
name|idx
operator|=
name|strlen
argument_list|(
name|impbuf
argument_list|)
operator|+
literal|1
expr_stmt|;
name|idx
operator|+=
name|strlen
argument_list|(
name|impbuf
operator|+
name|idx
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"LIBPATH=%s\n"
argument_list|,
name|impbuf
argument_list|)
expr_stmt|;
name|prefix_from_string
argument_list|(
name|impbuf
argument_list|,
operator|&
name|libpath
argument_list|)
expr_stmt|;
while|while
condition|(
name|idx
operator|<
name|ldh
operator|.
name|l_istlen
condition|)
block|{
name|char
modifier|*
name|implib
init|=
name|impbuf
operator|+
name|idx
decl_stmt|;
name|char
modifier|*
name|impmem
init|=
name|implib
operator|+
name|strlen
argument_list|(
name|implib
argument_list|)
operator|+
literal|1
decl_stmt|;
name|char
modifier|*
name|soname
init|=
literal|0
decl_stmt|;
name|LDFILE
modifier|*
name|libptr
init|=
name|NULL
decl_stmt|;
name|struct
name|prefix_list
modifier|*
name|pl
decl_stmt|;
name|ARCHDR
name|ah
decl_stmt|;
name|idx
operator|+=
name|strlen
argument_list|(
name|implib
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|implib
index|[
literal|0
index|]
condition|)
continue|continue;
name|idx
operator|+=
name|strlen
argument_list|(
name|impmem
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|implib
operator|==
literal|'/'
condition|)
block|{
if|if
condition|(
name|access
argument_list|(
name|soname
argument_list|,
name|R_OK
argument_list|)
operator|==
literal|0
condition|)
name|soname
operator|=
name|implib
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|temp
init|=
name|alloca
argument_list|(
name|libpath
operator|.
name|max_len
operator|+
name|strlen
argument_list|(
name|implib
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
for|for
control|(
name|pl
operator|=
name|libpath
operator|.
name|plist
init|;
name|pl
condition|;
name|pl
operator|=
name|pl
operator|->
name|next
control|)
block|{
name|strcpy
argument_list|(
name|temp
argument_list|,
name|pl
operator|->
name|prefix
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp
argument_list|,
name|implib
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|temp
argument_list|,
name|R_OK
argument_list|)
operator|==
literal|0
condition|)
block|{
name|soname
operator|=
name|temp
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|soname
condition|)
block|{
name|fatal
argument_list|(
literal|"%s: library not found"
argument_list|,
name|implib
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|debug
condition|)
block|{
if|if
condition|(
name|impmem
index|[
literal|0
index|]
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s (%s)\n"
argument_list|,
name|soname
argument_list|,
name|impmem
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|soname
argument_list|)
expr_stmt|;
block|}
name|ah
operator|.
name|ar_name
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
do|do
block|{
comment|/* scan imported shared objects for GCC GLOBAL ctors */
name|short
name|type
decl_stmt|;
if|if
condition|(
operator|(
name|libptr
operator|=
name|ldopen
argument_list|(
name|soname
argument_list|,
name|libptr
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"%s: can't open import library"
argument_list|,
name|soname
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|libptr
argument_list|)
operator|==
name|ARTYPE
condition|)
block|{
name|LDFILE
modifier|*
name|memptr
decl_stmt|;
if|if
condition|(
operator|!
name|impmem
index|[
literal|0
index|]
condition|)
name|fatal
argument_list|(
literal|"%s: no archive member specified"
argument_list|,
name|soname
argument_list|)
expr_stmt|;
name|ldahread
argument_list|(
name|libptr
argument_list|,
operator|&
name|ah
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|ah
operator|.
name|ar_name
argument_list|,
name|impmem
argument_list|)
condition|)
continue|continue;
block|}
name|type
operator|=
name|HEADER
argument_list|(
name|libptr
argument_list|)
operator|.
name|f_magic
expr_stmt|;
if|if
condition|(
name|HEADER
argument_list|(
name|libptr
argument_list|)
operator|.
name|f_flags
operator|&
name|F_SHROBJ
condition|)
block|{
name|SCNHDR
name|soldsh
decl_stmt|;
name|LDHDR
name|soldh
decl_stmt|;
name|long
name|symcnt
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
name|ldstrings
decl_stmt|;
name|LDSYM
modifier|*
name|lsyms
decl_stmt|;
if|if
condition|(
operator|!
name|ldnshread
argument_list|(
name|libptr
argument_list|,
name|_LOADER
argument_list|,
operator|&
name|soldsh
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"%s: not an import library"
argument_list|,
name|soname
argument_list|)
expr_stmt|;
name|FSEEK
argument_list|(
name|libptr
argument_list|,
name|soldsh
operator|.
name|s_scnptr
argument_list|,
name|BEGINNING
argument_list|)
expr_stmt|;
if|if
condition|(
name|FREAD
argument_list|(
operator|&
name|soldh
argument_list|,
sizeof|sizeof
name|soldh
argument_list|,
literal|1
argument_list|,
name|libptr
argument_list|)
operator|!=
literal|1
condition|)
name|fatal
argument_list|(
literal|"%s: can't read loader section"
argument_list|,
name|soname
argument_list|)
expr_stmt|;
comment|/*fprintf (stderr, "\tscanning %s\n", soname);*/
name|symcnt
operator|=
name|soldh
operator|.
name|l_nsyms
expr_stmt|;
name|lsyms
operator|=
operator|(
name|LDSYM
operator|*
operator|)
name|alloca
argument_list|(
name|symcnt
operator|*
sizeof|sizeof
expr|*
name|lsyms
argument_list|)
expr_stmt|;
name|symcnt
operator|=
name|FREAD
argument_list|(
name|lsyms
argument_list|,
sizeof|sizeof
expr|*
name|lsyms
argument_list|,
name|symcnt
argument_list|,
name|libptr
argument_list|)
expr_stmt|;
name|ldstrings
operator|=
name|alloca
argument_list|(
name|soldh
operator|.
name|l_stlen
argument_list|)
expr_stmt|;
name|FSEEK
argument_list|(
name|libptr
argument_list|,
name|soldsh
operator|.
name|s_scnptr
operator|+
name|soldh
operator|.
name|l_stoff
argument_list|,
name|BEGINNING
argument_list|)
expr_stmt|;
name|FREAD
argument_list|(
name|ldstrings
argument_list|,
name|soldh
operator|.
name|l_stlen
argument_list|,
literal|1
argument_list|,
name|libptr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|symcnt
condition|;
operator|++
name|i
control|)
block|{
name|LDSYM
modifier|*
name|l
init|=
name|lsyms
operator|+
name|i
decl_stmt|;
if|if
condition|(
name|LDR_EXPORT
argument_list|(
operator|*
name|l
argument_list|)
condition|)
block|{
name|char
modifier|*
name|expname
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|l
operator|->
name|l_zeroes
condition|)
name|expname
operator|=
name|l
operator|->
name|l_name
expr_stmt|;
elseif|else
if|if
condition|(
name|l
operator|->
name|l_offset
operator|<
name|soldh
operator|.
name|l_stlen
condition|)
name|expname
operator|=
name|ldstrings
operator|+
name|l
operator|->
name|l_offset
expr_stmt|;
switch|switch
condition|(
name|is_ctor_dtor
argument_list|(
name|expname
argument_list|)
condition|)
block|{
case|case
literal|3
case|:
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t%s\n"
argument_list|,
name|expname
argument_list|)
expr_stmt|;
name|add_to_list
argument_list|(
operator|&
name|constructors
argument_list|,
name|expname
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|add_to_list
argument_list|(
operator|&
name|destructors
argument_list|,
name|expname
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* not a constructor or destructor */
continue|continue;
block|}
block|}
block|}
block|}
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: type = %04X flags = %04X\n"
argument_list|,
name|ah
operator|.
name|ar_name
argument_list|,
name|type
argument_list|,
name|HEADER
argument_list|(
name|libptr
argument_list|)
operator|.
name|f_flags
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ldclose
argument_list|(
name|libptr
argument_list|)
operator|==
name|FAILURE
condition|)
do|;
comment|/* printf (stderr, "closed %s\n", soname); */
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* XCOFF_SCAN_LIBS */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJECT_FORMAT_COFF */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  * OSF/rose specific stuff.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OBJECT_FORMAT_ROSE
end_ifdef

begin_comment
comment|/* Union of the various load commands */
end_comment

begin_typedef
typedef|typedef
union|union
name|load_union
block|{
name|ldc_header_t
name|hdr
decl_stmt|;
comment|/* common header */
name|load_cmd_map_command_t
name|map
decl_stmt|;
comment|/* map indexing other load cmds */
name|interpreter_command_t
name|iprtr
decl_stmt|;
comment|/* interpreter pathname */
name|strings_command_t
name|str
decl_stmt|;
comment|/* load commands strings section */
name|region_command_t
name|region
decl_stmt|;
comment|/* region load command */
name|reloc_command_t
name|reloc
decl_stmt|;
comment|/* relocation section */
name|package_command_t
name|pkg
decl_stmt|;
comment|/* package load command */
name|symbols_command_t
name|sym
decl_stmt|;
comment|/* symbol sections */
name|entry_command_t
name|ent
decl_stmt|;
comment|/* program start section */
name|gen_info_command_t
name|info
decl_stmt|;
comment|/* object information */
name|func_table_command_t
name|func
decl_stmt|;
comment|/* function constructors/destructors */
block|}
name|load_union_t
typedef|;
end_typedef

begin_comment
comment|/* Structure to point to load command and data section in memory.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|load_all
block|{
name|load_union_t
modifier|*
name|load
decl_stmt|;
comment|/* load command */
name|char
modifier|*
name|section
decl_stmt|;
comment|/* pointer to section */
block|}
name|load_all_t
typedef|;
end_typedef

begin_comment
comment|/* Structure to contain information about a file mapped into memory.  */
end_comment

begin_struct
struct|struct
name|file_info
block|{
name|char
modifier|*
name|start
decl_stmt|;
comment|/* start of map */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* filename */
name|long
name|size
decl_stmt|;
comment|/* size of the file */
name|long
name|rounded_size
decl_stmt|;
comment|/* size rounded to page boundary */
name|int
name|fd
decl_stmt|;
comment|/* file descriptor */
name|int
name|rw
decl_stmt|;
comment|/* != 0 if opened read/write */
name|int
name|use_mmap
decl_stmt|;
comment|/* != 0 if mmap'ed */
block|}
struct|;
end_struct

begin_function_decl
specifier|extern
name|int
name|decode_mach_o_hdr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|encode_mach_o_hdr
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|add_func_table
name|PROTO
argument_list|(
operator|(
name|mo_header_t
operator|*
operator|,
name|load_all_t
operator|*
operator|,
name|symbol_info_t
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_header
name|PROTO
argument_list|(
operator|(
name|mo_header_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_load_command
name|PROTO
argument_list|(
operator|(
name|load_union_t
operator|*
operator|,
name|size_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|bad_header
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|file_info
modifier|*
name|read_file
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|end_file
name|PROTO
argument_list|(
operator|(
expr|struct
name|file_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* OSF/rose specific version to scan the name list of the loaded    program for the symbols g++ uses for static constructors and    destructors.     The constructor table begins at __CTOR_LIST__ and contains a count    of the number of pointers (or -1 if the constructors are built in a    separate section by the linker), followed by the pointers to the    constructor functions, terminated with a null pointer.  The    destructor table has the same format, and begins at __DTOR_LIST__.  */
end_comment

begin_function
specifier|static
name|void
name|scan_prog_file
parameter_list|(
name|prog_name
parameter_list|,
name|which_pass
parameter_list|)
name|char
modifier|*
name|prog_name
decl_stmt|;
name|enum
name|pass
name|which_pass
decl_stmt|;
block|{
name|char
modifier|*
name|obj
decl_stmt|;
name|mo_header_t
name|hdr
decl_stmt|;
name|load_all_t
modifier|*
name|load_array
decl_stmt|;
name|load_all_t
modifier|*
name|load_end
decl_stmt|;
name|load_all_t
modifier|*
name|load_cmd
decl_stmt|;
name|int
name|symbol_load_cmds
decl_stmt|;
name|off_t
name|offset
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|num_syms
decl_stmt|;
name|int
name|status
decl_stmt|;
name|char
modifier|*
name|str_sect
decl_stmt|;
name|struct
name|file_info
modifier|*
name|obj_file
decl_stmt|;
name|int
name|prog_fd
decl_stmt|;
name|mo_lcid_t
name|cmd_strings
init|=
operator|-
literal|1
decl_stmt|;
name|symbol_info_t
modifier|*
name|main_sym
init|=
literal|0
decl_stmt|;
name|int
name|rw
init|=
operator|(
name|which_pass
operator|!=
name|PASS_FIRST
operator|)
decl_stmt|;
name|prog_fd
operator|=
name|open
argument_list|(
name|prog_name
argument_list|,
operator|(
name|rw
operator|)
condition|?
name|O_RDWR
else|:
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|prog_fd
operator|<
literal|0
condition|)
name|fatal_perror
argument_list|(
literal|"can't read %s"
argument_list|,
name|prog_name
argument_list|)
expr_stmt|;
name|obj_file
operator|=
name|read_file
argument_list|(
name|prog_name
argument_list|,
name|prog_fd
argument_list|,
name|rw
argument_list|)
expr_stmt|;
name|obj
operator|=
name|obj_file
operator|->
name|start
expr_stmt|;
name|status
operator|=
name|decode_mach_o_hdr
argument_list|(
name|obj
argument_list|,
name|MO_SIZEOF_RAW_HDR
argument_list|,
name|MOH_HEADER_VERSION
argument_list|,
operator|&
name|hdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|MO_HDR_CONV_SUCCESS
condition|)
name|bad_header
argument_list|(
name|status
argument_list|)
expr_stmt|;
comment|/* Do some basic sanity checks.  Note we explicitly use the big endian magic number,      since the hardware will automatically swap bytes for us on loading little endian      integers.  */
ifndef|#
directive|ifndef
name|CROSS_COMPILE
if|if
condition|(
name|hdr
operator|.
name|moh_magic
operator|!=
name|MOH_MAGIC_MSB
operator|||
name|hdr
operator|.
name|moh_header_version
operator|!=
name|MOH_HEADER_VERSION
operator|||
name|hdr
operator|.
name|moh_byte_order
operator|!=
name|OUR_BYTE_ORDER
operator|||
name|hdr
operator|.
name|moh_data_rep_id
operator|!=
name|OUR_DATA_REP_ID
operator|||
name|hdr
operator|.
name|moh_cpu_type
operator|!=
name|OUR_CPU_TYPE
operator|||
name|hdr
operator|.
name|moh_cpu_subtype
operator|!=
name|OUR_CPU_SUBTYPE
operator|||
name|hdr
operator|.
name|moh_vendor_type
operator|!=
name|OUR_VENDOR_TYPE
condition|)
block|{
name|fatal
argument_list|(
literal|"incompatibilities between object file& expected values"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|debug
condition|)
name|print_header
argument_list|(
operator|&
name|hdr
argument_list|)
expr_stmt|;
name|offset
operator|=
name|hdr
operator|.
name|moh_first_cmd_off
expr_stmt|;
name|load_end
operator|=
name|load_array
operator|=
operator|(
name|load_all_t
operator|*
operator|)
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|load_all_t
argument_list|)
argument_list|,
name|hdr
operator|.
name|moh_n_load_cmds
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* Build array of load commands, calculating the offsets */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hdr
operator|.
name|moh_n_load_cmds
condition|;
name|i
operator|++
control|)
block|{
name|load_union_t
modifier|*
name|load_hdr
decl_stmt|;
comment|/* load command header */
name|load_cmd
operator|=
name|load_end
operator|++
expr_stmt|;
name|load_hdr
operator|=
operator|(
name|load_union_t
operator|*
operator|)
operator|(
name|obj
operator|+
name|offset
operator|)
expr_stmt|;
comment|/* If modifying the program file, copy the header.  */
if|if
condition|(
name|rw
condition|)
block|{
name|load_union_t
modifier|*
name|ptr
init|=
operator|(
name|load_union_t
operator|*
operator|)
name|xmalloc
argument_list|(
name|load_hdr
operator|->
name|hdr
operator|.
name|ldci_cmd_size
argument_list|)
decl_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|load_hdr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ptr
argument_list|,
name|load_hdr
operator|->
name|hdr
operator|.
name|ldci_cmd_size
argument_list|)
expr_stmt|;
name|load_hdr
operator|=
name|ptr
expr_stmt|;
comment|/* null out old command map, because we will rewrite at the end.  */
if|if
condition|(
name|ptr
operator|->
name|hdr
operator|.
name|ldci_cmd_type
operator|==
name|LDC_CMD_MAP
condition|)
block|{
name|cmd_strings
operator|=
name|ptr
operator|->
name|map
operator|.
name|lcm_ld_cmd_strings
expr_stmt|;
name|ptr
operator|->
name|hdr
operator|.
name|ldci_cmd_type
operator|=
name|LDC_UNDEFINED
expr_stmt|;
block|}
block|}
name|load_cmd
operator|->
name|load
operator|=
name|load_hdr
expr_stmt|;
if|if
condition|(
name|load_hdr
operator|->
name|hdr
operator|.
name|ldci_section_off
operator|>
literal|0
condition|)
name|load_cmd
operator|->
name|section
operator|=
name|obj
operator|+
name|load_hdr
operator|->
name|hdr
operator|.
name|ldci_section_off
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|print_load_command
argument_list|(
name|load_hdr
argument_list|,
name|offset
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|load_hdr
operator|->
name|hdr
operator|.
name|ldci_cmd_size
expr_stmt|;
block|}
comment|/* If the last command is the load command map and is not undefined,      decrement the count of load commands.  */
if|if
condition|(
name|rw
operator|&&
name|load_end
index|[
operator|-
literal|1
index|]
operator|.
name|load
operator|->
name|hdr
operator|.
name|ldci_cmd_type
operator|==
name|LDC_UNDEFINED
condition|)
block|{
name|load_end
operator|--
expr_stmt|;
name|hdr
operator|.
name|moh_n_load_cmds
operator|--
expr_stmt|;
block|}
comment|/* Go through and process each symbol table section.  */
name|symbol_load_cmds
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|load_cmd
operator|=
name|load_array
init|;
name|load_cmd
operator|<
name|load_end
condition|;
name|load_cmd
operator|++
control|)
block|{
name|load_union_t
modifier|*
name|load_hdr
init|=
name|load_cmd
operator|->
name|load
decl_stmt|;
if|if
condition|(
name|load_hdr
operator|->
name|hdr
operator|.
name|ldci_cmd_type
operator|==
name|LDC_SYMBOLS
condition|)
block|{
name|symbol_load_cmds
operator|++
expr_stmt|;
if|if
condition|(
name|debug
condition|)
block|{
name|char
modifier|*
name|kind
init|=
literal|"unknown"
decl_stmt|;
switch|switch
condition|(
name|load_hdr
operator|->
name|sym
operator|.
name|symc_kind
condition|)
block|{
case|case
name|SYMC_IMPORTS
case|:
name|kind
operator|=
literal|"imports"
expr_stmt|;
break|break;
case|case
name|SYMC_DEFINED_SYMBOLS
case|:
name|kind
operator|=
literal|"defined"
expr_stmt|;
break|break;
case|case
name|SYMC_STABS
case|:
name|kind
operator|=
literal|"stabs"
expr_stmt|;
break|break;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nProcessing symbol table #%d, offset = 0x%.8lx, kind = %s\n"
argument_list|,
name|symbol_load_cmds
argument_list|,
name|load_hdr
operator|->
name|hdr
operator|.
name|ldci_section_off
argument_list|,
name|kind
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|load_hdr
operator|->
name|sym
operator|.
name|symc_kind
operator|!=
name|SYMC_DEFINED_SYMBOLS
condition|)
continue|continue;
name|str_sect
operator|=
name|load_array
index|[
name|load_hdr
operator|->
name|sym
operator|.
name|symc_strings_section
index|]
operator|.
name|section
expr_stmt|;
if|if
condition|(
name|str_sect
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
name|fatal
argument_list|(
literal|"string section missing"
argument_list|)
expr_stmt|;
if|if
condition|(
name|load_cmd
operator|->
name|section
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
name|fatal
argument_list|(
literal|"section pointer missing"
argument_list|)
expr_stmt|;
name|num_syms
operator|=
name|load_hdr
operator|->
name|sym
operator|.
name|symc_nentries
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_syms
condition|;
name|i
operator|++
control|)
block|{
name|symbol_info_t
modifier|*
name|sym
init|=
operator|(
operator|(
name|symbol_info_t
operator|*
operator|)
name|load_cmd
operator|->
name|section
operator|)
operator|+
name|i
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|sym
operator|->
name|si_name
operator|.
name|symbol_name
operator|+
name|str_sect
decl_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|!=
literal|'_'
condition|)
continue|continue;
if|if
condition|(
name|rw
condition|)
block|{
name|char
modifier|*
name|n
init|=
name|name
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
operator|-
name|strlen
argument_list|(
name|NAME__MAIN
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|n
operator|-
name|name
operator|)
operator|<
literal|0
operator|||
name|strcmp
argument_list|(
name|n
argument_list|,
name|NAME__MAIN
argument_list|)
condition|)
continue|continue;
while|while
condition|(
name|n
operator|!=
name|name
condition|)
if|if
condition|(
operator|*
operator|--
name|n
operator|!=
literal|'_'
condition|)
continue|continue;
name|main_sym
operator|=
name|sym
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|is_ctor_dtor
argument_list|(
name|name
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
name|add_to_list
argument_list|(
operator|&
name|constructors
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|add_to_list
argument_list|(
operator|&
name|destructors
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* not a constructor or destructor */
continue|continue;
block|}
block|}
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ttype = 0x%.4x, sc = 0x%.2x, flags = 0x%.8x, name = %.30s\n"
argument_list|,
name|sym
operator|->
name|si_type
argument_list|,
name|sym
operator|->
name|si_sc_type
argument_list|,
name|sym
operator|->
name|si_flags
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|symbol_load_cmds
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"no symbol table found"
argument_list|)
expr_stmt|;
comment|/* Update the program file now, rewrite header and load commands.  At present,      we assume that there is enough space after the last load command to insert      one more.  Since the first section written out is page aligned, and the      number of load commands is small, this is ok for the present.  */
if|if
condition|(
name|rw
condition|)
block|{
name|load_union_t
modifier|*
name|load_map
decl_stmt|;
name|size_t
name|size
decl_stmt|;
if|if
condition|(
name|cmd_strings
operator|==
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|"no cmd_strings found"
argument_list|)
expr_stmt|;
comment|/* Add __main to initializer list. 	 If we are building a program instead of a shared library, don't 	 do anything, since in the current version, you cannot do mallocs 	 and such in the constructors.  */
if|if
condition|(
name|main_sym
operator|!=
operator|(
name|symbol_info_t
operator|*
operator|)
literal|0
operator|&&
operator|(
operator|(
name|hdr
operator|.
name|moh_flags
operator|&
name|MOH_EXECABLE_F
operator|)
operator|==
literal|0
operator|)
condition|)
name|add_func_table
argument_list|(
operator|&
name|hdr
argument_list|,
name|load_array
argument_list|,
name|main_sym
argument_list|,
name|FNTC_INITIALIZATION
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nUpdating header and load commands.\n\n"
argument_list|)
expr_stmt|;
name|hdr
operator|.
name|moh_n_load_cmds
operator|++
expr_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
name|load_cmd_map_command_t
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|mo_offset_t
argument_list|)
operator|*
operator|(
name|hdr
operator|.
name|moh_n_load_cmds
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
comment|/* Create new load command map.  */
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"load command map, %d cmds, new size %ld.\n"
argument_list|,
operator|(
name|int
operator|)
name|hdr
operator|.
name|moh_n_load_cmds
argument_list|,
operator|(
name|long
operator|)
name|size
argument_list|)
expr_stmt|;
name|load_map
operator|=
operator|(
name|load_union_t
operator|*
operator|)
name|xcalloc
argument_list|(
literal|1
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|load_map
operator|->
name|map
operator|.
name|ldc_header
operator|.
name|ldci_cmd_type
operator|=
name|LDC_CMD_MAP
expr_stmt|;
name|load_map
operator|->
name|map
operator|.
name|ldc_header
operator|.
name|ldci_cmd_size
operator|=
name|size
expr_stmt|;
name|load_map
operator|->
name|map
operator|.
name|lcm_ld_cmd_strings
operator|=
name|cmd_strings
expr_stmt|;
name|load_map
operator|->
name|map
operator|.
name|lcm_nentries
operator|=
name|hdr
operator|.
name|moh_n_load_cmds
expr_stmt|;
name|load_array
index|[
name|hdr
operator|.
name|moh_n_load_cmds
operator|-
literal|1
index|]
operator|.
name|load
operator|=
name|load_map
expr_stmt|;
name|offset
operator|=
name|hdr
operator|.
name|moh_first_cmd_off
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hdr
operator|.
name|moh_n_load_cmds
condition|;
name|i
operator|++
control|)
block|{
name|load_map
operator|->
name|map
operator|.
name|lcm_map
index|[
name|i
index|]
operator|=
name|offset
expr_stmt|;
if|if
condition|(
name|load_array
index|[
name|i
index|]
operator|.
name|load
operator|->
name|hdr
operator|.
name|ldci_cmd_type
operator|==
name|LDC_CMD_MAP
condition|)
name|hdr
operator|.
name|moh_load_map_cmd_off
operator|=
name|offset
expr_stmt|;
name|offset
operator|+=
name|load_array
index|[
name|i
index|]
operator|.
name|load
operator|->
name|hdr
operator|.
name|ldci_cmd_size
expr_stmt|;
block|}
name|hdr
operator|.
name|moh_sizeofcmds
operator|=
name|offset
operator|-
name|MO_SIZEOF_RAW_HDR
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|print_header
argument_list|(
operator|&
name|hdr
argument_list|)
expr_stmt|;
comment|/* Write header */
name|status
operator|=
name|encode_mach_o_hdr
argument_list|(
operator|&
name|hdr
argument_list|,
name|obj
argument_list|,
name|MO_SIZEOF_RAW_HDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|MO_HDR_CONV_SUCCESS
condition|)
name|bad_header
argument_list|(
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"writing load commands.\n\n"
argument_list|)
expr_stmt|;
comment|/* Write load commands */
name|offset
operator|=
name|hdr
operator|.
name|moh_first_cmd_off
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hdr
operator|.
name|moh_n_load_cmds
condition|;
name|i
operator|++
control|)
block|{
name|load_union_t
modifier|*
name|load_hdr
init|=
name|load_array
index|[
name|i
index|]
operator|.
name|load
decl_stmt|;
name|size_t
name|size
init|=
name|load_hdr
operator|->
name|hdr
operator|.
name|ldci_cmd_size
decl_stmt|;
if|if
condition|(
name|debug
condition|)
name|print_load_command
argument_list|(
name|load_hdr
argument_list|,
name|offset
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|load_hdr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|obj
operator|+
name|offset
operator|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|size
expr_stmt|;
block|}
block|}
name|end_file
argument_list|(
name|obj_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|prog_fd
argument_list|)
condition|)
name|fatal_perror
argument_list|(
literal|"closing %s"
argument_list|,
name|prog_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add a function table to the load commands to call a function    on initiation or termination of the process.  */
end_comment

begin_function
specifier|static
name|void
name|add_func_table
parameter_list|(
name|hdr_p
parameter_list|,
name|load_array
parameter_list|,
name|sym
parameter_list|,
name|type
parameter_list|)
name|mo_header_t
modifier|*
name|hdr_p
decl_stmt|;
comment|/* pointer to global header */
name|load_all_t
modifier|*
name|load_array
decl_stmt|;
comment|/* array of ptrs to load cmds */
name|symbol_info_t
modifier|*
name|sym
decl_stmt|;
comment|/* pointer to symbol entry */
name|int
name|type
decl_stmt|;
comment|/* fntc_type value */
block|{
comment|/* Add a new load command.  */
name|int
name|num_cmds
init|=
operator|++
name|hdr_p
operator|->
name|moh_n_load_cmds
decl_stmt|;
name|int
name|load_index
init|=
name|num_cmds
operator|-
literal|1
decl_stmt|;
name|size_t
name|size
init|=
sizeof|sizeof
argument_list|(
name|func_table_command_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|mo_addr_t
argument_list|)
decl_stmt|;
name|load_union_t
modifier|*
name|ptr
init|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
name|size
argument_list|)
decl_stmt|;
name|load_all_t
modifier|*
name|load_cmd
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Set the unresolved address bit in the header to force the loader to be      used, since kernel exec does not call the initialization functions.  */
name|hdr_p
operator|->
name|moh_flags
operator||=
name|MOH_UNRESOLVED_F
expr_stmt|;
name|load_cmd
operator|=
operator|&
name|load_array
index|[
name|load_index
index|]
expr_stmt|;
name|load_cmd
operator|->
name|load
operator|=
name|ptr
expr_stmt|;
name|load_cmd
operator|->
name|section
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* Fill in func table load command.  */
name|ptr
operator|->
name|func
operator|.
name|ldc_header
operator|.
name|ldci_cmd_type
operator|=
name|LDC_FUNC_TABLE
expr_stmt|;
name|ptr
operator|->
name|func
operator|.
name|ldc_header
operator|.
name|ldci_cmd_size
operator|=
name|size
expr_stmt|;
name|ptr
operator|->
name|func
operator|.
name|ldc_header
operator|.
name|ldci_section_off
operator|=
literal|0
expr_stmt|;
name|ptr
operator|->
name|func
operator|.
name|ldc_header
operator|.
name|ldci_section_len
operator|=
literal|0
expr_stmt|;
name|ptr
operator|->
name|func
operator|.
name|fntc_type
operator|=
name|type
expr_stmt|;
name|ptr
operator|->
name|func
operator|.
name|fntc_nentries
operator|=
literal|1
expr_stmt|;
comment|/* copy address, turn it from abs. address to (region,offset) if necessary.  */
comment|/* Is the symbol already expressed as (region, offset)?  */
if|if
condition|(
operator|(
name|sym
operator|->
name|si_flags
operator|&
name|SI_ABSOLUTE_VALUE_F
operator|)
operator|==
literal|0
condition|)
block|{
name|ptr
operator|->
name|func
operator|.
name|fntc_entry_loc
index|[
name|i
index|]
operator|.
name|adr_lcid
operator|=
name|sym
operator|->
name|si_value
operator|.
name|def_val
operator|.
name|adr_lcid
expr_stmt|;
name|ptr
operator|->
name|func
operator|.
name|fntc_entry_loc
index|[
name|i
index|]
operator|.
name|adr_sctoff
operator|=
name|sym
operator|->
name|si_value
operator|.
name|def_val
operator|.
name|adr_sctoff
expr_stmt|;
block|}
comment|/* If not, figure out which region it's in.  */
else|else
block|{
name|mo_vm_addr_t
name|addr
init|=
name|sym
operator|->
name|si_value
operator|.
name|abs_val
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|load_index
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|load_array
index|[
name|i
index|]
operator|.
name|load
operator|->
name|hdr
operator|.
name|ldci_cmd_type
operator|==
name|LDC_REGION
condition|)
block|{
name|region_command_t
modifier|*
name|region_ptr
init|=
operator|&
name|load_array
index|[
name|i
index|]
operator|.
name|load
operator|->
name|region
decl_stmt|;
if|if
condition|(
operator|(
name|region_ptr
operator|->
name|regc_flags
operator|&
name|REG_ABS_ADDR_F
operator|)
operator|!=
literal|0
operator|&&
name|addr
operator|>=
name|region_ptr
operator|->
name|regc_addr
operator|.
name|vm_addr
operator|&&
name|addr
operator|<=
name|region_ptr
operator|->
name|regc_addr
operator|.
name|vm_addr
operator|+
name|region_ptr
operator|->
name|regc_vm_size
condition|)
block|{
name|ptr
operator|->
name|func
operator|.
name|fntc_entry_loc
index|[
literal|0
index|]
operator|.
name|adr_lcid
operator|=
name|i
expr_stmt|;
name|ptr
operator|->
name|func
operator|.
name|fntc_entry_loc
index|[
literal|0
index|]
operator|.
name|adr_sctoff
operator|=
name|addr
operator|-
name|region_ptr
operator|->
name|regc_addr
operator|.
name|vm_addr
expr_stmt|;
name|found
operator|++
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
name|fatal
argument_list|(
literal|"could not convert 0x%l.8x into a region"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s function, region %d, offset = %ld (0x%.8lx)\n"
argument_list|,
operator|(
name|type
operator|==
name|FNTC_INITIALIZATION
operator|)
condition|?
literal|"init"
else|:
literal|"term"
argument_list|,
operator|(
name|int
operator|)
name|ptr
operator|->
name|func
operator|.
name|fntc_entry_loc
index|[
name|i
index|]
operator|.
name|adr_lcid
argument_list|,
operator|(
name|long
operator|)
name|ptr
operator|->
name|func
operator|.
name|fntc_entry_loc
index|[
name|i
index|]
operator|.
name|adr_sctoff
argument_list|,
operator|(
name|long
operator|)
name|ptr
operator|->
name|func
operator|.
name|fntc_entry_loc
index|[
name|i
index|]
operator|.
name|adr_sctoff
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print the global header for an OSF/rose object.  */
end_comment

begin_function
specifier|static
name|void
name|print_header
parameter_list|(
name|hdr_ptr
parameter_list|)
name|mo_header_t
modifier|*
name|hdr_ptr
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nglobal header:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tmoh_magic            = 0x%.8lx\n"
argument_list|,
name|hdr_ptr
operator|->
name|moh_magic
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tmoh_major_version    = %d\n"
argument_list|,
operator|(
name|int
operator|)
name|hdr_ptr
operator|->
name|moh_major_version
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tmoh_minor_version    = %d\n"
argument_list|,
operator|(
name|int
operator|)
name|hdr_ptr
operator|->
name|moh_minor_version
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tmoh_header_version   = %d\n"
argument_list|,
operator|(
name|int
operator|)
name|hdr_ptr
operator|->
name|moh_header_version
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tmoh_max_page_size    = %d\n"
argument_list|,
operator|(
name|int
operator|)
name|hdr_ptr
operator|->
name|moh_max_page_size
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tmoh_byte_order       = %d\n"
argument_list|,
operator|(
name|int
operator|)
name|hdr_ptr
operator|->
name|moh_byte_order
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tmoh_data_rep_id      = %d\n"
argument_list|,
operator|(
name|int
operator|)
name|hdr_ptr
operator|->
name|moh_data_rep_id
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tmoh_cpu_type         = %d\n"
argument_list|,
operator|(
name|int
operator|)
name|hdr_ptr
operator|->
name|moh_cpu_type
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tmoh_cpu_subtype      = %d\n"
argument_list|,
operator|(
name|int
operator|)
name|hdr_ptr
operator|->
name|moh_cpu_subtype
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tmoh_vendor_type      = %d\n"
argument_list|,
operator|(
name|int
operator|)
name|hdr_ptr
operator|->
name|moh_vendor_type
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tmoh_load_map_cmd_off = %d\n"
argument_list|,
operator|(
name|int
operator|)
name|hdr_ptr
operator|->
name|moh_load_map_cmd_off
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tmoh_first_cmd_off    = %d\n"
argument_list|,
operator|(
name|int
operator|)
name|hdr_ptr
operator|->
name|moh_first_cmd_off
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tmoh_sizeofcmds       = %d\n"
argument_list|,
operator|(
name|int
operator|)
name|hdr_ptr
operator|->
name|moh_sizeofcmds
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tmon_n_load_cmds      = %d\n"
argument_list|,
operator|(
name|int
operator|)
name|hdr_ptr
operator|->
name|moh_n_load_cmds
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tmoh_flags            = 0x%.8lx"
argument_list|,
operator|(
name|long
operator|)
name|hdr_ptr
operator|->
name|moh_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr_ptr
operator|->
name|moh_flags
operator|&
name|MOH_RELOCATABLE_F
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|", relocatable"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr_ptr
operator|->
name|moh_flags
operator|&
name|MOH_LINKABLE_F
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|", linkable"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr_ptr
operator|->
name|moh_flags
operator|&
name|MOH_EXECABLE_F
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|", execable"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr_ptr
operator|->
name|moh_flags
operator|&
name|MOH_EXECUTABLE_F
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|", executable"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr_ptr
operator|->
name|moh_flags
operator|&
name|MOH_UNRESOLVED_F
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|", unresolved"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print a short summary of a load command.  */
end_comment

begin_function
specifier|static
name|void
name|print_load_command
parameter_list|(
name|load_hdr
parameter_list|,
name|offset
parameter_list|,
name|number
parameter_list|)
name|load_union_t
modifier|*
name|load_hdr
decl_stmt|;
name|size_t
name|offset
decl_stmt|;
name|int
name|number
decl_stmt|;
block|{
name|mo_long_t
name|type
init|=
name|load_hdr
operator|->
name|hdr
operator|.
name|ldci_cmd_type
decl_stmt|;
name|char
modifier|*
name|type_str
init|=
operator|(
name|char
operator|*
operator|)
literal|0
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|LDC_UNDEFINED
case|:
name|type_str
operator|=
literal|"UNDEFINED"
expr_stmt|;
break|break;
case|case
name|LDC_CMD_MAP
case|:
name|type_str
operator|=
literal|"CMD_MAP"
expr_stmt|;
break|break;
case|case
name|LDC_INTERPRETER
case|:
name|type_str
operator|=
literal|"INTERPRETER"
expr_stmt|;
break|break;
case|case
name|LDC_STRINGS
case|:
name|type_str
operator|=
literal|"STRINGS"
expr_stmt|;
break|break;
case|case
name|LDC_REGION
case|:
name|type_str
operator|=
literal|"REGION"
expr_stmt|;
break|break;
case|case
name|LDC_RELOC
case|:
name|type_str
operator|=
literal|"RELOC"
expr_stmt|;
break|break;
case|case
name|LDC_PACKAGE
case|:
name|type_str
operator|=
literal|"PACKAGE"
expr_stmt|;
break|break;
case|case
name|LDC_SYMBOLS
case|:
name|type_str
operator|=
literal|"SYMBOLS"
expr_stmt|;
break|break;
case|case
name|LDC_ENTRY
case|:
name|type_str
operator|=
literal|"ENTRY"
expr_stmt|;
break|break;
case|case
name|LDC_FUNC_TABLE
case|:
name|type_str
operator|=
literal|"FUNC_TABLE"
expr_stmt|;
break|break;
case|case
name|LDC_GEN_INFO
case|:
name|type_str
operator|=
literal|"GEN_INFO"
expr_stmt|;
break|break;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"cmd %2d, sz: 0x%.2lx, coff: 0x%.3lx, doff: 0x%.6lx, dlen: 0x%.6lx"
argument_list|,
name|number
argument_list|,
operator|(
name|long
operator|)
name|load_hdr
operator|->
name|hdr
operator|.
name|ldci_cmd_size
argument_list|,
operator|(
name|long
operator|)
name|offset
argument_list|,
operator|(
name|long
operator|)
name|load_hdr
operator|->
name|hdr
operator|.
name|ldci_section_off
argument_list|,
operator|(
name|long
operator|)
name|load_hdr
operator|->
name|hdr
operator|.
name|ldci_section_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|type_str
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|", ty: unknown (%ld)\n"
argument_list|,
operator|(
name|long
operator|)
name|type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|!=
name|LDC_REGION
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|", ty: %s\n"
argument_list|,
name|type_str
argument_list|)
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|region
init|=
literal|""
decl_stmt|;
switch|switch
condition|(
name|load_hdr
operator|->
name|region
operator|.
name|regc_usage_type
condition|)
block|{
case|case
name|REG_TEXT_T
case|:
name|region
operator|=
literal|", .text"
expr_stmt|;
break|break;
case|case
name|REG_DATA_T
case|:
name|region
operator|=
literal|", .data"
expr_stmt|;
break|break;
case|case
name|REG_BSS_T
case|:
name|region
operator|=
literal|", .bss"
expr_stmt|;
break|break;
case|case
name|REG_GLUE_T
case|:
name|region
operator|=
literal|", .glue"
expr_stmt|;
break|break;
if|#
directive|if
name|defined
argument_list|(
name|REG_RDATA_T
argument_list|)
operator|&&
name|defined
argument_list|(
name|REG_SDATA_T
argument_list|)
operator|&&
name|defined
argument_list|(
name|REG_SBSS_T
argument_list|)
comment|/*mips*/
case|case
name|REG_RDATA_T
case|:
name|region
operator|=
literal|", .rdata"
expr_stmt|;
break|break;
case|case
name|REG_SDATA_T
case|:
name|region
operator|=
literal|", .sdata"
expr_stmt|;
break|break;
case|case
name|REG_SBSS_T
case|:
name|region
operator|=
literal|", .sbss"
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|", ty: %s, vaddr: 0x%.8lx, vlen: 0x%.6lx%s\n"
argument_list|,
name|type_str
argument_list|,
operator|(
name|long
operator|)
name|load_hdr
operator|->
name|region
operator|.
name|regc_vm_addr
argument_list|,
operator|(
name|long
operator|)
name|load_hdr
operator|->
name|region
operator|.
name|regc_vm_size
argument_list|,
name|region
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Fatal error when {en,de}code_mach_o_header fails.  */
end_comment

begin_function
specifier|static
name|void
name|bad_header
parameter_list|(
name|status
parameter_list|)
name|int
name|status
decl_stmt|;
block|{
name|char
modifier|*
name|msg
init|=
operator|(
name|char
operator|*
operator|)
literal|0
decl_stmt|;
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|MO_ERROR_BAD_MAGIC
case|:
name|msg
operator|=
literal|"bad magic number"
expr_stmt|;
break|break;
case|case
name|MO_ERROR_BAD_HDR_VERS
case|:
name|msg
operator|=
literal|"bad header version"
expr_stmt|;
break|break;
case|case
name|MO_ERROR_BAD_RAW_HDR_VERS
case|:
name|msg
operator|=
literal|"bad raw header version"
expr_stmt|;
break|break;
case|case
name|MO_ERROR_BUF2SML
case|:
name|msg
operator|=
literal|"raw header buffer too small"
expr_stmt|;
break|break;
case|case
name|MO_ERROR_OLD_RAW_HDR_FILE
case|:
name|msg
operator|=
literal|"old raw header file"
expr_stmt|;
break|break;
case|case
name|MO_ERROR_UNSUPPORTED_VERS
case|:
name|msg
operator|=
literal|"unsupported version"
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|msg
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
name|fatal
argument_list|(
literal|"unknown {de,en}code_mach_o_hdr return value %d"
argument_list|,
name|status
argument_list|)
expr_stmt|;
else|else
name|fatal
argument_list|(
literal|"%s"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read a file into a memory buffer.  */
end_comment

begin_function
specifier|static
name|struct
name|file_info
modifier|*
name|read_file
parameter_list|(
name|name
parameter_list|,
name|fd
parameter_list|,
name|rw
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
comment|/* filename */
name|int
name|fd
decl_stmt|;
comment|/* file descriptor */
name|int
name|rw
decl_stmt|;
comment|/* read/write */
block|{
name|struct
name|stat
name|stat_pkt
decl_stmt|;
name|struct
name|file_info
modifier|*
name|p
init|=
operator|(
expr|struct
name|file_info
operator|*
operator|)
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|file_info
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_MMAP
specifier|static
name|int
name|page_size
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|stat_pkt
argument_list|)
operator|<
literal|0
condition|)
name|fatal_perror
argument_list|(
literal|"fstat %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|p
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|p
operator|->
name|size
operator|=
name|stat_pkt
operator|.
name|st_size
expr_stmt|;
name|p
operator|->
name|rounded_size
operator|=
name|stat_pkt
operator|.
name|st_size
expr_stmt|;
name|p
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
name|p
operator|->
name|rw
operator|=
name|rw
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_MMAP
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"mmap %s, %s\n"
argument_list|,
name|name
argument_list|,
operator|(
name|rw
operator|)
condition|?
literal|"read/write"
else|:
literal|"read-only"
argument_list|)
expr_stmt|;
if|if
condition|(
name|page_size
operator|==
literal|0
condition|)
name|page_size
operator|=
name|sysconf
argument_list|(
name|_SC_PAGE_SIZE
argument_list|)
expr_stmt|;
name|p
operator|->
name|rounded_size
operator|=
operator|(
operator|(
name|p
operator|->
name|size
operator|+
name|page_size
operator|-
literal|1
operator|)
operator|/
name|page_size
operator|)
operator|*
name|page_size
expr_stmt|;
name|p
operator|->
name|start
operator|=
name|mmap
argument_list|(
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
operator|(
name|rw
operator|)
condition|?
name|p
operator|->
name|rounded_size
else|:
name|p
operator|->
name|size
argument_list|,
operator|(
name|rw
operator|)
condition|?
operator|(
name|PROT_READ
operator||
name|PROT_WRITE
operator|)
else|:
name|PROT_READ
argument_list|,
name|MAP_FILE
operator||
name|MAP_VARIABLE
operator||
name|MAP_SHARED
argument_list|,
name|fd
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|start
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
operator|&&
name|p
operator|->
name|start
operator|!=
operator|(
name|char
operator|*
operator|)
operator|-
literal|1
condition|)
name|p
operator|->
name|use_mmap
operator|=
literal|1
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* USE_MMAP */
block|{
name|long
name|len
decl_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"read %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|p
operator|->
name|use_mmap
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|start
operator|=
name|xmalloc
argument_list|(
name|p
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|fd
argument_list|,
literal|0L
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
name|fatal_perror
argument_list|(
literal|"lseek to 0 on %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|len
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|p
operator|->
name|start
argument_list|,
name|p
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
name|fatal_perror
argument_list|(
literal|"read %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|!=
name|p
operator|->
name|size
condition|)
name|fatal
argument_list|(
literal|"read %ld bytes, expected %ld, from %s"
argument_list|,
name|len
argument_list|,
name|p
operator|->
name|size
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Do anything necessary to write a file back from memory.  */
end_comment

begin_function
specifier|static
name|void
name|end_file
parameter_list|(
name|ptr
parameter_list|)
name|struct
name|file_info
modifier|*
name|ptr
decl_stmt|;
comment|/* file information block */
block|{
ifdef|#
directive|ifdef
name|USE_MMAP
if|if
condition|(
name|ptr
operator|->
name|use_mmap
condition|)
block|{
if|if
condition|(
name|ptr
operator|->
name|rw
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"msync %s\n"
argument_list|,
name|ptr
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|msync
argument_list|(
name|ptr
operator|->
name|start
argument_list|,
name|ptr
operator|->
name|rounded_size
argument_list|,
name|MS_ASYNC
argument_list|)
condition|)
name|fatal_perror
argument_list|(
literal|"msync %s"
argument_list|,
name|ptr
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"munmap %s\n"
argument_list|,
name|ptr
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|munmap
argument_list|(
name|ptr
operator|->
name|start
argument_list|,
name|ptr
operator|->
name|size
argument_list|)
condition|)
name|fatal_perror
argument_list|(
literal|"munmap %s"
argument_list|,
name|ptr
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* USE_MMAP */
block|{
if|if
condition|(
name|ptr
operator|->
name|rw
condition|)
block|{
name|long
name|len
decl_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"write %s\n"
argument_list|,
name|ptr
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|ptr
operator|->
name|fd
argument_list|,
literal|0L
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
name|fatal_perror
argument_list|(
literal|"lseek to 0 on %s"
argument_list|,
name|ptr
operator|->
name|name
argument_list|)
expr_stmt|;
name|len
operator|=
name|write
argument_list|(
name|ptr
operator|->
name|fd
argument_list|,
name|ptr
operator|->
name|start
argument_list|,
name|ptr
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
name|fatal_perror
argument_list|(
literal|"write %s"
argument_list|,
name|ptr
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|!=
name|ptr
operator|->
name|size
condition|)
name|fatal
argument_list|(
literal|"wrote %ld bytes, expected %ld, to %s"
argument_list|,
name|len
argument_list|,
name|ptr
operator|->
name|size
argument_list|,
name|ptr
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|ptr
operator|->
name|start
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJECT_FORMAT_ROSE */
end_comment

end_unit

