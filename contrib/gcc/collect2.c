begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Collect static initialization info into data structures that can be    traversed by C++ initialization and finalization routines.    Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.    Contributed by Chris Smith (csmith@convex.com).    Heavily modified by Michael Meissner (meissner@cygnus.com),    Per Bothner (bothner@cygnus.com), and John Gilmore (gnu@cygnus.com).  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* Build tables of static constructors and destructors and run ld.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SIGCHLD
argument_list|)
operator|&&
name|defined
argument_list|(
name|SIGCLD
argument_list|)
end_if

begin_define
define|#
directive|define
name|SIGCHLD
value|SIGCLD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LIBRARY_PATH_ENV
end_ifndef

begin_define
define|#
directive|define
name|LIBRARY_PATH_ENV
value|"LIBRARY_PATH"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|COLLECT
end_define

begin_include
include|#
directive|include
file|"collect2.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"intl.h"
end_include

begin_include
include|#
directive|include
file|"version.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* On certain systems, we have code that works by scanning the object file    directly.  But this code uses system-specific header files and library    functions, so turn it off in a cross-compiler.  Likewise, the names of    the utilities are not correct for a cross-compiler; we have to hope that    cross-versions are in the proper directories.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CROSS_COMPILE
end_ifdef

begin_undef
undef|#
directive|undef
name|OBJECT_FORMAT_COFF
end_undef

begin_undef
undef|#
directive|undef
name|MD_EXEC_PREFIX
end_undef

begin_undef
undef|#
directive|undef
name|REAL_LD_FILE_NAME
end_undef

begin_undef
undef|#
directive|undef
name|REAL_NM_FILE_NAME
end_undef

begin_undef
undef|#
directive|undef
name|REAL_STRIP_FILE_NAME
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* If we cannot use a special method, use the ordinary one:    run nm to find what symbols are present.    In a cross-compiler, this means you need a cross nm,    but that is not quite as unpleasant as special headers.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|OBJECT_FORMAT_COFF
argument_list|)
end_if

begin_define
define|#
directive|define
name|OBJECT_FORMAT_NONE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|OBJECT_FORMAT_COFF
end_ifdef

begin_include
include|#
directive|include
file|<a.out.h>
end_include

begin_include
include|#
directive|include
file|<ar.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|UMAX
end_ifdef

begin_include
include|#
directive|include
file|<sgs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Many versions of ldfcn.h define these.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|FREAD
end_ifdef

begin_undef
undef|#
directive|undef
name|FREAD
end_undef

begin_undef
undef|#
directive|undef
name|FWRITE
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<ldfcn.h>
end_include

begin_comment
comment|/* Some systems have an ISCOFF macro, but others do not.  In some cases    the macro may be wrong.  MY_ISCOFF is defined in tm.h files for machines    that either do not have an ISCOFF macro in /usr/include or for those    where it is wrong.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MY_ISCOFF
end_ifndef

begin_define
define|#
directive|define
name|MY_ISCOFF
parameter_list|(
name|X
parameter_list|)
value|ISCOFF (X)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJECT_FORMAT_COFF */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OBJECT_FORMAT_NONE
end_ifdef

begin_comment
comment|/* Default flags to pass to nm.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NM_FLAGS
end_ifndef

begin_define
define|#
directive|define
name|NM_FLAGS
value|"-n"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJECT_FORMAT_NONE */
end_comment

begin_comment
comment|/* Some systems use __main in a way incompatible with its use in gcc, in these    cases use the macros NAME__MAIN to give a quoted symbol and SYMBOL__MAIN to    give the same symbol without quotes for an alternative entry point.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NAME__MAIN
end_ifndef

begin_define
define|#
directive|define
name|NAME__MAIN
value|"__main"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This must match tree.h.  */
end_comment

begin_define
define|#
directive|define
name|DEFAULT_INIT_PRIORITY
value|65535
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|COLLECT_SHARED_INIT_FUNC
end_ifndef

begin_define
define|#
directive|define
name|COLLECT_SHARED_INIT_FUNC
parameter_list|(
name|STREAM
parameter_list|,
name|FUNC
parameter_list|)
define|\
value|fprintf ((STREAM), "void _GLOBAL__DI() {\n\t%s();\n}\n", (FUNC))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|COLLECT_SHARED_FINI_FUNC
end_ifndef

begin_define
define|#
directive|define
name|COLLECT_SHARED_FINI_FUNC
parameter_list|(
name|STREAM
parameter_list|,
name|FUNC
parameter_list|)
define|\
value|fprintf ((STREAM), "void _GLOBAL__DD() {\n\t%s();\n}\n", (FUNC))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|LDD_SUFFIX
end_ifdef

begin_define
define|#
directive|define
name|SCAN_LIBRARIES
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|USE_COLLECT2
end_ifdef

begin_decl_stmt
name|int
name|do_collecting
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|do_collecting
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Nonzero if we should suppress the automatic demangling of identifiers    in linker error messages.  Set from COLLECT_NO_DEMANGLE.  */
end_comment

begin_decl_stmt
name|int
name|no_demangle
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Linked lists of constructor and destructor names.  */
end_comment

begin_struct
struct|struct
name|id
block|{
name|struct
name|id
modifier|*
name|next
decl_stmt|;
name|int
name|sequence
decl_stmt|;
name|char
name|name
index|[
literal|1
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|head
block|{
name|struct
name|id
modifier|*
name|first
decl_stmt|;
name|struct
name|id
modifier|*
name|last
decl_stmt|;
name|int
name|number
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Enumeration giving which pass this is for scanning the program file.  */
end_comment

begin_enum
enum|enum
name|pass
block|{
name|PASS_FIRST
block|,
comment|/* without constructors */
name|PASS_OBJ
block|,
comment|/* individual objects */
name|PASS_LIB
block|,
comment|/* looking for shared libraries */
name|PASS_SECOND
comment|/* with constructors linked in */
block|}
enum|;
end_enum

begin_decl_stmt
name|int
name|vflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if -v */
end_comment

begin_decl_stmt
specifier|static
name|int
name|rflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if -r */
end_comment

begin_decl_stmt
specifier|static
name|int
name|strip_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if -s */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|demangle_flag
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|COLLECT_EXPORT_LIST
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|export_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if -bE */
end_comment

begin_decl_stmt
specifier|static
name|int
name|aix64_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if -b64 */
end_comment

begin_decl_stmt
specifier|static
name|int
name|aixrtl_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if -brtl */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|debug
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if -debug */
end_comment

begin_decl_stmt
specifier|static
name|int
name|shared_obj
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if -shared */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|c_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*<xxx>.c for constructor/destructor list.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|o_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*<xxx>.o for constructor/destructor list.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|COLLECT_EXPORT_LIST
end_ifdef

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|export_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*<xxx>.x for AIX export list.  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|const
name|char
modifier|*
name|ldout
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* File for ld stdout.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|lderrout
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* File for ld stderr.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|output_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Output file for ld.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|nm_file_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pathname of nm */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|LDD_SUFFIX
end_ifdef

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|ldd_file_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pathname of ldd (or equivalent) */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|strip_file_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pathname of strip */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|c_file_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pathname of gcc */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|initname
decl_stmt|,
modifier|*
name|fininame
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* names of init and fini funcs */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|head
name|constructors
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of constructors found */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|head
name|destructors
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of destructors found */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|COLLECT_EXPORT_LIST
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|head
name|exports
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of exported symbols */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|head
name|frame_tables
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of frame unwind info tables */
end_comment

begin_decl_stmt
name|struct
name|obstack
name|temporary_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|temporary_firstobj
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Structure to hold all the directories in which to search for files to    execute.  */
end_comment

begin_struct
struct|struct
name|prefix_list
block|{
specifier|const
name|char
modifier|*
name|prefix
decl_stmt|;
comment|/* String to prepend to the path.  */
name|struct
name|prefix_list
modifier|*
name|next
decl_stmt|;
comment|/* Next in linked list.  */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|path_prefix
block|{
name|struct
name|prefix_list
modifier|*
name|plist
decl_stmt|;
comment|/* List of prefixes to try */
name|int
name|max_len
decl_stmt|;
comment|/* Max length of a prefix in PLIST */
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Name of this list (used in config stuff) */
block|}
struct|;
end_struct

begin_ifdef
ifdef|#
directive|ifdef
name|COLLECT_EXPORT_LIST
end_ifdef

begin_comment
comment|/* Lists to keep libraries to be scanned for global constructors/destructors.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|head
name|libs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of libraries */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|path_prefix
name|cmdline_lib_dirs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* directories specified with -L */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|path_prefix
name|libpath_lib_dirs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* directories in LIBPATH */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|path_prefix
modifier|*
name|libpaths
index|[
literal|3
index|]
init|=
block|{
operator|&
name|cmdline_lib_dirs
block|,
operator|&
name|libpath_lib_dirs
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|handler
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|is_ctor_dtor
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|find_a_file
parameter_list|(
name|struct
name|path_prefix
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_prefix
parameter_list|(
name|struct
name|path_prefix
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|prefix_from_env
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|struct
name|path_prefix
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|prefix_from_string
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|struct
name|path_prefix
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_wait
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|struct
name|pex_obj
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fork_execute
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|maybe_unlink
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_to_list
parameter_list|(
name|struct
name|head
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|extract_init_priority
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sort_ids
parameter_list|(
name|struct
name|head
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_list
parameter_list|(
name|FILE
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|struct
name|id
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|COLLECT_EXPORT_LIST
end_ifdef

begin_function_decl
specifier|static
name|void
name|dump_list
parameter_list|(
name|FILE
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|struct
name|id
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void dump_prefix_list (FILE *, const char *, struct prefix_list *);
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|write_list_with_asm
parameter_list|(
name|FILE
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|struct
name|id
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_c_file
parameter_list|(
name|FILE
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_c_file_stat
parameter_list|(
name|FILE
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|LD_INIT_SWITCH
end_ifndef

begin_function_decl
specifier|static
name|void
name|write_c_file_glob
parameter_list|(
name|FILE
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|scan_prog_file
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|enum
name|pass
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|SCAN_LIBRARIES
end_ifdef

begin_function_decl
specifier|static
name|void
name|scan_libraries
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|LINK_ELIMINATE_DUPLICATE_LDIRECTORIES
end_if

begin_function_decl
specifier|static
name|int
name|is_in_args
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|COLLECT_EXPORT_LIST
end_ifdef

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static int is_in_list (const char *, struct id *);
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|write_aix_file
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|struct
name|id
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|resolve_lib_name
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|char
modifier|*
name|extract_string
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Delete tempfiles and exit function.  */
end_comment

begin_function
name|void
name|collect_exit
parameter_list|(
name|int
name|status
parameter_list|)
block|{
if|if
condition|(
name|c_file
operator|!=
literal|0
operator|&&
name|c_file
index|[
literal|0
index|]
condition|)
name|maybe_unlink
argument_list|(
name|c_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|o_file
operator|!=
literal|0
operator|&&
name|o_file
index|[
literal|0
index|]
condition|)
name|maybe_unlink
argument_list|(
name|o_file
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COLLECT_EXPORT_LIST
if|if
condition|(
name|export_file
operator|!=
literal|0
operator|&&
name|export_file
index|[
literal|0
index|]
condition|)
name|maybe_unlink
argument_list|(
name|export_file
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ldout
operator|!=
literal|0
operator|&&
name|ldout
index|[
literal|0
index|]
condition|)
block|{
name|dump_file
argument_list|(
name|ldout
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|maybe_unlink
argument_list|(
name|ldout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lderrout
operator|!=
literal|0
operator|&&
name|lderrout
index|[
literal|0
index|]
condition|)
block|{
name|dump_file
argument_list|(
name|lderrout
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|maybe_unlink
argument_list|(
name|lderrout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|!=
literal|0
operator|&&
name|output_file
operator|!=
literal|0
operator|&&
name|output_file
index|[
literal|0
index|]
condition|)
name|maybe_unlink
argument_list|(
name|output_file
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Notify user of a non-error.  */
end_comment

begin_function
name|void
name|notice
parameter_list|(
specifier|const
name|char
modifier|*
name|cmsgid
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|cmsgid
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
name|cmsgid
argument_list|)
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Die when sys call fails.  */
end_comment

begin_function
name|void
name|fatal_perror
parameter_list|(
specifier|const
name|char
modifier|*
name|cmsgid
parameter_list|,
modifier|...
parameter_list|)
block|{
name|int
name|e
init|=
name|errno
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|cmsgid
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"collect2: "
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
name|cmsgid
argument_list|)
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|": %s\n"
argument_list|,
name|xstrerror
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|collect_exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Just die.  */
end_comment

begin_function
name|void
name|fatal
parameter_list|(
specifier|const
name|char
modifier|*
name|cmsgid
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|cmsgid
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"collect2: "
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
name|cmsgid
argument_list|)
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|collect_exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write error message.  */
end_comment

begin_function
name|void
name|error
parameter_list|(
specifier|const
name|char
modifier|*
name|gmsgid
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|gmsgid
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"collect2: "
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
name|gmsgid
argument_list|)
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* In case obstack is linked in, and abort is defined to fancy_abort,    provide a default entry.  */
end_comment

begin_function
name|void
name|fancy_abort
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|func
parameter_list|)
block|{
name|fatal
argument_list|(
literal|"internal gcc abort in %s, at %s:%d"
argument_list|,
name|func
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|handler
parameter_list|(
name|int
name|signo
parameter_list|)
block|{
if|if
condition|(
name|c_file
operator|!=
literal|0
operator|&&
name|c_file
index|[
literal|0
index|]
condition|)
name|maybe_unlink
argument_list|(
name|c_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|o_file
operator|!=
literal|0
operator|&&
name|o_file
index|[
literal|0
index|]
condition|)
name|maybe_unlink
argument_list|(
name|o_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|ldout
operator|!=
literal|0
operator|&&
name|ldout
index|[
literal|0
index|]
condition|)
name|maybe_unlink
argument_list|(
name|ldout
argument_list|)
expr_stmt|;
if|if
condition|(
name|lderrout
operator|!=
literal|0
operator|&&
name|lderrout
index|[
literal|0
index|]
condition|)
name|maybe_unlink
argument_list|(
name|lderrout
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COLLECT_EXPORT_LIST
if|if
condition|(
name|export_file
operator|!=
literal|0
operator|&&
name|export_file
index|[
literal|0
index|]
condition|)
name|maybe_unlink
argument_list|(
name|export_file
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|signal
argument_list|(
name|signo
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|raise
argument_list|(
name|signo
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|int
name|file_exists
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
name|access
argument_list|(
name|name
argument_list|,
name|R_OK
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Parse a reasonable subset of shell quoting syntax.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|extract_string
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|pp
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
init|=
operator|*
name|pp
decl_stmt|;
name|int
name|backquote
init|=
literal|0
decl_stmt|;
name|int
name|inside
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
name|c
init|=
operator|*
name|p
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
break|break;
operator|++
name|p
expr_stmt|;
if|if
condition|(
name|backquote
condition|)
name|obstack_1grow
argument_list|(
operator|&
name|temporary_obstack
argument_list|,
name|c
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|inside
operator|&&
name|c
operator|==
literal|' '
condition|)
break|break;
elseif|else
if|if
condition|(
operator|!
name|inside
operator|&&
name|c
operator|==
literal|'\\'
condition|)
name|backquote
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\''
condition|)
name|inside
operator|=
operator|!
name|inside
expr_stmt|;
else|else
name|obstack_1grow
argument_list|(
operator|&
name|temporary_obstack
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
name|obstack_1grow
argument_list|(
operator|&
name|temporary_obstack
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
operator|*
name|pp
operator|=
name|p
expr_stmt|;
return|return
name|XOBFINISH
argument_list|(
operator|&
name|temporary_obstack
argument_list|,
name|char
operator|*
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|dump_file
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|FILE
modifier|*
name|to
parameter_list|)
block|{
name|FILE
modifier|*
name|stream
init|=
name|fopen
argument_list|(
name|name
argument_list|,
literal|"r"
argument_list|)
decl_stmt|;
if|if
condition|(
name|stream
operator|==
literal|0
condition|)
return|return;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|c
decl_stmt|;
while|while
condition|(
name|c
operator|=
name|getc
argument_list|(
name|stream
argument_list|)
operator|,
name|c
operator|!=
name|EOF
operator|&&
operator|(
name|ISIDNUM
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'$'
operator|||
name|c
operator|==
literal|'.'
operator|)
condition|)
name|obstack_1grow
argument_list|(
operator|&
name|temporary_obstack
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|obstack_object_size
argument_list|(
operator|&
name|temporary_obstack
argument_list|)
operator|>
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|word
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|temporary_obstack
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
name|word
operator|=
name|XOBFINISH
argument_list|(
operator|&
name|temporary_obstack
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|word
operator|==
literal|'.'
condition|)
operator|++
name|word
operator|,
name|putc
argument_list|(
literal|'.'
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|p
operator|=
name|word
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
name|USER_LABEL_PREFIX
argument_list|,
name|strlen
argument_list|(
name|USER_LABEL_PREFIX
argument_list|)
argument_list|)
condition|)
name|p
operator|+=
name|strlen
argument_list|(
name|USER_LABEL_PREFIX
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_LD_DEMANGLE
name|result
operator|=
literal|0
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|no_demangle
condition|)
name|result
operator|=
literal|0
expr_stmt|;
else|else
name|result
operator|=
name|cplus_demangle
argument_list|(
name|p
argument_list|,
name|DMGL_PARAMS
operator||
name|DMGL_ANSI
operator||
name|DMGL_VERBOSE
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|result
condition|)
block|{
name|int
name|diff
decl_stmt|;
name|fputs
argument_list|(
name|result
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|diff
operator|=
name|strlen
argument_list|(
name|word
argument_list|)
operator|-
name|strlen
argument_list|(
name|result
argument_list|)
expr_stmt|;
while|while
condition|(
name|diff
operator|>
literal|0
operator|&&
name|c
operator|==
literal|' '
condition|)
operator|--
name|diff
operator|,
name|putc
argument_list|(
literal|' '
argument_list|,
name|to
argument_list|)
expr_stmt|;
while|while
condition|(
name|diff
operator|<
literal|0
operator|&&
name|c
operator|==
literal|' '
condition|)
operator|++
name|diff
operator|,
name|c
operator|=
name|getc
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
else|else
name|fputs
argument_list|(
name|word
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|to
argument_list|)
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|temporary_obstack
argument_list|,
name|temporary_firstobj
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
name|putc
argument_list|(
name|c
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Decide whether the given symbol is: a constructor (1), a destructor    (2), a routine in a shared object that calls all the constructors    (3) or destructors (4), a DWARF exception-handling table (5), or    nothing special (0).  */
end_comment

begin_function
specifier|static
name|int
name|is_ctor_dtor
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
struct|struct
name|names
block|{
specifier|const
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
specifier|const
name|int
name|len
decl_stmt|;
specifier|const
name|int
name|ret
decl_stmt|;
specifier|const
name|int
name|two_underscores
decl_stmt|;
block|}
struct|;
specifier|const
name|struct
name|names
modifier|*
name|p
decl_stmt|;
name|int
name|ch
decl_stmt|;
specifier|const
name|char
modifier|*
name|orig_s
init|=
name|s
decl_stmt|;
specifier|static
specifier|const
name|struct
name|names
name|special
index|[]
init|=
block|{
ifndef|#
directive|ifndef
name|NO_DOLLAR_IN_LABEL
block|{
literal|"GLOBAL__I$"
block|,
sizeof|sizeof
argument_list|(
literal|"GLOBAL__I$"
argument_list|)
operator|-
literal|1
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"GLOBAL__D$"
block|,
sizeof|sizeof
argument_list|(
literal|"GLOBAL__D$"
argument_list|)
operator|-
literal|1
block|,
literal|2
block|,
literal|0
block|}
block|,
else|#
directive|else
ifndef|#
directive|ifndef
name|NO_DOT_IN_LABEL
block|{
literal|"GLOBAL__I."
block|,
sizeof|sizeof
argument_list|(
literal|"GLOBAL__I."
argument_list|)
operator|-
literal|1
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"GLOBAL__D."
block|,
sizeof|sizeof
argument_list|(
literal|"GLOBAL__D."
argument_list|)
operator|-
literal|1
block|,
literal|2
block|,
literal|0
block|}
block|,
endif|#
directive|endif
comment|/* NO_DOT_IN_LABEL */
endif|#
directive|endif
comment|/* NO_DOLLAR_IN_LABEL */
block|{
literal|"GLOBAL__I_"
block|,
sizeof|sizeof
argument_list|(
literal|"GLOBAL__I_"
argument_list|)
operator|-
literal|1
block|,
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|"GLOBAL__D_"
block|,
sizeof|sizeof
argument_list|(
literal|"GLOBAL__D_"
argument_list|)
operator|-
literal|1
block|,
literal|2
block|,
literal|0
block|}
block|,
block|{
literal|"GLOBAL__F_"
block|,
sizeof|sizeof
argument_list|(
literal|"GLOBAL__F_"
argument_list|)
operator|-
literal|1
block|,
literal|5
block|,
literal|0
block|}
block|,
block|{
literal|"GLOBAL__FI_"
block|,
sizeof|sizeof
argument_list|(
literal|"GLOBAL__FI_"
argument_list|)
operator|-
literal|1
block|,
literal|3
block|,
literal|0
block|}
block|,
block|{
literal|"GLOBAL__FD_"
block|,
sizeof|sizeof
argument_list|(
literal|"GLOBAL__FD_"
argument_list|)
operator|-
literal|1
block|,
literal|4
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
operator|*
name|s
operator|)
operator|==
literal|'_'
condition|)
operator|++
name|s
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|orig_s
condition|)
return|return
literal|0
return|;
for|for
control|(
name|p
operator|=
operator|&
name|special
index|[
literal|0
index|]
init|;
name|p
operator|->
name|len
operator|>
literal|0
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|ch
operator|==
name|p
operator|->
name|name
index|[
literal|0
index|]
operator|&&
operator|(
operator|!
name|p
operator|->
name|two_underscores
operator|||
operator|(
operator|(
name|s
operator|-
name|orig_s
operator|)
operator|>=
literal|2
operator|)
operator|)
operator|&&
name|strncmp
argument_list|(
name|s
argument_list|,
name|p
operator|->
name|name
argument_list|,
name|p
operator|->
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|p
operator|->
name|ret
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* We maintain two prefix lists: one from COMPILER_PATH environment variable    and one from the PATH variable.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|path_prefix
name|cpath
decl_stmt|,
name|path
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|CROSS_COMPILE
end_ifdef

begin_comment
comment|/* This is the name of the target machine.  We use it to form the name    of the files to execute.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|target_machine
init|=
name|TARGET_MACHINE
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Search for NAME using prefix list PPREFIX.  We only look for executable    files.     Return 0 if not found, otherwise return its name, allocated with malloc.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|find_a_file
parameter_list|(
name|struct
name|path_prefix
modifier|*
name|pprefix
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|char
modifier|*
name|temp
decl_stmt|;
name|struct
name|prefix_list
modifier|*
name|pl
decl_stmt|;
name|int
name|len
init|=
name|pprefix
operator|->
name|max_len
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Looking for '%s'\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HOST_EXECUTABLE_SUFFIX
name|len
operator|+=
name|strlen
argument_list|(
name|HOST_EXECUTABLE_SUFFIX
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|temp
operator|=
name|XNEWVEC
argument_list|(
name|char
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Determine the filename to execute (special case for absolute paths).  */
if|if
condition|(
operator|*
name|name
operator|==
literal|'/'
ifdef|#
directive|ifdef
name|HAVE_DOS_BASED_FILE_SYSTEM
operator|||
operator|(
operator|*
name|name
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|':'
operator|)
endif|#
directive|endif
condition|)
block|{
if|if
condition|(
name|access
argument_list|(
name|name
argument_list|,
name|X_OK
argument_list|)
operator|==
literal|0
condition|)
block|{
name|strcpy
argument_list|(
name|temp
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  - found: absolute path\n"
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
ifdef|#
directive|ifdef
name|HOST_EXECUTABLE_SUFFIX
comment|/* Some systems have a suffix for executable files. 	   So try appending that.  */
name|strcpy
argument_list|(
name|temp
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp
argument_list|,
name|HOST_EXECUTABLE_SUFFIX
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|temp
argument_list|,
name|X_OK
argument_list|)
operator|==
literal|0
condition|)
return|return
name|temp
return|;
endif|#
directive|endif
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  - failed to locate using absolute path\n"
argument_list|)
expr_stmt|;
block|}
else|else
for|for
control|(
name|pl
operator|=
name|pprefix
operator|->
name|plist
init|;
name|pl
condition|;
name|pl
operator|=
name|pl
operator|->
name|next
control|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
name|strcpy
argument_list|(
name|temp
argument_list|,
name|pl
operator|->
name|prefix
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|temp
argument_list|,
operator|&
name|st
argument_list|)
operator|>=
literal|0
operator|&&
operator|!
name|S_ISDIR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
operator|&&
name|access
argument_list|(
name|temp
argument_list|,
name|X_OK
argument_list|)
operator|==
literal|0
condition|)
return|return
name|temp
return|;
ifdef|#
directive|ifdef
name|HOST_EXECUTABLE_SUFFIX
comment|/* Some systems have a suffix for executable files. 	   So try appending that.  */
name|strcat
argument_list|(
name|temp
argument_list|,
name|HOST_EXECUTABLE_SUFFIX
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|temp
argument_list|,
operator|&
name|st
argument_list|)
operator|>=
literal|0
operator|&&
operator|!
name|S_ISDIR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
operator|&&
name|access
argument_list|(
name|temp
argument_list|,
name|X_OK
argument_list|)
operator|==
literal|0
condition|)
return|return
name|temp
return|;
endif|#
directive|endif
block|}
if|if
condition|(
name|debug
operator|&&
name|pprefix
operator|->
name|plist
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  - failed: no entries in prefix list\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Add an entry for PREFIX to prefix list PPREFIX.  */
end_comment

begin_function
specifier|static
name|void
name|add_prefix
parameter_list|(
name|struct
name|path_prefix
modifier|*
name|pprefix
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|struct
name|prefix_list
modifier|*
name|pl
decl_stmt|,
modifier|*
modifier|*
name|prev
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|pprefix
operator|->
name|plist
condition|)
block|{
for|for
control|(
name|pl
operator|=
name|pprefix
operator|->
name|plist
init|;
name|pl
operator|->
name|next
condition|;
name|pl
operator|=
name|pl
operator|->
name|next
control|)
empty_stmt|;
name|prev
operator|=
operator|&
name|pl
operator|->
name|next
expr_stmt|;
block|}
else|else
name|prev
operator|=
operator|&
name|pprefix
operator|->
name|plist
expr_stmt|;
comment|/* Keep track of the longest prefix.  */
name|len
operator|=
name|strlen
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|pprefix
operator|->
name|max_len
condition|)
name|pprefix
operator|->
name|max_len
operator|=
name|len
expr_stmt|;
name|pl
operator|=
name|XNEW
argument_list|(
expr|struct
name|prefix_list
argument_list|)
expr_stmt|;
name|pl
operator|->
name|prefix
operator|=
name|xstrdup
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|prev
condition|)
name|pl
operator|->
name|next
operator|=
operator|*
name|prev
expr_stmt|;
else|else
name|pl
operator|->
name|next
operator|=
operator|(
expr|struct
name|prefix_list
operator|*
operator|)
literal|0
expr_stmt|;
operator|*
name|prev
operator|=
name|pl
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Take the value of the environment variable ENV, break it into a path, and    add of the entries to PPREFIX.  */
end_comment

begin_function
specifier|static
name|void
name|prefix_from_env
parameter_list|(
specifier|const
name|char
modifier|*
name|env
parameter_list|,
name|struct
name|path_prefix
modifier|*
name|pprefix
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|GET_ENVIRONMENT
argument_list|(
name|p
argument_list|,
name|env
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|prefix_from_string
argument_list|(
name|p
argument_list|,
name|pprefix
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|prefix_from_string
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|,
name|struct
name|path_prefix
modifier|*
name|pprefix
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|startp
decl_stmt|,
modifier|*
name|endp
decl_stmt|;
name|char
modifier|*
name|nstore
init|=
name|XNEWVEC
argument_list|(
name|char
argument_list|,
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
literal|3
argument_list|)
decl_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Convert string '%s' into prefixes, separator = '%c'\n"
argument_list|,
name|p
argument_list|,
name|PATH_SEPARATOR
argument_list|)
expr_stmt|;
name|startp
operator|=
name|endp
operator|=
name|p
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|*
name|endp
operator|==
name|PATH_SEPARATOR
operator|||
operator|*
name|endp
operator|==
literal|0
condition|)
block|{
name|strncpy
argument_list|(
name|nstore
argument_list|,
name|startp
argument_list|,
name|endp
operator|-
name|startp
argument_list|)
expr_stmt|;
if|if
condition|(
name|endp
operator|==
name|startp
condition|)
block|{
name|strcpy
argument_list|(
name|nstore
argument_list|,
literal|"./"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|IS_DIR_SEPARATOR
argument_list|(
name|endp
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
block|{
name|nstore
index|[
name|endp
operator|-
name|startp
index|]
operator|=
name|DIR_SEPARATOR
expr_stmt|;
name|nstore
index|[
name|endp
operator|-
name|startp
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|nstore
index|[
name|endp
operator|-
name|startp
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  - add prefix: %s\n"
argument_list|,
name|nstore
argument_list|)
expr_stmt|;
name|add_prefix
argument_list|(
name|pprefix
argument_list|,
name|nstore
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|endp
operator|==
literal|0
condition|)
break|break;
name|endp
operator|=
name|startp
operator|=
name|endp
operator|+
literal|1
expr_stmt|;
block|}
else|else
name|endp
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Main program.  */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|ld_suffix
init|=
literal|"ld"
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|real_ld_suffix
init|=
literal|"real-ld"
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|collect_ld_suffix
init|=
literal|"collect-ld"
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|nm_suffix
init|=
literal|"nm"
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|gnm_suffix
init|=
literal|"gnm"
decl_stmt|;
ifdef|#
directive|ifdef
name|LDD_SUFFIX
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|ldd_suffix
init|=
name|LDD_SUFFIX
decl_stmt|;
endif|#
directive|endif
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|strip_suffix
init|=
literal|"strip"
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|gstrip_suffix
init|=
literal|"gstrip"
decl_stmt|;
ifdef|#
directive|ifdef
name|CROSS_COMPILE
comment|/* If we look for a program in the compiler directories, we just use      the short name, since these directories are already system-specific.      But it we look for a program in the system directories, we need to      qualify the program name with the target machine.  */
specifier|const
name|char
modifier|*
specifier|const
name|full_ld_suffix
init|=
name|concat
argument_list|(
name|target_machine
argument_list|,
literal|"-"
argument_list|,
name|ld_suffix
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|full_nm_suffix
init|=
name|concat
argument_list|(
name|target_machine
argument_list|,
literal|"-"
argument_list|,
name|nm_suffix
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|full_gnm_suffix
init|=
name|concat
argument_list|(
name|target_machine
argument_list|,
literal|"-"
argument_list|,
name|gnm_suffix
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|LDD_SUFFIX
specifier|const
name|char
modifier|*
specifier|const
name|full_ldd_suffix
init|=
name|concat
argument_list|(
name|target_machine
argument_list|,
literal|"-"
argument_list|,
name|ldd_suffix
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
endif|#
directive|endif
specifier|const
name|char
modifier|*
specifier|const
name|full_strip_suffix
init|=
name|concat
argument_list|(
name|target_machine
argument_list|,
literal|"-"
argument_list|,
name|strip_suffix
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|full_gstrip_suffix
init|=
name|concat
argument_list|(
name|target_machine
argument_list|,
literal|"-"
argument_list|,
name|gstrip_suffix
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
else|#
directive|else
specifier|const
name|char
modifier|*
specifier|const
name|full_ld_suffix
init|=
name|ld_suffix
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|full_nm_suffix
init|=
name|nm_suffix
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|full_gnm_suffix
init|=
name|gnm_suffix
decl_stmt|;
ifdef|#
directive|ifdef
name|LDD_SUFFIX
specifier|const
name|char
modifier|*
specifier|const
name|full_ldd_suffix
init|=
name|ldd_suffix
decl_stmt|;
endif|#
directive|endif
specifier|const
name|char
modifier|*
specifier|const
name|full_strip_suffix
init|=
name|strip_suffix
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|full_gstrip_suffix
init|=
name|gstrip_suffix
decl_stmt|;
endif|#
directive|endif
comment|/* CROSS_COMPILE */
specifier|const
name|char
modifier|*
name|arg
decl_stmt|;
name|FILE
modifier|*
name|outf
decl_stmt|;
ifdef|#
directive|ifdef
name|COLLECT_EXPORT_LIST
name|FILE
modifier|*
name|exportf
decl_stmt|;
endif|#
directive|endif
specifier|const
name|char
modifier|*
name|ld_file_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
modifier|*
name|c_argv
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|c_ptr
decl_stmt|;
name|char
modifier|*
modifier|*
name|ld1_argv
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|ld1
decl_stmt|;
name|char
modifier|*
modifier|*
name|ld2_argv
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|ld2
decl_stmt|;
name|char
modifier|*
modifier|*
name|object_lst
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|object
decl_stmt|;
name|int
name|first_file
decl_stmt|;
name|int
name|num_c_args
init|=
name|argc
operator|+
literal|9
decl_stmt|;
name|no_demangle
operator|=
operator|!
operator|!
name|getenv
argument_list|(
literal|"COLLECT_NO_DEMANGLE"
argument_list|)
expr_stmt|;
comment|/* Suppress demangling by the real linker, which may be broken.  */
name|putenv
argument_list|(
name|xstrdup
argument_list|(
literal|"COLLECT_NO_DEMANGLE="
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|COLLECT2_HOST_INITIALIZATION
argument_list|)
comment|/* Perform system dependent initialization, if necessary.  */
name|COLLECT2_HOST_INITIALIZATION
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGCHLD
comment|/* We *MUST* set SIGCHLD to SIG_DFL so that the wait4() call will      receive the signal.  A different setting is inheritable */
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Unlock the stdio streams.  */
name|unlock_std_streams
argument_list|()
expr_stmt|;
name|gcc_init_libintl
argument_list|()
expr_stmt|;
comment|/* Do not invoke xcalloc before this point, since locale needs to be      set first, in case a diagnostic is issued.  */
name|ld1
operator|=
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
operator|(
name|ld1_argv
operator|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|,
name|argc
operator|+
literal|4
argument_list|)
operator|)
expr_stmt|;
name|ld2
operator|=
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
operator|(
name|ld2_argv
operator|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|,
name|argc
operator|+
literal|11
argument_list|)
operator|)
expr_stmt|;
name|object
operator|=
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
operator|(
name|object_lst
operator|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|,
name|argc
argument_list|)
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|debug
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* Parse command line early for instances of -debug.  This allows      the debug flag to be set before functions like find_a_file()      are called.  */
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|argv
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-debug"
argument_list|)
condition|)
name|debug
operator|=
literal|1
expr_stmt|;
block|}
name|vflag
operator|=
name|debug
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|DEFAULT_A_OUT_NAME
name|output_file
operator|=
literal|"a.out"
expr_stmt|;
else|#
directive|else
name|output_file
operator|=
name|DEFAULT_A_OUT_NAME
expr_stmt|;
endif|#
directive|endif
name|obstack_begin
argument_list|(
operator|&
name|temporary_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|temporary_firstobj
operator|=
name|obstack_alloc
argument_list|(
operator|&
name|temporary_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|HAVE_LD_DEMANGLE
name|current_demangling_style
operator|=
name|auto_demangling
expr_stmt|;
endif|#
directive|endif
name|p
operator|=
name|getenv
argument_list|(
literal|"COLLECT_GCC_OPTIONS"
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|&&
operator|*
name|p
condition|)
block|{
specifier|const
name|char
modifier|*
name|q
init|=
name|extract_string
argument_list|(
operator|&
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|q
operator|==
literal|'-'
operator|&&
operator|(
name|q
index|[
literal|1
index|]
operator|==
literal|'m'
operator|||
name|q
index|[
literal|1
index|]
operator|==
literal|'f'
operator|)
condition|)
name|num_c_args
operator|++
expr_stmt|;
block|}
name|obstack_free
argument_list|(
operator|&
name|temporary_obstack
argument_list|,
name|temporary_firstobj
argument_list|)
expr_stmt|;
comment|/* -fno-profile-arcs -fno-test-coverage -fno-branch-probabilities      -fno-exceptions -w */
name|num_c_args
operator|+=
literal|5
expr_stmt|;
name|c_ptr
operator|=
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
operator|(
name|c_argv
operator|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|,
name|num_c_args
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
name|fatal
argument_list|(
literal|"no arguments"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGQUIT
if|if
condition|(
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|handler
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|handler
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGALRM
if|if
condition|(
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|handler
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGHUP
if|if
condition|(
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|handler
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|signal
argument_list|(
name|SIGSEGV
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGSEGV
argument_list|,
name|handler
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGBUS
if|if
condition|(
name|signal
argument_list|(
name|SIGBUS
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGBUS
argument_list|,
name|handler
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Extract COMPILER_PATH and PATH into our prefix list.  */
name|prefix_from_env
argument_list|(
literal|"COMPILER_PATH"
argument_list|,
operator|&
name|cpath
argument_list|)
expr_stmt|;
name|prefix_from_env
argument_list|(
literal|"PATH"
argument_list|,
operator|&
name|path
argument_list|)
expr_stmt|;
comment|/* Try to discover a valid linker/nm/strip to use.  */
comment|/* Maybe we know the right file to use (if not cross).  */
name|ld_file_name
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEFAULT_LINKER
if|if
condition|(
name|access
argument_list|(
name|DEFAULT_LINKER
argument_list|,
name|X_OK
argument_list|)
operator|==
literal|0
condition|)
name|ld_file_name
operator|=
name|DEFAULT_LINKER
expr_stmt|;
if|if
condition|(
name|ld_file_name
operator|==
literal|0
condition|)
endif|#
directive|endif
ifdef|#
directive|ifdef
name|REAL_LD_FILE_NAME
name|ld_file_name
operator|=
name|find_a_file
argument_list|(
operator|&
name|path
argument_list|,
name|REAL_LD_FILE_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|ld_file_name
operator|==
literal|0
condition|)
endif|#
directive|endif
comment|/* Search the (target-specific) compiler dirs for ld'.  */
name|ld_file_name
operator|=
name|find_a_file
argument_list|(
operator|&
name|cpath
argument_list|,
name|real_ld_suffix
argument_list|)
expr_stmt|;
comment|/* Likewise for `collect-ld'.  */
if|if
condition|(
name|ld_file_name
operator|==
literal|0
condition|)
name|ld_file_name
operator|=
name|find_a_file
argument_list|(
operator|&
name|cpath
argument_list|,
name|collect_ld_suffix
argument_list|)
expr_stmt|;
comment|/* Search the compiler directories for `ld'.  We have protection against      recursive calls in find_a_file.  */
if|if
condition|(
name|ld_file_name
operator|==
literal|0
condition|)
name|ld_file_name
operator|=
name|find_a_file
argument_list|(
operator|&
name|cpath
argument_list|,
name|ld_suffix
argument_list|)
expr_stmt|;
comment|/* Search the ordinary system bin directories      for `ld' (if native linking) or `TARGET-ld' (if cross).  */
if|if
condition|(
name|ld_file_name
operator|==
literal|0
condition|)
name|ld_file_name
operator|=
name|find_a_file
argument_list|(
operator|&
name|path
argument_list|,
name|full_ld_suffix
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|REAL_NM_FILE_NAME
name|nm_file_name
operator|=
name|find_a_file
argument_list|(
operator|&
name|path
argument_list|,
name|REAL_NM_FILE_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|nm_file_name
operator|==
literal|0
condition|)
endif|#
directive|endif
name|nm_file_name
operator|=
name|find_a_file
argument_list|(
operator|&
name|cpath
argument_list|,
name|gnm_suffix
argument_list|)
expr_stmt|;
if|if
condition|(
name|nm_file_name
operator|==
literal|0
condition|)
name|nm_file_name
operator|=
name|find_a_file
argument_list|(
operator|&
name|path
argument_list|,
name|full_gnm_suffix
argument_list|)
expr_stmt|;
if|if
condition|(
name|nm_file_name
operator|==
literal|0
condition|)
name|nm_file_name
operator|=
name|find_a_file
argument_list|(
operator|&
name|cpath
argument_list|,
name|nm_suffix
argument_list|)
expr_stmt|;
if|if
condition|(
name|nm_file_name
operator|==
literal|0
condition|)
name|nm_file_name
operator|=
name|find_a_file
argument_list|(
operator|&
name|path
argument_list|,
name|full_nm_suffix
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LDD_SUFFIX
name|ldd_file_name
operator|=
name|find_a_file
argument_list|(
operator|&
name|cpath
argument_list|,
name|ldd_suffix
argument_list|)
expr_stmt|;
if|if
condition|(
name|ldd_file_name
operator|==
literal|0
condition|)
name|ldd_file_name
operator|=
name|find_a_file
argument_list|(
operator|&
name|path
argument_list|,
name|full_ldd_suffix
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|REAL_STRIP_FILE_NAME
name|strip_file_name
operator|=
name|find_a_file
argument_list|(
operator|&
name|path
argument_list|,
name|REAL_STRIP_FILE_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|strip_file_name
operator|==
literal|0
condition|)
endif|#
directive|endif
name|strip_file_name
operator|=
name|find_a_file
argument_list|(
operator|&
name|cpath
argument_list|,
name|gstrip_suffix
argument_list|)
expr_stmt|;
if|if
condition|(
name|strip_file_name
operator|==
literal|0
condition|)
name|strip_file_name
operator|=
name|find_a_file
argument_list|(
operator|&
name|path
argument_list|,
name|full_gstrip_suffix
argument_list|)
expr_stmt|;
if|if
condition|(
name|strip_file_name
operator|==
literal|0
condition|)
name|strip_file_name
operator|=
name|find_a_file
argument_list|(
operator|&
name|cpath
argument_list|,
name|strip_suffix
argument_list|)
expr_stmt|;
if|if
condition|(
name|strip_file_name
operator|==
literal|0
condition|)
name|strip_file_name
operator|=
name|find_a_file
argument_list|(
operator|&
name|path
argument_list|,
name|full_strip_suffix
argument_list|)
expr_stmt|;
comment|/* Determine the full path name of the C compiler to use.  */
name|c_file_name
operator|=
name|getenv
argument_list|(
literal|"COLLECT_GCC"
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_file_name
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|CROSS_COMPILE
name|c_file_name
operator|=
name|concat
argument_list|(
name|target_machine
argument_list|,
literal|"-gcc"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
name|c_file_name
operator|=
literal|"gcc"
expr_stmt|;
endif|#
directive|endif
block|}
name|p
operator|=
name|find_a_file
argument_list|(
operator|&
name|cpath
argument_list|,
name|c_file_name
argument_list|)
expr_stmt|;
comment|/* Here it should be safe to use the system search path since we should have      already qualified the name of the compiler when it is needed.  */
if|if
condition|(
name|p
operator|==
literal|0
condition|)
name|p
operator|=
name|find_a_file
argument_list|(
operator|&
name|path
argument_list|,
name|c_file_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|c_file_name
operator|=
name|p
expr_stmt|;
operator|*
name|ld1
operator|++
operator|=
operator|*
name|ld2
operator|++
operator|=
name|ld_file_name
expr_stmt|;
comment|/* Make temp file names.  */
name|c_file
operator|=
name|make_temp_file
argument_list|(
literal|".c"
argument_list|)
expr_stmt|;
name|o_file
operator|=
name|make_temp_file
argument_list|(
literal|".o"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COLLECT_EXPORT_LIST
name|export_file
operator|=
name|make_temp_file
argument_list|(
literal|".x"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ldout
operator|=
name|make_temp_file
argument_list|(
literal|".ld"
argument_list|)
expr_stmt|;
name|lderrout
operator|=
name|make_temp_file
argument_list|(
literal|".le"
argument_list|)
expr_stmt|;
operator|*
name|c_ptr
operator|++
operator|=
name|c_file_name
expr_stmt|;
operator|*
name|c_ptr
operator|++
operator|=
literal|"-x"
expr_stmt|;
operator|*
name|c_ptr
operator|++
operator|=
literal|"c"
expr_stmt|;
operator|*
name|c_ptr
operator|++
operator|=
literal|"-c"
expr_stmt|;
operator|*
name|c_ptr
operator|++
operator|=
literal|"-o"
expr_stmt|;
operator|*
name|c_ptr
operator|++
operator|=
name|o_file
expr_stmt|;
ifdef|#
directive|ifdef
name|COLLECT_EXPORT_LIST
comment|/* Generate a list of directories from LIBPATH.  */
name|prefix_from_env
argument_list|(
literal|"LIBPATH"
argument_list|,
operator|&
name|libpath_lib_dirs
argument_list|)
expr_stmt|;
comment|/* Add to this list also two standard directories where      AIX loader always searches for libraries.  */
name|add_prefix
argument_list|(
operator|&
name|libpath_lib_dirs
argument_list|,
literal|"/lib"
argument_list|)
expr_stmt|;
name|add_prefix
argument_list|(
operator|&
name|libpath_lib_dirs
argument_list|,
literal|"/usr/lib"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Get any options that the upper GCC wants to pass to the sub-GCC.       AIX support needs to know if -shared has been specified before      parsing commandline arguments.  */
name|p
operator|=
name|getenv
argument_list|(
literal|"COLLECT_GCC_OPTIONS"
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|&&
operator|*
name|p
condition|)
block|{
specifier|const
name|char
modifier|*
name|q
init|=
name|extract_string
argument_list|(
operator|&
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|q
operator|==
literal|'-'
operator|&&
operator|(
name|q
index|[
literal|1
index|]
operator|==
literal|'m'
operator|||
name|q
index|[
literal|1
index|]
operator|==
literal|'f'
operator|)
condition|)
operator|*
name|c_ptr
operator|++
operator|=
name|xstrdup
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|q
argument_list|,
literal|"-EL"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|q
argument_list|,
literal|"-EB"
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|c_ptr
operator|++
operator|=
name|xstrdup
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|q
argument_list|,
literal|"-shared"
argument_list|)
operator|==
literal|0
condition|)
name|shared_obj
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|q
operator|==
literal|'-'
operator|&&
name|q
index|[
literal|1
index|]
operator|==
literal|'B'
condition|)
block|{
operator|*
name|c_ptr
operator|++
operator|=
name|xstrdup
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
index|[
literal|2
index|]
operator|==
literal|0
condition|)
block|{
name|q
operator|=
name|extract_string
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
operator|*
name|c_ptr
operator|++
operator|=
name|xstrdup
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|obstack_free
argument_list|(
operator|&
name|temporary_obstack
argument_list|,
name|temporary_firstobj
argument_list|)
expr_stmt|;
operator|*
name|c_ptr
operator|++
operator|=
literal|"-fno-profile-arcs"
expr_stmt|;
operator|*
name|c_ptr
operator|++
operator|=
literal|"-fno-test-coverage"
expr_stmt|;
operator|*
name|c_ptr
operator|++
operator|=
literal|"-fno-branch-probabilities"
expr_stmt|;
operator|*
name|c_ptr
operator|++
operator|=
literal|"-fno-exceptions"
expr_stmt|;
operator|*
name|c_ptr
operator|++
operator|=
literal|"-w"
expr_stmt|;
comment|/* !!! When GCC calls collect2,      it does not know whether it is calling collect2 or ld.      So collect2 cannot meaningfully understand any options      except those ld understands.      If you propose to make GCC pass some other option,      just imagine what will happen if ld is really ld!!!  */
comment|/* Parse arguments.  Remember output file spec, pass the rest to ld.  */
comment|/* After the first file, put in the c++ rt0.  */
name|first_file
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_LD_DEMANGLE
if|if
condition|(
operator|!
name|demangle_flag
operator|&&
operator|!
name|no_demangle
condition|)
name|demangle_flag
operator|=
literal|"--demangle"
expr_stmt|;
if|if
condition|(
name|demangle_flag
condition|)
operator|*
name|ld1
operator|++
operator|=
operator|*
name|ld2
operator|++
operator|=
name|demangle_flag
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
operator|(
name|arg
operator|=
operator|*
operator|++
name|argv
operator|)
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
block|{
operator|*
name|ld1
operator|++
operator|=
operator|*
name|ld2
operator|++
operator|=
name|arg
expr_stmt|;
if|if
condition|(
name|arg
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
switch|switch
condition|(
name|arg
index|[
literal|1
index|]
condition|)
block|{
ifdef|#
directive|ifdef
name|COLLECT_EXPORT_LIST
comment|/* We want to disable automatic exports on AIX when user 	       explicitly puts an export list in command line */
case|case
literal|'b'
case|:
if|if
condition|(
name|arg
index|[
literal|2
index|]
operator|==
literal|'E'
operator|||
name|strncmp
argument_list|(
operator|&
name|arg
index|[
literal|2
index|]
argument_list|,
literal|"export"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
name|export_flag
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|arg
index|[
literal|2
index|]
operator|==
literal|'6'
operator|&&
name|arg
index|[
literal|3
index|]
operator|==
literal|'4'
condition|)
name|aix64_flag
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|arg
index|[
literal|2
index|]
operator|==
literal|'r'
operator|&&
name|arg
index|[
literal|3
index|]
operator|==
literal|'t'
operator|&&
name|arg
index|[
literal|4
index|]
operator|==
literal|'l'
condition|)
name|aixrtl_flag
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'d'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"-debug"
argument_list|)
condition|)
block|{
comment|/* Already parsed.  */
name|ld1
operator|--
expr_stmt|;
name|ld2
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"-dynamic-linker"
argument_list|)
operator|&&
name|argv
index|[
literal|1
index|]
condition|)
block|{
operator|++
name|argv
expr_stmt|;
operator|*
name|ld1
operator|++
operator|=
operator|*
name|ld2
operator|++
operator|=
operator|*
name|argv
expr_stmt|;
block|}
break|break;
case|case
literal|'l'
case|:
if|if
condition|(
name|first_file
condition|)
block|{
comment|/* place o_file BEFORE this argument! */
name|first_file
operator|=
literal|0
expr_stmt|;
name|ld2
operator|--
expr_stmt|;
operator|*
name|ld2
operator|++
operator|=
name|o_file
expr_stmt|;
operator|*
name|ld2
operator|++
operator|=
name|arg
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|COLLECT_EXPORT_LIST
block|{
comment|/* Resolving full library name.  */
specifier|const
name|char
modifier|*
name|s
init|=
name|resolve_lib_name
argument_list|(
name|arg
operator|+
literal|2
argument_list|)
decl_stmt|;
comment|/* Saving a full library name.  */
name|add_to_list
argument_list|(
operator|&
name|libs
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
ifdef|#
directive|ifdef
name|COLLECT_EXPORT_LIST
comment|/* Saving directories where to search for libraries.  */
case|case
literal|'L'
case|:
name|add_prefix
argument_list|(
operator|&
name|cmdline_lib_dirs
argument_list|,
name|arg
operator|+
literal|2
argument_list|)
expr_stmt|;
break|break;
else|#
directive|else
if|#
directive|if
name|LINK_ELIMINATE_DUPLICATE_LDIRECTORIES
case|case
literal|'L'
case|:
if|if
condition|(
name|is_in_args
argument_list|(
name|arg
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|ld1_argv
argument_list|,
name|ld1
operator|-
literal|1
argument_list|)
condition|)
operator|--
name|ld1
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* LINK_ELIMINATE_DUPLICATE_LDIRECTORIES */
endif|#
directive|endif
case|case
literal|'o'
case|:
if|if
condition|(
name|arg
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
name|output_file
operator|=
operator|*
name|ld1
operator|++
operator|=
operator|*
name|ld2
operator|++
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
elseif|else
if|if
condition|(
literal|1
ifdef|#
directive|ifdef
name|SWITCHES_NEED_SPACES
operator|&&
operator|!
name|strchr
argument_list|(
name|SWITCHES_NEED_SPACES
argument_list|,
name|arg
index|[
literal|1
index|]
argument_list|)
endif|#
directive|endif
condition|)
name|output_file
operator|=
operator|&
name|arg
index|[
literal|2
index|]
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
if|if
condition|(
name|arg
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
name|rflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|arg
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|&&
name|do_collecting
condition|)
block|{
comment|/* We must strip after the nm run, otherwise C++ linking 		     will not work.  Thus we strip in the second ld run, or 		     else with strip if there is no second ld run.  */
name|strip_flag
operator|=
literal|1
expr_stmt|;
name|ld1
operator|--
expr_stmt|;
block|}
break|break;
case|case
literal|'v'
case|:
if|if
condition|(
name|arg
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
name|vflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"--no-demangle"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|demangle_flag
operator|=
name|arg
expr_stmt|;
name|no_demangle
operator|=
literal|1
expr_stmt|;
name|ld1
operator|--
expr_stmt|;
name|ld2
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|arg
argument_list|,
literal|"--demangle"
argument_list|,
literal|10
argument_list|)
operator|==
literal|0
condition|)
block|{
name|demangle_flag
operator|=
name|arg
expr_stmt|;
name|no_demangle
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|HAVE_LD_DEMANGLE
if|if
condition|(
name|arg
index|[
literal|10
index|]
operator|==
literal|'='
condition|)
block|{
name|enum
name|demangling_styles
name|style
init|=
name|cplus_demangle_name_to_style
argument_list|(
name|arg
operator|+
literal|11
argument_list|)
decl_stmt|;
if|if
condition|(
name|style
operator|==
name|unknown_demangling
condition|)
name|error
argument_list|(
literal|"unknown demangling style '%s'"
argument_list|,
name|arg
operator|+
literal|11
argument_list|)
expr_stmt|;
else|else
name|current_demangling_style
operator|=
name|style
expr_stmt|;
block|}
endif|#
directive|endif
name|ld1
operator|--
expr_stmt|;
name|ld2
operator|--
expr_stmt|;
block|}
break|break;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|p
operator|=
name|strrchr
argument_list|(
name|arg
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
operator|&&
operator|(
name|strcmp
argument_list|(
name|p
argument_list|,
literal|".o"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|p
argument_list|,
literal|".a"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|p
argument_list|,
literal|".so"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|p
argument_list|,
literal|".lo"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|p
argument_list|,
literal|".obj"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|first_file
condition|)
block|{
name|first_file
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'o'
condition|)
operator|*
name|ld2
operator|++
operator|=
name|o_file
expr_stmt|;
else|else
block|{
comment|/* place o_file BEFORE this argument! */
name|ld2
operator|--
expr_stmt|;
operator|*
name|ld2
operator|++
operator|=
name|o_file
expr_stmt|;
operator|*
name|ld2
operator|++
operator|=
name|arg
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'o'
operator|||
name|p
index|[
literal|1
index|]
operator|==
literal|'l'
condition|)
operator|*
name|object
operator|++
operator|=
name|arg
expr_stmt|;
ifdef|#
directive|ifdef
name|COLLECT_EXPORT_LIST
comment|/* libraries can be specified directly, i.e. without -l flag.  */
else|else
block|{
comment|/* Saving a full library name.  */
name|add_to_list
argument_list|(
operator|&
name|libs
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
ifdef|#
directive|ifdef
name|COLLECT_EXPORT_LIST
comment|/* This is added only for debugging purposes.  */
if|if
condition|(
name|debug
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"List of libraries:\n"
argument_list|)
expr_stmt|;
name|dump_list
argument_list|(
name|stderr
argument_list|,
literal|"\t"
argument_list|,
name|libs
operator|.
name|first
argument_list|)
expr_stmt|;
block|}
comment|/* The AIX linker will discard static constructors in object files if      nothing else in the file is referenced, so look at them first.  */
block|{
specifier|const
name|char
modifier|*
modifier|*
name|export_object_lst
init|=
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|object_lst
decl_stmt|;
while|while
condition|(
name|export_object_lst
operator|<
name|object
condition|)
name|scan_prog_file
argument_list|(
operator|*
name|export_object_lst
operator|++
argument_list|,
name|PASS_OBJ
argument_list|)
expr_stmt|;
block|}
block|{
name|struct
name|id
modifier|*
name|list
init|=
name|libs
operator|.
name|first
decl_stmt|;
for|for
control|(
init|;
name|list
condition|;
name|list
operator|=
name|list
operator|->
name|next
control|)
name|scan_prog_file
argument_list|(
name|list
operator|->
name|name
argument_list|,
name|PASS_FIRST
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|exports
operator|.
name|first
condition|)
block|{
name|char
modifier|*
name|buf
init|=
name|concat
argument_list|(
literal|"-bE:"
argument_list|,
name|export_file
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
operator|*
name|ld1
operator|++
operator|=
name|buf
expr_stmt|;
operator|*
name|ld2
operator|++
operator|=
name|buf
expr_stmt|;
name|exportf
operator|=
name|fopen
argument_list|(
name|export_file
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|exportf
operator|==
operator|(
name|FILE
operator|*
operator|)
literal|0
condition|)
name|fatal_perror
argument_list|(
literal|"fopen %s"
argument_list|,
name|export_file
argument_list|)
expr_stmt|;
name|write_aix_file
argument_list|(
name|exportf
argument_list|,
name|exports
operator|.
name|first
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|exportf
argument_list|)
condition|)
name|fatal_perror
argument_list|(
literal|"fclose %s"
argument_list|,
name|export_file
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
operator|*
name|c_ptr
operator|++
operator|=
name|c_file
expr_stmt|;
operator|*
name|c_ptr
operator|=
operator|*
name|ld1
operator|=
operator|*
name|object
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
if|if
condition|(
name|vflag
condition|)
block|{
name|notice
argument_list|(
literal|"collect2 version %s"
argument_list|,
name|version_string
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TARGET_VERSION
name|TARGET_VERSION
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|debug
condition|)
block|{
specifier|const
name|char
modifier|*
name|ptr
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ld_file_name        = %s\n"
argument_list|,
operator|(
name|ld_file_name
condition|?
name|ld_file_name
else|:
literal|"not found"
operator|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"c_file_name         = %s\n"
argument_list|,
operator|(
name|c_file_name
condition|?
name|c_file_name
else|:
literal|"not found"
operator|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"nm_file_name        = %s\n"
argument_list|,
operator|(
name|nm_file_name
condition|?
name|nm_file_name
else|:
literal|"not found"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LDD_SUFFIX
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ldd_file_name       = %s\n"
argument_list|,
operator|(
name|ldd_file_name
condition|?
name|ldd_file_name
else|:
literal|"not found"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"strip_file_name     = %s\n"
argument_list|,
operator|(
name|strip_file_name
condition|?
name|strip_file_name
else|:
literal|"not found"
operator|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"c_file              = %s\n"
argument_list|,
operator|(
name|c_file
condition|?
name|c_file
else|:
literal|"not found"
operator|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"o_file              = %s\n"
argument_list|,
operator|(
name|o_file
condition|?
name|o_file
else|:
literal|"not found"
operator|)
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|getenv
argument_list|(
literal|"COLLECT_GCC_OPTIONS"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"COLLECT_GCC_OPTIONS = %s\n"
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|getenv
argument_list|(
literal|"COLLECT_GCC"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"COLLECT_GCC         = %s\n"
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|getenv
argument_list|(
literal|"COMPILER_PATH"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"COMPILER_PATH       = %s\n"
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|getenv
argument_list|(
name|LIBRARY_PATH_ENV
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%-20s= %s\n"
argument_list|,
name|LIBRARY_PATH_ENV
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Load the program, searching all libraries and attempting to provide      undefined symbols from repository information.  */
comment|/* On AIX we do this later.  */
ifndef|#
directive|ifndef
name|COLLECT_EXPORT_LIST
name|do_tlink
argument_list|(
name|ld1_argv
argument_list|,
name|object_lst
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If -r or they will be run via some other method, do not build the      constructor or destructor list, just return now.  */
if|if
condition|(
name|rflag
ifndef|#
directive|ifndef
name|COLLECT_EXPORT_LIST
operator|||
operator|!
name|do_collecting
endif|#
directive|endif
condition|)
block|{
ifdef|#
directive|ifdef
name|COLLECT_EXPORT_LIST
comment|/* Do the link we avoided above if we are exiting.  */
name|do_tlink
argument_list|(
name|ld1_argv
argument_list|,
name|object_lst
argument_list|)
expr_stmt|;
comment|/* But make sure we delete the export file we may have created.  */
if|if
condition|(
name|export_file
operator|!=
literal|0
operator|&&
name|export_file
index|[
literal|0
index|]
condition|)
name|maybe_unlink
argument_list|(
name|export_file
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|maybe_unlink
argument_list|(
name|c_file
argument_list|)
expr_stmt|;
name|maybe_unlink
argument_list|(
name|o_file
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Examine the namelist with nm and search it for static constructors      and destructors to call.      Write the constructor and destructor tables to a .s file and reload.  */
comment|/* On AIX we already scanned for global constructors/destructors.  */
ifndef|#
directive|ifndef
name|COLLECT_EXPORT_LIST
name|scan_prog_file
argument_list|(
name|output_file
argument_list|,
name|PASS_FIRST
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SCAN_LIBRARIES
name|scan_libraries
argument_list|(
name|output_file
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|debug
condition|)
block|{
name|notice
argument_list|(
literal|"%d constructor(s) found\n"
argument_list|,
name|constructors
operator|.
name|number
argument_list|)
expr_stmt|;
name|notice
argument_list|(
literal|"%d destructor(s)  found\n"
argument_list|,
name|destructors
operator|.
name|number
argument_list|)
expr_stmt|;
name|notice
argument_list|(
literal|"%d frame table(s) found\n"
argument_list|,
name|frame_tables
operator|.
name|number
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|constructors
operator|.
name|number
operator|==
literal|0
operator|&&
name|destructors
operator|.
name|number
operator|==
literal|0
operator|&&
name|frame_tables
operator|.
name|number
operator|==
literal|0
if|#
directive|if
name|defined
argument_list|(
name|SCAN_LIBRARIES
argument_list|)
operator|||
name|defined
argument_list|(
name|COLLECT_EXPORT_LIST
argument_list|)
comment|/* If we will be running these functions ourselves, we want to emit 	 stubs into the shared library so that we do not have to relink 	 dependent programs when we add static objects.  */
operator|&&
operator|!
name|shared_obj
endif|#
directive|endif
condition|)
block|{
ifdef|#
directive|ifdef
name|COLLECT_EXPORT_LIST
comment|/* Do tlink without additional code generation.  */
name|do_tlink
argument_list|(
name|ld1_argv
argument_list|,
name|object_lst
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Strip now if it was requested on the command line.  */
if|if
condition|(
name|strip_flag
condition|)
block|{
name|char
modifier|*
modifier|*
name|real_strip_argv
init|=
name|XCNEWVEC
argument_list|(
name|char
operator|*
argument_list|,
literal|3
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|strip_argv
init|=
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|real_strip_argv
decl_stmt|;
name|strip_argv
index|[
literal|0
index|]
operator|=
name|strip_file_name
expr_stmt|;
name|strip_argv
index|[
literal|1
index|]
operator|=
name|output_file
expr_stmt|;
name|strip_argv
index|[
literal|2
index|]
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
name|fork_execute
argument_list|(
literal|"strip"
argument_list|,
name|real_strip_argv
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|COLLECT_EXPORT_LIST
name|maybe_unlink
argument_list|(
name|export_file
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|maybe_unlink
argument_list|(
name|c_file
argument_list|)
expr_stmt|;
name|maybe_unlink
argument_list|(
name|o_file
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Sort ctor and dtor lists by priority.  */
name|sort_ids
argument_list|(
operator|&
name|constructors
argument_list|)
expr_stmt|;
name|sort_ids
argument_list|(
operator|&
name|destructors
argument_list|)
expr_stmt|;
name|maybe_unlink
argument_list|(
name|output_file
argument_list|)
expr_stmt|;
name|outf
operator|=
name|fopen
argument_list|(
name|c_file
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|outf
operator|==
operator|(
name|FILE
operator|*
operator|)
literal|0
condition|)
name|fatal_perror
argument_list|(
literal|"fopen %s"
argument_list|,
name|c_file
argument_list|)
expr_stmt|;
name|write_c_file
argument_list|(
name|outf
argument_list|,
name|c_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|outf
argument_list|)
condition|)
name|fatal_perror
argument_list|(
literal|"fclose %s"
argument_list|,
name|c_file
argument_list|)
expr_stmt|;
comment|/* Tell the linker that we have initializer and finalizer functions.  */
ifdef|#
directive|ifdef
name|LD_INIT_SWITCH
ifdef|#
directive|ifdef
name|COLLECT_EXPORT_LIST
operator|*
name|ld2
operator|++
operator|=
name|concat
argument_list|(
name|LD_INIT_SWITCH
argument_list|,
literal|":"
argument_list|,
name|initname
argument_list|,
literal|":"
argument_list|,
name|fininame
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
operator|*
name|ld2
operator|++
operator|=
name|LD_INIT_SWITCH
expr_stmt|;
operator|*
name|ld2
operator|++
operator|=
name|initname
expr_stmt|;
operator|*
name|ld2
operator|++
operator|=
name|LD_FINI_SWITCH
expr_stmt|;
operator|*
name|ld2
operator|++
operator|=
name|fininame
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|COLLECT_EXPORT_LIST
if|if
condition|(
name|shared_obj
condition|)
block|{
comment|/* If we did not add export flag to link arguments before, add it to 	 second link phase now.  No new exports should have been added.  */
if|if
condition|(
operator|!
name|exports
operator|.
name|first
condition|)
operator|*
name|ld2
operator|++
operator|=
name|concat
argument_list|(
literal|"-bE:"
argument_list|,
name|export_file
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|LD_INIT_SWITCH
name|add_to_list
argument_list|(
operator|&
name|exports
argument_list|,
name|initname
argument_list|)
expr_stmt|;
name|add_to_list
argument_list|(
operator|&
name|exports
argument_list|,
name|fininame
argument_list|)
expr_stmt|;
name|add_to_list
argument_list|(
operator|&
name|exports
argument_list|,
literal|"_GLOBAL__DI"
argument_list|)
expr_stmt|;
name|add_to_list
argument_list|(
operator|&
name|exports
argument_list|,
literal|"_GLOBAL__DD"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|exportf
operator|=
name|fopen
argument_list|(
name|export_file
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|exportf
operator|==
operator|(
name|FILE
operator|*
operator|)
literal|0
condition|)
name|fatal_perror
argument_list|(
literal|"fopen %s"
argument_list|,
name|export_file
argument_list|)
expr_stmt|;
name|write_aix_file
argument_list|(
name|exportf
argument_list|,
name|exports
operator|.
name|first
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|exportf
argument_list|)
condition|)
name|fatal_perror
argument_list|(
literal|"fclose %s"
argument_list|,
name|export_file
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* End of arguments to second link phase.  */
operator|*
name|ld2
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
if|if
condition|(
name|debug
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n========== output_file = %s, c_file = %s\n"
argument_list|,
name|output_file
argument_list|,
name|c_file
argument_list|)
expr_stmt|;
name|write_c_file
argument_list|(
name|stderr
argument_list|,
literal|"stderr"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"========== end of c_file\n\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COLLECT_EXPORT_LIST
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n========== export_file = %s\n"
argument_list|,
name|export_file
argument_list|)
expr_stmt|;
name|write_aix_file
argument_list|(
name|stderr
argument_list|,
name|exports
operator|.
name|first
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"========== end of export_file\n\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Assemble the constructor and destructor tables.      Link the tables in with the rest of the program.  */
name|fork_execute
argument_list|(
literal|"gcc"
argument_list|,
name|c_argv
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COLLECT_EXPORT_LIST
comment|/* On AIX we must call tlink because of possible templates resolution.  */
name|do_tlink
argument_list|(
name|ld2_argv
argument_list|,
name|object_lst
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Otherwise, simply call ld because tlink is already done.  */
name|fork_execute
argument_list|(
literal|"ld"
argument_list|,
name|ld2_argv
argument_list|)
expr_stmt|;
comment|/* Let scan_prog_file do any final mods (OSF/rose needs this for      constructors/destructors in shared libraries.  */
name|scan_prog_file
argument_list|(
name|output_file
argument_list|,
name|PASS_SECOND
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|maybe_unlink
argument_list|(
name|c_file
argument_list|)
expr_stmt|;
name|maybe_unlink
argument_list|(
name|o_file
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COLLECT_EXPORT_LIST
name|maybe_unlink
argument_list|(
name|export_file
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Wait for a process to finish, and exit if a nonzero status is found.  */
end_comment

begin_function
name|int
name|collect_wait
parameter_list|(
specifier|const
name|char
modifier|*
name|prog
parameter_list|,
name|struct
name|pex_obj
modifier|*
name|pex
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
if|if
condition|(
operator|!
name|pex_get_status
argument_list|(
name|pex
argument_list|,
literal|1
argument_list|,
operator|&
name|status
argument_list|)
condition|)
name|fatal_perror
argument_list|(
literal|"can't get program status"
argument_list|)
expr_stmt|;
name|pex_free
argument_list|(
name|pex
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|int
name|sig
init|=
name|WTERMSIG
argument_list|(
name|status
argument_list|)
decl_stmt|;
name|error
argument_list|(
literal|"%s terminated with signal %d [%s]%s"
argument_list|,
name|prog
argument_list|,
name|sig
argument_list|,
name|strsignal
argument_list|(
name|sig
argument_list|)
argument_list|,
name|WCOREDUMP
argument_list|(
name|status
argument_list|)
condition|?
literal|", core dumped"
else|:
literal|""
argument_list|)
expr_stmt|;
name|collect_exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|WIFEXITED
argument_list|(
name|status
argument_list|)
condition|)
return|return
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_wait
parameter_list|(
specifier|const
name|char
modifier|*
name|prog
parameter_list|,
name|struct
name|pex_obj
modifier|*
name|pex
parameter_list|)
block|{
name|int
name|ret
init|=
name|collect_wait
argument_list|(
name|prog
argument_list|,
name|pex
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"%s returned %d exit status"
argument_list|,
name|prog
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|collect_exit
argument_list|(
name|ret
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Execute a program, and wait for the reply.  */
end_comment

begin_function
name|struct
name|pex_obj
modifier|*
name|collect_execute
parameter_list|(
specifier|const
name|char
modifier|*
name|prog
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|outname
parameter_list|,
specifier|const
name|char
modifier|*
name|errname
parameter_list|)
block|{
name|struct
name|pex_obj
modifier|*
name|pex
decl_stmt|;
specifier|const
name|char
modifier|*
name|errmsg
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|vflag
operator|||
name|debug
condition|)
block|{
name|char
modifier|*
modifier|*
name|p_argv
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
if|if
condition|(
name|argv
index|[
literal|0
index|]
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
else|else
name|notice
argument_list|(
literal|"[cannot find %s]"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
for|for
control|(
name|p_argv
operator|=
operator|&
name|argv
index|[
literal|1
index|]
init|;
operator|(
name|str
operator|=
operator|*
name|p_argv
operator|)
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
condition|;
name|p_argv
operator|++
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
comment|/* If we cannot find a program we need, complain error.  Do this here      since we might not end up needing something that we could not find.  */
if|if
condition|(
name|argv
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"cannot find '%s'"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|pex
operator|=
name|pex_init
argument_list|(
literal|0
argument_list|,
literal|"collect2"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|pex
operator|==
name|NULL
condition|)
name|fatal_perror
argument_list|(
literal|"pex_init failed"
argument_list|)
expr_stmt|;
name|errmsg
operator|=
name|pex_run
argument_list|(
name|pex
argument_list|,
name|PEX_LAST
operator||
name|PEX_SEARCH
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|argv
argument_list|,
name|outname
argument_list|,
name|errname
argument_list|,
operator|&
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|errmsg
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|errno
operator|=
name|err
expr_stmt|;
name|fatal_perror
argument_list|(
literal|"%s"
argument_list|,
name|errmsg
argument_list|)
expr_stmt|;
block|}
else|else
name|fatal
argument_list|(
literal|"%s"
argument_list|,
name|errmsg
argument_list|)
expr_stmt|;
block|}
return|return
name|pex
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fork_execute
parameter_list|(
specifier|const
name|char
modifier|*
name|prog
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|struct
name|pex_obj
modifier|*
name|pex
decl_stmt|;
name|pex
operator|=
name|collect_execute
argument_list|(
name|prog
argument_list|,
name|argv
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|do_wait
argument_list|(
name|prog
argument_list|,
name|pex
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Unlink a file unless we are debugging.  */
end_comment

begin_function
specifier|static
name|void
name|maybe_unlink
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|)
block|{
if|if
condition|(
operator|!
name|debug
condition|)
name|unlink_if_ordinary
argument_list|(
name|file
argument_list|)
expr_stmt|;
else|else
name|notice
argument_list|(
literal|"[Leaving %s]\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|long
name|sequence_number
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Add a name to a linked list.  */
end_comment

begin_function
specifier|static
name|void
name|add_to_list
parameter_list|(
name|struct
name|head
modifier|*
name|head_ptr
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|id
modifier|*
name|newid
init|=
name|xcalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|id
argument_list|)
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|struct
name|id
modifier|*
name|p
decl_stmt|;
name|strcpy
argument_list|(
name|newid
operator|->
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|head_ptr
operator|->
name|first
condition|)
name|head_ptr
operator|->
name|last
operator|->
name|next
operator|=
name|newid
expr_stmt|;
else|else
name|head_ptr
operator|->
name|first
operator|=
name|newid
expr_stmt|;
comment|/* Check for duplicate symbols.  */
for|for
control|(
name|p
operator|=
name|head_ptr
operator|->
name|first
init|;
name|strcmp
argument_list|(
name|name
argument_list|,
name|p
operator|->
name|name
argument_list|)
operator|!=
literal|0
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
empty_stmt|;
if|if
condition|(
name|p
operator|!=
name|newid
condition|)
block|{
name|head_ptr
operator|->
name|last
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|newid
argument_list|)
expr_stmt|;
return|return;
block|}
name|newid
operator|->
name|sequence
operator|=
operator|++
name|sequence_number
expr_stmt|;
name|head_ptr
operator|->
name|last
operator|=
name|newid
expr_stmt|;
name|head_ptr
operator|->
name|number
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Grab the init priority number from an init function name that    looks like "_GLOBAL_.I.12345.foo".  */
end_comment

begin_function
specifier|static
name|int
name|extract_init_priority
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|pos
init|=
literal|0
decl_stmt|,
name|pri
decl_stmt|;
while|while
condition|(
name|name
index|[
name|pos
index|]
operator|==
literal|'_'
condition|)
operator|++
name|pos
expr_stmt|;
name|pos
operator|+=
literal|10
expr_stmt|;
comment|/* strlen ("GLOBAL__X_") */
comment|/* Extract init_p number from ctor/dtor name.  */
name|pri
operator|=
name|atoi
argument_list|(
name|name
operator|+
name|pos
argument_list|)
expr_stmt|;
return|return
name|pri
condition|?
name|pri
else|:
name|DEFAULT_INIT_PRIORITY
return|;
block|}
end_function

begin_comment
comment|/* Insertion sort the ids from ctor/dtor list HEAD_PTR in descending order.    ctors will be run from right to left, dtors from left to right.  */
end_comment

begin_function
specifier|static
name|void
name|sort_ids
parameter_list|(
name|struct
name|head
modifier|*
name|head_ptr
parameter_list|)
block|{
comment|/* id holds the current element to insert.  id_next holds the next      element to insert.  id_ptr iterates through the already sorted elements      looking for the place to insert id.  */
name|struct
name|id
modifier|*
name|id
decl_stmt|,
modifier|*
name|id_next
decl_stmt|,
modifier|*
modifier|*
name|id_ptr
decl_stmt|;
name|id
operator|=
name|head_ptr
operator|->
name|first
expr_stmt|;
comment|/* We don't have any sorted elements yet.  */
name|head_ptr
operator|->
name|first
operator|=
name|NULL
expr_stmt|;
for|for
control|(
init|;
name|id
condition|;
name|id
operator|=
name|id_next
control|)
block|{
name|id_next
operator|=
name|id
operator|->
name|next
expr_stmt|;
name|id
operator|->
name|sequence
operator|=
name|extract_init_priority
argument_list|(
name|id
operator|->
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|id_ptr
operator|=
operator|&
operator|(
name|head_ptr
operator|->
name|first
operator|)
init|;
condition|;
name|id_ptr
operator|=
operator|&
operator|(
operator|(
operator|*
name|id_ptr
operator|)
operator|->
name|next
operator|)
control|)
if|if
condition|(
operator|*
name|id_ptr
operator|==
name|NULL
comment|/* If the sequence numbers are the same, we put the id from the 	       file later on the command line later in the list.  */
operator|||
name|id
operator|->
name|sequence
operator|>
operator|(
operator|*
name|id_ptr
operator|)
operator|->
name|sequence
comment|/* Hack: do lexical compare, too. 	    || (id->sequence == (*id_ptr)->sequence&& strcmp (id->name, (*id_ptr)->name)> 0) */
condition|)
block|{
name|id
operator|->
name|next
operator|=
operator|*
name|id_ptr
expr_stmt|;
operator|*
name|id_ptr
operator|=
name|id
expr_stmt|;
break|break;
block|}
block|}
comment|/* Now set the sequence numbers properly so write_c_file works.  */
for|for
control|(
name|id
operator|=
name|head_ptr
operator|->
name|first
init|;
name|id
condition|;
name|id
operator|=
name|id
operator|->
name|next
control|)
name|id
operator|->
name|sequence
operator|=
operator|++
name|sequence_number
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write: `prefix', the names on list LIST, `suffix'.  */
end_comment

begin_function
specifier|static
name|void
name|write_list
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
name|struct
name|id
modifier|*
name|list
parameter_list|)
block|{
while|while
condition|(
name|list
condition|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%sx%d,\n"
argument_list|,
name|prefix
argument_list|,
name|list
operator|->
name|sequence
argument_list|)
expr_stmt|;
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_if
if|#
directive|if
name|LINK_ELIMINATE_DUPLICATE_LDIRECTORIES
end_if

begin_comment
comment|/* Given a STRING, return nonzero if it occurs in the list in range    [ARGS_BEGIN,ARGS_END).  */
end_comment

begin_function
specifier|static
name|int
name|is_in_args
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|args_begin
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|args_end
parameter_list|)
block|{
specifier|const
name|char
modifier|*
modifier|*
name|args_pointer
decl_stmt|;
for|for
control|(
name|args_pointer
operator|=
name|args_begin
init|;
name|args_pointer
operator|!=
name|args_end
condition|;
operator|++
name|args_pointer
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|string
argument_list|,
operator|*
name|args_pointer
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LINK_ELIMINATE_DUPLICATE_LDIRECTORIES */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|COLLECT_EXPORT_LIST
end_ifdef

begin_comment
comment|/* This function is really used only on AIX, but may be useful.  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static int is_in_list (const char *prefix, struct id *list) {   while (list)     {       if (!strcmp (prefix, list->name)) return 1;       list = list->next;     }     return 0; }
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* COLLECT_EXPORT_LIST */
end_comment

begin_comment
comment|/* Added for debugging purpose.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|COLLECT_EXPORT_LIST
end_ifdef

begin_function
specifier|static
name|void
name|dump_list
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
name|struct
name|id
modifier|*
name|list
parameter_list|)
block|{
while|while
condition|(
name|list
condition|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%s%s,\n"
argument_list|,
name|prefix
argument_list|,
name|list
operator|->
name|name
argument_list|)
expr_stmt|;
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void dump_prefix_list (FILE *stream, const char *prefix, struct prefix_list *list) {   while (list)     {       fprintf (stream, "%s%s,\n", prefix, list->prefix);       list = list->next;     } }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|write_list_with_asm
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
name|struct
name|id
modifier|*
name|list
parameter_list|)
block|{
while|while
condition|(
name|list
condition|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%sx%d __asm__ (\"%s\");\n"
argument_list|,
name|prefix
argument_list|,
name|list
operator|->
name|sequence
argument_list|,
name|list
operator|->
name|name
argument_list|)
expr_stmt|;
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Write out the constructor and destructor tables statically (for a shared    object), along with the functions to execute them.  */
end_comment

begin_function
specifier|static
name|void
name|write_c_file_stat
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|char
modifier|*
name|prefix
decl_stmt|,
modifier|*
name|r
decl_stmt|;
name|int
name|frames
init|=
operator|(
name|frame_tables
operator|.
name|number
operator|>
literal|0
operator|)
decl_stmt|;
comment|/* Figure out name of output_file, stripping off .so version.  */
name|p
operator|=
name|strrchr
argument_list|(
name|output_file
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
name|p
operator|=
name|output_file
expr_stmt|;
else|else
name|p
operator|++
expr_stmt|;
name|q
operator|=
name|p
expr_stmt|;
while|while
condition|(
name|q
condition|)
block|{
name|q
operator|=
name|strchr
argument_list|(
name|q
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|==
literal|0
condition|)
block|{
name|q
operator|=
name|p
operator|+
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|q
argument_list|,
literal|".so"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|q
operator|+=
literal|3
expr_stmt|;
break|break;
block|}
else|else
name|q
operator|++
expr_stmt|;
block|}
block|}
comment|/* q points to null at end of the string (or . of the .so version) */
name|prefix
operator|=
name|XNEWVEC
argument_list|(
name|char
argument_list|,
name|q
operator|-
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|prefix
argument_list|,
name|p
argument_list|,
name|q
operator|-
name|p
argument_list|)
expr_stmt|;
name|prefix
index|[
name|q
operator|-
name|p
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|r
operator|=
name|prefix
init|;
operator|*
name|r
condition|;
name|r
operator|++
control|)
if|if
condition|(
operator|!
name|ISALNUM
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|r
argument_list|)
condition|)
operator|*
name|r
operator|=
literal|'_'
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|notice
argument_list|(
literal|"\nwrite_c_file - output name is %s, prefix is %s\n"
argument_list|,
name|output_file
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|initname
operator|=
name|concat
argument_list|(
literal|"_GLOBAL__FI_"
argument_list|,
name|prefix
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fininame
operator|=
name|concat
argument_list|(
literal|"_GLOBAL__FD_"
argument_list|,
name|prefix
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
comment|/* Write the tables as C code.  */
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"static int count;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"typedef void entry_pt();\n"
argument_list|)
expr_stmt|;
name|write_list_with_asm
argument_list|(
name|stream
argument_list|,
literal|"extern entry_pt "
argument_list|,
name|constructors
operator|.
name|first
argument_list|)
expr_stmt|;
if|if
condition|(
name|frames
condition|)
block|{
name|write_list_with_asm
argument_list|(
name|stream
argument_list|,
literal|"extern void *"
argument_list|,
name|frame_tables
operator|.
name|first
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\tstatic void *frame_table[] = {\n"
argument_list|)
expr_stmt|;
name|write_list
argument_list|(
name|stream
argument_list|,
literal|"\t\t&"
argument_list|,
name|frame_tables
operator|.
name|first
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t0\n};\n"
argument_list|)
expr_stmt|;
comment|/* This must match what's in frame.h.  */
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"struct object {\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"  void *pc_begin;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"  void *pc_end;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"  void *fde_begin;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"  void *fde_array;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"  __SIZE_TYPE__ count;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"  struct object *next;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"};\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"extern void __register_frame_info_table (void *, struct object *);\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"extern void *__deregister_frame_info (void *);\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"static void reg_frame () {\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\tstatic struct object ob;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t__register_frame_info_table (frame_table,&ob);\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t}\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"static void dereg_frame () {\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t__deregister_frame_info (frame_table);\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t}\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"void %s() {\n"
argument_list|,
name|initname
argument_list|)
expr_stmt|;
if|if
condition|(
name|constructors
operator|.
name|number
operator|>
literal|0
operator|||
name|frames
condition|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\tstatic entry_pt *ctors[] = {\n"
argument_list|)
expr_stmt|;
name|write_list
argument_list|(
name|stream
argument_list|,
literal|"\t\t"
argument_list|,
name|constructors
operator|.
name|first
argument_list|)
expr_stmt|;
if|if
condition|(
name|frames
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\treg_frame,\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t};\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\tentry_pt **p;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\tif (count++ != 0) return;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\tp = ctors + %d;\n"
argument_list|,
name|constructors
operator|.
name|number
operator|+
name|frames
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\twhile (p> ctors) (*--p)();\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t++count;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"}\n"
argument_list|)
expr_stmt|;
name|write_list_with_asm
argument_list|(
name|stream
argument_list|,
literal|"extern entry_pt "
argument_list|,
name|destructors
operator|.
name|first
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"void %s() {\n"
argument_list|,
name|fininame
argument_list|)
expr_stmt|;
if|if
condition|(
name|destructors
operator|.
name|number
operator|>
literal|0
operator|||
name|frames
condition|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\tstatic entry_pt *dtors[] = {\n"
argument_list|)
expr_stmt|;
name|write_list
argument_list|(
name|stream
argument_list|,
literal|"\t\t"
argument_list|,
name|destructors
operator|.
name|first
argument_list|)
expr_stmt|;
if|if
condition|(
name|frames
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\tdereg_frame,\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t};\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\tentry_pt **p;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\tif (--count != 0) return;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\tp = dtors;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\twhile (p< dtors + %d) (*p++)();\n"
argument_list|,
name|destructors
operator|.
name|number
operator|+
name|frames
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"}\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|shared_obj
condition|)
block|{
name|COLLECT_SHARED_INIT_FUNC
argument_list|(
name|stream
argument_list|,
name|initname
argument_list|)
expr_stmt|;
name|COLLECT_SHARED_FINI_FUNC
argument_list|(
name|stream
argument_list|,
name|fininame
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Write the constructor/destructor tables.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LD_INIT_SWITCH
end_ifndef

begin_function
specifier|static
name|void
name|write_c_file_glob
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* Write the tables as C code.  */
name|int
name|frames
init|=
operator|(
name|frame_tables
operator|.
name|number
operator|>
literal|0
operator|)
decl_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"typedef void entry_pt();\n\n"
argument_list|)
expr_stmt|;
name|write_list_with_asm
argument_list|(
name|stream
argument_list|,
literal|"extern entry_pt "
argument_list|,
name|constructors
operator|.
name|first
argument_list|)
expr_stmt|;
if|if
condition|(
name|frames
condition|)
block|{
name|write_list_with_asm
argument_list|(
name|stream
argument_list|,
literal|"extern void *"
argument_list|,
name|frame_tables
operator|.
name|first
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\tstatic void *frame_table[] = {\n"
argument_list|)
expr_stmt|;
name|write_list
argument_list|(
name|stream
argument_list|,
literal|"\t\t&"
argument_list|,
name|frame_tables
operator|.
name|first
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t0\n};\n"
argument_list|)
expr_stmt|;
comment|/* This must match what's in frame.h.  */
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"struct object {\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"  void *pc_begin;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"  void *pc_end;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"  void *fde_begin;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"  void *fde_array;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"  __SIZE_TYPE__ count;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"  struct object *next;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"};\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"extern void __register_frame_info_table (void *, struct object *);\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"extern void *__deregister_frame_info (void *);\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"static void reg_frame () {\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\tstatic struct object ob;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t__register_frame_info_table (frame_table,&ob);\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t}\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"static void dereg_frame () {\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t__deregister_frame_info (frame_table);\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t}\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\nentry_pt * __CTOR_LIST__[] = {\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t(entry_pt *) %d,\n"
argument_list|,
name|constructors
operator|.
name|number
operator|+
name|frames
argument_list|)
expr_stmt|;
name|write_list
argument_list|(
name|stream
argument_list|,
literal|"\t"
argument_list|,
name|constructors
operator|.
name|first
argument_list|)
expr_stmt|;
if|if
condition|(
name|frames
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\treg_frame,\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t0\n};\n\n"
argument_list|)
expr_stmt|;
name|write_list_with_asm
argument_list|(
name|stream
argument_list|,
literal|"extern entry_pt "
argument_list|,
name|destructors
operator|.
name|first
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\nentry_pt * __DTOR_LIST__[] = {\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t(entry_pt *) %d,\n"
argument_list|,
name|destructors
operator|.
name|number
operator|+
name|frames
argument_list|)
expr_stmt|;
name|write_list
argument_list|(
name|stream
argument_list|,
literal|"\t"
argument_list|,
name|destructors
operator|.
name|first
argument_list|)
expr_stmt|;
if|if
condition|(
name|frames
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\tdereg_frame,\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\t0\n};\n\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"extern entry_pt %s;\n"
argument_list|,
name|NAME__MAIN
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"entry_pt *__main_reference = %s;\n\n"
argument_list|,
name|NAME__MAIN
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! LD_INIT_SWITCH */
end_comment

begin_function
specifier|static
name|void
name|write_c_file
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"#ifdef __cplusplus\nextern \"C\" {\n#endif\n"
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|LD_INIT_SWITCH
if|if
condition|(
operator|!
name|shared_obj
condition|)
name|write_c_file_glob
argument_list|(
name|stream
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|write_c_file_stat
argument_list|(
name|stream
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"#ifdef __cplusplus\n}\n#endif\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|COLLECT_EXPORT_LIST
end_ifdef

begin_function
specifier|static
name|void
name|write_aix_file
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
name|struct
name|id
modifier|*
name|list
parameter_list|)
block|{
for|for
control|(
init|;
name|list
condition|;
name|list
operator|=
name|list
operator|->
name|next
control|)
block|{
name|fputs
argument_list|(
name|list
operator|->
name|name
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|OBJECT_FORMAT_NONE
end_ifdef

begin_comment
comment|/* Generic version to scan the name list of the loaded program for    the symbols g++ uses for static constructors and destructors.     The constructor table begins at __CTOR_LIST__ and contains a count    of the number of pointers (or -1 if the constructors are built in a    separate section by the linker), followed by the pointers to the    constructor functions, terminated with a null pointer.  The    destructor table has the same format, and begins at __DTOR_LIST__.  */
end_comment

begin_function
specifier|static
name|void
name|scan_prog_file
parameter_list|(
specifier|const
name|char
modifier|*
name|prog_name
parameter_list|,
name|enum
name|pass
name|which_pass
parameter_list|)
block|{
name|void
function_decl|(
modifier|*
name|int_handler
function_decl|)
parameter_list|(
name|int
parameter_list|)
function_decl|;
ifdef|#
directive|ifdef
name|SIGQUIT
name|void
function_decl|(
modifier|*
name|quit_handler
function_decl|)
parameter_list|(
name|int
parameter_list|)
function_decl|;
endif|#
directive|endif
name|char
modifier|*
name|real_nm_argv
index|[
literal|4
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|nm_argv
init|=
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|real_nm_argv
decl_stmt|;
name|int
name|argc
init|=
literal|0
decl_stmt|;
name|struct
name|pex_obj
modifier|*
name|pex
decl_stmt|;
specifier|const
name|char
modifier|*
name|errmsg
decl_stmt|;
name|int
name|err
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|FILE
modifier|*
name|inf
decl_stmt|;
if|if
condition|(
name|which_pass
operator|==
name|PASS_SECOND
condition|)
return|return;
comment|/* If we do not have an `nm', complain.  */
if|if
condition|(
name|nm_file_name
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"cannot find 'nm'"
argument_list|)
expr_stmt|;
name|nm_argv
index|[
name|argc
operator|++
index|]
operator|=
name|nm_file_name
expr_stmt|;
if|if
condition|(
name|NM_FLAGS
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|nm_argv
index|[
name|argc
operator|++
index|]
operator|=
name|NM_FLAGS
expr_stmt|;
name|nm_argv
index|[
name|argc
operator|++
index|]
operator|=
name|prog_name
expr_stmt|;
name|nm_argv
index|[
name|argc
operator|++
index|]
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* Trace if needed.  */
if|if
condition|(
name|vflag
condition|)
block|{
specifier|const
name|char
modifier|*
modifier|*
name|p_argv
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
for|for
control|(
name|p_argv
operator|=
operator|&
name|nm_argv
index|[
literal|0
index|]
init|;
operator|(
name|str
operator|=
operator|*
name|p_argv
operator|)
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
condition|;
name|p_argv
operator|++
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|pex
operator|=
name|pex_init
argument_list|(
name|PEX_USE_PIPES
argument_list|,
literal|"collect2"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|pex
operator|==
name|NULL
condition|)
name|fatal_perror
argument_list|(
literal|"pex_init failed"
argument_list|)
expr_stmt|;
name|errmsg
operator|=
name|pex_run
argument_list|(
name|pex
argument_list|,
literal|0
argument_list|,
name|nm_file_name
argument_list|,
name|real_nm_argv
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|errmsg
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|errno
operator|=
name|err
expr_stmt|;
name|fatal_perror
argument_list|(
literal|"%s"
argument_list|,
name|errmsg
argument_list|)
expr_stmt|;
block|}
else|else
name|fatal
argument_list|(
literal|"%s"
argument_list|,
name|errmsg
argument_list|)
expr_stmt|;
block|}
name|int_handler
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|int
argument_list|)
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGQUIT
name|quit_handler
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|int
argument_list|)
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|inf
operator|=
name|pex_read_output
argument_list|(
name|pex
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|inf
operator|==
name|NULL
condition|)
name|fatal_perror
argument_list|(
literal|"can't open nm output"
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nnm output with constructors/destructors.\n"
argument_list|)
expr_stmt|;
comment|/* Read each line of nm output.  */
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|inf
argument_list|)
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
block|{
name|int
name|ch
decl_stmt|,
name|ch2
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|end
decl_stmt|;
comment|/* If it contains a constructor or destructor name, add the name 	 to the appropriate list.  */
for|for
control|(
name|p
operator|=
name|buf
init|;
operator|(
name|ch
operator|=
operator|*
name|p
operator|)
operator|!=
literal|'\0'
operator|&&
name|ch
operator|!=
literal|'\n'
operator|&&
name|ch
operator|!=
literal|'_'
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|ch
operator|==
literal|' '
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'U'
operator|&&
name|p
index|[
literal|2
index|]
operator|==
literal|' '
condition|)
break|break;
if|if
condition|(
name|ch
operator|!=
literal|'_'
condition|)
continue|continue;
name|name
operator|=
name|p
expr_stmt|;
comment|/* Find the end of the symbol name. 	 Do not include `|', because Encore nm can tack that on the end.  */
for|for
control|(
name|end
operator|=
name|p
init|;
operator|(
name|ch2
operator|=
operator|*
name|end
operator|)
operator|!=
literal|'\0'
operator|&&
operator|!
name|ISSPACE
argument_list|(
name|ch2
argument_list|)
operator|&&
name|ch2
operator|!=
literal|'|'
condition|;
name|end
operator|++
control|)
continue|continue;
operator|*
name|end
operator|=
literal|'\0'
expr_stmt|;
switch|switch
condition|(
name|is_ctor_dtor
argument_list|(
name|name
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
if|if
condition|(
name|which_pass
operator|!=
name|PASS_LIB
condition|)
name|add_to_list
argument_list|(
operator|&
name|constructors
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
if|if
condition|(
name|which_pass
operator|!=
name|PASS_LIB
condition|)
name|add_to_list
argument_list|(
operator|&
name|destructors
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
if|if
condition|(
name|which_pass
operator|!=
name|PASS_LIB
condition|)
name|fatal
argument_list|(
literal|"init function found in object %s"
argument_list|,
name|prog_name
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|LD_INIT_SWITCH
name|add_to_list
argument_list|(
operator|&
name|constructors
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|4
case|:
if|if
condition|(
name|which_pass
operator|!=
name|PASS_LIB
condition|)
name|fatal
argument_list|(
literal|"fini function found in object %s"
argument_list|,
name|prog_name
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|LD_FINI_SWITCH
name|add_to_list
argument_list|(
operator|&
name|destructors
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|5
case|:
if|if
condition|(
name|which_pass
operator|!=
name|PASS_LIB
condition|)
name|add_to_list
argument_list|(
operator|&
name|frame_tables
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* not a constructor or destructor */
continue|continue;
block|}
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t%s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|do_wait
argument_list|(
name|nm_file_name
argument_list|,
name|pex
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|int_handler
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGQUIT
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|quit_handler
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|LDD_SUFFIX
end_ifdef

begin_comment
comment|/* Use the List Dynamic Dependencies program to find shared libraries that    the output file depends upon and their initialization/finalization    routines, if any.  */
end_comment

begin_function
specifier|static
name|void
name|scan_libraries
parameter_list|(
specifier|const
name|char
modifier|*
name|prog_name
parameter_list|)
block|{
specifier|static
name|struct
name|head
name|libraries
decl_stmt|;
comment|/* list of shared libraries found */
name|struct
name|id
modifier|*
name|list
decl_stmt|;
name|void
function_decl|(
modifier|*
name|int_handler
function_decl|)
parameter_list|(
name|int
parameter_list|)
function_decl|;
ifdef|#
directive|ifdef
name|SIGQUIT
name|void
function_decl|(
modifier|*
name|quit_handler
function_decl|)
parameter_list|(
name|int
parameter_list|)
function_decl|;
endif|#
directive|endif
name|char
modifier|*
name|real_ldd_argv
index|[
literal|4
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|ldd_argv
init|=
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|real_ldd_argv
decl_stmt|;
name|int
name|argc
init|=
literal|0
decl_stmt|;
name|struct
name|pex_obj
modifier|*
name|pex
decl_stmt|;
specifier|const
name|char
modifier|*
name|errmsg
decl_stmt|;
name|int
name|err
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|FILE
modifier|*
name|inf
decl_stmt|;
comment|/* If we do not have an `ldd', complain.  */
if|if
condition|(
name|ldd_file_name
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"cannot find 'ldd'"
argument_list|)
expr_stmt|;
return|return;
block|}
name|ldd_argv
index|[
name|argc
operator|++
index|]
operator|=
name|ldd_file_name
expr_stmt|;
name|ldd_argv
index|[
name|argc
operator|++
index|]
operator|=
name|prog_name
expr_stmt|;
name|ldd_argv
index|[
name|argc
operator|++
index|]
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* Trace if needed.  */
if|if
condition|(
name|vflag
condition|)
block|{
specifier|const
name|char
modifier|*
modifier|*
name|p_argv
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
for|for
control|(
name|p_argv
operator|=
operator|&
name|ldd_argv
index|[
literal|0
index|]
init|;
operator|(
name|str
operator|=
operator|*
name|p_argv
operator|)
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
condition|;
name|p_argv
operator|++
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|pex
operator|=
name|pex_init
argument_list|(
name|PEX_USE_PIPES
argument_list|,
literal|"collect2"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|pex
operator|==
name|NULL
condition|)
name|fatal_perror
argument_list|(
literal|"pex_init failed"
argument_list|)
expr_stmt|;
name|errmsg
operator|=
name|pex_run
argument_list|(
name|pex
argument_list|,
literal|0
argument_list|,
name|ldd_file_name
argument_list|,
name|real_ldd_argv
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|errmsg
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|errno
operator|=
name|err
expr_stmt|;
name|fatal_perror
argument_list|(
name|errmsg
argument_list|)
expr_stmt|;
block|}
else|else
name|fatal
argument_list|(
name|errmsg
argument_list|)
expr_stmt|;
block|}
name|int_handler
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|int
argument_list|)
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGQUIT
name|quit_handler
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|int
argument_list|)
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|inf
operator|=
name|pex_read_output
argument_list|(
name|pex
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|inf
operator|==
name|NULL
condition|)
name|fatal_perror
argument_list|(
literal|"can't open ldd output"
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|notice
argument_list|(
literal|"\nldd output with constructors/destructors.\n"
argument_list|)
expr_stmt|;
comment|/* Read each line of ldd output.  */
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|inf
argument_list|)
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
block|{
name|int
name|ch2
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|end
decl_stmt|,
modifier|*
name|p
init|=
name|buf
decl_stmt|;
comment|/* Extract names of libraries and add to list.  */
name|PARSE_LDD_OUTPUT
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
continue|continue;
name|name
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"not found"
argument_list|,
sizeof|sizeof
argument_list|(
literal|"not found"
argument_list|)
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"dynamic dependency %s not found"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* Find the end of the symbol name.  */
for|for
control|(
name|end
operator|=
name|p
init|;
operator|(
name|ch2
operator|=
operator|*
name|end
operator|)
operator|!=
literal|'\0'
operator|&&
name|ch2
operator|!=
literal|'\n'
operator|&&
operator|!
name|ISSPACE
argument_list|(
name|ch2
argument_list|)
operator|&&
name|ch2
operator|!=
literal|'|'
condition|;
name|end
operator|++
control|)
continue|continue;
operator|*
name|end
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|name
argument_list|,
name|R_OK
argument_list|)
operator|==
literal|0
condition|)
name|add_to_list
argument_list|(
operator|&
name|libraries
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|fatal
argument_list|(
literal|"unable to open dynamic dependency '%s'"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t%s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|do_wait
argument_list|(
name|ldd_file_name
argument_list|,
name|pex
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|int_handler
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGQUIT
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|quit_handler
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Now iterate through the library list adding their symbols to      the list.  */
for|for
control|(
name|list
operator|=
name|libraries
operator|.
name|first
init|;
name|list
condition|;
name|list
operator|=
name|list
operator|->
name|next
control|)
name|scan_prog_file
argument_list|(
name|list
operator|->
name|name
argument_list|,
name|PASS_LIB
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LDD_SUFFIX */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJECT_FORMAT_NONE */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  * COFF specific stuff.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OBJECT_FORMAT_COFF
end_ifdef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|EXTENDED_COFF
argument_list|)
end_if

begin_define
define|#
directive|define
name|GCC_SYMBOLS
parameter_list|(
name|X
parameter_list|)
value|(SYMHEADER(X).isymMax + SYMHEADER(X).iextMax)
end_define

begin_define
define|#
directive|define
name|GCC_SYMENT
value|SYMR
end_define

begin_define
define|#
directive|define
name|GCC_OK_SYMBOL
parameter_list|(
name|X
parameter_list|)
value|((X).st == stProc || (X).st == stGlobal)
end_define

begin_define
define|#
directive|define
name|GCC_SYMINC
parameter_list|(
name|X
parameter_list|)
value|(1)
end_define

begin_define
define|#
directive|define
name|GCC_SYMZERO
parameter_list|(
name|X
parameter_list|)
value|(SYMHEADER(X).isymMax)
end_define

begin_define
define|#
directive|define
name|GCC_CHECK_HDR
parameter_list|(
name|X
parameter_list|)
value|(PSYMTAB(X) != 0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|GCC_SYMBOLS
parameter_list|(
name|X
parameter_list|)
value|(HEADER(ldptr).f_nsyms)
end_define

begin_define
define|#
directive|define
name|GCC_SYMENT
value|SYMENT
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|C_WEAKEXT
argument_list|)
end_if

begin_define
define|#
directive|define
name|GCC_OK_SYMBOL
parameter_list|(
name|X
parameter_list|)
define|\
value|(((X).n_sclass == C_EXT || (X).n_sclass == C_WEAKEXT)&& \ 	((X).n_scnum> N_UNDEF)&& \ 	(aix64_flag \ 	 || (((X).n_type& N_TMASK) == (DT_NON<< N_BTSHFT) \ 	     || ((X).n_type& N_TMASK) == (DT_FCN<< N_BTSHFT))))
end_define

begin_define
define|#
directive|define
name|GCC_UNDEF_SYMBOL
parameter_list|(
name|X
parameter_list|)
define|\
value|(((X).n_sclass == C_EXT || (X).n_sclass == C_WEAKEXT)&& \ 	((X).n_scnum == N_UNDEF))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|GCC_OK_SYMBOL
parameter_list|(
name|X
parameter_list|)
define|\
value|(((X).n_sclass == C_EXT)&& \ 	((X).n_scnum> N_UNDEF)&& \ 	(aix64_flag \ 	 || (((X).n_type& N_TMASK) == (DT_NON<< N_BTSHFT) \ 	     || ((X).n_type& N_TMASK) == (DT_FCN<< N_BTSHFT))))
end_define

begin_define
define|#
directive|define
name|GCC_UNDEF_SYMBOL
parameter_list|(
name|X
parameter_list|)
define|\
value|(((X).n_sclass == C_EXT)&& ((X).n_scnum == N_UNDEF))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|GCC_SYMINC
parameter_list|(
name|X
parameter_list|)
value|((X).n_numaux+1)
end_define

begin_define
define|#
directive|define
name|GCC_SYMZERO
parameter_list|(
name|X
parameter_list|)
value|0
end_define

begin_comment
comment|/* 0757 = U803XTOCMAGIC (AIX 4.3) and 0767 = U64_TOCMAGIC (AIX V5) */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_AIX51
end_ifdef

begin_define
define|#
directive|define
name|GCC_CHECK_HDR
parameter_list|(
name|X
parameter_list|)
define|\
value|((HEADER (X).f_magic == U802TOCMAGIC&& ! aix64_flag) \       || (HEADER (X).f_magic == 0767&& aix64_flag))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|GCC_CHECK_HDR
parameter_list|(
name|X
parameter_list|)
define|\
value|((HEADER (X).f_magic == U802TOCMAGIC&& ! aix64_flag) \       || (HEADER (X).f_magic == 0757&& aix64_flag))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|COLLECT_EXPORT_LIST
end_ifdef

begin_comment
comment|/* Array of standard AIX libraries which should not    be scanned for ctors/dtors.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|aix_std_libs
index|[]
init|=
block|{
literal|"/unix"
block|,
literal|"/lib/libc.a"
block|,
literal|"/lib/libm.a"
block|,
literal|"/lib/libc_r.a"
block|,
literal|"/lib/libm_r.a"
block|,
literal|"/usr/lib/libc.a"
block|,
literal|"/usr/lib/libm.a"
block|,
literal|"/usr/lib/libc_r.a"
block|,
literal|"/usr/lib/libm_r.a"
block|,
literal|"/usr/lib/threads/libc.a"
block|,
literal|"/usr/ccs/lib/libc.a"
block|,
literal|"/usr/ccs/lib/libm.a"
block|,
literal|"/usr/ccs/lib/libc_r.a"
block|,
literal|"/usr/ccs/lib/libm_r.a"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This function checks the filename and returns 1    if this name matches the location of a standard AIX library.  */
end_comment

begin_function_decl
specifier|static
name|int
name|ignore_library
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|ignore_library
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|p
init|=
operator|&
name|aix_std_libs
index|[
literal|0
index|]
decl_stmt|;
while|while
condition|(
operator|*
name|p
operator|++
operator|!=
name|NULL
condition|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
operator|*
name|p
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* COLLECT_EXPORT_LIST */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_DECL_LDGETNAME
argument_list|)
operator|&&
operator|!
name|HAVE_DECL_LDGETNAME
end_if

begin_function_decl
specifier|extern
name|char
modifier|*
name|ldgetname
parameter_list|(
name|LDFILE
modifier|*
parameter_list|,
name|GCC_SYMENT
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* COFF version to scan the name list of the loaded program for    the symbols g++ uses for static constructors and destructors.     The constructor table begins at __CTOR_LIST__ and contains a count    of the number of pointers (or -1 if the constructors are built in a    separate section by the linker), followed by the pointers to the    constructor functions, terminated with a null pointer.  The    destructor table has the same format, and begins at __DTOR_LIST__.  */
end_comment

begin_function
specifier|static
name|void
name|scan_prog_file
parameter_list|(
specifier|const
name|char
modifier|*
name|prog_name
parameter_list|,
name|enum
name|pass
name|which_pass
parameter_list|)
block|{
name|LDFILE
modifier|*
name|ldptr
init|=
name|NULL
decl_stmt|;
name|int
name|sym_index
decl_stmt|,
name|sym_count
decl_stmt|;
name|int
name|is_shared
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|which_pass
operator|!=
name|PASS_FIRST
operator|&&
name|which_pass
operator|!=
name|PASS_OBJ
condition|)
return|return;
ifdef|#
directive|ifdef
name|COLLECT_EXPORT_LIST
comment|/* We do not need scanning for some standard C libraries.  */
if|if
condition|(
name|which_pass
operator|==
name|PASS_FIRST
operator|&&
name|ignore_library
argument_list|(
name|prog_name
argument_list|)
condition|)
return|return;
comment|/* On AIX we have a loop, because there is not much difference      between an object and an archive. This trick allows us to      eliminate scan_libraries() function.  */
do|do
block|{
endif|#
directive|endif
comment|/* Some platforms (e.g. OSF4) declare ldopen as taking a 	 non-const char * filename parameter, even though it will not 	 modify that string.  So we must cast away const-ness here, 	 which will cause -Wcast-qual to burp.  */
if|if
condition|(
operator|(
name|ldptr
operator|=
name|ldopen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|prog_name
argument_list|,
name|ldptr
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|MY_ISCOFF
argument_list|(
name|HEADER
argument_list|(
name|ldptr
argument_list|)
operator|.
name|f_magic
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"%s: not a COFF file"
argument_list|,
name|prog_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|GCC_CHECK_HDR
argument_list|(
name|ldptr
argument_list|)
condition|)
block|{
name|sym_count
operator|=
name|GCC_SYMBOLS
argument_list|(
name|ldptr
argument_list|)
expr_stmt|;
name|sym_index
operator|=
name|GCC_SYMZERO
argument_list|(
name|ldptr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COLLECT_EXPORT_LIST
comment|/* Is current archive member a shared object?  */
name|is_shared
operator|=
name|HEADER
argument_list|(
name|ldptr
argument_list|)
operator|.
name|f_flags
operator|&
name|F_SHROBJ
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|sym_index
operator|<
name|sym_count
condition|)
block|{
name|GCC_SYMENT
name|symbol
decl_stmt|;
if|if
condition|(
name|ldtbread
argument_list|(
name|ldptr
argument_list|,
name|sym_index
argument_list|,
operator|&
name|symbol
argument_list|)
operator|<=
literal|0
condition|)
break|break;
name|sym_index
operator|+=
name|GCC_SYMINC
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|GCC_OK_SYMBOL
argument_list|(
name|symbol
argument_list|)
condition|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
operator|(
name|name
operator|=
name|ldgetname
argument_list|(
name|ldptr
argument_list|,
operator|&
name|symbol
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
comment|/* Should never happen.  */
ifdef|#
directive|ifdef
name|XCOFF_DEBUGGING_INFO
comment|/* All AIX function names have a duplicate entry 			 beginning with a dot.  */
if|if
condition|(
operator|*
name|name
operator|==
literal|'.'
condition|)
operator|++
name|name
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|is_ctor_dtor
argument_list|(
name|name
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
if|if
condition|(
operator|!
name|is_shared
condition|)
name|add_to_list
argument_list|(
operator|&
name|constructors
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|COLLECT_EXPORT_LIST
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|LD_INIT_SWITCH
argument_list|)
if|if
condition|(
name|which_pass
operator|==
name|PASS_OBJ
condition|)
name|add_to_list
argument_list|(
operator|&
name|exports
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|2
case|:
if|if
condition|(
operator|!
name|is_shared
condition|)
name|add_to_list
argument_list|(
operator|&
name|destructors
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|COLLECT_EXPORT_LIST
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|LD_INIT_SWITCH
argument_list|)
if|if
condition|(
name|which_pass
operator|==
name|PASS_OBJ
condition|)
name|add_to_list
argument_list|(
operator|&
name|exports
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
ifdef|#
directive|ifdef
name|COLLECT_EXPORT_LIST
case|case
literal|3
case|:
ifndef|#
directive|ifndef
name|LD_INIT_SWITCH
if|if
condition|(
name|is_shared
condition|)
name|add_to_list
argument_list|(
operator|&
name|constructors
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|4
case|:
ifndef|#
directive|ifndef
name|LD_INIT_SWITCH
if|if
condition|(
name|is_shared
condition|)
name|add_to_list
argument_list|(
operator|&
name|destructors
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
endif|#
directive|endif
case|case
literal|5
case|:
if|if
condition|(
operator|!
name|is_shared
condition|)
name|add_to_list
argument_list|(
operator|&
name|frame_tables
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|COLLECT_EXPORT_LIST
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|LD_INIT_SWITCH
argument_list|)
if|if
condition|(
name|which_pass
operator|==
name|PASS_OBJ
condition|)
name|add_to_list
argument_list|(
operator|&
name|exports
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
default|default:
comment|/* not a constructor or destructor */
ifdef|#
directive|ifdef
name|COLLECT_EXPORT_LIST
comment|/* Explicitly export all global symbols when 			     building a shared object on AIX, but do not 			     re-export symbols from another shared object 			     and do not export symbols if the user 			     provides an explicit export list.  */
if|if
condition|(
name|shared_obj
operator|&&
operator|!
name|is_shared
operator|&&
name|which_pass
operator|==
name|PASS_OBJ
operator|&&
operator|!
name|export_flag
condition|)
name|add_to_list
argument_list|(
operator|&
name|exports
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
if|if
condition|(
name|debug
condition|)
if|#
directive|if
operator|!
name|defined
argument_list|(
name|EXTENDED_COFF
argument_list|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tsec=%d class=%d type=%s%o %s\n"
argument_list|,
name|symbol
operator|.
name|n_scnum
argument_list|,
name|symbol
operator|.
name|n_sclass
argument_list|,
operator|(
name|symbol
operator|.
name|n_type
condition|?
literal|"0"
else|:
literal|""
operator|)
argument_list|,
name|symbol
operator|.
name|n_type
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tiss = %5d, value = %5ld, index = %5d, name = %s\n"
argument_list|,
name|symbol
operator|.
name|iss
argument_list|,
operator|(
name|long
operator|)
name|symbol
operator|.
name|value
argument_list|,
name|symbol
operator|.
name|index
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|COLLECT_EXPORT_LIST
else|else
block|{
comment|/* If archive contains both 32-bit and 64-bit objects, 		 we want to skip objects in other mode so mismatch normal.  */
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s : magic=%o aix64=%d mismatch\n"
argument_list|,
name|prog_name
argument_list|,
name|HEADER
argument_list|(
name|ldptr
argument_list|)
operator|.
name|f_magic
argument_list|,
name|aix64_flag
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
else|else
block|{
name|fatal
argument_list|(
literal|"%s: cannot open as COFF file"
argument_list|,
name|prog_name
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|COLLECT_EXPORT_LIST
comment|/* On AIX loop continues while there are more members in archive.  */
block|}
do|while
condition|(
name|ldclose
argument_list|(
name|ldptr
argument_list|)
operator|==
name|FAILURE
condition|)
do|;
else|#
directive|else
comment|/* Otherwise we simply close ldptr.  */
operator|(
name|void
operator|)
name|ldclose
argument_list|(
name|ldptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJECT_FORMAT_COFF */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|COLLECT_EXPORT_LIST
end_ifdef

begin_comment
comment|/* Given a library name without "lib" prefix, this function    returns a full library name including a path.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|resolve_lib_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|char
modifier|*
name|lib_buf
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|l
init|=
literal|0
decl_stmt|;
comment|/* Library extensions for AIX dynamic linking.  */
specifier|const
name|char
modifier|*
specifier|const
name|libexts
index|[
literal|2
index|]
init|=
block|{
literal|"a"
block|,
literal|"so"
block|}
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|libpaths
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|libpaths
index|[
name|i
index|]
operator|->
name|max_len
operator|>
name|l
condition|)
name|l
operator|=
name|libpaths
index|[
name|i
index|]
operator|->
name|max_len
expr_stmt|;
name|lib_buf
operator|=
name|xmalloc
argument_list|(
name|l
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|libpaths
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|prefix_list
modifier|*
name|list
init|=
name|libpaths
index|[
name|i
index|]
operator|->
name|plist
decl_stmt|;
for|for
control|(
init|;
name|list
condition|;
name|list
operator|=
name|list
operator|->
name|next
control|)
block|{
comment|/* The following lines are needed because path_prefix list 	     may contain directories both with trailing '/' and 	     without it.  */
specifier|const
name|char
modifier|*
name|p
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|list
operator|->
name|prefix
index|[
name|strlen
argument_list|(
name|list
operator|->
name|prefix
argument_list|)
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
name|p
operator|=
literal|"/"
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|2
condition|;
name|j
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|lib_buf
argument_list|,
literal|"%s%slib%s.%s"
argument_list|,
name|list
operator|->
name|prefix
argument_list|,
name|p
argument_list|,
name|name
argument_list|,
name|libexts
index|[
operator|(
name|j
operator|+
name|aixrtl_flag
operator|)
operator|%
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"searching for: %s\n"
argument_list|,
name|lib_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|file_exists
argument_list|(
name|lib_buf
argument_list|)
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"found: %s\n"
argument_list|,
name|lib_buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|lib_buf
operator|)
return|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"not found\n"
argument_list|)
expr_stmt|;
else|else
name|fatal
argument_list|(
literal|"library lib%s not found"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* COLLECT_EXPORT_LIST */
end_comment

end_unit

