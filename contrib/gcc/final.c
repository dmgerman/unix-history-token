begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Convert RTL to assembler code and output it, for GNU compiler.    Copyright (C) 1987, 88, 89, 92, 93, 94, 1995 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This is the final pass of the compiler.    It looks at the rtl code for a function and outputs assembler code.     Call `final_start_function' to output the assembler code for function entry,    `final' to output assembler code for some RTL code,    `final_end_function' to output assembler code for function exit.    If a function is compiled in several pieces, each piece is    output separately with `final'.     Some optimizations are also done at this level.    Move instructions that were made unnecessary by good register allocation    are detected and omitted from the output.  (Though most of these    are removed by the last jump pass.)     Instructions to set the condition codes are omitted when it can be    seen that the condition codes already had the desired values.     In some cases it is sufficient if the inherited condition codes    have related values, but this may require the following insn    (the one that tests the condition codes) to be modified.     The code for the function prologue and epilogue are generated    directly as assembler code by the macros FUNCTION_PROLOGUE and    FUNCTION_EPILOGUE.  Those instructions never exist as rtl.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"insn-flags.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_include
include|#
directive|include
file|"insn-codes.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"conditions.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"defaults.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_comment
comment|/* Get N_SLINE and N_SOL from stab.h if we can expect the file to exist.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DBX_DEBUGGING_INFO
argument_list|)
operator|||
name|defined
argument_list|(
name|XCOFF_DEBUGGING_INFO
argument_list|)
end_if

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USG
argument_list|)
operator|||
name|defined
argument_list|(
name|NO_STAB_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|"gstab.h"
end_include

begin_comment
comment|/* If doing DBX on sysV, use our own stab.h.  */
end_comment

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<stab.h>
end_include

begin_comment
comment|/* On BSD, use the system's stab.h.  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not USG */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DBX_DEBUGGING_INFO || XCOFF_DEBUGGING_INFO */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|XCOFF_DEBUGGING_INFO
end_ifdef

begin_include
include|#
directive|include
file|"xcoffout.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* .stabd code for line number.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|N_SLINE
end_ifndef

begin_define
define|#
directive|define
name|N_SLINE
value|0x44
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* .stabs code for included file name.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|N_SOL
end_ifndef

begin_define
define|#
directive|define
name|N_SOL
value|0x84
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|INT_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|INT_TYPE_SIZE
value|BITS_PER_WORD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* If we aren't using cc0, CC_STATUS_INIT shouldn't exist.  So define a    null default for it to save conditionalization later.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CC_STATUS_INIT
end_ifndef

begin_define
define|#
directive|define
name|CC_STATUS_INIT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* How to start an assembler comment.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_COMMENT_START
end_ifndef

begin_define
define|#
directive|define
name|ASM_COMMENT_START
value|";#"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Is the given character a logical line separator for the assembler?  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|IS_ASM_LOGICAL_LINE_SEPARATOR
end_ifndef

begin_define
define|#
directive|define
name|IS_ASM_LOGICAL_LINE_SEPARATOR
parameter_list|(
name|C
parameter_list|)
value|((C) == ';')
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Nonzero means this function is a leaf function, with no function calls.     This variable exists to be examined in FUNCTION_PROLOGUE    and FUNCTION_EPILOGUE.  Always zero, unless set by some action.  */
end_comment

begin_decl_stmt
name|int
name|leaf_function
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last insn processed by final_scan_insn.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|debug_insn
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Line number of last NOTE.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|last_linenum
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Highest line number in current block.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|high_block_linenum
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Likewise for function.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|high_function_linenum
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Filename of last NOTE.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|last_filename
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of basic blocks seen so far;    used if profile_block_flag is set.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|count_basic_blocks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero while outputting an `asm' with operands.    This means that inconsistencies are the user's fault, so don't abort.    The precise value is the insn being output, to pass to error_for_asm.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|this_is_asm_operands
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of operands of this insn, for an `asm' with operands.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|insn_noperands
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Compare optimization flag.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|last_ignored_compare
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag indicating this insn is the start of a new basic block.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|new_block
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* All the symbol-blocks (levels of scoping) in the compilation    are assigned sequence numbers in order of appearance of the    beginnings of the symbol-blocks.  Both final and dbxout do this,    and assume that they will both give the same number to each block.    Final uses these sequence numbers to generate assembler label names    LBBnnn and LBEnnn for the beginning and end of the symbol-block.    Dbxout uses the sequence numbers to generate references to the same labels    from the dbx debugging information.     Sdb records this level at the beginning of each function,    in order to find the current level when recursing down declarations.    It outputs the block beginning and endings    at the point in the asm file where the blocks would begin and end.  */
end_comment

begin_decl_stmt
name|int
name|next_block_index
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Assign a unique number to each insn that is output.    This can be used to generate unique local labels.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|insn_counter
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_cc0
end_ifdef

begin_comment
comment|/* This variable contains machine-dependent flags (defined in tm.h)    set and examined by output routines    that describe how to interpret the condition codes properly.  */
end_comment

begin_decl_stmt
name|CC_STATUS
name|cc_status
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* During output of an insn, this contains a copy of cc_status    from before the insn.  */
end_comment

begin_decl_stmt
name|CC_STATUS
name|cc_prev_status
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Indexed by hardware reg number, is 1 if that register is ever    used in the current function.     In life_analysis, or in stupid_life_analysis, this is set    up to record the hard regs used explicitly.  Reload adds    in the hard regs used for holding pseudo regs.  Final uses    it to generate the code in the function prologue and epilogue    to save and restore registers as needed.  */
end_comment

begin_decl_stmt
name|char
name|regs_ever_live
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means current function must be given a frame pointer.    Set in stmt.c if anything is allocated on the stack there.    Set in reload1.c if anything is allocated on the stack there.  */
end_comment

begin_decl_stmt
name|int
name|frame_pointer_needed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Assign unique numbers to labels generated for profiling.  */
end_comment

begin_decl_stmt
name|int
name|profile_label_no
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Length so far allocated in PENDING_BLOCKS.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_block_depth
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Stack of sequence numbers of symbol-blocks of which we have seen the    beginning but not yet the end.  Sequence numbers are assigned at    the beginning; this stack allows us to find the sequence number    of a block that is ending.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|pending_blocks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of elements currently in use in PENDING_BLOCKS.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|block_depth
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if have enabled APP processing of our assembler output.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|app_on
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If we are outputting an insn sequence, this contains the sequence rtx.    Zero otherwise.  */
end_comment

begin_decl_stmt
name|rtx
name|final_sequence
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|ASSEMBLER_DIALECT
end_ifdef

begin_comment
comment|/* Number of the assembler dialect to use, starting at 0.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|dialect_number
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Indexed by line number, nonzero if there is a note for that line.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|line_note_exists
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Linked list to hold line numbers for each basic block.  */
end_comment

begin_struct
struct|struct
name|bb_list
block|{
name|struct
name|bb_list
modifier|*
name|next
decl_stmt|;
comment|/* pointer to next basic block */
name|int
name|line_num
decl_stmt|;
comment|/* line number */
name|int
name|file_label_num
decl_stmt|;
comment|/* LPBC<n> label # for stored filename */
name|int
name|func_label_num
decl_stmt|;
comment|/* LPBC<n> label # for stored function name */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|bb_list
modifier|*
name|bb_head
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Head of basic block list */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|bb_list
modifier|*
modifier|*
name|bb_tail
init|=
operator|&
name|bb_head
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Ptr to store next bb ptr */
end_comment

begin_decl_stmt
specifier|static
name|int
name|bb_file_label_num
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current label # for file */
end_comment

begin_decl_stmt
specifier|static
name|int
name|bb_func_label_num
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current label # for func */
end_comment

begin_comment
comment|/* Linked list to hold the strings for each file and function name output.  */
end_comment

begin_struct
struct|struct
name|bb_str
block|{
name|struct
name|bb_str
modifier|*
name|next
decl_stmt|;
comment|/* pointer to next string */
name|char
modifier|*
name|string
decl_stmt|;
comment|/* string */
name|int
name|label_num
decl_stmt|;
comment|/* label number */
name|int
name|length
decl_stmt|;
comment|/* string length */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|extern
name|rtx
name|peephole
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bb_str
modifier|*
name|sbb_head
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Head of string list.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|bb_str
modifier|*
modifier|*
name|sbb_tail
init|=
operator|&
name|sbb_head
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Ptr to store next bb str */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sbb_label_num
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last label used */
end_comment

begin_decl_stmt
specifier|static
name|int
name|asm_insn_count
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|profile_function
name|PROTO
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|profile_after_prologue
name|PROTO
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_bb
name|PROTO
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|add_bb_string
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_source_line
name|PROTO
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|walk_alter_subreg
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|alter_cond
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_asm_name
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_operand
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|leaf_renumber_regs
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|char
modifier|*
name|getpwd
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Initialize data in final at the beginning of a compilation.  */
end_comment

begin_function
name|void
name|init_final
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|next_block_index
operator|=
literal|2
expr_stmt|;
name|app_on
operator|=
literal|0
expr_stmt|;
name|max_block_depth
operator|=
literal|20
expr_stmt|;
name|pending_blocks
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
literal|20
operator|*
sizeof|sizeof
expr|*
name|pending_blocks
argument_list|)
expr_stmt|;
name|final_sequence
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|ASSEMBLER_DIALECT
name|dialect_number
operator|=
name|ASSEMBLER_DIALECT
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Called at end of source file,    to output the block-profiling table for this entire compilation.  */
end_comment

begin_function
name|void
name|end_final
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|profile_block_flag
condition|)
block|{
name|char
name|name
index|[
literal|20
index|]
decl_stmt|;
name|int
name|align
init|=
name|exact_log2
argument_list|(
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
argument_list|)
decl_stmt|;
name|int
name|size
init|=
operator|(
name|POINTER_SIZE
operator|/
name|BITS_PER_UNIT
operator|)
operator|*
name|count_basic_blocks
decl_stmt|;
name|int
name|rounded
init|=
name|size
decl_stmt|;
name|struct
name|bb_list
modifier|*
name|ptr
decl_stmt|;
name|struct
name|bb_str
modifier|*
name|sptr
decl_stmt|;
name|rounded
operator|+=
operator|(
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
operator|)
operator|-
literal|1
expr_stmt|;
name|rounded
operator|=
operator|(
name|rounded
operator|/
operator|(
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
operator|)
operator|*
operator|(
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
operator|)
operator|)
expr_stmt|;
name|data_section
argument_list|()
expr_stmt|;
comment|/* Output the main header, of 10 words: 	 0:  1 if this file's initialized, else 0. 	 1:  address of file name (LPBX1). 	 2:  address of table of counts (LPBX2). 	 3:  number of counts in the table. 	 4:  always 0, for compatibility with Sun.           The following are GNU extensions:  	 5:  address of table of start addrs of basic blocks (LPBX3). 	 6:  Number of bytes in this header. 	 7:  address of table of function names (LPBX4). 	 8:  address of table of line numbers (LPBX5) or 0. 	 9:  address of table of file names (LPBX6) or 0.  */
name|ASM_OUTPUT_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
name|align
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|asm_out_file
argument_list|,
literal|"LPBX"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* zero word */
name|assemble_integer
argument_list|(
name|const0_rtx
argument_list|,
name|UNITS_PER_WORD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|".stabs \"bbset\", 25, 0, 0, LPBX0\n"
argument_list|)
expr_stmt|;
comment|/* address of filename */
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|name
argument_list|,
literal|"LPBX"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
name|name
argument_list|)
argument_list|,
name|UNITS_PER_WORD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* address of count table */
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|name
argument_list|,
literal|"LPBX"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
name|name
argument_list|)
argument_list|,
name|UNITS_PER_WORD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* count of the # of basic blocks */
name|assemble_integer
argument_list|(
name|GEN_INT
argument_list|(
name|count_basic_blocks
argument_list|)
argument_list|,
name|UNITS_PER_WORD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* zero word (link field) */
name|assemble_integer
argument_list|(
name|const0_rtx
argument_list|,
name|UNITS_PER_WORD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* address of basic block start address table */
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|name
argument_list|,
literal|"LPBX"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
name|name
argument_list|)
argument_list|,
name|UNITS_PER_WORD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* byte count for extended structure.  */
name|assemble_integer
argument_list|(
name|GEN_INT
argument_list|(
literal|10
operator|*
name|UNITS_PER_WORD
argument_list|)
argument_list|,
name|UNITS_PER_WORD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* address of function name table */
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|name
argument_list|,
literal|"LPBX"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
name|name
argument_list|)
argument_list|,
name|UNITS_PER_WORD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* address of line number and filename tables if debugging.  */
if|if
condition|(
name|write_symbols
operator|!=
name|NO_DEBUG
condition|)
block|{
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|name
argument_list|,
literal|"LPBX"
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
name|name
argument_list|)
argument_list|,
name|UNITS_PER_WORD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|name
argument_list|,
literal|"LPBX"
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
name|name
argument_list|)
argument_list|,
name|UNITS_PER_WORD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assemble_integer
argument_list|(
name|const0_rtx
argument_list|,
name|UNITS_PER_WORD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|const0_rtx
argument_list|,
name|UNITS_PER_WORD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Output the file name changing the suffix to .d for Sun tcov 	 compatibility.  */
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|asm_out_file
argument_list|,
literal|"LPBX"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|{
name|char
modifier|*
name|cwd
init|=
name|getpwd
argument_list|()
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|filename
argument_list|)
operator|+
name|strlen
argument_list|(
name|cwd
argument_list|)
operator|+
literal|1
decl_stmt|;
name|char
modifier|*
name|data_file
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
operator|+
literal|4
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|data_file
argument_list|,
name|cwd
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|data_file
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|data_file
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|strip_off_ending
argument_list|(
name|data_file
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|data_file
argument_list|,
literal|".d"
argument_list|)
expr_stmt|;
name|assemble_string
argument_list|(
name|data_file
argument_list|,
name|strlen
argument_list|(
name|data_file
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Make space for the table of counts.  */
if|if
condition|(
name|flag_no_common
operator|||
name|size
operator|==
literal|0
condition|)
block|{
comment|/* Realign data section.  */
name|ASM_OUTPUT_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
name|align
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|asm_out_file
argument_list|,
literal|"LPBX"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|!=
literal|0
condition|)
name|assemble_zeros
argument_list|(
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|name
argument_list|,
literal|"LPBX"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ASM_OUTPUT_SHARED_LOCAL
if|if
condition|(
name|flag_shared_data
condition|)
name|ASM_OUTPUT_SHARED_LOCAL
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|,
name|size
argument_list|,
name|rounded
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ASM_OUTPUT_ALIGNED_LOCAL
name|ASM_OUTPUT_ALIGNED_LOCAL
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|,
name|size
argument_list|,
name|BIGGEST_ALIGNMENT
argument_list|)
expr_stmt|;
else|#
directive|else
name|ASM_OUTPUT_LOCAL
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|,
name|size
argument_list|,
name|rounded
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Output any basic block strings */
name|readonly_data_section
argument_list|()
expr_stmt|;
if|if
condition|(
name|sbb_head
condition|)
block|{
name|ASM_OUTPUT_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
name|align
argument_list|)
expr_stmt|;
for|for
control|(
name|sptr
operator|=
name|sbb_head
init|;
name|sptr
operator|!=
literal|0
condition|;
name|sptr
operator|=
name|sptr
operator|->
name|next
control|)
block|{
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|asm_out_file
argument_list|,
literal|"LPBC"
argument_list|,
name|sptr
operator|->
name|label_num
argument_list|)
expr_stmt|;
name|assemble_string
argument_list|(
name|sptr
operator|->
name|string
argument_list|,
name|sptr
operator|->
name|length
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Output the table of addresses.  */
comment|/* Realign in new section */
name|ASM_OUTPUT_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
name|align
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|asm_out_file
argument_list|,
literal|"LPBX"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count_basic_blocks
condition|;
name|i
operator|++
control|)
block|{
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|name
argument_list|,
literal|"LPB"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
name|name
argument_list|)
argument_list|,
name|UNITS_PER_WORD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Output the table of function names.  */
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|asm_out_file
argument_list|,
literal|"LPBX"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
for|for
control|(
operator|(
name|ptr
operator|=
name|bb_head
operator|)
operator|,
operator|(
name|i
operator|=
literal|0
operator|)
init|;
name|ptr
operator|!=
literal|0
condition|;
operator|(
name|ptr
operator|=
name|ptr
operator|->
name|next
operator|)
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ptr
operator|->
name|func_label_num
operator|>=
literal|0
condition|)
block|{
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|name
argument_list|,
literal|"LPBC"
argument_list|,
name|ptr
operator|->
name|func_label_num
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
name|name
argument_list|)
argument_list|,
name|UNITS_PER_WORD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|assemble_integer
argument_list|(
name|const0_rtx
argument_list|,
name|UNITS_PER_WORD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|<
name|count_basic_blocks
condition|;
name|i
operator|++
control|)
name|assemble_integer
argument_list|(
name|const0_rtx
argument_list|,
name|UNITS_PER_WORD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_symbols
operator|!=
name|NO_DEBUG
condition|)
block|{
comment|/* Output the table of line numbers.  */
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|asm_out_file
argument_list|,
literal|"LPBX"
argument_list|,
literal|5
argument_list|)
expr_stmt|;
for|for
control|(
operator|(
name|ptr
operator|=
name|bb_head
operator|)
operator|,
operator|(
name|i
operator|=
literal|0
operator|)
init|;
name|ptr
operator|!=
literal|0
condition|;
operator|(
name|ptr
operator|=
name|ptr
operator|->
name|next
operator|)
operator|,
name|i
operator|++
control|)
name|assemble_integer
argument_list|(
name|GEN_INT
argument_list|(
name|ptr
operator|->
name|line_num
argument_list|)
argument_list|,
name|UNITS_PER_WORD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|count_basic_blocks
condition|;
name|i
operator|++
control|)
name|assemble_integer
argument_list|(
name|const0_rtx
argument_list|,
name|UNITS_PER_WORD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Output the table of file names.  */
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|asm_out_file
argument_list|,
literal|"LPBX"
argument_list|,
literal|6
argument_list|)
expr_stmt|;
for|for
control|(
operator|(
name|ptr
operator|=
name|bb_head
operator|)
operator|,
operator|(
name|i
operator|=
literal|0
operator|)
init|;
name|ptr
operator|!=
literal|0
condition|;
operator|(
name|ptr
operator|=
name|ptr
operator|->
name|next
operator|)
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ptr
operator|->
name|file_label_num
operator|>=
literal|0
condition|)
block|{
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|name
argument_list|,
literal|"LPBC"
argument_list|,
name|ptr
operator|->
name|file_label_num
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
name|name
argument_list|)
argument_list|,
name|UNITS_PER_WORD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|assemble_integer
argument_list|(
name|const0_rtx
argument_list|,
name|UNITS_PER_WORD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|<
name|count_basic_blocks
condition|;
name|i
operator|++
control|)
name|assemble_integer
argument_list|(
name|const0_rtx
argument_list|,
name|UNITS_PER_WORD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* End with the address of the table of addresses, 	 so we can find it easily, as the last word in the file's text.  */
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|name
argument_list|,
literal|"LPBX"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
name|name
argument_list|)
argument_list|,
name|UNITS_PER_WORD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Enable APP processing of subsequent output.    Used before the output from an `asm' statement.  */
end_comment

begin_function
name|void
name|app_enable
parameter_list|()
block|{
if|if
condition|(
operator|!
name|app_on
condition|)
block|{
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
name|ASM_APP_ON
argument_list|)
expr_stmt|;
name|app_on
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Disable APP processing of subsequent output.    Called from varasm.c before most kinds of output.  */
end_comment

begin_function
name|void
name|app_disable
parameter_list|()
block|{
if|if
condition|(
name|app_on
condition|)
block|{
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
name|ASM_APP_OFF
argument_list|)
expr_stmt|;
name|app_on
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the number of slots filled in the current     delayed branch sequence (we don't count the insn needing the    delay slot).   Zero if not in a delayed branch sequence.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DELAY_SLOTS
end_ifdef

begin_function
name|int
name|dbr_sequence_length
parameter_list|()
block|{
if|if
condition|(
name|final_sequence
operator|!=
literal|0
condition|)
return|return
name|XVECLEN
argument_list|(
name|final_sequence
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* The next two pages contain routines used to compute the length of an insn    and to shorten branches.  */
end_comment

begin_comment
comment|/* Arrays for insn lengths, and addresses.  The latter is referenced by    `insn_current_length'.  */
end_comment

begin_decl_stmt
specifier|static
name|short
modifier|*
name|insn_lengths
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|insn_addresses
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Address of insn being processed.  Used by `insn_current_length'.  */
end_comment

begin_decl_stmt
name|int
name|insn_current_address
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indicate that branch shortening hasn't yet been done.  */
end_comment

begin_function
name|void
name|init_insn_lengths
parameter_list|()
block|{
name|insn_lengths
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Obtain the current length of an insn.  If branch shortening has been done,    get its actual length.  Otherwise, get its maximum length.  */
end_comment

begin_function
name|int
name|get_attr_length
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|HAVE_ATTR_length
name|rtx
name|body
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|length
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|insn_lengths
condition|)
return|return
name|insn_lengths
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
return|;
else|else
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|NOTE
case|:
case|case
name|BARRIER
case|:
case|case
name|CODE_LABEL
case|:
return|return
literal|0
return|;
case|case
name|CALL_INSN
case|:
name|length
operator|=
name|insn_default_length
argument_list|(
name|insn
argument_list|)
expr_stmt|;
break|break;
case|case
name|JUMP_INSN
case|:
name|body
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|ADDR_VEC
operator|||
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|ADDR_DIFF_VEC
condition|)
block|{
comment|/* This only takes room if jump tables go into the text section.  */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|READONLY_DATA_SECTION
argument_list|)
operator|||
name|defined
argument_list|(
name|JUMP_TABLES_IN_TEXT_SECTION
argument_list|)
name|length
operator|=
operator|(
name|XVECLEN
argument_list|(
name|body
argument_list|,
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|ADDR_DIFF_VEC
argument_list|)
operator|*
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|body
argument_list|)
argument_list|)
operator|)
expr_stmt|;
comment|/* Be pessimistic and assume worst-case alignment.  */
name|length
operator|+=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|body
argument_list|)
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
else|#
directive|else
return|return
literal|0
return|;
endif|#
directive|endif
block|}
else|else
name|length
operator|=
name|insn_default_length
argument_list|(
name|insn
argument_list|)
expr_stmt|;
break|break;
case|case
name|INSN
case|:
name|body
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|CLOBBER
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|ASM_INPUT
operator|||
name|asm_noperands
argument_list|(
name|body
argument_list|)
operator|>=
literal|0
condition|)
name|length
operator|=
name|asm_insn_count
argument_list|(
name|body
argument_list|)
operator|*
name|insn_default_length
argument_list|(
name|insn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|SEQUENCE
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
name|length
operator|+=
name|get_attr_length
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|length
operator|=
name|insn_default_length
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ADJUST_INSN_LENGTH
name|ADJUST_INSN_LENGTH
argument_list|(
name|insn
argument_list|,
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|length
return|;
else|#
directive|else
comment|/* not HAVE_ATTR_length */
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* not HAVE_ATTR_length */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make a pass over all insns and compute their actual lengths by shortening    any branches of variable length if possible.  */
end_comment

begin_comment
comment|/* Give a default value for the lowest address in a function.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|FIRST_INSN_ADDRESS
end_ifndef

begin_define
define|#
directive|define
name|FIRST_INSN_ADDRESS
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|shorten_branches
parameter_list|(
name|first
parameter_list|)
name|rtx
name|first
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|HAVE_ATTR_length
name|rtx
name|insn
decl_stmt|;
name|int
name|something_changed
init|=
literal|1
decl_stmt|;
name|int
name|max_uid
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|varying_length
decl_stmt|;
name|rtx
name|body
decl_stmt|;
name|int
name|uid
decl_stmt|;
comment|/* Compute maximum UID and allocate arrays.  */
for|for
control|(
name|insn
operator|=
name|first
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|>
name|max_uid
condition|)
name|max_uid
operator|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|max_uid
operator|++
expr_stmt|;
name|insn_lengths
operator|=
operator|(
name|short
operator|*
operator|)
name|oballoc
argument_list|(
name|max_uid
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|insn_addresses
operator|=
operator|(
name|int
operator|*
operator|)
name|oballoc
argument_list|(
name|max_uid
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|varying_length
operator|=
operator|(
name|char
operator|*
operator|)
name|oballoc
argument_list|(
name|max_uid
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Compute initial lengths, addresses, and varying flags for each insn.  */
for|for
control|(
name|insn_current_address
operator|=
name|FIRST_INSN_ADDRESS
operator|,
name|insn
operator|=
name|first
init|;
name|insn
operator|!=
literal|0
condition|;
name|insn_current_address
operator|+=
name|insn_lengths
index|[
name|uid
index|]
operator|,
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|uid
operator|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|insn_addresses
index|[
name|uid
index|]
operator|=
name|insn_current_address
expr_stmt|;
name|insn_lengths
index|[
name|uid
index|]
operator|=
literal|0
expr_stmt|;
name|varying_length
index|[
name|uid
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|BARRIER
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
continue|continue;
name|body
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|ADDR_VEC
operator|||
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|ADDR_DIFF_VEC
condition|)
block|{
comment|/* This only takes room if read-only data goes into the text 	     section.  */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|READONLY_DATA_SECTION
argument_list|)
operator|||
name|defined
argument_list|(
name|JUMP_TABLES_IN_TEXT_SECTION
argument_list|)
name|int
name|unitsize
init|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|body
argument_list|)
argument_list|)
decl_stmt|;
name|insn_lengths
index|[
name|uid
index|]
operator|=
operator|(
name|XVECLEN
argument_list|(
name|body
argument_list|,
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|ADDR_DIFF_VEC
argument_list|)
operator|*
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|body
argument_list|)
argument_list|)
operator|)
expr_stmt|;
comment|/* Account for possible alignment.  */
name|insn_lengths
index|[
name|uid
index|]
operator|+=
name|unitsize
operator|-
operator|(
name|insn_current_address
operator|&
operator|(
name|unitsize
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
else|#
directive|else
empty_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|asm_noperands
argument_list|(
name|body
argument_list|)
operator|>=
literal|0
condition|)
name|insn_lengths
index|[
name|uid
index|]
operator|=
name|asm_insn_count
argument_list|(
name|body
argument_list|)
operator|*
name|insn_default_length
argument_list|(
name|insn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|SEQUENCE
condition|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|const_delay_slots
decl_stmt|;
ifdef|#
directive|ifdef
name|DELAY_SLOTS
name|const_delay_slots
operator|=
name|const_num_delay_slots
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|const_delay_slots
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* Inside a delay slot sequence, we do not do any branch shortening 	     if the shortening could change the number of delay slots 	     of the branch. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|inner_insn
init|=
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|int
name|inner_uid
init|=
name|INSN_UID
argument_list|(
name|inner_insn
argument_list|)
decl_stmt|;
name|int
name|inner_length
decl_stmt|;
if|if
condition|(
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
name|inner_length
operator|=
operator|(
name|asm_insn_count
argument_list|(
name|PATTERN
argument_list|(
name|inner_insn
argument_list|)
argument_list|)
operator|*
name|insn_default_length
argument_list|(
name|inner_insn
argument_list|)
operator|)
expr_stmt|;
else|else
name|inner_length
operator|=
name|insn_default_length
argument_list|(
name|inner_insn
argument_list|)
expr_stmt|;
name|insn_lengths
index|[
name|inner_uid
index|]
operator|=
name|inner_length
expr_stmt|;
if|if
condition|(
name|const_delay_slots
condition|)
block|{
if|if
condition|(
operator|(
name|varying_length
index|[
name|inner_uid
index|]
operator|=
name|insn_variable_length_p
argument_list|(
name|inner_insn
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|varying_length
index|[
name|uid
index|]
operator|=
literal|1
expr_stmt|;
name|insn_addresses
index|[
name|inner_uid
index|]
operator|=
operator|(
name|insn_current_address
operator|+
name|insn_lengths
index|[
name|uid
index|]
operator|)
expr_stmt|;
block|}
else|else
name|varying_length
index|[
name|inner_uid
index|]
operator|=
literal|0
expr_stmt|;
name|insn_lengths
index|[
name|uid
index|]
operator|+=
name|inner_length
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|!=
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|!=
name|CLOBBER
condition|)
block|{
name|insn_lengths
index|[
name|uid
index|]
operator|=
name|insn_default_length
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|varying_length
index|[
name|uid
index|]
operator|=
name|insn_variable_length_p
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* If needed, do any adjustment.  */
ifdef|#
directive|ifdef
name|ADJUST_INSN_LENGTH
name|ADJUST_INSN_LENGTH
argument_list|(
name|insn
argument_list|,
name|insn_lengths
index|[
name|uid
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Now loop over all the insns finding varying length insns.  For each,      get the current insn length.  If it has changed, reflect the change.      When nothing changes for a full pass, we are done.  */
while|while
condition|(
name|something_changed
condition|)
block|{
name|something_changed
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|insn_current_address
operator|=
name|FIRST_INSN_ADDRESS
operator|,
name|insn
operator|=
name|first
init|;
name|insn
operator|!=
literal|0
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|int
name|new_length
decl_stmt|;
name|int
name|tmp_length
decl_stmt|;
name|uid
operator|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|insn_addresses
index|[
name|uid
index|]
operator|=
name|insn_current_address
expr_stmt|;
if|if
condition|(
operator|!
name|varying_length
index|[
name|uid
index|]
condition|)
block|{
name|insn_current_address
operator|+=
name|insn_lengths
index|[
name|uid
index|]
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
condition|)
block|{
name|int
name|i
decl_stmt|;
name|body
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|new_length
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|inner_insn
init|=
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|int
name|inner_uid
init|=
name|INSN_UID
argument_list|(
name|inner_insn
argument_list|)
decl_stmt|;
name|int
name|inner_length
decl_stmt|;
name|insn_addresses
index|[
name|inner_uid
index|]
operator|=
name|insn_current_address
expr_stmt|;
comment|/* insn_current_length returns 0 for insns with a 		     non-varying length.  */
if|if
condition|(
operator|!
name|varying_length
index|[
name|inner_uid
index|]
condition|)
name|inner_length
operator|=
name|insn_lengths
index|[
name|inner_uid
index|]
expr_stmt|;
else|else
name|inner_length
operator|=
name|insn_current_length
argument_list|(
name|inner_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|inner_length
operator|!=
name|insn_lengths
index|[
name|inner_uid
index|]
condition|)
block|{
name|insn_lengths
index|[
name|inner_uid
index|]
operator|=
name|inner_length
expr_stmt|;
name|something_changed
operator|=
literal|1
expr_stmt|;
block|}
name|insn_current_address
operator|+=
name|insn_lengths
index|[
name|inner_uid
index|]
expr_stmt|;
name|new_length
operator|+=
name|inner_length
expr_stmt|;
block|}
block|}
else|else
block|{
name|new_length
operator|=
name|insn_current_length
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|insn_current_address
operator|+=
name|new_length
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SHORTEN_WITH_ADJUST_INSN_LENGTH
ifdef|#
directive|ifdef
name|ADJUST_INSN_LENGTH
comment|/* If needed, do any adjustment.  */
name|tmp_length
operator|=
name|new_length
expr_stmt|;
name|ADJUST_INSN_LENGTH
argument_list|(
name|insn
argument_list|,
name|new_length
argument_list|)
expr_stmt|;
name|insn_current_address
operator|+=
operator|(
name|new_length
operator|-
name|tmp_length
operator|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
name|new_length
operator|!=
name|insn_lengths
index|[
name|uid
index|]
condition|)
block|{
name|insn_lengths
index|[
name|uid
index|]
operator|=
name|new_length
expr_stmt|;
name|something_changed
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* For a non-optimizing compile, do only a single pass.  */
if|if
condition|(
operator|!
name|optimize
condition|)
break|break;
block|}
endif|#
directive|endif
comment|/* HAVE_ATTR_length */
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ATTR_length
end_ifdef

begin_comment
comment|/* Given the body of an INSN known to be generated by an ASM statement, return    the number of machine instructions likely to be generated for this insn.    This is used to compute its length.  */
end_comment

begin_function
specifier|static
name|int
name|asm_insn_count
parameter_list|(
name|body
parameter_list|)
name|rtx
name|body
decl_stmt|;
block|{
name|char
modifier|*
name|template
decl_stmt|;
name|int
name|count
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|ASM_INPUT
condition|)
name|template
operator|=
name|XSTR
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|template
operator|=
name|decode_asm_operands
argument_list|(
name|body
argument_list|,
name|NULL_PTR
argument_list|,
name|NULL_PTR
argument_list|,
name|NULL_PTR
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|*
name|template
condition|;
name|template
operator|++
control|)
if|if
condition|(
name|IS_ASM_LOGICAL_LINE_SEPARATOR
argument_list|(
operator|*
name|template
argument_list|)
operator|||
operator|*
name|template
operator|==
literal|'\n'
condition|)
name|count
operator|++
expr_stmt|;
return|return
name|count
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Output assembler code for the start of a function,    and initialize some of the variables in this file    for the new function.  The label for the function and associated    assembler pseudo-ops have already been output in `assemble_start_function'.     FIRST is the first insn of the rtl for the function being compiled.    FILE is the file to write assembler code to.    OPTIMIZE is nonzero if we should eliminate redundant      test and compare insns.  */
end_comment

begin_function
name|void
name|final_start_function
parameter_list|(
name|first
parameter_list|,
name|file
parameter_list|,
name|optimize
parameter_list|)
name|rtx
name|first
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|optimize
decl_stmt|;
block|{
name|block_depth
operator|=
literal|0
expr_stmt|;
name|this_is_asm_operands
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|NON_SAVING_SETJMP
comment|/* A function that calls setjmp should save and restore all the      call-saved registers on a system where longjmp clobbers them.  */
if|if
condition|(
name|NON_SAVING_SETJMP
operator|&&
name|current_function_calls_setjmp
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|call_used_regs
index|[
name|i
index|]
operator|&&
operator|!
name|call_fixed_regs
index|[
name|i
index|]
condition|)
name|regs_ever_live
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Initial line number is supposed to be output      before the function's prologue and label      so that the function's address will not appear to be      in the last statement of the preceding function.  */
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|first
argument_list|)
operator|!=
name|NOTE_INSN_DELETED
condition|)
name|last_linenum
operator|=
name|high_block_linenum
operator|=
name|high_function_linenum
operator|=
name|NOTE_LINE_NUMBER
argument_list|(
name|first
argument_list|)
expr_stmt|;
comment|/* For SDB and XCOFF, the function beginning must be marked between      the function label and the prologue.  We always need this, even when      -g1 was used.  Defer on MIPS systems so that parameter descriptions      follow function entry. */
if|#
directive|if
name|defined
argument_list|(
name|SDB_DEBUGGING_INFO
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|MIPS_DEBUGGING_INFO
argument_list|)
if|if
condition|(
name|write_symbols
operator|==
name|SDB_DEBUG
condition|)
name|sdbout_begin_function
argument_list|(
name|last_linenum
argument_list|)
expr_stmt|;
elseif|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|XCOFF_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|XCOFF_DEBUG
condition|)
name|xcoffout_begin_function
argument_list|(
name|file
argument_list|,
name|last_linenum
argument_list|)
expr_stmt|;
elseif|else
endif|#
directive|endif
comment|/* But only output line number for other debug info types if -g2 	 or better.  */
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|first
argument_list|)
operator|!=
name|NOTE_INSN_DELETED
condition|)
name|output_source_line
argument_list|(
name|file
argument_list|,
name|first
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LEAF_REG_REMAP
if|if
condition|(
name|leaf_function
condition|)
name|leaf_renumber_regs
argument_list|(
name|first
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|profile_block_flag
condition|)
name|add_bb
argument_list|(
name|file
argument_list|)
expr_stmt|;
comment|/* The Sun386i and perhaps other machines don't work right      if the profiling code comes after the prologue.  */
ifdef|#
directive|ifdef
name|PROFILE_BEFORE_PROLOGUE
if|if
condition|(
name|profile_flag
condition|)
name|profile_function
argument_list|(
name|file
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PROFILE_BEFORE_PROLOGUE */
ifdef|#
directive|ifdef
name|FUNCTION_PROLOGUE
comment|/* First output the function prologue: code to set up the stack frame.  */
name|FUNCTION_PROLOGUE
argument_list|(
name|file
argument_list|,
name|get_frame_size
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SDB_DEBUGGING_INFO
argument_list|)
operator|||
name|defined
argument_list|(
name|XCOFF_DEBUGGING_INFO
argument_list|)
if|if
condition|(
name|write_symbols
operator|==
name|SDB_DEBUG
operator|||
name|write_symbols
operator|==
name|XCOFF_DEBUG
condition|)
name|next_block_index
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* If the machine represents the prologue as RTL, the profiling code must      be emitted when NOTE_INSN_PROLOGUE_END is scanned.  */
ifdef|#
directive|ifdef
name|HAVE_prologue
if|if
condition|(
operator|!
name|HAVE_prologue
condition|)
endif|#
directive|endif
name|profile_after_prologue
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|profile_label_no
operator|++
expr_stmt|;
comment|/* If we are doing basic block profiling, remember a printable version      of the function name.  */
if|if
condition|(
name|profile_block_flag
condition|)
block|{
name|char
modifier|*
name|junk
init|=
literal|"function"
decl_stmt|;
name|bb_func_label_num
operator|=
name|add_bb_string
argument_list|(
call|(
modifier|*
name|decl_printable_name
call|)
argument_list|(
name|current_function_decl
argument_list|,
operator|&
name|junk
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|profile_after_prologue
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|FUNCTION_BLOCK_PROFILER
if|if
condition|(
name|profile_block_flag
condition|)
block|{
name|FUNCTION_BLOCK_PROFILER
argument_list|(
name|file
argument_list|,
name|profile_label_no
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* FUNCTION_BLOCK_PROFILER */
ifndef|#
directive|ifndef
name|PROFILE_BEFORE_PROLOGUE
if|if
condition|(
name|profile_flag
condition|)
name|profile_function
argument_list|(
name|file
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not PROFILE_BEFORE_PROLOGUE */
block|}
end_function

begin_function
specifier|static
name|void
name|profile_function
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|NO_PROFILE_DATA
name|int
name|align
init|=
name|MIN
argument_list|(
name|BIGGEST_ALIGNMENT
argument_list|,
name|POINTER_SIZE
argument_list|)
decl_stmt|;
endif|#
directive|endif
comment|/* not NO_PROFILE_DATA */
name|int
name|sval
init|=
name|current_function_returns_struct
decl_stmt|;
name|int
name|cxt
init|=
name|current_function_needs_context
decl_stmt|;
ifndef|#
directive|ifndef
name|NO_PROFILE_DATA
name|data_section
argument_list|()
expr_stmt|;
name|ASM_OUTPUT_ALIGN
argument_list|(
name|file
argument_list|,
name|floor_log2
argument_list|(
name|align
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|file
argument_list|,
literal|"LP"
argument_list|,
name|profile_label_no
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|const0_rtx
argument_list|,
name|POINTER_SIZE
operator|/
name|BITS_PER_UNIT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not NO_PROFILE_DATA */
name|text_section
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|STRUCT_VALUE_INCOMING_REGNUM
if|if
condition|(
name|sval
condition|)
name|ASM_OUTPUT_REG_PUSH
argument_list|(
name|file
argument_list|,
name|STRUCT_VALUE_INCOMING_REGNUM
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|STRUCT_VALUE_REGNUM
if|if
condition|(
name|sval
condition|)
name|ASM_OUTPUT_REG_PUSH
argument_list|(
name|file
argument_list|,
name|STRUCT_VALUE_REGNUM
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
if|#
directive|if
literal|0
ifdef|#
directive|ifdef
name|STATIC_CHAIN_INCOMING_REGNUM
block|if (cxt)     ASM_OUTPUT_REG_PUSH (file, STATIC_CHAIN_INCOMING_REGNUM);
else|#
directive|else
ifdef|#
directive|ifdef
name|STATIC_CHAIN_REGNUM
block|if (cxt)     ASM_OUTPUT_REG_PUSH (file, STATIC_CHAIN_REGNUM);
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
comment|/* 0 */
name|FUNCTION_PROFILER
argument_list|(
name|file
argument_list|,
name|profile_label_no
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
ifdef|#
directive|ifdef
name|STATIC_CHAIN_INCOMING_REGNUM
block|if (cxt)     ASM_OUTPUT_REG_POP (file, STATIC_CHAIN_INCOMING_REGNUM);
else|#
directive|else
ifdef|#
directive|ifdef
name|STATIC_CHAIN_REGNUM
block|if (cxt)     ASM_OUTPUT_REG_POP (file, STATIC_CHAIN_REGNUM);
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
comment|/* 0 */
ifdef|#
directive|ifdef
name|STRUCT_VALUE_INCOMING_REGNUM
if|if
condition|(
name|sval
condition|)
name|ASM_OUTPUT_REG_POP
argument_list|(
name|file
argument_list|,
name|STRUCT_VALUE_INCOMING_REGNUM
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|STRUCT_VALUE_REGNUM
if|if
condition|(
name|sval
condition|)
name|ASM_OUTPUT_REG_POP
argument_list|(
name|file
argument_list|,
name|STRUCT_VALUE_REGNUM
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Output assembler code for the end of a function.    For clarity, args are same as those of `final_start_function'    even though not all of them are needed.  */
end_comment

begin_function
name|void
name|final_end_function
parameter_list|(
name|first
parameter_list|,
name|file
parameter_list|,
name|optimize
parameter_list|)
name|rtx
name|first
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|optimize
decl_stmt|;
block|{
if|if
condition|(
name|app_on
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
name|ASM_APP_OFF
argument_list|)
expr_stmt|;
name|app_on
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SDB_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|SDB_DEBUG
condition|)
name|sdbout_end_function
argument_list|(
name|high_function_linenum
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DWARF_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|DWARF_DEBUG
condition|)
name|dwarfout_end_function
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|XCOFF_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|XCOFF_DEBUG
condition|)
name|xcoffout_end_function
argument_list|(
name|file
argument_list|,
name|high_function_linenum
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|FUNCTION_EPILOGUE
comment|/* Finally, output the function epilogue:      code to restore the stack frame and return to the caller.  */
name|FUNCTION_EPILOGUE
argument_list|(
name|file
argument_list|,
name|get_frame_size
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|profile_block_flag
condition|)
name|add_bb
argument_list|(
name|file
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SDB_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|SDB_DEBUG
condition|)
name|sdbout_end_epilogue
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DWARF_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|DWARF_DEBUG
condition|)
name|dwarfout_end_epilogue
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|XCOFF_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|XCOFF_DEBUG
condition|)
name|xcoffout_end_epilogue
argument_list|(
name|file
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bb_func_label_num
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* not in function, nuke label # */
comment|/* If FUNCTION_EPILOGUE is not defined, then the function body      itself contains return instructions wherever needed.  */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add a block to the linked list that remembers the current line/file/function    for basic block profiling.  Emit the label in front of the basic block and    the instructions that increment the count field.  */
end_comment

begin_function
specifier|static
name|void
name|add_bb
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|struct
name|bb_list
modifier|*
name|ptr
init|=
operator|(
expr|struct
name|bb_list
operator|*
operator|)
name|permalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|bb_list
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Add basic block to linked list.  */
name|ptr
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|ptr
operator|->
name|line_num
operator|=
name|last_linenum
expr_stmt|;
name|ptr
operator|->
name|file_label_num
operator|=
name|bb_file_label_num
expr_stmt|;
name|ptr
operator|->
name|func_label_num
operator|=
name|bb_func_label_num
expr_stmt|;
operator|*
name|bb_tail
operator|=
name|ptr
expr_stmt|;
name|bb_tail
operator|=
operator|&
name|ptr
operator|->
name|next
expr_stmt|;
comment|/* Enable the table of basic-block use counts      to point at the code it applies to.  */
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|file
argument_list|,
literal|"LPB"
argument_list|,
name|count_basic_blocks
argument_list|)
expr_stmt|;
comment|/* Before first insn of this basic block, increment the      count of times it was entered.  */
ifdef|#
directive|ifdef
name|BLOCK_PROFILER
name|BLOCK_PROFILER
argument_list|(
name|file
argument_list|,
name|count_basic_blocks
argument_list|)
expr_stmt|;
name|CC_STATUS_INIT
expr_stmt|;
endif|#
directive|endif
name|new_block
operator|=
literal|0
expr_stmt|;
name|count_basic_blocks
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a string to be used for basic block profiling.  */
end_comment

begin_function
specifier|static
name|int
name|add_bb_string
parameter_list|(
name|string
parameter_list|,
name|perm_p
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|perm_p
decl_stmt|;
block|{
name|int
name|len
decl_stmt|;
name|struct
name|bb_str
modifier|*
name|ptr
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|string
condition|)
block|{
name|string
operator|=
literal|"<unknown>"
expr_stmt|;
name|perm_p
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* Allocate a new string if the current string isn't permanent.  If      the string is permanent search for the same string in other      allocations.  */
name|len
operator|=
name|strlen
argument_list|(
name|string
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|perm_p
condition|)
block|{
name|char
modifier|*
name|p
init|=
operator|(
name|char
operator|*
operator|)
name|permalloc
argument_list|(
name|len
argument_list|)
decl_stmt|;
name|bcopy
argument_list|(
name|string
argument_list|,
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|string
operator|=
name|p
expr_stmt|;
block|}
else|else
for|for
control|(
name|ptr
operator|=
name|sbb_head
init|;
name|ptr
operator|!=
operator|(
expr|struct
name|bb_str
operator|*
operator|)
literal|0
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
if|if
condition|(
name|ptr
operator|->
name|string
operator|==
name|string
condition|)
break|break;
comment|/* Allocate a new string block if we need to.  */
if|if
condition|(
operator|!
name|ptr
condition|)
block|{
name|ptr
operator|=
operator|(
expr|struct
name|bb_str
operator|*
operator|)
name|permalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|ptr
operator|->
name|length
operator|=
name|len
expr_stmt|;
name|ptr
operator|->
name|label_num
operator|=
name|sbb_label_num
operator|++
expr_stmt|;
name|ptr
operator|->
name|string
operator|=
name|string
expr_stmt|;
operator|*
name|sbb_tail
operator|=
name|ptr
expr_stmt|;
name|sbb_tail
operator|=
operator|&
name|ptr
operator|->
name|next
expr_stmt|;
block|}
return|return
name|ptr
operator|->
name|label_num
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output assembler code for some insns: all or part of a function.    For description of args, see `final_start_function', above.     PRESCAN is 1 if we are not really outputting,      just scanning as if we were outputting.    Prescanning deletes and rearranges insns just like ordinary output.    PRESCAN is -2 if we are outputting after having prescanned.    In this case, don't try to delete or rearrange insns    because that has already been done.    Prescanning is done only on certain machines.  */
end_comment

begin_function
name|void
name|final
parameter_list|(
name|first
parameter_list|,
name|file
parameter_list|,
name|optimize
parameter_list|,
name|prescan
parameter_list|)
name|rtx
name|first
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|optimize
decl_stmt|;
name|int
name|prescan
decl_stmt|;
block|{
specifier|register
name|rtx
name|insn
decl_stmt|;
name|int
name|max_line
init|=
literal|0
decl_stmt|;
name|last_ignored_compare
operator|=
literal|0
expr_stmt|;
name|new_block
operator|=
literal|1
expr_stmt|;
comment|/* Make a map indicating which line numbers appear in this function.      When producing SDB debugging info, delete troublesome line number      notes from inlined functions in other files as well as duplicate      line number notes.  */
ifdef|#
directive|ifdef
name|SDB_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|SDB_DEBUG
condition|)
block|{
name|rtx
name|last
init|=
literal|0
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|first
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|RTX_INTEGRATED_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
argument_list|,
name|main_input_filename
argument_list|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|last
operator|!=
literal|0
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_LINE_NUMBER
argument_list|(
name|last
argument_list|)
operator|&&
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_SOURCE_FILE
argument_list|(
name|last
argument_list|)
operator|)
condition|)
block|{
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|last
operator|=
name|insn
expr_stmt|;
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|>
name|max_line
condition|)
name|max_line
operator|=
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
block|{
for|for
control|(
name|insn
operator|=
name|first
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|>
name|max_line
condition|)
name|max_line
operator|=
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
name|line_note_exists
operator|=
operator|(
name|char
operator|*
operator|)
name|oballoc
argument_list|(
name|max_line
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|line_note_exists
argument_list|,
name|max_line
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|first
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|>
literal|0
condition|)
name|line_note_exists
index|[
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
index|]
operator|=
literal|1
expr_stmt|;
name|init_recog
argument_list|()
expr_stmt|;
name|CC_STATUS_INIT
expr_stmt|;
comment|/* Output the insns.  */
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|first
argument_list|)
init|;
name|insn
condition|;
control|)
name|insn
operator|=
name|final_scan_insn
argument_list|(
name|insn
argument_list|,
name|file
argument_list|,
name|optimize
argument_list|,
name|prescan
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Do basic-block profiling here      if the last insn was a conditional branch.  */
if|if
condition|(
name|profile_block_flag
operator|&&
name|new_block
condition|)
name|add_bb
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The final scan for one insn, INSN.    Args are same as in `final', except that INSN    is the insn being scanned.    Value returned is the next insn to be scanned.     NOPEEPHOLES is the flag to disallow peephole processing (currently    used for within delayed branch sequence output).  */
end_comment

begin_function
name|rtx
name|final_scan_insn
parameter_list|(
name|insn
parameter_list|,
name|file
parameter_list|,
name|optimize
parameter_list|,
name|prescan
parameter_list|,
name|nopeepholes
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|optimize
decl_stmt|;
name|int
name|prescan
decl_stmt|;
name|int
name|nopeepholes
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|insn_counter
operator|++
expr_stmt|;
comment|/* Ignore deleted insns.  These can occur when we split insns (due to a      template of "#") while not optimizing.  */
if|if
condition|(
name|INSN_DELETED_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
return|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|NOTE
case|:
if|if
condition|(
name|prescan
operator|>
literal|0
condition|)
break|break;
comment|/* Align the beginning of a loop, for higher speed 	 on certain machines.  */
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
operator|&&
name|optimize
operator|>
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|ASM_OUTPUT_LOOP_ALIGN
name|rtx
name|next
init|=
name|next_nonnote_insn
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|next
operator|&&
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|CODE_LABEL
condition|)
block|{
name|ASM_OUTPUT_LOOP_ALIGN
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
block|}
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_END
condition|)
break|break;
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_PROLOGUE_END
condition|)
block|{
ifdef|#
directive|ifdef
name|FUNCTION_END_PROLOGUE
name|FUNCTION_END_PROLOGUE
argument_list|(
name|file
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|profile_after_prologue
argument_list|(
name|file
argument_list|)
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|FUNCTION_BEGIN_EPILOGUE
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_EPILOGUE_BEG
condition|)
block|{
name|FUNCTION_BEGIN_EPILOGUE
argument_list|(
name|file
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
if|if
condition|(
name|write_symbols
operator|==
name|NO_DEBUG
condition|)
break|break;
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_FUNCTION_BEG
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|SDB_DEBUGGING_INFO
argument_list|)
operator|&&
name|defined
argument_list|(
name|MIPS_DEBUGGING_INFO
argument_list|)
comment|/* MIPS stabs require the parameter descriptions to be after the 	     function entry point rather than before. */
if|if
condition|(
name|write_symbols
operator|==
name|SDB_DEBUG
condition|)
name|sdbout_begin_function
argument_list|(
name|last_linenum
argument_list|)
expr_stmt|;
elseif|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DWARF_DEBUGGING_INFO
comment|/* This outputs a marker where the function body starts, so it 	     must be after the prologue.  */
if|if
condition|(
name|write_symbols
operator|==
name|DWARF_DEBUG
condition|)
name|dwarfout_begin_function
argument_list|()
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_DELETED
condition|)
break|break;
comment|/* An insn that was "deleted" */
if|if
condition|(
name|app_on
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
name|ASM_APP_OFF
argument_list|)
expr_stmt|;
name|app_on
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_BLOCK_BEG
operator|&&
operator|(
name|debug_info_level
operator|==
name|DINFO_LEVEL_NORMAL
operator|||
name|debug_info_level
operator|==
name|DINFO_LEVEL_VERBOSE
ifdef|#
directive|ifdef
name|DWARF_DEBUGGING_INFO
operator|||
name|write_symbols
operator|==
name|DWARF_DEBUG
endif|#
directive|endif
operator|)
condition|)
block|{
comment|/* Beginning of a symbol-block.  Assign it a sequence number 	     and push the number onto the stack PENDING_BLOCKS.  */
if|if
condition|(
name|block_depth
operator|==
name|max_block_depth
condition|)
block|{
comment|/* PENDING_BLOCKS is full; make it longer.  */
name|max_block_depth
operator|*=
literal|2
expr_stmt|;
name|pending_blocks
operator|=
operator|(
name|int
operator|*
operator|)
name|xrealloc
argument_list|(
name|pending_blocks
argument_list|,
name|max_block_depth
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|pending_blocks
index|[
name|block_depth
operator|++
index|]
operator|=
name|next_block_index
expr_stmt|;
name|high_block_linenum
operator|=
name|last_linenum
expr_stmt|;
comment|/* Output debugging info about the symbol-block beginning.  */
ifdef|#
directive|ifdef
name|SDB_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|SDB_DEBUG
condition|)
name|sdbout_begin_block
argument_list|(
name|file
argument_list|,
name|last_linenum
argument_list|,
name|next_block_index
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|XCOFF_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|XCOFF_DEBUG
condition|)
name|xcoffout_begin_block
argument_list|(
name|file
argument_list|,
name|last_linenum
argument_list|,
name|next_block_index
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DBX_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|DBX_DEBUG
condition|)
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|file
argument_list|,
literal|"LBB"
argument_list|,
name|next_block_index
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DWARF_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|DWARF_DEBUG
operator|&&
name|block_depth
operator|>
literal|1
condition|)
name|dwarfout_begin_block
argument_list|(
name|next_block_index
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|next_block_index
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_BLOCK_END
operator|&&
operator|(
name|debug_info_level
operator|==
name|DINFO_LEVEL_NORMAL
operator|||
name|debug_info_level
operator|==
name|DINFO_LEVEL_VERBOSE
ifdef|#
directive|ifdef
name|DWARF_DEBUGGING_INFO
operator|||
name|write_symbols
operator|==
name|DWARF_DEBUG
endif|#
directive|endif
operator|)
condition|)
block|{
comment|/* End of a symbol-block.  Pop its sequence number off 	     PENDING_BLOCKS and output debugging info based on that.  */
operator|--
name|block_depth
expr_stmt|;
ifdef|#
directive|ifdef
name|XCOFF_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|XCOFF_DEBUG
operator|&&
name|block_depth
operator|>=
literal|0
condition|)
name|xcoffout_end_block
argument_list|(
name|file
argument_list|,
name|high_block_linenum
argument_list|,
name|pending_blocks
index|[
name|block_depth
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DBX_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|DBX_DEBUG
operator|&&
name|block_depth
operator|>=
literal|0
condition|)
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|file
argument_list|,
literal|"LBE"
argument_list|,
name|pending_blocks
index|[
name|block_depth
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SDB_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|SDB_DEBUG
operator|&&
name|block_depth
operator|>=
literal|0
condition|)
name|sdbout_end_block
argument_list|(
name|file
argument_list|,
name|high_block_linenum
argument_list|,
name|pending_blocks
index|[
name|block_depth
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DWARF_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|DWARF_DEBUG
operator|&&
name|block_depth
operator|>=
literal|1
condition|)
name|dwarfout_end_block
argument_list|(
name|pending_blocks
index|[
name|block_depth
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_DELETED_LABEL
operator|&&
operator|(
name|debug_info_level
operator|==
name|DINFO_LEVEL_NORMAL
operator|||
name|debug_info_level
operator|==
name|DINFO_LEVEL_VERBOSE
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DWARF_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|DWARF_DEBUG
condition|)
name|dwarfout_label
argument_list|(
name|insn
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|>
literal|0
condition|)
comment|/* This note is a line-number.  */
block|{
specifier|register
name|rtx
name|note
decl_stmt|;
if|#
directive|if
literal|0
comment|/* This is what we used to do.  */
block|output_source_line (file, insn);
endif|#
directive|endif
name|int
name|note_after
init|=
literal|0
decl_stmt|;
comment|/* If there is anything real after this note, 	     output it.  If another line note follows, omit this one.  */
for|for
control|(
name|note
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|NEXT_INSN
argument_list|(
name|note
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|note
argument_list|)
operator|!=
name|NOTE
operator|&&
name|GET_CODE
argument_list|(
name|note
argument_list|)
operator|!=
name|CODE_LABEL
condition|)
break|break;
comment|/* These types of notes can be significant 		 so make sure the preceding line number stays.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|note
argument_list|)
operator|==
name|NOTE
operator|&&
operator|(
name|NOTE_LINE_NUMBER
argument_list|(
name|note
argument_list|)
operator|==
name|NOTE_INSN_BLOCK_BEG
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|note
argument_list|)
operator|==
name|NOTE_INSN_BLOCK_END
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|note
argument_list|)
operator|==
name|NOTE_INSN_FUNCTION_BEG
operator|)
condition|)
break|break;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|note
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|note
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|/* Another line note follows; we can delete this note 		     if no intervening line numbers have notes elsewhere.  */
name|int
name|num
decl_stmt|;
for|for
control|(
name|num
operator|=
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|+
literal|1
init|;
name|num
operator|<
name|NOTE_LINE_NUMBER
argument_list|(
name|note
argument_list|)
condition|;
name|num
operator|++
control|)
if|if
condition|(
name|line_note_exists
index|[
name|num
index|]
condition|)
break|break;
if|if
condition|(
name|num
operator|>=
name|NOTE_LINE_NUMBER
argument_list|(
name|note
argument_list|)
condition|)
name|note_after
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
comment|/* Output this line note 	     if it is the first or the last line note in a row.  */
if|if
condition|(
operator|!
name|note_after
condition|)
name|output_source_line
argument_list|(
name|file
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|BARRIER
case|:
ifdef|#
directive|ifdef
name|ASM_OUTPUT_ALIGN_CODE
comment|/* Don't litter the assembler output with needless alignments.  A 	 BARRIER will be placed at the end of every function if HAVE_epilogue 	 is true.  */
if|if
condition|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
condition|)
name|ASM_OUTPUT_ALIGN_CODE
argument_list|(
name|file
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|CODE_LABEL
case|:
name|CC_STATUS_INIT
expr_stmt|;
if|if
condition|(
name|prescan
operator|>
literal|0
condition|)
break|break;
name|new_block
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|FINAL_PRESCAN_INSN
name|FINAL_PRESCAN_INSN
argument_list|(
name|insn
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SDB_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|SDB_DEBUG
operator|&&
name|LABEL_NAME
argument_list|(
name|insn
argument_list|)
condition|)
name|sdbout_label
argument_list|(
name|insn
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DWARF_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|DWARF_DEBUG
operator|&&
name|LABEL_NAME
argument_list|(
name|insn
argument_list|)
condition|)
name|dwarfout_label
argument_list|(
name|insn
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|app_on
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
name|ASM_APP_OFF
argument_list|)
expr_stmt|;
name|app_on
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
name|rtx
name|nextbody
init|=
name|PATTERN
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
decl_stmt|;
comment|/* If this label is followed by a jump-table, 	     make sure we put the label in the read-only section.  Also 	     possibly write the label and jump table together.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|nextbody
argument_list|)
operator|==
name|ADDR_VEC
operator|||
name|GET_CODE
argument_list|(
name|nextbody
argument_list|)
operator|==
name|ADDR_DIFF_VEC
condition|)
block|{
ifndef|#
directive|ifndef
name|JUMP_TABLES_IN_TEXT_SECTION
name|readonly_data_section
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|READONLY_DATA_SECTION
name|ASM_OUTPUT_ALIGN
argument_list|(
name|file
argument_list|,
name|exact_log2
argument_list|(
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* READONLY_DATA_SECTION */
else|#
directive|else
comment|/* JUMP_TABLES_IN_TEXT_SECTION */
name|function_section
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* JUMP_TABLES_IN_TEXT_SECTION */
ifdef|#
directive|ifdef
name|ASM_OUTPUT_CASE_LABEL
name|ASM_OUTPUT_CASE_LABEL
argument_list|(
name|file
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|insn
argument_list|)
argument_list|,
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|file
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
block|}
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|file
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
block|{
specifier|register
name|rtx
name|body
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|int
name|insn_code_number
decl_stmt|;
name|char
modifier|*
name|template
decl_stmt|;
name|rtx
name|note
decl_stmt|;
comment|/* An INSN, JUMP_INSN or CALL_INSN. 	   First check for special kinds that recog doesn't recognize.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|USE
comment|/* These are just declarations */
operator|||
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|CLOBBER
condition|)
break|break;
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* If there is a REG_CC_SETTER note on this insn, it means that 	   the setting of the condition code was done in the delay slot 	   of the insn that branched here.  So recover the cc status 	   from the insn that set it.  */
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_CC_SETTER
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|note
condition|)
block|{
name|NOTICE_UPDATE_CC
argument_list|(
name|PATTERN
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|cc_prev_status
operator|=
name|cc_status
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Detect insns that are really jump-tables 	   and output them as such.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|ADDR_VEC
operator|||
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|ADDR_DIFF_VEC
condition|)
block|{
specifier|register
name|int
name|vlen
decl_stmt|,
name|idx
decl_stmt|;
if|if
condition|(
name|prescan
operator|>
literal|0
condition|)
break|break;
if|if
condition|(
name|app_on
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
name|ASM_APP_OFF
argument_list|)
expr_stmt|;
name|app_on
operator|=
literal|0
expr_stmt|;
block|}
name|vlen
operator|=
name|XVECLEN
argument_list|(
name|body
argument_list|,
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|ADDR_DIFF_VEC
argument_list|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|vlen
condition|;
name|idx
operator|++
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|ADDR_VEC
condition|)
block|{
ifdef|#
directive|ifdef
name|ASM_OUTPUT_ADDR_VEC_ELT
name|ASM_OUTPUT_ADDR_VEC_ELT
argument_list|(
name|file
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|idx
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|ASM_OUTPUT_ADDR_DIFF_ELT
name|ASM_OUTPUT_ADDR_DIFF_ELT
argument_list|(
name|file
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|1
argument_list|,
name|idx
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
block|}
ifdef|#
directive|ifdef
name|ASM_OUTPUT_CASE_END
name|ASM_OUTPUT_CASE_END
argument_list|(
name|file
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|function_section
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Do basic-block profiling when we reach a new block. 	   Done here to avoid jump tables.  */
if|if
condition|(
name|profile_block_flag
operator|&&
name|new_block
condition|)
name|add_bb
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|ASM_INPUT
condition|)
block|{
comment|/* There's no telling what that did to the condition codes.  */
name|CC_STATUS_INIT
expr_stmt|;
if|if
condition|(
name|prescan
operator|>
literal|0
condition|)
break|break;
if|if
condition|(
operator|!
name|app_on
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
name|ASM_APP_ON
argument_list|)
expr_stmt|;
name|app_on
operator|=
literal|1
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s\n"
argument_list|,
name|XSTR
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Detect `asm' construct with operands.  */
if|if
condition|(
name|asm_noperands
argument_list|(
name|body
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|int
name|noperands
init|=
name|asm_noperands
argument_list|(
name|body
argument_list|)
decl_stmt|;
name|rtx
modifier|*
name|ops
init|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|noperands
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
comment|/* There's no telling what that did to the condition codes.  */
name|CC_STATUS_INIT
expr_stmt|;
if|if
condition|(
name|prescan
operator|>
literal|0
condition|)
break|break;
if|if
condition|(
operator|!
name|app_on
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
name|ASM_APP_ON
argument_list|)
expr_stmt|;
name|app_on
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Get out the operand values.  */
name|string
operator|=
name|decode_asm_operands
argument_list|(
name|body
argument_list|,
name|ops
argument_list|,
name|NULL_PTR
argument_list|,
name|NULL_PTR
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
comment|/* Inhibit aborts on what would otherwise be compiler bugs.  */
name|insn_noperands
operator|=
name|noperands
expr_stmt|;
name|this_is_asm_operands
operator|=
name|insn
expr_stmt|;
comment|/* Output the insn using them.  */
name|output_asm_insn
argument_list|(
name|string
argument_list|,
name|ops
argument_list|)
expr_stmt|;
name|this_is_asm_operands
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|prescan
operator|<=
literal|0
operator|&&
name|app_on
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
name|ASM_APP_OFF
argument_list|)
expr_stmt|;
name|app_on
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|SEQUENCE
condition|)
block|{
comment|/* A delayed-branch sequence */
specifier|register
name|int
name|i
decl_stmt|;
name|rtx
name|next
decl_stmt|;
if|if
condition|(
name|prescan
operator|>
literal|0
condition|)
break|break;
name|final_sequence
operator|=
name|body
expr_stmt|;
comment|/* The first insn in this SEQUENCE might be a JUMP_INSN that will 	       force the restoration of a comparison that was previously 	       thought unnecessary.  If that happens, cancel this sequence 	       and cause that insn to be restored.  */
name|next
operator|=
name|final_scan_insn
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|file
argument_list|,
literal|0
argument_list|,
name|prescan
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|!=
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|final_sequence
operator|=
literal|0
expr_stmt|;
return|return
name|next
return|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|insn
init|=
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|rtx
name|next
init|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* We loop in case any instruction in a delay slot gets 		   split.  */
do|do
name|insn
operator|=
name|final_scan_insn
argument_list|(
name|insn
argument_list|,
name|file
argument_list|,
literal|0
argument_list|,
name|prescan
argument_list|,
literal|1
argument_list|)
expr_stmt|;
do|while
condition|(
name|insn
operator|!=
name|next
condition|)
do|;
block|}
ifdef|#
directive|ifdef
name|DBR_OUTPUT_SEQEND
name|DBR_OUTPUT_SEQEND
argument_list|(
name|file
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|final_sequence
operator|=
literal|0
expr_stmt|;
comment|/* If the insn requiring the delay slot was a CALL_INSN, the 	       insns in the delay slot are actually executed before the 	       called function.  Hence we don't preserve any CC-setting 	       actions in these insns and the CC must be marked as being 	       clobbered by the function.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CALL_INSN
condition|)
name|CC_STATUS_INIT
expr_stmt|;
comment|/* Following a conditional branch sequence, we have a new basic 	       block.  */
if|if
condition|(
name|profile_block_flag
condition|)
block|{
name|rtx
name|insn
init|=
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|body
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
operator|!=
name|LABEL_REF
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|LABEL_REF
operator|)
condition|)
name|new_block
operator|=
literal|1
expr_stmt|;
block|}
break|break;
block|}
comment|/* We have a real machine instruction as rtl.  */
name|body
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* Check for redundant test and compare instructions 	   (when the condition codes are already set up as desired). 	   This is done only when optimizing; if not optimizing, 	   it should be possible for the user to alter a variable 	   with the debugger in between statements 	   and the next statement should reexamine the variable 	   to compute the condition codes.  */
if|if
condition|(
name|optimize
operator|&&
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|CC0
operator|&&
name|insn
operator|!=
name|last_ignored_compare
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|SUBREG
condition|)
name|SET_SRC
argument_list|(
name|body
argument_list|)
operator|=
name|alter_subreg
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|COMPARE
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SUBREG
condition|)
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|=
name|alter_subreg
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|SUBREG
condition|)
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|=
name|alter_subreg
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cc_status
operator|.
name|value1
operator|!=
literal|0
operator|&&
name|rtx_equal_p
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
name|cc_status
operator|.
name|value1
argument_list|)
operator|)
operator|||
operator|(
name|cc_status
operator|.
name|value2
operator|!=
literal|0
operator|&&
name|rtx_equal_p
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
name|cc_status
operator|.
name|value2
argument_list|)
operator|)
condition|)
block|{
comment|/* Don't delete insn if it has an addressing side-effect.  */
if|if
condition|(
operator|!
name|FIND_REG_INC_NOTE
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
comment|/* or if anything in it is volatile.  */
operator|&&
operator|!
name|volatile_refs_p
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
block|{
comment|/* We don't really delete the insn; just ignore it.  */
name|last_ignored_compare
operator|=
name|insn
expr_stmt|;
break|break;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* Following a conditional branch, we have a new basic block. 	   But if we are inside a sequence, the new block starts after the 	   last insn of the sequence.  */
if|if
condition|(
name|profile_block_flag
operator|&&
name|final_sequence
operator|==
literal|0
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
operator|!=
name|LABEL_REF
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|LABEL_REF
operator|)
operator|)
condition|)
name|new_block
operator|=
literal|1
expr_stmt|;
ifndef|#
directive|ifndef
name|STACK_REGS
comment|/* Don't bother outputting obvious no-ops, even without -O. 	   This optimization is fast and doesn't interfere with debugging. 	   Don't do this if the insn is in a delay slot, since this 	   will cause an improper number of delay insns to be written.  */
if|if
condition|(
name|final_sequence
operator|==
literal|0
operator|&&
name|prescan
operator|>=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
condition|)
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* If this is a conditional branch, maybe modify it 	   if the cc's are in a nonstandard state 	   so that it accomplishes the same thing that it would 	   do straightforwardly if the cc's were set up normally.  */
if|if
condition|(
name|cc_status
operator|.
name|flags
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|body
argument_list|)
operator|==
name|pc_rtx
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|IF_THEN_ELSE
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'<'
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|cc0_rtx
comment|/* This is done during prescan; it is not done again 	       in final scan when prescan has been done.  */
operator|&&
name|prescan
operator|>=
literal|0
condition|)
block|{
comment|/* This function may alter the contents of its argument 	       and clear some of the cc_status.flags bits. 	       It may also return 1 meaning condition now always true 	       or -1 meaning condition now always false 	       or 2 meaning condition nontrivial but altered.  */
specifier|register
name|int
name|result
init|=
name|alter_cond
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
comment|/* If condition now has fixed value, replace the IF_THEN_ELSE 	       with its then-operand or its else-operand.  */
if|if
condition|(
name|result
operator|==
literal|1
condition|)
name|SET_SRC
argument_list|(
name|body
argument_list|)
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
operator|-
literal|1
condition|)
name|SET_SRC
argument_list|(
name|body
argument_list|)
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* The jump is now either unconditional or a no-op. 	       If it has become a no-op, don't try to output it. 	       (It would not be recognized.)  */
if|if
condition|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
operator|==
name|pc_rtx
condition|)
block|{
name|PUT_CODE
argument_list|(
name|insn
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|RETURN
condition|)
comment|/* Replace (set (pc) (return)) with (return).  */
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|=
name|body
operator|=
name|SET_SRC
argument_list|(
name|body
argument_list|)
expr_stmt|;
comment|/* Rerecognize the instruction if it has changed.  */
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Make same adjustments to instructions that examine the 	   condition codes without jumping (if this machine has them).  */
if|if
condition|(
name|cc_status
operator|.
name|flags
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|SET
condition|)
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|GTU
case|:
case|case
name|GT
case|:
case|case
name|LTU
case|:
case|case
name|LT
case|:
case|case
name|GEU
case|:
case|case
name|GE
case|:
case|case
name|LEU
case|:
case|case
name|LE
case|:
case|case
name|EQ
case|:
case|case
name|NE
case|:
block|{
specifier|register
name|int
name|result
decl_stmt|;
if|if
condition|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|!=
name|cc0_rtx
condition|)
break|break;
name|result
operator|=
name|alter_cond
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
literal|1
condition|)
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
name|const_true_rtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|result
operator|==
operator|-
literal|1
condition|)
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|result
operator|==
literal|2
condition|)
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* Do machine-specific peephole optimizations if desired.  */
if|if
condition|(
name|optimize
operator|&&
operator|!
name|flag_no_peephole
operator|&&
operator|!
name|nopeepholes
condition|)
block|{
name|rtx
name|next
init|=
name|peephole
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* When peepholing, if there were notes within the peephole, 	       emit them before the peephole.  */
if|if
condition|(
name|next
operator|!=
literal|0
operator|&&
name|next
operator|!=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|rtx
name|prev
init|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|note
decl_stmt|;
for|for
control|(
name|note
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
init|;
name|note
operator|!=
name|next
condition|;
name|note
operator|=
name|NEXT_INSN
argument_list|(
name|note
argument_list|)
control|)
name|final_scan_insn
argument_list|(
name|note
argument_list|,
name|file
argument_list|,
name|optimize
argument_list|,
name|prescan
argument_list|,
name|nopeepholes
argument_list|)
expr_stmt|;
comment|/* In case this is prescan, put the notes 		   in proper position for later rescan.  */
name|note
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|PREV_INSN
argument_list|(
name|note
argument_list|)
operator|=
name|prev
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|prev
argument_list|)
operator|=
name|note
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|PREV_INSN
argument_list|(
name|next
argument_list|)
argument_list|)
operator|=
name|insn
expr_stmt|;
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|PREV_INSN
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|next
expr_stmt|;
name|PREV_INSN
argument_list|(
name|next
argument_list|)
operator|=
name|insn
expr_stmt|;
block|}
comment|/* PEEPHOLE might have changed this.  */
name|body
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* Try to recognize the instruction. 	   If successful, verify that the operands satisfy the 	   constraints for the instruction.  Crash if they don't, 	   since `reload' should have changed them so that they do.  */
name|insn_code_number
operator|=
name|recog_memoized
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|insn_extract
argument_list|(
name|insn
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|insn_n_operands
index|[
name|insn_code_number
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
operator|==
name|SUBREG
condition|)
name|recog_operand
index|[
name|i
index|]
operator|=
name|alter_subreg
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
operator|==
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
operator|==
name|MULT
condition|)
name|recog_operand
index|[
name|i
index|]
operator|=
name|walk_alter_subreg
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|insn_n_dups
index|[
name|insn_code_number
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
operator|*
name|recog_dup_loc
index|[
name|i
index|]
argument_list|)
operator|==
name|SUBREG
condition|)
operator|*
name|recog_dup_loc
index|[
name|i
index|]
operator|=
name|alter_subreg
argument_list|(
operator|*
name|recog_dup_loc
index|[
name|i
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
operator|*
name|recog_dup_loc
index|[
name|i
index|]
argument_list|)
operator|==
name|PLUS
operator|||
name|GET_CODE
argument_list|(
operator|*
name|recog_dup_loc
index|[
name|i
index|]
argument_list|)
operator|==
name|MULT
condition|)
operator|*
name|recog_dup_loc
index|[
name|i
index|]
operator|=
name|walk_alter_subreg
argument_list|(
operator|*
name|recog_dup_loc
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|REGISTER_CONSTRAINTS
if|if
condition|(
operator|!
name|constrain_operands
argument_list|(
name|insn_code_number
argument_list|,
literal|1
argument_list|)
condition|)
name|fatal_insn_not_found
argument_list|(
name|insn
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Some target machines need to prescan each insn before 	   it is output.  */
ifdef|#
directive|ifdef
name|FINAL_PRESCAN_INSN
name|FINAL_PRESCAN_INSN
argument_list|(
name|insn
argument_list|,
name|recog_operand
argument_list|,
name|insn_n_operands
index|[
name|insn_code_number
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_cc0
name|cc_prev_status
operator|=
name|cc_status
expr_stmt|;
comment|/* Update `cc_status' for this instruction. 	   The instruction's output routine may change it further. 	   If the output routine for a jump insn needs to depend 	   on the cc status, it should look at cc_prev_status.  */
name|NOTICE_UPDATE_CC
argument_list|(
name|body
argument_list|,
name|insn
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|debug_insn
operator|=
name|insn
expr_stmt|;
comment|/* If the proper template needs to be chosen by some C code, 	   run that code and get the real template.  */
name|template
operator|=
name|insn_template
index|[
name|insn_code_number
index|]
expr_stmt|;
if|if
condition|(
name|template
operator|==
literal|0
condition|)
block|{
name|template
operator|=
call|(
modifier|*
name|insn_outfun
index|[
name|insn_code_number
index|]
call|)
argument_list|(
name|recog_operand
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* If the C code returns 0, it means that it is a jump insn 	       which follows a deleted test insn, and that test insn 	       needs to be reinserted.  */
if|if
condition|(
name|template
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
operator|!=
name|last_ignored_compare
condition|)
name|abort
argument_list|()
expr_stmt|;
name|new_block
operator|=
literal|0
expr_stmt|;
return|return
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
return|;
block|}
block|}
comment|/* If the template is the string "#", it means that this insn must 	   be split.  */
if|if
condition|(
name|template
index|[
literal|0
index|]
operator|==
literal|'#'
operator|&&
name|template
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
name|rtx
name|new
init|=
name|try_split
argument_list|(
name|body
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* If we didn't split the insn, go away.  */
if|if
condition|(
name|new
operator|==
name|insn
operator|&&
name|PATTERN
argument_list|(
name|new
argument_list|)
operator|==
name|body
condition|)
name|abort
argument_list|()
expr_stmt|;
name|new_block
operator|=
literal|0
expr_stmt|;
return|return
name|new
return|;
block|}
if|if
condition|(
name|prescan
operator|>
literal|0
condition|)
break|break;
comment|/* Output assembler code from the template.  */
name|output_asm_insn
argument_list|(
name|template
argument_list|,
name|recog_operand
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* It's not at all clear why we did this and doing so interferes 	   with tests we'd like to do to use REG_WAS_0 notes, so let's try 	   with this out.  */
comment|/* Mark this insn as having been output.  */
block|INSN_DELETED_P (insn) = 1;
endif|#
directive|endif
name|debug_insn
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output debugging info to the assembler file FILE    based on the NOTE-insn INSN, assumed to be a line number.  */
end_comment

begin_function
specifier|static
name|void
name|output_source_line
parameter_list|(
name|file
parameter_list|,
name|insn
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|filename
init|=
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* Remember filename for basic block profiling.      Filenames are allocated on the permanent obstack      or are passed in ARGV, so we don't have to save      the string.  */
if|if
condition|(
name|profile_block_flag
operator|&&
name|last_filename
operator|!=
name|filename
condition|)
name|bb_file_label_num
operator|=
name|add_bb_string
argument_list|(
name|filename
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|last_filename
operator|=
name|filename
expr_stmt|;
name|last_linenum
operator|=
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|high_block_linenum
operator|=
name|MAX
argument_list|(
name|last_linenum
argument_list|,
name|high_block_linenum
argument_list|)
expr_stmt|;
name|high_function_linenum
operator|=
name|MAX
argument_list|(
name|last_linenum
argument_list|,
name|high_function_linenum
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_symbols
operator|!=
name|NO_DEBUG
condition|)
block|{
ifdef|#
directive|ifdef
name|SDB_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|SDB_DEBUG
if|#
directive|if
literal|0
comment|/* People like having line numbers even in wrong file!  */
comment|/* COFF can't handle multiple source files--lose, lose.  */
expr|&& !strcmp (filename, main_input_filename)
endif|#
directive|endif
comment|/* COFF relative line numbers must be positive.  */
operator|&&
name|last_linenum
operator|>
name|sdb_begin_function_line
condition|)
block|{
ifdef|#
directive|ifdef
name|ASM_OUTPUT_SOURCE_LINE
name|ASM_OUTPUT_SOURCE_LINE
argument_list|(
name|file
argument_list|,
name|last_linenum
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.ln\t%d\n"
argument_list|,
operator|(
operator|(
name|sdb_begin_function_line
operator|>
operator|-
literal|1
operator|)
condition|?
name|last_linenum
operator|-
name|sdb_begin_function_line
else|:
literal|1
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|DBX_DEBUGGING_INFO
argument_list|)
if|if
condition|(
name|write_symbols
operator|==
name|DBX_DEBUG
condition|)
name|dbxout_source_line
argument_list|(
name|file
argument_list|,
name|filename
argument_list|,
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|XCOFF_DEBUGGING_INFO
argument_list|)
if|if
condition|(
name|write_symbols
operator|==
name|XCOFF_DEBUG
condition|)
name|xcoffout_source_line
argument_list|(
name|file
argument_list|,
name|filename
argument_list|,
name|insn
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DWARF_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|DWARF_DEBUG
condition|)
name|dwarfout_line
argument_list|(
name|filename
argument_list|,
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If X is a SUBREG, replace it with a REG or a MEM,    based on the thing it is a subreg of.  */
end_comment

begin_function
name|rtx
name|alter_subreg
parameter_list|(
name|x
parameter_list|)
specifier|register
name|rtx
name|x
decl_stmt|;
block|{
specifier|register
name|rtx
name|y
init|=
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|SUBREG
condition|)
name|y
operator|=
name|alter_subreg
argument_list|(
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|REG
condition|)
block|{
comment|/* If the containing reg really gets a hard reg, so do we.  */
name|PUT_CODE
argument_list|(
name|x
argument_list|,
name|REG
argument_list|)
expr_stmt|;
name|REGNO
argument_list|(
name|x
argument_list|)
operator|=
name|REGNO
argument_list|(
name|y
argument_list|)
operator|+
name|SUBREG_WORD
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|MEM
condition|)
block|{
specifier|register
name|int
name|offset
init|=
name|SUBREG_WORD
argument_list|(
name|x
argument_list|)
operator|*
name|UNITS_PER_WORD
decl_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
name|offset
operator|-=
operator|(
name|MIN
argument_list|(
name|UNITS_PER_WORD
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|-
name|MIN
argument_list|(
name|UNITS_PER_WORD
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|y
argument_list|)
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|PUT_CODE
argument_list|(
name|x
argument_list|,
name|MEM
argument_list|)
expr_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
operator|=
name|MEM_VOLATILE_P
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Do alter_subreg on all the SUBREGs contained in X.  */
end_comment

begin_function
specifier|static
name|rtx
name|walk_alter_subreg
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|PLUS
case|:
case|case
name|MULT
case|:
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|walk_alter_subreg
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|=
name|walk_alter_subreg
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEM
case|:
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|walk_alter_subreg
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SUBREG
case|:
return|return
name|alter_subreg
argument_list|(
name|x
argument_list|)
return|;
block|}
return|return
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_cc0
end_ifdef

begin_comment
comment|/* Given BODY, the body of a jump instruction, alter the jump condition    as required by the bits that are set in cc_status.flags.    Not all of the bits there can be handled at this level in all cases.     The value is normally 0.    1 means that the condition has become always true.    -1 means that the condition has become always false.    2 means that COND has been altered.  */
end_comment

begin_function
specifier|static
name|int
name|alter_cond
parameter_list|(
name|cond
parameter_list|)
specifier|register
name|rtx
name|cond
decl_stmt|;
block|{
name|int
name|value
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|cc_status
operator|.
name|flags
operator|&
name|CC_REVERSED
condition|)
block|{
name|value
operator|=
literal|2
expr_stmt|;
name|PUT_CODE
argument_list|(
name|cond
argument_list|,
name|swap_condition
argument_list|(
name|GET_CODE
argument_list|(
name|cond
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cc_status
operator|.
name|flags
operator|&
name|CC_INVERTED
condition|)
block|{
name|value
operator|=
literal|2
expr_stmt|;
name|PUT_CODE
argument_list|(
name|cond
argument_list|,
name|reverse_condition
argument_list|(
name|GET_CODE
argument_list|(
name|cond
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cc_status
operator|.
name|flags
operator|&
name|CC_NOT_POSITIVE
condition|)
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|cond
argument_list|)
condition|)
block|{
case|case
name|LE
case|:
case|case
name|LEU
case|:
case|case
name|GEU
case|:
comment|/* Jump becomes unconditional.  */
return|return
literal|1
return|;
case|case
name|GT
case|:
case|case
name|GTU
case|:
case|case
name|LTU
case|:
comment|/* Jump becomes no-op.  */
return|return
operator|-
literal|1
return|;
case|case
name|GE
case|:
name|PUT_CODE
argument_list|(
name|cond
argument_list|,
name|EQ
argument_list|)
expr_stmt|;
name|value
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|LT
case|:
name|PUT_CODE
argument_list|(
name|cond
argument_list|,
name|NE
argument_list|)
expr_stmt|;
name|value
operator|=
literal|2
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cc_status
operator|.
name|flags
operator|&
name|CC_NOT_NEGATIVE
condition|)
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|cond
argument_list|)
condition|)
block|{
case|case
name|GE
case|:
case|case
name|GEU
case|:
comment|/* Jump becomes unconditional.  */
return|return
literal|1
return|;
case|case
name|LT
case|:
case|case
name|LTU
case|:
comment|/* Jump becomes no-op.  */
return|return
operator|-
literal|1
return|;
case|case
name|LE
case|:
case|case
name|LEU
case|:
name|PUT_CODE
argument_list|(
name|cond
argument_list|,
name|EQ
argument_list|)
expr_stmt|;
name|value
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|GT
case|:
case|case
name|GTU
case|:
name|PUT_CODE
argument_list|(
name|cond
argument_list|,
name|NE
argument_list|)
expr_stmt|;
name|value
operator|=
literal|2
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cc_status
operator|.
name|flags
operator|&
name|CC_NO_OVERFLOW
condition|)
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|cond
argument_list|)
condition|)
block|{
case|case
name|GEU
case|:
comment|/* Jump becomes unconditional.  */
return|return
literal|1
return|;
case|case
name|LEU
case|:
name|PUT_CODE
argument_list|(
name|cond
argument_list|,
name|EQ
argument_list|)
expr_stmt|;
name|value
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|GTU
case|:
name|PUT_CODE
argument_list|(
name|cond
argument_list|,
name|NE
argument_list|)
expr_stmt|;
name|value
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|LTU
case|:
comment|/* Jump becomes no-op.  */
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|cc_status
operator|.
name|flags
operator|&
operator|(
name|CC_Z_IN_NOT_N
operator||
name|CC_Z_IN_N
operator|)
condition|)
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|cond
argument_list|)
condition|)
block|{
case|case
name|LE
case|:
case|case
name|LEU
case|:
case|case
name|GE
case|:
case|case
name|GEU
case|:
case|case
name|LT
case|:
case|case
name|LTU
case|:
case|case
name|GT
case|:
case|case
name|GTU
case|:
name|abort
argument_list|()
expr_stmt|;
case|case
name|NE
case|:
name|PUT_CODE
argument_list|(
name|cond
argument_list|,
name|cc_status
operator|.
name|flags
operator|&
name|CC_Z_IN_N
condition|?
name|GE
else|:
name|LT
argument_list|)
expr_stmt|;
name|value
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|EQ
case|:
name|PUT_CODE
argument_list|(
name|cond
argument_list|,
name|cc_status
operator|.
name|flags
operator|&
name|CC_Z_IN_N
condition|?
name|LT
else|:
name|GE
argument_list|)
expr_stmt|;
name|value
operator|=
literal|2
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cc_status
operator|.
name|flags
operator|&
name|CC_NOT_SIGNED
condition|)
comment|/* The flags are valid if signed condition operators are converted        to unsigned.  */
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|cond
argument_list|)
condition|)
block|{
case|case
name|LE
case|:
name|PUT_CODE
argument_list|(
name|cond
argument_list|,
name|LEU
argument_list|)
expr_stmt|;
name|value
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|LT
case|:
name|PUT_CODE
argument_list|(
name|cond
argument_list|,
name|LTU
argument_list|)
expr_stmt|;
name|value
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|GT
case|:
name|PUT_CODE
argument_list|(
name|cond
argument_list|,
name|GTU
argument_list|)
expr_stmt|;
name|value
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|GE
case|:
name|PUT_CODE
argument_list|(
name|cond
argument_list|,
name|GEU
argument_list|)
expr_stmt|;
name|value
operator|=
literal|2
expr_stmt|;
break|break;
block|}
return|return
name|value
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Report inconsistency between the assembler template and the operands.    In an `asm', it's the user's fault; otherwise, the compiler's fault.  */
end_comment

begin_function
name|void
name|output_operand_lossage
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
if|if
condition|(
name|this_is_asm_operands
condition|)
name|error_for_asm
argument_list|(
name|this_is_asm_operands
argument_list|,
literal|"invalid `asm': %s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output of assembler code from a template, and its subroutines.  */
end_comment

begin_comment
comment|/* Output text from TEMPLATE to the assembler output file,    obeying %-directions to substitute operands taken from    the vector OPERANDS.     %N (for N a digit) means print operand N in usual manner.    %lN means require operand N to be a CODE_LABEL or LABEL_REF       and print the label name with no punctuation.    %cN means require operand N to be a constant       and print the constant expression with no punctuation.    %aN means expect operand N to be a memory address       (not a memory reference!) and print a reference       to that address.    %nN means expect operand N to be a constant       and print a constant expression for minus the value       of the operand, with no other punctuation.  */
end_comment

begin_function
specifier|static
name|void
name|output_asm_name
parameter_list|()
block|{
if|if
condition|(
name|flag_print_asm_name
condition|)
block|{
comment|/* Annotate the assembly with a comment describing the pattern and 	 alternative used.  */
if|if
condition|(
name|debug_insn
condition|)
block|{
specifier|register
name|int
name|num
init|=
name|INSN_CODE
argument_list|(
name|debug_insn
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|" %s %d %s"
argument_list|,
name|ASM_COMMENT_START
argument_list|,
name|INSN_UID
argument_list|(
name|debug_insn
argument_list|)
argument_list|,
name|insn_name
index|[
name|num
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn_n_alternatives
index|[
name|num
index|]
operator|>
literal|1
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"/%d"
argument_list|,
name|which_alternative
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Clear this so only the first assembler insn 	     of any rtl insn will get the special comment for -dp.  */
name|debug_insn
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|output_asm_insn
parameter_list|(
name|template
parameter_list|,
name|operands
parameter_list|)
name|char
modifier|*
name|template
decl_stmt|;
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|,
name|i
decl_stmt|;
comment|/* An insn may return a null string template      in a case where no assembler code is needed.  */
if|if
condition|(
operator|*
name|template
operator|==
literal|0
condition|)
return|return;
name|p
operator|=
name|template
expr_stmt|;
name|putc
argument_list|(
literal|'\t'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ASM_OUTPUT_OPCODE
name|ASM_OUTPUT_OPCODE
argument_list|(
name|asm_out_file
argument_list|,
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|c
operator|=
operator|*
name|p
operator|++
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
name|output_asm_name
argument_list|()
expr_stmt|;
name|putc
argument_list|(
name|c
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ASM_OUTPUT_OPCODE
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|)
operator|==
literal|'\t'
condition|)
block|{
name|putc
argument_list|(
name|c
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
name|ASM_OUTPUT_OPCODE
argument_list|(
name|asm_out_file
argument_list|,
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
ifdef|#
directive|ifdef
name|ASSEMBLER_DIALECT
case|case
literal|'{'
case|:
comment|/* If we want the first dialect, do nothing.  Otherwise, skip 	   DIALECT_NUMBER of strings ending with '|'.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dialect_number
condition|;
name|i
operator|++
control|)
block|{
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|++
operator|!=
literal|'|'
condition|)
empty_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'|'
condition|)
name|p
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'|'
case|:
comment|/* Skip to close brace.  */
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|++
operator|!=
literal|'}'
condition|)
empty_stmt|;
break|break;
case|case
literal|'}'
case|:
break|break;
endif|#
directive|endif
case|case
literal|'%'
case|:
comment|/* %% outputs a single %.  */
if|if
condition|(
operator|*
name|p
operator|==
literal|'%'
condition|)
block|{
name|p
operator|++
expr_stmt|;
name|putc
argument_list|(
name|c
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
comment|/* %= outputs a number which is unique to each insn in the entire 	   compilation.  This is useful for making local labels that are 	   referred to more than once in a given insn.  */
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'='
condition|)
block|{
name|p
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"%d"
argument_list|,
name|insn_counter
argument_list|)
expr_stmt|;
block|}
comment|/* % followed by a letter and some digits 	   outputs an operand in a special way depending on the letter. 	   Letters `acln' are implemented directly. 	   Other letters are passed to `output_operand' so that 	   the PRINT_OPERAND macro can define them.  */
elseif|else
if|if
condition|(
operator|(
operator|*
name|p
operator|>=
literal|'a'
operator|&&
operator|*
name|p
operator|<=
literal|'z'
operator|)
operator|||
operator|(
operator|*
name|p
operator|>=
literal|'A'
operator|&&
operator|*
name|p
operator|<=
literal|'Z'
operator|)
condition|)
block|{
name|int
name|letter
init|=
operator|*
name|p
operator|++
decl_stmt|;
name|c
operator|=
name|atoi
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|p
operator|>=
literal|'0'
operator|&&
operator|*
name|p
operator|<=
literal|'9'
operator|)
condition|)
name|output_operand_lossage
argument_list|(
literal|"operand number missing after %-letter"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|this_is_asm_operands
operator|&&
name|c
operator|>=
operator|(
name|unsigned
operator|)
name|insn_noperands
condition|)
name|output_operand_lossage
argument_list|(
literal|"operand number out of range"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|letter
operator|==
literal|'l'
condition|)
name|output_asm_label
argument_list|(
name|operands
index|[
name|c
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|letter
operator|==
literal|'a'
condition|)
name|output_address
argument_list|(
name|operands
index|[
name|c
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|letter
operator|==
literal|'c'
condition|)
block|{
if|if
condition|(
name|CONSTANT_ADDRESS_P
argument_list|(
name|operands
index|[
name|c
index|]
argument_list|)
condition|)
name|output_addr_const
argument_list|(
name|asm_out_file
argument_list|,
name|operands
index|[
name|c
index|]
argument_list|)
expr_stmt|;
else|else
name|output_operand
argument_list|(
name|operands
index|[
name|c
index|]
argument_list|,
literal|'c'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|letter
operator|==
literal|'n'
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
name|c
index|]
argument_list|)
operator|==
name|CONST_INT
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
name|HOST_BITS_PER_INT
literal|"%d"
argument_list|,
else|#
directive|else
literal|"%ld"
argument_list|,
endif|#
directive|endif
operator|-
name|INTVAL
argument_list|(
name|operands
index|[
name|c
index|]
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|putc
argument_list|(
literal|'-'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|asm_out_file
argument_list|,
name|operands
index|[
name|c
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|output_operand
argument_list|(
name|operands
index|[
name|c
index|]
argument_list|,
name|letter
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|)
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
name|p
operator|++
expr_stmt|;
block|}
comment|/* % followed by a digit outputs an operand the default way.  */
elseif|else
if|if
condition|(
operator|*
name|p
operator|>=
literal|'0'
operator|&&
operator|*
name|p
operator|<=
literal|'9'
condition|)
block|{
name|c
operator|=
name|atoi
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_is_asm_operands
operator|&&
name|c
operator|>=
operator|(
name|unsigned
operator|)
name|insn_noperands
condition|)
name|output_operand_lossage
argument_list|(
literal|"operand number out of range"
argument_list|)
expr_stmt|;
else|else
name|output_operand
argument_list|(
name|operands
index|[
name|c
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|)
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
name|p
operator|++
expr_stmt|;
block|}
comment|/* % followed by punctuation: output something for that 	   punctuation character alone, with no operand. 	   The PRINT_OPERAND macro decides what is actually done.  */
ifdef|#
directive|ifdef
name|PRINT_OPERAND_PUNCT_VALID_P
elseif|else
if|if
condition|(
name|PRINT_OPERAND_PUNCT_VALID_P
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|output_operand
argument_list|(
name|NULL_RTX
argument_list|,
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|else
name|output_operand_lossage
argument_list|(
literal|"invalid %%-code"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|putc
argument_list|(
name|c
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
name|output_asm_name
argument_list|()
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output a LABEL_REF, or a bare CODE_LABEL, as an assembler symbol.  */
end_comment

begin_function
name|void
name|output_asm_label
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LABEL_REF
condition|)
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|output_operand_lossage
argument_list|(
literal|"`%l' operand isn't a label"
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|asm_out_file
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print operand X using machine-dependent assembler syntax.    The macro PRINT_OPERAND is defined just to control this function.    CODE is a non-digit that preceded the operand-number in the % spec,    such as 'z' if the spec was `%z3'.  CODE is 0 if there was no char    between the % and the digits.    When CODE is a non-letter, X is 0.     The meanings of the letters are machine-dependent and controlled    by PRINT_OPERAND.  */
end_comment

begin_function
specifier|static
name|void
name|output_operand
parameter_list|(
name|x
parameter_list|,
name|code
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|int
name|code
decl_stmt|;
block|{
if|if
condition|(
name|x
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
condition|)
name|x
operator|=
name|alter_subreg
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* If X is a pseudo-register, abort now rather than writing trash to the      assembler file.  */
if|if
condition|(
name|x
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|abort
argument_list|()
expr_stmt|;
name|PRINT_OPERAND
argument_list|(
name|asm_out_file
argument_list|,
name|x
argument_list|,
name|code
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print a memory reference operand for address X    using machine-dependent assembler syntax.    The macro PRINT_OPERAND_ADDRESS exists just to control this function.  */
end_comment

begin_function
name|void
name|output_address
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|walk_alter_subreg
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|PRINT_OPERAND_ADDRESS
argument_list|(
name|asm_out_file
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print an integer constant expression in assembler syntax.    Addition and subtraction are the only arithmetic    that may appear in these expressions.  */
end_comment

begin_function
name|void
name|output_addr_const
parameter_list|(
name|file
parameter_list|,
name|x
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|restart
label|:
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|PC
case|:
if|if
condition|(
name|flag_pic
condition|)
name|putc
argument_list|(
literal|'.'
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
break|break;
case|case
name|SYMBOL_REF
case|:
name|assemble_name
argument_list|(
name|file
argument_list|,
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LABEL_REF
case|:
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|CODE_LABEL
case|:
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST_INT
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
name|HOST_BITS_PER_INT
literal|"%d"
argument_list|,
else|#
directive|else
literal|"%ld"
argument_list|,
endif|#
directive|endif
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST
case|:
comment|/* This used to output parentheses around the expression, 	 but that does not work on the 386 (either ATT or BSD assembler).  */
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST_DOUBLE
case|:
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|VOIDmode
condition|)
block|{
comment|/* We can use %d if the number is one word and positive.  */
if|if
condition|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|64
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|!=
name|HOST_BITS_PER_INT
literal|"0x%lx%016lx"
argument_list|,
else|#
directive|else
literal|"0x%x%016x"
argument_list|,
endif|#
directive|endif
else|#
directive|else
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|!=
name|HOST_BITS_PER_INT
literal|"0x%lx%08lx"
argument_list|,
else|#
directive|else
literal|"0x%x%08x"
argument_list|,
endif|#
directive|endif
endif|#
directive|endif
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
argument_list|,
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
name|HOST_BITS_PER_INT
literal|"0x%x"
argument_list|,
else|#
directive|else
literal|"0x%lx"
argument_list|,
endif|#
directive|endif
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
name|HOST_BITS_PER_INT
literal|"%d"
argument_list|,
else|#
directive|else
literal|"%ld"
argument_list|,
endif|#
directive|endif
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* We can't handle floating point constants; 	   PRINT_OPERAND must handle them.  */
name|output_operand_lossage
argument_list|(
literal|"floating constant misused"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PLUS
case|:
comment|/* Some assemblers need integer constants to appear last (eg masm).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"+"
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"+"
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|MINUS
case|:
comment|/* Avoid outputting things like x-x or x+5-x, 	 since some assemblers can't handle that.  */
name|x
operator|=
name|simplify_subtraction
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MINUS
condition|)
goto|goto
name|restart
goto|;
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
name|ASM_OPEN_PAREN
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|ASM_CLOSE_PAREN
argument_list|)
expr_stmt|;
block|}
else|else
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZERO_EXTEND
case|:
case|case
name|SIGN_EXTEND
case|:
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|output_operand_lossage
argument_list|(
literal|"invalid expression as operand"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A poor man's fprintf, with the added features of %I, %R, %L, and %U.    %R prints the value of REGISTER_PREFIX.    %L prints the value of LOCAL_LABEL_PREFIX.    %U prints the value of USER_LABEL_PREFIX.    %I prints the value of IMMEDIATE_PREFIX.    %O runs ASM_OUTPUT_OPCODE to transform what follows in the string.    Also supported are %d, %x, %s, %e, %f, %g and %%.     We handle alternate assembler dialects here, just like output_asm_insn.  */
end_comment

begin_decl_stmt
name|void
name|asm_fprintf
name|VPROTO
argument_list|(
operator|(
name|FILE
operator|*
name|file
operator|,
name|char
operator|*
name|p
operator|,
operator|...
operator|)
argument_list|)
block|{
ifndef|#
directive|ifndef
name|__STDC__
name|FILE
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
endif|#
directive|endif
name|va_list
name|argptr
decl_stmt|;
name|char
name|buf
index|[
literal|10
index|]
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|,
name|c
decl_stmt|;
name|int
name|i
decl_stmt|;
name|VA_START
argument_list|(
name|argptr
argument_list|,
name|p
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|__STDC__
name|file
operator|=
name|va_arg
argument_list|(
name|argptr
argument_list|,
name|FILE
operator|*
argument_list|)
expr_stmt|;
name|p
operator|=
name|va_arg
argument_list|(
name|argptr
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|buf
index|[
literal|0
index|]
operator|=
literal|'%'
expr_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|p
operator|++
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
ifdef|#
directive|ifdef
name|ASSEMBLER_DIALECT
case|case
literal|'{'
case|:
comment|/* If we want the first dialect, do nothing.  Otherwise, skip 	   DIALECT_NUMBER of strings ending with '|'.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dialect_number
condition|;
name|i
operator|++
control|)
block|{
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|++
operator|!=
literal|'|'
condition|)
empty_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'|'
condition|)
name|p
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'|'
case|:
comment|/* Skip to close brace.  */
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|++
operator|!=
literal|'}'
condition|)
empty_stmt|;
break|break;
case|case
literal|'}'
case|:
break|break;
endif|#
directive|endif
case|case
literal|'%'
case|:
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|q
operator|=
operator|&
name|buf
index|[
literal|1
index|]
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
operator|)
operator|||
name|c
operator|==
literal|'.'
condition|)
block|{
operator|*
name|q
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'%'
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%%"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'i'
case|:
case|case
literal|'u'
case|:
case|case
literal|'x'
case|:
case|case
literal|'p'
case|:
case|case
literal|'X'
case|:
case|case
literal|'o'
case|:
operator|*
name|q
operator|++
operator|=
name|c
expr_stmt|;
operator|*
name|q
operator|=
literal|0
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|buf
argument_list|,
name|va_arg
argument_list|(
name|argptr
argument_list|,
name|int
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
comment|/* This is a prefix to the 'd', 'i', 'u', 'x', 'p', and 'X' cases, 	       but we do not check for those cases.  It means that the value 	       is a HOST_WIDE_INT, which may be either `int' or `long'.  */
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|!=
name|HOST_BITS_PER_INT
operator|*
name|q
operator|++
operator|=
literal|'l'
expr_stmt|;
endif|#
directive|endif
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|q
operator|=
literal|0
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|buf
argument_list|,
name|va_arg
argument_list|(
name|argptr
argument_list|,
name|HOST_WIDE_INT
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
operator|*
name|q
operator|++
operator|=
name|c
expr_stmt|;
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|q
operator|=
literal|0
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|buf
argument_list|,
name|va_arg
argument_list|(
name|argptr
argument_list|,
name|long
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
case|case
literal|'f'
case|:
case|case
literal|'g'
case|:
operator|*
name|q
operator|++
operator|=
name|c
expr_stmt|;
operator|*
name|q
operator|=
literal|0
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|buf
argument_list|,
name|va_arg
argument_list|(
name|argptr
argument_list|,
name|double
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
operator|*
name|q
operator|++
operator|=
name|c
expr_stmt|;
operator|*
name|q
operator|=
literal|0
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|buf
argument_list|,
name|va_arg
argument_list|(
name|argptr
argument_list|,
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
ifdef|#
directive|ifdef
name|ASM_OUTPUT_OPCODE
name|ASM_OUTPUT_OPCODE
argument_list|(
name|asm_out_file
argument_list|,
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'R'
case|:
ifdef|#
directive|ifdef
name|REGISTER_PREFIX
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|REGISTER_PREFIX
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'I'
case|:
ifdef|#
directive|ifdef
name|IMMEDIATE_PREFIX
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|IMMEDIATE_PREFIX
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'L'
case|:
ifdef|#
directive|ifdef
name|LOCAL_LABEL_PREFIX
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|LOCAL_LABEL_PREFIX
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'U'
case|:
ifdef|#
directive|ifdef
name|USER_LABEL_PREFIX
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|USER_LABEL_PREFIX
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
default|default:
name|fputc
argument_list|(
name|c
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Split up a CONST_DOUBLE or integer constant rtx    into two rtx's for single words,    storing in *FIRST the word that comes first in memory in the target    and in *SECOND the other.  */
end_comment

begin_function
name|void
name|split_double
parameter_list|(
name|value
parameter_list|,
name|first
parameter_list|,
name|second
parameter_list|)
name|rtx
name|value
decl_stmt|;
name|rtx
modifier|*
name|first
decl_stmt|,
decl|*
name|second
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|HOST_BITS_PER_WIDE_INT
operator|>=
operator|(
literal|2
operator|*
name|BITS_PER_WORD
operator|)
condition|)
block|{
comment|/* In this case the CONST_INT holds both target words. 	     Extract the bits from it into two word-sized pieces.  */
name|rtx
name|low
decl_stmt|,
name|high
decl_stmt|;
name|HOST_WIDE_INT
name|word_mask
decl_stmt|;
comment|/* Avoid warnings for shift count>= BITS_PER_WORD.  */
name|int
name|shift_count
init|=
name|BITS_PER_WORD
operator|-
literal|1
decl_stmt|;
name|word_mask
operator|=
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|shift_count
expr_stmt|;
name|word_mask
operator||=
name|word_mask
operator|-
literal|1
expr_stmt|;
name|low
operator|=
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|value
argument_list|)
operator|&
name|word_mask
argument_list|)
expr_stmt|;
name|high
operator|=
name|GEN_INT
argument_list|(
operator|(
name|INTVAL
argument_list|(
name|value
argument_list|)
operator|>>
operator|(
name|shift_count
operator|+
literal|1
operator|)
operator|)
operator|&
name|word_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
block|{
operator|*
name|first
operator|=
name|high
expr_stmt|;
operator|*
name|second
operator|=
name|low
expr_stmt|;
block|}
else|else
block|{
operator|*
name|first
operator|=
name|low
expr_stmt|;
operator|*
name|second
operator|=
name|high
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* The rule for using CONST_INT for a wider mode 	     is that we regard the value as signed. 	     So sign-extend it.  */
name|rtx
name|high
init|=
operator|(
name|INTVAL
argument_list|(
name|value
argument_list|)
operator|<
literal|0
condition|?
name|constm1_rtx
else|:
name|const0_rtx
operator|)
decl_stmt|;
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
block|{
operator|*
name|first
operator|=
name|high
expr_stmt|;
operator|*
name|second
operator|=
name|value
expr_stmt|;
block|}
else|else
block|{
operator|*
name|first
operator|=
name|value
expr_stmt|;
operator|*
name|second
operator|=
name|high
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|!=
name|CONST_DOUBLE
condition|)
block|{
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
block|{
operator|*
name|first
operator|=
name|const0_rtx
expr_stmt|;
operator|*
name|second
operator|=
name|value
expr_stmt|;
block|}
else|else
block|{
operator|*
name|first
operator|=
name|value
expr_stmt|;
operator|*
name|second
operator|=
name|const0_rtx
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
operator|==
name|VOIDmode
comment|/* This is the old way we did CONST_DOUBLE integers.  */
operator|||
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|MODE_INT
condition|)
block|{
comment|/* In an integer, the words are defined as most and least significant. 	 So order them by the target's convention.  */
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
block|{
operator|*
name|first
operator|=
name|GEN_INT
argument_list|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|second
operator|=
name|GEN_INT
argument_list|(
name|CONST_DOUBLE_LOW
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|first
operator|=
name|GEN_INT
argument_list|(
name|CONST_DOUBLE_LOW
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|second
operator|=
name|GEN_INT
argument_list|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|REAL_ARITHMETIC
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|long
name|l
index|[
literal|2
index|]
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|r
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|/* Note, this converts the REAL_VALUE_TYPE to the target's 	 format, splits up the floating point double and outputs 	 exactly 32 bits of it into each of l[0] and l[1] -- 	 not necessarily BITS_PER_WORD bits. */
name|REAL_VALUE_TO_TARGET_DOUBLE
argument_list|(
name|r
argument_list|,
name|l
argument_list|)
expr_stmt|;
operator|*
name|first
operator|=
name|GEN_INT
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|)
name|l
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
operator|*
name|second
operator|=
name|GEN_INT
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|)
name|l
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|(
name|HOST_FLOAT_FORMAT
operator|!=
name|TARGET_FLOAT_FORMAT
operator|||
name|HOST_BITS_PER_WIDE_INT
operator|!=
name|BITS_PER_WORD
operator|)
operator|&&
operator|!
name|flag_pretend_float
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
ifdef|#
directive|ifdef
name|HOST_WORDS_BIG_ENDIAN
name|WORDS_BIG_ENDIAN
else|#
directive|else
operator|!
name|WORDS_BIG_ENDIAN
endif|#
directive|endif
condition|)
block|{
comment|/* Host and target agree => no need to swap.  */
operator|*
name|first
operator|=
name|GEN_INT
argument_list|(
name|CONST_DOUBLE_LOW
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|second
operator|=
name|GEN_INT
argument_list|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|second
operator|=
name|GEN_INT
argument_list|(
name|CONST_DOUBLE_LOW
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|first
operator|=
name|GEN_INT
argument_list|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* no REAL_ARITHMETIC */
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if this function has no function calls.  */
end_comment

begin_function
name|int
name|leaf_function_p
parameter_list|()
block|{
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
name|profile_flag
operator|||
name|profile_block_flag
condition|)
return|return
literal|0
return|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CALL_INSN
condition|)
return|return
literal|0
return|;
block|}
for|for
control|(
name|insn
operator|=
name|current_function_epilogue_delay_list
init|;
name|insn
condition|;
name|insn
operator|=
name|XEXP
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CALL_INSN
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|XEXP
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|XEXP
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CALL_INSN
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* On some machines, a function with no call insns    can run faster if it doesn't create its own register window.    When output, the leaf function should use only the "output"    registers.  Ordinarily, the function would be compiled to use    the "input" registers to find its arguments; it is a candidate    for leaf treatment if it uses only the "input" registers.    Leaf function treatment means renumbering so the function    uses the "output" registers instead.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|LEAF_REGISTERS
end_ifdef

begin_decl_stmt
specifier|static
name|char
name|permitted_reg_in_leaf_functions
index|[]
init|=
name|LEAF_REGISTERS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return 1 if this function uses only the registers that can be    safely renumbered.  */
end_comment

begin_function
name|int
name|only_leaf_regs_used
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|regs_ever_live
index|[
name|i
index|]
operator|||
name|global_regs
index|[
name|i
index|]
operator|)
operator|&&
operator|!
name|permitted_reg_in_leaf_functions
index|[
name|i
index|]
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Scan all instructions and renumber all registers into those    available in leaf functions.  */
end_comment

begin_function
specifier|static
name|void
name|leaf_renumber_regs
parameter_list|(
name|first
parameter_list|)
name|rtx
name|first
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
comment|/* Renumber only the actual patterns.      The reg-notes can contain frame pointer refs,      and renumbering them could crash, and should not be needed.  */
for|for
control|(
name|insn
operator|=
name|first
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
name|leaf_renumber_regs_insn
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|current_function_epilogue_delay_list
init|;
name|insn
condition|;
name|insn
operator|=
name|XEXP
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
name|leaf_renumber_regs_insn
argument_list|(
name|PATTERN
argument_list|(
name|XEXP
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Scan IN_RTX and its subexpressions, and renumber all regs into those    available in leaf functions.  */
end_comment

begin_function
name|void
name|leaf_renumber_regs_insn
parameter_list|(
name|in_rtx
parameter_list|)
specifier|register
name|rtx
name|in_rtx
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|char
modifier|*
name|format_ptr
decl_stmt|;
if|if
condition|(
name|in_rtx
operator|==
literal|0
condition|)
return|return;
comment|/* Renumber all input-registers into output-registers.      renumbered_regs would be 1 for an output-register;      they  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|in_rtx
argument_list|)
operator|==
name|REG
condition|)
block|{
name|int
name|newreg
decl_stmt|;
comment|/* Don't renumber the same reg twice.  */
if|if
condition|(
name|in_rtx
operator|->
name|used
condition|)
return|return;
name|newreg
operator|=
name|REGNO
argument_list|(
name|in_rtx
argument_list|)
expr_stmt|;
comment|/* Don't try to renumber pseudo regs.  It is possible for a pseudo reg 	 to reach here as part of a REG_NOTE.  */
if|if
condition|(
name|newreg
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|in_rtx
operator|->
name|used
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|newreg
operator|=
name|LEAF_REG_REMAP
argument_list|(
name|newreg
argument_list|)
expr_stmt|;
if|if
condition|(
name|newreg
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|regs_ever_live
index|[
name|REGNO
argument_list|(
name|in_rtx
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
name|regs_ever_live
index|[
name|newreg
index|]
operator|=
literal|1
expr_stmt|;
name|REGNO
argument_list|(
name|in_rtx
argument_list|)
operator|=
name|newreg
expr_stmt|;
name|in_rtx
operator|->
name|used
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|in_rtx
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
block|{
comment|/* Inside a SEQUENCE, we find insns. 	 Renumber just the patterns of these insns, 	 just as we do for the top-level insns.  */
name|leaf_renumber_regs_insn
argument_list|(
name|PATTERN
argument_list|(
name|in_rtx
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|format_ptr
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|in_rtx
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|in_rtx
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
switch|switch
condition|(
operator|*
name|format_ptr
operator|++
condition|)
block|{
case|case
literal|'e'
case|:
name|leaf_renumber_regs_insn
argument_list|(
name|XEXP
argument_list|(
name|in_rtx
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
if|if
condition|(
name|NULL
operator|!=
name|XVEC
argument_list|(
name|in_rtx
argument_list|,
name|i
argument_list|)
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|in_rtx
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|leaf_renumber_regs_insn
argument_list|(
name|XVECEXP
argument_list|(
name|in_rtx
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'S'
case|:
case|case
literal|'s'
case|:
case|case
literal|'0'
case|:
case|case
literal|'i'
case|:
case|case
literal|'w'
case|:
case|case
literal|'n'
case|:
case|case
literal|'u'
case|:
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

