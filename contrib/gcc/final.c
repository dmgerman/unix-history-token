begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Convert RTL to assembler code and output it, for GNU compiler.    Copyright (C) 1987, 88, 89, 92-98, 1999 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/* This is the final pass of the compiler.    It looks at the rtl code for a function and outputs assembler code.     Call `final_start_function' to output the assembler code for function entry,    `final' to output assembler code for some RTL code,    `final_end_function' to output assembler code for function exit.    If a function is compiled in several pieces, each piece is    output separately with `final'.     Some optimizations are also done at this level.    Move instructions that were made unnecessary by good register allocation    are detected and omitted from the output.  (Though most of these    are removed by the last jump pass.)     Instructions to set the condition codes are omitted when it can be    seen that the condition codes already had the desired values.     In some cases it is sufficient if the inherited condition codes    have related values, but this may require the following insn    (the one that tests the condition codes) to be modified.     The code for the function prologue and epilogue are generated    directly as assembler code by the macros FUNCTION_PROLOGUE and    FUNCTION_EPILOGUE.  Those instructions never exist as rtl.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"insn-flags.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_include
include|#
directive|include
file|"insn-codes.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"conditions.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"defaults.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"reload.h"
end_include

begin_include
include|#
directive|include
file|"intl.h"
end_include

begin_comment
comment|/* Get N_SLINE and N_SOL from stab.h if we can expect the file to exist.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DBX_DEBUGGING_INFO
argument_list|)
operator|||
name|defined
argument_list|(
name|XCOFF_DEBUGGING_INFO
argument_list|)
end_if

begin_include
include|#
directive|include
file|"dbxout.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USG
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|HAVE_STAB_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|"gstab.h"
end_include

begin_comment
comment|/* If doing DBX on sysV, use our own stab.h.  */
end_comment

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<stab.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DBX_DEBUGGING_INFO || XCOFF_DEBUGGING_INFO */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|XCOFF_DEBUGGING_INFO
end_ifdef

begin_include
include|#
directive|include
file|"xcoffout.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DWARF_DEBUGGING_INFO
end_ifdef

begin_include
include|#
directive|include
file|"dwarfout.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DWARF2_UNWIND_INFO
argument_list|)
operator|||
name|defined
argument_list|(
name|DWARF2_DEBUGGING_INFO
argument_list|)
end_if

begin_include
include|#
directive|include
file|"dwarf2out.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SDB_DEBUGGING_INFO
end_ifdef

begin_include
include|#
directive|include
file|"sdbout.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* .stabd code for line number.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|N_SLINE
end_ifndef

begin_define
define|#
directive|define
name|N_SLINE
value|0x44
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* .stabs code for included file name.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|N_SOL
end_ifndef

begin_define
define|#
directive|define
name|N_SOL
value|0x84
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|INT_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|INT_TYPE_SIZE
value|BITS_PER_WORD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LONG_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|LONG_TYPE_SIZE
value|BITS_PER_WORD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* If we aren't using cc0, CC_STATUS_INIT shouldn't exist.  So define a    null default for it to save conditionalization later.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CC_STATUS_INIT
end_ifndef

begin_define
define|#
directive|define
name|CC_STATUS_INIT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* How to start an assembler comment.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_COMMENT_START
end_ifndef

begin_define
define|#
directive|define
name|ASM_COMMENT_START
value|";#"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Is the given character a logical line separator for the assembler?  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|IS_ASM_LOGICAL_LINE_SEPARATOR
end_ifndef

begin_define
define|#
directive|define
name|IS_ASM_LOGICAL_LINE_SEPARATOR
parameter_list|(
name|C
parameter_list|)
value|((C) == ';')
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|JUMP_TABLES_IN_TEXT_SECTION
end_ifndef

begin_define
define|#
directive|define
name|JUMP_TABLES_IN_TEXT_SECTION
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Last insn processed by final_scan_insn.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|debug_insn
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Line number of last NOTE.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|last_linenum
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Highest line number in current block.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|high_block_linenum
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Likewise for function.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|high_function_linenum
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Filename of last NOTE.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|last_filename
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of basic blocks seen so far;    used if profile_block_flag is set.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|count_basic_blocks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of instrumented arcs when profile_arc_flag is set.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|count_instrumented_arcs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|length_unit_log
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is defined in insn-attrtab.c.  */
end_comment

begin_comment
comment|/* Nonzero while outputting an `asm' with operands.    This means that inconsistencies are the user's fault, so don't abort.    The precise value is the insn being output, to pass to error_for_asm.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|this_is_asm_operands
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of operands of this insn, for an `asm' with operands.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|insn_noperands
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Compare optimization flag.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|last_ignored_compare
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag indicating this insn is the start of a new basic block.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|new_block
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* All the symbol-blocks (levels of scoping) in the compilation    are assigned sequence numbers in order of appearance of the    beginnings of the symbol-blocks.  Both final and dbxout do this,    and assume that they will both give the same number to each block.    Final uses these sequence numbers to generate assembler label names    LBBnnn and LBEnnn for the beginning and end of the symbol-block.    Dbxout uses the sequence numbers to generate references to the same labels    from the dbx debugging information.     Sdb records this level at the beginning of each function,    in order to find the current level when recursing down declarations.    It outputs the block beginning and endings    at the point in the asm file where the blocks would begin and end.  */
end_comment

begin_decl_stmt
name|int
name|next_block_index
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Assign a unique number to each insn that is output.    This can be used to generate unique local labels.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|insn_counter
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_cc0
end_ifdef

begin_comment
comment|/* This variable contains machine-dependent flags (defined in tm.h)    set and examined by output routines    that describe how to interpret the condition codes properly.  */
end_comment

begin_decl_stmt
name|CC_STATUS
name|cc_status
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* During output of an insn, this contains a copy of cc_status    from before the insn.  */
end_comment

begin_decl_stmt
name|CC_STATUS
name|cc_prev_status
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Indexed by hardware reg number, is 1 if that register is ever    used in the current function.     In life_analysis, or in stupid_life_analysis, this is set    up to record the hard regs used explicitly.  Reload adds    in the hard regs used for holding pseudo regs.  Final uses    it to generate the code in the function prologue and epilogue    to save and restore registers as needed.  */
end_comment

begin_decl_stmt
name|char
name|regs_ever_live
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means current function must be given a frame pointer.    Set in stmt.c if anything is allocated on the stack there.    Set in reload1.c if anything is allocated on the stack there.  */
end_comment

begin_decl_stmt
name|int
name|frame_pointer_needed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Assign unique numbers to labels generated for profiling.  */
end_comment

begin_decl_stmt
name|int
name|profile_label_no
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Length so far allocated in PENDING_BLOCKS.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_block_depth
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Stack of sequence numbers of symbol-blocks of which we have seen the    beginning but not yet the end.  Sequence numbers are assigned at    the beginning; this stack allows us to find the sequence number    of a block that is ending.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|pending_blocks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of elements currently in use in PENDING_BLOCKS.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|block_depth
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if have enabled APP processing of our assembler output.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|app_on
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If we are outputting an insn sequence, this contains the sequence rtx.    Zero otherwise.  */
end_comment

begin_decl_stmt
name|rtx
name|final_sequence
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|ASSEMBLER_DIALECT
end_ifdef

begin_comment
comment|/* Number of the assembler dialect to use, starting at 0.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|dialect_number
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Indexed by line number, nonzero if there is a note for that line.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|line_note_exists
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Linked list to hold line numbers for each basic block.  */
end_comment

begin_struct
struct|struct
name|bb_list
block|{
name|struct
name|bb_list
modifier|*
name|next
decl_stmt|;
comment|/* pointer to next basic block */
name|int
name|line_num
decl_stmt|;
comment|/* line number */
name|int
name|file_label_num
decl_stmt|;
comment|/* LPBC<n> label # for stored filename */
name|int
name|func_label_num
decl_stmt|;
comment|/* LPBC<n> label # for stored function name */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|bb_list
modifier|*
name|bb_head
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Head of basic block list */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|bb_list
modifier|*
modifier|*
name|bb_tail
init|=
operator|&
name|bb_head
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Ptr to store next bb ptr */
end_comment

begin_decl_stmt
specifier|static
name|int
name|bb_file_label_num
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current label # for file */
end_comment

begin_decl_stmt
specifier|static
name|int
name|bb_func_label_num
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current label # for func */
end_comment

begin_comment
comment|/* Linked list to hold the strings for each file and function name output.  */
end_comment

begin_struct
struct|struct
name|bb_str
block|{
name|struct
name|bb_str
modifier|*
name|next
decl_stmt|;
comment|/* pointer to next string */
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
comment|/* string */
name|int
name|label_num
decl_stmt|;
comment|/* label number */
name|int
name|length
decl_stmt|;
comment|/* string length */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|extern
name|rtx
name|peephole
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bb_str
modifier|*
name|sbb_head
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Head of string list.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|bb_str
modifier|*
modifier|*
name|sbb_tail
init|=
operator|&
name|sbb_head
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Ptr to store next bb str */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sbb_label_num
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last label used */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ATTR_length
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|asm_insn_count
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|profile_function
name|PROTO
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|profile_after_prologue
name|PROTO
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_bb
name|PROTO
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|add_bb_string
name|PROTO
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_source_line
name|PROTO
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|walk_alter_subreg
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_asm_name
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_operand
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|LEAF_REGISTERS
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|leaf_renumber_regs
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_cc0
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|alter_cond
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|extern
name|char
modifier|*
name|getpwd
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Initialize data in final at the beginning of a compilation.  */
end_comment

begin_function
name|void
name|init_final
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|next_block_index
operator|=
literal|2
expr_stmt|;
name|app_on
operator|=
literal|0
expr_stmt|;
name|max_block_depth
operator|=
literal|20
expr_stmt|;
name|pending_blocks
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
literal|20
operator|*
sizeof|sizeof
expr|*
name|pending_blocks
argument_list|)
expr_stmt|;
name|final_sequence
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|ASSEMBLER_DIALECT
name|dialect_number
operator|=
name|ASSEMBLER_DIALECT
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Called at end of source file,    to output the block-profiling table for this entire compilation.  */
end_comment

begin_function
name|void
name|end_final
parameter_list|(
name|filename
parameter_list|)
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|profile_block_flag
operator|||
name|profile_arc_flag
condition|)
block|{
name|char
name|name
index|[
literal|20
index|]
decl_stmt|;
name|int
name|align
init|=
name|exact_log2
argument_list|(
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
argument_list|)
decl_stmt|;
name|int
name|size
decl_stmt|,
name|rounded
decl_stmt|;
name|struct
name|bb_list
modifier|*
name|ptr
decl_stmt|;
name|struct
name|bb_str
modifier|*
name|sptr
decl_stmt|;
name|int
name|long_bytes
init|=
name|LONG_TYPE_SIZE
operator|/
name|BITS_PER_UNIT
decl_stmt|;
name|int
name|pointer_bytes
init|=
name|POINTER_SIZE
operator|/
name|BITS_PER_UNIT
decl_stmt|;
if|if
condition|(
name|profile_block_flag
condition|)
name|size
operator|=
name|long_bytes
operator|*
name|count_basic_blocks
expr_stmt|;
else|else
name|size
operator|=
name|long_bytes
operator|*
name|count_instrumented_arcs
expr_stmt|;
name|rounded
operator|=
name|size
expr_stmt|;
name|rounded
operator|+=
operator|(
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
operator|)
operator|-
literal|1
expr_stmt|;
name|rounded
operator|=
operator|(
name|rounded
operator|/
operator|(
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
operator|)
operator|*
operator|(
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
operator|)
operator|)
expr_stmt|;
name|data_section
argument_list|()
expr_stmt|;
comment|/* Output the main header, of 11 words: 	 0:  1 if this file is initialized, else 0. 	 1:  address of file name (LPBX1). 	 2:  address of table of counts (LPBX2). 	 3:  number of counts in the table. 	 4:  always 0, for compatibility with Sun.           The following are GNU extensions:  	 5:  address of table of start addrs of basic blocks (LPBX3). 	 6:  Number of bytes in this header. 	 7:  address of table of function names (LPBX4). 	 8:  address of table of line numbers (LPBX5) or 0. 	 9:  address of table of file names (LPBX6) or 0. 	10:  space reserved for basic block profiling.  */
name|ASM_OUTPUT_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
name|align
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|asm_out_file
argument_list|,
literal|"LPBX"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* zero word */
name|assemble_integer
argument_list|(
name|const0_rtx
argument_list|,
name|long_bytes
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* address of filename */
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|name
argument_list|,
literal|"LPBX"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|name
argument_list|)
argument_list|,
name|pointer_bytes
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* address of count table */
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|name
argument_list|,
literal|"LPBX"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|name
argument_list|)
argument_list|,
name|pointer_bytes
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* count of the # of basic blocks or # of instrumented arcs */
if|if
condition|(
name|profile_block_flag
condition|)
name|assemble_integer
argument_list|(
name|GEN_INT
argument_list|(
name|count_basic_blocks
argument_list|)
argument_list|,
name|long_bytes
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|assemble_integer
argument_list|(
name|GEN_INT
argument_list|(
name|count_instrumented_arcs
argument_list|)
argument_list|,
name|long_bytes
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* zero word (link field) */
name|assemble_integer
argument_list|(
name|const0_rtx
argument_list|,
name|pointer_bytes
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* address of basic block start address table */
if|if
condition|(
name|profile_block_flag
condition|)
block|{
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|name
argument_list|,
literal|"LPBX"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|name
argument_list|)
argument_list|,
name|pointer_bytes
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|assemble_integer
argument_list|(
name|const0_rtx
argument_list|,
name|pointer_bytes
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* byte count for extended structure.  */
name|assemble_integer
argument_list|(
name|GEN_INT
argument_list|(
literal|11
operator|*
name|UNITS_PER_WORD
argument_list|)
argument_list|,
name|long_bytes
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* address of function name table */
if|if
condition|(
name|profile_block_flag
condition|)
block|{
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|name
argument_list|,
literal|"LPBX"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|name
argument_list|)
argument_list|,
name|pointer_bytes
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|assemble_integer
argument_list|(
name|const0_rtx
argument_list|,
name|pointer_bytes
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* address of line number and filename tables if debugging.  */
if|if
condition|(
name|write_symbols
operator|!=
name|NO_DEBUG
operator|&&
name|profile_block_flag
condition|)
block|{
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|name
argument_list|,
literal|"LPBX"
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|name
argument_list|)
argument_list|,
name|pointer_bytes
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|name
argument_list|,
literal|"LPBX"
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|name
argument_list|)
argument_list|,
name|pointer_bytes
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assemble_integer
argument_list|(
name|const0_rtx
argument_list|,
name|pointer_bytes
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|const0_rtx
argument_list|,
name|pointer_bytes
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* space for extension ptr (link field) */
name|assemble_integer
argument_list|(
name|const0_rtx
argument_list|,
name|UNITS_PER_WORD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Output the file name changing the suffix to .d for Sun tcov 	 compatibility.  */
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|asm_out_file
argument_list|,
literal|"LPBX"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|{
name|char
modifier|*
name|cwd
init|=
name|getpwd
argument_list|()
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|filename
argument_list|)
operator|+
name|strlen
argument_list|(
name|cwd
argument_list|)
operator|+
literal|1
decl_stmt|;
name|char
modifier|*
name|data_file
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
operator|+
literal|4
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|data_file
argument_list|,
name|cwd
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|data_file
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|data_file
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|strip_off_ending
argument_list|(
name|data_file
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|profile_block_flag
condition|)
name|strcat
argument_list|(
name|data_file
argument_list|,
literal|".d"
argument_list|)
expr_stmt|;
else|else
name|strcat
argument_list|(
name|data_file
argument_list|,
literal|".da"
argument_list|)
expr_stmt|;
name|assemble_string
argument_list|(
name|data_file
argument_list|,
name|strlen
argument_list|(
name|data_file
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Make space for the table of counts.  */
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
comment|/* Realign data section.  */
name|ASM_OUTPUT_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
name|align
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|asm_out_file
argument_list|,
literal|"LPBX"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|!=
literal|0
condition|)
name|assemble_zeros
argument_list|(
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|name
argument_list|,
literal|"LPBX"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ASM_OUTPUT_SHARED_LOCAL
if|if
condition|(
name|flag_shared_data
condition|)
name|ASM_OUTPUT_SHARED_LOCAL
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|,
name|size
argument_list|,
name|rounded
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ASM_OUTPUT_ALIGNED_DECL_LOCAL
name|ASM_OUTPUT_ALIGNED_DECL_LOCAL
argument_list|(
name|asm_out_file
argument_list|,
name|NULL_TREE
argument_list|,
name|name
argument_list|,
name|size
argument_list|,
name|BIGGEST_ALIGNMENT
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|ASM_OUTPUT_ALIGNED_LOCAL
name|ASM_OUTPUT_ALIGNED_LOCAL
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|,
name|size
argument_list|,
name|BIGGEST_ALIGNMENT
argument_list|)
expr_stmt|;
else|#
directive|else
name|ASM_OUTPUT_LOCAL
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|,
name|size
argument_list|,
name|rounded
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
comment|/* Output any basic block strings */
if|if
condition|(
name|profile_block_flag
condition|)
block|{
name|readonly_data_section
argument_list|()
expr_stmt|;
if|if
condition|(
name|sbb_head
condition|)
block|{
name|ASM_OUTPUT_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
name|align
argument_list|)
expr_stmt|;
for|for
control|(
name|sptr
operator|=
name|sbb_head
init|;
name|sptr
operator|!=
literal|0
condition|;
name|sptr
operator|=
name|sptr
operator|->
name|next
control|)
block|{
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|asm_out_file
argument_list|,
literal|"LPBC"
argument_list|,
name|sptr
operator|->
name|label_num
argument_list|)
expr_stmt|;
name|assemble_string
argument_list|(
name|sptr
operator|->
name|string
argument_list|,
name|sptr
operator|->
name|length
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Output the table of addresses.  */
if|if
condition|(
name|profile_block_flag
condition|)
block|{
comment|/* Realign in new section */
name|ASM_OUTPUT_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
name|align
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|asm_out_file
argument_list|,
literal|"LPBX"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count_basic_blocks
condition|;
name|i
operator|++
control|)
block|{
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|name
argument_list|,
literal|"LPB"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|name
argument_list|)
argument_list|,
name|pointer_bytes
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Output the table of function names.  */
if|if
condition|(
name|profile_block_flag
condition|)
block|{
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|asm_out_file
argument_list|,
literal|"LPBX"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
for|for
control|(
operator|(
name|ptr
operator|=
name|bb_head
operator|)
operator|,
operator|(
name|i
operator|=
literal|0
operator|)
init|;
name|ptr
operator|!=
literal|0
condition|;
operator|(
name|ptr
operator|=
name|ptr
operator|->
name|next
operator|)
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ptr
operator|->
name|func_label_num
operator|>=
literal|0
condition|)
block|{
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|name
argument_list|,
literal|"LPBC"
argument_list|,
name|ptr
operator|->
name|func_label_num
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|name
argument_list|)
argument_list|,
name|pointer_bytes
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|assemble_integer
argument_list|(
name|const0_rtx
argument_list|,
name|pointer_bytes
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|<
name|count_basic_blocks
condition|;
name|i
operator|++
control|)
name|assemble_integer
argument_list|(
name|const0_rtx
argument_list|,
name|pointer_bytes
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|write_symbols
operator|!=
name|NO_DEBUG
operator|&&
name|profile_block_flag
condition|)
block|{
comment|/* Output the table of line numbers.  */
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|asm_out_file
argument_list|,
literal|"LPBX"
argument_list|,
literal|5
argument_list|)
expr_stmt|;
for|for
control|(
operator|(
name|ptr
operator|=
name|bb_head
operator|)
operator|,
operator|(
name|i
operator|=
literal|0
operator|)
init|;
name|ptr
operator|!=
literal|0
condition|;
operator|(
name|ptr
operator|=
name|ptr
operator|->
name|next
operator|)
operator|,
name|i
operator|++
control|)
name|assemble_integer
argument_list|(
name|GEN_INT
argument_list|(
name|ptr
operator|->
name|line_num
argument_list|)
argument_list|,
name|long_bytes
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|count_basic_blocks
condition|;
name|i
operator|++
control|)
name|assemble_integer
argument_list|(
name|const0_rtx
argument_list|,
name|long_bytes
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Output the table of file names.  */
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|asm_out_file
argument_list|,
literal|"LPBX"
argument_list|,
literal|6
argument_list|)
expr_stmt|;
for|for
control|(
operator|(
name|ptr
operator|=
name|bb_head
operator|)
operator|,
operator|(
name|i
operator|=
literal|0
operator|)
init|;
name|ptr
operator|!=
literal|0
condition|;
operator|(
name|ptr
operator|=
name|ptr
operator|->
name|next
operator|)
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ptr
operator|->
name|file_label_num
operator|>=
literal|0
condition|)
block|{
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|name
argument_list|,
literal|"LPBC"
argument_list|,
name|ptr
operator|->
name|file_label_num
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|name
argument_list|)
argument_list|,
name|pointer_bytes
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|assemble_integer
argument_list|(
name|const0_rtx
argument_list|,
name|pointer_bytes
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|<
name|count_basic_blocks
condition|;
name|i
operator|++
control|)
name|assemble_integer
argument_list|(
name|const0_rtx
argument_list|,
name|pointer_bytes
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* End with the address of the table of addresses, 	 so we can find it easily, as the last word in the file's text.  */
if|if
condition|(
name|profile_block_flag
condition|)
block|{
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|name
argument_list|,
literal|"LPBX"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|name
argument_list|)
argument_list|,
name|pointer_bytes
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Enable APP processing of subsequent output.    Used before the output from an `asm' statement.  */
end_comment

begin_function
name|void
name|app_enable
parameter_list|()
block|{
if|if
condition|(
operator|!
name|app_on
condition|)
block|{
name|fputs
argument_list|(
name|ASM_APP_ON
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|app_on
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Disable APP processing of subsequent output.    Called from varasm.c before most kinds of output.  */
end_comment

begin_function
name|void
name|app_disable
parameter_list|()
block|{
if|if
condition|(
name|app_on
condition|)
block|{
name|fputs
argument_list|(
name|ASM_APP_OFF
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|app_on
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the number of slots filled in the current     delayed branch sequence (we don't count the insn needing the    delay slot).   Zero if not in a delayed branch sequence.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DELAY_SLOTS
end_ifdef

begin_function
name|int
name|dbr_sequence_length
parameter_list|()
block|{
if|if
condition|(
name|final_sequence
operator|!=
literal|0
condition|)
return|return
name|XVECLEN
argument_list|(
name|final_sequence
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* The next two pages contain routines used to compute the length of an insn    and to shorten branches.  */
end_comment

begin_comment
comment|/* Arrays for insn lengths, and addresses.  The latter is referenced by    `insn_current_length'.  */
end_comment

begin_decl_stmt
specifier|static
name|short
modifier|*
name|insn_lengths
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|insn_addresses
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Max uid for which the above arrays are valid.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|insn_lengths_max_uid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Address of insn being processed.  Used by `insn_current_length'.  */
end_comment

begin_decl_stmt
name|int
name|insn_current_address
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Address of insn being processed in previous iteration.  */
end_comment

begin_decl_stmt
name|int
name|insn_last_address
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* konwn invariant alignment of insn being processed.  */
end_comment

begin_decl_stmt
name|int
name|insn_current_align
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* After shorten_branches, for any insn, uid_align[INSN_UID (insn)]    gives the next following alignment insn that increases the known    alignment, or NULL_RTX if there is no such insn.    For any alignment obtained this way, we can again index uid_align with    its uid to obtain the next following align that in turn increases the    alignment, till we reach NULL_RTX; the sequence obtained this way    for each insn we'll call the alignment chain of this insn in the following    comments.  */
end_comment

begin_struct
struct|struct
name|label_alignment
block|{
name|short
name|alignment
decl_stmt|;
name|short
name|max_skip
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|uid_align
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
modifier|*
name|uid_shuid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|label_alignment
modifier|*
name|label_align
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indicate that branch shortening hasn't yet been done.  */
end_comment

begin_function
name|void
name|init_insn_lengths
parameter_list|()
block|{
if|if
condition|(
name|label_align
condition|)
block|{
name|free
argument_list|(
name|label_align
argument_list|)
expr_stmt|;
name|label_align
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|uid_shuid
condition|)
block|{
name|free
argument_list|(
name|uid_shuid
argument_list|)
expr_stmt|;
name|uid_shuid
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|insn_lengths
condition|)
block|{
name|free
argument_list|(
name|insn_lengths
argument_list|)
expr_stmt|;
name|insn_lengths
operator|=
literal|0
expr_stmt|;
name|insn_lengths_max_uid
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|insn_addresses
condition|)
block|{
name|free
argument_list|(
name|insn_addresses
argument_list|)
expr_stmt|;
name|insn_addresses
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|uid_align
condition|)
block|{
name|free
argument_list|(
name|uid_align
argument_list|)
expr_stmt|;
name|uid_align
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Obtain the current length of an insn.  If branch shortening has been done,    get its actual length.  Otherwise, get its maximum length.  */
end_comment

begin_function
name|int
name|get_attr_length
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|HAVE_ATTR_length
name|rtx
name|body
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|length
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|insn_lengths_max_uid
operator|>
name|INSN_UID
argument_list|(
name|insn
argument_list|)
condition|)
return|return
name|insn_lengths
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
return|;
else|else
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|NOTE
case|:
case|case
name|BARRIER
case|:
case|case
name|CODE_LABEL
case|:
return|return
literal|0
return|;
case|case
name|CALL_INSN
case|:
name|length
operator|=
name|insn_default_length
argument_list|(
name|insn
argument_list|)
expr_stmt|;
break|break;
case|case
name|JUMP_INSN
case|:
name|body
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|ADDR_VEC
operator|||
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|ADDR_DIFF_VEC
condition|)
block|{
comment|/* Alignment is machine-dependent and should be handled by 	       ADDR_VEC_ALIGN.  */
block|}
else|else
name|length
operator|=
name|insn_default_length
argument_list|(
name|insn
argument_list|)
expr_stmt|;
break|break;
case|case
name|INSN
case|:
name|body
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|CLOBBER
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|ASM_INPUT
operator|||
name|asm_noperands
argument_list|(
name|body
argument_list|)
operator|>=
literal|0
condition|)
name|length
operator|=
name|asm_insn_count
argument_list|(
name|body
argument_list|)
operator|*
name|insn_default_length
argument_list|(
name|insn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|SEQUENCE
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
name|length
operator|+=
name|get_attr_length
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|length
operator|=
name|insn_default_length
argument_list|(
name|insn
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
ifdef|#
directive|ifdef
name|ADJUST_INSN_LENGTH
name|ADJUST_INSN_LENGTH
argument_list|(
name|insn
argument_list|,
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|length
return|;
else|#
directive|else
comment|/* not HAVE_ATTR_length */
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* not HAVE_ATTR_length */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Code to handle alignment inside shorten_branches.  */
end_comment

begin_comment
comment|/* Here is an explanation how the algorithm in align_fuzz can give    proper results:     Call a sequence of instructions beginning with alignment point X    and continuing until the next alignment point `block X'.  When `X'    is used in an expression, it means the alignment value of the     alignment point.        Call the distance between the start of the first insn of block X, and    the end of the last insn of block X `IX', for the `inner size of X'.    This is clearly the sum of the instruction lengths.        Likewise with the next alignment-delimited block following X, which we    shall call block Y.        Call the distance between the start of the first insn of block X, and    the start of the first insn of block Y `OX', for the `outer size of X'.        The estimated padding is then OX - IX.        OX can be safely estimated as                if (X>= Y)                    OX = round_up(IX, Y)            else                    OX = round_up(IX, X) + Y - X        Clearly est(IX)>= real(IX), because that only depends on the    instruction lengths, and those being overestimated is a given.        Clearly round_up(foo, Z)>= round_up(bar, Z) if foo>= bar, so    we needn't worry about that when thinking about OX.        When X>= Y, the alignment provided by Y adds no uncertainty factor    for branch ranges starting before X, so we can just round what we have.    But when X< Y, we don't know anything about the, so to speak,    `middle bits', so we have to assume the worst when aligning up from an    address mod X to one mod Y, which is Y - X.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LABEL_ALIGN
end_ifndef

begin_define
define|#
directive|define
name|LABEL_ALIGN
parameter_list|(
name|LABEL
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LABEL_ALIGN_MAX_SKIP
end_ifndef

begin_define
define|#
directive|define
name|LABEL_ALIGN_MAX_SKIP
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LOOP_ALIGN
end_ifndef

begin_define
define|#
directive|define
name|LOOP_ALIGN
parameter_list|(
name|LABEL
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LOOP_ALIGN_MAX_SKIP
end_ifndef

begin_define
define|#
directive|define
name|LOOP_ALIGN_MAX_SKIP
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LABEL_ALIGN_AFTER_BARRIER
end_ifndef

begin_define
define|#
directive|define
name|LABEL_ALIGN_AFTER_BARRIER
parameter_list|(
name|LABEL
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LABEL_ALIGN_AFTER_BARRIER_MAX_SKIP
end_ifndef

begin_define
define|#
directive|define
name|LABEL_ALIGN_AFTER_BARRIER_MAX_SKIP
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ADDR_VEC_ALIGN
end_ifndef

begin_function
name|int
name|final_addr_vec_align
parameter_list|(
name|addr_vec
parameter_list|)
name|rtx
name|addr_vec
decl_stmt|;
block|{
name|int
name|align
init|=
name|exact_log2
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|PATTERN
argument_list|(
name|addr_vec
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|align
operator|>
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
condition|)
name|align
operator|=
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
expr_stmt|;
return|return
name|align
return|;
block|}
end_function

begin_define
define|#
directive|define
name|ADDR_VEC_ALIGN
parameter_list|(
name|ADDR_VEC
parameter_list|)
value|final_addr_vec_align (ADDR_VEC)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|INSN_LENGTH_ALIGNMENT
end_ifndef

begin_define
define|#
directive|define
name|INSN_LENGTH_ALIGNMENT
parameter_list|(
name|INSN
parameter_list|)
value|length_unit_log
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|INSN_SHUID
parameter_list|(
name|INSN
parameter_list|)
value|(uid_shuid[INSN_UID (INSN)])
end_define

begin_decl_stmt
specifier|static
name|int
name|min_labelno
decl_stmt|,
name|max_labelno
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|LABEL_TO_ALIGNMENT
parameter_list|(
name|LABEL
parameter_list|)
define|\
value|(label_align[CODE_LABEL_NUMBER (LABEL) - min_labelno].alignment)
end_define

begin_define
define|#
directive|define
name|LABEL_TO_MAX_SKIP
parameter_list|(
name|LABEL
parameter_list|)
define|\
value|(label_align[CODE_LABEL_NUMBER (LABEL) - min_labelno].max_skip)
end_define

begin_comment
comment|/* For the benefit of port specific code do this also as a function.  */
end_comment

begin_function
name|int
name|label_to_alignment
parameter_list|(
name|label
parameter_list|)
name|rtx
name|label
decl_stmt|;
block|{
return|return
name|LABEL_TO_ALIGNMENT
argument_list|(
name|label
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ATTR_length
end_ifdef

begin_comment
comment|/* The differences in addresses    between a branch and its target might grow or shrink depending on    the alignment the start insn of the range (the branch for a forward    branch or the label for a backward branch) starts out on; if these    differences are used naively, they can even oscillate infinitely.    We therefore want to compute a 'worst case' address difference that    is independent of the alignment the start insn of the range end    up on, and that is at least as large as the actual difference.    The function align_fuzz calculates the amount we have to add to the    naively computed difference, by traversing the part of the alignment    chain of the start insn of the range that is in front of the end insn    of the range, and considering for each alignment the maximum amount    that it might contribute to a size increase.     For casesi tables, we also want to know worst case minimum amounts of    address difference, in case a machine description wants to introduce    some common offset that is added to all offsets in a table.    For this purpose, align_fuzz with a growth argument of 0 comuptes the    appropriate adjustment.  */
end_comment

begin_comment
comment|/* Compute the maximum delta by which the difference of the addresses of    START and END might grow / shrink due to a different address for start    which changes the size of alignment insns between START and END.    KNOWN_ALIGN_LOG is the alignment known for START.    GROWTH should be ~0 if the objective is to compute potential code size    increase, and 0 if the objective is to compute potential shrink.    The return value is undefined for any other value of GROWTH.  */
end_comment

begin_function
name|int
name|align_fuzz
parameter_list|(
name|start
parameter_list|,
name|end
parameter_list|,
name|known_align_log
parameter_list|,
name|growth
parameter_list|)
name|rtx
name|start
decl_stmt|,
name|end
decl_stmt|;
name|int
name|known_align_log
decl_stmt|;
name|unsigned
name|growth
decl_stmt|;
block|{
name|int
name|uid
init|=
name|INSN_UID
argument_list|(
name|start
argument_list|)
decl_stmt|;
name|rtx
name|align_label
decl_stmt|;
name|int
name|known_align
init|=
literal|1
operator|<<
name|known_align_log
decl_stmt|;
name|int
name|end_shuid
init|=
name|INSN_SHUID
argument_list|(
name|end
argument_list|)
decl_stmt|;
name|int
name|fuzz
init|=
literal|0
decl_stmt|;
for|for
control|(
name|align_label
operator|=
name|uid_align
index|[
name|uid
index|]
init|;
name|align_label
condition|;
name|align_label
operator|=
name|uid_align
index|[
name|uid
index|]
control|)
block|{
name|int
name|align_addr
decl_stmt|,
name|new_align
decl_stmt|;
name|uid
operator|=
name|INSN_UID
argument_list|(
name|align_label
argument_list|)
expr_stmt|;
name|align_addr
operator|=
name|insn_addresses
index|[
name|uid
index|]
operator|-
name|insn_lengths
index|[
name|uid
index|]
expr_stmt|;
if|if
condition|(
name|uid_shuid
index|[
name|uid
index|]
operator|>
name|end_shuid
condition|)
break|break;
name|known_align_log
operator|=
name|LABEL_TO_ALIGNMENT
argument_list|(
name|align_label
argument_list|)
expr_stmt|;
name|new_align
operator|=
literal|1
operator|<<
name|known_align_log
expr_stmt|;
if|if
condition|(
name|new_align
operator|<
name|known_align
condition|)
continue|continue;
name|fuzz
operator|+=
operator|(
operator|-
name|align_addr
operator|^
name|growth
operator|)
operator|&
operator|(
name|new_align
operator|-
name|known_align
operator|)
expr_stmt|;
name|known_align
operator|=
name|new_align
expr_stmt|;
block|}
return|return
name|fuzz
return|;
block|}
end_function

begin_comment
comment|/* Compute a worst-case reference address of a branch so that it    can be safely used in the presence of aligned labels.  Since the    size of the branch itself is unknown, the size of the branch is    not included in the range.  I.e. for a forward branch, the reference    address is the end address of the branch as known from the previous    branch shortening pass, minus a value to account for possible size    increase due to alignment.  For a backward branch, it is the start    address of the branch as known from the current pass, plus a value    to account for possible size increase due to alignment.    NB.: Therefore, the maximum offset allowed for backward branches needs    to exclude the branch size.  */
end_comment

begin_function
name|int
name|insn_current_reference_address
parameter_list|(
name|branch
parameter_list|)
name|rtx
name|branch
decl_stmt|;
block|{
name|rtx
name|dest
decl_stmt|;
name|rtx
name|seq
init|=
name|NEXT_INSN
argument_list|(
name|PREV_INSN
argument_list|(
name|branch
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|seq_uid
init|=
name|INSN_UID
argument_list|(
name|seq
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|branch
argument_list|)
operator|!=
name|JUMP_INSN
condition|)
comment|/* This can happen for example on the PA; the objective is to know the        offset to address something in front of the start of the function.        Thus, we can treat it like a backward branch.        We assume here that FUNCTION_BOUNDARY / BITS_PER_UNIT is larger than        any alignment we'd encounter, so we skip the call to align_fuzz.  */
return|return
name|insn_current_address
return|;
name|dest
operator|=
name|JUMP_LABEL
argument_list|(
name|branch
argument_list|)
expr_stmt|;
comment|/* BRANCH has no proper alignment chain set, so use SEQ.  */
if|if
condition|(
name|INSN_SHUID
argument_list|(
name|branch
argument_list|)
operator|<
name|INSN_SHUID
argument_list|(
name|dest
argument_list|)
condition|)
block|{
comment|/* Forward branch. */
return|return
operator|(
name|insn_last_address
operator|+
name|insn_lengths
index|[
name|seq_uid
index|]
operator|-
name|align_fuzz
argument_list|(
name|seq
argument_list|,
name|dest
argument_list|,
name|length_unit_log
argument_list|,
operator|~
literal|0
argument_list|)
operator|)
return|;
block|}
else|else
block|{
comment|/* Backward branch. */
return|return
operator|(
name|insn_current_address
operator|+
name|align_fuzz
argument_list|(
name|dest
argument_list|,
name|seq
argument_list|,
name|length_unit_log
argument_list|,
operator|~
literal|0
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_ATTR_length */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Make a pass over all insns and compute their actual lengths by shortening    any branches of variable length if possible.  */
end_comment

begin_comment
comment|/* Give a default value for the lowest address in a function.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|FIRST_INSN_ADDRESS
end_ifndef

begin_define
define|#
directive|define
name|FIRST_INSN_ADDRESS
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* shorten_branches might be called multiple times:  for example, the SH    port splits out-of-range conditional branches in MACHINE_DEPENDENT_REORG.    In order to do this, it needs proper length information, which it obtains    by calling shorten_branches.  This cannot be collapsed with    shorten_branches itself into a single pass unless we also want to intergate    reorg.c, since the branch splitting exposes new instructions with delay    slots.  */
end_comment

begin_function
name|void
name|shorten_branches
parameter_list|(
name|first
parameter_list|)
name|rtx
name|first
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
name|int
name|max_uid
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|max_log
decl_stmt|;
name|int
name|max_skip
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_ATTR_length
define|#
directive|define
name|MAX_CODE_ALIGN
value|16
name|rtx
name|seq
decl_stmt|;
name|int
name|something_changed
init|=
literal|1
decl_stmt|;
name|char
modifier|*
name|varying_length
decl_stmt|;
name|rtx
name|body
decl_stmt|;
name|int
name|uid
decl_stmt|;
name|rtx
name|align_tab
index|[
name|MAX_CODE_ALIGN
index|]
decl_stmt|;
comment|/* In order to make sure that all instructions have valid length info,      we must split them before we compute the address/length info.  */
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|first
argument_list|)
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
block|{
name|rtx
name|old
init|=
name|insn
decl_stmt|;
comment|/* Don't split the insn if it has been deleted.  */
if|if
condition|(
operator|!
name|INSN_DELETED_P
argument_list|(
name|old
argument_list|)
condition|)
name|insn
operator|=
name|try_split
argument_list|(
name|PATTERN
argument_list|(
name|old
argument_list|)
argument_list|,
name|old
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* When not optimizing, the old insn will be still left around 	   with only the 'deleted' bit set.  Transform it into a note 	   to avoid confusion of subsequent processing.  */
if|if
condition|(
name|INSN_DELETED_P
argument_list|(
name|old
argument_list|)
condition|)
block|{
name|PUT_CODE
argument_list|(
name|old
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|old
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|old
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* We must do some computations even when not actually shortening, in      order to get the alignment information for the labels.  */
name|init_insn_lengths
argument_list|()
expr_stmt|;
comment|/* Compute maximum UID and allocate label_align / uid_shuid.  */
name|max_uid
operator|=
name|get_max_uid
argument_list|()
expr_stmt|;
name|max_labelno
operator|=
name|max_label_num
argument_list|()
expr_stmt|;
name|min_labelno
operator|=
name|get_first_label_num
argument_list|()
expr_stmt|;
name|label_align
operator|=
operator|(
expr|struct
name|label_alignment
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|max_labelno
operator|-
name|min_labelno
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|label_alignment
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|label_align
argument_list|,
operator|(
name|max_labelno
operator|-
name|min_labelno
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|label_alignment
argument_list|)
argument_list|)
expr_stmt|;
name|uid_shuid
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
name|max_uid
operator|*
sizeof|sizeof
expr|*
name|uid_shuid
argument_list|)
expr_stmt|;
comment|/* Initialize label_align and set up uid_shuid to be strictly      monotonically rising with insn order.  */
comment|/* We use max_log here to keep track of the maximum alignment we want to      impose on the next CODE_LABEL (or the current one if we are processing      the CODE_LABEL itself).  */
name|max_log
operator|=
literal|0
expr_stmt|;
name|max_skip
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
operator|,
name|i
operator|=
literal|1
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|int
name|log
decl_stmt|;
name|INSN_SHUID
argument_list|(
name|insn
argument_list|)
operator|=
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
block|{
comment|/* reorg might make the first insn of a loop being run once only,              and delete the label in front of it.  Then we want to apply              the loop alignment to the new label created by reorg, which              is separated by the former loop start insn from the 	     NOTE_INSN_LOOP_BEG.  */
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
block|{
name|rtx
name|next
decl_stmt|;
name|log
operator|=
name|LABEL_ALIGN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|max_log
operator|<
name|log
condition|)
block|{
name|max_log
operator|=
name|log
expr_stmt|;
name|max_skip
operator|=
name|LABEL_ALIGN_MAX_SKIP
expr_stmt|;
block|}
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* ADDR_VECs only take room if read-only data goes into the text 	     section.  */
if|if
condition|(
name|JUMP_TABLES_IN_TEXT_SECTION
if|#
directive|if
operator|!
name|defined
argument_list|(
name|READONLY_DATA_SECTION
argument_list|)
operator|||
literal|1
endif|#
directive|endif
condition|)
if|if
condition|(
name|next
operator|&&
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
name|rtx
name|nextbody
init|=
name|PATTERN
argument_list|(
name|next
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|nextbody
argument_list|)
operator|==
name|ADDR_VEC
operator|||
name|GET_CODE
argument_list|(
name|nextbody
argument_list|)
operator|==
name|ADDR_DIFF_VEC
condition|)
block|{
name|log
operator|=
name|ADDR_VEC_ALIGN
argument_list|(
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|max_log
operator|<
name|log
condition|)
block|{
name|max_log
operator|=
name|log
expr_stmt|;
name|max_skip
operator|=
name|LABEL_ALIGN_MAX_SKIP
expr_stmt|;
block|}
block|}
block|}
name|LABEL_TO_ALIGNMENT
argument_list|(
name|insn
argument_list|)
operator|=
name|max_log
expr_stmt|;
name|LABEL_TO_MAX_SKIP
argument_list|(
name|insn
argument_list|)
operator|=
name|max_skip
expr_stmt|;
name|max_log
operator|=
literal|0
expr_stmt|;
name|max_skip
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|BARRIER
condition|)
block|{
name|rtx
name|label
decl_stmt|;
for|for
control|(
name|label
operator|=
name|insn
init|;
name|label
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|label
argument_list|)
argument_list|)
operator|!=
literal|'i'
condition|;
name|label
operator|=
name|NEXT_INSN
argument_list|(
name|label
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|label
argument_list|)
operator|==
name|CODE_LABEL
condition|)
block|{
name|log
operator|=
name|LABEL_ALIGN_AFTER_BARRIER
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|max_log
operator|<
name|log
condition|)
block|{
name|max_log
operator|=
name|log
expr_stmt|;
name|max_skip
operator|=
name|LABEL_ALIGN_AFTER_BARRIER_MAX_SKIP
expr_stmt|;
block|}
break|break;
block|}
block|}
comment|/* Again, we allow NOTE_INSN_LOOP_BEG - INSN - CODE_LABEL 	 sequences in order to handle reorg output efficiently.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
condition|)
block|{
name|rtx
name|label
decl_stmt|;
for|for
control|(
name|label
operator|=
name|insn
init|;
name|label
condition|;
name|label
operator|=
name|NEXT_INSN
argument_list|(
name|label
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|label
argument_list|)
operator|==
name|CODE_LABEL
condition|)
block|{
name|log
operator|=
name|LOOP_ALIGN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|max_log
operator|<
name|log
condition|)
block|{
name|max_log
operator|=
name|log
expr_stmt|;
name|max_skip
operator|=
name|LOOP_ALIGN_MAX_SKIP
expr_stmt|;
block|}
break|break;
block|}
block|}
else|else
continue|continue;
block|}
ifdef|#
directive|ifdef
name|HAVE_ATTR_length
comment|/* Allocate the rest of the arrays.  */
name|insn_lengths
operator|=
operator|(
name|short
operator|*
operator|)
name|xmalloc
argument_list|(
name|max_uid
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|insn_addresses
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
name|max_uid
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|insn_lengths_max_uid
operator|=
name|max_uid
expr_stmt|;
comment|/* Syntax errors can lead to labels being outside of the main insn stream.      Initialize insn_addresses, so that we get reproducible results.  */
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|insn_addresses
argument_list|,
name|max_uid
operator|*
sizeof|sizeof
expr|*
name|insn_addresses
argument_list|)
expr_stmt|;
name|uid_align
operator|=
operator|(
name|rtx
operator|*
operator|)
name|xmalloc
argument_list|(
name|max_uid
operator|*
sizeof|sizeof
expr|*
name|uid_align
argument_list|)
expr_stmt|;
name|varying_length
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|max_uid
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|varying_length
argument_list|,
name|max_uid
argument_list|)
expr_stmt|;
comment|/* Initialize uid_align.  We scan instructions      from end to start, and keep in align_tab[n] the last seen insn      that does an alignment of at least n+1, i.e. the successor      in the alignment chain for an insn that does / has a known      alignment of n.  */
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|uid_align
argument_list|,
name|max_uid
operator|*
sizeof|sizeof
expr|*
name|uid_align
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|MAX_CODE_ALIGN
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
name|align_tab
index|[
name|i
index|]
operator|=
name|NULL_RTX
expr_stmt|;
name|seq
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
for|for
control|(
init|;
name|seq
condition|;
name|seq
operator|=
name|PREV_INSN
argument_list|(
name|seq
argument_list|)
control|)
block|{
name|int
name|uid
init|=
name|INSN_UID
argument_list|(
name|seq
argument_list|)
decl_stmt|;
name|int
name|log
decl_stmt|;
name|log
operator|=
operator|(
name|GET_CODE
argument_list|(
name|seq
argument_list|)
operator|==
name|CODE_LABEL
condition|?
name|LABEL_TO_ALIGNMENT
argument_list|(
name|seq
argument_list|)
else|:
literal|0
operator|)
expr_stmt|;
name|uid_align
index|[
name|uid
index|]
operator|=
name|align_tab
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|log
condition|)
block|{
comment|/* Found an alignment label.  */
name|uid_align
index|[
name|uid
index|]
operator|=
name|align_tab
index|[
name|log
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|log
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|align_tab
index|[
name|i
index|]
operator|=
name|seq
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|CASE_VECTOR_SHORTEN_MODE
if|if
condition|(
name|optimize
condition|)
block|{
comment|/* Look for ADDR_DIFF_VECs, and initialize their minimum and maximum          label fields.  */
name|int
name|min_shuid
init|=
name|INSN_SHUID
argument_list|(
name|get_insns
argument_list|()
argument_list|)
operator|-
literal|1
decl_stmt|;
name|int
name|max_shuid
init|=
name|INSN_SHUID
argument_list|(
name|get_last_insn
argument_list|()
argument_list|)
operator|+
literal|1
decl_stmt|;
name|int
name|rel
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|first
init|;
name|insn
operator|!=
literal|0
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|rtx
name|min_lab
init|=
name|NULL_RTX
decl_stmt|,
name|max_lab
init|=
name|NULL_RTX
decl_stmt|,
name|pat
decl_stmt|;
name|int
name|len
decl_stmt|,
name|i
decl_stmt|,
name|min
decl_stmt|,
name|max
decl_stmt|,
name|insn_shuid
decl_stmt|;
name|int
name|min_align
decl_stmt|;
name|addr_diff_vec_flags
name|flags
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|JUMP_INSN
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|ADDR_DIFF_VEC
condition|)
continue|continue;
name|pat
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|len
operator|=
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|min_align
operator|=
name|MAX_CODE_ALIGN
expr_stmt|;
for|for
control|(
name|min
operator|=
name|max_shuid
operator|,
name|max
operator|=
name|min_shuid
operator|,
name|i
operator|=
name|len
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|rtx
name|lab
init|=
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|1
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|shuid
init|=
name|INSN_SHUID
argument_list|(
name|lab
argument_list|)
decl_stmt|;
if|if
condition|(
name|shuid
operator|<
name|min
condition|)
block|{
name|min
operator|=
name|shuid
expr_stmt|;
name|min_lab
operator|=
name|lab
expr_stmt|;
block|}
if|if
condition|(
name|shuid
operator|>
name|max
condition|)
block|{
name|max
operator|=
name|shuid
expr_stmt|;
name|max_lab
operator|=
name|lab
expr_stmt|;
block|}
if|if
condition|(
name|min_align
operator|>
name|LABEL_TO_ALIGNMENT
argument_list|(
name|lab
argument_list|)
condition|)
name|min_align
operator|=
name|LABEL_TO_ALIGNMENT
argument_list|(
name|lab
argument_list|)
expr_stmt|;
block|}
name|XEXP
argument_list|(
name|pat
argument_list|,
literal|2
argument_list|)
operator|=
name|gen_rtx_LABEL_REF
argument_list|(
name|VOIDmode
argument_list|,
name|min_lab
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|pat
argument_list|,
literal|3
argument_list|)
operator|=
name|gen_rtx_LABEL_REF
argument_list|(
name|VOIDmode
argument_list|,
name|max_lab
argument_list|)
expr_stmt|;
name|insn_shuid
operator|=
name|INSN_SHUID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|rel
operator|=
name|INSN_SHUID
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|flags
operator|.
name|min_align
operator|=
name|min_align
expr_stmt|;
name|flags
operator|.
name|base_after_vec
operator|=
name|rel
operator|>
name|insn_shuid
expr_stmt|;
name|flags
operator|.
name|min_after_vec
operator|=
name|min
operator|>
name|insn_shuid
expr_stmt|;
name|flags
operator|.
name|max_after_vec
operator|=
name|max
operator|>
name|insn_shuid
expr_stmt|;
name|flags
operator|.
name|min_after_base
operator|=
name|min
operator|>
name|rel
expr_stmt|;
name|flags
operator|.
name|max_after_base
operator|=
name|max
operator|>
name|rel
expr_stmt|;
name|ADDR_DIFF_VEC_FLAGS
argument_list|(
name|pat
argument_list|)
operator|=
name|flags
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* CASE_VECTOR_SHORTEN_MODE */
comment|/* Compute initial lengths, addresses, and varying flags for each insn.  */
for|for
control|(
name|insn_current_address
operator|=
name|FIRST_INSN_ADDRESS
operator|,
name|insn
operator|=
name|first
init|;
name|insn
operator|!=
literal|0
condition|;
name|insn_current_address
operator|+=
name|insn_lengths
index|[
name|uid
index|]
operator|,
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|uid
operator|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|insn_lengths
index|[
name|uid
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
block|{
name|int
name|log
init|=
name|LABEL_TO_ALIGNMENT
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|log
condition|)
block|{
name|int
name|align
init|=
literal|1
operator|<<
name|log
decl_stmt|;
name|int
name|new_address
init|=
operator|(
name|insn_current_address
operator|+
name|align
operator|-
literal|1
operator|)
operator|&
operator|-
name|align
decl_stmt|;
name|insn_lengths
index|[
name|uid
index|]
operator|=
name|new_address
operator|-
name|insn_current_address
expr_stmt|;
name|insn_current_address
operator|=
name|new_address
expr_stmt|;
block|}
block|}
name|insn_addresses
index|[
name|uid
index|]
operator|=
name|insn_current_address
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|BARRIER
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
continue|continue;
if|if
condition|(
name|INSN_DELETED_P
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
name|body
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|ADDR_VEC
operator|||
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|ADDR_DIFF_VEC
condition|)
block|{
comment|/* This only takes room if read-only data goes into the text 	     section.  */
if|if
condition|(
name|JUMP_TABLES_IN_TEXT_SECTION
if|#
directive|if
operator|!
name|defined
argument_list|(
name|READONLY_DATA_SECTION
argument_list|)
operator|||
literal|1
endif|#
directive|endif
condition|)
name|insn_lengths
index|[
name|uid
index|]
operator|=
operator|(
name|XVECLEN
argument_list|(
name|body
argument_list|,
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|ADDR_DIFF_VEC
argument_list|)
operator|*
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|body
argument_list|)
argument_list|)
operator|)
expr_stmt|;
comment|/* Alignment is handled by ADDR_VEC_ALIGN.  */
block|}
elseif|else
if|if
condition|(
name|asm_noperands
argument_list|(
name|body
argument_list|)
operator|>=
literal|0
condition|)
name|insn_lengths
index|[
name|uid
index|]
operator|=
name|asm_insn_count
argument_list|(
name|body
argument_list|)
operator|*
name|insn_default_length
argument_list|(
name|insn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|SEQUENCE
condition|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|const_delay_slots
decl_stmt|;
ifdef|#
directive|ifdef
name|DELAY_SLOTS
name|const_delay_slots
operator|=
name|const_num_delay_slots
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|const_delay_slots
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* Inside a delay slot sequence, we do not do any branch shortening 	     if the shortening could change the number of delay slots 	     of the branch.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|inner_insn
init|=
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|int
name|inner_uid
init|=
name|INSN_UID
argument_list|(
name|inner_insn
argument_list|)
decl_stmt|;
name|int
name|inner_length
decl_stmt|;
if|if
condition|(
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
name|inner_length
operator|=
operator|(
name|asm_insn_count
argument_list|(
name|PATTERN
argument_list|(
name|inner_insn
argument_list|)
argument_list|)
operator|*
name|insn_default_length
argument_list|(
name|inner_insn
argument_list|)
operator|)
expr_stmt|;
else|else
name|inner_length
operator|=
name|insn_default_length
argument_list|(
name|inner_insn
argument_list|)
expr_stmt|;
name|insn_lengths
index|[
name|inner_uid
index|]
operator|=
name|inner_length
expr_stmt|;
if|if
condition|(
name|const_delay_slots
condition|)
block|{
if|if
condition|(
operator|(
name|varying_length
index|[
name|inner_uid
index|]
operator|=
name|insn_variable_length_p
argument_list|(
name|inner_insn
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|varying_length
index|[
name|uid
index|]
operator|=
literal|1
expr_stmt|;
name|insn_addresses
index|[
name|inner_uid
index|]
operator|=
operator|(
name|insn_current_address
operator|+
name|insn_lengths
index|[
name|uid
index|]
operator|)
expr_stmt|;
block|}
else|else
name|varying_length
index|[
name|inner_uid
index|]
operator|=
literal|0
expr_stmt|;
name|insn_lengths
index|[
name|uid
index|]
operator|+=
name|inner_length
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|!=
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|!=
name|CLOBBER
condition|)
block|{
name|insn_lengths
index|[
name|uid
index|]
operator|=
name|insn_default_length
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|varying_length
index|[
name|uid
index|]
operator|=
name|insn_variable_length_p
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* If needed, do any adjustment.  */
ifdef|#
directive|ifdef
name|ADJUST_INSN_LENGTH
name|ADJUST_INSN_LENGTH
argument_list|(
name|insn
argument_list|,
name|insn_lengths
index|[
name|uid
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn_lengths
index|[
name|uid
index|]
operator|<
literal|0
condition|)
name|fatal_insn
argument_list|(
literal|"Negative insn length"
argument_list|,
name|insn
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Now loop over all the insns finding varying length insns.  For each,      get the current insn length.  If it has changed, reflect the change.      When nothing changes for a full pass, we are done.  */
while|while
condition|(
name|something_changed
condition|)
block|{
name|something_changed
operator|=
literal|0
expr_stmt|;
name|insn_current_align
operator|=
name|MAX_CODE_ALIGN
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|insn_current_address
operator|=
name|FIRST_INSN_ADDRESS
operator|,
name|insn
operator|=
name|first
init|;
name|insn
operator|!=
literal|0
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|int
name|new_length
decl_stmt|;
ifdef|#
directive|ifdef
name|ADJUST_INSN_LENGTH
name|int
name|tmp_length
decl_stmt|;
endif|#
directive|endif
name|int
name|length_align
decl_stmt|;
name|uid
operator|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
block|{
name|int
name|log
init|=
name|LABEL_TO_ALIGNMENT
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|log
operator|>
name|insn_current_align
condition|)
block|{
name|int
name|align
init|=
literal|1
operator|<<
name|log
decl_stmt|;
name|int
name|new_address
init|=
operator|(
name|insn_current_address
operator|+
name|align
operator|-
literal|1
operator|)
operator|&
operator|-
name|align
decl_stmt|;
name|insn_lengths
index|[
name|uid
index|]
operator|=
name|new_address
operator|-
name|insn_current_address
expr_stmt|;
name|insn_current_align
operator|=
name|log
expr_stmt|;
name|insn_current_address
operator|=
name|new_address
expr_stmt|;
block|}
else|else
name|insn_lengths
index|[
name|uid
index|]
operator|=
literal|0
expr_stmt|;
name|insn_addresses
index|[
name|uid
index|]
operator|=
name|insn_current_address
expr_stmt|;
continue|continue;
block|}
name|length_align
operator|=
name|INSN_LENGTH_ALIGNMENT
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|length_align
operator|<
name|insn_current_align
condition|)
name|insn_current_align
operator|=
name|length_align
expr_stmt|;
name|insn_last_address
operator|=
name|insn_addresses
index|[
name|uid
index|]
expr_stmt|;
name|insn_addresses
index|[
name|uid
index|]
operator|=
name|insn_current_address
expr_stmt|;
ifdef|#
directive|ifdef
name|CASE_VECTOR_SHORTEN_MODE
if|if
condition|(
name|optimize
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
condition|)
block|{
name|rtx
name|body
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|int
name|old_length
init|=
name|insn_lengths
index|[
name|uid
index|]
decl_stmt|;
name|rtx
name|rel_lab
init|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|min_lab
init|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|body
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|max_lab
init|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|body
argument_list|,
literal|3
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|addr_diff_vec_flags
name|flags
init|=
name|ADDR_DIFF_VEC_FLAGS
argument_list|(
name|body
argument_list|)
decl_stmt|;
name|int
name|rel_addr
init|=
name|insn_addresses
index|[
name|INSN_UID
argument_list|(
name|rel_lab
argument_list|)
index|]
decl_stmt|;
name|int
name|min_addr
init|=
name|insn_addresses
index|[
name|INSN_UID
argument_list|(
name|min_lab
argument_list|)
index|]
decl_stmt|;
name|int
name|max_addr
init|=
name|insn_addresses
index|[
name|INSN_UID
argument_list|(
name|max_lab
argument_list|)
index|]
decl_stmt|;
name|rtx
name|prev
decl_stmt|;
name|int
name|rel_align
init|=
literal|0
decl_stmt|;
comment|/* Try to find a known alignment for rel_lab.  */
for|for
control|(
name|prev
operator|=
name|rel_lab
init|;
name|prev
operator|&&
operator|!
name|insn_lengths
index|[
name|INSN_UID
argument_list|(
name|prev
argument_list|)
index|]
operator|&&
operator|!
operator|(
name|varying_length
index|[
name|INSN_UID
argument_list|(
name|prev
argument_list|)
index|]
operator|&
literal|1
operator|)
condition|;
name|prev
operator|=
name|PREV_INSN
argument_list|(
name|prev
argument_list|)
control|)
if|if
condition|(
name|varying_length
index|[
name|INSN_UID
argument_list|(
name|prev
argument_list|)
index|]
operator|&
literal|2
condition|)
block|{
name|rel_align
operator|=
name|LABEL_TO_ALIGNMENT
argument_list|(
name|prev
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* See the comment on addr_diff_vec_flags in rtl.h for the 		 meaning of the flags values.  base: REL_LAB   vec: INSN  */
comment|/* Anything after INSN has still addresses from the last 		 pass; adjust these so that they reflect our current 		 estimate for this pass.  */
if|if
condition|(
name|flags
operator|.
name|base_after_vec
condition|)
name|rel_addr
operator|+=
name|insn_current_address
operator|-
name|insn_last_address
expr_stmt|;
if|if
condition|(
name|flags
operator|.
name|min_after_vec
condition|)
name|min_addr
operator|+=
name|insn_current_address
operator|-
name|insn_last_address
expr_stmt|;
if|if
condition|(
name|flags
operator|.
name|max_after_vec
condition|)
name|max_addr
operator|+=
name|insn_current_address
operator|-
name|insn_last_address
expr_stmt|;
comment|/* We want to know the worst case, i.e. lowest possible value 		 for the offset of MIN_LAB.  If MIN_LAB is after REL_LAB, 		 its offset is positive, and we have to be wary of code shrink; 		 otherwise, it is negative, and we have to be vary of code 		 size increase.  */
if|if
condition|(
name|flags
operator|.
name|min_after_base
condition|)
block|{
comment|/* If INSN is between REL_LAB and MIN_LAB, the size 		     changes we are about to make can change the alignment 		     within the observed offset, therefore we have to break 		     it up into two parts that are independent.  */
if|if
condition|(
operator|!
name|flags
operator|.
name|base_after_vec
operator|&&
name|flags
operator|.
name|min_after_vec
condition|)
block|{
name|min_addr
operator|-=
name|align_fuzz
argument_list|(
name|rel_lab
argument_list|,
name|insn
argument_list|,
name|rel_align
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|min_addr
operator|-=
name|align_fuzz
argument_list|(
name|insn
argument_list|,
name|min_lab
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|min_addr
operator|-=
name|align_fuzz
argument_list|(
name|rel_lab
argument_list|,
name|min_lab
argument_list|,
name|rel_align
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|flags
operator|.
name|base_after_vec
operator|&&
operator|!
name|flags
operator|.
name|min_after_vec
condition|)
block|{
name|min_addr
operator|-=
name|align_fuzz
argument_list|(
name|min_lab
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
name|min_addr
operator|-=
name|align_fuzz
argument_list|(
name|insn
argument_list|,
name|rel_lab
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|min_addr
operator|-=
name|align_fuzz
argument_list|(
name|min_lab
argument_list|,
name|rel_lab
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Likewise, determine the highest lowest possible value 		 for the offset of MAX_LAB.  */
if|if
condition|(
name|flags
operator|.
name|max_after_base
condition|)
block|{
if|if
condition|(
operator|!
name|flags
operator|.
name|base_after_vec
operator|&&
name|flags
operator|.
name|max_after_vec
condition|)
block|{
name|max_addr
operator|+=
name|align_fuzz
argument_list|(
name|rel_lab
argument_list|,
name|insn
argument_list|,
name|rel_align
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
name|max_addr
operator|+=
name|align_fuzz
argument_list|(
name|insn
argument_list|,
name|max_lab
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|max_addr
operator|+=
name|align_fuzz
argument_list|(
name|rel_lab
argument_list|,
name|max_lab
argument_list|,
name|rel_align
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|flags
operator|.
name|base_after_vec
operator|&&
operator|!
name|flags
operator|.
name|max_after_vec
condition|)
block|{
name|max_addr
operator|+=
name|align_fuzz
argument_list|(
name|max_lab
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|max_addr
operator|+=
name|align_fuzz
argument_list|(
name|insn
argument_list|,
name|rel_lab
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|max_addr
operator|+=
name|align_fuzz
argument_list|(
name|max_lab
argument_list|,
name|rel_lab
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|PUT_MODE
argument_list|(
name|body
argument_list|,
name|CASE_VECTOR_SHORTEN_MODE
argument_list|(
name|min_addr
operator|-
name|rel_addr
argument_list|,
name|max_addr
operator|-
name|rel_addr
argument_list|,
name|body
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|JUMP_TABLES_IN_TEXT_SECTION
if|#
directive|if
operator|!
name|defined
argument_list|(
name|READONLY_DATA_SECTION
argument_list|)
operator|||
literal|1
endif|#
directive|endif
condition|)
block|{
name|insn_lengths
index|[
name|uid
index|]
operator|=
operator|(
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|1
argument_list|)
operator|*
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|body
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|insn_current_address
operator|+=
name|insn_lengths
index|[
name|uid
index|]
expr_stmt|;
if|if
condition|(
name|insn_lengths
index|[
name|uid
index|]
operator|!=
name|old_length
condition|)
name|something_changed
operator|=
literal|1
expr_stmt|;
block|}
continue|continue;
block|}
endif|#
directive|endif
comment|/* CASE_VECTOR_SHORTEN_MODE */
if|if
condition|(
operator|!
operator|(
name|varying_length
index|[
name|uid
index|]
operator|)
condition|)
block|{
name|insn_current_address
operator|+=
name|insn_lengths
index|[
name|uid
index|]
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
condition|)
block|{
name|int
name|i
decl_stmt|;
name|body
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|new_length
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|inner_insn
init|=
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|int
name|inner_uid
init|=
name|INSN_UID
argument_list|(
name|inner_insn
argument_list|)
decl_stmt|;
name|int
name|inner_length
decl_stmt|;
name|insn_addresses
index|[
name|inner_uid
index|]
operator|=
name|insn_current_address
expr_stmt|;
comment|/* insn_current_length returns 0 for insns with a 		     non-varying length.  */
if|if
condition|(
operator|!
name|varying_length
index|[
name|inner_uid
index|]
condition|)
name|inner_length
operator|=
name|insn_lengths
index|[
name|inner_uid
index|]
expr_stmt|;
else|else
name|inner_length
operator|=
name|insn_current_length
argument_list|(
name|inner_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|inner_length
operator|!=
name|insn_lengths
index|[
name|inner_uid
index|]
condition|)
block|{
name|insn_lengths
index|[
name|inner_uid
index|]
operator|=
name|inner_length
expr_stmt|;
name|something_changed
operator|=
literal|1
expr_stmt|;
block|}
name|insn_current_address
operator|+=
name|insn_lengths
index|[
name|inner_uid
index|]
expr_stmt|;
name|new_length
operator|+=
name|inner_length
expr_stmt|;
block|}
block|}
else|else
block|{
name|new_length
operator|=
name|insn_current_length
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|insn_current_address
operator|+=
name|new_length
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ADJUST_INSN_LENGTH
comment|/* If needed, do any adjustment.  */
name|tmp_length
operator|=
name|new_length
expr_stmt|;
name|ADJUST_INSN_LENGTH
argument_list|(
name|insn
argument_list|,
name|new_length
argument_list|)
expr_stmt|;
name|insn_current_address
operator|+=
operator|(
name|new_length
operator|-
name|tmp_length
operator|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|new_length
operator|!=
name|insn_lengths
index|[
name|uid
index|]
condition|)
block|{
name|insn_lengths
index|[
name|uid
index|]
operator|=
name|new_length
expr_stmt|;
name|something_changed
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* For a non-optimizing compile, do only a single pass.  */
if|if
condition|(
operator|!
name|optimize
condition|)
break|break;
block|}
name|free
argument_list|(
name|varying_length
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_ATTR_length */
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ATTR_length
end_ifdef

begin_comment
comment|/* Given the body of an INSN known to be generated by an ASM statement, return    the number of machine instructions likely to be generated for this insn.    This is used to compute its length.  */
end_comment

begin_function
specifier|static
name|int
name|asm_insn_count
parameter_list|(
name|body
parameter_list|)
name|rtx
name|body
decl_stmt|;
block|{
name|char
modifier|*
name|template
decl_stmt|;
name|int
name|count
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|ASM_INPUT
condition|)
name|template
operator|=
name|XSTR
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|template
operator|=
name|decode_asm_operands
argument_list|(
name|body
argument_list|,
name|NULL_PTR
argument_list|,
name|NULL_PTR
argument_list|,
name|NULL_PTR
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|*
name|template
condition|;
name|template
operator|++
control|)
if|if
condition|(
name|IS_ASM_LOGICAL_LINE_SEPARATOR
argument_list|(
operator|*
name|template
argument_list|)
operator|||
operator|*
name|template
operator|==
literal|'\n'
condition|)
name|count
operator|++
expr_stmt|;
return|return
name|count
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Output assembler code for the start of a function,    and initialize some of the variables in this file    for the new function.  The label for the function and associated    assembler pseudo-ops have already been output in `assemble_start_function'.     FIRST is the first insn of the rtl for the function being compiled.    FILE is the file to write assembler code to.    OPTIMIZE is nonzero if we should eliminate redundant      test and compare insns.  */
end_comment

begin_function
name|void
name|final_start_function
parameter_list|(
name|first
parameter_list|,
name|file
parameter_list|,
name|optimize
parameter_list|)
name|rtx
name|first
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|optimize
decl_stmt|;
block|{
name|block_depth
operator|=
literal|0
expr_stmt|;
name|this_is_asm_operands
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|NON_SAVING_SETJMP
comment|/* A function that calls setjmp should save and restore all the      call-saved registers on a system where longjmp clobbers them.  */
if|if
condition|(
name|NON_SAVING_SETJMP
operator|&&
name|current_function_calls_setjmp
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|call_used_regs
index|[
name|i
index|]
condition|)
name|regs_ever_live
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Initial line number is supposed to be output      before the function's prologue and label      so that the function's address will not appear to be      in the last statement of the preceding function.  */
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|first
argument_list|)
operator|!=
name|NOTE_INSN_DELETED
condition|)
name|last_linenum
operator|=
name|high_block_linenum
operator|=
name|high_function_linenum
operator|=
name|NOTE_LINE_NUMBER
argument_list|(
name|first
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DWARF2_UNWIND_INFO
argument_list|)
operator|||
name|defined
argument_list|(
name|DWARF2_DEBUGGING_INFO
argument_list|)
comment|/* Output DWARF definition of the function.  */
if|if
condition|(
name|dwarf2out_do_frame
argument_list|()
condition|)
name|dwarf2out_begin_prologue
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* For SDB and XCOFF, the function beginning must be marked between      the function label and the prologue.  We always need this, even when      -g1 was used.  Defer on MIPS systems so that parameter descriptions      follow function entry.  */
if|#
directive|if
name|defined
argument_list|(
name|SDB_DEBUGGING_INFO
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|MIPS_DEBUGGING_INFO
argument_list|)
if|if
condition|(
name|write_symbols
operator|==
name|SDB_DEBUG
condition|)
name|sdbout_begin_function
argument_list|(
name|last_linenum
argument_list|)
expr_stmt|;
elseif|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|XCOFF_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|XCOFF_DEBUG
condition|)
name|xcoffout_begin_function
argument_list|(
name|file
argument_list|,
name|last_linenum
argument_list|)
expr_stmt|;
elseif|else
endif|#
directive|endif
comment|/* But only output line number for other debug info types if -g2 	 or better.  */
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|first
argument_list|)
operator|!=
name|NOTE_INSN_DELETED
condition|)
name|output_source_line
argument_list|(
name|file
argument_list|,
name|first
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LEAF_REG_REMAP
if|if
condition|(
name|current_function_uses_only_leaf_regs
condition|)
name|leaf_renumber_regs
argument_list|(
name|first
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|profile_block_flag
condition|)
name|add_bb
argument_list|(
name|file
argument_list|)
expr_stmt|;
comment|/* The Sun386i and perhaps other machines don't work right      if the profiling code comes after the prologue.  */
ifdef|#
directive|ifdef
name|PROFILE_BEFORE_PROLOGUE
if|if
condition|(
name|profile_flag
condition|)
name|profile_function
argument_list|(
name|file
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PROFILE_BEFORE_PROLOGUE */
if|#
directive|if
name|defined
argument_list|(
name|DWARF2_UNWIND_INFO
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_prologue
argument_list|)
if|if
condition|(
name|dwarf2out_do_frame
argument_list|()
condition|)
name|dwarf2out_frame_debug
argument_list|(
name|NULL_RTX
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|FUNCTION_PROLOGUE
comment|/* First output the function prologue: code to set up the stack frame.  */
name|FUNCTION_PROLOGUE
argument_list|(
name|file
argument_list|,
name|get_frame_size
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SDB_DEBUGGING_INFO
argument_list|)
operator|||
name|defined
argument_list|(
name|XCOFF_DEBUGGING_INFO
argument_list|)
if|if
condition|(
name|write_symbols
operator|==
name|SDB_DEBUG
operator|||
name|write_symbols
operator|==
name|XCOFF_DEBUG
condition|)
name|next_block_index
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* If the machine represents the prologue as RTL, the profiling code must      be emitted when NOTE_INSN_PROLOGUE_END is scanned.  */
ifdef|#
directive|ifdef
name|HAVE_prologue
if|if
condition|(
operator|!
name|HAVE_prologue
condition|)
endif|#
directive|endif
name|profile_after_prologue
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|profile_label_no
operator|++
expr_stmt|;
comment|/* If we are doing basic block profiling, remember a printable version      of the function name.  */
if|if
condition|(
name|profile_block_flag
condition|)
block|{
name|bb_func_label_num
operator|=
name|add_bb_string
argument_list|(
call|(
modifier|*
name|decl_printable_name
call|)
argument_list|(
name|current_function_decl
argument_list|,
literal|2
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|profile_after_prologue
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|FUNCTION_BLOCK_PROFILER
if|if
condition|(
name|profile_block_flag
condition|)
block|{
name|FUNCTION_BLOCK_PROFILER
argument_list|(
name|file
argument_list|,
name|count_basic_blocks
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* FUNCTION_BLOCK_PROFILER */
ifndef|#
directive|ifndef
name|PROFILE_BEFORE_PROLOGUE
if|if
condition|(
name|profile_flag
condition|)
name|profile_function
argument_list|(
name|file
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not PROFILE_BEFORE_PROLOGUE */
block|}
end_function

begin_function
specifier|static
name|void
name|profile_function
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|NO_PROFILE_COUNTERS
name|int
name|align
init|=
name|MIN
argument_list|(
name|BIGGEST_ALIGNMENT
argument_list|,
name|LONG_TYPE_SIZE
argument_list|)
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ASM_OUTPUT_REG_PUSH
argument_list|)
if|#
directive|if
name|defined
argument_list|(
name|STRUCT_VALUE_INCOMING_REGNUM
argument_list|)
operator|||
name|defined
argument_list|(
name|STRUCT_VALUE_REGNUM
argument_list|)
name|int
name|sval
init|=
name|current_function_returns_struct
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|STATIC_CHAIN_INCOMING_REGNUM
argument_list|)
operator|||
name|defined
argument_list|(
name|STATIC_CHAIN_REGNUM
argument_list|)
name|int
name|cxt
init|=
name|current_function_needs_context
decl_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* ASM_OUTPUT_REG_PUSH */
ifndef|#
directive|ifndef
name|NO_PROFILE_COUNTERS
name|data_section
argument_list|()
expr_stmt|;
name|ASM_OUTPUT_ALIGN
argument_list|(
name|file
argument_list|,
name|floor_log2
argument_list|(
name|align
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|file
argument_list|,
literal|"LP"
argument_list|,
name|profile_label_no
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|const0_rtx
argument_list|,
name|LONG_TYPE_SIZE
operator|/
name|BITS_PER_UNIT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|function_section
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|STRUCT_VALUE_INCOMING_REGNUM
argument_list|)
operator|&&
name|defined
argument_list|(
name|ASM_OUTPUT_REG_PUSH
argument_list|)
if|if
condition|(
name|sval
condition|)
name|ASM_OUTPUT_REG_PUSH
argument_list|(
name|file
argument_list|,
name|STRUCT_VALUE_INCOMING_REGNUM
argument_list|)
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|STRUCT_VALUE_REGNUM
argument_list|)
operator|&&
name|defined
argument_list|(
name|ASM_OUTPUT_REG_PUSH
argument_list|)
if|if
condition|(
name|sval
condition|)
block|{
name|ASM_OUTPUT_REG_PUSH
argument_list|(
name|file
argument_list|,
name|STRUCT_VALUE_REGNUM
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|STATIC_CHAIN_INCOMING_REGNUM
argument_list|)
operator|&&
name|defined
argument_list|(
name|ASM_OUTPUT_REG_PUSH
argument_list|)
if|if
condition|(
name|cxt
condition|)
name|ASM_OUTPUT_REG_PUSH
argument_list|(
name|file
argument_list|,
name|STATIC_CHAIN_INCOMING_REGNUM
argument_list|)
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|STATIC_CHAIN_REGNUM
argument_list|)
operator|&&
name|defined
argument_list|(
name|ASM_OUTPUT_REG_PUSH
argument_list|)
if|if
condition|(
name|cxt
condition|)
block|{
name|ASM_OUTPUT_REG_PUSH
argument_list|(
name|file
argument_list|,
name|STATIC_CHAIN_REGNUM
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
name|FUNCTION_PROFILER
argument_list|(
name|file
argument_list|,
name|profile_label_no
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|STATIC_CHAIN_INCOMING_REGNUM
argument_list|)
operator|&&
name|defined
argument_list|(
name|ASM_OUTPUT_REG_PUSH
argument_list|)
if|if
condition|(
name|cxt
condition|)
name|ASM_OUTPUT_REG_POP
argument_list|(
name|file
argument_list|,
name|STATIC_CHAIN_INCOMING_REGNUM
argument_list|)
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|STATIC_CHAIN_REGNUM
argument_list|)
operator|&&
name|defined
argument_list|(
name|ASM_OUTPUT_REG_PUSH
argument_list|)
if|if
condition|(
name|cxt
condition|)
block|{
name|ASM_OUTPUT_REG_POP
argument_list|(
name|file
argument_list|,
name|STATIC_CHAIN_REGNUM
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|STRUCT_VALUE_INCOMING_REGNUM
argument_list|)
operator|&&
name|defined
argument_list|(
name|ASM_OUTPUT_REG_PUSH
argument_list|)
if|if
condition|(
name|sval
condition|)
name|ASM_OUTPUT_REG_POP
argument_list|(
name|file
argument_list|,
name|STRUCT_VALUE_INCOMING_REGNUM
argument_list|)
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|STRUCT_VALUE_REGNUM
argument_list|)
operator|&&
name|defined
argument_list|(
name|ASM_OUTPUT_REG_PUSH
argument_list|)
if|if
condition|(
name|sval
condition|)
block|{
name|ASM_OUTPUT_REG_POP
argument_list|(
name|file
argument_list|,
name|STRUCT_VALUE_REGNUM
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Output assembler code for the end of a function.    For clarity, args are same as those of `final_start_function'    even though not all of them are needed.  */
end_comment

begin_function
name|void
name|final_end_function
parameter_list|(
name|first
parameter_list|,
name|file
parameter_list|,
name|optimize
parameter_list|)
name|rtx
name|first
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|optimize
decl_stmt|;
block|{
if|if
condition|(
name|app_on
condition|)
block|{
name|fputs
argument_list|(
name|ASM_APP_OFF
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|app_on
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SDB_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|SDB_DEBUG
condition|)
name|sdbout_end_function
argument_list|(
name|high_function_linenum
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DWARF_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|DWARF_DEBUG
condition|)
name|dwarfout_end_function
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|XCOFF_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|XCOFF_DEBUG
condition|)
name|xcoffout_end_function
argument_list|(
name|file
argument_list|,
name|high_function_linenum
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|FUNCTION_EPILOGUE
comment|/* Finally, output the function epilogue:      code to restore the stack frame and return to the caller.  */
name|FUNCTION_EPILOGUE
argument_list|(
name|file
argument_list|,
name|get_frame_size
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|profile_block_flag
condition|)
name|add_bb
argument_list|(
name|file
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SDB_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|SDB_DEBUG
condition|)
name|sdbout_end_epilogue
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DWARF_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|DWARF_DEBUG
condition|)
name|dwarfout_end_epilogue
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|DWARF2_UNWIND_INFO
argument_list|)
operator|||
name|defined
argument_list|(
name|DWARF2_DEBUGGING_INFO
argument_list|)
if|if
condition|(
name|dwarf2out_do_frame
argument_list|()
condition|)
name|dwarf2out_end_epilogue
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|XCOFF_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|XCOFF_DEBUG
condition|)
name|xcoffout_end_epilogue
argument_list|(
name|file
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bb_func_label_num
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* not in function, nuke label # */
comment|/* If FUNCTION_EPILOGUE is not defined, then the function body      itself contains return instructions wherever needed.  */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add a block to the linked list that remembers the current line/file/function    for basic block profiling.  Emit the label in front of the basic block and    the instructions that increment the count field.  */
end_comment

begin_function
specifier|static
name|void
name|add_bb
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|struct
name|bb_list
modifier|*
name|ptr
init|=
operator|(
expr|struct
name|bb_list
operator|*
operator|)
name|permalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|bb_list
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Add basic block to linked list.  */
name|ptr
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|ptr
operator|->
name|line_num
operator|=
name|last_linenum
expr_stmt|;
name|ptr
operator|->
name|file_label_num
operator|=
name|bb_file_label_num
expr_stmt|;
name|ptr
operator|->
name|func_label_num
operator|=
name|bb_func_label_num
expr_stmt|;
operator|*
name|bb_tail
operator|=
name|ptr
expr_stmt|;
name|bb_tail
operator|=
operator|&
name|ptr
operator|->
name|next
expr_stmt|;
comment|/* Enable the table of basic-block use counts      to point at the code it applies to.  */
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|file
argument_list|,
literal|"LPB"
argument_list|,
name|count_basic_blocks
argument_list|)
expr_stmt|;
comment|/* Before first insn of this basic block, increment the      count of times it was entered.  */
ifdef|#
directive|ifdef
name|BLOCK_PROFILER
name|BLOCK_PROFILER
argument_list|(
name|file
argument_list|,
name|count_basic_blocks
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_cc0
name|CC_STATUS_INIT
expr_stmt|;
endif|#
directive|endif
name|new_block
operator|=
literal|0
expr_stmt|;
name|count_basic_blocks
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a string to be used for basic block profiling.  */
end_comment

begin_function
specifier|static
name|int
name|add_bb_string
parameter_list|(
name|string
parameter_list|,
name|perm_p
parameter_list|)
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|perm_p
decl_stmt|;
block|{
name|int
name|len
decl_stmt|;
name|struct
name|bb_str
modifier|*
name|ptr
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|string
condition|)
block|{
name|string
operator|=
literal|"<unknown>"
expr_stmt|;
name|perm_p
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* Allocate a new string if the current string isn't permanent.  If      the string is permanent search for the same string in other      allocations.  */
name|len
operator|=
name|strlen
argument_list|(
name|string
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|perm_p
condition|)
block|{
name|char
modifier|*
name|p
init|=
operator|(
name|char
operator|*
operator|)
name|permalloc
argument_list|(
name|len
argument_list|)
decl_stmt|;
name|bcopy
argument_list|(
name|string
argument_list|,
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|string
operator|=
name|p
expr_stmt|;
block|}
else|else
for|for
control|(
name|ptr
operator|=
name|sbb_head
init|;
name|ptr
operator|!=
operator|(
expr|struct
name|bb_str
operator|*
operator|)
literal|0
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
if|if
condition|(
name|ptr
operator|->
name|string
operator|==
name|string
condition|)
break|break;
comment|/* Allocate a new string block if we need to.  */
if|if
condition|(
operator|!
name|ptr
condition|)
block|{
name|ptr
operator|=
operator|(
expr|struct
name|bb_str
operator|*
operator|)
name|permalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|ptr
operator|->
name|length
operator|=
name|len
expr_stmt|;
name|ptr
operator|->
name|label_num
operator|=
name|sbb_label_num
operator|++
expr_stmt|;
name|ptr
operator|->
name|string
operator|=
name|string
expr_stmt|;
operator|*
name|sbb_tail
operator|=
name|ptr
expr_stmt|;
name|sbb_tail
operator|=
operator|&
name|ptr
operator|->
name|next
expr_stmt|;
block|}
return|return
name|ptr
operator|->
name|label_num
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output assembler code for some insns: all or part of a function.    For description of args, see `final_start_function', above.     PRESCAN is 1 if we are not really outputting,      just scanning as if we were outputting.    Prescanning deletes and rearranges insns just like ordinary output.    PRESCAN is -2 if we are outputting after having prescanned.    In this case, don't try to delete or rearrange insns    because that has already been done.    Prescanning is done only on certain machines.  */
end_comment

begin_function
name|void
name|final
parameter_list|(
name|first
parameter_list|,
name|file
parameter_list|,
name|optimize
parameter_list|,
name|prescan
parameter_list|)
name|rtx
name|first
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|optimize
decl_stmt|;
name|int
name|prescan
decl_stmt|;
block|{
specifier|register
name|rtx
name|insn
decl_stmt|;
name|int
name|max_line
init|=
literal|0
decl_stmt|;
name|int
name|max_uid
init|=
literal|0
decl_stmt|;
name|last_ignored_compare
operator|=
literal|0
expr_stmt|;
name|new_block
operator|=
literal|1
expr_stmt|;
name|check_exception_handler_labels
argument_list|()
expr_stmt|;
comment|/* Make a map indicating which line numbers appear in this function.      When producing SDB debugging info, delete troublesome line number      notes from inlined functions in other files as well as duplicate      line number notes.  */
ifdef|#
directive|ifdef
name|SDB_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|SDB_DEBUG
condition|)
block|{
name|rtx
name|last
init|=
literal|0
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|first
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|RTX_INTEGRATED_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
argument_list|,
name|main_input_filename
argument_list|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|last
operator|!=
literal|0
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_LINE_NUMBER
argument_list|(
name|last
argument_list|)
operator|&&
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_SOURCE_FILE
argument_list|(
name|last
argument_list|)
operator|)
condition|)
block|{
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|last
operator|=
name|insn
expr_stmt|;
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|>
name|max_line
condition|)
name|max_line
operator|=
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
block|{
for|for
control|(
name|insn
operator|=
name|first
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|>
name|max_line
condition|)
name|max_line
operator|=
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
name|line_note_exists
operator|=
operator|(
name|char
operator|*
operator|)
name|oballoc
argument_list|(
name|max_line
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|line_note_exists
argument_list|,
name|max_line
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|first
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|>
name|max_uid
condition|)
comment|/* find largest UID */
name|max_uid
operator|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|>
literal|0
condition|)
name|line_note_exists
index|[
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
index|]
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* If CC tracking across branches is enabled, record the insn which 	 jumps to each branch only reached from one place.  */
if|if
condition|(
name|optimize
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
name|rtx
name|lab
init|=
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|lab
operator|&&
name|LABEL_NUSES
argument_list|(
name|lab
argument_list|)
operator|==
literal|1
condition|)
block|{
name|LABEL_REFS
argument_list|(
name|lab
argument_list|)
operator|=
name|insn
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
comment|/* Initialize insn_eh_region table if eh is being used. */
name|init_insn_eh_region
argument_list|(
name|first
argument_list|,
name|max_uid
argument_list|)
expr_stmt|;
name|init_recog
argument_list|()
expr_stmt|;
name|CC_STATUS_INIT
expr_stmt|;
comment|/* Output the insns.  */
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|first
argument_list|)
init|;
name|insn
condition|;
control|)
block|{
ifdef|#
directive|ifdef
name|HAVE_ATTR_length
name|insn_current_address
operator|=
name|insn_addresses
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
expr_stmt|;
endif|#
directive|endif
name|insn
operator|=
name|final_scan_insn
argument_list|(
name|insn
argument_list|,
name|file
argument_list|,
name|optimize
argument_list|,
name|prescan
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Do basic-block profiling here      if the last insn was a conditional branch.  */
if|if
condition|(
name|profile_block_flag
operator|&&
name|new_block
condition|)
name|add_bb
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|free_insn_eh_region
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The final scan for one insn, INSN.    Args are same as in `final', except that INSN    is the insn being scanned.    Value returned is the next insn to be scanned.     NOPEEPHOLES is the flag to disallow peephole processing (currently    used for within delayed branch sequence output).  */
end_comment

begin_function
name|rtx
name|final_scan_insn
parameter_list|(
name|insn
parameter_list|,
name|file
parameter_list|,
name|optimize
parameter_list|,
name|prescan
parameter_list|,
name|nopeepholes
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|optimize
decl_stmt|;
name|int
name|prescan
decl_stmt|;
name|int
name|nopeepholes
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|HAVE_cc0
name|rtx
name|set
decl_stmt|;
endif|#
directive|endif
name|insn_counter
operator|++
expr_stmt|;
comment|/* Ignore deleted insns.  These can occur when we split insns (due to a      template of "#") while not optimizing.  */
if|if
condition|(
name|INSN_DELETED_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
return|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|NOTE
case|:
if|if
condition|(
name|prescan
operator|>
literal|0
condition|)
break|break;
comment|/* Align the beginning of a loop, for higher speed 	 on certain machines.  */
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
condition|)
break|break;
comment|/* This used to depend on optimize, but that was bogus.  */
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_END
condition|)
break|break;
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_EH_REGION_BEG
operator|&&
operator|!
name|exceptions_via_longjmp
condition|)
block|{
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|file
argument_list|,
literal|"LEHB"
argument_list|,
name|NOTE_BLOCK_NUMBER
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flag_new_exceptions
condition|)
name|add_eh_table_entry
argument_list|(
name|NOTE_BLOCK_NUMBER
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ASM_OUTPUT_EH_REGION_BEG
name|ASM_OUTPUT_EH_REGION_BEG
argument_list|(
name|file
argument_list|,
name|NOTE_BLOCK_NUMBER
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_EH_REGION_END
operator|&&
operator|!
name|exceptions_via_longjmp
condition|)
block|{
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|file
argument_list|,
literal|"LEHE"
argument_list|,
name|NOTE_BLOCK_NUMBER
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_new_exceptions
condition|)
name|add_eh_table_entry
argument_list|(
name|NOTE_BLOCK_NUMBER
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ASM_OUTPUT_EH_REGION_END
name|ASM_OUTPUT_EH_REGION_END
argument_list|(
name|file
argument_list|,
name|NOTE_BLOCK_NUMBER
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_PROLOGUE_END
condition|)
block|{
ifdef|#
directive|ifdef
name|FUNCTION_END_PROLOGUE
name|FUNCTION_END_PROLOGUE
argument_list|(
name|file
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|profile_after_prologue
argument_list|(
name|file
argument_list|)
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|FUNCTION_BEGIN_EPILOGUE
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_EPILOGUE_BEG
condition|)
block|{
name|FUNCTION_BEGIN_EPILOGUE
argument_list|(
name|file
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
if|if
condition|(
name|write_symbols
operator|==
name|NO_DEBUG
condition|)
break|break;
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_FUNCTION_BEG
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|SDB_DEBUGGING_INFO
argument_list|)
operator|&&
name|defined
argument_list|(
name|MIPS_DEBUGGING_INFO
argument_list|)
comment|/* MIPS stabs require the parameter descriptions to be after the 	     function entry point rather than before.  */
if|if
condition|(
name|write_symbols
operator|==
name|SDB_DEBUG
condition|)
name|sdbout_begin_function
argument_list|(
name|last_linenum
argument_list|)
expr_stmt|;
elseif|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DWARF_DEBUGGING_INFO
comment|/* This outputs a marker where the function body starts, so it 	     must be after the prologue.  */
if|if
condition|(
name|write_symbols
operator|==
name|DWARF_DEBUG
condition|)
name|dwarfout_begin_function
argument_list|()
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_DELETED
condition|)
break|break;
comment|/* An insn that was "deleted" */
if|if
condition|(
name|app_on
condition|)
block|{
name|fputs
argument_list|(
name|ASM_APP_OFF
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|app_on
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_BLOCK_BEG
operator|&&
operator|(
name|debug_info_level
operator|==
name|DINFO_LEVEL_NORMAL
operator|||
name|debug_info_level
operator|==
name|DINFO_LEVEL_VERBOSE
operator|||
name|write_symbols
operator|==
name|DWARF_DEBUG
operator|||
name|write_symbols
operator|==
name|DWARF2_DEBUG
operator|)
condition|)
block|{
comment|/* Beginning of a symbol-block.  Assign it a sequence number 	     and push the number onto the stack PENDING_BLOCKS.  */
if|if
condition|(
name|block_depth
operator|==
name|max_block_depth
condition|)
block|{
comment|/* PENDING_BLOCKS is full; make it longer.  */
name|max_block_depth
operator|*=
literal|2
expr_stmt|;
name|pending_blocks
operator|=
operator|(
name|int
operator|*
operator|)
name|xrealloc
argument_list|(
name|pending_blocks
argument_list|,
name|max_block_depth
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|pending_blocks
index|[
name|block_depth
operator|++
index|]
operator|=
name|next_block_index
expr_stmt|;
name|high_block_linenum
operator|=
name|last_linenum
expr_stmt|;
comment|/* Output debugging info about the symbol-block beginning.  */
ifdef|#
directive|ifdef
name|SDB_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|SDB_DEBUG
condition|)
name|sdbout_begin_block
argument_list|(
name|file
argument_list|,
name|last_linenum
argument_list|,
name|next_block_index
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|XCOFF_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|XCOFF_DEBUG
condition|)
name|xcoffout_begin_block
argument_list|(
name|file
argument_list|,
name|last_linenum
argument_list|,
name|next_block_index
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DBX_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|DBX_DEBUG
condition|)
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|file
argument_list|,
literal|"LBB"
argument_list|,
name|next_block_index
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DWARF_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|DWARF_DEBUG
condition|)
name|dwarfout_begin_block
argument_list|(
name|next_block_index
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DWARF2_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|DWARF2_DEBUG
condition|)
name|dwarf2out_begin_block
argument_list|(
name|next_block_index
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|next_block_index
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_BLOCK_END
operator|&&
operator|(
name|debug_info_level
operator|==
name|DINFO_LEVEL_NORMAL
operator|||
name|debug_info_level
operator|==
name|DINFO_LEVEL_VERBOSE
operator|||
name|write_symbols
operator|==
name|DWARF_DEBUG
operator|||
name|write_symbols
operator|==
name|DWARF2_DEBUG
operator|)
condition|)
block|{
comment|/* End of a symbol-block.  Pop its sequence number off 	     PENDING_BLOCKS and output debugging info based on that.  */
operator|--
name|block_depth
expr_stmt|;
if|if
condition|(
name|block_depth
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|XCOFF_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|XCOFF_DEBUG
condition|)
name|xcoffout_end_block
argument_list|(
name|file
argument_list|,
name|high_block_linenum
argument_list|,
name|pending_blocks
index|[
name|block_depth
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DBX_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|DBX_DEBUG
condition|)
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|file
argument_list|,
literal|"LBE"
argument_list|,
name|pending_blocks
index|[
name|block_depth
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SDB_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|SDB_DEBUG
condition|)
name|sdbout_end_block
argument_list|(
name|file
argument_list|,
name|high_block_linenum
argument_list|,
name|pending_blocks
index|[
name|block_depth
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DWARF_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|DWARF_DEBUG
condition|)
name|dwarfout_end_block
argument_list|(
name|pending_blocks
index|[
name|block_depth
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DWARF2_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|DWARF2_DEBUG
condition|)
name|dwarf2out_end_block
argument_list|(
name|pending_blocks
index|[
name|block_depth
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_DELETED_LABEL
operator|&&
operator|(
name|debug_info_level
operator|==
name|DINFO_LEVEL_NORMAL
operator|||
name|debug_info_level
operator|==
name|DINFO_LEVEL_VERBOSE
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DWARF_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|DWARF_DEBUG
condition|)
name|dwarfout_label
argument_list|(
name|insn
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DWARF2_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|DWARF2_DEBUG
condition|)
name|dwarf2out_label
argument_list|(
name|insn
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|>
literal|0
condition|)
comment|/* This note is a line-number.  */
block|{
specifier|register
name|rtx
name|note
decl_stmt|;
if|#
directive|if
literal|0
comment|/* This is what we used to do.  */
block|output_source_line (file, insn);
endif|#
directive|endif
name|int
name|note_after
init|=
literal|0
decl_stmt|;
comment|/* If there is anything real after this note, 	     output it.  If another line note follows, omit this one.  */
for|for
control|(
name|note
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|NEXT_INSN
argument_list|(
name|note
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|note
argument_list|)
operator|!=
name|NOTE
operator|&&
name|GET_CODE
argument_list|(
name|note
argument_list|)
operator|!=
name|CODE_LABEL
condition|)
break|break;
comment|/* These types of notes can be significant 		 so make sure the preceding line number stays.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|note
argument_list|)
operator|==
name|NOTE
operator|&&
operator|(
name|NOTE_LINE_NUMBER
argument_list|(
name|note
argument_list|)
operator|==
name|NOTE_INSN_BLOCK_BEG
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|note
argument_list|)
operator|==
name|NOTE_INSN_BLOCK_END
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|note
argument_list|)
operator|==
name|NOTE_INSN_FUNCTION_BEG
operator|)
condition|)
break|break;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|note
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|note
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|/* Another line note follows; we can delete this note 		     if no intervening line numbers have notes elsewhere.  */
name|int
name|num
decl_stmt|;
for|for
control|(
name|num
operator|=
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|+
literal|1
init|;
name|num
operator|<
name|NOTE_LINE_NUMBER
argument_list|(
name|note
argument_list|)
condition|;
name|num
operator|++
control|)
if|if
condition|(
name|line_note_exists
index|[
name|num
index|]
condition|)
break|break;
if|if
condition|(
name|num
operator|>=
name|NOTE_LINE_NUMBER
argument_list|(
name|note
argument_list|)
condition|)
name|note_after
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
comment|/* Output this line note 	     if it is the first or the last line note in a row.  */
if|if
condition|(
operator|!
name|note_after
condition|)
name|output_source_line
argument_list|(
name|file
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|BARRIER
case|:
if|#
directive|if
name|defined
argument_list|(
name|DWARF2_UNWIND_INFO
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|ACCUMULATE_OUTGOING_ARGS
argument_list|)
comment|/* If we push arguments, we need to check all insns for stack 	   adjustments.  */
if|if
condition|(
name|dwarf2out_do_frame
argument_list|()
condition|)
name|dwarf2out_frame_debug
argument_list|(
name|insn
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|CODE_LABEL
case|:
comment|/* The target port might emit labels in the output function for 	 some insn, e.g. sh.c output_branchy_insn.  */
if|if
condition|(
name|CODE_LABEL_NUMBER
argument_list|(
name|insn
argument_list|)
operator|<=
name|max_labelno
condition|)
block|{
name|int
name|align
init|=
name|LABEL_TO_ALIGNMENT
argument_list|(
name|insn
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|ASM_OUTPUT_MAX_SKIP_ALIGN
name|int
name|max_skip
init|=
name|LABEL_TO_MAX_SKIP
argument_list|(
name|insn
argument_list|)
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|align
operator|&&
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
condition|)
ifdef|#
directive|ifdef
name|ASM_OUTPUT_MAX_SKIP_ALIGN
name|ASM_OUTPUT_MAX_SKIP_ALIGN
argument_list|(
name|file
argument_list|,
name|align
argument_list|,
name|max_skip
argument_list|)
expr_stmt|;
else|#
directive|else
name|ASM_OUTPUT_ALIGN
argument_list|(
name|file
argument_list|,
name|align
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|HAVE_cc0
name|CC_STATUS_INIT
expr_stmt|;
comment|/* If this label is reached from only one place, set the condition 	 codes from the instruction just before the branch.  */
comment|/* Disabled because some insns set cc_status in the C output code 	 and NOTICE_UPDATE_CC alone can set incorrect status.  */
if|if
condition|(
literal|0
comment|/* optimize&& LABEL_NUSES (insn) == 1*/
condition|)
block|{
name|rtx
name|jump
init|=
name|LABEL_REFS
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|barrier
init|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|prev
decl_stmt|;
comment|/* If the LABEL_REFS field of this label has been set to point 	     at a branch, the predecessor of the branch is a regular 	     insn, and that branch is the only way to reach this label, 	     set the condition codes based on the branch and its 	     predecessor.  */
if|if
condition|(
name|barrier
operator|&&
name|GET_CODE
argument_list|(
name|barrier
argument_list|)
operator|==
name|BARRIER
operator|&&
name|jump
operator|&&
name|GET_CODE
argument_list|(
name|jump
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
operator|(
name|prev
operator|=
name|prev_nonnote_insn
argument_list|(
name|jump
argument_list|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|prev
argument_list|)
operator|==
name|INSN
condition|)
block|{
name|NOTICE_UPDATE_CC
argument_list|(
name|PATTERN
argument_list|(
name|prev
argument_list|)
argument_list|,
name|prev
argument_list|)
expr_stmt|;
name|NOTICE_UPDATE_CC
argument_list|(
name|PATTERN
argument_list|(
name|jump
argument_list|)
argument_list|,
name|jump
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|prescan
operator|>
literal|0
condition|)
break|break;
name|new_block
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|FINAL_PRESCAN_LABEL
name|FINAL_PRESCAN_INSN
argument_list|(
name|insn
argument_list|,
name|NULL_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SDB_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|SDB_DEBUG
operator|&&
name|LABEL_NAME
argument_list|(
name|insn
argument_list|)
condition|)
name|sdbout_label
argument_list|(
name|insn
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DWARF_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|DWARF_DEBUG
operator|&&
name|LABEL_NAME
argument_list|(
name|insn
argument_list|)
condition|)
name|dwarfout_label
argument_list|(
name|insn
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DWARF2_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|DWARF2_DEBUG
operator|&&
name|LABEL_NAME
argument_list|(
name|insn
argument_list|)
condition|)
name|dwarf2out_label
argument_list|(
name|insn
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|app_on
condition|)
block|{
name|fputs
argument_list|(
name|ASM_APP_OFF
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|app_on
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
name|rtx
name|nextbody
init|=
name|PATTERN
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
decl_stmt|;
comment|/* If this label is followed by a jump-table, 	     make sure we put the label in the read-only section.  Also 	     possibly write the label and jump table together.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|nextbody
argument_list|)
operator|==
name|ADDR_VEC
operator|||
name|GET_CODE
argument_list|(
name|nextbody
argument_list|)
operator|==
name|ADDR_DIFF_VEC
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|ASM_OUTPUT_ADDR_VEC
argument_list|)
operator|||
name|defined
argument_list|(
name|ASM_OUTPUT_ADDR_DIFF_VEC
argument_list|)
comment|/* In this case, the case vector is being moved by the 		 target, so don't output the label at all.  Leave that 		 to the back end macros.  */
else|#
directive|else
if|if
condition|(
operator|!
name|JUMP_TABLES_IN_TEXT_SECTION
condition|)
block|{
name|readonly_data_section
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|READONLY_DATA_SECTION
name|ASM_OUTPUT_ALIGN
argument_list|(
name|file
argument_list|,
name|exact_log2
argument_list|(
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* READONLY_DATA_SECTION */
block|}
else|else
name|function_section
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ASM_OUTPUT_CASE_LABEL
name|ASM_OUTPUT_CASE_LABEL
argument_list|(
name|file
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|insn
argument_list|)
argument_list|,
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|file
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
break|break;
block|}
block|}
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|file
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
block|{
specifier|register
name|rtx
name|body
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|int
name|insn_code_number
decl_stmt|;
specifier|const
name|char
modifier|*
name|template
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
name|rtx
name|note
decl_stmt|;
endif|#
directive|endif
comment|/* An INSN, JUMP_INSN or CALL_INSN. 	   First check for special kinds that recog doesn't recognize.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|USE
comment|/* These are just declarations */
operator|||
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|CLOBBER
condition|)
break|break;
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* If there is a REG_CC_SETTER note on this insn, it means that 	   the setting of the condition code was done in the delay slot 	   of the insn that branched here.  So recover the cc status 	   from the insn that set it.  */
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_CC_SETTER
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|note
condition|)
block|{
name|NOTICE_UPDATE_CC
argument_list|(
name|PATTERN
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|cc_prev_status
operator|=
name|cc_status
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Detect insns that are really jump-tables 	   and output them as such.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|ADDR_VEC
operator|||
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|ADDR_DIFF_VEC
condition|)
block|{
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|ASM_OUTPUT_ADDR_VEC
argument_list|)
operator|||
name|defined
argument_list|(
name|ASM_OUTPUT_ADDR_DIFF_VEC
argument_list|)
operator|)
specifier|register
name|int
name|vlen
decl_stmt|,
name|idx
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|prescan
operator|>
literal|0
condition|)
break|break;
if|if
condition|(
name|app_on
condition|)
block|{
name|fputs
argument_list|(
name|ASM_APP_OFF
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|app_on
operator|=
literal|0
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|ASM_OUTPUT_ADDR_VEC
argument_list|)
operator|||
name|defined
argument_list|(
name|ASM_OUTPUT_ADDR_DIFF_VEC
argument_list|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|ADDR_VEC
condition|)
block|{
ifdef|#
directive|ifdef
name|ASM_OUTPUT_ADDR_VEC
name|ASM_OUTPUT_ADDR_VEC
argument_list|(
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|body
argument_list|)
expr_stmt|;
else|#
directive|else
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|ASM_OUTPUT_ADDR_DIFF_VEC
name|ASM_OUTPUT_ADDR_DIFF_VEC
argument_list|(
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|body
argument_list|)
expr_stmt|;
else|#
directive|else
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
else|#
directive|else
name|vlen
operator|=
name|XVECLEN
argument_list|(
name|body
argument_list|,
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|ADDR_DIFF_VEC
argument_list|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|vlen
condition|;
name|idx
operator|++
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|ADDR_VEC
condition|)
block|{
ifdef|#
directive|ifdef
name|ASM_OUTPUT_ADDR_VEC_ELT
name|ASM_OUTPUT_ADDR_VEC_ELT
argument_list|(
name|file
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|idx
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|ASM_OUTPUT_ADDR_DIFF_ELT
name|ASM_OUTPUT_ADDR_DIFF_ELT
argument_list|(
name|file
argument_list|,
name|body
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|1
argument_list|,
name|idx
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
block|}
ifdef|#
directive|ifdef
name|ASM_OUTPUT_CASE_END
name|ASM_OUTPUT_CASE_END
argument_list|(
name|file
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|function_section
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Do basic-block profiling when we reach a new block. 	   Done here to avoid jump tables.  */
if|if
condition|(
name|profile_block_flag
operator|&&
name|new_block
condition|)
name|add_bb
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|ASM_INPUT
condition|)
block|{
comment|/* There's no telling what that did to the condition codes.  */
name|CC_STATUS_INIT
expr_stmt|;
if|if
condition|(
name|prescan
operator|>
literal|0
condition|)
break|break;
if|if
condition|(
operator|!
name|app_on
condition|)
block|{
name|fputs
argument_list|(
name|ASM_APP_ON
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|app_on
operator|=
literal|1
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s\n"
argument_list|,
name|XSTR
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Detect `asm' construct with operands.  */
if|if
condition|(
name|asm_noperands
argument_list|(
name|body
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|unsigned
name|int
name|noperands
init|=
name|asm_noperands
argument_list|(
name|body
argument_list|)
decl_stmt|;
name|rtx
modifier|*
name|ops
init|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|noperands
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
comment|/* There's no telling what that did to the condition codes.  */
name|CC_STATUS_INIT
expr_stmt|;
if|if
condition|(
name|prescan
operator|>
literal|0
condition|)
break|break;
if|if
condition|(
operator|!
name|app_on
condition|)
block|{
name|fputs
argument_list|(
name|ASM_APP_ON
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|app_on
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Get out the operand values.  */
name|string
operator|=
name|decode_asm_operands
argument_list|(
name|body
argument_list|,
name|ops
argument_list|,
name|NULL_PTR
argument_list|,
name|NULL_PTR
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
comment|/* Inhibit aborts on what would otherwise be compiler bugs.  */
name|insn_noperands
operator|=
name|noperands
expr_stmt|;
name|this_is_asm_operands
operator|=
name|insn
expr_stmt|;
comment|/* Output the insn using them.  */
name|output_asm_insn
argument_list|(
name|string
argument_list|,
name|ops
argument_list|)
expr_stmt|;
name|this_is_asm_operands
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|prescan
operator|<=
literal|0
operator|&&
name|app_on
condition|)
block|{
name|fputs
argument_list|(
name|ASM_APP_OFF
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|app_on
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|SEQUENCE
condition|)
block|{
comment|/* A delayed-branch sequence */
specifier|register
name|int
name|i
decl_stmt|;
name|rtx
name|next
decl_stmt|;
if|if
condition|(
name|prescan
operator|>
literal|0
condition|)
break|break;
name|final_sequence
operator|=
name|body
expr_stmt|;
comment|/* The first insn in this SEQUENCE might be a JUMP_INSN that will 	       force the restoration of a comparison that was previously 	       thought unnecessary.  If that happens, cancel this sequence 	       and cause that insn to be restored.  */
name|next
operator|=
name|final_scan_insn
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|file
argument_list|,
literal|0
argument_list|,
name|prescan
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|!=
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|final_sequence
operator|=
literal|0
expr_stmt|;
return|return
name|next
return|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|insn
init|=
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|rtx
name|next
init|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* We loop in case any instruction in a delay slot gets 		   split.  */
do|do
name|insn
operator|=
name|final_scan_insn
argument_list|(
name|insn
argument_list|,
name|file
argument_list|,
literal|0
argument_list|,
name|prescan
argument_list|,
literal|1
argument_list|)
expr_stmt|;
do|while
condition|(
name|insn
operator|!=
name|next
condition|)
do|;
block|}
ifdef|#
directive|ifdef
name|DBR_OUTPUT_SEQEND
name|DBR_OUTPUT_SEQEND
argument_list|(
name|file
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|final_sequence
operator|=
literal|0
expr_stmt|;
comment|/* If the insn requiring the delay slot was a CALL_INSN, the 	       insns in the delay slot are actually executed before the 	       called function.  Hence we don't preserve any CC-setting 	       actions in these insns and the CC must be marked as being 	       clobbered by the function.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|CC_STATUS_INIT
expr_stmt|;
block|}
comment|/* Following a conditional branch sequence, we have a new basic 	       block.  */
if|if
condition|(
name|profile_block_flag
condition|)
block|{
name|rtx
name|insn
init|=
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|body
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
operator|!=
name|LABEL_REF
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|LABEL_REF
operator|)
condition|)
name|new_block
operator|=
literal|1
expr_stmt|;
block|}
break|break;
block|}
comment|/* We have a real machine instruction as rtl.  */
name|body
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Check for redundant test and compare instructions 	   (when the condition codes are already set up as desired). 	   This is done only when optimizing; if not optimizing, 	   it should be possible for the user to alter a variable 	   with the debugger in between statements 	   and the next statement should reexamine the variable 	   to compute the condition codes.  */
if|if
condition|(
name|optimize
condition|)
block|{
if|#
directive|if
literal|0
block|rtx set = single_set(insn);
endif|#
directive|endif
if|if
condition|(
name|set
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|CC0
operator|&&
name|insn
operator|!=
name|last_ignored_compare
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|SUBREG
condition|)
name|SET_SRC
argument_list|(
name|set
argument_list|)
operator|=
name|alter_subreg
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|COMPARE
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SUBREG
condition|)
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|=
name|alter_subreg
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|SUBREG
condition|)
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|=
name|alter_subreg
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cc_status
operator|.
name|value1
operator|!=
literal|0
operator|&&
name|rtx_equal_p
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|cc_status
operator|.
name|value1
argument_list|)
operator|)
operator|||
operator|(
name|cc_status
operator|.
name|value2
operator|!=
literal|0
operator|&&
name|rtx_equal_p
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|cc_status
operator|.
name|value2
argument_list|)
operator|)
condition|)
block|{
comment|/* Don't delete insn if it has an addressing side-effect.  */
if|if
condition|(
operator|!
name|FIND_REG_INC_NOTE
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
comment|/* or if anything in it is volatile.  */
operator|&&
operator|!
name|volatile_refs_p
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
block|{
comment|/* We don't really delete the insn; just ignore it.  */
name|last_ignored_compare
operator|=
name|insn
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
endif|#
directive|endif
comment|/* Following a conditional branch, we have a new basic block. 	   But if we are inside a sequence, the new block starts after the 	   last insn of the sequence.  */
if|if
condition|(
name|profile_block_flag
operator|&&
name|final_sequence
operator|==
literal|0
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
operator|!=
name|LABEL_REF
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|LABEL_REF
operator|)
operator|)
condition|)
name|new_block
operator|=
literal|1
expr_stmt|;
ifndef|#
directive|ifndef
name|STACK_REGS
comment|/* Don't bother outputting obvious no-ops, even without -O. 	   This optimization is fast and doesn't interfere with debugging. 	   Don't do this if the insn is in a delay slot, since this 	   will cause an improper number of delay insns to be written.  */
if|if
condition|(
name|final_sequence
operator|==
literal|0
operator|&&
name|prescan
operator|>=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
condition|)
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* If this is a conditional branch, maybe modify it 	   if the cc's are in a nonstandard state 	   so that it accomplishes the same thing that it would 	   do straightforwardly if the cc's were set up normally.  */
if|if
condition|(
name|cc_status
operator|.
name|flags
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|body
argument_list|)
operator|==
name|pc_rtx
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|IF_THEN_ELSE
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'<'
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|cc0_rtx
comment|/* This is done during prescan; it is not done again 	       in final scan when prescan has been done.  */
operator|&&
name|prescan
operator|>=
literal|0
condition|)
block|{
comment|/* This function may alter the contents of its argument 	       and clear some of the cc_status.flags bits. 	       It may also return 1 meaning condition now always true 	       or -1 meaning condition now always false 	       or 2 meaning condition nontrivial but altered.  */
specifier|register
name|int
name|result
init|=
name|alter_cond
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
comment|/* If condition now has fixed value, replace the IF_THEN_ELSE 	       with its then-operand or its else-operand.  */
if|if
condition|(
name|result
operator|==
literal|1
condition|)
name|SET_SRC
argument_list|(
name|body
argument_list|)
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
operator|-
literal|1
condition|)
name|SET_SRC
argument_list|(
name|body
argument_list|)
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* The jump is now either unconditional or a no-op. 	       If it has become a no-op, don't try to output it. 	       (It would not be recognized.)  */
if|if
condition|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
operator|==
name|pc_rtx
condition|)
block|{
name|PUT_CODE
argument_list|(
name|insn
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|RETURN
condition|)
comment|/* Replace (set (pc) (return)) with (return).  */
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|=
name|body
operator|=
name|SET_SRC
argument_list|(
name|body
argument_list|)
expr_stmt|;
comment|/* Rerecognize the instruction if it has changed.  */
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Make same adjustments to instructions that examine the 	   condition codes without jumping and instructions that 	   handle conditional moves (if this machine has either one).  */
if|if
condition|(
name|cc_status
operator|.
name|flags
operator|!=
literal|0
operator|&&
name|set
operator|!=
literal|0
condition|)
block|{
name|rtx
name|cond_rtx
decl_stmt|,
name|then_rtx
decl_stmt|,
name|else_rtx
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|IF_THEN_ELSE
condition|)
block|{
name|cond_rtx
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|then_rtx
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|else_rtx
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cond_rtx
operator|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|then_rtx
operator|=
name|const_true_rtx
expr_stmt|;
name|else_rtx
operator|=
name|const0_rtx
expr_stmt|;
block|}
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|cond_rtx
argument_list|)
condition|)
block|{
case|case
name|GTU
case|:
case|case
name|GT
case|:
case|case
name|LTU
case|:
case|case
name|LT
case|:
case|case
name|GEU
case|:
case|case
name|GE
case|:
case|case
name|LEU
case|:
case|case
name|LE
case|:
case|case
name|EQ
case|:
case|case
name|NE
case|:
block|{
specifier|register
name|int
name|result
decl_stmt|;
if|if
condition|(
name|XEXP
argument_list|(
name|cond_rtx
argument_list|,
literal|0
argument_list|)
operator|!=
name|cc0_rtx
condition|)
break|break;
name|result
operator|=
name|alter_cond
argument_list|(
name|cond_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
literal|1
condition|)
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|then_rtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|result
operator|==
operator|-
literal|1
condition|)
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|else_rtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|result
operator|==
literal|2
condition|)
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|==
name|SET_SRC
argument_list|(
name|set
argument_list|)
condition|)
block|{
name|PUT_CODE
argument_list|(
name|insn
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
break|break;
default|default:
break|break;
block|}
block|}
endif|#
directive|endif
comment|/* Do machine-specific peephole optimizations if desired.  */
if|if
condition|(
name|optimize
operator|&&
operator|!
name|flag_no_peephole
operator|&&
operator|!
name|nopeepholes
condition|)
block|{
name|rtx
name|next
init|=
name|peephole
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* When peepholing, if there were notes within the peephole, 	       emit them before the peephole.  */
if|if
condition|(
name|next
operator|!=
literal|0
operator|&&
name|next
operator|!=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|rtx
name|prev
init|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|note
decl_stmt|;
for|for
control|(
name|note
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
init|;
name|note
operator|!=
name|next
condition|;
name|note
operator|=
name|NEXT_INSN
argument_list|(
name|note
argument_list|)
control|)
name|final_scan_insn
argument_list|(
name|note
argument_list|,
name|file
argument_list|,
name|optimize
argument_list|,
name|prescan
argument_list|,
name|nopeepholes
argument_list|)
expr_stmt|;
comment|/* In case this is prescan, put the notes 		   in proper position for later rescan.  */
name|note
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|PREV_INSN
argument_list|(
name|note
argument_list|)
operator|=
name|prev
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|prev
argument_list|)
operator|=
name|note
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|PREV_INSN
argument_list|(
name|next
argument_list|)
argument_list|)
operator|=
name|insn
expr_stmt|;
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|PREV_INSN
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|next
expr_stmt|;
name|PREV_INSN
argument_list|(
name|next
argument_list|)
operator|=
name|insn
expr_stmt|;
block|}
comment|/* PEEPHOLE might have changed this.  */
name|body
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* Try to recognize the instruction. 	   If successful, verify that the operands satisfy the 	   constraints for the instruction.  Crash if they don't, 	   since `reload' should have changed them so that they do.  */
name|insn_code_number
operator|=
name|recog_memoized
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|extract_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|cleanup_subreg_operands
argument_list|(
name|insn
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|REGISTER_CONSTRAINTS
if|if
condition|(
operator|!
name|constrain_operands
argument_list|(
literal|1
argument_list|)
condition|)
name|fatal_insn_not_found
argument_list|(
name|insn
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Some target machines need to prescan each insn before 	   it is output.  */
ifdef|#
directive|ifdef
name|FINAL_PRESCAN_INSN
name|FINAL_PRESCAN_INSN
argument_list|(
name|insn
argument_list|,
name|recog_operand
argument_list|,
name|recog_n_operands
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_cc0
name|cc_prev_status
operator|=
name|cc_status
expr_stmt|;
comment|/* Update `cc_status' for this instruction. 	   The instruction's output routine may change it further. 	   If the output routine for a jump insn needs to depend 	   on the cc status, it should look at cc_prev_status.  */
name|NOTICE_UPDATE_CC
argument_list|(
name|body
argument_list|,
name|insn
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|debug_insn
operator|=
name|insn
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DWARF2_UNWIND_INFO
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|ACCUMULATE_OUTGOING_ARGS
argument_list|)
comment|/* If we push arguments, we want to know where the calls are.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|&&
name|dwarf2out_do_frame
argument_list|()
condition|)
name|dwarf2out_frame_debug
argument_list|(
name|insn
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If the proper template needs to be chosen by some C code, 	   run that code and get the real template.  */
name|template
operator|=
name|insn_template
index|[
name|insn_code_number
index|]
expr_stmt|;
if|if
condition|(
name|template
operator|==
literal|0
condition|)
block|{
name|template
operator|=
call|(
modifier|*
name|insn_outfun
index|[
name|insn_code_number
index|]
call|)
argument_list|(
name|recog_operand
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* If the C code returns 0, it means that it is a jump insn 	       which follows a deleted test insn, and that test insn 	       needs to be reinserted.  */
if|if
condition|(
name|template
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
operator|!=
name|last_ignored_compare
condition|)
name|abort
argument_list|()
expr_stmt|;
name|new_block
operator|=
literal|0
expr_stmt|;
return|return
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
return|;
block|}
block|}
comment|/* If the template is the string "#", it means that this insn must 	   be split.  */
if|if
condition|(
name|template
index|[
literal|0
index|]
operator|==
literal|'#'
operator|&&
name|template
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
name|rtx
name|new
init|=
name|try_split
argument_list|(
name|body
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* If we didn't split the insn, go away.  */
if|if
condition|(
name|new
operator|==
name|insn
operator|&&
name|PATTERN
argument_list|(
name|new
argument_list|)
operator|==
name|body
condition|)
name|fatal_insn
argument_list|(
literal|"Could not split insn"
argument_list|,
name|insn
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_ATTR_length
comment|/* This instruction should have been split in shorten_branches, 	       to ensure that we would have valid length info for the 	       splitees.  */
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|new_block
operator|=
literal|0
expr_stmt|;
return|return
name|new
return|;
block|}
if|if
condition|(
name|prescan
operator|>
literal|0
condition|)
break|break;
comment|/* Output assembler code from the template.  */
name|output_asm_insn
argument_list|(
name|template
argument_list|,
name|recog_operand
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DWARF2_UNWIND_INFO
argument_list|)
if|#
directive|if
operator|!
name|defined
argument_list|(
name|ACCUMULATE_OUTGOING_ARGS
argument_list|)
comment|/* If we push arguments, we need to check all insns for stack 	   adjustments.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|dwarf2out_do_frame
argument_list|()
condition|)
name|dwarf2out_frame_debug
argument_list|(
name|insn
argument_list|)
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|HAVE_prologue
argument_list|)
comment|/* If this insn is part of the prologue, emit DWARF v2 	   call frame info.  */
if|if
condition|(
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|dwarf2out_do_frame
argument_list|()
condition|)
name|dwarf2out_frame_debug
argument_list|(
name|insn
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
if|#
directive|if
literal|0
comment|/* It's not at all clear why we did this and doing so interferes 	   with tests we'd like to do to use REG_WAS_0 notes, so let's try 	   with this out.  */
comment|/* Mark this insn as having been output.  */
block|INSN_DELETED_P (insn) = 1;
endif|#
directive|endif
name|debug_insn
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output debugging info to the assembler file FILE    based on the NOTE-insn INSN, assumed to be a line number.  */
end_comment

begin_function
specifier|static
name|void
name|output_source_line
parameter_list|(
name|file
parameter_list|,
name|insn
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|filename
init|=
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* Remember filename for basic block profiling.      Filenames are allocated on the permanent obstack      or are passed in ARGV, so we don't have to save      the string.  */
if|if
condition|(
name|profile_block_flag
operator|&&
name|last_filename
operator|!=
name|filename
condition|)
name|bb_file_label_num
operator|=
name|add_bb_string
argument_list|(
name|filename
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|last_filename
operator|=
name|filename
expr_stmt|;
name|last_linenum
operator|=
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|high_block_linenum
operator|=
name|MAX
argument_list|(
name|last_linenum
argument_list|,
name|high_block_linenum
argument_list|)
expr_stmt|;
name|high_function_linenum
operator|=
name|MAX
argument_list|(
name|last_linenum
argument_list|,
name|high_function_linenum
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_symbols
operator|!=
name|NO_DEBUG
condition|)
block|{
ifdef|#
directive|ifdef
name|SDB_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|SDB_DEBUG
if|#
directive|if
literal|0
comment|/* People like having line numbers even in wrong file!  */
comment|/* COFF can't handle multiple source files--lose, lose.  */
expr|&& !strcmp (filename, main_input_filename)
endif|#
directive|endif
comment|/* COFF relative line numbers must be positive.  */
operator|&&
name|last_linenum
operator|>
name|sdb_begin_function_line
condition|)
block|{
ifdef|#
directive|ifdef
name|ASM_OUTPUT_SOURCE_LINE
name|ASM_OUTPUT_SOURCE_LINE
argument_list|(
name|file
argument_list|,
name|last_linenum
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.ln\t%d\n"
argument_list|,
operator|(
operator|(
name|sdb_begin_function_line
operator|>
operator|-
literal|1
operator|)
condition|?
name|last_linenum
operator|-
name|sdb_begin_function_line
else|:
literal|1
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|DBX_DEBUGGING_INFO
argument_list|)
if|if
condition|(
name|write_symbols
operator|==
name|DBX_DEBUG
condition|)
name|dbxout_source_line
argument_list|(
name|file
argument_list|,
name|filename
argument_list|,
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|XCOFF_DEBUGGING_INFO
argument_list|)
if|if
condition|(
name|write_symbols
operator|==
name|XCOFF_DEBUG
condition|)
name|xcoffout_source_line
argument_list|(
name|file
argument_list|,
name|filename
argument_list|,
name|insn
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DWARF_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|DWARF_DEBUG
condition|)
name|dwarfout_line
argument_list|(
name|filename
argument_list|,
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DWARF2_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|DWARF2_DEBUG
condition|)
name|dwarf2out_line
argument_list|(
name|filename
argument_list|,
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* For each operand in INSN, simplify (subreg (reg)) so that it refers    directly to the desired hard register.  */
end_comment

begin_function
name|void
name|cleanup_subreg_operands
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|extract_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|recog_n_operands
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
operator|==
name|SUBREG
condition|)
name|recog_operand
index|[
name|i
index|]
operator|=
name|alter_subreg
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
operator|==
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
operator|==
name|MULT
condition|)
name|recog_operand
index|[
name|i
index|]
operator|=
name|walk_alter_subreg
argument_list|(
name|recog_operand
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|recog_n_dups
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
operator|*
name|recog_dup_loc
index|[
name|i
index|]
argument_list|)
operator|==
name|SUBREG
condition|)
operator|*
name|recog_dup_loc
index|[
name|i
index|]
operator|=
name|alter_subreg
argument_list|(
operator|*
name|recog_dup_loc
index|[
name|i
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
operator|*
name|recog_dup_loc
index|[
name|i
index|]
argument_list|)
operator|==
name|PLUS
operator|||
name|GET_CODE
argument_list|(
operator|*
name|recog_dup_loc
index|[
name|i
index|]
argument_list|)
operator|==
name|MULT
condition|)
operator|*
name|recog_dup_loc
index|[
name|i
index|]
operator|=
name|walk_alter_subreg
argument_list|(
operator|*
name|recog_dup_loc
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* If X is a SUBREG, replace it with a REG or a MEM,    based on the thing it is a subreg of.  */
end_comment

begin_function
name|rtx
name|alter_subreg
parameter_list|(
name|x
parameter_list|)
specifier|register
name|rtx
name|x
decl_stmt|;
block|{
specifier|register
name|rtx
name|y
init|=
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|SUBREG
condition|)
name|y
operator|=
name|alter_subreg
argument_list|(
name|y
argument_list|)
expr_stmt|;
comment|/* If reload is operating, we may be replacing inside this SUBREG.      Check for that and make a new one if so.  */
if|if
condition|(
name|reload_in_progress
operator|&&
name|find_replacement
argument_list|(
operator|&
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|x
operator|=
name|copy_rtx
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|REG
condition|)
block|{
comment|/* If the word size is larger than the size of this register, 	 adjust the register number to compensate.  */
comment|/* ??? Note that this just catches stragglers created by/for 	 integrate.  It would be better if we either caught these 	 earlier, or kept _all_ subregs until now and eliminate 	 gen_lowpart and friends.  */
name|PUT_CODE
argument_list|(
name|x
argument_list|,
name|REG
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ALTER_HARD_SUBREG
name|REGNO
argument_list|(
name|x
argument_list|)
operator|=
name|ALTER_HARD_SUBREG
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|SUBREG_WORD
argument_list|(
name|x
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|y
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|y
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|REGNO
argument_list|(
name|x
argument_list|)
operator|=
name|REGNO
argument_list|(
name|y
argument_list|)
operator|+
name|SUBREG_WORD
argument_list|(
name|x
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* This field has a different meaning for REGs and SUBREGs.  Make sure 	 to clear it!  */
name|x
operator|->
name|used
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|MEM
condition|)
block|{
specifier|register
name|int
name|offset
init|=
name|SUBREG_WORD
argument_list|(
name|x
argument_list|)
operator|*
name|UNITS_PER_WORD
decl_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
name|offset
operator|-=
operator|(
name|MIN
argument_list|(
name|UNITS_PER_WORD
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|-
name|MIN
argument_list|(
name|UNITS_PER_WORD
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|y
argument_list|)
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|PUT_CODE
argument_list|(
name|x
argument_list|,
name|MEM
argument_list|)
expr_stmt|;
name|MEM_COPY_ATTRIBUTES
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|MEM_ALIAS_SET
argument_list|(
name|x
argument_list|)
operator|=
name|MEM_ALIAS_SET
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|plus_constant_for_output
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Do alter_subreg on all the SUBREGs contained in X.  */
end_comment

begin_function
specifier|static
name|rtx
name|walk_alter_subreg
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|PLUS
case|:
case|case
name|MULT
case|:
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|walk_alter_subreg
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|=
name|walk_alter_subreg
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEM
case|:
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|walk_alter_subreg
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SUBREG
case|:
return|return
name|alter_subreg
argument_list|(
name|x
argument_list|)
return|;
default|default:
break|break;
block|}
return|return
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_cc0
end_ifdef

begin_comment
comment|/* Given BODY, the body of a jump instruction, alter the jump condition    as required by the bits that are set in cc_status.flags.    Not all of the bits there can be handled at this level in all cases.     The value is normally 0.    1 means that the condition has become always true.    -1 means that the condition has become always false.    2 means that COND has been altered.  */
end_comment

begin_function
specifier|static
name|int
name|alter_cond
parameter_list|(
name|cond
parameter_list|)
specifier|register
name|rtx
name|cond
decl_stmt|;
block|{
name|int
name|value
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|cc_status
operator|.
name|flags
operator|&
name|CC_REVERSED
condition|)
block|{
name|value
operator|=
literal|2
expr_stmt|;
name|PUT_CODE
argument_list|(
name|cond
argument_list|,
name|swap_condition
argument_list|(
name|GET_CODE
argument_list|(
name|cond
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cc_status
operator|.
name|flags
operator|&
name|CC_INVERTED
condition|)
block|{
name|value
operator|=
literal|2
expr_stmt|;
name|PUT_CODE
argument_list|(
name|cond
argument_list|,
name|reverse_condition
argument_list|(
name|GET_CODE
argument_list|(
name|cond
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cc_status
operator|.
name|flags
operator|&
name|CC_NOT_POSITIVE
condition|)
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|cond
argument_list|)
condition|)
block|{
case|case
name|LE
case|:
case|case
name|LEU
case|:
case|case
name|GEU
case|:
comment|/* Jump becomes unconditional.  */
return|return
literal|1
return|;
case|case
name|GT
case|:
case|case
name|GTU
case|:
case|case
name|LTU
case|:
comment|/* Jump becomes no-op.  */
return|return
operator|-
literal|1
return|;
case|case
name|GE
case|:
name|PUT_CODE
argument_list|(
name|cond
argument_list|,
name|EQ
argument_list|)
expr_stmt|;
name|value
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|LT
case|:
name|PUT_CODE
argument_list|(
name|cond
argument_list|,
name|NE
argument_list|)
expr_stmt|;
name|value
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|cc_status
operator|.
name|flags
operator|&
name|CC_NOT_NEGATIVE
condition|)
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|cond
argument_list|)
condition|)
block|{
case|case
name|GE
case|:
case|case
name|GEU
case|:
comment|/* Jump becomes unconditional.  */
return|return
literal|1
return|;
case|case
name|LT
case|:
case|case
name|LTU
case|:
comment|/* Jump becomes no-op.  */
return|return
operator|-
literal|1
return|;
case|case
name|LE
case|:
case|case
name|LEU
case|:
name|PUT_CODE
argument_list|(
name|cond
argument_list|,
name|EQ
argument_list|)
expr_stmt|;
name|value
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|GT
case|:
case|case
name|GTU
case|:
name|PUT_CODE
argument_list|(
name|cond
argument_list|,
name|NE
argument_list|)
expr_stmt|;
name|value
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|cc_status
operator|.
name|flags
operator|&
name|CC_NO_OVERFLOW
condition|)
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|cond
argument_list|)
condition|)
block|{
case|case
name|GEU
case|:
comment|/* Jump becomes unconditional.  */
return|return
literal|1
return|;
case|case
name|LEU
case|:
name|PUT_CODE
argument_list|(
name|cond
argument_list|,
name|EQ
argument_list|)
expr_stmt|;
name|value
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|GTU
case|:
name|PUT_CODE
argument_list|(
name|cond
argument_list|,
name|NE
argument_list|)
expr_stmt|;
name|value
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|LTU
case|:
comment|/* Jump becomes no-op.  */
return|return
operator|-
literal|1
return|;
default|default:
break|break;
block|}
if|if
condition|(
name|cc_status
operator|.
name|flags
operator|&
operator|(
name|CC_Z_IN_NOT_N
operator||
name|CC_Z_IN_N
operator|)
condition|)
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|cond
argument_list|)
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
name|NE
case|:
name|PUT_CODE
argument_list|(
name|cond
argument_list|,
name|cc_status
operator|.
name|flags
operator|&
name|CC_Z_IN_N
condition|?
name|GE
else|:
name|LT
argument_list|)
expr_stmt|;
name|value
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|EQ
case|:
name|PUT_CODE
argument_list|(
name|cond
argument_list|,
name|cc_status
operator|.
name|flags
operator|&
name|CC_Z_IN_N
condition|?
name|LT
else|:
name|GE
argument_list|)
expr_stmt|;
name|value
operator|=
literal|2
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cc_status
operator|.
name|flags
operator|&
name|CC_NOT_SIGNED
condition|)
comment|/* The flags are valid if signed condition operators are converted        to unsigned.  */
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|cond
argument_list|)
condition|)
block|{
case|case
name|LE
case|:
name|PUT_CODE
argument_list|(
name|cond
argument_list|,
name|LEU
argument_list|)
expr_stmt|;
name|value
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|LT
case|:
name|PUT_CODE
argument_list|(
name|cond
argument_list|,
name|LTU
argument_list|)
expr_stmt|;
name|value
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|GT
case|:
name|PUT_CODE
argument_list|(
name|cond
argument_list|,
name|GTU
argument_list|)
expr_stmt|;
name|value
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|GE
case|:
name|PUT_CODE
argument_list|(
name|cond
argument_list|,
name|GEU
argument_list|)
expr_stmt|;
name|value
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|value
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Report inconsistency between the assembler template and the operands.    In an `asm', it's the user's fault; otherwise, the compiler's fault.  */
end_comment

begin_function
name|void
name|output_operand_lossage
parameter_list|(
name|msgid
parameter_list|)
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
block|{
if|if
condition|(
name|this_is_asm_operands
condition|)
name|error_for_asm
argument_list|(
name|this_is_asm_operands
argument_list|,
literal|"invalid `asm': %s"
argument_list|,
name|_
argument_list|(
name|msgid
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fatal
argument_list|(
literal|"Internal compiler error, output_operand_lossage `%s'"
argument_list|,
name|_
argument_list|(
name|msgid
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output of assembler code from a template, and its subroutines.  */
end_comment

begin_comment
comment|/* Output text from TEMPLATE to the assembler output file,    obeying %-directions to substitute operands taken from    the vector OPERANDS.     %N (for N a digit) means print operand N in usual manner.    %lN means require operand N to be a CODE_LABEL or LABEL_REF       and print the label name with no punctuation.    %cN means require operand N to be a constant       and print the constant expression with no punctuation.    %aN means expect operand N to be a memory address       (not a memory reference!) and print a reference       to that address.    %nN means expect operand N to be a constant       and print a constant expression for minus the value       of the operand, with no other punctuation.  */
end_comment

begin_function
specifier|static
name|void
name|output_asm_name
parameter_list|()
block|{
if|if
condition|(
name|flag_print_asm_name
condition|)
block|{
comment|/* Annotate the assembly with a comment describing the pattern and 	 alternative used.  */
if|if
condition|(
name|debug_insn
condition|)
block|{
specifier|register
name|int
name|num
init|=
name|INSN_CODE
argument_list|(
name|debug_insn
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s %d\t%s"
argument_list|,
name|ASM_COMMENT_START
argument_list|,
name|INSN_UID
argument_list|(
name|debug_insn
argument_list|)
argument_list|,
name|insn_name
index|[
name|num
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn_n_alternatives
index|[
name|num
index|]
operator|>
literal|1
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"/%d"
argument_list|,
name|which_alternative
operator|+
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_ATTR_length
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t[length = %d]"
argument_list|,
name|get_attr_length
argument_list|(
name|debug_insn
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Clear this so only the first assembler insn 	     of any rtl insn will get the special comment for -dp.  */
name|debug_insn
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|output_asm_insn
parameter_list|(
name|template
parameter_list|,
name|operands
parameter_list|)
specifier|const
name|char
modifier|*
name|template
decl_stmt|;
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
specifier|register
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
comment|/* An insn may return a null string template      in a case where no assembler code is needed.  */
if|if
condition|(
operator|*
name|template
operator|==
literal|0
condition|)
return|return;
name|p
operator|=
name|template
expr_stmt|;
name|putc
argument_list|(
literal|'\t'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ASM_OUTPUT_OPCODE
name|ASM_OUTPUT_OPCODE
argument_list|(
name|asm_out_file
argument_list|,
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
name|output_asm_name
argument_list|()
expr_stmt|;
name|putc
argument_list|(
name|c
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ASM_OUTPUT_OPCODE
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|)
operator|==
literal|'\t'
condition|)
block|{
name|putc
argument_list|(
name|c
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
name|ASM_OUTPUT_OPCODE
argument_list|(
name|asm_out_file
argument_list|,
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
ifdef|#
directive|ifdef
name|ASSEMBLER_DIALECT
case|case
literal|'{'
case|:
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* If we want the first dialect, do nothing.  Otherwise, skip 	     DIALECT_NUMBER of strings ending with '|'.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dialect_number
condition|;
name|i
operator|++
control|)
block|{
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|++
operator|!=
literal|'|'
condition|)
empty_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'|'
condition|)
name|p
operator|++
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'|'
case|:
comment|/* Skip to close brace.  */
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|++
operator|!=
literal|'}'
condition|)
empty_stmt|;
break|break;
case|case
literal|'}'
case|:
break|break;
endif|#
directive|endif
case|case
literal|'%'
case|:
comment|/* %% outputs a single %.  */
if|if
condition|(
operator|*
name|p
operator|==
literal|'%'
condition|)
block|{
name|p
operator|++
expr_stmt|;
name|putc
argument_list|(
name|c
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
comment|/* %= outputs a number which is unique to each insn in the entire 	   compilation.  This is useful for making local labels that are 	   referred to more than once in a given insn.  */
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'='
condition|)
block|{
name|p
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"%d"
argument_list|,
name|insn_counter
argument_list|)
expr_stmt|;
block|}
comment|/* % followed by a letter and some digits 	   outputs an operand in a special way depending on the letter. 	   Letters `acln' are implemented directly. 	   Other letters are passed to `output_operand' so that 	   the PRINT_OPERAND macro can define them.  */
elseif|else
if|if
condition|(
operator|(
operator|*
name|p
operator|>=
literal|'a'
operator|&&
operator|*
name|p
operator|<=
literal|'z'
operator|)
operator|||
operator|(
operator|*
name|p
operator|>=
literal|'A'
operator|&&
operator|*
name|p
operator|<=
literal|'Z'
operator|)
condition|)
block|{
name|int
name|letter
init|=
operator|*
name|p
operator|++
decl_stmt|;
name|c
operator|=
name|atoi
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|p
operator|>=
literal|'0'
operator|&&
operator|*
name|p
operator|<=
literal|'9'
operator|)
condition|)
name|output_operand_lossage
argument_list|(
literal|"operand number missing after %-letter"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|this_is_asm_operands
operator|&&
operator|(
name|c
operator|<
literal|0
operator|||
operator|(
name|unsigned
name|int
operator|)
name|c
operator|>=
name|insn_noperands
operator|)
condition|)
name|output_operand_lossage
argument_list|(
literal|"operand number out of range"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|letter
operator|==
literal|'l'
condition|)
name|output_asm_label
argument_list|(
name|operands
index|[
name|c
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|letter
operator|==
literal|'a'
condition|)
name|output_address
argument_list|(
name|operands
index|[
name|c
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|letter
operator|==
literal|'c'
condition|)
block|{
if|if
condition|(
name|CONSTANT_ADDRESS_P
argument_list|(
name|operands
index|[
name|c
index|]
argument_list|)
condition|)
name|output_addr_const
argument_list|(
name|asm_out_file
argument_list|,
name|operands
index|[
name|c
index|]
argument_list|)
expr_stmt|;
else|else
name|output_operand
argument_list|(
name|operands
index|[
name|c
index|]
argument_list|,
literal|'c'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|letter
operator|==
literal|'n'
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
name|c
index|]
argument_list|)
operator|==
name|CONST_INT
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
operator|-
name|INTVAL
argument_list|(
name|operands
index|[
name|c
index|]
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|putc
argument_list|(
literal|'-'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|asm_out_file
argument_list|,
name|operands
index|[
name|c
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|output_operand
argument_list|(
name|operands
index|[
name|c
index|]
argument_list|,
name|letter
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|)
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
name|p
operator|++
expr_stmt|;
block|}
comment|/* % followed by a digit outputs an operand the default way.  */
elseif|else
if|if
condition|(
operator|*
name|p
operator|>=
literal|'0'
operator|&&
operator|*
name|p
operator|<=
literal|'9'
condition|)
block|{
name|c
operator|=
name|atoi
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_is_asm_operands
operator|&&
operator|(
name|c
operator|<
literal|0
operator|||
operator|(
name|unsigned
name|int
operator|)
name|c
operator|>=
name|insn_noperands
operator|)
condition|)
name|output_operand_lossage
argument_list|(
literal|"operand number out of range"
argument_list|)
expr_stmt|;
else|else
name|output_operand
argument_list|(
name|operands
index|[
name|c
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|)
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
name|p
operator|++
expr_stmt|;
block|}
comment|/* % followed by punctuation: output something for that 	   punctuation character alone, with no operand. 	   The PRINT_OPERAND macro decides what is actually done.  */
ifdef|#
directive|ifdef
name|PRINT_OPERAND_PUNCT_VALID_P
elseif|else
if|if
condition|(
name|PRINT_OPERAND_PUNCT_VALID_P
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
argument_list|)
condition|)
name|output_operand
argument_list|(
name|NULL_RTX
argument_list|,
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|else
name|output_operand_lossage
argument_list|(
literal|"invalid %%-code"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|putc
argument_list|(
name|c
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
name|output_asm_name
argument_list|()
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output a LABEL_REF, or a bare CODE_LABEL, as an assembler symbol.  */
end_comment

begin_function
name|void
name|output_asm_label
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LABEL_REF
condition|)
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|output_operand_lossage
argument_list|(
literal|"`%l' operand isn't a label"
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|asm_out_file
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print operand X using machine-dependent assembler syntax.    The macro PRINT_OPERAND is defined just to control this function.    CODE is a non-digit that preceded the operand-number in the % spec,    such as 'z' if the spec was `%z3'.  CODE is 0 if there was no char    between the % and the digits.    When CODE is a non-letter, X is 0.     The meanings of the letters are machine-dependent and controlled    by PRINT_OPERAND.  */
end_comment

begin_function
specifier|static
name|void
name|output_operand
parameter_list|(
name|x
parameter_list|,
name|code
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|int
name|code
decl_stmt|;
block|{
if|if
condition|(
name|x
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
condition|)
name|x
operator|=
name|alter_subreg
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* If X is a pseudo-register, abort now rather than writing trash to the      assembler file.  */
if|if
condition|(
name|x
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|abort
argument_list|()
expr_stmt|;
name|PRINT_OPERAND
argument_list|(
name|asm_out_file
argument_list|,
name|x
argument_list|,
name|code
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print a memory reference operand for address X    using machine-dependent assembler syntax.    The macro PRINT_OPERAND_ADDRESS exists just to control this function.  */
end_comment

begin_function
name|void
name|output_address
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|walk_alter_subreg
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|PRINT_OPERAND_ADDRESS
argument_list|(
name|asm_out_file
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print an integer constant expression in assembler syntax.    Addition and subtraction are the only arithmetic    that may appear in these expressions.  */
end_comment

begin_function
name|void
name|output_addr_const
parameter_list|(
name|file
parameter_list|,
name|x
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|restart
label|:
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|PC
case|:
if|if
condition|(
name|flag_pic
condition|)
name|putc
argument_list|(
literal|'.'
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
break|break;
case|case
name|SYMBOL_REF
case|:
name|assemble_name
argument_list|(
name|file
argument_list|,
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LABEL_REF
case|:
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|CODE_LABEL
case|:
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST_INT
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST
case|:
comment|/* This used to output parentheses around the expression, 	 but that does not work on the 386 (either ATT or BSD assembler).  */
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST_DOUBLE
case|:
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|VOIDmode
condition|)
block|{
comment|/* We can use %d if the number is one word and positive.  */
if|if
condition|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DOUBLE_HEX
argument_list|,
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
argument_list|,
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_HEX
argument_list|,
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* We can't handle floating point constants; 	   PRINT_OPERAND must handle them.  */
name|output_operand_lossage
argument_list|(
literal|"floating constant misused"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PLUS
case|:
comment|/* Some assemblers need integer constants to appear last (eg masm).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"+"
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"+"
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|MINUS
case|:
comment|/* Avoid outputting things like x-x or x+5-x, 	 since some assemblers can't handle that.  */
name|x
operator|=
name|simplify_subtraction
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MINUS
condition|)
goto|goto
name|restart
goto|;
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
name|ASM_OPEN_PAREN
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|ASM_CLOSE_PAREN
argument_list|)
expr_stmt|;
block|}
else|else
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZERO_EXTEND
case|:
case|case
name|SIGN_EXTEND
case|:
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|output_operand_lossage
argument_list|(
literal|"invalid expression as operand"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A poor man's fprintf, with the added features of %I, %R, %L, and %U.    %R prints the value of REGISTER_PREFIX.    %L prints the value of LOCAL_LABEL_PREFIX.    %U prints the value of USER_LABEL_PREFIX.    %I prints the value of IMMEDIATE_PREFIX.    %O runs ASM_OUTPUT_OPCODE to transform what follows in the string.    Also supported are %d, %x, %s, %e, %f, %g and %%.     We handle alternate assembler dialects here, just like output_asm_insn.  */
end_comment

begin_decl_stmt
name|void
name|asm_fprintf
name|VPROTO
argument_list|(
operator|(
name|FILE
operator|*
name|file
operator|,
specifier|const
name|char
operator|*
name|p
operator|,
operator|...
operator|)
argument_list|)
block|{
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
name|FILE
modifier|*
name|file
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
endif|#
directive|endif
name|va_list
name|argptr
decl_stmt|;
name|char
name|buf
index|[
literal|10
index|]
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|,
name|c
decl_stmt|;
name|VA_START
argument_list|(
name|argptr
argument_list|,
name|p
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ANSI_PROTOTYPES
name|file
operator|=
name|va_arg
argument_list|(
name|argptr
argument_list|,
name|FILE
operator|*
argument_list|)
expr_stmt|;
name|p
operator|=
name|va_arg
argument_list|(
name|argptr
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|buf
index|[
literal|0
index|]
operator|=
literal|'%'
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
ifdef|#
directive|ifdef
name|ASSEMBLER_DIALECT
case|case
literal|'{'
case|:
block|{
name|int
name|i
decl_stmt|;
comment|/* If we want the first dialect, do nothing.  Otherwise, skip 	     DIALECT_NUMBER of strings ending with '|'.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dialect_number
condition|;
name|i
operator|++
control|)
block|{
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|++
operator|!=
literal|'|'
condition|)
empty_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'|'
condition|)
name|p
operator|++
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'|'
case|:
comment|/* Skip to close brace.  */
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|++
operator|!=
literal|'}'
condition|)
empty_stmt|;
break|break;
case|case
literal|'}'
case|:
break|break;
endif|#
directive|endif
case|case
literal|'%'
case|:
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|q
operator|=
operator|&
name|buf
index|[
literal|1
index|]
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
operator|)
operator|||
name|c
operator|==
literal|'.'
condition|)
block|{
operator|*
name|q
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'%'
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%%"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'i'
case|:
case|case
literal|'u'
case|:
case|case
literal|'x'
case|:
case|case
literal|'p'
case|:
case|case
literal|'X'
case|:
case|case
literal|'o'
case|:
operator|*
name|q
operator|++
operator|=
name|c
expr_stmt|;
operator|*
name|q
operator|=
literal|0
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|buf
argument_list|,
name|va_arg
argument_list|(
name|argptr
argument_list|,
name|int
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
comment|/* This is a prefix to the 'd', 'i', 'u', 'x', 'p', and 'X' cases, 	       but we do not check for those cases.  It means that the value 	       is a HOST_WIDE_INT, which may be either `int' or `long'.  */
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
name|HOST_BITS_PER_INT
else|#
directive|else
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
name|HOST_BITS_PER_LONG
operator|*
name|q
operator|++
operator|=
literal|'l'
expr_stmt|;
else|#
directive|else
operator|*
name|q
operator|++
operator|=
literal|'l'
expr_stmt|;
operator|*
name|q
operator|++
operator|=
literal|'l'
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|q
operator|=
literal|0
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|buf
argument_list|,
name|va_arg
argument_list|(
name|argptr
argument_list|,
name|HOST_WIDE_INT
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
operator|*
name|q
operator|++
operator|=
name|c
expr_stmt|;
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|q
operator|=
literal|0
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|buf
argument_list|,
name|va_arg
argument_list|(
name|argptr
argument_list|,
name|long
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
case|case
literal|'f'
case|:
case|case
literal|'g'
case|:
operator|*
name|q
operator|++
operator|=
name|c
expr_stmt|;
operator|*
name|q
operator|=
literal|0
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|buf
argument_list|,
name|va_arg
argument_list|(
name|argptr
argument_list|,
name|double
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
operator|*
name|q
operator|++
operator|=
name|c
expr_stmt|;
operator|*
name|q
operator|=
literal|0
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|buf
argument_list|,
name|va_arg
argument_list|(
name|argptr
argument_list|,
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
ifdef|#
directive|ifdef
name|ASM_OUTPUT_OPCODE
name|ASM_OUTPUT_OPCODE
argument_list|(
name|asm_out_file
argument_list|,
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'R'
case|:
ifdef|#
directive|ifdef
name|REGISTER_PREFIX
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|REGISTER_PREFIX
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'I'
case|:
ifdef|#
directive|ifdef
name|IMMEDIATE_PREFIX
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|IMMEDIATE_PREFIX
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'L'
case|:
ifdef|#
directive|ifdef
name|LOCAL_LABEL_PREFIX
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|LOCAL_LABEL_PREFIX
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'U'
case|:
name|fputs
argument_list|(
name|user_label_prefix
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
default|default:
name|fputc
argument_list|(
name|c
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Split up a CONST_DOUBLE or integer constant rtx    into two rtx's for single words,    storing in *FIRST the word that comes first in memory in the target    and in *SECOND the other.  */
end_comment

begin_function
name|void
name|split_double
parameter_list|(
name|value
parameter_list|,
name|first
parameter_list|,
name|second
parameter_list|)
name|rtx
name|value
decl_stmt|;
name|rtx
modifier|*
name|first
decl_stmt|,
decl|*
name|second
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|HOST_BITS_PER_WIDE_INT
operator|>=
operator|(
literal|2
operator|*
name|BITS_PER_WORD
operator|)
condition|)
block|{
comment|/* In this case the CONST_INT holds both target words. 	     Extract the bits from it into two word-sized pieces. 	     Sign extend each half to HOST_WIDE_INT.  */
name|rtx
name|low
decl_stmt|,
name|high
decl_stmt|;
comment|/* On machines where HOST_BITS_PER_WIDE_INT == BITS_PER_WORD 	     the shift below will cause a compiler warning, even though 	     this code won't be executed.  So put the shift amounts in 	     variables to avoid the warning.  */
name|int
name|rshift
init|=
name|HOST_BITS_PER_WIDE_INT
operator|-
name|BITS_PER_WORD
decl_stmt|;
name|int
name|lshift
init|=
name|HOST_BITS_PER_WIDE_INT
operator|-
literal|2
operator|*
name|BITS_PER_WORD
decl_stmt|;
name|low
operator|=
name|GEN_INT
argument_list|(
operator|(
name|INTVAL
argument_list|(
name|value
argument_list|)
operator|<<
name|rshift
operator|)
operator|>>
name|rshift
argument_list|)
expr_stmt|;
name|high
operator|=
name|GEN_INT
argument_list|(
operator|(
name|INTVAL
argument_list|(
name|value
argument_list|)
operator|<<
name|lshift
operator|)
operator|>>
name|rshift
argument_list|)
expr_stmt|;
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
block|{
operator|*
name|first
operator|=
name|high
expr_stmt|;
operator|*
name|second
operator|=
name|low
expr_stmt|;
block|}
else|else
block|{
operator|*
name|first
operator|=
name|low
expr_stmt|;
operator|*
name|second
operator|=
name|high
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* The rule for using CONST_INT for a wider mode 	     is that we regard the value as signed. 	     So sign-extend it.  */
name|rtx
name|high
init|=
operator|(
name|INTVAL
argument_list|(
name|value
argument_list|)
operator|<
literal|0
condition|?
name|constm1_rtx
else|:
name|const0_rtx
operator|)
decl_stmt|;
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
block|{
operator|*
name|first
operator|=
name|high
expr_stmt|;
operator|*
name|second
operator|=
name|value
expr_stmt|;
block|}
else|else
block|{
operator|*
name|first
operator|=
name|value
expr_stmt|;
operator|*
name|second
operator|=
name|high
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|!=
name|CONST_DOUBLE
condition|)
block|{
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
block|{
operator|*
name|first
operator|=
name|const0_rtx
expr_stmt|;
operator|*
name|second
operator|=
name|value
expr_stmt|;
block|}
else|else
block|{
operator|*
name|first
operator|=
name|value
expr_stmt|;
operator|*
name|second
operator|=
name|const0_rtx
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
operator|==
name|VOIDmode
comment|/* This is the old way we did CONST_DOUBLE integers.  */
operator|||
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|MODE_INT
condition|)
block|{
comment|/* In an integer, the words are defined as most and least significant. 	 So order them by the target's convention.  */
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
block|{
operator|*
name|first
operator|=
name|GEN_INT
argument_list|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|second
operator|=
name|GEN_INT
argument_list|(
name|CONST_DOUBLE_LOW
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|first
operator|=
name|GEN_INT
argument_list|(
name|CONST_DOUBLE_LOW
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|second
operator|=
name|GEN_INT
argument_list|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|REAL_ARITHMETIC
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|long
name|l
index|[
literal|2
index|]
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|r
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|/* Note, this converts the REAL_VALUE_TYPE to the target's 	 format, splits up the floating point double and outputs 	 exactly 32 bits of it into each of l[0] and l[1] -- 	 not necessarily BITS_PER_WORD bits.  */
name|REAL_VALUE_TO_TARGET_DOUBLE
argument_list|(
name|r
argument_list|,
name|l
argument_list|)
expr_stmt|;
comment|/* If 32 bits is an entire word for the target, but not for the host, 	 then sign-extend on the host so that the number will look the same 	 way on the host that it would on the target.  See for instance 	 simplify_unary_operation.  The #if is needed to avoid compiler 	 warnings.  */
if|#
directive|if
name|HOST_BITS_PER_LONG
operator|>
literal|32
if|if
condition|(
name|BITS_PER_WORD
operator|<
name|HOST_BITS_PER_LONG
operator|&&
name|BITS_PER_WORD
operator|==
literal|32
condition|)
block|{
if|if
condition|(
name|l
index|[
literal|0
index|]
operator|&
operator|(
operator|(
name|long
operator|)
literal|1
operator|<<
literal|31
operator|)
condition|)
name|l
index|[
literal|0
index|]
operator||=
operator|(
call|(
name|long
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
literal|32
operator|)
expr_stmt|;
if|if
condition|(
name|l
index|[
literal|1
index|]
operator|&
operator|(
operator|(
name|long
operator|)
literal|1
operator|<<
literal|31
operator|)
condition|)
name|l
index|[
literal|1
index|]
operator||=
operator|(
call|(
name|long
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
literal|32
operator|)
expr_stmt|;
block|}
endif|#
directive|endif
operator|*
name|first
operator|=
name|GEN_INT
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|)
name|l
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
operator|*
name|second
operator|=
name|GEN_INT
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|)
name|l
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|(
name|HOST_FLOAT_FORMAT
operator|!=
name|TARGET_FLOAT_FORMAT
operator|||
name|HOST_BITS_PER_WIDE_INT
operator|!=
name|BITS_PER_WORD
operator|)
operator|&&
operator|!
name|flag_pretend_float
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
ifdef|#
directive|ifdef
name|HOST_WORDS_BIG_ENDIAN
name|WORDS_BIG_ENDIAN
else|#
directive|else
operator|!
name|WORDS_BIG_ENDIAN
endif|#
directive|endif
condition|)
block|{
comment|/* Host and target agree => no need to swap.  */
operator|*
name|first
operator|=
name|GEN_INT
argument_list|(
name|CONST_DOUBLE_LOW
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|second
operator|=
name|GEN_INT
argument_list|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|second
operator|=
name|GEN_INT
argument_list|(
name|CONST_DOUBLE_LOW
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|first
operator|=
name|GEN_INT
argument_list|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* no REAL_ARITHMETIC */
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if this function has no function calls.  */
end_comment

begin_function
name|int
name|leaf_function_p
parameter_list|()
block|{
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
name|profile_flag
operator|||
name|profile_block_flag
operator|||
name|profile_arc_flag
condition|)
return|return
literal|0
return|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CALL_INSN
condition|)
return|return
literal|0
return|;
block|}
for|for
control|(
name|insn
operator|=
name|current_function_epilogue_delay_list
init|;
name|insn
condition|;
name|insn
operator|=
name|XEXP
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CALL_INSN
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|XEXP
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|XEXP
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CALL_INSN
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* On some machines, a function with no call insns    can run faster if it doesn't create its own register window.    When output, the leaf function should use only the "output"    registers.  Ordinarily, the function would be compiled to use    the "input" registers to find its arguments; it is a candidate    for leaf treatment if it uses only the "input" registers.    Leaf function treatment means renumbering so the function    uses the "output" registers instead.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|LEAF_REGISTERS
end_ifdef

begin_decl_stmt
specifier|static
name|char
name|permitted_reg_in_leaf_functions
index|[]
init|=
name|LEAF_REGISTERS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return 1 if this function uses only the registers that can be    safely renumbered.  */
end_comment

begin_function
name|int
name|only_leaf_regs_used
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|regs_ever_live
index|[
name|i
index|]
operator|||
name|global_regs
index|[
name|i
index|]
operator|)
operator|&&
operator|!
name|permitted_reg_in_leaf_functions
index|[
name|i
index|]
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|current_function_uses_pic_offset_table
operator|&&
name|pic_offset_table_rtx
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|pic_offset_table_rtx
argument_list|)
operator|==
name|REG
operator|&&
operator|!
name|permitted_reg_in_leaf_functions
index|[
name|REGNO
argument_list|(
name|pic_offset_table_rtx
argument_list|)
index|]
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Scan all instructions and renumber all registers into those    available in leaf functions.  */
end_comment

begin_function
specifier|static
name|void
name|leaf_renumber_regs
parameter_list|(
name|first
parameter_list|)
name|rtx
name|first
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
comment|/* Renumber only the actual patterns.      The reg-notes can contain frame pointer refs,      and renumbering them could crash, and should not be needed.  */
for|for
control|(
name|insn
operator|=
name|first
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
name|leaf_renumber_regs_insn
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|current_function_epilogue_delay_list
init|;
name|insn
condition|;
name|insn
operator|=
name|XEXP
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
name|leaf_renumber_regs_insn
argument_list|(
name|PATTERN
argument_list|(
name|XEXP
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Scan IN_RTX and its subexpressions, and renumber all regs into those    available in leaf functions.  */
end_comment

begin_function
name|void
name|leaf_renumber_regs_insn
parameter_list|(
name|in_rtx
parameter_list|)
specifier|register
name|rtx
name|in_rtx
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|char
modifier|*
name|format_ptr
decl_stmt|;
if|if
condition|(
name|in_rtx
operator|==
literal|0
condition|)
return|return;
comment|/* Renumber all input-registers into output-registers.      renumbered_regs would be 1 for an output-register;      they  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|in_rtx
argument_list|)
operator|==
name|REG
condition|)
block|{
name|int
name|newreg
decl_stmt|;
comment|/* Don't renumber the same reg twice.  */
if|if
condition|(
name|in_rtx
operator|->
name|used
condition|)
return|return;
name|newreg
operator|=
name|REGNO
argument_list|(
name|in_rtx
argument_list|)
expr_stmt|;
comment|/* Don't try to renumber pseudo regs.  It is possible for a pseudo reg 	 to reach here as part of a REG_NOTE.  */
if|if
condition|(
name|newreg
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|in_rtx
operator|->
name|used
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|newreg
operator|=
name|LEAF_REG_REMAP
argument_list|(
name|newreg
argument_list|)
expr_stmt|;
if|if
condition|(
name|newreg
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|regs_ever_live
index|[
name|REGNO
argument_list|(
name|in_rtx
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
name|regs_ever_live
index|[
name|newreg
index|]
operator|=
literal|1
expr_stmt|;
name|REGNO
argument_list|(
name|in_rtx
argument_list|)
operator|=
name|newreg
expr_stmt|;
name|in_rtx
operator|->
name|used
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|in_rtx
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
block|{
comment|/* Inside a SEQUENCE, we find insns. 	 Renumber just the patterns of these insns, 	 just as we do for the top-level insns.  */
name|leaf_renumber_regs_insn
argument_list|(
name|PATTERN
argument_list|(
name|in_rtx
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|format_ptr
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|in_rtx
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|in_rtx
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
switch|switch
condition|(
operator|*
name|format_ptr
operator|++
condition|)
block|{
case|case
literal|'e'
case|:
name|leaf_renumber_regs_insn
argument_list|(
name|XEXP
argument_list|(
name|in_rtx
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
if|if
condition|(
name|NULL
operator|!=
name|XVEC
argument_list|(
name|in_rtx
argument_list|,
name|i
argument_list|)
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|in_rtx
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|leaf_renumber_regs_insn
argument_list|(
name|XVECEXP
argument_list|(
name|in_rtx
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'S'
case|:
case|case
literal|'s'
case|:
case|case
literal|'0'
case|:
case|case
literal|'i'
case|:
case|case
literal|'w'
case|:
case|case
literal|'n'
case|:
case|case
literal|'u'
case|:
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

