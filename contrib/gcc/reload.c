begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Search an insn for pseudo regs that must be in hard regs and are not.    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This file contains subroutines used only from the file reload1.c.    It knows how to scan one insn for operands and values    that need to be copied into registers to make valid code.    It also finds other operands and values which are valid    but for which equivalent values in registers exist and    ought to be used instead.     Before processing the first insn of the function, call `init_reload'.     To scan an insn, call `find_reloads'.  This does two things:    1. sets up tables describing which values must be reloaded    for this insn, and what kind of hard regs they must be reloaded into;    2. optionally record the locations where those values appear in    the data, so they can be replaced properly later.    This is done only if the second arg to `find_reloads' is nonzero.     The third arg to `find_reloads' specifies the number of levels    of indirect addressing supported by the machine.  If it is zero,    indirect addressing is not valid.  If it is one, (MEM (REG n))    is valid even if (REG n) did not get a hard register; if it is two,    (MEM (MEM (REG n))) is also valid even if (REG n) did not get a    hard register, and similarly for higher values.     Then you must choose the hard regs to reload those pseudo regs into,    and generate appropriate load insns before this insn and perhaps    also store insns after this insn.  Set up the array `reload_reg_rtx'    to contain the REG rtx's for the registers you used.  In some    cases `find_reloads' will return a nonzero value in `reload_reg_rtx'    for certain reloads.  Then that tells you which register to use,    so you do not need to allocate one.  But you still do need to add extra    instructions to copy the value into and out of that register.     Finally you must call `subst_reloads' to substitute the reload reg rtx's    into the locations already recorded.  NOTE SIDE EFFECTS:     find_reloads can alter the operands of the instruction it is called on.     1. Two operands of any sort may be interchanged, if they are in a    commutative instruction.    This happens only if find_reloads thinks the instruction will compile    better that way.     2. Pseudo-registers that are equivalent to constants are replaced    with those constants if they are not in hard registers.  1 happens every time find_reloads is called. 2 happens only when REPLACE is 1, which is only when actually doing the reloads, not when just counting them.  Using a reload register for several reloads in one insn:  When an insn has reloads, it is considered as having three parts: the input reloads, the insn itself after reloading, and the output reloads. Reloads of values used in memory addresses are often needed for only one part.  When this is so, reload_when_needed records which part needs the reload. Two reloads for different parts of the insn can share the same reload register.  When a reload is used for addresses in multiple parts, or when it is an ordinary operand, it is classified as RELOAD_OTHER, and cannot share a register with any other reload.  */
end_comment

begin_define
define|#
directive|define
name|REG_OK_STRICT
end_define

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"optabs.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"reload.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|REGISTER_MOVE_COST
end_ifndef

begin_define
define|#
directive|define
name|REGISTER_MOVE_COST
parameter_list|(
name|m
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|)
value|2
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|REGNO_MODE_OK_FOR_BASE_P
end_ifndef

begin_define
define|#
directive|define
name|REGNO_MODE_OK_FOR_BASE_P
parameter_list|(
name|REGNO
parameter_list|,
name|MODE
parameter_list|)
value|REGNO_OK_FOR_BASE_P (REGNO)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|REG_MODE_OK_FOR_BASE_P
end_ifndef

begin_define
define|#
directive|define
name|REG_MODE_OK_FOR_BASE_P
parameter_list|(
name|REGNO
parameter_list|,
name|MODE
parameter_list|)
value|REG_OK_FOR_BASE_P (REGNO)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* All reloads of the current insn are recorded here.  See reload.h for    comments.  */
end_comment

begin_decl_stmt
name|int
name|n_reloads
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|reload
name|rld
index|[
name|MAX_RELOADS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* All the "earlyclobber" operands of the current insn    are recorded here.  */
end_comment

begin_decl_stmt
name|int
name|n_earlyclobbers
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|reload_earlyclobbers
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|reload_n_operands
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Replacing reloads.     If `replace_reloads' is nonzero, then as each reload is recorded    an entry is made for it in the table `replacements'.    Then later `subst_reloads' can look through that table and    perform all the replacements needed.  */
end_comment

begin_comment
comment|/* Nonzero means record the places to replace.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|replace_reloads
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Each replacement is recorded with a structure like this.  */
end_comment

begin_struct
struct|struct
name|replacement
block|{
name|rtx
modifier|*
name|where
decl_stmt|;
comment|/* Location to store in */
name|rtx
modifier|*
name|subreg_loc
decl_stmt|;
comment|/* Location of SUBREG if WHERE is inside 				   a SUBREG; 0 otherwise.  */
name|int
name|what
decl_stmt|;
comment|/* which reload this is for */
name|enum
name|machine_mode
name|mode
decl_stmt|;
comment|/* mode it must have */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|replacement
name|replacements
index|[
name|MAX_RECOG_OPERANDS
operator|*
operator|(
operator|(
name|MAX_REGS_PER_ADDRESS
operator|*
literal|2
operator|)
operator|+
literal|1
operator|)
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of replacements currently recorded.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|n_replacements
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used to track what is modified by an operand.  */
end_comment

begin_struct
struct|struct
name|decomposition
block|{
name|int
name|reg_flag
decl_stmt|;
comment|/* Nonzero if referencing a register.  */
name|int
name|safe
decl_stmt|;
comment|/* Nonzero if this can't conflict with anything.  */
name|rtx
name|base
decl_stmt|;
comment|/* Base address for MEM.  */
name|HOST_WIDE_INT
name|start
decl_stmt|;
comment|/* Starting offset or register number.  */
name|HOST_WIDE_INT
name|end
decl_stmt|;
comment|/* Ending offset or register number.  */
block|}
struct|;
end_struct

begin_ifdef
ifdef|#
directive|ifdef
name|SECONDARY_MEMORY_NEEDED
end_ifdef

begin_comment
comment|/* Save MEMs needed to copy from one class of registers to another.  One MEM    is used per mode, but normally only one or two modes are ever used.     We keep two versions, before and after register elimination.  The one    after register elimination is record separately for each operand.  This    is done in case the address is not valid to be sure that we separately    reload each.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|secondary_memlocs
index|[
name|NUM_MACHINE_MODES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|secondary_memlocs_elim
index|[
name|NUM_MACHINE_MODES
index|]
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The instruction we are doing reloads for;    so we can test whether a register dies in it.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|this_insn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if this instruction is a user-specified asm with operands.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|this_insn_is_asm
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If hard_regs_live_known is nonzero,    we can tell which hard regs are currently live,    at least enough to succeed in choosing dummy reloads.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|hard_regs_live_known
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by hard reg number,    element is nonnegative if hard reg has been spilled.    This vector is passed to `find_reloads' as an argument    and is not changed here.  */
end_comment

begin_decl_stmt
specifier|static
name|short
modifier|*
name|static_reload_reg_p
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to 1 in subst_reg_equivs if it changes anything.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|subst_reg_equivs_changed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* On return from push_reload, holds the reload-number for the OUT    operand, which can be different for that from the input operand.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|output_reloadnum
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Compare two RTX's.  */
end_comment

begin_define
define|#
directive|define
name|MATCHES
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
define|\
value|(x == y || (x != 0&& (GET_CODE (x) == REG				\ 			? GET_CODE (y) == REG&& REGNO (x) == REGNO (y)	\ 			: rtx_equal_p (x, y)&& ! side_effects_p (x))))
end_define

begin_comment
comment|/* Indicates if two reloads purposes are for similar enough things that we      can merge their reloads.  */
end_comment

begin_define
define|#
directive|define
name|MERGABLE_RELOADS
parameter_list|(
name|when1
parameter_list|,
name|when2
parameter_list|,
name|op1
parameter_list|,
name|op2
parameter_list|)
define|\
value|((when1) == RELOAD_OTHER || (when2) == RELOAD_OTHER	\    || ((when1) == (when2)&& (op1) == (op2))		\    || ((when1) == RELOAD_FOR_INPUT&& (when2) == RELOAD_FOR_INPUT) \    || ((when1) == RELOAD_FOR_OPERAND_ADDRESS		\&& (when2) == RELOAD_FOR_OPERAND_ADDRESS)	\    || ((when1) == RELOAD_FOR_OTHER_ADDRESS		\&& (when2) == RELOAD_FOR_OTHER_ADDRESS))
end_define

begin_comment
comment|/* Nonzero if these two reload purposes produce RELOAD_OTHER when merged.  */
end_comment

begin_define
define|#
directive|define
name|MERGE_TO_OTHER
parameter_list|(
name|when1
parameter_list|,
name|when2
parameter_list|,
name|op1
parameter_list|,
name|op2
parameter_list|)
define|\
value|((when1) != (when2)					\    || ! ((op1) == (op2)					\ 	 || (when1) == RELOAD_FOR_INPUT			\ 	 || (when1) == RELOAD_FOR_OPERAND_ADDRESS	\ 	 || (when1) == RELOAD_FOR_OTHER_ADDRESS))
end_define

begin_comment
comment|/* If we are going to reload an address, compute the reload type to      use.  */
end_comment

begin_define
define|#
directive|define
name|ADDR_TYPE
parameter_list|(
name|type
parameter_list|)
define|\
value|((type) == RELOAD_FOR_INPUT_ADDRESS			\    ? RELOAD_FOR_INPADDR_ADDRESS				\    : ((type) == RELOAD_FOR_OUTPUT_ADDRESS		\       ? RELOAD_FOR_OUTADDR_ADDRESS			\       : (type)))
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SECONDARY_RELOADS
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|push_secondary_reload
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|rtx
operator|,
name|int
operator|,
name|int
operator|,
expr|enum
name|reg_class
operator|,
expr|enum
name|machine_mode
operator|,
expr|enum
name|reload_type
operator|,
expr|enum
name|insn_code
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|enum
name|reg_class
name|find_valid_class
name|PARAMS
argument_list|(
operator|(
expr|enum
name|machine_mode
operator|,
name|int
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reload_inner_reg_of_subreg
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
expr|enum
name|machine_mode
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|push_replacement
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|*
operator|,
name|int
operator|,
expr|enum
name|machine_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|combine_reloads
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|find_reusable_reload
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|*
operator|,
name|rtx
operator|,
expr|enum
name|reg_class
operator|,
expr|enum
name|reload_type
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|find_dummy_reload
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|*
operator|,
name|rtx
operator|*
operator|,
expr|enum
name|machine_mode
operator|,
expr|enum
name|machine_mode
operator|,
expr|enum
name|reg_class
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hard_reg_set_here_p
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|,
name|unsigned
name|int
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|decomposition
name|decompose
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|immune_p
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
expr|struct
name|decomposition
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|alternative_allows_memconst
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|find_reloads_toplev
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|,
expr|enum
name|reload_type
operator|,
name|int
operator|,
name|int
operator|,
name|rtx
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|make_memloc
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|find_reloads_address
name|PARAMS
argument_list|(
operator|(
expr|enum
name|machine_mode
operator|,
name|rtx
operator|*
operator|,
name|rtx
operator|,
name|rtx
operator|*
operator|,
name|int
operator|,
expr|enum
name|reload_type
operator|,
name|int
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|subst_reg_equivs
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|subst_indexed_address
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|update_auto_inc_notes
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|find_reloads_address_1
name|PARAMS
argument_list|(
operator|(
expr|enum
name|machine_mode
operator|,
name|rtx
operator|,
name|int
operator|,
name|rtx
operator|*
operator|,
name|int
operator|,
expr|enum
name|reload_type
operator|,
name|int
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|find_reloads_address_part
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|*
operator|,
expr|enum
name|reg_class
operator|,
expr|enum
name|machine_mode
operator|,
name|int
operator|,
expr|enum
name|reload_type
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|find_reloads_subreg_address
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|,
name|int
operator|,
expr|enum
name|reload_type
operator|,
name|int
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|copy_replacements_1
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|*
operator|,
name|rtx
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|find_inc_amount
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SECONDARY_RELOADS
end_ifdef

begin_comment
comment|/* Determine if any secondary reloads are needed for loading (if IN_P is    non-zero) or storing (if IN_P is zero) X to or from a reload register of    register class RELOAD_CLASS in mode RELOAD_MODE.  If secondary reloads    are needed, push them.     Return the reload number of the secondary reload we made, or -1 if    we didn't need one.  *PICODE is set to the insn_code to use if we do    need a secondary reload.  */
end_comment

begin_function
specifier|static
name|int
name|push_secondary_reload
parameter_list|(
name|in_p
parameter_list|,
name|x
parameter_list|,
name|opnum
parameter_list|,
name|optional
parameter_list|,
name|reload_class
parameter_list|,
name|reload_mode
parameter_list|,
name|type
parameter_list|,
name|picode
parameter_list|)
name|int
name|in_p
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|int
name|opnum
decl_stmt|;
name|int
name|optional
decl_stmt|;
name|enum
name|reg_class
name|reload_class
decl_stmt|;
name|enum
name|machine_mode
name|reload_mode
decl_stmt|;
name|enum
name|reload_type
name|type
decl_stmt|;
name|enum
name|insn_code
modifier|*
name|picode
decl_stmt|;
block|{
name|enum
name|reg_class
name|class
init|=
name|NO_REGS
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|reload_mode
decl_stmt|;
name|enum
name|insn_code
name|icode
init|=
name|CODE_FOR_nothing
decl_stmt|;
name|enum
name|reg_class
name|t_class
init|=
name|NO_REGS
decl_stmt|;
name|enum
name|machine_mode
name|t_mode
init|=
name|VOIDmode
decl_stmt|;
name|enum
name|insn_code
name|t_icode
init|=
name|CODE_FOR_nothing
decl_stmt|;
name|enum
name|reload_type
name|secondary_type
decl_stmt|;
name|int
name|s_reload
decl_stmt|,
name|t_reload
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|RELOAD_FOR_INPUT_ADDRESS
operator|||
name|type
operator|==
name|RELOAD_FOR_OUTPUT_ADDRESS
operator|||
name|type
operator|==
name|RELOAD_FOR_INPADDR_ADDRESS
operator|||
name|type
operator|==
name|RELOAD_FOR_OUTADDR_ADDRESS
condition|)
name|secondary_type
operator|=
name|type
expr_stmt|;
else|else
name|secondary_type
operator|=
name|in_p
condition|?
name|RELOAD_FOR_INPUT_ADDRESS
else|:
name|RELOAD_FOR_OUTPUT_ADDRESS
expr_stmt|;
operator|*
name|picode
operator|=
name|CODE_FOR_nothing
expr_stmt|;
comment|/* If X is a paradoxical SUBREG, use the inner value to determine both the      mode and object being reloaded.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|x
operator|=
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|reload_mode
operator|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
comment|/* If X is a pseudo-register that has an equivalent MEM (actually, if it      is still a pseudo-register by now, it *must* have an equivalent MEM      but we don't want to assume that), use that equivalent when seeing if      a secondary reload is needed since whether or not a reload is needed      might be sensitive to the form of the MEM.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|reg_equiv_mem
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
operator|!=
literal|0
condition|)
name|x
operator|=
name|reg_equiv_mem
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|SECONDARY_INPUT_RELOAD_CLASS
if|if
condition|(
name|in_p
condition|)
name|class
operator|=
name|SECONDARY_INPUT_RELOAD_CLASS
argument_list|(
name|reload_class
argument_list|,
name|reload_mode
argument_list|,
name|x
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SECONDARY_OUTPUT_RELOAD_CLASS
if|if
condition|(
operator|!
name|in_p
condition|)
name|class
operator|=
name|SECONDARY_OUTPUT_RELOAD_CLASS
argument_list|(
name|reload_class
argument_list|,
name|reload_mode
argument_list|,
name|x
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If we don't need any secondary registers, done.  */
if|if
condition|(
name|class
operator|==
name|NO_REGS
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Get a possible insn to use.  If the predicate doesn't accept X, don't      use the insn.  */
name|icode
operator|=
operator|(
name|in_p
condition|?
name|reload_in_optab
index|[
operator|(
name|int
operator|)
name|reload_mode
index|]
else|:
name|reload_out_optab
index|[
operator|(
name|int
operator|)
name|reload_mode
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|icode
operator|!=
name|CODE_FOR_nothing
operator|&&
name|insn_data
index|[
operator|(
name|int
operator|)
name|icode
index|]
operator|.
name|operand
index|[
name|in_p
index|]
operator|.
name|predicate
operator|&&
operator|(
operator|!
operator|(
name|insn_data
index|[
operator|(
name|int
operator|)
name|icode
index|]
operator|.
name|operand
index|[
name|in_p
index|]
operator|.
name|predicate
operator|)
operator|(
name|x
operator|,
name|reload_mode
operator|)
operator|)
condition|)
name|icode
operator|=
name|CODE_FOR_nothing
expr_stmt|;
comment|/* If we will be using an insn, see if it can directly handle the reload      register we will be using.  If it can, the secondary reload is for a      scratch register.  If it can't, we will use the secondary reload for      an intermediate register and require a tertiary reload for the scratch      register.  */
if|if
condition|(
name|icode
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
comment|/* If IN_P is non-zero, the reload register will be the output in 	 operand 0.  If IN_P is zero, the reload register will be the input 	 in operand 1.  Outputs should have an initial "=", which we must 	 skip.  */
name|enum
name|reg_class
name|insn_class
decl_stmt|;
if|if
condition|(
name|insn_data
index|[
operator|(
name|int
operator|)
name|icode
index|]
operator|.
name|operand
index|[
operator|!
name|in_p
index|]
operator|.
name|constraint
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|insn_class
operator|=
name|ALL_REGS
expr_stmt|;
else|else
block|{
name|char
name|insn_letter
init|=
name|insn_data
index|[
operator|(
name|int
operator|)
name|icode
index|]
operator|.
name|operand
index|[
operator|!
name|in_p
index|]
operator|.
name|constraint
index|[
name|in_p
index|]
decl_stmt|;
name|insn_class
operator|=
operator|(
name|insn_letter
operator|==
literal|'r'
condition|?
name|GENERAL_REGS
else|:
name|REG_CLASS_FROM_LETTER
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|insn_letter
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|insn_class
operator|==
name|NO_REGS
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|in_p
operator|&&
name|insn_data
index|[
operator|(
name|int
operator|)
name|icode
index|]
operator|.
name|operand
index|[
operator|!
name|in_p
index|]
operator|.
name|constraint
index|[
literal|0
index|]
operator|!=
literal|'='
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* The scratch register's constraint must start with "=&".  */
if|if
condition|(
name|insn_data
index|[
operator|(
name|int
operator|)
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|constraint
index|[
literal|0
index|]
operator|!=
literal|'='
operator|||
name|insn_data
index|[
operator|(
name|int
operator|)
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|constraint
index|[
literal|1
index|]
operator|!=
literal|'&'
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|reg_class_subset_p
argument_list|(
name|reload_class
argument_list|,
name|insn_class
argument_list|)
condition|)
name|mode
operator|=
name|insn_data
index|[
operator|(
name|int
operator|)
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
expr_stmt|;
else|else
block|{
name|char
name|t_letter
init|=
name|insn_data
index|[
operator|(
name|int
operator|)
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|constraint
index|[
literal|2
index|]
decl_stmt|;
name|class
operator|=
name|insn_class
expr_stmt|;
name|t_mode
operator|=
name|insn_data
index|[
operator|(
name|int
operator|)
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
expr_stmt|;
name|t_class
operator|=
operator|(
name|t_letter
operator|==
literal|'r'
condition|?
name|GENERAL_REGS
else|:
name|REG_CLASS_FROM_LETTER
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|t_letter
argument_list|)
operator|)
expr_stmt|;
name|t_icode
operator|=
name|icode
expr_stmt|;
name|icode
operator|=
name|CODE_FOR_nothing
expr_stmt|;
block|}
block|}
comment|/* This case isn't valid, so fail.  Reload is allowed to use the same      register for RELOAD_FOR_INPUT_ADDRESS and RELOAD_FOR_INPUT reloads, but      in the case of a secondary register, we actually need two different      registers for correct code.  We fail here to prevent the possibility of      silently generating incorrect code later.       The convention is that secondary input reloads are valid only if the      secondary_class is different from class.  If you have such a case, you      can not use secondary reloads, you must work around the problem some      other way.       Allow this when a reload_in/out pattern is being used.  I.e. assume      that the generated code handles this case.  */
if|if
condition|(
name|in_p
operator|&&
name|class
operator|==
name|reload_class
operator|&&
name|icode
operator|==
name|CODE_FOR_nothing
operator|&&
name|t_icode
operator|==
name|CODE_FOR_nothing
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If we need a tertiary reload, see if we have one we can reuse or else      make a new one.  */
if|if
condition|(
name|t_class
operator|!=
name|NO_REGS
condition|)
block|{
for|for
control|(
name|t_reload
operator|=
literal|0
init|;
name|t_reload
operator|<
name|n_reloads
condition|;
name|t_reload
operator|++
control|)
if|if
condition|(
name|rld
index|[
name|t_reload
index|]
operator|.
name|secondary_p
operator|&&
operator|(
name|reg_class_subset_p
argument_list|(
name|t_class
argument_list|,
name|rld
index|[
name|t_reload
index|]
operator|.
name|class
argument_list|)
operator|||
name|reg_class_subset_p
argument_list|(
name|rld
index|[
name|t_reload
index|]
operator|.
name|class
argument_list|,
name|t_class
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|in_p
operator|&&
name|rld
index|[
name|t_reload
index|]
operator|.
name|inmode
operator|==
name|t_mode
operator|)
operator|||
operator|(
operator|!
name|in_p
operator|&&
name|rld
index|[
name|t_reload
index|]
operator|.
name|outmode
operator|==
name|t_mode
operator|)
operator|)
operator|&&
operator|(
operator|(
name|in_p
operator|&&
operator|(
name|rld
index|[
name|t_reload
index|]
operator|.
name|secondary_in_icode
operator|==
name|CODE_FOR_nothing
operator|)
operator|)
operator|||
operator|(
operator|!
name|in_p
operator|&&
operator|(
name|rld
index|[
name|t_reload
index|]
operator|.
name|secondary_out_icode
operator|==
name|CODE_FOR_nothing
operator|)
operator|)
operator|)
operator|&&
operator|(
name|reg_class_size
index|[
operator|(
name|int
operator|)
name|t_class
index|]
operator|==
literal|1
operator|||
name|SMALL_REGISTER_CLASSES
operator|)
operator|&&
name|MERGABLE_RELOADS
argument_list|(
name|secondary_type
argument_list|,
name|rld
index|[
name|t_reload
index|]
operator|.
name|when_needed
argument_list|,
name|opnum
argument_list|,
name|rld
index|[
name|t_reload
index|]
operator|.
name|opnum
argument_list|)
condition|)
block|{
if|if
condition|(
name|in_p
condition|)
name|rld
index|[
name|t_reload
index|]
operator|.
name|inmode
operator|=
name|t_mode
expr_stmt|;
if|if
condition|(
operator|!
name|in_p
condition|)
name|rld
index|[
name|t_reload
index|]
operator|.
name|outmode
operator|=
name|t_mode
expr_stmt|;
if|if
condition|(
name|reg_class_subset_p
argument_list|(
name|t_class
argument_list|,
name|rld
index|[
name|t_reload
index|]
operator|.
name|class
argument_list|)
condition|)
name|rld
index|[
name|t_reload
index|]
operator|.
name|class
operator|=
name|t_class
expr_stmt|;
name|rld
index|[
name|t_reload
index|]
operator|.
name|opnum
operator|=
name|MIN
argument_list|(
name|rld
index|[
name|t_reload
index|]
operator|.
name|opnum
argument_list|,
name|opnum
argument_list|)
expr_stmt|;
name|rld
index|[
name|t_reload
index|]
operator|.
name|optional
operator|&=
name|optional
expr_stmt|;
name|rld
index|[
name|t_reload
index|]
operator|.
name|secondary_p
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|MERGE_TO_OTHER
argument_list|(
name|secondary_type
argument_list|,
name|rld
index|[
name|t_reload
index|]
operator|.
name|when_needed
argument_list|,
name|opnum
argument_list|,
name|rld
index|[
name|t_reload
index|]
operator|.
name|opnum
argument_list|)
condition|)
name|rld
index|[
name|t_reload
index|]
operator|.
name|when_needed
operator|=
name|RELOAD_OTHER
expr_stmt|;
block|}
if|if
condition|(
name|t_reload
operator|==
name|n_reloads
condition|)
block|{
comment|/* We need to make a new tertiary reload for this register class.  */
name|rld
index|[
name|t_reload
index|]
operator|.
name|in
operator|=
name|rld
index|[
name|t_reload
index|]
operator|.
name|out
operator|=
literal|0
expr_stmt|;
name|rld
index|[
name|t_reload
index|]
operator|.
name|class
operator|=
name|t_class
expr_stmt|;
name|rld
index|[
name|t_reload
index|]
operator|.
name|inmode
operator|=
name|in_p
condition|?
name|t_mode
else|:
name|VOIDmode
expr_stmt|;
name|rld
index|[
name|t_reload
index|]
operator|.
name|outmode
operator|=
operator|!
name|in_p
condition|?
name|t_mode
else|:
name|VOIDmode
expr_stmt|;
name|rld
index|[
name|t_reload
index|]
operator|.
name|reg_rtx
operator|=
literal|0
expr_stmt|;
name|rld
index|[
name|t_reload
index|]
operator|.
name|optional
operator|=
name|optional
expr_stmt|;
name|rld
index|[
name|t_reload
index|]
operator|.
name|inc
operator|=
literal|0
expr_stmt|;
comment|/* Maybe we could combine these, but it seems too tricky.  */
name|rld
index|[
name|t_reload
index|]
operator|.
name|nocombine
operator|=
literal|1
expr_stmt|;
name|rld
index|[
name|t_reload
index|]
operator|.
name|in_reg
operator|=
literal|0
expr_stmt|;
name|rld
index|[
name|t_reload
index|]
operator|.
name|out_reg
operator|=
literal|0
expr_stmt|;
name|rld
index|[
name|t_reload
index|]
operator|.
name|opnum
operator|=
name|opnum
expr_stmt|;
name|rld
index|[
name|t_reload
index|]
operator|.
name|when_needed
operator|=
name|secondary_type
expr_stmt|;
name|rld
index|[
name|t_reload
index|]
operator|.
name|secondary_in_reload
operator|=
operator|-
literal|1
expr_stmt|;
name|rld
index|[
name|t_reload
index|]
operator|.
name|secondary_out_reload
operator|=
operator|-
literal|1
expr_stmt|;
name|rld
index|[
name|t_reload
index|]
operator|.
name|secondary_in_icode
operator|=
name|CODE_FOR_nothing
expr_stmt|;
name|rld
index|[
name|t_reload
index|]
operator|.
name|secondary_out_icode
operator|=
name|CODE_FOR_nothing
expr_stmt|;
name|rld
index|[
name|t_reload
index|]
operator|.
name|secondary_p
operator|=
literal|1
expr_stmt|;
name|n_reloads
operator|++
expr_stmt|;
block|}
block|}
comment|/* See if we can reuse an existing secondary reload.  */
for|for
control|(
name|s_reload
operator|=
literal|0
init|;
name|s_reload
operator|<
name|n_reloads
condition|;
name|s_reload
operator|++
control|)
if|if
condition|(
name|rld
index|[
name|s_reload
index|]
operator|.
name|secondary_p
operator|&&
operator|(
name|reg_class_subset_p
argument_list|(
name|class
argument_list|,
name|rld
index|[
name|s_reload
index|]
operator|.
name|class
argument_list|)
operator|||
name|reg_class_subset_p
argument_list|(
name|rld
index|[
name|s_reload
index|]
operator|.
name|class
argument_list|,
name|class
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|in_p
operator|&&
name|rld
index|[
name|s_reload
index|]
operator|.
name|inmode
operator|==
name|mode
operator|)
operator|||
operator|(
operator|!
name|in_p
operator|&&
name|rld
index|[
name|s_reload
index|]
operator|.
name|outmode
operator|==
name|mode
operator|)
operator|)
operator|&&
operator|(
operator|(
name|in_p
operator|&&
name|rld
index|[
name|s_reload
index|]
operator|.
name|secondary_in_reload
operator|==
name|t_reload
operator|)
operator|||
operator|(
operator|!
name|in_p
operator|&&
name|rld
index|[
name|s_reload
index|]
operator|.
name|secondary_out_reload
operator|==
name|t_reload
operator|)
operator|)
operator|&&
operator|(
operator|(
name|in_p
operator|&&
name|rld
index|[
name|s_reload
index|]
operator|.
name|secondary_in_icode
operator|==
name|t_icode
operator|)
operator|||
operator|(
operator|!
name|in_p
operator|&&
name|rld
index|[
name|s_reload
index|]
operator|.
name|secondary_out_icode
operator|==
name|t_icode
operator|)
operator|)
operator|&&
operator|(
name|reg_class_size
index|[
operator|(
name|int
operator|)
name|class
index|]
operator|==
literal|1
operator|||
name|SMALL_REGISTER_CLASSES
operator|)
operator|&&
name|MERGABLE_RELOADS
argument_list|(
name|secondary_type
argument_list|,
name|rld
index|[
name|s_reload
index|]
operator|.
name|when_needed
argument_list|,
name|opnum
argument_list|,
name|rld
index|[
name|s_reload
index|]
operator|.
name|opnum
argument_list|)
condition|)
block|{
if|if
condition|(
name|in_p
condition|)
name|rld
index|[
name|s_reload
index|]
operator|.
name|inmode
operator|=
name|mode
expr_stmt|;
if|if
condition|(
operator|!
name|in_p
condition|)
name|rld
index|[
name|s_reload
index|]
operator|.
name|outmode
operator|=
name|mode
expr_stmt|;
if|if
condition|(
name|reg_class_subset_p
argument_list|(
name|class
argument_list|,
name|rld
index|[
name|s_reload
index|]
operator|.
name|class
argument_list|)
condition|)
name|rld
index|[
name|s_reload
index|]
operator|.
name|class
operator|=
name|class
expr_stmt|;
name|rld
index|[
name|s_reload
index|]
operator|.
name|opnum
operator|=
name|MIN
argument_list|(
name|rld
index|[
name|s_reload
index|]
operator|.
name|opnum
argument_list|,
name|opnum
argument_list|)
expr_stmt|;
name|rld
index|[
name|s_reload
index|]
operator|.
name|optional
operator|&=
name|optional
expr_stmt|;
name|rld
index|[
name|s_reload
index|]
operator|.
name|secondary_p
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|MERGE_TO_OTHER
argument_list|(
name|secondary_type
argument_list|,
name|rld
index|[
name|s_reload
index|]
operator|.
name|when_needed
argument_list|,
name|opnum
argument_list|,
name|rld
index|[
name|s_reload
index|]
operator|.
name|opnum
argument_list|)
condition|)
name|rld
index|[
name|s_reload
index|]
operator|.
name|when_needed
operator|=
name|RELOAD_OTHER
expr_stmt|;
block|}
if|if
condition|(
name|s_reload
operator|==
name|n_reloads
condition|)
block|{
ifdef|#
directive|ifdef
name|SECONDARY_MEMORY_NEEDED
comment|/* If we need a memory location to copy between the two reload regs, 	 set it up now.  Note that we do the input case before making 	 the reload and the output case after.  This is due to the 	 way reloads are output.  */
if|if
condition|(
name|in_p
operator|&&
name|icode
operator|==
name|CODE_FOR_nothing
operator|&&
name|SECONDARY_MEMORY_NEEDED
argument_list|(
name|class
argument_list|,
name|reload_class
argument_list|,
name|mode
argument_list|)
condition|)
block|{
name|get_secondary_mem
argument_list|(
name|x
argument_list|,
name|reload_mode
argument_list|,
name|opnum
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* We may have just added new reloads.  Make sure we add 	     the new reload at the end.  */
name|s_reload
operator|=
name|n_reloads
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* We need to make a new secondary reload for this register class.  */
name|rld
index|[
name|s_reload
index|]
operator|.
name|in
operator|=
name|rld
index|[
name|s_reload
index|]
operator|.
name|out
operator|=
literal|0
expr_stmt|;
name|rld
index|[
name|s_reload
index|]
operator|.
name|class
operator|=
name|class
expr_stmt|;
name|rld
index|[
name|s_reload
index|]
operator|.
name|inmode
operator|=
name|in_p
condition|?
name|mode
else|:
name|VOIDmode
expr_stmt|;
name|rld
index|[
name|s_reload
index|]
operator|.
name|outmode
operator|=
operator|!
name|in_p
condition|?
name|mode
else|:
name|VOIDmode
expr_stmt|;
name|rld
index|[
name|s_reload
index|]
operator|.
name|reg_rtx
operator|=
literal|0
expr_stmt|;
name|rld
index|[
name|s_reload
index|]
operator|.
name|optional
operator|=
name|optional
expr_stmt|;
name|rld
index|[
name|s_reload
index|]
operator|.
name|inc
operator|=
literal|0
expr_stmt|;
comment|/* Maybe we could combine these, but it seems too tricky.  */
name|rld
index|[
name|s_reload
index|]
operator|.
name|nocombine
operator|=
literal|1
expr_stmt|;
name|rld
index|[
name|s_reload
index|]
operator|.
name|in_reg
operator|=
literal|0
expr_stmt|;
name|rld
index|[
name|s_reload
index|]
operator|.
name|out_reg
operator|=
literal|0
expr_stmt|;
name|rld
index|[
name|s_reload
index|]
operator|.
name|opnum
operator|=
name|opnum
expr_stmt|;
name|rld
index|[
name|s_reload
index|]
operator|.
name|when_needed
operator|=
name|secondary_type
expr_stmt|;
name|rld
index|[
name|s_reload
index|]
operator|.
name|secondary_in_reload
operator|=
name|in_p
condition|?
name|t_reload
else|:
operator|-
literal|1
expr_stmt|;
name|rld
index|[
name|s_reload
index|]
operator|.
name|secondary_out_reload
operator|=
operator|!
name|in_p
condition|?
name|t_reload
else|:
operator|-
literal|1
expr_stmt|;
name|rld
index|[
name|s_reload
index|]
operator|.
name|secondary_in_icode
operator|=
name|in_p
condition|?
name|t_icode
else|:
name|CODE_FOR_nothing
expr_stmt|;
name|rld
index|[
name|s_reload
index|]
operator|.
name|secondary_out_icode
operator|=
operator|!
name|in_p
condition|?
name|t_icode
else|:
name|CODE_FOR_nothing
expr_stmt|;
name|rld
index|[
name|s_reload
index|]
operator|.
name|secondary_p
operator|=
literal|1
expr_stmt|;
name|n_reloads
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|SECONDARY_MEMORY_NEEDED
if|if
condition|(
operator|!
name|in_p
operator|&&
name|icode
operator|==
name|CODE_FOR_nothing
operator|&&
name|SECONDARY_MEMORY_NEEDED
argument_list|(
name|reload_class
argument_list|,
name|class
argument_list|,
name|mode
argument_list|)
condition|)
name|get_secondary_mem
argument_list|(
name|x
argument_list|,
name|mode
argument_list|,
name|opnum
argument_list|,
name|type
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
operator|*
name|picode
operator|=
name|icode
expr_stmt|;
return|return
name|s_reload
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SECONDARY_RELOADS */
end_comment

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|SECONDARY_MEMORY_NEEDED
end_ifdef

begin_comment
comment|/* Return a memory location that will be used to copy X in mode MODE.    If we haven't already made a location for this mode in this insn,    call find_reloads_address on the location being returned.  */
end_comment

begin_function
name|rtx
name|get_secondary_mem
parameter_list|(
name|x
parameter_list|,
name|mode
parameter_list|,
name|opnum
parameter_list|,
name|type
parameter_list|)
name|rtx
name|x
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|opnum
decl_stmt|;
name|enum
name|reload_type
name|type
decl_stmt|;
block|{
name|rtx
name|loc
decl_stmt|;
name|int
name|mem_valid
decl_stmt|;
comment|/* By default, if MODE is narrower than a word, widen it to a word.      This is required because most machines that require these memory      locations do not support short load and stores from all registers      (e.g., FP registers).  */
ifdef|#
directive|ifdef
name|SECONDARY_MEMORY_NEEDED_MODE
name|mode
operator|=
name|SECONDARY_MEMORY_NEEDED_MODE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<
name|BITS_PER_WORD
operator|&&
name|INTEGRAL_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
name|mode
operator|=
name|mode_for_size
argument_list|(
name|BITS_PER_WORD
argument_list|,
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If we already have made a MEM for this operand in MODE, return it.  */
if|if
condition|(
name|secondary_memlocs_elim
index|[
operator|(
name|int
operator|)
name|mode
index|]
index|[
name|opnum
index|]
operator|!=
literal|0
condition|)
return|return
name|secondary_memlocs_elim
index|[
operator|(
name|int
operator|)
name|mode
index|]
index|[
name|opnum
index|]
return|;
comment|/* If this is the first time we've tried to get a MEM for this mode,      allocate a new one.  `something_changed' in reload will get set      by noticing that the frame size has changed.  */
if|if
condition|(
name|secondary_memlocs
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|SECONDARY_MEMORY_NEEDED_RTX
name|secondary_memlocs
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|=
name|SECONDARY_MEMORY_NEEDED_RTX
argument_list|(
name|mode
argument_list|)
expr_stmt|;
else|#
directive|else
name|secondary_memlocs
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|=
name|assign_stack_local
argument_list|(
name|mode
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Get a version of the address doing any eliminations needed.  If that      didn't give us a new MEM, make a new one if it isn't valid.  */
name|loc
operator|=
name|eliminate_regs
argument_list|(
name|secondary_memlocs
index|[
operator|(
name|int
operator|)
name|mode
index|]
argument_list|,
name|VOIDmode
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|mem_valid
operator|=
name|strict_memory_address_p
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mem_valid
operator|&&
name|loc
operator|==
name|secondary_memlocs
index|[
operator|(
name|int
operator|)
name|mode
index|]
condition|)
name|loc
operator|=
name|copy_rtx
argument_list|(
name|loc
argument_list|)
expr_stmt|;
comment|/* The only time the call below will do anything is if the stack      offset is too large.  In that case IND_LEVELS doesn't matter, so we      can just pass a zero.  Adjust the type to be the address of the      corresponding object.  If the address was valid, save the eliminated      address.  If it wasn't valid, we need to make a reload each time, so      don't save it.  */
if|if
condition|(
operator|!
name|mem_valid
condition|)
block|{
name|type
operator|=
operator|(
name|type
operator|==
name|RELOAD_FOR_INPUT
condition|?
name|RELOAD_FOR_INPUT_ADDRESS
else|:
name|type
operator|==
name|RELOAD_FOR_OUTPUT
condition|?
name|RELOAD_FOR_OUTPUT_ADDRESS
else|:
name|RELOAD_OTHER
operator|)
expr_stmt|;
name|find_reloads_address
argument_list|(
name|mode
argument_list|,
operator|(
name|rtx
operator|*
operator|)
literal|0
argument_list|,
name|XEXP
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|XEXP
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|)
argument_list|,
name|opnum
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|secondary_memlocs_elim
index|[
operator|(
name|int
operator|)
name|mode
index|]
index|[
name|opnum
index|]
operator|=
name|loc
expr_stmt|;
return|return
name|loc
return|;
block|}
end_function

begin_comment
comment|/* Clear any secondary memory locations we've made.  */
end_comment

begin_function
name|void
name|clear_secondary_mem
parameter_list|()
block|{
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|secondary_memlocs
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|secondary_memlocs
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SECONDARY_MEMORY_NEEDED */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Find the largest class for which every register number plus N is valid in    M1 (if in range) and is cheap to move into REGNO.    Abort if no such class exists.  */
end_comment

begin_function
specifier|static
name|enum
name|reg_class
name|find_valid_class
parameter_list|(
name|m1
parameter_list|,
name|n
parameter_list|,
name|dest_regno
parameter_list|)
name|enum
name|machine_mode
name|m1
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|n
decl_stmt|;
name|unsigned
name|int
name|dest_regno
decl_stmt|;
block|{
name|int
name|best_cost
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|class
decl_stmt|;
name|int
name|regno
decl_stmt|;
name|enum
name|reg_class
name|best_class
init|=
name|NO_REGS
decl_stmt|;
name|enum
name|reg_class
name|dest_class
init|=
name|REGNO_REG_CLASS
argument_list|(
name|dest_regno
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|best_size
init|=
literal|0
decl_stmt|;
name|int
name|cost
decl_stmt|;
for|for
control|(
name|class
operator|=
literal|1
init|;
name|class
operator|<
name|N_REG_CLASSES
condition|;
name|class
operator|++
control|)
block|{
name|int
name|bad
init|=
literal|0
decl_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|!
name|bad
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
name|class
index|]
argument_list|,
name|regno
argument_list|)
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
name|class
index|]
argument_list|,
name|regno
operator|+
name|n
argument_list|)
operator|&&
operator|!
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
operator|+
name|n
argument_list|,
name|m1
argument_list|)
condition|)
name|bad
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|bad
condition|)
continue|continue;
name|cost
operator|=
name|REGISTER_MOVE_COST
argument_list|(
name|m1
argument_list|,
name|class
argument_list|,
name|dest_class
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|reg_class_size
index|[
name|class
index|]
operator|>
name|best_size
operator|&&
operator|(
name|best_cost
operator|<
literal|0
operator|||
name|best_cost
operator|>=
name|cost
operator|)
operator|)
operator|||
name|best_cost
operator|>
name|cost
condition|)
block|{
name|best_class
operator|=
name|class
expr_stmt|;
name|best_size
operator|=
name|reg_class_size
index|[
name|class
index|]
expr_stmt|;
name|best_cost
operator|=
name|REGISTER_MOVE_COST
argument_list|(
name|m1
argument_list|,
name|class
argument_list|,
name|dest_class
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|best_size
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|best_class
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the number of a previously made reload that can be combined with    a new one, or n_reloads if none of the existing reloads can be used.    OUT, CLASS, TYPE and OPNUM are the same arguments as passed to    push_reload, they determine the kind of the new reload that we try to    combine.  P_IN points to the corresponding value of IN, which can be    modified by this function.    DONT_SHARE is nonzero if we can't share any input-only reload for IN.  */
end_comment

begin_function
specifier|static
name|int
name|find_reusable_reload
parameter_list|(
name|p_in
parameter_list|,
name|out
parameter_list|,
name|class
parameter_list|,
name|type
parameter_list|,
name|opnum
parameter_list|,
name|dont_share
parameter_list|)
name|rtx
modifier|*
name|p_in
decl_stmt|,
name|out
decl_stmt|;
name|enum
name|reg_class
name|class
decl_stmt|;
name|enum
name|reload_type
name|type
decl_stmt|;
name|int
name|opnum
decl_stmt|,
name|dont_share
decl_stmt|;
block|{
name|rtx
name|in
init|=
operator|*
name|p_in
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* We can't merge two reloads if the output of either one is      earlyclobbered.  */
if|if
condition|(
name|earlyclobber_operand_p
argument_list|(
name|out
argument_list|)
condition|)
return|return
name|n_reloads
return|;
comment|/* We can use an existing reload if the class is right      and at least one of IN and OUT is a match      and the other is at worst neutral.      (A zero compared against anything is neutral.)       If SMALL_REGISTER_CLASSES, don't use existing reloads unless they are      for the same thing since that can cause us to need more reload registers      than we otherwise would.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_reloads
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|reg_class_subset_p
argument_list|(
name|class
argument_list|,
name|rld
index|[
name|i
index|]
operator|.
name|class
argument_list|)
operator|||
name|reg_class_subset_p
argument_list|(
name|rld
index|[
name|i
index|]
operator|.
name|class
argument_list|,
name|class
argument_list|)
operator|)
comment|/* If the existing reload has a register, it must fit our class.  */
operator|&&
operator|(
name|rld
index|[
name|i
index|]
operator|.
name|reg_rtx
operator|==
literal|0
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|class
index|]
argument_list|,
name|true_regnum
argument_list|(
name|rld
index|[
name|i
index|]
operator|.
name|reg_rtx
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|in
operator|!=
literal|0
operator|&&
name|MATCHES
argument_list|(
name|rld
index|[
name|i
index|]
operator|.
name|in
argument_list|,
name|in
argument_list|)
operator|&&
operator|!
name|dont_share
operator|&&
operator|(
name|out
operator|==
literal|0
operator|||
name|rld
index|[
name|i
index|]
operator|.
name|out
operator|==
literal|0
operator|||
name|MATCHES
argument_list|(
name|rld
index|[
name|i
index|]
operator|.
name|out
argument_list|,
name|out
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|out
operator|!=
literal|0
operator|&&
name|MATCHES
argument_list|(
name|rld
index|[
name|i
index|]
operator|.
name|out
argument_list|,
name|out
argument_list|)
operator|&&
operator|(
name|in
operator|==
literal|0
operator|||
name|rld
index|[
name|i
index|]
operator|.
name|in
operator|==
literal|0
operator|||
name|MATCHES
argument_list|(
name|rld
index|[
name|i
index|]
operator|.
name|in
argument_list|,
name|in
argument_list|)
operator|)
operator|)
operator|)
operator|&&
operator|(
name|rld
index|[
name|i
index|]
operator|.
name|out
operator|==
literal|0
operator|||
operator|!
name|earlyclobber_operand_p
argument_list|(
name|rld
index|[
name|i
index|]
operator|.
name|out
argument_list|)
operator|)
operator|&&
operator|(
name|reg_class_size
index|[
operator|(
name|int
operator|)
name|class
index|]
operator|==
literal|1
operator|||
name|SMALL_REGISTER_CLASSES
operator|)
operator|&&
name|MERGABLE_RELOADS
argument_list|(
name|type
argument_list|,
name|rld
index|[
name|i
index|]
operator|.
name|when_needed
argument_list|,
name|opnum
argument_list|,
name|rld
index|[
name|i
index|]
operator|.
name|opnum
argument_list|)
condition|)
return|return
name|i
return|;
comment|/* Reloading a plain reg for input can match a reload to postincrement      that reg, since the postincrement's value is the right value.      Likewise, it can match a preincrement reload, since we regard      the preincrementation as happening before any ref in this insn      to that register.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_reloads
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|reg_class_subset_p
argument_list|(
name|class
argument_list|,
name|rld
index|[
name|i
index|]
operator|.
name|class
argument_list|)
operator|||
name|reg_class_subset_p
argument_list|(
name|rld
index|[
name|i
index|]
operator|.
name|class
argument_list|,
name|class
argument_list|)
operator|)
comment|/* If the existing reload has a register, it must fit our 	   class.  */
operator|&&
operator|(
name|rld
index|[
name|i
index|]
operator|.
name|reg_rtx
operator|==
literal|0
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|class
index|]
argument_list|,
name|true_regnum
argument_list|(
name|rld
index|[
name|i
index|]
operator|.
name|reg_rtx
argument_list|)
argument_list|)
operator|)
operator|&&
name|out
operator|==
literal|0
operator|&&
name|rld
index|[
name|i
index|]
operator|.
name|out
operator|==
literal|0
operator|&&
name|rld
index|[
name|i
index|]
operator|.
name|in
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|REG
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|rld
index|[
name|i
index|]
operator|.
name|in
argument_list|)
argument_list|)
operator|==
literal|'a'
operator|&&
name|MATCHES
argument_list|(
name|XEXP
argument_list|(
name|rld
index|[
name|i
index|]
operator|.
name|in
argument_list|,
literal|0
argument_list|)
argument_list|,
name|in
argument_list|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|rld
index|[
name|i
index|]
operator|.
name|in
argument_list|)
operator|==
name|REG
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|in
argument_list|)
argument_list|)
operator|==
literal|'a'
operator|&&
name|MATCHES
argument_list|(
name|XEXP
argument_list|(
name|in
argument_list|,
literal|0
argument_list|)
argument_list|,
name|rld
index|[
name|i
index|]
operator|.
name|in
argument_list|)
operator|)
operator|)
operator|&&
operator|(
name|rld
index|[
name|i
index|]
operator|.
name|out
operator|==
literal|0
operator|||
operator|!
name|earlyclobber_operand_p
argument_list|(
name|rld
index|[
name|i
index|]
operator|.
name|out
argument_list|)
operator|)
operator|&&
operator|(
name|reg_class_size
index|[
operator|(
name|int
operator|)
name|class
index|]
operator|==
literal|1
operator|||
name|SMALL_REGISTER_CLASSES
operator|)
operator|&&
name|MERGABLE_RELOADS
argument_list|(
name|type
argument_list|,
name|rld
index|[
name|i
index|]
operator|.
name|when_needed
argument_list|,
name|opnum
argument_list|,
name|rld
index|[
name|i
index|]
operator|.
name|opnum
argument_list|)
condition|)
block|{
comment|/* Make sure reload_in ultimately has the increment, 	   not the plain register.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|REG
condition|)
operator|*
name|p_in
operator|=
name|rld
index|[
name|i
index|]
operator|.
name|in
expr_stmt|;
return|return
name|i
return|;
block|}
return|return
name|n_reloads
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if X is a SUBREG which will require reloading of its    SUBREG_REG expression.  */
end_comment

begin_function
specifier|static
name|int
name|reload_inner_reg_of_subreg
parameter_list|(
name|x
parameter_list|,
name|mode
parameter_list|,
name|output
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|output
decl_stmt|;
block|{
name|rtx
name|inner
decl_stmt|;
comment|/* Only SUBREGs are problematical.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|SUBREG
condition|)
return|return
literal|0
return|;
name|inner
operator|=
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* If INNER is a constant or PLUS, then INNER must be reloaded.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|inner
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|PLUS
condition|)
return|return
literal|1
return|;
comment|/* If INNER is not a hard register, then INNER will not need to      be reloaded.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|inner
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|inner
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
return|return
literal|0
return|;
comment|/* If INNER is not ok for MODE, then INNER will need reloading.  */
if|if
condition|(
operator|!
name|HARD_REGNO_MODE_OK
argument_list|(
name|subreg_regno
argument_list|(
name|x
argument_list|)
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* If the outer part is a word or smaller, INNER larger than a      word and the number of regs for INNER is not the same as the      number of words in INNER, then INNER will need reloading.  */
return|return
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|UNITS_PER_WORD
operator|&&
name|output
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|inner
argument_list|)
argument_list|)
operator|>
name|UNITS_PER_WORD
operator|&&
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|inner
argument_list|)
argument_list|)
operator|/
name|UNITS_PER_WORD
operator|)
operator|!=
name|HARD_REGNO_NREGS
argument_list|(
name|REGNO
argument_list|(
name|inner
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|inner
argument_list|)
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Record one reload that needs to be performed.    IN is an rtx saying where the data are to be found before this instruction.    OUT says where they must be stored after the instruction.    (IN is zero for data not read, and OUT is zero for data not written.)    INLOC and OUTLOC point to the places in the instructions where    IN and OUT were found.    If IN and OUT are both non-zero, it means the same register must be used    to reload both IN and OUT.     CLASS is a register class required for the reloaded data.    INMODE is the machine mode that the instruction requires    for the reg that replaces IN and OUTMODE is likewise for OUT.     If IN is zero, then OUT's location and mode should be passed as    INLOC and INMODE.     STRICT_LOW is the 1 if there is a containing STRICT_LOW_PART rtx.     OPTIONAL nonzero means this reload does not need to be performed:    it can be discarded if that is more convenient.     OPNUM and TYPE say what the purpose of this reload is.     The return value is the reload-number for this reload.     If both IN and OUT are nonzero, in some rare cases we might    want to make two separate reloads.  (Actually we never do this now.)    Therefore, the reload-number for OUT is stored in    output_reloadnum when we return; the return value applies to IN.    Usually (presently always), when IN and OUT are nonzero,    the two reload-numbers are equal, but the caller should be careful to    distinguish them.  */
end_comment

begin_function
name|int
name|push_reload
parameter_list|(
name|in
parameter_list|,
name|out
parameter_list|,
name|inloc
parameter_list|,
name|outloc
parameter_list|,
name|class
parameter_list|,
name|inmode
parameter_list|,
name|outmode
parameter_list|,
name|strict_low
parameter_list|,
name|optional
parameter_list|,
name|opnum
parameter_list|,
name|type
parameter_list|)
name|rtx
name|in
decl_stmt|,
name|out
decl_stmt|;
name|rtx
modifier|*
name|inloc
decl_stmt|,
decl|*
name|outloc
decl_stmt|;
end_function

begin_decl_stmt
name|enum
name|reg_class
name|class
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|machine_mode
name|inmode
decl_stmt|,
name|outmode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|strict_low
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|optional
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|opnum
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|reload_type
name|type
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|int
name|dont_share
init|=
literal|0
decl_stmt|;
name|int
name|dont_remove_subreg
init|=
literal|0
decl_stmt|;
name|rtx
modifier|*
name|in_subreg_loc
init|=
literal|0
decl_stmt|,
modifier|*
name|out_subreg_loc
init|=
literal|0
decl_stmt|;
name|int
name|secondary_in_reload
init|=
operator|-
literal|1
decl_stmt|,
name|secondary_out_reload
init|=
operator|-
literal|1
decl_stmt|;
name|enum
name|insn_code
name|secondary_in_icode
init|=
name|CODE_FOR_nothing
decl_stmt|;
name|enum
name|insn_code
name|secondary_out_icode
init|=
name|CODE_FOR_nothing
decl_stmt|;
comment|/* INMODE and/or OUTMODE could be VOIDmode if no mode      has been specified for the operand.  In that case,      use the operand's mode as the mode to reload.  */
if|if
condition|(
name|inmode
operator|==
name|VOIDmode
operator|&&
name|in
operator|!=
literal|0
condition|)
name|inmode
operator|=
name|GET_MODE
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|outmode
operator|==
name|VOIDmode
operator|&&
name|out
operator|!=
literal|0
condition|)
name|outmode
operator|=
name|GET_MODE
argument_list|(
name|out
argument_list|)
expr_stmt|;
comment|/* If IN is a pseudo register everywhere-equivalent to a constant, and      it is not in a hard register, reload straight from the constant,      since we want to get rid of such pseudo registers.      Often this is done earlier, but not always in find_reloads_address.  */
if|if
condition|(
name|in
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|REG
condition|)
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|in
argument_list|)
decl_stmt|;
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|reg_renumber
index|[
name|regno
index|]
operator|<
literal|0
operator|&&
name|reg_equiv_constant
index|[
name|regno
index|]
operator|!=
literal|0
condition|)
name|in
operator|=
name|reg_equiv_constant
index|[
name|regno
index|]
expr_stmt|;
block|}
comment|/* Likewise for OUT.  Of course, OUT will never be equivalent to      an actual constant, but it might be equivalent to a memory location      (in the case of a parameter).  */
if|if
condition|(
name|out
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|out
argument_list|)
operator|==
name|REG
condition|)
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|out
argument_list|)
decl_stmt|;
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|reg_renumber
index|[
name|regno
index|]
operator|<
literal|0
operator|&&
name|reg_equiv_constant
index|[
name|regno
index|]
operator|!=
literal|0
condition|)
name|out
operator|=
name|reg_equiv_constant
index|[
name|regno
index|]
expr_stmt|;
block|}
comment|/* If we have a read-write operand with an address side-effect,      change either IN or OUT so the side-effect happens only once.  */
if|if
condition|(
name|in
operator|!=
literal|0
operator|&&
name|out
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|MEM
operator|&&
name|rtx_equal_p
argument_list|(
name|in
argument_list|,
name|out
argument_list|)
condition|)
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|in
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|POST_INC
case|:
case|case
name|POST_DEC
case|:
case|case
name|POST_MODIFY
case|:
name|in
operator|=
name|replace_equiv_address_nv
argument_list|(
name|in
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|in
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRE_INC
case|:
case|case
name|PRE_DEC
case|:
case|case
name|PRE_MODIFY
case|:
name|out
operator|=
name|replace_equiv_address_nv
argument_list|(
name|out
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|out
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* If we are reloading a (SUBREG constant ...), really reload just the      inside expression in its own mode.  Similarly for (SUBREG (PLUS ...)).      If we have (SUBREG:M1 (MEM:M2 ...) ...) (or an inner REG that is still      a pseudo and hence will become a MEM) with M1 wider than M2 and the      register is a pseudo, also reload the inside expression.      For machines that extend byte loads, do this for any SUBREG of a pseudo      where both M1 and M2 are a word or smaller, M1 is wider than M2, and      M2 is an integral mode that gets extended when loaded.      Similar issue for (SUBREG:M1 (REG:M2 ...) ...) for a hard register R where      either M1 is not valid for R or M2 is wider than a word but we only      need one word to store an M2-sized quantity in R.      (However, if OUT is nonzero, we need to reload the reg *and*      the subreg, so do nothing here, and let following statement handle it.)       Note that the case of (SUBREG (CONST_INT...)...) is handled elsewhere;      we can't handle it here because CONST_INT does not indicate a mode.       Similarly, we must reload the inside expression if we have a      STRICT_LOW_PART (presumably, in == out in the cas).       Also reload the inner expression if it does not require a secondary      reload but the SUBREG does.       Finally, reload the inner expression if it is a register that is in      the class whose registers cannot be referenced in a different size      and M1 is not the same size as M2.  If subreg_lowpart_p is false, we      cannot reload just the inside since we might end up with the wrong      register class.  But if it is inside a STRICT_LOW_PART, we have      no choice, so we hope we do get the right register class there.  */
if|if
condition|(
name|in
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|(
name|subreg_lowpart_p
argument_list|(
name|in
argument_list|)
operator|||
name|strict_low
operator|)
ifdef|#
directive|ifdef
name|CLASS_CANNOT_CHANGE_MODE
operator|&&
operator|(
name|class
operator|!=
name|CLASS_CANNOT_CHANGE_MODE
operator|||
operator|!
name|CLASS_CANNOT_CHANGE_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|in
argument_list|)
argument_list|)
argument_list|,
name|inmode
argument_list|)
operator|)
endif|#
directive|endif
operator|&&
operator|(
name|CONSTANT_P
argument_list|(
name|SUBREG_REG
argument_list|(
name|in
argument_list|)
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|in
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|||
name|strict_low
operator|||
operator|(
operator|(
operator|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|in
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|in
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|||
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|in
argument_list|)
argument_list|)
operator|==
name|MEM
operator|)
operator|&&
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|inmode
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|in
argument_list|)
argument_list|)
argument_list|)
operator|)
ifdef|#
directive|ifdef
name|LOAD_EXTEND_OP
operator|||
operator|(
name|GET_MODE_SIZE
argument_list|(
name|inmode
argument_list|)
operator|<=
name|UNITS_PER_WORD
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|in
argument_list|)
argument_list|)
argument_list|)
operator|<=
name|UNITS_PER_WORD
operator|)
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|inmode
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|in
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|&&
name|INTEGRAL_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|in
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|LOAD_EXTEND_OP
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|in
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|NIL
operator|)
endif|#
directive|endif
ifdef|#
directive|ifdef
name|WORD_REGISTER_OPERATIONS
operator|||
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|inmode
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|in
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|inmode
argument_list|)
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
operator|==
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|in
argument_list|)
argument_list|)
argument_list|)
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
operator|)
operator|)
endif|#
directive|endif
operator|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|in
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|in
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
comment|/* The case where out is nonzero 		 is handled differently in the following statement.  */
operator|&&
operator|(
name|out
operator|==
literal|0
operator|||
name|subreg_lowpart_p
argument_list|(
name|in
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|inmode
argument_list|)
operator|<=
name|UNITS_PER_WORD
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|in
argument_list|)
argument_list|)
argument_list|)
operator|>
name|UNITS_PER_WORD
operator|)
operator|&&
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|in
argument_list|)
argument_list|)
argument_list|)
operator|/
name|UNITS_PER_WORD
operator|)
operator|!=
name|HARD_REGNO_NREGS
argument_list|(
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|in
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|in
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|)
operator|||
operator|!
name|HARD_REGNO_MODE_OK
argument_list|(
name|subreg_regno
argument_list|(
name|in
argument_list|)
argument_list|,
name|inmode
argument_list|)
operator|)
operator|)
ifdef|#
directive|ifdef
name|SECONDARY_INPUT_RELOAD_CLASS
operator|||
operator|(
name|SECONDARY_INPUT_RELOAD_CLASS
argument_list|(
name|class
argument_list|,
name|inmode
argument_list|,
name|in
argument_list|)
operator|!=
name|NO_REGS
operator|&&
operator|(
name|SECONDARY_INPUT_RELOAD_CLASS
argument_list|(
name|class
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|in
argument_list|)
argument_list|)
argument_list|,
name|SUBREG_REG
argument_list|(
name|in
argument_list|)
argument_list|)
operator|==
name|NO_REGS
operator|)
operator|)
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CLASS_CANNOT_CHANGE_MODE
operator|||
operator|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|in
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|in
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|CLASS_CANNOT_CHANGE_MODE
index|]
argument_list|,
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|in
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|&&
name|CLASS_CANNOT_CHANGE_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|in
argument_list|)
argument_list|)
argument_list|,
name|inmode
argument_list|)
operator|)
endif|#
directive|endif
operator|)
condition|)
block|{
name|in_subreg_loc
operator|=
name|inloc
expr_stmt|;
name|inloc
operator|=
operator|&
name|SUBREG_REG
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|in
operator|=
operator|*
name|inloc
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|LOAD_EXTEND_OP
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|WORD_REGISTER_OPERATIONS
argument_list|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|MEM
condition|)
comment|/* This is supposed to happen only for paradoxical subregs made by 	   combine.c.  (SUBREG (MEM)) isn't supposed to occur other ways.  */
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|in
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|inmode
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|inmode
operator|=
name|GET_MODE
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
comment|/* Similar issue for (SUBREG:M1 (REG:M2 ...) ...) for a hard register R where      either M1 is not valid for R or M2 is wider than a word but we only      need one word to store an M2-sized quantity in R.       However, we must reload the inner reg *as well as* the subreg in      that case.  */
comment|/* Similar issue for (SUBREG constant ...) if it was not handled by the      code above.  This can happen if SUBREG_BYTE != 0.  */
if|if
condition|(
name|in
operator|!=
literal|0
operator|&&
name|reload_inner_reg_of_subreg
argument_list|(
name|in
argument_list|,
name|inmode
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|enum
name|reg_class
name|in_class
init|=
name|class
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|in
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|in_class
operator|=
name|find_valid_class
argument_list|(
name|inmode
argument_list|,
name|subreg_regno_offset
argument_list|(
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|in
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|in
argument_list|)
argument_list|)
argument_list|,
name|SUBREG_BYTE
argument_list|(
name|in
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|in
argument_list|)
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|in
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This relies on the fact that emit_reload_insns outputs the 	 instructions for input reloads of type RELOAD_OTHER in the same 	 order as the reloads.  Thus if the outer reload is also of type 	 RELOAD_OTHER, we are guaranteed that this inner reload will be 	 output before the outer reload.  */
name|push_reload
argument_list|(
name|SUBREG_REG
argument_list|(
name|in
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
operator|&
name|SUBREG_REG
argument_list|(
name|in
argument_list|)
argument_list|,
operator|(
name|rtx
operator|*
operator|)
literal|0
argument_list|,
name|in_class
argument_list|,
name|VOIDmode
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|opnum
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|dont_remove_subreg
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Similarly for paradoxical and problematical SUBREGs on the output.      Note that there is no reason we need worry about the previous value      of SUBREG_REG (out); even if wider than out,      storing in a subreg is entitled to clobber it all      (except in the case of STRICT_LOW_PART,      and in that case the constraint should label it input-output.)  */
if|if
condition|(
name|out
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|out
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|(
name|subreg_lowpart_p
argument_list|(
name|out
argument_list|)
operator|||
name|strict_low
operator|)
ifdef|#
directive|ifdef
name|CLASS_CANNOT_CHANGE_MODE
operator|&&
operator|(
name|class
operator|!=
name|CLASS_CANNOT_CHANGE_MODE
operator|||
operator|!
name|CLASS_CANNOT_CHANGE_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|out
argument_list|)
argument_list|)
argument_list|,
name|outmode
argument_list|)
operator|)
endif|#
directive|endif
operator|&&
operator|(
name|CONSTANT_P
argument_list|(
name|SUBREG_REG
argument_list|(
name|out
argument_list|)
argument_list|)
operator|||
name|strict_low
operator|||
operator|(
operator|(
operator|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|out
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|out
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|||
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|out
argument_list|)
argument_list|)
operator|==
name|MEM
operator|)
operator|&&
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|outmode
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|out
argument_list|)
argument_list|)
argument_list|)
operator|)
ifdef|#
directive|ifdef
name|WORD_REGISTER_OPERATIONS
operator|||
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|outmode
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|out
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|outmode
argument_list|)
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
operator|==
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|out
argument_list|)
argument_list|)
argument_list|)
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
operator|)
operator|)
endif|#
directive|endif
operator|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|out
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|out
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|outmode
argument_list|)
operator|<=
name|UNITS_PER_WORD
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|out
argument_list|)
argument_list|)
argument_list|)
operator|>
name|UNITS_PER_WORD
operator|)
operator|&&
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|out
argument_list|)
argument_list|)
argument_list|)
operator|/
name|UNITS_PER_WORD
operator|)
operator|!=
name|HARD_REGNO_NREGS
argument_list|(
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|out
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|out
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|)
operator|||
operator|!
name|HARD_REGNO_MODE_OK
argument_list|(
name|subreg_regno
argument_list|(
name|out
argument_list|)
argument_list|,
name|outmode
argument_list|)
operator|)
operator|)
ifdef|#
directive|ifdef
name|SECONDARY_OUTPUT_RELOAD_CLASS
operator|||
operator|(
name|SECONDARY_OUTPUT_RELOAD_CLASS
argument_list|(
name|class
argument_list|,
name|outmode
argument_list|,
name|out
argument_list|)
operator|!=
name|NO_REGS
operator|&&
operator|(
name|SECONDARY_OUTPUT_RELOAD_CLASS
argument_list|(
name|class
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|out
argument_list|)
argument_list|)
argument_list|,
name|SUBREG_REG
argument_list|(
name|out
argument_list|)
argument_list|)
operator|==
name|NO_REGS
operator|)
operator|)
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CLASS_CANNOT_CHANGE_MODE
operator|||
operator|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|out
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|out
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|CLASS_CANNOT_CHANGE_MODE
index|]
argument_list|,
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|out
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|&&
name|CLASS_CANNOT_CHANGE_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|out
argument_list|)
argument_list|)
argument_list|,
name|outmode
argument_list|)
operator|)
endif|#
directive|endif
operator|)
condition|)
block|{
name|out_subreg_loc
operator|=
name|outloc
expr_stmt|;
name|outloc
operator|=
operator|&
name|SUBREG_REG
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|out
operator|=
operator|*
name|outloc
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|LOAD_EXTEND_OP
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|WORD_REGISTER_OPERATIONS
argument_list|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|out
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|out
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|outmode
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|outmode
operator|=
name|GET_MODE
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
comment|/* Similar issue for (SUBREG:M1 (REG:M2 ...) ...) for a hard register R where      either M1 is not valid for R or M2 is wider than a word but we only      need one word to store an M2-sized quantity in R.       However, we must reload the inner reg *as well as* the subreg in      that case.  In this case, the inner reg is an in-out reload.  */
if|if
condition|(
name|out
operator|!=
literal|0
operator|&&
name|reload_inner_reg_of_subreg
argument_list|(
name|out
argument_list|,
name|outmode
argument_list|,
literal|1
argument_list|)
condition|)
block|{
comment|/* This relies on the fact that emit_reload_insns outputs the 	 instructions for output reloads of type RELOAD_OTHER in reverse 	 order of the reloads.  Thus if the outer reload is also of type 	 RELOAD_OTHER, we are guaranteed that this inner reload will be 	 output after the outer reload.  */
name|dont_remove_subreg
operator|=
literal|1
expr_stmt|;
name|push_reload
argument_list|(
name|SUBREG_REG
argument_list|(
name|out
argument_list|)
argument_list|,
name|SUBREG_REG
argument_list|(
name|out
argument_list|)
argument_list|,
operator|&
name|SUBREG_REG
argument_list|(
name|out
argument_list|)
argument_list|,
operator|&
name|SUBREG_REG
argument_list|(
name|out
argument_list|)
argument_list|,
name|find_valid_class
argument_list|(
name|outmode
argument_list|,
name|subreg_regno_offset
argument_list|(
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|out
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|out
argument_list|)
argument_list|)
argument_list|,
name|SUBREG_BYTE
argument_list|(
name|out
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|out
argument_list|)
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|out
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|VOIDmode
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|opnum
argument_list|,
name|RELOAD_OTHER
argument_list|)
expr_stmt|;
block|}
comment|/* If IN appears in OUT, we can't share any input-only reload for IN.  */
if|if
condition|(
name|in
operator|!=
literal|0
operator|&&
name|out
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|out
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|MEM
operator|)
operator|&&
name|reg_overlap_mentioned_for_reload_p
argument_list|(
name|in
argument_list|,
name|XEXP
argument_list|(
name|out
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|dont_share
operator|=
literal|1
expr_stmt|;
comment|/* If IN is a SUBREG of a hard register, make a new REG.  This      simplifies some of the cases below.  */
if|if
condition|(
name|in
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|in
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|in
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|!
name|dont_remove_subreg
condition|)
name|in
operator|=
name|gen_rtx_REG
argument_list|(
name|GET_MODE
argument_list|(
name|in
argument_list|)
argument_list|,
name|subreg_regno
argument_list|(
name|in
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Similarly for OUT.  */
if|if
condition|(
name|out
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|out
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|out
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|out
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|!
name|dont_remove_subreg
condition|)
name|out
operator|=
name|gen_rtx_REG
argument_list|(
name|GET_MODE
argument_list|(
name|out
argument_list|)
argument_list|,
name|subreg_regno
argument_list|(
name|out
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Narrow down the class of register wanted if that is      desirable on this machine for efficiency.  */
if|if
condition|(
name|in
operator|!=
literal|0
condition|)
name|class
operator|=
name|PREFERRED_RELOAD_CLASS
argument_list|(
name|in
argument_list|,
name|class
argument_list|)
expr_stmt|;
comment|/* Output reloads may need analogous treatment, different in detail.  */
ifdef|#
directive|ifdef
name|PREFERRED_OUTPUT_RELOAD_CLASS
if|if
condition|(
name|out
operator|!=
literal|0
condition|)
name|class
operator|=
name|PREFERRED_OUTPUT_RELOAD_CLASS
argument_list|(
name|out
argument_list|,
name|class
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Make sure we use a class that can handle the actual pseudo      inside any subreg.  For example, on the 386, QImode regs      can appear within SImode subregs.  Although GENERAL_REGS      can handle SImode, QImode needs a smaller class.  */
ifdef|#
directive|ifdef
name|LIMIT_RELOAD_CLASS
if|if
condition|(
name|in_subreg_loc
condition|)
name|class
operator|=
name|LIMIT_RELOAD_CLASS
argument_list|(
name|inmode
argument_list|,
name|class
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|in
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|SUBREG
condition|)
name|class
operator|=
name|LIMIT_RELOAD_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|in
argument_list|)
argument_list|)
argument_list|,
name|class
argument_list|)
expr_stmt|;
if|if
condition|(
name|out_subreg_loc
condition|)
name|class
operator|=
name|LIMIT_RELOAD_CLASS
argument_list|(
name|outmode
argument_list|,
name|class
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|out
argument_list|)
operator|==
name|SUBREG
condition|)
name|class
operator|=
name|LIMIT_RELOAD_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|out
argument_list|)
argument_list|)
argument_list|,
name|class
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Verify that this class is at least possible for the mode that      is specified.  */
if|if
condition|(
name|this_insn_is_asm
condition|)
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|;
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|inmode
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|outmode
argument_list|)
condition|)
name|mode
operator|=
name|inmode
expr_stmt|;
else|else
name|mode
operator|=
name|outmode
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
block|{
name|error_for_asm
argument_list|(
name|this_insn
argument_list|,
literal|"cannot reload integer constant operand in `asm'"
argument_list|)
expr_stmt|;
name|mode
operator|=
name|word_mode
expr_stmt|;
if|if
condition|(
name|in
operator|!=
literal|0
condition|)
name|inmode
operator|=
name|word_mode
expr_stmt|;
if|if
condition|(
name|out
operator|!=
literal|0
condition|)
name|outmode
operator|=
name|word_mode
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|HARD_REGNO_MODE_OK
argument_list|(
name|i
argument_list|,
name|mode
argument_list|)
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|class
index|]
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|int
name|nregs
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|i
argument_list|,
name|mode
argument_list|)
decl_stmt|;
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|nregs
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|class
index|]
argument_list|,
name|i
operator|+
name|j
argument_list|)
condition|)
break|break;
if|if
condition|(
name|j
operator|==
name|nregs
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|error_for_asm
argument_list|(
name|this_insn
argument_list|,
literal|"impossible register constraint in `asm'"
argument_list|)
expr_stmt|;
name|class
operator|=
name|ALL_REGS
expr_stmt|;
block|}
block|}
comment|/* Optional output reloads are always OK even if we have no register class,      since the function of these reloads is only to have spill_reg_store etc.      set, so that the storing insn can be deleted later.  */
if|if
condition|(
name|class
operator|==
name|NO_REGS
operator|&&
operator|(
name|optional
operator|==
literal|0
operator|||
name|type
operator|!=
name|RELOAD_FOR_OUTPUT
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|i
operator|=
name|find_reusable_reload
argument_list|(
operator|&
name|in
argument_list|,
name|out
argument_list|,
name|class
argument_list|,
name|type
argument_list|,
name|opnum
argument_list|,
name|dont_share
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|n_reloads
condition|)
block|{
comment|/* See if we need a secondary reload register to move between CLASS 	 and IN or CLASS and OUT.  Get the icode and push any required reloads 	 needed for each of them if so.  */
ifdef|#
directive|ifdef
name|SECONDARY_INPUT_RELOAD_CLASS
if|if
condition|(
name|in
operator|!=
literal|0
condition|)
name|secondary_in_reload
operator|=
name|push_secondary_reload
argument_list|(
literal|1
argument_list|,
name|in
argument_list|,
name|opnum
argument_list|,
name|optional
argument_list|,
name|class
argument_list|,
name|inmode
argument_list|,
name|type
argument_list|,
operator|&
name|secondary_in_icode
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SECONDARY_OUTPUT_RELOAD_CLASS
if|if
condition|(
name|out
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|out
argument_list|)
operator|!=
name|SCRATCH
condition|)
name|secondary_out_reload
operator|=
name|push_secondary_reload
argument_list|(
literal|0
argument_list|,
name|out
argument_list|,
name|opnum
argument_list|,
name|optional
argument_list|,
name|class
argument_list|,
name|outmode
argument_list|,
name|type
argument_list|,
operator|&
name|secondary_out_icode
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* We found no existing reload suitable for re-use. 	 So add an additional reload.  */
ifdef|#
directive|ifdef
name|SECONDARY_MEMORY_NEEDED
block|{
name|int
name|regnum
decl_stmt|;
comment|/* If a memory location is needed for the copy, make one.  */
if|if
condition|(
name|in
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|regnum
operator|=
name|true_regnum
argument_list|(
name|in
argument_list|)
operator|)
operator|>=
literal|0
operator|)
operator|&&
name|regnum
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|SECONDARY_MEMORY_NEEDED
argument_list|(
name|REGNO_REG_CLASS
argument_list|(
name|regnum
argument_list|)
argument_list|,
name|class
argument_list|,
name|inmode
argument_list|)
condition|)
name|get_secondary_mem
argument_list|(
name|in
argument_list|,
name|inmode
argument_list|,
name|opnum
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|i
operator|=
name|n_reloads
expr_stmt|;
name|rld
index|[
name|i
index|]
operator|.
name|in
operator|=
name|in
expr_stmt|;
name|rld
index|[
name|i
index|]
operator|.
name|out
operator|=
name|out
expr_stmt|;
name|rld
index|[
name|i
index|]
operator|.
name|class
operator|=
name|class
expr_stmt|;
name|rld
index|[
name|i
index|]
operator|.
name|inmode
operator|=
name|inmode
expr_stmt|;
name|rld
index|[
name|i
index|]
operator|.
name|outmode
operator|=
name|outmode
expr_stmt|;
name|rld
index|[
name|i
index|]
operator|.
name|reg_rtx
operator|=
literal|0
expr_stmt|;
name|rld
index|[
name|i
index|]
operator|.
name|optional
operator|=
name|optional
expr_stmt|;
name|rld
index|[
name|i
index|]
operator|.
name|inc
operator|=
literal|0
expr_stmt|;
name|rld
index|[
name|i
index|]
operator|.
name|nocombine
operator|=
literal|0
expr_stmt|;
name|rld
index|[
name|i
index|]
operator|.
name|in_reg
operator|=
name|inloc
condition|?
operator|*
name|inloc
else|:
literal|0
expr_stmt|;
name|rld
index|[
name|i
index|]
operator|.
name|out_reg
operator|=
name|outloc
condition|?
operator|*
name|outloc
else|:
literal|0
expr_stmt|;
name|rld
index|[
name|i
index|]
operator|.
name|opnum
operator|=
name|opnum
expr_stmt|;
name|rld
index|[
name|i
index|]
operator|.
name|when_needed
operator|=
name|type
expr_stmt|;
name|rld
index|[
name|i
index|]
operator|.
name|secondary_in_reload
operator|=
name|secondary_in_reload
expr_stmt|;
name|rld
index|[
name|i
index|]
operator|.
name|secondary_out_reload
operator|=
name|secondary_out_reload
expr_stmt|;
name|rld
index|[
name|i
index|]
operator|.
name|secondary_in_icode
operator|=
name|secondary_in_icode
expr_stmt|;
name|rld
index|[
name|i
index|]
operator|.
name|secondary_out_icode
operator|=
name|secondary_out_icode
expr_stmt|;
name|rld
index|[
name|i
index|]
operator|.
name|secondary_p
operator|=
literal|0
expr_stmt|;
name|n_reloads
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|SECONDARY_MEMORY_NEEDED
block|{
name|int
name|regnum
decl_stmt|;
if|if
condition|(
name|out
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|regnum
operator|=
name|true_regnum
argument_list|(
name|out
argument_list|)
operator|)
operator|>=
literal|0
operator|)
operator|&&
name|regnum
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|SECONDARY_MEMORY_NEEDED
argument_list|(
name|class
argument_list|,
name|REGNO_REG_CLASS
argument_list|(
name|regnum
argument_list|)
argument_list|,
name|outmode
argument_list|)
condition|)
name|get_secondary_mem
argument_list|(
name|out
argument_list|,
name|outmode
argument_list|,
name|opnum
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
else|else
block|{
comment|/* We are reusing an existing reload, 	 but we may have additional information for it. 	 For example, we may now have both IN and OUT 	 while the old one may have just one of them.  */
comment|/* The modes can be different.  If they are, we want to reload in 	 the larger mode, so that the value is valid for both modes.  */
if|if
condition|(
name|inmode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|inmode
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|rld
index|[
name|i
index|]
operator|.
name|inmode
argument_list|)
condition|)
name|rld
index|[
name|i
index|]
operator|.
name|inmode
operator|=
name|inmode
expr_stmt|;
if|if
condition|(
name|outmode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|outmode
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|rld
index|[
name|i
index|]
operator|.
name|outmode
argument_list|)
condition|)
name|rld
index|[
name|i
index|]
operator|.
name|outmode
operator|=
name|outmode
expr_stmt|;
if|if
condition|(
name|in
operator|!=
literal|0
condition|)
block|{
name|rtx
name|in_reg
init|=
name|inloc
condition|?
operator|*
name|inloc
else|:
literal|0
decl_stmt|;
comment|/* If we merge reloads for two distinct rtl expressions that 	     are identical in content, there might be duplicate address 	     reloads.  Remove the extra set now, so that if we later find 	     that we can inherit this reload, we can get rid of the 	     address reloads altogether.  	     Do not do this if both reloads are optional since the result 	     would be an optional reload which could potentially leave 	     unresolved address replacements.  	     It is not sufficient to call transfer_replacements since 	     choose_reload_regs will remove the replacements for address 	     reloads of inherited reloads which results in the same 	     problem.  */
if|if
condition|(
name|rld
index|[
name|i
index|]
operator|.
name|in
operator|!=
name|in
operator|&&
name|rtx_equal_p
argument_list|(
name|in
argument_list|,
name|rld
index|[
name|i
index|]
operator|.
name|in
argument_list|)
operator|&&
operator|!
operator|(
name|rld
index|[
name|i
index|]
operator|.
name|optional
operator|&&
name|optional
operator|)
condition|)
block|{
comment|/* We must keep the address reload with the lower operand 		 number alive.  */
if|if
condition|(
name|opnum
operator|>
name|rld
index|[
name|i
index|]
operator|.
name|opnum
condition|)
block|{
name|remove_address_replacements
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|in
operator|=
name|rld
index|[
name|i
index|]
operator|.
name|in
expr_stmt|;
name|in_reg
operator|=
name|rld
index|[
name|i
index|]
operator|.
name|in_reg
expr_stmt|;
block|}
else|else
name|remove_address_replacements
argument_list|(
name|rld
index|[
name|i
index|]
operator|.
name|in
argument_list|)
expr_stmt|;
block|}
name|rld
index|[
name|i
index|]
operator|.
name|in
operator|=
name|in
expr_stmt|;
name|rld
index|[
name|i
index|]
operator|.
name|in_reg
operator|=
name|in_reg
expr_stmt|;
block|}
if|if
condition|(
name|out
operator|!=
literal|0
condition|)
block|{
name|rld
index|[
name|i
index|]
operator|.
name|out
operator|=
name|out
expr_stmt|;
name|rld
index|[
name|i
index|]
operator|.
name|out_reg
operator|=
name|outloc
condition|?
operator|*
name|outloc
else|:
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|reg_class_subset_p
argument_list|(
name|class
argument_list|,
name|rld
index|[
name|i
index|]
operator|.
name|class
argument_list|)
condition|)
name|rld
index|[
name|i
index|]
operator|.
name|class
operator|=
name|class
expr_stmt|;
name|rld
index|[
name|i
index|]
operator|.
name|optional
operator|&=
name|optional
expr_stmt|;
if|if
condition|(
name|MERGE_TO_OTHER
argument_list|(
name|type
argument_list|,
name|rld
index|[
name|i
index|]
operator|.
name|when_needed
argument_list|,
name|opnum
argument_list|,
name|rld
index|[
name|i
index|]
operator|.
name|opnum
argument_list|)
condition|)
name|rld
index|[
name|i
index|]
operator|.
name|when_needed
operator|=
name|RELOAD_OTHER
expr_stmt|;
name|rld
index|[
name|i
index|]
operator|.
name|opnum
operator|=
name|MIN
argument_list|(
name|rld
index|[
name|i
index|]
operator|.
name|opnum
argument_list|,
name|opnum
argument_list|)
expr_stmt|;
block|}
comment|/* If the ostensible rtx being reloaded differs from the rtx found      in the location to substitute, this reload is not safe to combine      because we cannot reliably tell whether it appears in the insn.  */
if|if
condition|(
name|in
operator|!=
literal|0
operator|&&
name|in
operator|!=
operator|*
name|inloc
condition|)
name|rld
index|[
name|i
index|]
operator|.
name|nocombine
operator|=
literal|1
expr_stmt|;
if|#
directive|if
literal|0
comment|/* This was replaced by changes in find_reloads_address_1 and the new      function inc_for_reload, which go with a new meaning of reload_inc.  */
comment|/* If this is an IN/OUT reload in an insn that sets the CC,      it must be for an autoincrement.  It doesn't work to store      the incremented value after the insn because that would clobber the CC.      So we must do the increment of the value reloaded from,      increment it, store it back, then decrement again.  */
block|if (out != 0&& sets_cc0_p (PATTERN (this_insn)))     {       out = 0;       rld[i].out = 0;       rld[i].inc = find_inc_amount (PATTERN (this_insn), in);
comment|/* If we did not find a nonzero amount-to-increment-by, 	 that contradicts the belief that IN is being incremented 	 in an address in this insn.  */
block|if (rld[i].inc == 0) 	abort ();     }
endif|#
directive|endif
comment|/* If we will replace IN and OUT with the reload-reg,      record where they are located so that substitution need      not do a tree walk.  */
if|if
condition|(
name|replace_reloads
condition|)
block|{
if|if
condition|(
name|inloc
operator|!=
literal|0
condition|)
block|{
name|struct
name|replacement
modifier|*
name|r
init|=
operator|&
name|replacements
index|[
name|n_replacements
operator|++
index|]
decl_stmt|;
name|r
operator|->
name|what
operator|=
name|i
expr_stmt|;
name|r
operator|->
name|subreg_loc
operator|=
name|in_subreg_loc
expr_stmt|;
name|r
operator|->
name|where
operator|=
name|inloc
expr_stmt|;
name|r
operator|->
name|mode
operator|=
name|inmode
expr_stmt|;
block|}
if|if
condition|(
name|outloc
operator|!=
literal|0
operator|&&
name|outloc
operator|!=
name|inloc
condition|)
block|{
name|struct
name|replacement
modifier|*
name|r
init|=
operator|&
name|replacements
index|[
name|n_replacements
operator|++
index|]
decl_stmt|;
name|r
operator|->
name|what
operator|=
name|i
expr_stmt|;
name|r
operator|->
name|where
operator|=
name|outloc
expr_stmt|;
name|r
operator|->
name|subreg_loc
operator|=
name|out_subreg_loc
expr_stmt|;
name|r
operator|->
name|mode
operator|=
name|outmode
expr_stmt|;
block|}
block|}
comment|/* If this reload is just being introduced and it has both      an incoming quantity and an outgoing quantity that are      supposed to be made to match, see if either one of the two      can serve as the place to reload into.       If one of them is acceptable, set rld[i].reg_rtx      to that one.  */
if|if
condition|(
name|in
operator|!=
literal|0
operator|&&
name|out
operator|!=
literal|0
operator|&&
name|in
operator|!=
name|out
operator|&&
name|rld
index|[
name|i
index|]
operator|.
name|reg_rtx
operator|==
literal|0
condition|)
block|{
name|rld
index|[
name|i
index|]
operator|.
name|reg_rtx
operator|=
name|find_dummy_reload
argument_list|(
name|in
argument_list|,
name|out
argument_list|,
name|inloc
argument_list|,
name|outloc
argument_list|,
name|inmode
argument_list|,
name|outmode
argument_list|,
name|rld
index|[
name|i
index|]
operator|.
name|class
argument_list|,
name|i
argument_list|,
name|earlyclobber_operand_p
argument_list|(
name|out
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the outgoing register already contains the same value 	 as the incoming one, we can dispense with loading it. 	 The easiest way to tell the caller that is to give a phony 	 value for the incoming operand (same as outgoing one).  */
if|if
condition|(
name|rld
index|[
name|i
index|]
operator|.
name|reg_rtx
operator|==
name|out
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|REG
operator|||
name|CONSTANT_P
argument_list|(
name|in
argument_list|)
operator|)
operator|&&
literal|0
operator|!=
name|find_equiv_reg
argument_list|(
name|in
argument_list|,
name|this_insn
argument_list|,
literal|0
argument_list|,
name|REGNO
argument_list|(
name|out
argument_list|)
argument_list|,
name|static_reload_reg_p
argument_list|,
name|i
argument_list|,
name|inmode
argument_list|)
condition|)
name|rld
index|[
name|i
index|]
operator|.
name|in
operator|=
name|out
expr_stmt|;
block|}
comment|/* If this is an input reload and the operand contains a register that      dies in this insn and is used nowhere else, see if it is the right class      to be used for this reload.  Use it if so.  (This occurs most commonly      in the case of paradoxical SUBREGs and in-out reloads).  We cannot do      this if it is also an output reload that mentions the register unless      the output is a SUBREG that clobbers an entire register.       Note that the operand might be one of the spill regs, if it is a      pseudo reg and we are in a block where spilling has not taken place.      But if there is no spilling in this block, that is OK.      An explicitly used hard reg cannot be a spill reg.  */
if|if
condition|(
name|rld
index|[
name|i
index|]
operator|.
name|reg_rtx
operator|==
literal|0
operator|&&
name|in
operator|!=
literal|0
condition|)
block|{
name|rtx
name|note
decl_stmt|;
name|int
name|regno
decl_stmt|;
name|enum
name|machine_mode
name|rel_mode
init|=
name|inmode
decl_stmt|;
if|if
condition|(
name|out
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|outmode
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|inmode
argument_list|)
condition|)
name|rel_mode
operator|=
name|outmode
expr_stmt|;
for|for
control|(
name|note
operator|=
name|REG_NOTES
argument_list|(
name|this_insn
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_DEAD
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|regno
operator|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|reg_mentioned_p
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|in
argument_list|)
operator|&&
operator|!
name|refers_to_regno_for_reload_p
argument_list|(
name|regno
argument_list|,
operator|(
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|rel_mode
argument_list|)
operator|)
argument_list|,
name|PATTERN
argument_list|(
name|this_insn
argument_list|)
argument_list|,
name|inloc
argument_list|)
comment|/* If this is also an output reload, IN cannot be used as 	       the reload register if it is set in this insn unless IN 	       is also OUT.  */
operator|&&
operator|(
name|out
operator|==
literal|0
operator|||
name|in
operator|==
name|out
operator|||
operator|!
name|hard_reg_set_here_p
argument_list|(
name|regno
argument_list|,
operator|(
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|rel_mode
argument_list|)
operator|)
argument_list|,
name|PATTERN
argument_list|(
name|this_insn
argument_list|)
argument_list|)
operator|)
comment|/* ??? Why is this code so different from the previous? 	       Is there any simple coherent way to describe the two together? 	       What's going on here.  */
operator|&&
operator|(
name|in
operator|!=
name|out
operator|||
operator|(
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|(
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|in
argument_list|)
argument_list|)
operator|+
operator|(
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
operator|==
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|in
argument_list|)
argument_list|)
argument_list|)
operator|+
operator|(
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
operator|)
operator|)
operator|)
comment|/* Make sure the operand fits in the reg that dies.  */
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|rel_mode
argument_list|)
operator|<=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|&&
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|inmode
argument_list|)
operator|&&
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|outmode
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|offs
decl_stmt|;
name|unsigned
name|int
name|nregs
init|=
name|MAX
argument_list|(
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|inmode
argument_list|)
argument_list|,
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|outmode
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|offs
operator|=
literal|0
init|;
name|offs
operator|<
name|nregs
condition|;
name|offs
operator|++
control|)
if|if
condition|(
name|fixed_regs
index|[
name|regno
operator|+
name|offs
index|]
operator|||
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|class
index|]
argument_list|,
name|regno
operator|+
name|offs
argument_list|)
condition|)
break|break;
if|if
condition|(
name|offs
operator|==
name|nregs
condition|)
block|{
name|rld
index|[
name|i
index|]
operator|.
name|reg_rtx
operator|=
name|gen_rtx_REG
argument_list|(
name|rel_mode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|out
condition|)
name|output_reloadnum
operator|=
name|i
expr_stmt|;
return|return
name|i
return|;
block|}
end_block

begin_comment
comment|/* Record an additional place we must replace a value    for which we have already recorded a reload.    RELOADNUM is the value returned by push_reload    when the reload was recorded.    This is used in insn patterns that use match_dup.  */
end_comment

begin_function
specifier|static
name|void
name|push_replacement
parameter_list|(
name|loc
parameter_list|,
name|reloadnum
parameter_list|,
name|mode
parameter_list|)
name|rtx
modifier|*
name|loc
decl_stmt|;
name|int
name|reloadnum
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|replace_reloads
condition|)
block|{
name|struct
name|replacement
modifier|*
name|r
init|=
operator|&
name|replacements
index|[
name|n_replacements
operator|++
index|]
decl_stmt|;
name|r
operator|->
name|what
operator|=
name|reloadnum
expr_stmt|;
name|r
operator|->
name|where
operator|=
name|loc
expr_stmt|;
name|r
operator|->
name|subreg_loc
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|mode
operator|=
name|mode
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Transfer all replacements that used to be in reload FROM to be in    reload TO.  */
end_comment

begin_function
name|void
name|transfer_replacements
parameter_list|(
name|to
parameter_list|,
name|from
parameter_list|)
name|int
name|to
decl_stmt|,
name|from
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_replacements
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|replacements
index|[
name|i
index|]
operator|.
name|what
operator|==
name|from
condition|)
name|replacements
index|[
name|i
index|]
operator|.
name|what
operator|=
name|to
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* IN_RTX is the value loaded by a reload that we now decided to inherit,    or a subpart of it.  If we have any replacements registered for IN_RTX,    cancel the reloads that were supposed to load them.    Return non-zero if we canceled any reloads.  */
end_comment

begin_function
name|int
name|remove_address_replacements
parameter_list|(
name|in_rtx
parameter_list|)
name|rtx
name|in_rtx
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
name|reload_flags
index|[
name|MAX_RELOADS
index|]
decl_stmt|;
name|int
name|something_changed
init|=
literal|0
decl_stmt|;
name|memset
argument_list|(
name|reload_flags
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|reload_flags
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|n_replacements
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|loc_mentioned_in_p
argument_list|(
name|replacements
index|[
name|i
index|]
operator|.
name|where
argument_list|,
name|in_rtx
argument_list|)
condition|)
name|reload_flags
index|[
name|replacements
index|[
name|i
index|]
operator|.
name|what
index|]
operator||=
literal|1
expr_stmt|;
else|else
block|{
name|replacements
index|[
name|j
operator|++
index|]
operator|=
name|replacements
index|[
name|i
index|]
expr_stmt|;
name|reload_flags
index|[
name|replacements
index|[
name|i
index|]
operator|.
name|what
index|]
operator||=
literal|2
expr_stmt|;
block|}
block|}
comment|/* Note that the following store must be done before the recursive calls.  */
name|n_replacements
operator|=
name|j
expr_stmt|;
for|for
control|(
name|i
operator|=
name|n_reloads
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|reload_flags
index|[
name|i
index|]
operator|==
literal|1
condition|)
block|{
name|deallocate_reload_reg
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|remove_address_replacements
argument_list|(
name|rld
index|[
name|i
index|]
operator|.
name|in
argument_list|)
expr_stmt|;
name|rld
index|[
name|i
index|]
operator|.
name|in
operator|=
literal|0
expr_stmt|;
name|something_changed
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
name|something_changed
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If there is only one output reload, and it is not for an earlyclobber    operand, try to combine it with a (logically unrelated) input reload    to reduce the number of reload registers needed.     This is safe if the input reload does not appear in    the value being output-reloaded, because this implies    it is not needed any more once the original insn completes.     If that doesn't work, see we can use any of the registers that    die in this insn as a reload register.  We can if it is of the right    class and does not appear in the value being output-reloaded.  */
end_comment

begin_function
specifier|static
name|void
name|combine_reloads
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|int
name|output_reload
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|secondary_out
init|=
operator|-
literal|1
decl_stmt|;
name|rtx
name|note
decl_stmt|;
comment|/* Find the output reload; return unless there is exactly one      and that one is mandatory.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_reloads
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|rld
index|[
name|i
index|]
operator|.
name|out
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|output_reload
operator|>=
literal|0
condition|)
return|return;
name|output_reload
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|output_reload
operator|<
literal|0
operator|||
name|rld
index|[
name|output_reload
index|]
operator|.
name|optional
condition|)
return|return;
comment|/* An input-output reload isn't combinable.  */
if|if
condition|(
name|rld
index|[
name|output_reload
index|]
operator|.
name|in
operator|!=
literal|0
condition|)
return|return;
comment|/* If this reload is for an earlyclobber operand, we can't do anything.  */
if|if
condition|(
name|earlyclobber_operand_p
argument_list|(
name|rld
index|[
name|output_reload
index|]
operator|.
name|out
argument_list|)
condition|)
return|return;
comment|/* If there is a reload for part of the address of this operand, we would      need to chnage it to RELOAD_FOR_OTHER_ADDRESS.  But that would extend      its life to the point where doing this combine would not lower the      number of spill registers needed.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_reloads
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|rld
index|[
name|i
index|]
operator|.
name|when_needed
operator|==
name|RELOAD_FOR_OUTPUT_ADDRESS
operator|||
name|rld
index|[
name|i
index|]
operator|.
name|when_needed
operator|==
name|RELOAD_FOR_OUTADDR_ADDRESS
operator|)
operator|&&
name|rld
index|[
name|i
index|]
operator|.
name|opnum
operator|==
name|rld
index|[
name|output_reload
index|]
operator|.
name|opnum
condition|)
return|return;
comment|/* Check each input reload; can we combine it?  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_reloads
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|rld
index|[
name|i
index|]
operator|.
name|in
operator|&&
operator|!
name|rld
index|[
name|i
index|]
operator|.
name|optional
operator|&&
operator|!
name|rld
index|[
name|i
index|]
operator|.
name|nocombine
comment|/* Life span of this reload must not extend past main insn.  */
operator|&&
name|rld
index|[
name|i
index|]
operator|.
name|when_needed
operator|!=
name|RELOAD_FOR_OUTPUT_ADDRESS
operator|&&
name|rld
index|[
name|i
index|]
operator|.
name|when_needed
operator|!=
name|RELOAD_FOR_OUTADDR_ADDRESS
operator|&&
name|rld
index|[
name|i
index|]
operator|.
name|when_needed
operator|!=
name|RELOAD_OTHER
operator|&&
operator|(
name|CLASS_MAX_NREGS
argument_list|(
name|rld
index|[
name|i
index|]
operator|.
name|class
argument_list|,
name|rld
index|[
name|i
index|]
operator|.
name|inmode
argument_list|)
operator|==
name|CLASS_MAX_NREGS
argument_list|(
name|rld
index|[
name|output_reload
index|]
operator|.
name|class
argument_list|,
name|rld
index|[
name|output_reload
index|]
operator|.
name|outmode
argument_list|)
operator|)
operator|&&
name|rld
index|[
name|i
index|]
operator|.
name|inc
operator|==
literal|0
operator|&&
name|rld
index|[
name|i
index|]
operator|.
name|reg_rtx
operator|==
literal|0
ifdef|#
directive|ifdef
name|SECONDARY_MEMORY_NEEDED
comment|/* Don't combine two reloads with different secondary 	   memory locations.  */
operator|&&
operator|(
name|secondary_memlocs_elim
index|[
operator|(
name|int
operator|)
name|rld
index|[
name|output_reload
index|]
operator|.
name|outmode
index|]
index|[
name|rld
index|[
name|i
index|]
operator|.
name|opnum
index|]
operator|==
literal|0
operator|||
name|secondary_memlocs_elim
index|[
operator|(
name|int
operator|)
name|rld
index|[
name|output_reload
index|]
operator|.
name|outmode
index|]
index|[
name|rld
index|[
name|output_reload
index|]
operator|.
name|opnum
index|]
operator|==
literal|0
operator|||
name|rtx_equal_p
argument_list|(
name|secondary_memlocs_elim
index|[
operator|(
name|int
operator|)
name|rld
index|[
name|output_reload
index|]
operator|.
name|outmode
index|]
index|[
name|rld
index|[
name|i
index|]
operator|.
name|opnum
index|]
argument_list|,
name|secondary_memlocs_elim
index|[
operator|(
name|int
operator|)
name|rld
index|[
name|output_reload
index|]
operator|.
name|outmode
index|]
index|[
name|rld
index|[
name|output_reload
index|]
operator|.
name|opnum
index|]
argument_list|)
operator|)
endif|#
directive|endif
operator|&&
operator|(
name|SMALL_REGISTER_CLASSES
condition|?
operator|(
name|rld
index|[
name|i
index|]
operator|.
name|class
operator|==
name|rld
index|[
name|output_reload
index|]
operator|.
name|class
operator|)
else|:
operator|(
name|reg_class_subset_p
argument_list|(
name|rld
index|[
name|i
index|]
operator|.
name|class
argument_list|,
name|rld
index|[
name|output_reload
index|]
operator|.
name|class
argument_list|)
operator|||
name|reg_class_subset_p
argument_list|(
name|rld
index|[
name|output_reload
index|]
operator|.
name|class
argument_list|,
name|rld
index|[
name|i
index|]
operator|.
name|class
argument_list|)
operator|)
operator|)
operator|&&
operator|(
name|MATCHES
argument_list|(
name|rld
index|[
name|i
index|]
operator|.
name|in
argument_list|,
name|rld
index|[
name|output_reload
index|]
operator|.
name|out
argument_list|)
comment|/* Args reversed because the first arg seems to be 	       the one that we imagine being modified 	       while the second is the one that might be affected.  */
operator|||
operator|(
operator|!
name|reg_overlap_mentioned_for_reload_p
argument_list|(
name|rld
index|[
name|output_reload
index|]
operator|.
name|out
argument_list|,
name|rld
index|[
name|i
index|]
operator|.
name|in
argument_list|)
comment|/* However, if the input is a register that appears inside 		   the output, then we also can't share. 		   Imagine (set (mem (reg 69)) (plus (reg 69) ...)). 		   If the same reload reg is used for both reg 69 and the 		   result to be stored in memory, then that result 		   will clobber the address of the memory ref.  */
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|rld
index|[
name|i
index|]
operator|.
name|in
argument_list|)
operator|==
name|REG
operator|&&
name|reg_overlap_mentioned_for_reload_p
argument_list|(
name|rld
index|[
name|i
index|]
operator|.
name|in
argument_list|,
name|rld
index|[
name|output_reload
index|]
operator|.
name|out
argument_list|)
operator|)
operator|)
operator|)
operator|&&
operator|!
name|reload_inner_reg_of_subreg
argument_list|(
name|rld
index|[
name|i
index|]
operator|.
name|in
argument_list|,
name|rld
index|[
name|i
index|]
operator|.
name|inmode
argument_list|,
name|rld
index|[
name|i
index|]
operator|.
name|when_needed
operator|!=
name|RELOAD_FOR_INPUT
argument_list|)
operator|&&
operator|(
name|reg_class_size
index|[
operator|(
name|int
operator|)
name|rld
index|[
name|i
index|]
operator|.
name|class
index|]
operator|||
name|SMALL_REGISTER_CLASSES
operator|)
comment|/* We will allow making things slightly worse by combining an 	   input and an output, but no worse than that.  */
operator|&&
operator|(
name|rld
index|[
name|i
index|]
operator|.
name|when_needed
operator|==
name|RELOAD_FOR_INPUT
operator|||
name|rld
index|[
name|i
index|]
operator|.
name|when_needed
operator|==
name|RELOAD_FOR_OUTPUT
operator|)
condition|)
block|{
name|int
name|j
decl_stmt|;
comment|/* We have found a reload to combine with!  */
name|rld
index|[
name|i
index|]
operator|.
name|out
operator|=
name|rld
index|[
name|output_reload
index|]
operator|.
name|out
expr_stmt|;
name|rld
index|[
name|i
index|]
operator|.
name|out_reg
operator|=
name|rld
index|[
name|output_reload
index|]
operator|.
name|out_reg
expr_stmt|;
name|rld
index|[
name|i
index|]
operator|.
name|outmode
operator|=
name|rld
index|[
name|output_reload
index|]
operator|.
name|outmode
expr_stmt|;
comment|/* Mark the old output reload as inoperative.  */
name|rld
index|[
name|output_reload
index|]
operator|.
name|out
operator|=
literal|0
expr_stmt|;
comment|/* The combined reload is needed for the entire insn.  */
name|rld
index|[
name|i
index|]
operator|.
name|when_needed
operator|=
name|RELOAD_OTHER
expr_stmt|;
comment|/* If the output reload had a secondary reload, copy it.  */
if|if
condition|(
name|rld
index|[
name|output_reload
index|]
operator|.
name|secondary_out_reload
operator|!=
operator|-
literal|1
condition|)
block|{
name|rld
index|[
name|i
index|]
operator|.
name|secondary_out_reload
operator|=
name|rld
index|[
name|output_reload
index|]
operator|.
name|secondary_out_reload
expr_stmt|;
name|rld
index|[
name|i
index|]
operator|.
name|secondary_out_icode
operator|=
name|rld
index|[
name|output_reload
index|]
operator|.
name|secondary_out_icode
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SECONDARY_MEMORY_NEEDED
comment|/* Copy any secondary MEM.  */
if|if
condition|(
name|secondary_memlocs_elim
index|[
operator|(
name|int
operator|)
name|rld
index|[
name|output_reload
index|]
operator|.
name|outmode
index|]
index|[
name|rld
index|[
name|output_reload
index|]
operator|.
name|opnum
index|]
operator|!=
literal|0
condition|)
name|secondary_memlocs_elim
index|[
operator|(
name|int
operator|)
name|rld
index|[
name|output_reload
index|]
operator|.
name|outmode
index|]
index|[
name|rld
index|[
name|i
index|]
operator|.
name|opnum
index|]
operator|=
name|secondary_memlocs_elim
index|[
operator|(
name|int
operator|)
name|rld
index|[
name|output_reload
index|]
operator|.
name|outmode
index|]
index|[
name|rld
index|[
name|output_reload
index|]
operator|.
name|opnum
index|]
expr_stmt|;
endif|#
directive|endif
comment|/* If required, minimize the register class.  */
if|if
condition|(
name|reg_class_subset_p
argument_list|(
name|rld
index|[
name|output_reload
index|]
operator|.
name|class
argument_list|,
name|rld
index|[
name|i
index|]
operator|.
name|class
argument_list|)
condition|)
name|rld
index|[
name|i
index|]
operator|.
name|class
operator|=
name|rld
index|[
name|output_reload
index|]
operator|.
name|class
expr_stmt|;
comment|/* Transfer all replacements from the old reload to the combined.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_replacements
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|replacements
index|[
name|j
index|]
operator|.
name|what
operator|==
name|output_reload
condition|)
name|replacements
index|[
name|j
index|]
operator|.
name|what
operator|=
name|i
expr_stmt|;
return|return;
block|}
comment|/* If this insn has only one operand that is modified or written (assumed      to be the first),  it must be the one corresponding to this reload.  It      is safe to use anything that dies in this insn for that output provided      that it does not occur in the output (we already know it isn't an      earlyclobber.  If this is an asm insn, give up.  */
if|if
condition|(
name|INSN_CODE
argument_list|(
name|this_insn
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|insn_data
index|[
name|INSN_CODE
argument_list|(
name|this_insn
argument_list|)
index|]
operator|.
name|n_operands
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|insn_data
index|[
name|INSN_CODE
argument_list|(
name|this_insn
argument_list|)
index|]
operator|.
name|operand
index|[
name|i
index|]
operator|.
name|constraint
index|[
literal|0
index|]
operator|==
literal|'='
operator|||
name|insn_data
index|[
name|INSN_CODE
argument_list|(
name|this_insn
argument_list|)
index|]
operator|.
name|operand
index|[
name|i
index|]
operator|.
name|constraint
index|[
literal|0
index|]
operator|==
literal|'+'
condition|)
return|return;
comment|/* See if some hard register that dies in this insn and is not used in      the output is the right class.  Only works if the register we pick      up can fully hold our output reload.  */
for|for
control|(
name|note
operator|=
name|REG_NOTES
argument_list|(
name|this_insn
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_DEAD
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|!
name|reg_overlap_mentioned_for_reload_p
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|rld
index|[
name|output_reload
index|]
operator|.
name|out
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|HARD_REGNO_MODE_OK
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|rld
index|[
name|output_reload
index|]
operator|.
name|outmode
argument_list|)
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|rld
index|[
name|output_reload
index|]
operator|.
name|class
index|]
argument_list|,
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|&&
operator|(
name|HARD_REGNO_NREGS
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|rld
index|[
name|output_reload
index|]
operator|.
name|outmode
argument_list|)
operator|<=
name|HARD_REGNO_NREGS
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
comment|/* Ensure that a secondary or tertiary reload for this output 	   won't want this register.  */
operator|&&
operator|(
operator|(
name|secondary_out
operator|=
name|rld
index|[
name|output_reload
index|]
operator|.
name|secondary_out_reload
operator|)
operator|==
operator|-
literal|1
operator|||
operator|(
operator|!
operator|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|rld
index|[
name|secondary_out
index|]
operator|.
name|class
index|]
argument_list|,
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|secondary_out
operator|=
name|rld
index|[
name|secondary_out
index|]
operator|.
name|secondary_out_reload
operator|)
operator|==
operator|-
literal|1
operator|||
operator|!
operator|(
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|rld
index|[
name|secondary_out
index|]
operator|.
name|class
index|]
argument_list|,
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|)
operator|)
operator|)
operator|&&
operator|!
name|fixed_regs
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
condition|)
block|{
name|rld
index|[
name|output_reload
index|]
operator|.
name|reg_rtx
operator|=
name|gen_rtx_REG
argument_list|(
name|rld
index|[
name|output_reload
index|]
operator|.
name|outmode
argument_list|,
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Try to find a reload register for an in-out reload (expressions IN and OUT).    See if one of IN and OUT is a register that may be used;    this is desirable since a spill-register won't be needed.    If so, return the register rtx that proves acceptable.     INLOC and OUTLOC are locations where IN and OUT appear in the insn.    CLASS is the register class required for the reload.     If FOR_REAL is>= 0, it is the number of the reload,    and in some cases when it can be discovered that OUT doesn't need    to be computed, clear out rld[FOR_REAL].out.     If FOR_REAL is -1, this should not be done, because this call    is just to see if a register can be found, not to find and install it.     EARLYCLOBBER is non-zero if OUT is an earlyclobber operand.  This    puts an additional constraint on being able to use IN for OUT since    IN must not appear elsewhere in the insn (it is assumed that IN itself    is safe from the earlyclobber).  */
end_comment

begin_function
specifier|static
name|rtx
name|find_dummy_reload
parameter_list|(
name|real_in
parameter_list|,
name|real_out
parameter_list|,
name|inloc
parameter_list|,
name|outloc
parameter_list|,
name|inmode
parameter_list|,
name|outmode
parameter_list|,
name|class
parameter_list|,
name|for_real
parameter_list|,
name|earlyclobber
parameter_list|)
name|rtx
name|real_in
decl_stmt|,
name|real_out
decl_stmt|;
name|rtx
modifier|*
name|inloc
decl_stmt|,
decl|*
name|outloc
decl_stmt|;
end_function

begin_decl_stmt
name|enum
name|machine_mode
name|inmode
decl_stmt|,
name|outmode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|reg_class
name|class
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|for_real
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|earlyclobber
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|rtx
name|in
init|=
name|real_in
decl_stmt|;
name|rtx
name|out
init|=
name|real_out
decl_stmt|;
name|int
name|in_offset
init|=
literal|0
decl_stmt|;
name|int
name|out_offset
init|=
literal|0
decl_stmt|;
name|rtx
name|value
init|=
literal|0
decl_stmt|;
comment|/* If operands exceed a word, we can't use either of them      unless they have the same size.  */
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|outmode
argument_list|)
operator|!=
name|GET_MODE_SIZE
argument_list|(
name|inmode
argument_list|)
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|outmode
argument_list|)
operator|>
name|UNITS_PER_WORD
operator|||
name|GET_MODE_SIZE
argument_list|(
name|inmode
argument_list|)
operator|>
name|UNITS_PER_WORD
operator|)
condition|)
return|return
literal|0
return|;
comment|/* Note that {in,out}_offset are needed only when 'in' or 'out'      respectively refers to a hard register.  */
comment|/* Find the inside of any subregs.  */
while|while
condition|(
name|GET_CODE
argument_list|(
name|out
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|out
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|out
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|out_offset
operator|+=
name|subreg_regno_offset
argument_list|(
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|out
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|out
argument_list|)
argument_list|)
argument_list|,
name|SUBREG_BYTE
argument_list|(
name|out
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|out
argument_list|)
argument_list|)
expr_stmt|;
name|out
operator|=
name|SUBREG_REG
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|in
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|in
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|in_offset
operator|+=
name|subreg_regno_offset
argument_list|(
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|in
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|in
argument_list|)
argument_list|)
argument_list|,
name|SUBREG_BYTE
argument_list|(
name|in
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|in
argument_list|)
argument_list|)
expr_stmt|;
name|in
operator|=
name|SUBREG_REG
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
comment|/* Narrow down the reg class, the same way push_reload will;      otherwise we might find a dummy now, but push_reload won't.  */
name|class
operator|=
name|PREFERRED_RELOAD_CLASS
argument_list|(
name|in
argument_list|,
name|class
argument_list|)
expr_stmt|;
comment|/* See if OUT will do.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|out
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|out
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|unsigned
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|out
argument_list|)
operator|+
name|out_offset
decl_stmt|;
name|unsigned
name|int
name|nwords
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|outmode
argument_list|)
decl_stmt|;
name|rtx
name|saved_rtx
decl_stmt|;
comment|/* When we consider whether the insn uses OUT, 	 ignore references within IN.  They don't prevent us 	 from copying IN into OUT, because those refs would 	 move into the insn that reloads IN.  	 However, we only ignore IN in its role as this reload. 	 If the insn uses IN elsewhere and it contains OUT, 	 that counts.  We can't be sure it's the "same" operand 	 so it might not go through this reload.  */
name|saved_rtx
operator|=
operator|*
name|inloc
expr_stmt|;
operator|*
name|inloc
operator|=
name|const0_rtx
expr_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|outmode
argument_list|)
operator|&&
operator|!
name|refers_to_regno_for_reload_p
argument_list|(
name|regno
argument_list|,
name|regno
operator|+
name|nwords
argument_list|,
name|PATTERN
argument_list|(
name|this_insn
argument_list|)
argument_list|,
name|outloc
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nwords
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|class
index|]
argument_list|,
name|regno
operator|+
name|i
argument_list|)
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|nwords
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|real_out
argument_list|)
operator|==
name|REG
condition|)
name|value
operator|=
name|real_out
expr_stmt|;
else|else
name|value
operator|=
name|gen_rtx_REG
argument_list|(
name|outmode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|inloc
operator|=
name|saved_rtx
expr_stmt|;
block|}
comment|/* Consider using IN if OUT was not acceptable      or if OUT dies in this insn (like the quotient in a divmod insn).      We can't use IN unless it is dies in this insn,      which means we must know accurately which hard regs are live.      Also, the result can't go in IN if IN is used within OUT,      or if OUT is an earlyclobber and IN appears elsewhere in the insn.  */
if|if
condition|(
name|hard_regs_live_known
operator|&&
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|in
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|(
name|value
operator|==
literal|0
operator|||
name|find_reg_note
argument_list|(
name|this_insn
argument_list|,
name|REG_UNUSED
argument_list|,
name|real_out
argument_list|)
operator|)
operator|&&
name|find_reg_note
argument_list|(
name|this_insn
argument_list|,
name|REG_DEAD
argument_list|,
name|real_in
argument_list|)
operator|&&
operator|!
name|fixed_regs
index|[
name|REGNO
argument_list|(
name|in
argument_list|)
index|]
operator|&&
name|HARD_REGNO_MODE_OK
argument_list|(
name|REGNO
argument_list|(
name|in
argument_list|)
argument_list|,
comment|/* The only case where out and real_out might 				have different modes is where real_out 				is a subreg, and in that case, out 				has a real mode.  */
operator|(
name|GET_MODE
argument_list|(
name|out
argument_list|)
operator|!=
name|VOIDmode
condition|?
name|GET_MODE
argument_list|(
name|out
argument_list|)
else|:
name|outmode
operator|)
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|in
argument_list|)
operator|+
name|in_offset
decl_stmt|;
name|unsigned
name|int
name|nwords
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|inmode
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|refers_to_regno_for_reload_p
argument_list|(
name|regno
argument_list|,
name|regno
operator|+
name|nwords
argument_list|,
name|out
argument_list|,
operator|(
name|rtx
operator|*
operator|)
literal|0
argument_list|)
operator|&&
operator|!
name|hard_reg_set_here_p
argument_list|(
name|regno
argument_list|,
name|regno
operator|+
name|nwords
argument_list|,
name|PATTERN
argument_list|(
name|this_insn
argument_list|)
argument_list|)
operator|&&
operator|(
operator|!
name|earlyclobber
operator|||
operator|!
name|refers_to_regno_for_reload_p
argument_list|(
name|regno
argument_list|,
name|regno
operator|+
name|nwords
argument_list|,
name|PATTERN
argument_list|(
name|this_insn
argument_list|)
argument_list|,
name|inloc
argument_list|)
operator|)
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nwords
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|class
index|]
argument_list|,
name|regno
operator|+
name|i
argument_list|)
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|nwords
condition|)
block|{
comment|/* If we were going to use OUT as the reload reg 		 and changed our mind, it means OUT is a dummy that 		 dies here.  So don't bother copying value to it.  */
if|if
condition|(
name|for_real
operator|>=
literal|0
operator|&&
name|value
operator|==
name|real_out
condition|)
name|rld
index|[
name|for_real
index|]
operator|.
name|out
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|real_in
argument_list|)
operator|==
name|REG
condition|)
name|value
operator|=
name|real_in
expr_stmt|;
else|else
name|value
operator|=
name|gen_rtx_REG
argument_list|(
name|inmode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|value
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* This page contains subroutines used mainly for determining    whether the IN or an OUT of a reload can serve as the    reload register.  */
end_comment

begin_comment
comment|/* Return 1 if X is an operand of an insn that is being earlyclobbered.  */
end_comment

begin_function
name|int
name|earlyclobber_operand_p
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_earlyclobbers
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|reload_earlyclobbers
index|[
name|i
index|]
operator|==
name|x
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if expression X alters a hard reg in the range    from BEG_REGNO (inclusive) to END_REGNO (exclusive),    either explicitly or in the guise of a pseudo-reg allocated to REGNO.    X should be the body of an instruction.  */
end_comment

begin_function
specifier|static
name|int
name|hard_reg_set_here_p
parameter_list|(
name|beg_regno
parameter_list|,
name|end_regno
parameter_list|,
name|x
parameter_list|)
name|unsigned
name|int
name|beg_regno
decl_stmt|,
name|end_regno
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SET
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CLOBBER
condition|)
block|{
name|rtx
name|op0
init|=
name|SET_DEST
argument_list|(
name|x
argument_list|)
decl_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SUBREG
condition|)
name|op0
operator|=
name|SUBREG_REG
argument_list|(
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|REG
condition|)
block|{
name|unsigned
name|int
name|r
init|=
name|REGNO
argument_list|(
name|op0
argument_list|)
decl_stmt|;
comment|/* See if this reg overlaps range under consideration.  */
if|if
condition|(
name|r
operator|<
name|end_regno
operator|&&
name|r
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|r
argument_list|,
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|>
name|beg_regno
condition|)
return|return
literal|1
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|i
init|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
decl_stmt|;
for|for
control|(
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|hard_reg_set_here_p
argument_list|(
name|beg_regno
argument_list|,
name|end_regno
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if ADDR is a valid memory address for mode MODE,    and check that each pseudo reg has the proper kind of    hard reg.  */
end_comment

begin_function
name|int
name|strict_memory_address_p
parameter_list|(
name|mode
parameter_list|,
name|addr
parameter_list|)
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|rtx
name|addr
decl_stmt|;
block|{
name|GO_IF_LEGITIMATE_ADDRESS
argument_list|(
name|mode
argument_list|,
name|addr
argument_list|,
name|win
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|win
label|:
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Like rtx_equal_p except that it allows a REG and a SUBREG to match    if they are the same hard reg, and has special hacks for    autoincrement and autodecrement.    This is specifically intended for find_reloads to use    in determining whether two operands match.    X is the operand whose number is the lower of the two.     The value is 2 if Y contains a pre-increment that matches    a non-incrementing address in X.  */
end_comment

begin_comment
comment|/* ??? To be completely correct, we should arrange to pass    for X the output operand and for Y the input operand.    For now, we assume that the output operand has the lower number    because that is natural in (SET output (... input ...)).  */
end_comment

begin_function
name|int
name|operands_match_p
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|success_2
decl_stmt|;
if|if
condition|(
name|x
operator|==
name|y
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|code
operator|==
name|REG
operator|||
operator|(
name|code
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
operator|)
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|REG
operator|||
operator|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|y
argument_list|)
argument_list|)
operator|==
name|REG
operator|)
operator|)
condition|)
block|{
name|int
name|j
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|SUBREG
condition|)
block|{
name|i
operator|=
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
goto|goto
name|slow
goto|;
name|i
operator|+=
name|subreg_regno_offset
argument_list|(
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|SUBREG_BYTE
argument_list|(
name|x
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|i
operator|=
name|REGNO
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|j
operator|=
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|y
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
goto|goto
name|slow
goto|;
name|j
operator|+=
name|subreg_regno_offset
argument_list|(
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|y
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|y
argument_list|)
argument_list|)
argument_list|,
name|SUBREG_BYTE
argument_list|(
name|y
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|y
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|j
operator|=
name|REGNO
argument_list|(
name|y
argument_list|)
expr_stmt|;
comment|/* On a WORDS_BIG_ENDIAN machine, point to the last register of a 	 multiple hard register group, so that for example (reg:DI 0) and 	 (reg:SI 1) will be considered the same register.  */
if|if
condition|(
name|WORDS_BIG_ENDIAN
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|>
name|UNITS_PER_WORD
operator|&&
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|i
operator|+=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|/
name|UNITS_PER_WORD
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|WORDS_BIG_ENDIAN
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|y
argument_list|)
argument_list|)
operator|>
name|UNITS_PER_WORD
operator|&&
name|j
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|j
operator|+=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|y
argument_list|)
argument_list|)
operator|/
name|UNITS_PER_WORD
operator|)
operator|-
literal|1
expr_stmt|;
return|return
name|i
operator|==
name|j
return|;
block|}
comment|/* If two operands must match, because they are really a single      operand of an assembler insn, then two postincrements are invalid      because the assembler insn would increment only once.      On the other hand, an postincrement matches ordinary indexing      if the postincrement is the output operand.  */
if|if
condition|(
name|code
operator|==
name|POST_DEC
operator|||
name|code
operator|==
name|POST_INC
operator|||
name|code
operator|==
name|POST_MODIFY
condition|)
return|return
name|operands_match_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|y
argument_list|)
return|;
comment|/* Two preincrements are invalid      because the assembler insn would increment only once.      On the other hand, an preincrement matches ordinary indexing      if the preincrement is the input operand.      In this case, return 2, since some callers need to do special      things when this happens.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|PRE_DEC
operator|||
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|PRE_INC
operator|||
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|PRE_MODIFY
condition|)
return|return
name|operands_match_p
argument_list|(
name|x
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|?
literal|2
else|:
literal|0
return|;
name|slow
label|:
comment|/* Now we have disposed of all the cases      in which different rtx codes can match.  */
if|if
condition|(
name|code
operator|!=
name|GET_CODE
argument_list|(
name|y
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|code
operator|==
name|LABEL_REF
condition|)
return|return
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
return|;
if|if
condition|(
name|code
operator|==
name|SYMBOL_REF
condition|)
return|return
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|XSTR
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
return|;
comment|/* (MULT:SI x y) and (MULT:HI x y) are NOT equivalent.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|y
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Compare the elements.  If any pair of corresponding elements      fail to match, return 0 for the whole things.  */
name|success_2
operator|=
literal|0
expr_stmt|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|int
name|val
decl_stmt|,
name|j
decl_stmt|;
switch|switch
condition|(
name|fmt
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'w'
case|:
if|if
condition|(
name|XWINT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XWINT
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'i'
case|:
if|if
condition|(
name|XINT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XINT
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'e'
case|:
name|val
operator|=
name|operands_match_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* If any subexpression returns 2, 	     we should return 2 if we are successful.  */
if|if
condition|(
name|val
operator|==
literal|2
condition|)
name|success_2
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
break|break;
case|case
literal|'E'
case|:
if|if
condition|(
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XVECLEN
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
operator|--
name|j
control|)
block|{
name|val
operator|=
name|operands_match_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|XVECEXP
argument_list|(
name|y
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|val
operator|==
literal|2
condition|)
name|success_2
operator|=
literal|1
expr_stmt|;
block|}
break|break;
comment|/* It is believed that rtx's at this level will never 	     contain anything but integers and other rtx's, 	     except for within LABEL_REFs and SYMBOL_REFs.  */
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
return|return
literal|1
operator|+
name|success_2
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Describe the range of registers or memory referenced by X.    If X is a register, set REG_FLAG and put the first register    number into START and the last plus one into END.    If X is a memory reference, put a base address into BASE    and a range of integer offsets into START and END.    If X is pushing on the stack, we can assume it causes no trouble,    so we set the SAFE field.  */
end_comment

begin_function
specifier|static
name|struct
name|decomposition
name|decompose
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|struct
name|decomposition
name|val
decl_stmt|;
name|int
name|all_const
init|=
literal|0
decl_stmt|;
name|val
operator|.
name|reg_flag
operator|=
literal|0
expr_stmt|;
name|val
operator|.
name|safe
operator|=
literal|0
expr_stmt|;
name|val
operator|.
name|base
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|rtx
name|base
init|=
name|NULL_RTX
decl_stmt|,
name|offset
init|=
literal|0
decl_stmt|;
name|rtx
name|addr
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PRE_DEC
operator|||
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PRE_INC
operator|||
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|POST_DEC
operator|||
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|POST_INC
condition|)
block|{
name|val
operator|.
name|base
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|val
operator|.
name|start
operator|=
operator|-
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|val
operator|.
name|end
operator|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|val
operator|.
name|safe
operator|=
name|REGNO
argument_list|(
name|val
operator|.
name|base
argument_list|)
operator|==
name|STACK_POINTER_REGNUM
expr_stmt|;
return|return
name|val
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PRE_MODIFY
operator|||
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|POST_MODIFY
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
operator|==
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|val
operator|.
name|base
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|val
operator|.
name|start
operator|=
operator|-
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|val
operator|.
name|end
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|val
operator|.
name|safe
operator|=
name|REGNO
argument_list|(
name|val
operator|.
name|base
argument_list|)
operator|==
name|STACK_POINTER_REGNUM
expr_stmt|;
return|return
name|val
return|;
block|}
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|CONST
condition|)
block|{
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|all_const
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
condition|)
block|{
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|base
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|offset
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|base
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|offset
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
block|{
name|base
operator|=
name|addr
expr_stmt|;
name|offset
operator|=
name|const0_rtx
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|offset
argument_list|)
operator|==
name|CONST
condition|)
name|offset
operator|=
name|XEXP
argument_list|(
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|offset
argument_list|)
operator|==
name|PLUS
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|offset
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|base
operator|=
name|gen_rtx_PLUS
argument_list|(
name|GET_MODE
argument_list|(
name|base
argument_list|)
argument_list|,
name|base
argument_list|,
name|XEXP
argument_list|(
name|offset
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|=
name|XEXP
argument_list|(
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|offset
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|base
operator|=
name|gen_rtx_PLUS
argument_list|(
name|GET_MODE
argument_list|(
name|base
argument_list|)
argument_list|,
name|base
argument_list|,
name|XEXP
argument_list|(
name|offset
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|=
name|XEXP
argument_list|(
name|offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|base
operator|=
name|gen_rtx_PLUS
argument_list|(
name|GET_MODE
argument_list|(
name|base
argument_list|)
argument_list|,
name|base
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|=
name|const0_rtx
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|offset
argument_list|)
operator|!=
name|CONST_INT
condition|)
block|{
name|base
operator|=
name|gen_rtx_PLUS
argument_list|(
name|GET_MODE
argument_list|(
name|base
argument_list|)
argument_list|,
name|base
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|=
name|const0_rtx
expr_stmt|;
block|}
if|if
condition|(
name|all_const
operator|&&
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|PLUS
condition|)
name|base
operator|=
name|gen_rtx_CONST
argument_list|(
name|GET_MODE
argument_list|(
name|base
argument_list|)
argument_list|,
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|offset
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|abort
argument_list|()
expr_stmt|;
name|val
operator|.
name|start
operator|=
name|INTVAL
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|val
operator|.
name|end
operator|=
name|val
operator|.
name|start
operator|+
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|val
operator|.
name|base
operator|=
name|base
expr_stmt|;
return|return
name|val
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
block|{
name|val
operator|.
name|reg_flag
operator|=
literal|1
expr_stmt|;
name|val
operator|.
name|start
operator|=
name|true_regnum
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|.
name|start
operator|<
literal|0
condition|)
block|{
comment|/* A pseudo with no hard reg.  */
name|val
operator|.
name|start
operator|=
name|REGNO
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|val
operator|.
name|end
operator|=
name|val
operator|.
name|start
operator|+
literal|1
expr_stmt|;
block|}
else|else
comment|/* A hard reg.  */
name|val
operator|.
name|end
operator|=
name|val
operator|.
name|start
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|val
operator|.
name|start
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
comment|/* This could be more precise, but it's good enough.  */
return|return
name|decompose
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
return|;
name|val
operator|.
name|reg_flag
operator|=
literal|1
expr_stmt|;
name|val
operator|.
name|start
operator|=
name|true_regnum
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|.
name|start
operator|<
literal|0
condition|)
return|return
name|decompose
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
return|;
else|else
comment|/* A hard reg.  */
name|val
operator|.
name|end
operator|=
name|val
operator|.
name|start
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|val
operator|.
name|start
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
comment|/* This hasn't been assigned yet, so it can't conflict yet.  */
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SCRATCH
condition|)
name|val
operator|.
name|safe
operator|=
literal|1
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if altering Y will not modify the value of X.    Y is also described by YDATA, which should be decompose (Y).  */
end_comment

begin_function
specifier|static
name|int
name|immune_p
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|ydata
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
name|struct
name|decomposition
name|ydata
decl_stmt|;
block|{
name|struct
name|decomposition
name|xdata
decl_stmt|;
if|if
condition|(
name|ydata
operator|.
name|reg_flag
condition|)
return|return
operator|!
name|refers_to_regno_for_reload_p
argument_list|(
name|ydata
operator|.
name|start
argument_list|,
name|ydata
operator|.
name|end
argument_list|,
name|x
argument_list|,
operator|(
name|rtx
operator|*
operator|)
literal|0
argument_list|)
return|;
if|if
condition|(
name|ydata
operator|.
name|safe
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|!=
name|MEM
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If Y is memory and X is not, Y can't affect X.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM
condition|)
return|return
literal|1
return|;
name|xdata
operator|=
name|decompose
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|xdata
operator|.
name|base
argument_list|,
name|ydata
operator|.
name|base
argument_list|)
condition|)
block|{
comment|/* If bases are distinct symbolic constants, there is no overlap.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|xdata
operator|.
name|base
argument_list|)
operator|&&
name|CONSTANT_P
argument_list|(
name|ydata
operator|.
name|base
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Constants and stack slots never overlap.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|xdata
operator|.
name|base
argument_list|)
operator|&&
operator|(
name|ydata
operator|.
name|base
operator|==
name|frame_pointer_rtx
operator|||
name|ydata
operator|.
name|base
operator|==
name|hard_frame_pointer_rtx
operator|||
name|ydata
operator|.
name|base
operator|==
name|stack_pointer_rtx
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|ydata
operator|.
name|base
argument_list|)
operator|&&
operator|(
name|xdata
operator|.
name|base
operator|==
name|frame_pointer_rtx
operator|||
name|xdata
operator|.
name|base
operator|==
name|hard_frame_pointer_rtx
operator|||
name|xdata
operator|.
name|base
operator|==
name|stack_pointer_rtx
operator|)
condition|)
return|return
literal|1
return|;
comment|/* If either base is variable, we don't know anything.  */
return|return
literal|0
return|;
block|}
return|return
operator|(
name|xdata
operator|.
name|start
operator|>=
name|ydata
operator|.
name|end
operator|||
name|ydata
operator|.
name|start
operator|>=
name|xdata
operator|.
name|end
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Similar, but calls decompose.  */
end_comment

begin_function
name|int
name|safe_from_earlyclobber
parameter_list|(
name|op
parameter_list|,
name|clobber
parameter_list|)
name|rtx
name|op
decl_stmt|,
name|clobber
decl_stmt|;
block|{
name|struct
name|decomposition
name|early_data
decl_stmt|;
name|early_data
operator|=
name|decompose
argument_list|(
name|clobber
argument_list|)
expr_stmt|;
return|return
name|immune_p
argument_list|(
name|op
argument_list|,
name|clobber
argument_list|,
name|early_data
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Main entry point of this file: search the body of INSN    for values that need reloading and record them with push_reload.    REPLACE nonzero means record also where the values occur    so that subst_reloads can be used.     IND_LEVELS says how many levels of indirection are supported by this    machine; a value of zero means that a memory reference is not a valid    memory address.     LIVE_KNOWN says we have valid information about which hard    regs are live at each point in the program; this is true when    we are called from global_alloc but false when stupid register    allocation has been done.     RELOAD_REG_P if nonzero is a vector indexed by hard reg number    which is nonnegative if the reg has been commandeered for reloading into.    It is copied into STATIC_RELOAD_REG_P and referenced from there    by various subroutines.     Return TRUE if some operands need to be changed, because of swapping    commutative operands, reg_equiv_address substitution, or whatever.  */
end_comment

begin_function
name|int
name|find_reloads
parameter_list|(
name|insn
parameter_list|,
name|replace
parameter_list|,
name|ind_levels
parameter_list|,
name|live_known
parameter_list|,
name|reload_reg_p
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|int
name|replace
decl_stmt|,
name|ind_levels
decl_stmt|;
name|int
name|live_known
decl_stmt|;
name|short
modifier|*
name|reload_reg_p
decl_stmt|;
block|{
name|int
name|insn_code_number
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|noperands
decl_stmt|;
comment|/* These start out as the constraints for the insn      and they are chewed up as we consider alternatives.  */
name|char
modifier|*
name|constraints
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
comment|/* These are the preferred classes for an operand, or NO_REGS if it isn't      a register.  */
name|enum
name|reg_class
name|preferred_class
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|char
name|pref_or_nothing
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
comment|/* Nonzero for a MEM operand whose entire address needs a reload.  */
name|int
name|address_reloaded
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
comment|/* Value of enum reload_type to use for operand.  */
name|enum
name|reload_type
name|operand_type
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
comment|/* Value of enum reload_type to use within address of operand.  */
name|enum
name|reload_type
name|address_type
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
comment|/* Save the usage of each operand.  */
enum|enum
name|reload_usage
block|{
name|RELOAD_READ
block|,
name|RELOAD_READ_WRITE
block|,
name|RELOAD_WRITE
block|}
name|modified
index|[
name|MAX_RECOG_OPERANDS
index|]
enum|;
name|int
name|no_input_reloads
init|=
literal|0
decl_stmt|,
name|no_output_reloads
init|=
literal|0
decl_stmt|;
name|int
name|n_alternatives
decl_stmt|;
name|int
name|this_alternative
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|char
name|this_alternative_match_win
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|char
name|this_alternative_win
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|char
name|this_alternative_offmemok
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|char
name|this_alternative_earlyclobber
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|int
name|this_alternative_matches
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|int
name|swapped
decl_stmt|;
name|int
name|goal_alternative
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|int
name|this_alternative_number
decl_stmt|;
name|int
name|goal_alternative_number
init|=
literal|0
decl_stmt|;
name|int
name|operand_reloadnum
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|int
name|goal_alternative_matches
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|int
name|goal_alternative_matched
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|char
name|goal_alternative_match_win
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|char
name|goal_alternative_win
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|char
name|goal_alternative_offmemok
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|char
name|goal_alternative_earlyclobber
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|int
name|goal_alternative_swapped
decl_stmt|;
name|int
name|best
decl_stmt|;
name|int
name|commutative
decl_stmt|;
name|char
name|operands_match
index|[
name|MAX_RECOG_OPERANDS
index|]
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|rtx
name|substed_operand
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|rtx
name|body
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|set
init|=
name|single_set
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|int
name|goal_earlyclobber
init|=
literal|0
decl_stmt|,
name|this_earlyclobber
decl_stmt|;
name|enum
name|machine_mode
name|operand_mode
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|this_insn
operator|=
name|insn
expr_stmt|;
name|n_reloads
operator|=
literal|0
expr_stmt|;
name|n_replacements
operator|=
literal|0
expr_stmt|;
name|n_earlyclobbers
operator|=
literal|0
expr_stmt|;
name|replace_reloads
operator|=
name|replace
expr_stmt|;
name|hard_regs_live_known
operator|=
name|live_known
expr_stmt|;
name|static_reload_reg_p
operator|=
name|reload_reg_p
expr_stmt|;
comment|/* JUMP_INSNs and CALL_INSNs are not allowed to have any output reloads;      neither are insns that SET cc0.  Insns that use CC0 are not allowed      to have any input reloads.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
name|no_output_reloads
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
if|if
condition|(
name|reg_referenced_p
argument_list|(
name|cc0_rtx
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
name|no_input_reloads
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|reg_set_p
argument_list|(
name|cc0_rtx
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
name|no_output_reloads
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SECONDARY_MEMORY_NEEDED
comment|/* The eliminated forms of any secondary memory locations are per-insn, so      clear them out here.  */
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|secondary_memlocs_elim
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|secondary_memlocs_elim
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Dispose quickly of (set (reg..) (reg..)) if both have hard regs and it      is cheap to move between them.  If it is not, there may not be an insn      to do the copy, so we may need a reload.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|REGISTER_MOVE_COST
argument_list|(
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
argument_list|,
name|REGNO_REG_CLASS
argument_list|(
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|REGNO_REG_CLASS
argument_list|(
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|2
condition|)
return|return
literal|0
return|;
name|extract_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|noperands
operator|=
name|reload_n_operands
operator|=
name|recog_data
operator|.
name|n_operands
expr_stmt|;
name|n_alternatives
operator|=
name|recog_data
operator|.
name|n_alternatives
expr_stmt|;
comment|/* Just return "no reloads" if insn has no operands with constraints.  */
if|if
condition|(
name|noperands
operator|==
literal|0
operator|||
name|n_alternatives
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|insn_code_number
operator|=
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|this_insn_is_asm
operator|=
name|insn_code_number
operator|<
literal|0
expr_stmt|;
name|memcpy
argument_list|(
name|operand_mode
argument_list|,
name|recog_data
operator|.
name|operand_mode
argument_list|,
name|noperands
operator|*
sizeof|sizeof
argument_list|(
expr|enum
name|machine_mode
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|constraints
argument_list|,
name|recog_data
operator|.
name|constraints
argument_list|,
name|noperands
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|commutative
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* If we will need to know, later, whether some pair of operands      are the same, we must compare them now and save the result.      Reloading the base and index registers will clobber them      and afterward they will fail to match.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|noperands
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|c
decl_stmt|;
name|substed_operand
index|[
name|i
index|]
operator|=
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
expr_stmt|;
name|p
operator|=
name|constraints
index|[
name|i
index|]
expr_stmt|;
name|modified
index|[
name|i
index|]
operator|=
name|RELOAD_READ
expr_stmt|;
comment|/* Scan this operand's constraint to see if it is an output operand, 	 an in-out operand, is commutative, or should match another.  */
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'='
condition|)
name|modified
index|[
name|i
index|]
operator|=
name|RELOAD_WRITE
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'+'
condition|)
name|modified
index|[
name|i
index|]
operator|=
name|RELOAD_READ_WRITE
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'%'
condition|)
block|{
comment|/* The last operand should not be marked commutative.  */
if|if
condition|(
name|i
operator|==
name|noperands
operator|-
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
name|commutative
operator|=
name|i
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ISDIGIT
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|c
operator|=
name|strtoul
argument_list|(
name|p
operator|-
literal|1
argument_list|,
operator|&
name|p
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|operands_match
index|[
name|c
index|]
index|[
name|i
index|]
operator|=
name|operands_match_p
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|c
index|]
argument_list|,
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* An operand may not match itself.  */
if|if
condition|(
name|c
operator|==
name|i
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If C can be commuted with C+1, and C might need to match I, 		 then C+1 might also need to match I.  */
if|if
condition|(
name|commutative
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|commutative
operator|||
name|c
operator|==
name|commutative
operator|+
literal|1
condition|)
block|{
name|int
name|other
init|=
name|c
operator|+
operator|(
name|c
operator|==
name|commutative
condition|?
literal|1
else|:
operator|-
literal|1
operator|)
decl_stmt|;
name|operands_match
index|[
name|other
index|]
index|[
name|i
index|]
operator|=
name|operands_match_p
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|other
index|]
argument_list|,
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|commutative
operator|||
name|i
operator|==
name|commutative
operator|+
literal|1
condition|)
block|{
name|int
name|other
init|=
name|i
operator|+
operator|(
name|i
operator|==
name|commutative
condition|?
literal|1
else|:
operator|-
literal|1
operator|)
decl_stmt|;
name|operands_match
index|[
name|c
index|]
index|[
name|other
index|]
operator|=
name|operands_match_p
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|c
index|]
argument_list|,
name|recog_data
operator|.
name|operand
index|[
name|other
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Note that C is supposed to be less than I. 		     No need to consider altering both C and I because in 		     that case we would alter one into the other.  */
block|}
block|}
block|}
block|}
comment|/* Examine each operand that is a memory reference or memory address      and reload parts of the addresses into index registers.      Also here any references to pseudo regs that didn't get hard regs      but are equivalent to constants get replaced in the insn itself      with those constants.  Nobody will ever see them again.       Finally, set up the preferred classes of each operand.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|noperands
condition|;
name|i
operator|++
control|)
block|{
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|address_reloaded
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|operand_type
index|[
name|i
index|]
operator|=
operator|(
name|modified
index|[
name|i
index|]
operator|==
name|RELOAD_READ
condition|?
name|RELOAD_FOR_INPUT
else|:
name|modified
index|[
name|i
index|]
operator|==
name|RELOAD_WRITE
condition|?
name|RELOAD_FOR_OUTPUT
else|:
name|RELOAD_OTHER
operator|)
expr_stmt|;
name|address_type
index|[
name|i
index|]
operator|=
operator|(
name|modified
index|[
name|i
index|]
operator|==
name|RELOAD_READ
condition|?
name|RELOAD_FOR_INPUT_ADDRESS
else|:
name|modified
index|[
name|i
index|]
operator|==
name|RELOAD_WRITE
condition|?
name|RELOAD_FOR_OUTPUT_ADDRESS
else|:
name|RELOAD_OTHER
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|constraints
index|[
name|i
index|]
operator|==
literal|0
condition|)
comment|/* Ignore things like match_operator operands.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|constraints
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'p'
condition|)
block|{
name|find_reloads_address
argument_list|(
name|recog_data
operator|.
name|operand_mode
index|[
name|i
index|]
argument_list|,
operator|(
name|rtx
operator|*
operator|)
literal|0
argument_list|,
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|,
name|recog_data
operator|.
name|operand_loc
index|[
name|i
index|]
argument_list|,
name|i
argument_list|,
name|operand_type
index|[
name|i
index|]
argument_list|,
name|ind_levels
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* If we now have a simple operand where we used to have a 	     PLUS or MULT, re-recognize and try again.  */
if|if
condition|(
operator|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
operator|*
name|recog_data
operator|.
name|operand_loc
index|[
name|i
index|]
argument_list|)
argument_list|)
operator|==
literal|'o'
operator|||
name|GET_CODE
argument_list|(
operator|*
name|recog_data
operator|.
name|operand_loc
index|[
name|i
index|]
argument_list|)
operator|==
name|SUBREG
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
operator|==
name|MULT
operator|||
name|GET_CODE
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
operator|==
name|PLUS
operator|)
condition|)
block|{
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
name|retval
operator|=
name|find_reloads
argument_list|(
name|insn
argument_list|,
name|replace
argument_list|,
name|ind_levels
argument_list|,
name|live_known
argument_list|,
name|reload_reg_p
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
operator|=
operator|*
name|recog_data
operator|.
name|operand_loc
index|[
name|i
index|]
expr_stmt|;
name|substed_operand
index|[
name|i
index|]
operator|=
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|MEM
condition|)
block|{
name|address_reloaded
index|[
name|i
index|]
operator|=
name|find_reloads_address
argument_list|(
name|GET_MODE
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
argument_list|,
name|recog_data
operator|.
name|operand_loc
index|[
name|i
index|]
argument_list|,
name|XEXP
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|XEXP
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
name|i
argument_list|,
name|address_type
index|[
name|i
index|]
argument_list|,
name|ind_levels
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
operator|=
operator|*
name|recog_data
operator|.
name|operand_loc
index|[
name|i
index|]
expr_stmt|;
name|substed_operand
index|[
name|i
index|]
operator|=
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|SUBREG
condition|)
block|{
name|rtx
name|reg
init|=
name|SUBREG_REG
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|rtx
name|op
init|=
name|find_reloads_toplev
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|,
name|i
argument_list|,
name|address_type
index|[
name|i
index|]
argument_list|,
name|ind_levels
argument_list|,
name|set
operator|!=
literal|0
operator|&&
operator|&
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|==
name|recog_data
operator|.
name|operand_loc
index|[
name|i
index|]
argument_list|,
name|insn
argument_list|,
operator|&
name|address_reloaded
index|[
name|i
index|]
argument_list|)
decl_stmt|;
comment|/* If we made a MEM to load (a part of) the stackslot of a pseudo 	     that didn't get a hard register, emit a USE with a REG_EQUAL 	     note in front so that we might inherit a previous, possibly 	     wider reload.  */
if|if
condition|(
name|replace
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|>=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|)
condition|)
name|set_unique_reg_note
argument_list|(
name|emit_insn_before
argument_list|(
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|)
argument_list|,
name|insn
argument_list|)
argument_list|,
name|REG_EQUAL
argument_list|,
name|reg_equiv_memory_loc
index|[
name|REGNO
argument_list|(
name|reg
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|substed_operand
index|[
name|i
index|]
operator|=
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
operator|=
name|op
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|PLUS
operator|||
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'1'
condition|)
comment|/* We can get a PLUS as an "operand" as a result of register 	   elimination.  See eliminate_regs and gen_reload.  We handle 	   a unary operator by reloading the operand.  */
name|substed_operand
index|[
name|i
index|]
operator|=
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
operator|=
name|find_reloads_toplev
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|,
name|i
argument_list|,
name|address_type
index|[
name|i
index|]
argument_list|,
name|ind_levels
argument_list|,
literal|0
argument_list|,
name|insn
argument_list|,
operator|&
name|address_reloaded
index|[
name|i
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|REG
condition|)
block|{
comment|/* This is equivalent to calling find_reloads_toplev. 	     The code is duplicated for speed. 	     When we find a pseudo always equivalent to a constant, 	     we replace it by the constant.  We must be sure, however, 	     that we don't try to replace it in the insn in which it 	     is being set.  */
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|reg_equiv_constant
index|[
name|regno
index|]
operator|!=
literal|0
operator|&&
operator|(
name|set
operator|==
literal|0
operator|||
operator|&
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|!=
name|recog_data
operator|.
name|operand_loc
index|[
name|i
index|]
operator|)
condition|)
block|{
comment|/* Record the existing mode so that the check if constants are 		 allowed will work when operand_mode isn't specified.  */
if|if
condition|(
name|operand_mode
index|[
name|i
index|]
operator|==
name|VOIDmode
condition|)
name|operand_mode
index|[
name|i
index|]
operator|=
name|GET_MODE
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|substed_operand
index|[
name|i
index|]
operator|=
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
operator|=
name|reg_equiv_constant
index|[
name|regno
index|]
expr_stmt|;
block|}
if|if
condition|(
name|reg_equiv_memory_loc
index|[
name|regno
index|]
operator|!=
literal|0
operator|&&
operator|(
name|reg_equiv_address
index|[
name|regno
index|]
operator|!=
literal|0
operator|||
name|num_not_at_initial_offset
operator|)
condition|)
comment|/* We need not give a valid is_set_dest argument since the case 	       of a constant equivalence was checked above.  */
name|substed_operand
index|[
name|i
index|]
operator|=
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
operator|=
name|find_reloads_toplev
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|,
name|i
argument_list|,
name|address_type
index|[
name|i
index|]
argument_list|,
name|ind_levels
argument_list|,
literal|0
argument_list|,
name|insn
argument_list|,
operator|&
name|address_reloaded
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* If the operand is still a register (we didn't replace it with an 	 equivalent), get the preferred class to reload it into.  */
name|code
operator|=
name|GET_CODE
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|preferred_class
index|[
name|i
index|]
operator|=
operator|(
operator|(
name|code
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
condition|?
name|reg_preferred_class
argument_list|(
name|REGNO
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
argument_list|)
else|:
name|NO_REGS
operator|)
expr_stmt|;
name|pref_or_nothing
index|[
name|i
index|]
operator|=
operator|(
name|code
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|reg_alternate_class
argument_list|(
name|REGNO
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
argument_list|)
operator|==
name|NO_REGS
operator|)
expr_stmt|;
block|}
comment|/* If this is simply a copy from operand 1 to operand 0, merge the      preferred classes for the operands.  */
if|if
condition|(
name|set
operator|!=
literal|0
operator|&&
name|noperands
operator|>=
literal|2
operator|&&
name|recog_data
operator|.
name|operand
index|[
literal|0
index|]
operator|==
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|&&
name|recog_data
operator|.
name|operand
index|[
literal|1
index|]
operator|==
name|SET_SRC
argument_list|(
name|set
argument_list|)
condition|)
block|{
name|preferred_class
index|[
literal|0
index|]
operator|=
name|preferred_class
index|[
literal|1
index|]
operator|=
name|reg_class_subunion
index|[
operator|(
name|int
operator|)
name|preferred_class
index|[
literal|0
index|]
index|]
index|[
operator|(
name|int
operator|)
name|preferred_class
index|[
literal|1
index|]
index|]
expr_stmt|;
name|pref_or_nothing
index|[
literal|0
index|]
operator||=
name|pref_or_nothing
index|[
literal|1
index|]
expr_stmt|;
name|pref_or_nothing
index|[
literal|1
index|]
operator||=
name|pref_or_nothing
index|[
literal|0
index|]
expr_stmt|;
block|}
comment|/* Now see what we need for pseudo-regs that didn't get hard regs      or got the wrong kind of hard reg.  For this, we must consider      all the operands together against the register constraints.  */
name|best
operator|=
name|MAX_RECOG_OPERANDS
operator|*
literal|2
operator|+
literal|600
expr_stmt|;
name|swapped
operator|=
literal|0
expr_stmt|;
name|goal_alternative_swapped
operator|=
literal|0
expr_stmt|;
name|try_swapped
label|:
comment|/* The constraints are made of several alternatives.      Each operand's constraint looks like foo,bar,... with commas      separating the alternatives.  The first alternatives for all      operands go together, the second alternatives go together, etc.       First loop over alternatives.  */
for|for
control|(
name|this_alternative_number
operator|=
literal|0
init|;
name|this_alternative_number
operator|<
name|n_alternatives
condition|;
name|this_alternative_number
operator|++
control|)
block|{
comment|/* Loop over operands for one constraint alternative.  */
comment|/* LOSERS counts those that don't fit this alternative 	 and would require loading.  */
name|int
name|losers
init|=
literal|0
decl_stmt|;
comment|/* BAD is set to 1 if it some operand can't fit this alternative 	 even after reloading.  */
name|int
name|bad
init|=
literal|0
decl_stmt|;
comment|/* REJECT is a count of how undesirable this alternative says it is 	 if any reloading is required.  If the alternative matches exactly 	 then REJECT is ignored, but otherwise it gets this much 	 counted against it in addition to the reloading needed.  Each 	 ? counts three times here since we want the disparaging caused by 	 a bad register class to only count 1/3 as much.  */
name|int
name|reject
init|=
literal|0
decl_stmt|;
name|this_earlyclobber
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|noperands
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|p
init|=
name|constraints
index|[
name|i
index|]
decl_stmt|;
name|int
name|win
init|=
literal|0
decl_stmt|;
name|int
name|did_match
init|=
literal|0
decl_stmt|;
comment|/* 0 => this operand can be reloaded somehow for this alternative.  */
name|int
name|badop
init|=
literal|1
decl_stmt|;
comment|/* 0 => this operand can be reloaded if the alternative allows regs.  */
name|int
name|winreg
init|=
literal|0
decl_stmt|;
name|int
name|c
decl_stmt|;
name|rtx
name|operand
init|=
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
comment|/* Nonzero means this is a MEM that must be reloaded into a reg 	     regardless of what the constraint says.  */
name|int
name|force_reload
init|=
literal|0
decl_stmt|;
name|int
name|offmemok
init|=
literal|0
decl_stmt|;
comment|/* Nonzero if a constant forced into memory would be OK for this 	     operand.  */
name|int
name|constmemok
init|=
literal|0
decl_stmt|;
name|int
name|earlyclobber
init|=
literal|0
decl_stmt|;
comment|/* If the predicate accepts a unary operator, it means that 	     we need to reload the operand, but do not do this for 	     match_operator and friends.  */
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|operand
argument_list|)
argument_list|)
operator|==
literal|'1'
operator|&&
operator|*
name|p
operator|!=
literal|0
condition|)
name|operand
operator|=
name|XEXP
argument_list|(
name|operand
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If the operand is a SUBREG, extract 	     the REG or MEM (or maybe even a constant) within. 	     (Constants can occur as a result of reg_equiv_constant.)  */
while|while
condition|(
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
comment|/* Offset only matters when operand is a REG and 		 it is a hard reg.  This is because it is passed 		 to reg_fits_class_p if it is a REG and all pseudos 		 return 0 from that function.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|operand
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|operand
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|offset
operator|+=
name|subreg_regno_offset
argument_list|(
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|operand
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|operand
argument_list|)
argument_list|)
argument_list|,
name|SUBREG_BYTE
argument_list|(
name|operand
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|operand
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|operand
operator|=
name|SUBREG_REG
argument_list|(
name|operand
argument_list|)
expr_stmt|;
comment|/* Force reload if this is a constant or PLUS or if there may 		 be a problem accessing OPERAND in the outer mode.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|operand
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|PLUS
comment|/* We must force a reload of paradoxical SUBREGs 		     of a MEM because the alignment of the inner value 		     may not be enough to do the outer reference.  On 		     big-endian machines, it may also reference outside 		     the object.  		     On machines that extend byte operations and we have a 		     SUBREG where both the inner and outer modes are no wider 		     than a word and the inner mode is narrower, is integral, 		     and gets extended when loaded from memory, combine.c has 		     made assumptions about the behavior of the machine in such 		     register access.  If the data is, in fact, in memory we 		     must always load using the size assumed to be in the 		     register and let the insn do the different-sized 		     accesses.  		     This is doubly true if WORD_REGISTER_OPERATIONS.  In 		     this case eliminate_regs has left non-paradoxical 		     subregs for push_reloads to see.  Make sure it does 		     by forcing the reload.  		     ??? When is it right at this stage to have a subreg 		     of a mem that is _not_ to be handled specialy?  IMO 		     those should have been reduced to just a mem.  */
operator|||
operator|(
operator|(
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|MEM
operator|||
operator|(
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|operand
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|)
ifndef|#
directive|ifndef
name|WORD_REGISTER_OPERATIONS
operator|&&
operator|(
operator|(
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|operand
argument_list|)
argument_list|)
operator|<
name|BIGGEST_ALIGNMENT
operator|)
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|operand_mode
index|[
name|i
index|]
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|operand
argument_list|)
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|MEM
operator|&&
name|BYTES_BIG_ENDIAN
operator|)
ifdef|#
directive|ifdef
name|LOAD_EXTEND_OP
operator|||
operator|(
name|GET_MODE_SIZE
argument_list|(
name|operand_mode
index|[
name|i
index|]
argument_list|)
operator|<=
name|UNITS_PER_WORD
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|operand
argument_list|)
argument_list|)
operator|<=
name|UNITS_PER_WORD
operator|)
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|operand_mode
index|[
name|i
index|]
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|operand
argument_list|)
argument_list|)
operator|)
operator|&&
name|INTEGRAL_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|operand
argument_list|)
argument_list|)
operator|&&
name|LOAD_EXTEND_OP
argument_list|(
name|GET_MODE
argument_list|(
name|operand
argument_list|)
argument_list|)
operator|!=
name|NIL
operator|)
endif|#
directive|endif
operator|)
endif|#
directive|endif
operator|)
comment|/* This following hunk of code should no longer be 		     needed at all with SUBREG_BYTE.  If you need this 		     code back, please explain to me why so I can 		     fix the real problem.  -DaveM */
if|#
directive|if
literal|0
comment|/* Subreg of a hard reg which can't handle the subreg's mode 		     or which would handle that mode in the wrong number of 		     registers for subregging to work.  */
condition||| (GET_CODE (operand) == REG&& REGNO (operand)< FIRST_PSEUDO_REGISTER&& ((GET_MODE_SIZE (operand_mode[i])<= UNITS_PER_WORD&& (GET_MODE_SIZE (GET_MODE (operand))> UNITS_PER_WORD)&& ((GET_MODE_SIZE (GET_MODE (operand)) 				/ UNITS_PER_WORD) 			       != HARD_REGNO_NREGS (REGNO (operand), 						    GET_MODE (operand)))) 			  || ! HARD_REGNO_MODE_OK (REGNO (operand) + offset, 						   operand_mode[i])))
endif|#
directive|endif
condition|)
name|force_reload
operator|=
literal|1
expr_stmt|;
block|}
name|this_alternative
index|[
name|i
index|]
operator|=
operator|(
name|int
operator|)
name|NO_REGS
expr_stmt|;
name|this_alternative_win
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|this_alternative_match_win
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|this_alternative_offmemok
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|this_alternative_earlyclobber
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|this_alternative_matches
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* An empty constraint or empty alternative 	     allows anything which matched the pattern.  */
if|if
condition|(
operator|*
name|p
operator|==
literal|0
operator|||
operator|*
name|p
operator|==
literal|','
condition|)
name|win
operator|=
literal|1
operator|,
name|badop
operator|=
literal|0
expr_stmt|;
comment|/* Scan this alternative's specs for this operand; 	     set WIN if the operand fits any letter in this alternative. 	     Otherwise, clear BADOP if this operand could 	     fit some letter after reloads, 	     or set WINREG if this operand could fit after reloads 	     provided the constraint allows some registers.  */
while|while
condition|(
operator|*
name|p
operator|&&
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|','
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'='
case|:
case|case
literal|'+'
case|:
case|case
literal|'*'
case|:
break|break;
case|case
literal|'%'
case|:
comment|/* The last operand should not be marked commutative.  */
if|if
condition|(
name|i
operator|!=
name|noperands
operator|-
literal|1
condition|)
name|commutative
operator|=
name|i
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
name|reject
operator|+=
literal|6
expr_stmt|;
break|break;
case|case
literal|'!'
case|:
name|reject
operator|=
literal|600
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
comment|/* Ignore rest of this alternative as far as 		   reloading is concerned.  */
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|','
condition|)
name|p
operator|++
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|c
operator|=
name|strtoul
argument_list|(
name|p
operator|-
literal|1
argument_list|,
operator|&
name|p
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|this_alternative_matches
index|[
name|i
index|]
operator|=
name|c
expr_stmt|;
comment|/* We are supposed to match a previous operand. 		   If we do, we win if that one did. 		   If we do not, count both of the operands as losers. 		   (This is too conservative, since most of the time 		   only a single reload insn will be needed to make 		   the two operands win.  As a result, this alternative 		   may be rejected when it is actually desirable.)  */
if|if
condition|(
operator|(
name|swapped
operator|&&
operator|(
name|c
operator|!=
name|commutative
operator|||
name|i
operator|!=
name|commutative
operator|+
literal|1
operator|)
operator|)
comment|/* If we are matching as if two operands were swapped, 		       also pretend that operands_match had been computed 		       with swapped. 		       But if I is the second of those and C is the first, 		       don't exchange them, because operands_match is valid 		       only on one side of its diagonal.  */
condition|?
operator|(
name|operands_match
index|[
operator|(
name|c
operator|==
name|commutative
operator|||
name|c
operator|==
name|commutative
operator|+
literal|1
operator|)
condition|?
literal|2
operator|*
name|commutative
operator|+
literal|1
operator|-
name|c
else|:
name|c
index|]
index|[
operator|(
name|i
operator|==
name|commutative
operator|||
name|i
operator|==
name|commutative
operator|+
literal|1
operator|)
condition|?
literal|2
operator|*
name|commutative
operator|+
literal|1
operator|-
name|i
else|:
name|i
index|]
operator|)
else|:
name|operands_match
index|[
name|c
index|]
index|[
name|i
index|]
condition|)
block|{
comment|/* If we are matching a non-offsettable address where an 		       offsettable address was expected, then we must reject 		       this combination, because we can't reload it.  */
if|if
condition|(
name|this_alternative_offmemok
index|[
name|c
index|]
operator|&&
name|GET_CODE
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|c
index|]
argument_list|)
operator|==
name|MEM
operator|&&
name|this_alternative
index|[
name|c
index|]
operator|==
operator|(
name|int
operator|)
name|NO_REGS
operator|&&
operator|!
name|this_alternative_win
index|[
name|c
index|]
condition|)
name|bad
operator|=
literal|1
expr_stmt|;
name|did_match
operator|=
name|this_alternative_win
index|[
name|c
index|]
expr_stmt|;
block|}
else|else
block|{
comment|/* Operands don't match.  */
name|rtx
name|value
decl_stmt|;
comment|/* Retroactively mark the operand we had to match 		       as a loser, if it wasn't already.  */
if|if
condition|(
name|this_alternative_win
index|[
name|c
index|]
condition|)
name|losers
operator|++
expr_stmt|;
name|this_alternative_win
index|[
name|c
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|this_alternative
index|[
name|c
index|]
operator|==
operator|(
name|int
operator|)
name|NO_REGS
condition|)
name|bad
operator|=
literal|1
expr_stmt|;
comment|/* But count the pair only once in the total badness of 		       this alternative, if the pair can be a dummy reload.  */
name|value
operator|=
name|find_dummy_reload
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|,
name|recog_data
operator|.
name|operand
index|[
name|c
index|]
argument_list|,
name|recog_data
operator|.
name|operand_loc
index|[
name|i
index|]
argument_list|,
name|recog_data
operator|.
name|operand_loc
index|[
name|c
index|]
argument_list|,
name|operand_mode
index|[
name|i
index|]
argument_list|,
name|operand_mode
index|[
name|c
index|]
argument_list|,
name|this_alternative
index|[
name|c
index|]
argument_list|,
operator|-
literal|1
argument_list|,
name|this_alternative_earlyclobber
index|[
name|c
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
name|losers
operator|--
expr_stmt|;
block|}
comment|/* This can be fixed with reloads if the operand 		   we are supposed to match can be fixed with reloads.  */
name|badop
operator|=
literal|0
expr_stmt|;
name|this_alternative
index|[
name|i
index|]
operator|=
name|this_alternative
index|[
name|c
index|]
expr_stmt|;
comment|/* If we have to reload this operand and some previous 		   operand also had to match the same thing as this 		   operand, we don't know how to do that.  So reject this 		   alternative.  */
if|if
condition|(
operator|!
name|did_match
operator|||
name|force_reload
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|this_alternative_matches
index|[
name|j
index|]
operator|==
name|this_alternative_matches
index|[
name|i
index|]
condition|)
name|badop
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
comment|/* All necessary reloads for an address_operand 		   were handled in find_reloads_address.  */
name|this_alternative
index|[
name|i
index|]
operator|=
operator|(
name|int
operator|)
name|MODE_BASE_REG_CLASS
argument_list|(
name|VOIDmode
argument_list|)
expr_stmt|;
name|win
operator|=
literal|1
expr_stmt|;
name|badop
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
if|if
condition|(
name|force_reload
condition|)
break|break;
if|if
condition|(
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|MEM
operator|||
operator|(
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|operand
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|reg_renumber
index|[
name|REGNO
argument_list|(
name|operand
argument_list|)
index|]
operator|<
literal|0
operator|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|operand
argument_list|)
comment|/* force_const_mem does not accept HIGH.  */
operator|&&
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|!=
name|HIGH
condition|)
name|badop
operator|=
literal|0
expr_stmt|;
name|constmemok
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|address_reloaded
index|[
name|i
index|]
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|operand
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_DEC
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|operand
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|POST_DEC
operator|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|address_reloaded
index|[
name|i
index|]
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|operand
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_INC
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|operand
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|POST_INC
operator|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* Memory operand whose address is not offsettable.  */
case|case
literal|'V'
case|:
if|if
condition|(
name|force_reload
condition|)
break|break;
if|if
condition|(
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
operator|(
name|ind_levels
condition|?
name|offsettable_memref_p
argument_list|(
name|operand
argument_list|)
else|:
name|offsettable_nonstrict_memref_p
argument_list|(
name|operand
argument_list|)
operator|)
comment|/* Certain mem addresses will become offsettable 		       after they themselves are reloaded.  This is important; 		       we don't want our own handling of unoffsettables 		       to override the handling of reg_equiv_address.  */
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|operand
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|ind_levels
operator|==
literal|0
operator|||
name|reg_equiv_address
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|operand
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
operator|!=
literal|0
operator|)
operator|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* Memory operand whose address is offsettable.  */
case|case
literal|'o'
case|:
if|if
condition|(
name|force_reload
condition|)
break|break;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|MEM
comment|/* If IND_LEVELS, find_reloads_address won't reload a 			pseudo that didn't get a hard reg, so we have to 			reject that case.  */
operator|&&
operator|(
operator|(
name|ind_levels
condition|?
name|offsettable_memref_p
argument_list|(
name|operand
argument_list|)
else|:
name|offsettable_nonstrict_memref_p
argument_list|(
name|operand
argument_list|)
operator|)
comment|/* A reloaded address is offsettable because it is now 			    just a simple register indirect.  */
operator|||
name|address_reloaded
index|[
name|i
index|]
operator|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|operand
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|reg_renumber
index|[
name|REGNO
argument_list|(
name|operand
argument_list|)
index|]
operator|<
literal|0
comment|/* If reg_equiv_address is nonzero, we will be 			   loading it into a register; hence it will be 			   offsettable, but we cannot say that reg_equiv_mem 			   is offsettable without checking.  */
operator|&&
operator|(
operator|(
name|reg_equiv_mem
index|[
name|REGNO
argument_list|(
name|operand
argument_list|)
index|]
operator|!=
literal|0
operator|&&
name|offsettable_memref_p
argument_list|(
name|reg_equiv_mem
index|[
name|REGNO
argument_list|(
name|operand
argument_list|)
index|]
argument_list|)
operator|)
operator|||
operator|(
name|reg_equiv_address
index|[
name|REGNO
argument_list|(
name|operand
argument_list|)
index|]
operator|!=
literal|0
operator|)
operator|)
operator|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
comment|/* force_const_mem does not accept HIGH.  */
if|if
condition|(
operator|(
name|CONSTANT_P
argument_list|(
name|operand
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|!=
name|HIGH
operator|)
operator|||
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|MEM
condition|)
name|badop
operator|=
literal|0
expr_stmt|;
name|constmemok
operator|=
literal|1
expr_stmt|;
name|offmemok
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'&'
case|:
comment|/* Output operand that is stored before the need for the 		   input operands (and their index registers) is over.  */
name|earlyclobber
operator|=
literal|1
operator|,
name|this_earlyclobber
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
ifndef|#
directive|ifndef
name|REAL_ARITHMETIC
comment|/* Match any floating double constant, but only if 		   we can examine the bits of it reliably.  */
if|if
condition|(
operator|(
name|HOST_FLOAT_FORMAT
operator|!=
name|TARGET_FLOAT_FORMAT
operator|||
name|HOST_BITS_PER_WIDE_INT
operator|!=
name|BITS_PER_WORD
operator|)
operator|&&
name|GET_MODE
argument_list|(
name|operand
argument_list|)
operator|!=
name|VOIDmode
operator|&&
operator|!
name|flag_pretend_float
condition|)
break|break;
endif|#
directive|endif
if|if
condition|(
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
case|case
literal|'H'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|CONST_DOUBLE_OK_FOR_LETTER_P
argument_list|(
name|operand
argument_list|,
name|c
argument_list|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|CONST_INT
operator|||
operator|(
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE
argument_list|(
name|operand
argument_list|)
operator|==
name|VOIDmode
operator|)
condition|)
break|break;
case|case
literal|'i'
case|:
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|operand
argument_list|)
ifdef|#
directive|ifdef
name|LEGITIMATE_PIC_OPERAND_P
operator|&&
operator|(
operator|!
name|flag_pic
operator|||
name|LEGITIMATE_PIC_OPERAND_P
argument_list|(
name|operand
argument_list|)
operator|)
endif|#
directive|endif
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|CONST_INT
operator|||
operator|(
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE
argument_list|(
name|operand
argument_list|)
operator|==
name|VOIDmode
operator|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
case|case
literal|'J'
case|:
case|case
literal|'K'
case|:
case|case
literal|'L'
case|:
case|case
literal|'M'
case|:
case|case
literal|'N'
case|:
case|case
literal|'O'
case|:
case|case
literal|'P'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|INTVAL
argument_list|(
name|operand
argument_list|)
argument_list|,
name|c
argument_list|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
name|win
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
if|if
condition|(
operator|!
name|force_reload
comment|/* A PLUS is never a valid operand, but reload can make 		       it from a register when eliminating registers.  */
operator|&&
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|!=
name|PLUS
comment|/* A SCRATCH is not a valid operand.  */
operator|&&
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|!=
name|SCRATCH
ifdef|#
directive|ifdef
name|LEGITIMATE_PIC_OPERAND_P
operator|&&
operator|(
operator|!
name|CONSTANT_P
argument_list|(
name|operand
argument_list|)
operator|||
operator|!
name|flag_pic
operator|||
name|LEGITIMATE_PIC_OPERAND_P
argument_list|(
name|operand
argument_list|)
operator|)
endif|#
directive|endif
operator|&&
operator|(
name|GENERAL_REGS
operator|==
name|ALL_REGS
operator|||
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|!=
name|REG
operator|||
operator|(
name|REGNO
argument_list|(
name|operand
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|reg_renumber
index|[
name|REGNO
argument_list|(
name|operand
argument_list|)
index|]
operator|<
literal|0
operator|)
operator|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
comment|/* Drop through into 'r' case.  */
case|case
literal|'r'
case|:
name|this_alternative
index|[
name|i
index|]
operator|=
operator|(
name|int
operator|)
name|reg_class_subunion
index|[
name|this_alternative
index|[
name|i
index|]
index|]
index|[
operator|(
name|int
operator|)
name|GENERAL_REGS
index|]
expr_stmt|;
goto|goto
name|reg
goto|;
default|default:
if|if
condition|(
name|REG_CLASS_FROM_LETTER
argument_list|(
name|c
argument_list|)
operator|==
name|NO_REGS
condition|)
block|{
ifdef|#
directive|ifdef
name|EXTRA_CONSTRAINT
if|if
condition|(
name|EXTRA_CONSTRAINT
argument_list|(
name|operand
argument_list|,
name|c
argument_list|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
name|this_alternative
index|[
name|i
index|]
operator|=
operator|(
name|int
operator|)
name|reg_class_subunion
index|[
name|this_alternative
index|[
name|i
index|]
index|]
index|[
operator|(
name|int
operator|)
name|REG_CLASS_FROM_LETTER
argument_list|(
name|c
argument_list|)
index|]
expr_stmt|;
name|reg
label|:
if|if
condition|(
name|GET_MODE
argument_list|(
name|operand
argument_list|)
operator|==
name|BLKmode
condition|)
break|break;
name|winreg
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|REG
operator|&&
name|reg_fits_class_p
argument_list|(
name|operand
argument_list|,
name|this_alternative
index|[
name|i
index|]
argument_list|,
name|offset
argument_list|,
name|GET_MODE
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
argument_list|)
condition|)
name|win
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|constraints
index|[
name|i
index|]
operator|=
name|p
expr_stmt|;
comment|/* If this operand could be handled with a reg, 	     and some reg is allowed, then this operand can be handled.  */
if|if
condition|(
name|winreg
operator|&&
name|this_alternative
index|[
name|i
index|]
operator|!=
operator|(
name|int
operator|)
name|NO_REGS
condition|)
name|badop
operator|=
literal|0
expr_stmt|;
comment|/* Record which operands fit this alternative.  */
name|this_alternative_earlyclobber
index|[
name|i
index|]
operator|=
name|earlyclobber
expr_stmt|;
if|if
condition|(
name|win
operator|&&
operator|!
name|force_reload
condition|)
name|this_alternative_win
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|did_match
operator|&&
operator|!
name|force_reload
condition|)
name|this_alternative_match_win
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|int
name|const_to_mem
init|=
literal|0
decl_stmt|;
name|this_alternative_offmemok
index|[
name|i
index|]
operator|=
name|offmemok
expr_stmt|;
name|losers
operator|++
expr_stmt|;
if|if
condition|(
name|badop
condition|)
name|bad
operator|=
literal|1
expr_stmt|;
comment|/* Alternative loses if it has no regs for a reg operand.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|REG
operator|&&
name|this_alternative
index|[
name|i
index|]
operator|==
operator|(
name|int
operator|)
name|NO_REGS
operator|&&
name|this_alternative_matches
index|[
name|i
index|]
operator|<
literal|0
condition|)
name|bad
operator|=
literal|1
expr_stmt|;
comment|/* If this is a constant that is reloaded into the desired 		 class by copying it to memory first, count that as another 		 reload.  This is consistent with other code and is 		 required to avoid choosing another alternative when 		 the constant is moved into memory by this function on 		 an early reload pass.  Note that the test here is 		 precisely the same as in the code below that calls 		 force_const_mem.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|operand
argument_list|)
comment|/* force_const_mem does not accept HIGH.  */
operator|&&
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|!=
name|HIGH
operator|&&
operator|(
operator|(
name|PREFERRED_RELOAD_CLASS
argument_list|(
name|operand
argument_list|,
operator|(
expr|enum
name|reg_class
operator|)
name|this_alternative
index|[
name|i
index|]
argument_list|)
operator|==
name|NO_REGS
operator|)
operator|||
name|no_input_reloads
operator|)
operator|&&
name|operand_mode
index|[
name|i
index|]
operator|!=
name|VOIDmode
condition|)
block|{
name|const_to_mem
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|this_alternative
index|[
name|i
index|]
operator|!=
operator|(
name|int
operator|)
name|NO_REGS
condition|)
name|losers
operator|++
expr_stmt|;
block|}
comment|/* If we can't reload this value at all, reject this 		 alternative.  Note that we could also lose due to 		 LIMIT_RELOAD_RELOAD_CLASS, but we don't check that 		 here.  */
if|if
condition|(
operator|!
name|CONSTANT_P
argument_list|(
name|operand
argument_list|)
operator|&&
operator|(
expr|enum
name|reg_class
operator|)
name|this_alternative
index|[
name|i
index|]
operator|!=
name|NO_REGS
operator|&&
operator|(
name|PREFERRED_RELOAD_CLASS
argument_list|(
name|operand
argument_list|,
operator|(
expr|enum
name|reg_class
operator|)
name|this_alternative
index|[
name|i
index|]
argument_list|)
operator|==
name|NO_REGS
operator|)
condition|)
name|bad
operator|=
literal|1
expr_stmt|;
comment|/* Alternative loses if it requires a type of reload not 		 permitted for this insn.  We can always reload SCRATCH 		 and objects with a REG_UNUSED note.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|!=
name|SCRATCH
operator|&&
name|modified
index|[
name|i
index|]
operator|!=
name|RELOAD_READ
operator|&&
name|no_output_reloads
operator|&&
operator|!
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_UNUSED
argument_list|,
name|operand
argument_list|)
condition|)
name|bad
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|modified
index|[
name|i
index|]
operator|!=
name|RELOAD_WRITE
operator|&&
name|no_input_reloads
operator|&&
operator|!
name|const_to_mem
condition|)
name|bad
operator|=
literal|1
expr_stmt|;
comment|/* We prefer to reload pseudos over reloading other things, 		 since such reloads may be able to be eliminated later. 		 If we are reloading a SCRATCH, we won't be generating any 		 insns, just using a register, so it is also preferred. 		 So bump REJECT in other cases.  Don't do this in the 		 case where we are forcing a constant into memory and 		 it will then win since we don't want to have a different 		 alternative match then.  */
if|if
condition|(
operator|!
operator|(
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|operand
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|!=
name|SCRATCH
operator|&&
operator|!
operator|(
name|const_to_mem
operator|&&
name|constmemok
operator|)
condition|)
name|reject
operator|+=
literal|2
expr_stmt|;
comment|/* Input reloads can be inherited more often than output 		 reloads can be removed, so penalize output reloads.  */
if|if
condition|(
name|operand_type
index|[
name|i
index|]
operator|!=
name|RELOAD_FOR_INPUT
operator|&&
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|!=
name|SCRATCH
condition|)
name|reject
operator|++
expr_stmt|;
block|}
comment|/* If this operand is a pseudo register that didn't get a hard 	     reg and this alternative accepts some register, see if the 	     class that we want is a subset of the preferred class for this 	     register.  If not, but it intersects that class, use the 	     preferred class instead.  If it does not intersect the preferred 	     class, show that usage of this alternative should be discouraged; 	     it will be discouraged more still if the register is `preferred 	     or nothing'.  We do this because it increases the chance of 	     reusing our spill register in a later insn and avoiding a pair 	     of memory stores and loads.  	     Don't bother with this if this alternative will accept this 	     operand.  	     Don't do this for a multiword operand, since it is only a 	     small win and has the risk of requiring more spill registers, 	     which could cause a large loss.  	     Don't do this if the preferred class has only one register 	     because we might otherwise exhaust the class.  */
if|if
condition|(
operator|!
name|win
operator|&&
operator|!
name|did_match
operator|&&
name|this_alternative
index|[
name|i
index|]
operator|!=
operator|(
name|int
operator|)
name|NO_REGS
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|operand_mode
index|[
name|i
index|]
argument_list|)
operator|<=
name|UNITS_PER_WORD
operator|&&
name|reg_class_size
index|[
operator|(
name|int
operator|)
name|preferred_class
index|[
name|i
index|]
index|]
operator|>
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|reg_class_subset_p
argument_list|(
name|this_alternative
index|[
name|i
index|]
argument_list|,
name|preferred_class
index|[
name|i
index|]
argument_list|)
condition|)
block|{
comment|/* Since we don't have a way of forming the intersection, 		     we just do something special if the preferred class 		     is a subset of the class we have; that's the most 		     common case anyway.  */
if|if
condition|(
name|reg_class_subset_p
argument_list|(
name|preferred_class
index|[
name|i
index|]
argument_list|,
name|this_alternative
index|[
name|i
index|]
argument_list|)
condition|)
name|this_alternative
index|[
name|i
index|]
operator|=
operator|(
name|int
operator|)
name|preferred_class
index|[
name|i
index|]
expr_stmt|;
else|else
name|reject
operator|+=
operator|(
literal|2
operator|+
literal|2
operator|*
name|pref_or_nothing
index|[
name|i
index|]
operator|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Now see if any output operands that are marked "earlyclobber" 	 in this alternative conflict with any input operands 	 or any memory addresses.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|noperands
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|this_alternative_earlyclobber
index|[
name|i
index|]
operator|&&
operator|(
name|this_alternative_win
index|[
name|i
index|]
operator|||
name|this_alternative_match_win
index|[
name|i
index|]
operator|)
condition|)
block|{
name|struct
name|decomposition
name|early_data
decl_stmt|;
name|early_data
operator|=
name|decompose
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|modified
index|[
name|i
index|]
operator|==
name|RELOAD_READ
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|this_alternative
index|[
name|i
index|]
operator|==
name|NO_REGS
condition|)
block|{
name|this_alternative_earlyclobber
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|this_insn_is_asm
condition|)
name|error_for_asm
argument_list|(
name|this_insn
argument_list|,
literal|"`&' constraint used with no register class"
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|noperands
condition|;
name|j
operator|++
control|)
comment|/* Is this an input operand or a memory ref?  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|j
index|]
argument_list|)
operator|==
name|MEM
operator|||
name|modified
index|[
name|j
index|]
operator|!=
name|RELOAD_WRITE
operator|)
operator|&&
name|j
operator|!=
name|i
comment|/* Ignore things like match_operator operands.  */
operator|&&
operator|*
name|recog_data
operator|.
name|constraints
index|[
name|j
index|]
operator|!=
literal|0
comment|/* Don't count an input operand that is constrained to match 		     the early clobber operand.  */
operator|&&
operator|!
operator|(
name|this_alternative_matches
index|[
name|j
index|]
operator|==
name|i
operator|&&
name|rtx_equal_p
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|,
name|recog_data
operator|.
name|operand
index|[
name|j
index|]
argument_list|)
operator|)
comment|/* Is it altered by storing the earlyclobber operand?  */
operator|&&
operator|!
name|immune_p
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|j
index|]
argument_list|,
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|,
name|early_data
argument_list|)
condition|)
block|{
comment|/* If the output is in a single-reg class, 		     it's costly to reload it, so reload the input instead.  */
if|if
condition|(
name|reg_class_size
index|[
name|this_alternative
index|[
name|i
index|]
index|]
operator|==
literal|1
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|j
index|]
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|j
index|]
argument_list|)
operator|==
name|SUBREG
operator|)
condition|)
block|{
name|losers
operator|++
expr_stmt|;
name|this_alternative_win
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
name|this_alternative_match_win
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
break|break;
block|}
comment|/* If an earlyclobber operand conflicts with something, 	       it must be reloaded, so request this and count the cost.  */
if|if
condition|(
name|j
operator|!=
name|noperands
condition|)
block|{
name|losers
operator|++
expr_stmt|;
name|this_alternative_win
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|this_alternative_match_win
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|noperands
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|this_alternative_matches
index|[
name|j
index|]
operator|==
name|i
operator|&&
name|this_alternative_match_win
index|[
name|j
index|]
condition|)
block|{
name|this_alternative_win
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
name|this_alternative_match_win
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
name|losers
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/* If one alternative accepts all the operands, no reload required, 	 choose that alternative; don't consider the remaining ones.  */
if|if
condition|(
name|losers
operator|==
literal|0
condition|)
block|{
comment|/* Unswap these so that they are never swapped at `finish'.  */
if|if
condition|(
name|commutative
operator|>=
literal|0
condition|)
block|{
name|recog_data
operator|.
name|operand
index|[
name|commutative
index|]
operator|=
name|substed_operand
index|[
name|commutative
index|]
expr_stmt|;
name|recog_data
operator|.
name|operand
index|[
name|commutative
operator|+
literal|1
index|]
operator|=
name|substed_operand
index|[
name|commutative
operator|+
literal|1
index|]
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|noperands
condition|;
name|i
operator|++
control|)
block|{
name|goal_alternative_win
index|[
name|i
index|]
operator|=
name|this_alternative_win
index|[
name|i
index|]
expr_stmt|;
name|goal_alternative_match_win
index|[
name|i
index|]
operator|=
name|this_alternative_match_win
index|[
name|i
index|]
expr_stmt|;
name|goal_alternative
index|[
name|i
index|]
operator|=
name|this_alternative
index|[
name|i
index|]
expr_stmt|;
name|goal_alternative_offmemok
index|[
name|i
index|]
operator|=
name|this_alternative_offmemok
index|[
name|i
index|]
expr_stmt|;
name|goal_alternative_matches
index|[
name|i
index|]
operator|=
name|this_alternative_matches
index|[
name|i
index|]
expr_stmt|;
name|goal_alternative_earlyclobber
index|[
name|i
index|]
operator|=
name|this_alternative_earlyclobber
index|[
name|i
index|]
expr_stmt|;
block|}
name|goal_alternative_number
operator|=
name|this_alternative_number
expr_stmt|;
name|goal_alternative_swapped
operator|=
name|swapped
expr_stmt|;
name|goal_earlyclobber
operator|=
name|this_earlyclobber
expr_stmt|;
goto|goto
name|finish
goto|;
block|}
comment|/* REJECT, set by the ! and ? constraint characters and when a register 	 would be reloaded into a non-preferred class, discourages the use of 	 this alternative for a reload goal.  REJECT is incremented by six 	 for each ? and two for each non-preferred class.  */
name|losers
operator|=
name|losers
operator|*
literal|6
operator|+
name|reject
expr_stmt|;
comment|/* If this alternative can be made to work by reloading, 	 and it needs less reloading than the others checked so far, 	 record it as the chosen goal for reloading.  */
if|if
condition|(
operator|!
name|bad
operator|&&
name|best
operator|>
name|losers
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|noperands
condition|;
name|i
operator|++
control|)
block|{
name|goal_alternative
index|[
name|i
index|]
operator|=
name|this_alternative
index|[
name|i
index|]
expr_stmt|;
name|goal_alternative_win
index|[
name|i
index|]
operator|=
name|this_alternative_win
index|[
name|i
index|]
expr_stmt|;
name|goal_alternative_match_win
index|[
name|i
index|]
operator|=
name|this_alternative_match_win
index|[
name|i
index|]
expr_stmt|;
name|goal_alternative_offmemok
index|[
name|i
index|]
operator|=
name|this_alternative_offmemok
index|[
name|i
index|]
expr_stmt|;
name|goal_alternative_matches
index|[
name|i
index|]
operator|=
name|this_alternative_matches
index|[
name|i
index|]
expr_stmt|;
name|goal_alternative_earlyclobber
index|[
name|i
index|]
operator|=
name|this_alternative_earlyclobber
index|[
name|i
index|]
expr_stmt|;
block|}
name|goal_alternative_swapped
operator|=
name|swapped
expr_stmt|;
name|best
operator|=
name|losers
expr_stmt|;
name|goal_alternative_number
operator|=
name|this_alternative_number
expr_stmt|;
name|goal_earlyclobber
operator|=
name|this_earlyclobber
expr_stmt|;
block|}
block|}
comment|/* If insn is commutative (it's safe to exchange a certain pair of operands)      then we need to try each alternative twice,      the second time matching those two operands      as if we had exchanged them.      To do this, really exchange them in operands.       If we have just tried the alternatives the second time,      return operands to normal and drop through.  */
if|if
condition|(
name|commutative
operator|>=
literal|0
condition|)
block|{
name|swapped
operator|=
operator|!
name|swapped
expr_stmt|;
if|if
condition|(
name|swapped
condition|)
block|{
name|enum
name|reg_class
name|tclass
decl_stmt|;
name|int
name|t
decl_stmt|;
name|recog_data
operator|.
name|operand
index|[
name|commutative
index|]
operator|=
name|substed_operand
index|[
name|commutative
operator|+
literal|1
index|]
expr_stmt|;
name|recog_data
operator|.
name|operand
index|[
name|commutative
operator|+
literal|1
index|]
operator|=
name|substed_operand
index|[
name|commutative
index|]
expr_stmt|;
comment|/* Swap the duplicates too.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|recog_data
operator|.
name|n_dups
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|recog_data
operator|.
name|dup_num
index|[
name|i
index|]
operator|==
name|commutative
operator|||
name|recog_data
operator|.
name|dup_num
index|[
name|i
index|]
operator|==
name|commutative
operator|+
literal|1
condition|)
operator|*
name|recog_data
operator|.
name|dup_loc
index|[
name|i
index|]
operator|=
name|recog_data
operator|.
name|operand
index|[
operator|(
name|int
operator|)
name|recog_data
operator|.
name|dup_num
index|[
name|i
index|]
index|]
expr_stmt|;
name|tclass
operator|=
name|preferred_class
index|[
name|commutative
index|]
expr_stmt|;
name|preferred_class
index|[
name|commutative
index|]
operator|=
name|preferred_class
index|[
name|commutative
operator|+
literal|1
index|]
expr_stmt|;
name|preferred_class
index|[
name|commutative
operator|+
literal|1
index|]
operator|=
name|tclass
expr_stmt|;
name|t
operator|=
name|pref_or_nothing
index|[
name|commutative
index|]
expr_stmt|;
name|pref_or_nothing
index|[
name|commutative
index|]
operator|=
name|pref_or_nothing
index|[
name|commutative
operator|+
literal|1
index|]
expr_stmt|;
name|pref_or_nothing
index|[
name|commutative
operator|+
literal|1
index|]
operator|=
name|t
expr_stmt|;
name|memcpy
argument_list|(
name|constraints
argument_list|,
name|recog_data
operator|.
name|constraints
argument_list|,
name|noperands
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|try_swapped
goto|;
block|}
else|else
block|{
name|recog_data
operator|.
name|operand
index|[
name|commutative
index|]
operator|=
name|substed_operand
index|[
name|commutative
index|]
expr_stmt|;
name|recog_data
operator|.
name|operand
index|[
name|commutative
operator|+
literal|1
index|]
operator|=
name|substed_operand
index|[
name|commutative
operator|+
literal|1
index|]
expr_stmt|;
comment|/* Unswap the duplicates too.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|recog_data
operator|.
name|n_dups
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|recog_data
operator|.
name|dup_num
index|[
name|i
index|]
operator|==
name|commutative
operator|||
name|recog_data
operator|.
name|dup_num
index|[
name|i
index|]
operator|==
name|commutative
operator|+
literal|1
condition|)
operator|*
name|recog_data
operator|.
name|dup_loc
index|[
name|i
index|]
operator|=
name|recog_data
operator|.
name|operand
index|[
operator|(
name|int
operator|)
name|recog_data
operator|.
name|dup_num
index|[
name|i
index|]
index|]
expr_stmt|;
block|}
block|}
comment|/* The operands don't meet the constraints.      goal_alternative describes the alternative      that we could reach by reloading the fewest operands.      Reload so as to fit it.  */
if|if
condition|(
name|best
operator|==
name|MAX_RECOG_OPERANDS
operator|*
literal|2
operator|+
literal|600
condition|)
block|{
comment|/* No alternative works with reloads??  */
if|if
condition|(
name|insn_code_number
operator|>=
literal|0
condition|)
name|fatal_insn
argument_list|(
literal|"unable to generate reloads for:"
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|error_for_asm
argument_list|(
name|insn
argument_list|,
literal|"inconsistent operand constraints in an `asm'"
argument_list|)
expr_stmt|;
comment|/* Avoid further trouble with this insn.  */
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|n_reloads
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Jump to `finish' from above if all operands are valid already.      In that case, goal_alternative_win is all 1.  */
name|finish
label|:
comment|/* Right now, for any pair of operands I and J that are required to match,      with I< J,      goal_alternative_matches[J] is I.      Set up goal_alternative_matched as the inverse function:      goal_alternative_matched[I] = J.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|noperands
condition|;
name|i
operator|++
control|)
name|goal_alternative_matched
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|noperands
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|goal_alternative_win
index|[
name|i
index|]
operator|&&
name|goal_alternative_matches
index|[
name|i
index|]
operator|>=
literal|0
condition|)
name|goal_alternative_matched
index|[
name|goal_alternative_matches
index|[
name|i
index|]
index|]
operator|=
name|i
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|noperands
condition|;
name|i
operator|++
control|)
name|goal_alternative_win
index|[
name|i
index|]
operator||=
name|goal_alternative_match_win
index|[
name|i
index|]
expr_stmt|;
comment|/* If the best alternative is with operands 1 and 2 swapped,      consider them swapped before reporting the reloads.  Update the      operand numbers of any reloads already pushed.  */
if|if
condition|(
name|goal_alternative_swapped
condition|)
block|{
name|rtx
name|tem
decl_stmt|;
name|tem
operator|=
name|substed_operand
index|[
name|commutative
index|]
expr_stmt|;
name|substed_operand
index|[
name|commutative
index|]
operator|=
name|substed_operand
index|[
name|commutative
operator|+
literal|1
index|]
expr_stmt|;
name|substed_operand
index|[
name|commutative
operator|+
literal|1
index|]
operator|=
name|tem
expr_stmt|;
name|tem
operator|=
name|recog_data
operator|.
name|operand
index|[
name|commutative
index|]
expr_stmt|;
name|recog_data
operator|.
name|operand
index|[
name|commutative
index|]
operator|=
name|recog_data
operator|.
name|operand
index|[
name|commutative
operator|+
literal|1
index|]
expr_stmt|;
name|recog_data
operator|.
name|operand
index|[
name|commutative
operator|+
literal|1
index|]
operator|=
name|tem
expr_stmt|;
name|tem
operator|=
operator|*
name|recog_data
operator|.
name|operand_loc
index|[
name|commutative
index|]
expr_stmt|;
operator|*
name|recog_data
operator|.
name|operand_loc
index|[
name|commutative
index|]
operator|=
operator|*
name|recog_data
operator|.
name|operand_loc
index|[
name|commutative
operator|+
literal|1
index|]
expr_stmt|;
operator|*
name|recog_data
operator|.
name|operand_loc
index|[
name|commutative
operator|+
literal|1
index|]
operator|=
name|tem
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_reloads
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|rld
index|[
name|i
index|]
operator|.
name|opnum
operator|==
name|commutative
condition|)
name|rld
index|[
name|i
index|]
operator|.
name|opnum
operator|=
name|commutative
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|rld
index|[
name|i
index|]
operator|.
name|opnum
operator|==
name|commutative
operator|+
literal|1
condition|)
name|rld
index|[
name|i
index|]
operator|.
name|opnum
operator|=
name|commutative
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|noperands
condition|;
name|i
operator|++
control|)
block|{
name|operand_reloadnum
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* If this is an earlyclobber operand, we need to widen the scope. 	 The reload must remain valid from the start of the insn being 	 reloaded until after the operand is stored into its destination. 	 We approximate this with RELOAD_OTHER even though we know that we 	 do not conflict with RELOAD_FOR_INPUT_ADDRESS reloads.  	 One special case that is worth checking is when we have an 	 output that is earlyclobber but isn't used past the insn (typically 	 a SCRATCH).  In this case, we only need have the reload live 	 through the insn itself, but not for any of our input or output 	 reloads. 	 But we must not accidentally narrow the scope of an existing 	 RELOAD_OTHER reload - leave these alone.  	 In any case, anything needed to address this operand can remain 	 however they were previously categorized.  */
if|if
condition|(
name|goal_alternative_earlyclobber
index|[
name|i
index|]
operator|&&
name|operand_type
index|[
name|i
index|]
operator|!=
name|RELOAD_OTHER
condition|)
name|operand_type
index|[
name|i
index|]
operator|=
operator|(
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_UNUSED
argument_list|,
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
condition|?
name|RELOAD_FOR_INSN
else|:
name|RELOAD_OTHER
operator|)
expr_stmt|;
block|}
comment|/* Any constants that aren't allowed and can't be reloaded      into registers are here changed into memory references.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|noperands
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|goal_alternative_win
index|[
name|i
index|]
operator|&&
name|CONSTANT_P
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
comment|/* force_const_mem does not accept HIGH.  */
operator|&&
name|GET_CODE
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
operator|!=
name|HIGH
operator|&&
operator|(
operator|(
name|PREFERRED_RELOAD_CLASS
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|,
operator|(
expr|enum
name|reg_class
operator|)
name|goal_alternative
index|[
name|i
index|]
argument_list|)
operator|==
name|NO_REGS
operator|)
operator|||
name|no_input_reloads
operator|)
operator|&&
name|operand_mode
index|[
name|i
index|]
operator|!=
name|VOIDmode
condition|)
block|{
name|substed_operand
index|[
name|i
index|]
operator|=
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
operator|=
name|find_reloads_toplev
argument_list|(
name|force_const_mem
argument_list|(
name|operand_mode
index|[
name|i
index|]
argument_list|,
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
argument_list|,
name|i
argument_list|,
name|address_type
index|[
name|i
index|]
argument_list|,
name|ind_levels
argument_list|,
literal|0
argument_list|,
name|insn
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|alternative_allows_memconst
argument_list|(
name|recog_data
operator|.
name|constraints
index|[
name|i
index|]
argument_list|,
name|goal_alternative_number
argument_list|)
condition|)
name|goal_alternative_win
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Record the values of the earlyclobber operands for the caller.  */
if|if
condition|(
name|goal_earlyclobber
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|noperands
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|goal_alternative_earlyclobber
index|[
name|i
index|]
condition|)
name|reload_earlyclobbers
index|[
name|n_earlyclobbers
operator|++
index|]
operator|=
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
expr_stmt|;
comment|/* Now record reloads for all the operands that need them.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|noperands
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|goal_alternative_win
index|[
name|i
index|]
condition|)
block|{
comment|/* Operands that match previous ones have already been handled.  */
if|if
condition|(
name|goal_alternative_matches
index|[
name|i
index|]
operator|>=
literal|0
condition|)
empty_stmt|;
comment|/* Handle an operand with a nonoffsettable address 	   appearing where an offsettable address will do 	   by reloading the address into a base register.  	   ??? We can also do this when the operand is a register and 	   reg_equiv_mem is not offsettable, but this is a bit tricky, 	   so we don't bother with it.  It may not be worth doing.  */
elseif|else
if|if
condition|(
name|goal_alternative_matched
index|[
name|i
index|]
operator|==
operator|-
literal|1
operator|&&
name|goal_alternative_offmemok
index|[
name|i
index|]
operator|&&
name|GET_CODE
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|operand_reloadnum
index|[
name|i
index|]
operator|=
name|push_reload
argument_list|(
name|XEXP
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
operator|&
name|XEXP
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|(
name|rtx
operator|*
operator|)
literal|0
argument_list|,
name|MODE_BASE_REG_CLASS
argument_list|(
name|VOIDmode
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|i
argument_list|,
name|RELOAD_FOR_INPUT
argument_list|)
expr_stmt|;
name|rld
index|[
name|operand_reloadnum
index|[
name|i
index|]
index|]
operator|.
name|inc
operator|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If this operand is an output, we will have made any 	       reloads for its address as RELOAD_FOR_OUTPUT_ADDRESS, but 	       now we are treating part of the operand as an input, so 	       we must change these to RELOAD_FOR_INPUT_ADDRESS.  */
if|if
condition|(
name|modified
index|[
name|i
index|]
operator|==
name|RELOAD_WRITE
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_reloads
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|rld
index|[
name|j
index|]
operator|.
name|opnum
operator|==
name|i
condition|)
block|{
if|if
condition|(
name|rld
index|[
name|j
index|]
operator|.
name|when_needed
operator|==
name|RELOAD_FOR_OUTPUT_ADDRESS
condition|)
name|rld
index|[
name|j
index|]
operator|.
name|when_needed
operator|=
name|RELOAD_FOR_INPUT_ADDRESS
expr_stmt|;
elseif|else
if|if
condition|(
name|rld
index|[
name|j
index|]
operator|.
name|when_needed
operator|==
name|RELOAD_FOR_OUTADDR_ADDRESS
condition|)
name|rld
index|[
name|j
index|]
operator|.
name|when_needed
operator|=
name|RELOAD_FOR_INPADDR_ADDRESS
expr_stmt|;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|goal_alternative_matched
index|[
name|i
index|]
operator|==
operator|-
literal|1
condition|)
block|{
name|operand_reloadnum
index|[
name|i
index|]
operator|=
name|push_reload
argument_list|(
operator|(
name|modified
index|[
name|i
index|]
operator|!=
name|RELOAD_WRITE
condition|?
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
else|:
literal|0
operator|)
argument_list|,
operator|(
name|modified
index|[
name|i
index|]
operator|!=
name|RELOAD_READ
condition|?
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
else|:
literal|0
operator|)
argument_list|,
operator|(
name|modified
index|[
name|i
index|]
operator|!=
name|RELOAD_WRITE
condition|?
name|recog_data
operator|.
name|operand_loc
index|[
name|i
index|]
else|:
literal|0
operator|)
argument_list|,
operator|(
name|modified
index|[
name|i
index|]
operator|!=
name|RELOAD_READ
condition|?
name|recog_data
operator|.
name|operand_loc
index|[
name|i
index|]
else|:
literal|0
operator|)
argument_list|,
operator|(
expr|enum
name|reg_class
operator|)
name|goal_alternative
index|[
name|i
index|]
argument_list|,
operator|(
name|modified
index|[
name|i
index|]
operator|==
name|RELOAD_WRITE
condition|?
name|VOIDmode
else|:
name|operand_mode
index|[
name|i
index|]
operator|)
argument_list|,
operator|(
name|modified
index|[
name|i
index|]
operator|==
name|RELOAD_READ
condition|?
name|VOIDmode
else|:
name|operand_mode
index|[
name|i
index|]
operator|)
argument_list|,
operator|(
name|insn_code_number
operator|<
literal|0
condition|?
literal|0
else|:
name|insn_data
index|[
name|insn_code_number
index|]
operator|.
name|operand
index|[
name|i
index|]
operator|.
name|strict_low
operator|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|,
name|operand_type
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* In a matching pair of operands, one must be input only 	   and the other must be output only. 	   Pass the input operand as IN and the other as OUT.  */
elseif|else
if|if
condition|(
name|modified
index|[
name|i
index|]
operator|==
name|RELOAD_READ
operator|&&
name|modified
index|[
name|goal_alternative_matched
index|[
name|i
index|]
index|]
operator|==
name|RELOAD_WRITE
condition|)
block|{
name|operand_reloadnum
index|[
name|i
index|]
operator|=
name|push_reload
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|,
name|recog_data
operator|.
name|operand
index|[
name|goal_alternative_matched
index|[
name|i
index|]
index|]
argument_list|,
name|recog_data
operator|.
name|operand_loc
index|[
name|i
index|]
argument_list|,
name|recog_data
operator|.
name|operand_loc
index|[
name|goal_alternative_matched
index|[
name|i
index|]
index|]
argument_list|,
operator|(
expr|enum
name|reg_class
operator|)
name|goal_alternative
index|[
name|i
index|]
argument_list|,
name|operand_mode
index|[
name|i
index|]
argument_list|,
name|operand_mode
index|[
name|goal_alternative_matched
index|[
name|i
index|]
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|i
argument_list|,
name|RELOAD_OTHER
argument_list|)
expr_stmt|;
name|operand_reloadnum
index|[
name|goal_alternative_matched
index|[
name|i
index|]
index|]
operator|=
name|output_reloadnum
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|modified
index|[
name|i
index|]
operator|==
name|RELOAD_WRITE
operator|&&
name|modified
index|[
name|goal_alternative_matched
index|[
name|i
index|]
index|]
operator|==
name|RELOAD_READ
condition|)
block|{
name|operand_reloadnum
index|[
name|goal_alternative_matched
index|[
name|i
index|]
index|]
operator|=
name|push_reload
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|goal_alternative_matched
index|[
name|i
index|]
index|]
argument_list|,
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|,
name|recog_data
operator|.
name|operand_loc
index|[
name|goal_alternative_matched
index|[
name|i
index|]
index|]
argument_list|,
name|recog_data
operator|.
name|operand_loc
index|[
name|i
index|]
argument_list|,
operator|(
expr|enum
name|reg_class
operator|)
name|goal_alternative
index|[
name|i
index|]
argument_list|,
name|operand_mode
index|[
name|goal_alternative_matched
index|[
name|i
index|]
index|]
argument_list|,
name|operand_mode
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|i
argument_list|,
name|RELOAD_OTHER
argument_list|)
expr_stmt|;
name|operand_reloadnum
index|[
name|i
index|]
operator|=
name|output_reloadnum
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|insn_code_number
operator|>=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
else|else
block|{
name|error_for_asm
argument_list|(
name|insn
argument_list|,
literal|"inconsistent operand constraints in an `asm'"
argument_list|)
expr_stmt|;
comment|/* Avoid further trouble with this insn.  */
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|n_reloads
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|goal_alternative_matched
index|[
name|i
index|]
operator|<
literal|0
operator|&&
name|goal_alternative_matches
index|[
name|i
index|]
operator|<
literal|0
operator|&&
name|optimize
condition|)
block|{
comment|/* For each non-matching operand that's a MEM or a pseudo-register 	   that didn't get a hard register, make an optional reload. 	   This may get done even if the insn needs no reloads otherwise.  */
name|rtx
name|operand
init|=
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
decl_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|SUBREG
condition|)
name|operand
operator|=
name|SUBREG_REG
argument_list|(
name|operand
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|MEM
operator|||
operator|(
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|operand
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|)
comment|/* If this is only for an output, the optional reload would not 	       actually cause us to use a register now, just note that 	       something is stored here.  */
operator|&&
operator|(
operator|(
expr|enum
name|reg_class
operator|)
name|goal_alternative
index|[
name|i
index|]
operator|!=
name|NO_REGS
operator|||
name|modified
index|[
name|i
index|]
operator|==
name|RELOAD_WRITE
operator|)
operator|&&
operator|!
name|no_input_reloads
comment|/* An optional output reload might allow to delete INSN later. 	       We mustn't make in-out reloads on insns that are not permitted 	       output reloads. 	       If this is an asm, we can't delete it; we must not even call 	       push_reload for an optional output reload in this case, 	       because we can't be sure that the constraint allows a register, 	       and push_reload verifies the constraints for asms.  */
operator|&&
operator|(
name|modified
index|[
name|i
index|]
operator|==
name|RELOAD_READ
operator|||
operator|(
operator|!
name|no_output_reloads
operator|&&
operator|!
name|this_insn_is_asm
operator|)
operator|)
condition|)
name|operand_reloadnum
index|[
name|i
index|]
operator|=
name|push_reload
argument_list|(
operator|(
name|modified
index|[
name|i
index|]
operator|!=
name|RELOAD_WRITE
condition|?
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
else|:
literal|0
operator|)
argument_list|,
operator|(
name|modified
index|[
name|i
index|]
operator|!=
name|RELOAD_READ
condition|?
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
else|:
literal|0
operator|)
argument_list|,
operator|(
name|modified
index|[
name|i
index|]
operator|!=
name|RELOAD_WRITE
condition|?
name|recog_data
operator|.
name|operand_loc
index|[
name|i
index|]
else|:
literal|0
operator|)
argument_list|,
operator|(
name|modified
index|[
name|i
index|]
operator|!=
name|RELOAD_READ
condition|?
name|recog_data
operator|.
name|operand_loc
index|[
name|i
index|]
else|:
literal|0
operator|)
argument_list|,
operator|(
expr|enum
name|reg_class
operator|)
name|goal_alternative
index|[
name|i
index|]
argument_list|,
operator|(
name|modified
index|[
name|i
index|]
operator|==
name|RELOAD_WRITE
condition|?
name|VOIDmode
else|:
name|operand_mode
index|[
name|i
index|]
operator|)
argument_list|,
operator|(
name|modified
index|[
name|i
index|]
operator|==
name|RELOAD_READ
condition|?
name|VOIDmode
else|:
name|operand_mode
index|[
name|i
index|]
operator|)
argument_list|,
operator|(
name|insn_code_number
operator|<
literal|0
condition|?
literal|0
else|:
name|insn_data
index|[
name|insn_code_number
index|]
operator|.
name|operand
index|[
name|i
index|]
operator|.
name|strict_low
operator|)
argument_list|,
literal|1
argument_list|,
name|i
argument_list|,
name|operand_type
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* If a memory reference remains (either as a MEM or a pseudo that 	   did not get a hard register), yet we can't make an optional 	   reload, check if this is actually a pseudo register reference; 	   we then need to emit a USE and/or a CLOBBER so that reload 	   inheritance will do the right thing.  */
elseif|else
if|if
condition|(
name|replace
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|MEM
operator|||
operator|(
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|operand
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|reg_renumber
index|[
name|REGNO
argument_list|(
name|operand
argument_list|)
index|]
operator|<
literal|0
operator|)
operator|)
condition|)
block|{
name|operand
operator|=
operator|*
name|recog_data
operator|.
name|operand_loc
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|SUBREG
condition|)
name|operand
operator|=
name|SUBREG_REG
argument_list|(
name|operand
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|modified
index|[
name|i
index|]
operator|!=
name|RELOAD_WRITE
condition|)
comment|/* We mark the USE with QImode so that we recognize 		     it as one that can be safely deleted at the end 		     of reload.  */
name|PUT_MODE
argument_list|(
name|emit_insn_before
argument_list|(
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|operand
argument_list|)
argument_list|,
name|insn
argument_list|)
argument_list|,
name|QImode
argument_list|)
expr_stmt|;
if|if
condition|(
name|modified
index|[
name|i
index|]
operator|!=
name|RELOAD_READ
condition|)
name|emit_insn_after
argument_list|(
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|operand
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|goal_alternative_matches
index|[
name|i
index|]
operator|>=
literal|0
operator|&&
name|goal_alternative_win
index|[
name|goal_alternative_matches
index|[
name|i
index|]
index|]
operator|&&
name|modified
index|[
name|i
index|]
operator|==
name|RELOAD_READ
operator|&&
name|modified
index|[
name|goal_alternative_matches
index|[
name|i
index|]
index|]
operator|==
name|RELOAD_WRITE
operator|&&
operator|!
name|no_input_reloads
operator|&&
operator|!
name|no_output_reloads
operator|&&
name|optimize
condition|)
block|{
comment|/* Similarly, make an optional reload for a pair of matching 	   objects that are in MEM or a pseudo that didn't get a hard reg.  */
name|rtx
name|operand
init|=
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
decl_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|SUBREG
condition|)
name|operand
operator|=
name|SUBREG_REG
argument_list|(
name|operand
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|MEM
operator|||
operator|(
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|operand
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|)
operator|&&
operator|(
operator|(
expr|enum
name|reg_class
operator|)
name|goal_alternative
index|[
name|goal_alternative_matches
index|[
name|i
index|]
index|]
operator|!=
name|NO_REGS
operator|)
condition|)
name|operand_reloadnum
index|[
name|i
index|]
operator|=
name|operand_reloadnum
index|[
name|goal_alternative_matches
index|[
name|i
index|]
index|]
operator|=
name|push_reload
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|goal_alternative_matches
index|[
name|i
index|]
index|]
argument_list|,
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|,
name|recog_data
operator|.
name|operand_loc
index|[
name|goal_alternative_matches
index|[
name|i
index|]
index|]
argument_list|,
name|recog_data
operator|.
name|operand_loc
index|[
name|i
index|]
argument_list|,
operator|(
expr|enum
name|reg_class
operator|)
name|goal_alternative
index|[
name|goal_alternative_matches
index|[
name|i
index|]
index|]
argument_list|,
name|operand_mode
index|[
name|goal_alternative_matches
index|[
name|i
index|]
index|]
argument_list|,
name|operand_mode
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|goal_alternative_matches
index|[
name|i
index|]
argument_list|,
name|RELOAD_OTHER
argument_list|)
expr_stmt|;
block|}
comment|/* Perform whatever substitutions on the operands we are supposed      to make due to commutativity or replacement of registers      with equivalent constants or memory slots.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|noperands
condition|;
name|i
operator|++
control|)
block|{
comment|/* We only do this on the last pass through reload, because it is 	 possible for some data (like reg_equiv_address) to be changed during 	 later passes.  Moreover, we loose the opportunity to get a useful 	 reload_{in,out}_reg when we do these replacements.  */
if|if
condition|(
name|replace
condition|)
block|{
name|rtx
name|substitution
init|=
name|substed_operand
index|[
name|i
index|]
decl_stmt|;
operator|*
name|recog_data
operator|.
name|operand_loc
index|[
name|i
index|]
operator|=
name|substitution
expr_stmt|;
comment|/* If we're replacing an operand with a LABEL_REF, we need 	     to make sure that there's a REG_LABEL note attached to 	     this instruction.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|substitution
argument_list|)
operator|==
name|LABEL_REF
operator|&&
operator|!
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_LABEL
argument_list|,
name|XEXP
argument_list|(
name|substitution
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_INSN_LIST
argument_list|(
name|REG_LABEL
argument_list|,
name|XEXP
argument_list|(
name|substitution
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|retval
operator||=
operator|(
name|substed_operand
index|[
name|i
index|]
operator|!=
operator|*
name|recog_data
operator|.
name|operand_loc
index|[
name|i
index|]
operator|)
expr_stmt|;
block|}
comment|/* If this insn pattern contains any MATCH_DUP's, make sure that      they will be substituted if the operands they match are substituted.      Also do now any substitutions we already did on the operands.       Don't do this if we aren't making replacements because we might be      propagating things allocated by frame pointer elimination into places      it doesn't expect.  */
if|if
condition|(
name|insn_code_number
operator|>=
literal|0
operator|&&
name|replace
condition|)
for|for
control|(
name|i
operator|=
name|insn_data
index|[
name|insn_code_number
index|]
operator|.
name|n_dups
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|int
name|opno
init|=
name|recog_data
operator|.
name|dup_num
index|[
name|i
index|]
decl_stmt|;
operator|*
name|recog_data
operator|.
name|dup_loc
index|[
name|i
index|]
operator|=
operator|*
name|recog_data
operator|.
name|operand_loc
index|[
name|opno
index|]
expr_stmt|;
if|if
condition|(
name|operand_reloadnum
index|[
name|opno
index|]
operator|>=
literal|0
condition|)
name|push_replacement
argument_list|(
name|recog_data
operator|.
name|dup_loc
index|[
name|i
index|]
argument_list|,
name|operand_reloadnum
index|[
name|opno
index|]
argument_list|,
name|insn_data
index|[
name|insn_code_number
index|]
operator|.
name|operand
index|[
name|opno
index|]
operator|.
name|mode
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* This loses because reloading of prior insns can invalidate the equivalence      (or at least find_equiv_reg isn't smart enough to find it any more),      causing this insn to need more reload regs than it needed before.      It may be too late to make the reload regs available.      Now this optimization is done safely in choose_reload_regs.  */
comment|/* For each reload of a reg into some other class of reg,      search for an existing equivalent reg (same value now) in the right class.      We can use it as long as we don't need to change its contents.  */
block|for (i = 0; i< n_reloads; i++)     if (rld[i].reg_rtx == 0&& rld[i].in != 0&& GET_CODE (rld[i].in) == REG&& rld[i].out == 0)       { 	rld[i].reg_rtx 	  = find_equiv_reg (rld[i].in, insn, rld[i].class, -1, 			    static_reload_reg_p, 0, rld[i].inmode);
comment|/* Prevent generation of insn to load the value 	   because the one we found already has the value.  */
block|if (rld[i].reg_rtx) 	  rld[i].in = rld[i].reg_rtx;       }
endif|#
directive|endif
comment|/* Perhaps an output reload can be combined with another      to reduce needs by one.  */
if|if
condition|(
operator|!
name|goal_earlyclobber
condition|)
name|combine_reloads
argument_list|()
expr_stmt|;
comment|/* If we have a pair of reloads for parts of an address, they are reloading      the same object, the operands themselves were not reloaded, and they      are for two operands that are supposed to match, merge the reloads and      change the type of the surviving reload to RELOAD_FOR_OPERAND_ADDRESS.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_reloads
condition|;
name|i
operator|++
control|)
block|{
name|int
name|k
decl_stmt|;
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|n_reloads
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|(
name|rld
index|[
name|i
index|]
operator|.
name|when_needed
operator|==
name|RELOAD_FOR_INPUT_ADDRESS
operator|||
name|rld
index|[
name|i
index|]
operator|.
name|when_needed
operator|==
name|RELOAD_FOR_OUTPUT_ADDRESS
operator|||
name|rld
index|[
name|i
index|]
operator|.
name|when_needed
operator|==
name|RELOAD_FOR_INPADDR_ADDRESS
operator|||
name|rld
index|[
name|i
index|]
operator|.
name|when_needed
operator|==
name|RELOAD_FOR_OUTADDR_ADDRESS
operator|)
operator|&&
operator|(
name|rld
index|[
name|j
index|]
operator|.
name|when_needed
operator|==
name|RELOAD_FOR_INPUT_ADDRESS
operator|||
name|rld
index|[
name|j
index|]
operator|.
name|when_needed
operator|==
name|RELOAD_FOR_OUTPUT_ADDRESS
operator|||
name|rld
index|[
name|j
index|]
operator|.
name|when_needed
operator|==
name|RELOAD_FOR_INPADDR_ADDRESS
operator|||
name|rld
index|[
name|j
index|]
operator|.
name|when_needed
operator|==
name|RELOAD_FOR_OUTADDR_ADDRESS
operator|)
operator|&&
name|rtx_equal_p
argument_list|(
name|rld
index|[
name|i
index|]
operator|.
name|in
argument_list|,
name|rld
index|[
name|j
index|]
operator|.
name|in
argument_list|)
operator|&&
operator|(
name|operand_reloadnum
index|[
name|rld
index|[
name|i
index|]
operator|.
name|opnum
index|]
operator|<
literal|0
operator|||
name|rld
index|[
name|operand_reloadnum
index|[
name|rld
index|[
name|i
index|]
operator|.
name|opnum
index|]
index|]
operator|.
name|optional
operator|)
operator|&&
operator|(
name|operand_reloadnum
index|[
name|rld
index|[
name|j
index|]
operator|.
name|opnum
index|]
operator|<
literal|0
operator|||
name|rld
index|[
name|operand_reloadnum
index|[
name|rld
index|[
name|j
index|]
operator|.
name|opnum
index|]
index|]
operator|.
name|optional
operator|)
operator|&&
operator|(
name|goal_alternative_matches
index|[
name|rld
index|[
name|i
index|]
operator|.
name|opnum
index|]
operator|==
name|rld
index|[
name|j
index|]
operator|.
name|opnum
operator|||
operator|(
name|goal_alternative_matches
index|[
name|rld
index|[
name|j
index|]
operator|.
name|opnum
index|]
operator|==
name|rld
index|[
name|i
index|]
operator|.
name|opnum
operator|)
operator|)
condition|)
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|n_replacements
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|replacements
index|[
name|k
index|]
operator|.
name|what
operator|==
name|j
condition|)
name|replacements
index|[
name|k
index|]
operator|.
name|what
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|rld
index|[
name|i
index|]
operator|.
name|when_needed
operator|==
name|RELOAD_FOR_INPADDR_ADDRESS
operator|||
name|rld
index|[
name|i
index|]
operator|.
name|when_needed
operator|==
name|RELOAD_FOR_OUTADDR_ADDRESS
condition|)
name|rld
index|[
name|i
index|]
operator|.
name|when_needed
operator|=
name|RELOAD_FOR_OPADDR_ADDR
expr_stmt|;
else|else
name|rld
index|[
name|i
index|]
operator|.
name|when_needed
operator|=
name|RELOAD_FOR_OPERAND_ADDRESS
expr_stmt|;
name|rld
index|[
name|j
index|]
operator|.
name|in
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Scan all the reloads and update their type.      If a reload is for the address of an operand and we didn't reload      that operand, change the type.  Similarly, change the operand number      of a reload when two operands match.  If a reload is optional, treat it      as though the operand isn't reloaded.       ??? This latter case is somewhat odd because if we do the optional      reload, it means the object is hanging around.  Thus we need only      do the address reload if the optional reload was NOT done.       Change secondary reloads to be the address type of their operand, not      the normal type.       If an operand's reload is now RELOAD_OTHER, change any      RELOAD_FOR_INPUT_ADDRESS reloads of that operand to      RELOAD_FOR_OTHER_ADDRESS.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_reloads
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|rld
index|[
name|i
index|]
operator|.
name|secondary_p
operator|&&
name|rld
index|[
name|i
index|]
operator|.
name|when_needed
operator|==
name|operand_type
index|[
name|rld
index|[
name|i
index|]
operator|.
name|opnum
index|]
condition|)
name|rld
index|[
name|i
index|]
operator|.
name|when_needed
operator|=
name|address_type
index|[
name|rld
index|[
name|i
index|]
operator|.
name|opnum
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|rld
index|[
name|i
index|]
operator|.
name|when_needed
operator|==
name|RELOAD_FOR_INPUT_ADDRESS
operator|||
name|rld
index|[
name|i
index|]
operator|.
name|when_needed
operator|==
name|RELOAD_FOR_OUTPUT_ADDRESS
operator|||
name|rld
index|[
name|i
index|]
operator|.
name|when_needed
operator|==
name|RELOAD_FOR_INPADDR_ADDRESS
operator|||
name|rld
index|[
name|i
index|]
operator|.
name|when_needed
operator|==
name|RELOAD_FOR_OUTADDR_ADDRESS
operator|)
operator|&&
operator|(
name|operand_reloadnum
index|[
name|rld
index|[
name|i
index|]
operator|.
name|opnum
index|]
operator|<
literal|0
operator|||
name|rld
index|[
name|operand_reloadnum
index|[
name|rld
index|[
name|i
index|]
operator|.
name|opnum
index|]
index|]
operator|.
name|optional
operator|)
condition|)
block|{
comment|/* If we have a secondary reload to go along with this reload, 	     change its type to RELOAD_FOR_OPADDR_ADDR.  */
if|if
condition|(
operator|(
name|rld
index|[
name|i
index|]
operator|.
name|when_needed
operator|==
name|RELOAD_FOR_INPUT_ADDRESS
operator|||
name|rld
index|[
name|i
index|]
operator|.
name|when_needed
operator|==
name|RELOAD_FOR_INPADDR_ADDRESS
operator|)
operator|&&
name|rld
index|[
name|i
index|]
operator|.
name|secondary_in_reload
operator|!=
operator|-
literal|1
condition|)
block|{
name|int
name|secondary_in_reload
init|=
name|rld
index|[
name|i
index|]
operator|.
name|secondary_in_reload
decl_stmt|;
name|rld
index|[
name|secondary_in_reload
index|]
operator|.
name|when_needed
operator|=
name|RELOAD_FOR_OPADDR_ADDR
expr_stmt|;
comment|/* If there's a tertiary reload we have to change it also.  */
if|if
condition|(
name|secondary_in_reload
operator|>
literal|0
operator|&&
name|rld
index|[
name|secondary_in_reload
index|]
operator|.
name|secondary_in_reload
operator|!=
operator|-
literal|1
condition|)
name|rld
index|[
name|rld
index|[
name|secondary_in_reload
index|]
operator|.
name|secondary_in_reload
index|]
operator|.
name|when_needed
operator|=
name|RELOAD_FOR_OPADDR_ADDR
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|rld
index|[
name|i
index|]
operator|.
name|when_needed
operator|==
name|RELOAD_FOR_OUTPUT_ADDRESS
operator|||
name|rld
index|[
name|i
index|]
operator|.
name|when_needed
operator|==
name|RELOAD_FOR_OUTADDR_ADDRESS
operator|)
operator|&&
name|rld
index|[
name|i
index|]
operator|.
name|secondary_out_reload
operator|!=
operator|-
literal|1
condition|)
block|{
name|int
name|secondary_out_reload
init|=
name|rld
index|[
name|i
index|]
operator|.
name|secondary_out_reload
decl_stmt|;
name|rld
index|[
name|secondary_out_reload
index|]
operator|.
name|when_needed
operator|=
name|RELOAD_FOR_OPADDR_ADDR
expr_stmt|;
comment|/* If there's a tertiary reload we have to change it also.  */
if|if
condition|(
name|secondary_out_reload
operator|&&
name|rld
index|[
name|secondary_out_reload
index|]
operator|.
name|secondary_out_reload
operator|!=
operator|-
literal|1
condition|)
name|rld
index|[
name|rld
index|[
name|secondary_out_reload
index|]
operator|.
name|secondary_out_reload
index|]
operator|.
name|when_needed
operator|=
name|RELOAD_FOR_OPADDR_ADDR
expr_stmt|;
block|}
if|if
condition|(
name|rld
index|[
name|i
index|]
operator|.
name|when_needed
operator|==
name|RELOAD_FOR_INPADDR_ADDRESS
operator|||
name|rld
index|[
name|i
index|]
operator|.
name|when_needed
operator|==
name|RELOAD_FOR_OUTADDR_ADDRESS
condition|)
name|rld
index|[
name|i
index|]
operator|.
name|when_needed
operator|=
name|RELOAD_FOR_OPADDR_ADDR
expr_stmt|;
else|else
name|rld
index|[
name|i
index|]
operator|.
name|when_needed
operator|=
name|RELOAD_FOR_OPERAND_ADDRESS
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|rld
index|[
name|i
index|]
operator|.
name|when_needed
operator|==
name|RELOAD_FOR_INPUT_ADDRESS
operator|||
name|rld
index|[
name|i
index|]
operator|.
name|when_needed
operator|==
name|RELOAD_FOR_INPADDR_ADDRESS
operator|)
operator|&&
name|operand_reloadnum
index|[
name|rld
index|[
name|i
index|]
operator|.
name|opnum
index|]
operator|>=
literal|0
operator|&&
operator|(
name|rld
index|[
name|operand_reloadnum
index|[
name|rld
index|[
name|i
index|]
operator|.
name|opnum
index|]
index|]
operator|.
name|when_needed
operator|==
name|RELOAD_OTHER
operator|)
condition|)
name|rld
index|[
name|i
index|]
operator|.
name|when_needed
operator|=
name|RELOAD_FOR_OTHER_ADDRESS
expr_stmt|;
if|if
condition|(
name|goal_alternative_matches
index|[
name|rld
index|[
name|i
index|]
operator|.
name|opnum
index|]
operator|>=
literal|0
condition|)
name|rld
index|[
name|i
index|]
operator|.
name|opnum
operator|=
name|goal_alternative_matches
index|[
name|rld
index|[
name|i
index|]
operator|.
name|opnum
index|]
expr_stmt|;
block|}
comment|/* Scan all the reloads, and check for RELOAD_FOR_OPERAND_ADDRESS reloads.      If we have more than one, then convert all RELOAD_FOR_OPADDR_ADDR      reloads to RELOAD_FOR_OPERAND_ADDRESS reloads.       choose_reload_regs assumes that RELOAD_FOR_OPADDR_ADDR reloads never      conflict with RELOAD_FOR_OPERAND_ADDRESS reloads.  This is true for a      single pair of RELOAD_FOR_OPADDR_ADDR/RELOAD_FOR_OPERAND_ADDRESS reloads.      However, if there is more than one RELOAD_FOR_OPERAND_ADDRESS reload,      then a RELOAD_FOR_OPADDR_ADDR reload conflicts with all      RELOAD_FOR_OPERAND_ADDRESS reloads other than the one that uses it.      This is complicated by the fact that a single operand can have more      than one RELOAD_FOR_OPERAND_ADDRESS reload.  It is very difficult to fix      choose_reload_regs without affecting code quality, and cases that      actually fail are extremely rare, so it turns out to be better to fix      the problem here by not generating cases that choose_reload_regs will      fail for.  */
comment|/* There is a similar problem with RELOAD_FOR_INPUT_ADDRESS /      RELOAD_FOR_OUTPUT_ADDRESS when there is more than one of a kind for      a single operand.      We can reduce the register pressure by exploiting that a      RELOAD_FOR_X_ADDR_ADDR that precedes all RELOAD_FOR_X_ADDRESS reloads      does not conflict with any of them, if it is only used for the first of      the RELOAD_FOR_X_ADDRESS reloads.  */
block|{
name|int
name|first_op_addr_num
init|=
operator|-
literal|2
decl_stmt|;
name|int
name|first_inpaddr_num
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|int
name|first_outpaddr_num
index|[
name|MAX_RECOG_OPERANDS
index|]
decl_stmt|;
name|int
name|need_change
init|=
literal|0
decl_stmt|;
comment|/* We use last_op_addr_reload and the contents of the above arrays        first as flags - -2 means no instance encountered, -1 means exactly        one instance encountered.        If more than one instance has been encountered, we store the reload        number of the first reload of the kind in question; reload numbers        are known to be non-negative.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|noperands
condition|;
name|i
operator|++
control|)
name|first_inpaddr_num
index|[
name|i
index|]
operator|=
name|first_outpaddr_num
index|[
name|i
index|]
operator|=
operator|-
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
name|n_reloads
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
switch|switch
condition|(
name|rld
index|[
name|i
index|]
operator|.
name|when_needed
condition|)
block|{
case|case
name|RELOAD_FOR_OPERAND_ADDRESS
case|:
if|if
condition|(
operator|++
name|first_op_addr_num
operator|>=
literal|0
condition|)
block|{
name|first_op_addr_num
operator|=
name|i
expr_stmt|;
name|need_change
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|RELOAD_FOR_INPUT_ADDRESS
case|:
if|if
condition|(
operator|++
name|first_inpaddr_num
index|[
name|rld
index|[
name|i
index|]
operator|.
name|opnum
index|]
operator|>=
literal|0
condition|)
block|{
name|first_inpaddr_num
index|[
name|rld
index|[
name|i
index|]
operator|.
name|opnum
index|]
operator|=
name|i
expr_stmt|;
name|need_change
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|RELOAD_FOR_OUTPUT_ADDRESS
case|:
if|if
condition|(
operator|++
name|first_outpaddr_num
index|[
name|rld
index|[
name|i
index|]
operator|.
name|opnum
index|]
operator|>=
literal|0
condition|)
block|{
name|first_outpaddr_num
index|[
name|rld
index|[
name|i
index|]
operator|.
name|opnum
index|]
operator|=
name|i
expr_stmt|;
name|need_change
operator|=
literal|1
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|need_change
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_reloads
condition|;
name|i
operator|++
control|)
block|{
name|int
name|first_num
decl_stmt|;
name|enum
name|reload_type
name|type
decl_stmt|;
switch|switch
condition|(
name|rld
index|[
name|i
index|]
operator|.
name|when_needed
condition|)
block|{
case|case
name|RELOAD_FOR_OPADDR_ADDR
case|:
name|first_num
operator|=
name|first_op_addr_num
expr_stmt|;
name|type
operator|=
name|RELOAD_FOR_OPERAND_ADDRESS
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_INPADDR_ADDRESS
case|:
name|first_num
operator|=
name|first_inpaddr_num
index|[
name|rld
index|[
name|i
index|]
operator|.
name|opnum
index|]
expr_stmt|;
name|type
operator|=
name|RELOAD_FOR_INPUT_ADDRESS
expr_stmt|;
break|break;
case|case
name|RELOAD_FOR_OUTADDR_ADDRESS
case|:
name|first_num
operator|=
name|first_outpaddr_num
index|[
name|rld
index|[
name|i
index|]
operator|.
name|opnum
index|]
expr_stmt|;
name|type
operator|=
name|RELOAD_FOR_OUTPUT_ADDRESS
expr_stmt|;
break|break;
default|default:
continue|continue;
block|}
if|if
condition|(
name|first_num
operator|<
literal|0
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|i
operator|>
name|first_num
condition|)
name|rld
index|[
name|i
index|]
operator|.
name|when_needed
operator|=
name|type
expr_stmt|;
else|else
block|{
comment|/* Check if the only TYPE reload that uses reload I is 		   reload FIRST_NUM.  */
for|for
control|(
name|j
operator|=
name|n_reloads
operator|-
literal|1
init|;
name|j
operator|>
name|first_num
condition|;
name|j
operator|--
control|)
block|{
if|if
condition|(
name|rld
index|[
name|j
index|]
operator|.
name|when_needed
operator|==
name|type
operator|&&
operator|(
name|rld
index|[
name|i
index|]
operator|.
name|secondary_p
condition|?
name|rld
index|[
name|j
index|]
operator|.
name|secondary_in_reload
operator|==
name|i
else|:
name|reg_mentioned_p
argument_list|(
name|rld
index|[
name|i
index|]
operator|.
name|in
argument_list|,
name|rld
index|[
name|j
index|]
operator|.
name|in
argument_list|)
operator|)
condition|)
block|{
name|rld
index|[
name|i
index|]
operator|.
name|when_needed
operator|=
name|type
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
block|}
comment|/* See if we have any reloads that are now allowed to be merged      because we've changed when the reload is needed to      RELOAD_FOR_OPERAND_ADDRESS or RELOAD_FOR_OTHER_ADDRESS.  Only      check for the most common cases.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_reloads
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|rld
index|[
name|i
index|]
operator|.
name|in
operator|!=
literal|0
operator|&&
name|rld
index|[
name|i
index|]
operator|.
name|out
operator|==
literal|0
operator|&&
operator|(
name|rld
index|[
name|i
index|]
operator|.
name|when_needed
operator|==
name|RELOAD_FOR_OPERAND_ADDRESS
operator|||
name|rld
index|[
name|i
index|]
operator|.
name|when_needed
operator|==
name|RELOAD_FOR_OPADDR_ADDR
operator|||
name|rld
index|[
name|i
index|]
operator|.
name|when_needed
operator|==
name|RELOAD_FOR_OTHER_ADDRESS
operator|)
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_reloads
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|i
operator|!=
name|j
operator|&&
name|rld
index|[
name|j
index|]
operator|.
name|in
operator|!=
literal|0
operator|&&
name|rld
index|[
name|j
index|]
operator|.
name|out
operator|==
literal|0
operator|&&
name|rld
index|[
name|j
index|]
operator|.
name|when_needed
operator|==
name|rld
index|[
name|i
index|]
operator|.
name|when_needed
operator|&&
name|MATCHES
argument_list|(
name|rld
index|[
name|i
index|]
operator|.
name|in
argument_list|,
name|rld
index|[
name|j
index|]
operator|.
name|in
argument_list|)
operator|&&
name|rld
index|[
name|i
index|]
operator|.
name|class
operator|==
name|rld
index|[
name|j
index|]
operator|.
name|class
operator|&&
operator|!
name|rld
index|[
name|i
index|]
operator|.
name|nocombine
operator|&&
operator|!
name|rld
index|[
name|j
index|]
operator|.
name|nocombine
operator|&&
name|rld
index|[
name|i
index|]
operator|.
name|reg_rtx
operator|==
name|rld
index|[
name|j
index|]
operator|.
name|reg_rtx
condition|)
block|{
name|rld
index|[
name|i
index|]
operator|.
name|opnum
operator|=
name|MIN
argument_list|(
name|rld
index|[
name|i
index|]
operator|.
name|opnum
argument_list|,
name|rld
index|[
name|j
index|]
operator|.
name|opnum
argument_list|)
expr_stmt|;
name|transfer_replacements
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|rld
index|[
name|j
index|]
operator|.
name|in
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* If we made any reloads for addresses, see if they violate a      "no input reloads" requirement for this insn.  But loads that we      do after the insn (such as for output addresses) are fine.  */
if|if
condition|(
name|no_input_reloads
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_reloads
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|rld
index|[
name|i
index|]
operator|.
name|in
operator|!=
literal|0
operator|&&
name|rld
index|[
name|i
index|]
operator|.
name|when_needed
operator|!=
name|RELOAD_FOR_OUTADDR_ADDRESS
operator|&&
name|rld
index|[
name|i
index|]
operator|.
name|when_needed
operator|!=
name|RELOAD_FOR_OUTPUT_ADDRESS
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* Compute reload_mode and reload_nregs.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_reloads
condition|;
name|i
operator|++
control|)
block|{
name|rld
index|[
name|i
index|]
operator|.
name|mode
operator|=
operator|(
name|rld
index|[
name|i
index|]
operator|.
name|inmode
operator|==
name|VOIDmode
operator|||
operator|(
name|GET_MODE_SIZE
argument_list|(
name|rld
index|[
name|i
index|]
operator|.
name|outmode
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|rld
index|[
name|i
index|]
operator|.
name|inmode
argument_list|)
operator|)
operator|)
condition|?
name|rld
index|[
name|i
index|]
operator|.
name|outmode
else|:
name|rld
index|[
name|i
index|]
operator|.
name|inmode
expr_stmt|;
name|rld
index|[
name|i
index|]
operator|.
name|nregs
operator|=
name|CLASS_MAX_NREGS
argument_list|(
name|rld
index|[
name|i
index|]
operator|.
name|class
argument_list|,
name|rld
index|[
name|i
index|]
operator|.
name|mode
argument_list|)
expr_stmt|;
block|}
comment|/* Special case a simple move with an input reload and a      destination of a hard reg, if the hard reg is ok, use it.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_reloads
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|rld
index|[
name|i
index|]
operator|.
name|when_needed
operator|==
name|RELOAD_FOR_INPUT
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|rld
index|[
name|i
index|]
operator|.
name|in
condition|)
block|{
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|dest
argument_list|)
decl_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
name|rld
index|[
name|i
index|]
operator|.
name|class
index|]
argument_list|,
name|regno
argument_list|)
operator|&&
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|rld
index|[
name|i
index|]
operator|.
name|mode
argument_list|)
condition|)
name|rld
index|[
name|i
index|]
operator|.
name|reg_rtx
operator|=
name|dest
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if alternative number ALTNUM in constraint-string CONSTRAINT    accepts a memory operand with constant address.  */
end_comment

begin_function
specifier|static
name|int
name|alternative_allows_memconst
parameter_list|(
name|constraint
parameter_list|,
name|altnum
parameter_list|)
specifier|const
name|char
modifier|*
name|constraint
decl_stmt|;
name|int
name|altnum
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
comment|/* Skip alternatives before the one requested.  */
while|while
condition|(
name|altnum
operator|>
literal|0
condition|)
block|{
while|while
condition|(
operator|*
name|constraint
operator|++
operator|!=
literal|','
condition|)
empty_stmt|;
name|altnum
operator|--
expr_stmt|;
block|}
comment|/* Scan the requested alternative for 'm' or 'o'.      If one of them is present, this alternative accepts memory constants.  */
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|constraint
operator|++
operator|)
operator|&&
name|c
operator|!=
literal|','
operator|&&
name|c
operator|!=
literal|'#'
condition|)
if|if
condition|(
name|c
operator|==
literal|'m'
operator|||
name|c
operator|==
literal|'o'
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Scan X for memory references and scan the addresses for reloading.    Also checks for references to "constant" regs that we want to eliminate    and replaces them with the values they stand for.    We may alter X destructively if it contains a reference to such.    If X is just a constant reg, we return the equivalent value    instead of X.     IND_LEVELS says how many levels of indirect addressing this machine    supports.     OPNUM and TYPE identify the purpose of the reload.     IS_SET_DEST is true if X is the destination of a SET, which is not    appropriate to be replaced by a constant.     INSN, if nonzero, is the insn in which we do the reload.  It is used    to determine if we may generate output reloads, and where to put USEs    for pseudos that we have to replace with stack slots.     ADDRESS_RELOADED.  If nonzero, is a pointer to where we put the    result of find_reloads_address.  */
end_comment

begin_function
specifier|static
name|rtx
name|find_reloads_toplev
parameter_list|(
name|x
parameter_list|,
name|opnum
parameter_list|,
name|type
parameter_list|,
name|ind_levels
parameter_list|,
name|is_set_dest
parameter_list|,
name|insn
parameter_list|,
name|address_reloaded
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|int
name|opnum
decl_stmt|;
name|enum
name|reload_type
name|type
decl_stmt|;
name|int
name|ind_levels
decl_stmt|;
name|int
name|is_set_dest
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
modifier|*
name|address_reloaded
decl_stmt|;
block|{
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
init|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|copied
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|REG
condition|)
block|{
comment|/* This code is duplicated for speed in find_reloads.  */
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|reg_equiv_constant
index|[
name|regno
index|]
operator|!=
literal|0
operator|&&
operator|!
name|is_set_dest
condition|)
name|x
operator|=
name|reg_equiv_constant
index|[
name|regno
index|]
expr_stmt|;
if|#
directive|if
literal|0
comment|/*  This creates (subreg (mem...)) which would cause an unnecessary 	  reload of the mem.  */
if|else if (reg_equiv_mem[regno] != 0) 	x = reg_equiv_mem[regno];
endif|#
directive|endif
elseif|else
if|if
condition|(
name|reg_equiv_memory_loc
index|[
name|regno
index|]
operator|&&
operator|(
name|reg_equiv_address
index|[
name|regno
index|]
operator|!=
literal|0
operator|||
name|num_not_at_initial_offset
operator|)
condition|)
block|{
name|rtx
name|mem
init|=
name|make_memloc
argument_list|(
name|x
argument_list|,
name|regno
argument_list|)
decl_stmt|;
if|if
condition|(
name|reg_equiv_address
index|[
name|regno
index|]
operator|||
operator|!
name|rtx_equal_p
argument_list|(
name|mem
argument_list|,
name|reg_equiv_mem
index|[
name|regno
index|]
argument_list|)
condition|)
block|{
comment|/* If this is not a toplevel operand, find_reloads doesn't see 		 this substitution.  We have to emit a USE of the pseudo so 		 that delete_output_reload can see it.  */
if|if
condition|(
name|replace_reloads
operator|&&
name|recog_data
operator|.
name|operand
index|[
name|opnum
index|]
operator|!=
name|x
condition|)
comment|/* We mark the USE with QImode so that we recognize it 		   as one that can be safely deleted at the end of 		   reload.  */
name|PUT_MODE
argument_list|(
name|emit_insn_before
argument_list|(
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|x
argument_list|)
argument_list|,
name|insn
argument_list|)
argument_list|,
name|QImode
argument_list|)
expr_stmt|;
name|x
operator|=
name|mem
expr_stmt|;
name|i
operator|=
name|find_reloads_address
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
operator|&
name|x
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|opnum
argument_list|,
name|type
argument_list|,
name|ind_levels
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|address_reloaded
condition|)
operator|*
name|address_reloaded
operator|=
name|i
expr_stmt|;
block|}
block|}
return|return
name|x
return|;
block|}
if|if
condition|(
name|code
operator|==
name|MEM
condition|)
block|{
name|rtx
name|tem
init|=
name|x
decl_stmt|;
name|i
operator|=
name|find_reloads_address
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
operator|&
name|tem
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|opnum
argument_list|,
name|type
argument_list|,
name|ind_levels
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|address_reloaded
condition|)
operator|*
name|address_reloaded
operator|=
name|i
expr_stmt|;
return|return
name|tem
return|;
block|}
if|if
condition|(
name|code
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
comment|/* Check for SUBREG containing a REG that's equivalent to a constant. 	 If the constant has a known value, truncate it right now. 	 Similarly if we are extracting a single-word of a multi-word 	 constant.  If the constant is symbolic, allow it to be substituted 	 normally.  push_reload will strip the subreg later.  If the 	 constant is VOIDmode, abort because we will lose the mode of 	 the register (this should never happen because one of the cases 	 above should handle it).  */
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
if|if
condition|(
name|subreg_lowpart_p
argument_list|(
name|x
argument_list|)
operator|&&
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|reg_renumber
index|[
name|regno
index|]
operator|<
literal|0
operator|&&
name|reg_equiv_constant
index|[
name|regno
index|]
operator|!=
literal|0
operator|&&
operator|(
name|tem
operator|=
name|gen_lowpart_common
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|reg_equiv_constant
index|[
name|regno
index|]
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|tem
return|;
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|reg_renumber
index|[
name|regno
index|]
operator|<
literal|0
operator|&&
name|reg_equiv_constant
index|[
name|regno
index|]
operator|!=
literal|0
condition|)
block|{
name|tem
operator|=
name|simplify_gen_subreg
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|reg_equiv_constant
index|[
name|regno
index|]
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|SUBREG_BYTE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tem
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|tem
return|;
block|}
comment|/* If the SUBREG is wider than a word, the above test will fail. 	 For example, we might have a SImode SUBREG of a DImode SUBREG_REG 	 for a 16 bit target, or a DImode SUBREG of a TImode SUBREG_REG for 	 a 32 bit target.  We still can - and have to - handle this 	 for non-paradoxical subregs of CONST_INTs.  */
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|reg_renumber
index|[
name|regno
index|]
operator|<
literal|0
operator|&&
name|reg_equiv_constant
index|[
name|regno
index|]
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|reg_equiv_constant
index|[
name|regno
index|]
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|int
name|shift
init|=
name|SUBREG_BYTE
argument_list|(
name|x
argument_list|)
operator|*
name|BITS_PER_UNIT
decl_stmt|;
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
name|shift
operator|=
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|-
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|-
name|shift
operator|)
expr_stmt|;
comment|/* Here we use the knowledge that CONST_INTs have a 	     HOST_WIDE_INT field.  */
if|if
condition|(
name|shift
operator|>=
name|HOST_BITS_PER_WIDE_INT
condition|)
name|shift
operator|=
name|HOST_BITS_PER_WIDE_INT
operator|-
literal|1
expr_stmt|;
return|return
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|reg_equiv_constant
index|[
name|regno
index|]
argument_list|)
operator|>>
name|shift
argument_list|)
return|;
block|}
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|reg_renumber
index|[
name|regno
index|]
operator|<
literal|0
operator|&&
name|reg_equiv_constant
index|[
name|regno
index|]
operator|!=
literal|0
operator|&&
name|GET_MODE
argument_list|(
name|reg_equiv_constant
index|[
name|regno
index|]
argument_list|)
operator|==
name|VOIDmode
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If the subreg contains a reg that will be converted to a mem, 	 convert the subreg to a narrower memref now. 	 Otherwise, we would get (subreg (mem ...) ...), 	 which would force reload of the mem.  	 We also need to do this if there is an equivalent MEM that is 	 not offsettable.  In that case, alter_subreg would produce an 	 invalid address on big-endian machines.  	 For machines that extend byte loads, we must not reload using 	 a wider mode if we have a paradoxical SUBREG.  find_reloads will 	 force a reload in that case.  So we should not do anything here.  */
elseif|else
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
ifdef|#
directive|ifdef
name|LOAD_EXTEND_OP
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|<=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|)
endif|#
directive|endif
operator|&&
operator|(
name|reg_equiv_address
index|[
name|regno
index|]
operator|!=
literal|0
operator|||
operator|(
name|reg_equiv_mem
index|[
name|regno
index|]
operator|!=
literal|0
operator|&&
operator|(
operator|!
name|strict_memory_address_p
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|reg_equiv_mem
index|[
name|regno
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
operator|!
name|offsettable_memref_p
argument_list|(
name|reg_equiv_mem
index|[
name|regno
index|]
argument_list|)
operator|||
name|num_not_at_initial_offset
operator|)
operator|)
operator|)
condition|)
name|x
operator|=
name|find_reloads_subreg_address
argument_list|(
name|x
argument_list|,
literal|1
argument_list|,
name|opnum
argument_list|,
name|type
argument_list|,
name|ind_levels
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|copied
operator|=
literal|0
operator|,
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
name|rtx
name|new_part
init|=
name|find_reloads_toplev
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|opnum
argument_list|,
name|type
argument_list|,
name|ind_levels
argument_list|,
name|is_set_dest
argument_list|,
name|insn
argument_list|,
name|address_reloaded
argument_list|)
decl_stmt|;
comment|/* If we have replaced a reg with it's equivalent memory loc - 	     that can still be handled here e.g. if it's in a paradoxical 	     subreg - we must make the change in a copy, rather than using 	     a destructive change.  This way, find_reloads can still elect 	     not to do the change.  */
if|if
condition|(
name|new_part
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|&&
operator|!
name|CONSTANT_P
argument_list|(
name|new_part
argument_list|)
operator|&&
operator|!
name|copied
condition|)
block|{
name|x
operator|=
name|shallow_copy_rtx
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|copied
operator|=
literal|1
expr_stmt|;
block|}
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|=
name|new_part
expr_stmt|;
block|}
block|}
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Return a mem ref for the memory equivalent of reg REGNO.    This mem ref is not shared with anything.  */
end_comment

begin_function
specifier|static
name|rtx
name|make_memloc
parameter_list|(
name|ad
parameter_list|,
name|regno
parameter_list|)
name|rtx
name|ad
decl_stmt|;
name|int
name|regno
decl_stmt|;
block|{
comment|/* We must rerun eliminate_regs, in case the elimination      offsets have changed.  */
name|rtx
name|tem
init|=
name|XEXP
argument_list|(
name|eliminate_regs
argument_list|(
name|reg_equiv_memory_loc
index|[
name|regno
index|]
argument_list|,
literal|0
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* If TEM might contain a pseudo, we must copy it to avoid      modifying it when we do the substitution for the reload.  */
if|if
condition|(
name|rtx_varies_p
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
condition|)
name|tem
operator|=
name|copy_rtx
argument_list|(
name|tem
argument_list|)
expr_stmt|;
name|tem
operator|=
name|replace_equiv_address_nv
argument_list|(
name|reg_equiv_memory_loc
index|[
name|regno
index|]
argument_list|,
name|tem
argument_list|)
expr_stmt|;
name|tem
operator|=
name|adjust_address_nv
argument_list|(
name|tem
argument_list|,
name|GET_MODE
argument_list|(
name|ad
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Copy the result if it's still the same as the equivalence, to avoid      modifying it when we do the substitution for the reload.  */
if|if
condition|(
name|tem
operator|==
name|reg_equiv_memory_loc
index|[
name|regno
index|]
condition|)
name|tem
operator|=
name|copy_rtx
argument_list|(
name|tem
argument_list|)
expr_stmt|;
return|return
name|tem
return|;
block|}
end_function

begin_comment
comment|/* Record all reloads needed for handling memory address AD    which appears in *LOC in a memory reference to mode MODE    which itself is found in location  *MEMREFLOC.    Note that we take shortcuts assuming that no multi-reg machine mode    occurs as part of an address.     OPNUM and TYPE specify the purpose of this reload.     IND_LEVELS says how many levels of indirect addressing this machine    supports.     INSN, if nonzero, is the insn in which we do the reload.  It is used    to determine if we may generate output reloads, and where to put USEs    for pseudos that we have to replace with stack slots.     Value is nonzero if this address is reloaded or replaced as a whole.    This is interesting to the caller if the address is an autoincrement.     Note that there is no verification that the address will be valid after    this routine does its work.  Instead, we rely on the fact that the address    was valid when reload started.  So we need only undo things that reload    could have broken.  These are wrong register types, pseudos not allocated    to a hard register, and frame pointer elimination.  */
end_comment

begin_function
specifier|static
name|int
name|find_reloads_address
parameter_list|(
name|mode
parameter_list|,
name|memrefloc
parameter_list|,
name|ad
parameter_list|,
name|loc
parameter_list|,
name|opnum
parameter_list|,
name|type
parameter_list|,
name|ind_levels
parameter_list|,
name|insn
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
modifier|*
name|memrefloc
decl_stmt|;
name|rtx
name|ad
decl_stmt|;
name|rtx
modifier|*
name|loc
decl_stmt|;
name|int
name|opnum
decl_stmt|;
name|enum
name|reload_type
name|type
decl_stmt|;
name|int
name|ind_levels
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|int
name|regno
decl_stmt|;
name|int
name|removed_and
init|=
literal|0
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
comment|/* If the address is a register, see if it is a legitimate address and      reload if not.  We first handle the cases where we need not reload      or where we must reload in a non-standard way.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|ad
argument_list|)
operator|==
name|REG
condition|)
block|{
name|regno
operator|=
name|REGNO
argument_list|(
name|ad
argument_list|)
expr_stmt|;
comment|/* If the register is equivalent to an invariant expression, substitute 	 the invariant, and eliminate any eliminable register references.  */
name|tem
operator|=
name|reg_equiv_constant
index|[
name|regno
index|]
expr_stmt|;
if|if
condition|(
name|tem
operator|!=
literal|0
operator|&&
operator|(
name|tem
operator|=
name|eliminate_regs
argument_list|(
name|tem
argument_list|,
name|mode
argument_list|,
name|insn
argument_list|)
operator|)
operator|&&
name|strict_memory_address_p
argument_list|(
name|mode
argument_list|,
name|tem
argument_list|)
condition|)
block|{
operator|*
name|loc
operator|=
name|ad
operator|=
name|tem
expr_stmt|;
return|return
literal|0
return|;
block|}
name|tem
operator|=
name|reg_equiv_memory_loc
index|[
name|regno
index|]
expr_stmt|;
if|if
condition|(
name|tem
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|reg_equiv_address
index|[
name|regno
index|]
operator|!=
literal|0
operator|||
name|num_not_at_initial_offset
condition|)
block|{
name|tem
operator|=
name|make_memloc
argument_list|(
name|ad
argument_list|,
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strict_memory_address_p
argument_list|(
name|GET_MODE
argument_list|(
name|tem
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|find_reloads_address
argument_list|(
name|GET_MODE
argument_list|(
name|tem
argument_list|)
argument_list|,
operator|(
name|rtx
operator|*
operator|)
literal|0
argument_list|,
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|opnum
argument_list|,
name|ADDR_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|ind_levels
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* We can avoid a reload if the register's equivalent memory 		 expression is valid as an indirect memory address. 		 But not all addresses are valid in a mem used as an indirect 		 address: only reg or reg+constant.  */
if|if
condition|(
name|ind_levels
operator|>
literal|0
operator|&&
name|strict_memory_address_p
argument_list|(
name|mode
argument_list|,
name|tem
argument_list|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
block|{
comment|/* TEM is not the same as what we'll be replacing the 		     pseudo with after reload, put a USE in front of INSN 		     in the final reload pass.  */
if|if
condition|(
name|replace_reloads
operator|&&
name|num_not_at_initial_offset
operator|&&
operator|!
name|rtx_equal_p
argument_list|(
name|tem
argument_list|,
name|reg_equiv_mem
index|[
name|regno
index|]
argument_list|)
condition|)
block|{
operator|*
name|loc
operator|=
name|tem
expr_stmt|;
comment|/* We mark the USE with QImode so that we 			 recognize it as one that can be safely 			 deleted at the end of reload.  */
name|PUT_MODE
argument_list|(
name|emit_insn_before
argument_list|(
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|ad
argument_list|)
argument_list|,
name|insn
argument_list|)
argument_list|,
name|QImode
argument_list|)
expr_stmt|;
comment|/* This doesn't really count as replacing the address 			 as a whole, since it is still a memory access.  */
block|}
return|return
literal|0
return|;
block|}
name|ad
operator|=
name|tem
expr_stmt|;
block|}
block|}
comment|/* The only remaining case where we can avoid a reload is if this is a 	 hard register that is valid as a base register and which is not the 	 subject of a CLOBBER in this insn.  */
elseif|else
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|REGNO_MODE_OK_FOR_BASE_P
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
operator|&&
operator|!
name|regno_clobbered_p
argument_list|(
name|regno
argument_list|,
name|this_insn
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* If we do not have one of the cases above, we must do the reload.  */
name|push_reload
argument_list|(
name|ad
argument_list|,
name|NULL_RTX
argument_list|,
name|loc
argument_list|,
operator|(
name|rtx
operator|*
operator|)
literal|0
argument_list|,
name|MODE_BASE_REG_CLASS
argument_list|(
name|mode
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|ad
argument_list|)
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|opnum
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|strict_memory_address_p
argument_list|(
name|mode
argument_list|,
name|ad
argument_list|)
condition|)
block|{
comment|/* The address appears valid, so reloads are not needed. 	 But the address may contain an eliminable register. 	 This can happen because a machine with indirect addressing 	 may consider a pseudo register by itself a valid address even when 	 it has failed to get a hard reg. 	 So do a tree-walk to find and eliminate all such regs.  */
comment|/* But first quickly dispose of a common case.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|ad
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|reg_equiv_constant
index|[
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|0
argument_list|)
argument_list|)
index|]
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|subst_reg_equivs_changed
operator|=
literal|0
expr_stmt|;
operator|*
name|loc
operator|=
name|subst_reg_equivs
argument_list|(
name|ad
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|subst_reg_equivs_changed
condition|)
return|return
literal|0
return|;
comment|/* Check result for validity after substitution.  */
if|if
condition|(
name|strict_memory_address_p
argument_list|(
name|mode
argument_list|,
name|ad
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
ifdef|#
directive|ifdef
name|LEGITIMIZE_RELOAD_ADDRESS
do|do
block|{
if|if
condition|(
name|memrefloc
condition|)
block|{
name|LEGITIMIZE_RELOAD_ADDRESS
argument_list|(
name|ad
argument_list|,
name|GET_MODE
argument_list|(
operator|*
name|memrefloc
argument_list|)
argument_list|,
name|opnum
argument_list|,
name|type
argument_list|,
name|ind_levels
argument_list|,
name|win
argument_list|)
expr_stmt|;
block|}
break|break;
name|win
label|:
operator|*
name|memrefloc
operator|=
name|copy_rtx
argument_list|(
operator|*
name|memrefloc
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
operator|*
name|memrefloc
argument_list|,
literal|0
argument_list|)
operator|=
name|ad
expr_stmt|;
name|move_replacements
argument_list|(
operator|&
name|ad
argument_list|,
operator|&
name|XEXP
argument_list|(
operator|*
name|memrefloc
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
endif|#
directive|endif
comment|/* The address is not valid.  We have to figure out why.  First see if      we have an outer AND and remove it if so.  Then analyze what's inside.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|ad
argument_list|)
operator|==
name|AND
condition|)
block|{
name|removed_and
operator|=
literal|1
expr_stmt|;
name|loc
operator|=
operator|&
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ad
operator|=
operator|*
name|loc
expr_stmt|;
block|}
comment|/* One possibility for why the address is invalid is that it is itself      a MEM.  This can happen when the frame pointer is being eliminated, a      pseudo is not allocated to a hard register, and the offset between the      frame and stack pointers is not its initial value.  In that case the      pseudo will have been replaced by a MEM referring to the      stack pointer.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|ad
argument_list|)
operator|==
name|MEM
condition|)
block|{
comment|/* First ensure that the address in this MEM is valid.  Then, unless 	 indirect addresses are valid, reload the MEM into a register.  */
name|tem
operator|=
name|ad
expr_stmt|;
name|find_reloads_address
argument_list|(
name|GET_MODE
argument_list|(
name|ad
argument_list|)
argument_list|,
operator|&
name|tem
argument_list|,
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|0
argument_list|)
argument_list|,
name|opnum
argument_list|,
name|ADDR_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|ind_levels
operator|==
literal|0
condition|?
literal|0
else|:
name|ind_levels
operator|-
literal|1
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* If tem was changed, then we must create a new memory reference to 	 hold it and store it back into memrefloc.  */
if|if
condition|(
name|tem
operator|!=
name|ad
operator|&&
name|memrefloc
condition|)
block|{
operator|*
name|memrefloc
operator|=
name|copy_rtx
argument_list|(
operator|*
name|memrefloc
argument_list|)
expr_stmt|;
name|copy_replacements
argument_list|(
name|tem
argument_list|,
name|XEXP
argument_list|(
operator|*
name|memrefloc
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|loc
operator|=
operator|&
name|XEXP
argument_list|(
operator|*
name|memrefloc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|removed_and
condition|)
name|loc
operator|=
operator|&
name|XEXP
argument_list|(
operator|*
name|loc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Check similar cases as for indirect addresses as above except 	 that we can allow pseudos and a MEM since they should have been 	 taken care of above.  */
if|if
condition|(
name|ind_levels
operator|==
literal|0
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
operator|!
name|indirect_symref_ok
operator|)
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
operator|||
operator|!
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|)
operator|)
condition|)
block|{
comment|/* Must use TEM here, not AD, since it is the one that will 	     have any subexpressions reloaded, if needed.  */
name|push_reload
argument_list|(
name|tem
argument_list|,
name|NULL_RTX
argument_list|,
name|loc
argument_list|,
operator|(
name|rtx
operator|*
operator|)
literal|0
argument_list|,
name|MODE_BASE_REG_CLASS
argument_list|(
name|mode
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|tem
argument_list|)
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|opnum
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
operator|!
name|removed_and
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
comment|/* If we have address of a stack slot but it's not valid because the      displacement is too large, compute the sum in a register.      Handle all base registers here, not just fp/ap/sp, because on some      targets (namely SH) we can also get too large displacements from      big-endian corrections.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|ad
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|REG_MODE_OK_FOR_BASE_P
argument_list|(
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
comment|/* Unshare the MEM rtx so we can safely alter it.  */
if|if
condition|(
name|memrefloc
condition|)
block|{
operator|*
name|memrefloc
operator|=
name|copy_rtx
argument_list|(
operator|*
name|memrefloc
argument_list|)
expr_stmt|;
name|loc
operator|=
operator|&
name|XEXP
argument_list|(
operator|*
name|memrefloc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|removed_and
condition|)
name|loc
operator|=
operator|&
name|XEXP
argument_list|(
operator|*
name|loc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|double_reg_address_ok
condition|)
block|{
comment|/* Unshare the sum as well.  */
operator|*
name|loc
operator|=
name|ad
operator|=
name|copy_rtx
argument_list|(
name|ad
argument_list|)
expr_stmt|;
comment|/* Reload the displacement into an index reg. 	     We assume the frame pointer or arg pointer is a base reg.  */
name|find_reloads_address_part
argument_list|(
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|1
argument_list|)
argument_list|,
operator|&
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|1
argument_list|)
argument_list|,
name|INDEX_REG_CLASS
argument_list|,
name|GET_MODE
argument_list|(
name|ad
argument_list|)
argument_list|,
name|opnum
argument_list|,
name|type
argument_list|,
name|ind_levels
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
comment|/* If the sum of two regs is not necessarily valid, 	     reload the sum into a base reg. 	     That will at least work.  */
name|find_reloads_address_part
argument_list|(
name|ad
argument_list|,
name|loc
argument_list|,
name|MODE_BASE_REG_CLASS
argument_list|(
name|mode
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|opnum
argument_list|,
name|type
argument_list|,
name|ind_levels
argument_list|)
expr_stmt|;
block|}
return|return
operator|!
name|removed_and
return|;
block|}
comment|/* If we have an indexed stack slot, there are three possible reasons why      it might be invalid: The index might need to be reloaded, the address      might have been made by frame pointer elimination and hence have a      constant out of range, or both reasons might apply.       We can easily check for an index needing reload, but even if that is the      case, we might also have an invalid constant.  To avoid making the      conservative assumption and requiring two reloads, we see if this address      is valid when not interpreted strictly.  If it is, the only problem is      that the index needs a reload and find_reloads_address_1 will take care      of it.       If we decide to do something here, it must be that      `double_reg_address_ok' is true and that this address rtl was made by      eliminate_regs.  We generate a reload of the fp/sp/ap + constant and      rework the sum so that the reload register will be added to the index.      This is safe because we know the address isn't shared.       We check for fp/ap/sp as both the first and second operand of the      innermost PLUS.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|ad
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
operator|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|frame_pointer_rtx
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|HARD_FRAME_POINTER_REGNUM
operator|||
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|hard_frame_pointer_rtx
endif|#
directive|endif
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|ARG_POINTER_REGNUM
operator|||
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|arg_pointer_rtx
endif|#
directive|endif
operator|||
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|stack_pointer_rtx
operator|)
operator|&&
operator|!
name|memory_address_p
argument_list|(
name|mode
argument_list|,
name|ad
argument_list|)
condition|)
block|{
operator|*
name|loc
operator|=
name|ad
operator|=
name|gen_rtx_PLUS
argument_list|(
name|GET_MODE
argument_list|(
name|ad
argument_list|)
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|find_reloads_address_part
argument_list|(
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|0
argument_list|)
argument_list|,
name|MODE_BASE_REG_CLASS
argument_list|(
name|mode
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|ad
argument_list|)
argument_list|,
name|opnum
argument_list|,
name|type
argument_list|,
name|ind_levels
argument_list|)
expr_stmt|;
name|find_reloads_address_1
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|1
argument_list|)
argument_list|,
name|opnum
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
name|insn
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|ad
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
operator|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|frame_pointer_rtx
if|#
directive|if
name|HARD_FRAME_POINTER_REGNUM
operator|!=
name|FRAME_POINTER_REGNUM
operator|||
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|hard_frame_pointer_rtx
endif|#
directive|endif
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|ARG_POINTER_REGNUM
operator|||
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|arg_pointer_rtx
endif|#
directive|endif
operator|||
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|stack_pointer_rtx
operator|)
operator|&&
operator|!
name|memory_address_p
argument_list|(
name|mode
argument_list|,
name|ad
argument_list|)
condition|)
block|{
operator|*
name|loc
operator|=
name|ad
operator|=
name|gen_rtx_PLUS
argument_list|(
name|GET_MODE
argument_list|(
name|ad
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|find_reloads_address_part
argument_list|(
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|1
argument_list|)
argument_list|,
operator|&
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|1
argument_list|)
argument_list|,
name|MODE_BASE_REG_CLASS
argument_list|(
name|mode
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|ad
argument_list|)
argument_list|,
name|opnum
argument_list|,
name|type
argument_list|,
name|ind_levels
argument_list|)
expr_stmt|;
name|find_reloads_address_1
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|0
argument_list|)
argument_list|,
name|opnum
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
name|insn
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* See if address becomes valid when an eliminable register      in a sum is replaced.  */
name|tem
operator|=
name|ad
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|ad
argument_list|)
operator|==
name|PLUS
condition|)
name|tem
operator|=
name|subst_indexed_address
argument_list|(
name|ad
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|!=
name|ad
operator|&&
name|strict_memory_address_p
argument_list|(
name|mode
argument_list|,
name|tem
argument_list|)
condition|)
block|{
comment|/* Ok, we win that way.  Replace any additional eliminable 	 registers.  */
name|subst_reg_equivs_changed
operator|=
literal|0
expr_stmt|;
name|tem
operator|=
name|subst_reg_equivs
argument_list|(
name|tem
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* Make sure that didn't make the address invalid again.  */
if|if
condition|(
operator|!
name|subst_reg_equivs_changed
operator|||
name|strict_memory_address_p
argument_list|(
name|mode
argument_list|,
name|tem
argument_list|)
condition|)
block|{
operator|*
name|loc
operator|=
name|tem
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/* If constants aren't valid addresses, reload the constant address      into a register.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|ad
argument_list|)
operator|&&
operator|!
name|strict_memory_address_p
argument_list|(
name|mode
argument_list|,
name|ad
argument_list|)
condition|)
block|{
comment|/* If AD is an address in the constant pool, the MEM rtx may be shared. 	 Unshare it so we can safely alter it.  */
if|if
condition|(
name|memrefloc
operator|&&
name|GET_CODE
argument_list|(
name|ad
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|ad
argument_list|)
condition|)
block|{
operator|*
name|memrefloc
operator|=
name|copy_rtx
argument_list|(
operator|*
name|memrefloc
argument_list|)
expr_stmt|;
name|loc
operator|=
operator|&
name|XEXP
argument_list|(
operator|*
name|memrefloc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|removed_and
condition|)
name|loc
operator|=
operator|&
name|XEXP
argument_list|(
operator|*
name|loc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|find_reloads_address_part
argument_list|(
name|ad
argument_list|,
name|loc
argument_list|,
name|MODE_BASE_REG_CLASS
argument_list|(
name|mode
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|opnum
argument_list|,
name|type
argument_list|,
name|ind_levels
argument_list|)
expr_stmt|;
return|return
operator|!
name|removed_and
return|;
block|}
return|return
name|find_reloads_address_1
argument_list|(
name|mode
argument_list|,
name|ad
argument_list|,
literal|0
argument_list|,
name|loc
argument_list|,
name|opnum
argument_list|,
name|type
argument_list|,
name|ind_levels
argument_list|,
name|insn
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find all pseudo regs appearing in AD    that are eliminable in favor of equivalent values    and do not have hard regs; replace them by their equivalents.    INSN, if nonzero, is the insn in which we do the reload.  We put USEs in    front of it for pseudos that we have to replace with stack slots.  */
end_comment

begin_function
specifier|static
name|rtx
name|subst_reg_equivs
parameter_list|(
name|ad
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|ad
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|ad
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|HIGH
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST_VECTOR
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
return|return
name|ad
return|;
case|case
name|REG
case|:
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|ad
argument_list|)
decl_stmt|;
if|if
condition|(
name|reg_equiv_constant
index|[
name|regno
index|]
operator|!=
literal|0
condition|)
block|{
name|subst_reg_equivs_changed
operator|=
literal|1
expr_stmt|;
return|return
name|reg_equiv_constant
index|[
name|regno
index|]
return|;
block|}
if|if
condition|(
name|reg_equiv_memory_loc
index|[
name|regno
index|]
operator|&&
name|num_not_at_initial_offset
condition|)
block|{
name|rtx
name|mem
init|=
name|make_memloc
argument_list|(
name|ad
argument_list|,
name|regno
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|mem
argument_list|,
name|reg_equiv_mem
index|[
name|regno
index|]
argument_list|)
condition|)
block|{
name|subst_reg_equivs_changed
operator|=
literal|1
expr_stmt|;
comment|/* We mark the USE with QImode so that we recognize it 		   as one that can be safely deleted at the end of 		   reload.  */
name|PUT_MODE
argument_list|(
name|emit_insn_before
argument_list|(
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|ad
argument_list|)
argument_list|,
name|insn
argument_list|)
argument_list|,
name|QImode
argument_list|)
expr_stmt|;
return|return
name|mem
return|;
block|}
block|}
block|}
return|return
name|ad
return|;
case|case
name|PLUS
case|:
comment|/* Quickly dispose of a common case.  */
if|if
condition|(
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|0
argument_list|)
operator|==
name|frame_pointer_rtx
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|ad
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|ad
return|;
break|break;
default|default:
break|break;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|XEXP
argument_list|(
name|ad
argument_list|,
name|i
argument_list|)
operator|=
name|subst_reg_equivs
argument_list|(
name|XEXP
argument_list|(
name|ad
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
return|return
name|ad
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compute the sum of X and Y, making canonicalizations assumed in an    address, namely: sum constant integers, surround the sum of two    constants with a CONST, put the constant as the second operand, and    group the constant on the outermost sum.     This routine assumes both inputs are already in canonical form.  */
end_comment

begin_function
name|rtx
name|form_sum
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
name|rtx
name|tem
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|mode
operator|=
name|GET_MODE
argument_list|(
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|mode
operator|=
name|Pmode
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|plus_constant
argument_list|(
name|y
argument_list|,
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|plus_constant
argument_list|(
name|x
argument_list|,
name|INTVAL
argument_list|(
name|y
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
condition|)
name|tem
operator|=
name|x
operator|,
name|x
operator|=
name|y
operator|,
name|y
operator|=
name|tem
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|form_sum
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|form_sum
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|y
argument_list|)
argument_list|)
return|;
comment|/* Note that if the operands of Y are specified in the opposite      order in the recursive calls below, infinite recursion will occur.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|PLUS
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|form_sum
argument_list|(
name|form_sum
argument_list|(
name|x
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
comment|/* If both constant, encapsulate sum.  Otherwise, just form sum.  A      constant will have been placed second.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
operator|&&
name|CONSTANT_P
argument_list|(
name|y
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST
condition|)
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|CONST
condition|)
name|y
operator|=
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|gen_rtx_CONST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
argument_list|)
return|;
block|}
return|return
name|gen_rtx_PLUS
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If ADDR is a sum containing a pseudo register that should be    replaced with a constant (from reg_equiv_constant),    return the result of doing so, and also apply the associative    law so that the result is more likely to be a valid address.    (But it is not guaranteed to be one.)     Note that at most one register is replaced, even if more are    replaceable.  Also, we try to put the result into a canonical form    so it is more likely to be a valid address.     In all other cases, return ADDR.  */
end_comment

begin_function
specifier|static
name|rtx
name|subst_indexed_address
parameter_list|(
name|addr
parameter_list|)
name|rtx
name|addr
decl_stmt|;
block|{
name|rtx
name|op0
init|=
literal|0
decl_stmt|,
name|op1
init|=
literal|0
decl_stmt|,
name|op2
init|=
literal|0
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
name|int
name|regno
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
condition|)
block|{
comment|/* Try to find a register to replace.  */
name|op0
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
operator|,
name|op1
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
operator|,
name|op2
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|regno
operator|=
name|REGNO
argument_list|(
name|op0
argument_list|)
operator|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|reg_renumber
index|[
name|regno
index|]
operator|<
literal|0
operator|&&
name|reg_equiv_constant
index|[
name|regno
index|]
operator|!=
literal|0
condition|)
name|op0
operator|=
name|reg_equiv_constant
index|[
name|regno
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|regno
operator|=
name|REGNO
argument_list|(
name|op1
argument_list|)
operator|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|reg_renumber
index|[
name|regno
index|]
operator|<
literal|0
operator|&&
name|reg_equiv_constant
index|[
name|regno
index|]
operator|!=
literal|0
condition|)
name|op1
operator|=
name|reg_equiv_constant
index|[
name|regno
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|PLUS
operator|&&
operator|(
name|tem
operator|=
name|subst_indexed_address
argument_list|(
name|op0
argument_list|)
operator|)
operator|!=
name|op0
condition|)
name|op0
operator|=
name|tem
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|PLUS
operator|&&
operator|(
name|tem
operator|=
name|subst_indexed_address
argument_list|(
name|op1
argument_list|)
operator|)
operator|!=
name|op1
condition|)
name|op1
operator|=
name|tem
expr_stmt|;
else|else
return|return
name|addr
return|;
comment|/* Pick out up to three things to add.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|PLUS
condition|)
name|op2
operator|=
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|1
argument_list|)
operator|,
name|op1
operator|=
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|PLUS
condition|)
name|op2
operator|=
name|op1
operator|,
name|op1
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
operator|,
name|op0
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Compute the sum.  */
if|if
condition|(
name|op2
operator|!=
literal|0
condition|)
name|op1
operator|=
name|form_sum
argument_list|(
name|op1
argument_list|,
name|op2
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
operator|!=
literal|0
condition|)
name|op0
operator|=
name|form_sum
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
return|return
name|op0
return|;
block|}
return|return
name|addr
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Update the REG_INC notes for an insn.  It updates all REG_INC    notes for the instruction which refer to REGNO the to refer    to the reload number.     INSN is the insn for which any REG_INC notes need updating.     REGNO is the register number which has been reloaded.     RELOADNUM is the reload number.  */
end_comment

begin_function
specifier|static
name|void
name|update_auto_inc_notes
parameter_list|(
name|insn
parameter_list|,
name|regno
parameter_list|,
name|reloadnum
parameter_list|)
name|rtx
name|insn
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|regno
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|reloadnum
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|AUTO_INC_DEC
name|rtx
name|link
decl_stmt|;
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_INC
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|regno
condition|)
name|push_replacement
argument_list|(
operator|&
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|,
name|reloadnum
argument_list|,
name|VOIDmode
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Record the pseudo registers we must reload into hard registers in a    subexpression of a would-be memory address, X referring to a value    in mode MODE.  (This function is not called if the address we find    is strictly valid.)     CONTEXT = 1 means we are considering regs as index regs,    = 0 means we are considering them as base regs.     OPNUM and TYPE specify the purpose of any reloads made.     IND_LEVELS says how many levels of indirect addressing are    supported at this point in the address.     INSN, if nonzero, is the insn in which we do the reload.  It is used    to determine if we may generate output reloads.     We return nonzero if X, as a whole, is reloaded or replaced.  */
end_comment

begin_comment
comment|/* Note that we take shortcuts assuming that no multi-reg machine mode    occurs as part of an address.    Also, this is not fully machine-customizable; it works for machines    such as VAXen and 68000's and 32000's, but other possible machines    could have addressing modes that this does not handle right.  */
end_comment

begin_function
specifier|static
name|int
name|find_reloads_address_1
parameter_list|(
name|mode
parameter_list|,
name|x
parameter_list|,
name|context
parameter_list|,
name|loc
parameter_list|,
name|opnum
parameter_list|,
name|type
parameter_list|,
name|ind_levels
parameter_list|,
name|insn
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|int
name|context
decl_stmt|;
name|rtx
modifier|*
name|loc
decl_stmt|;
name|int
name|opnum
decl_stmt|;
name|enum
name|reload_type
name|type
decl_stmt|;
name|int
name|ind_levels
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PLUS
case|:
block|{
name|rtx
name|orig_op0
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|orig_op1
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|RTX_CODE
name|code0
init|=
name|GET_CODE
argument_list|(
name|orig_op0
argument_list|)
decl_stmt|;
name|RTX_CODE
name|code1
init|=
name|GET_CODE
argument_list|(
name|orig_op1
argument_list|)
decl_stmt|;
name|rtx
name|op0
init|=
name|orig_op0
decl_stmt|;
name|rtx
name|op1
init|=
name|orig_op1
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|op0
operator|=
name|SUBREG_REG
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|code0
operator|=
name|GET_CODE
argument_list|(
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|code0
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|op0
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|op0
operator|=
name|gen_rtx_REG
argument_list|(
name|word_mode
argument_list|,
operator|(
name|REGNO
argument_list|(
name|op0
argument_list|)
operator|+
name|subreg_regno_offset
argument_list|(
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|orig_op0
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|orig_op0
argument_list|)
argument_list|)
argument_list|,
name|SUBREG_BYTE
argument_list|(
name|orig_op0
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|orig_op0
argument_list|)
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|op1
operator|=
name|SUBREG_REG
argument_list|(
name|op1
argument_list|)
expr_stmt|;
name|code1
operator|=
name|GET_CODE
argument_list|(
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|code1
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|op1
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
comment|/* ??? Why is this given op1's mode and above for 		 ??? op0 SUBREGs we use word_mode?  */
name|op1
operator|=
name|gen_rtx_REG
argument_list|(
name|GET_MODE
argument_list|(
name|op1
argument_list|)
argument_list|,
operator|(
name|REGNO
argument_list|(
name|op1
argument_list|)
operator|+
name|subreg_regno_offset
argument_list|(
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|orig_op1
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|orig_op1
argument_list|)
argument_list|)
argument_list|,
name|SUBREG_BYTE
argument_list|(
name|orig_op1
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|orig_op1
argument_list|)
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|code0
operator|==
name|MULT
operator|||
name|code0
operator|==
name|SIGN_EXTEND
operator|||
name|code0
operator|==
name|TRUNCATE
operator|||
name|code0
operator|==
name|ZERO_EXTEND
operator|||
name|code1
operator|==
name|MEM
condition|)
block|{
name|find_reloads_address_1
argument_list|(
name|mode
argument_list|,
name|orig_op0
argument_list|,
literal|1
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|opnum
argument_list|,
name|type
argument_list|,
name|ind_levels
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|find_reloads_address_1
argument_list|(
name|mode
argument_list|,
name|orig_op1
argument_list|,
literal|0
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|opnum
argument_list|,
name|type
argument_list|,
name|ind_levels
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code1
operator|==
name|MULT
operator|||
name|code1
operator|==
name|SIGN_EXTEND
operator|||
name|code1
operator|==
name|TRUNCATE
operator|||
name|code1
operator|==
name|ZERO_EXTEND
operator|||
name|code0
operator|==
name|MEM
condition|)
block|{
name|find_reloads_address_1
argument_list|(
name|mode
argument_list|,
name|orig_op0
argument_list|,
literal|0
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|opnum
argument_list|,
name|type
argument_list|,
name|ind_levels
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|find_reloads_address_1
argument_list|(
name|mode
argument_list|,
name|orig_op1
argument_list|,
literal|1
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|opnum
argument_list|,
name|type
argument_list|,
name|ind_levels
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code0
operator|==
name|CONST_INT
operator|||
name|code0
operator|==
name|CONST
operator|||
name|code0
operator|==
name|SYMBOL_REF
operator|||
name|code0
operator|==
name|LABEL_REF
condition|)
name|find_reloads_address_1
argument_list|(
name|mode
argument_list|,
name|orig_op1
argument_list|,
literal|0
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|opnum
argument_list|,
name|type
argument_list|,
name|ind_levels
argument_list|,
name|insn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code1
operator|==
name|CONST_INT
operator|||
name|code1
operator|==
name|CONST
operator|||
name|code1
operator|==
name|SYMBOL_REF
operator|||
name|code1
operator|==
name|LABEL_REF
condition|)
name|find_reloads_address_1
argument_list|(
name|mode
argument_list|,
name|orig_op0
argument_list|,
literal|0
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|opnum
argument_list|,
name|type
argument_list|,
name|ind_levels
argument_list|,
name|insn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code0
operator|==
name|REG
operator|&&
name|code1
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|REG_OK_FOR_INDEX_P
argument_list|(
name|op0
argument_list|)
operator|&&
name|REG_MODE_OK_FOR_BASE_P
argument_list|(
name|op1
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|REG_OK_FOR_INDEX_P
argument_list|(
name|op1
argument_list|)
operator|&&
name|REG_MODE_OK_FOR_BASE_P
argument_list|(
name|op0
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|REG_MODE_OK_FOR_BASE_P
argument_list|(
name|op1
argument_list|,
name|mode
argument_list|)
condition|)
name|find_reloads_address_1
argument_list|(
name|mode
argument_list|,
name|orig_op0
argument_list|,
literal|1
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|opnum
argument_list|,
name|type
argument_list|,
name|ind_levels
argument_list|,
name|insn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|REG_MODE_OK_FOR_BASE_P
argument_list|(
name|op0
argument_list|,
name|mode
argument_list|)
condition|)
name|find_reloads_address_1
argument_list|(
name|mode
argument_list|,
name|orig_op1
argument_list|,
literal|1
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|opnum
argument_list|,
name|type
argument_list|,
name|ind_levels
argument_list|,
name|insn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|REG_OK_FOR_INDEX_P
argument_list|(
name|op1
argument_list|)
condition|)
name|find_reloads_address_1
argument_list|(
name|mode
argument_list|,
name|orig_op0
argument_list|,
literal|0
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|opnum
argument_list|,
name|type
argument_list|,
name|ind_levels
argument_list|,
name|insn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|REG_OK_FOR_INDEX_P
argument_list|(
name|op0
argument_list|)
condition|)
name|find_reloads_address_1
argument_list|(
name|mode
argument_list|,
name|orig_op1
argument_list|,
literal|0
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|opnum
argument_list|,
name|type
argument_list|,
name|ind_levels
argument_list|,
name|insn
argument_list|)
expr_stmt|;
else|else
block|{
name|find_reloads_address_1
argument_list|(
name|mode
argument_list|,
name|orig_op0
argument_list|,
literal|1
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|opnum
argument_list|,
name|type
argument_list|,
name|ind_levels
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|find_reloads_address_1
argument_list|(
name|mode
argument_list|,
name|orig_op1
argument_list|,
literal|0
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|opnum
argument_list|,
name|type
argument_list|,
name|ind_levels
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|code0
operator|==
name|REG
condition|)
block|{
name|find_reloads_address_1
argument_list|(
name|mode
argument_list|,
name|orig_op0
argument_list|,
literal|1
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|opnum
argument_list|,
name|type
argument_list|,
name|ind_levels
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|find_reloads_address_1
argument_list|(
name|mode
argument_list|,
name|orig_op1
argument_list|,
literal|0
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|opnum
argument_list|,
name|type
argument_list|,
name|ind_levels
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code1
operator|==
name|REG
condition|)
block|{
name|find_reloads_address_1
argument_list|(
name|mode
argument_list|,
name|orig_op1
argument_list|,
literal|1
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|opnum
argument_list|,
name|type
argument_list|,
name|ind_levels
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|find_reloads_address_1
argument_list|(
name|mode
argument_list|,
name|orig_op0
argument_list|,
literal|0
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|opnum
argument_list|,
name|type
argument_list|,
name|ind_levels
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
case|case
name|POST_MODIFY
case|:
case|case
name|PRE_MODIFY
case|:
block|{
name|rtx
name|op0
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|MINUS
condition|)
return|return
literal|0
return|;
comment|/* Currently, we only support {PRE,POST}_MODIFY constructs 	   where a base register is {inc,dec}remented by the contents 	   of another register or by a constant value.  Thus, these 	   operands must match.  */
if|if
condition|(
name|op0
operator|!=
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Require index register (or constant).  Let's just handle the 	   register case in the meantime... If the target allows 	   auto-modify by a constant then we could try replacing a pseudo 	   register with its equivalent constant where applicable.  */
if|if
condition|(
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
if|if
condition|(
operator|!
name|REGNO_OK_FOR_INDEX_P
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
condition|)
name|find_reloads_address_1
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|1
argument_list|)
argument_list|,
name|opnum
argument_list|,
name|type
argument_list|,
name|ind_levels
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|reloadnum
decl_stmt|;
comment|/* A register that is incremented cannot be constant!  */
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|reg_equiv_constant
index|[
name|regno
index|]
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Handle a register that is equivalent to a memory location 	       which cannot be addressed directly.  */
if|if
condition|(
name|reg_equiv_memory_loc
index|[
name|regno
index|]
operator|!=
literal|0
operator|&&
operator|(
name|reg_equiv_address
index|[
name|regno
index|]
operator|!=
literal|0
operator|||
name|num_not_at_initial_offset
operator|)
condition|)
block|{
name|rtx
name|tem
init|=
name|make_memloc
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|regno
argument_list|)
decl_stmt|;
if|if
condition|(
name|reg_equiv_address
index|[
name|regno
index|]
operator|||
operator|!
name|rtx_equal_p
argument_list|(
name|tem
argument_list|,
name|reg_equiv_mem
index|[
name|regno
index|]
argument_list|)
condition|)
block|{
comment|/* First reload the memory location's address. 		       We can't use ADDR_TYPE (type) here, because we need to 		       write back the value after reading it, hence we actually 		       need two registers.  */
name|find_reloads_address
argument_list|(
name|GET_MODE
argument_list|(
name|tem
argument_list|)
argument_list|,
literal|0
argument_list|,
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|opnum
argument_list|,
name|RELOAD_OTHER
argument_list|,
name|ind_levels
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* Then reload the memory location into a base 		       register.  */
name|reloadnum
operator|=
name|push_reload
argument_list|(
name|tem
argument_list|,
name|tem
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|MODE_BASE_REG_CLASS
argument_list|(
name|mode
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|opnum
argument_list|,
name|RELOAD_OTHER
argument_list|)
expr_stmt|;
name|update_auto_inc_notes
argument_list|(
name|this_insn
argument_list|,
name|regno
argument_list|,
name|reloadnum
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
name|reg_renumber
index|[
name|regno
index|]
operator|>=
literal|0
condition|)
name|regno
operator|=
name|reg_renumber
index|[
name|regno
index|]
expr_stmt|;
comment|/* We require a base register here...  */
if|if
condition|(
operator|!
name|REGNO_MODE_OK_FOR_BASE_P
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
block|{
name|reloadnum
operator|=
name|push_reload
argument_list|(
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|MODE_BASE_REG_CLASS
argument_list|(
name|mode
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|opnum
argument_list|,
name|RELOAD_OTHER
argument_list|)
expr_stmt|;
name|update_auto_inc_notes
argument_list|(
name|this_insn
argument_list|,
name|regno
argument_list|,
name|reloadnum
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
literal|0
return|;
case|case
name|POST_INC
case|:
case|case
name|POST_DEC
case|:
case|case
name|PRE_INC
case|:
case|case
name|PRE_DEC
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|value
init|=
literal|0
decl_stmt|;
name|rtx
name|x_orig
init|=
name|x
decl_stmt|;
comment|/* A register that is incremented cannot be constant!  */
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|reg_equiv_constant
index|[
name|regno
index|]
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Handle a register that is equivalent to a memory location 	     which cannot be addressed directly.  */
if|if
condition|(
name|reg_equiv_memory_loc
index|[
name|regno
index|]
operator|!=
literal|0
operator|&&
operator|(
name|reg_equiv_address
index|[
name|regno
index|]
operator|!=
literal|0
operator|||
name|num_not_at_initial_offset
operator|)
condition|)
block|{
name|rtx
name|tem
init|=
name|make_memloc
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|regno
argument_list|)
decl_stmt|;
if|if
condition|(
name|reg_equiv_address
index|[
name|regno
index|]
operator|||
operator|!
name|rtx_equal_p
argument_list|(
name|tem
argument_list|,
name|reg_equiv_mem
index|[
name|regno
index|]
argument_list|)
condition|)
block|{
comment|/* First reload the memory location's address. 		     We can't use ADDR_TYPE (type) here, because we need to 		     write back the value after reading it, hence we actually 		     need two registers.  */
name|find_reloads_address
argument_list|(
name|GET_MODE
argument_list|(
name|tem
argument_list|)
argument_list|,
operator|&
name|tem
argument_list|,
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|opnum
argument_list|,
name|type
argument_list|,
name|ind_levels
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* Put this inside a new increment-expression.  */
name|x
operator|=
name|gen_rtx_fmt_e
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|tem
argument_list|)
expr_stmt|;
comment|/* Proceed to reload that, as if it contained a register.  */
block|}
block|}
comment|/* If we have a hard register that is ok as an index, 	     don't make a reload.  If an autoincrement of a nice register 	     isn't "valid", it must be that no autoincrement is "valid". 	     If that is true and something made an autoincrement anyway, 	     this must be a special context where one is allowed. 	     (For example, a "push" instruction.) 	     We can't improve this address, so leave it alone.  */
comment|/* Otherwise, reload the autoincrement into a suitable hard reg 	     and record how much to increment by.  */
if|if
condition|(
name|reg_renumber
index|[
name|regno
index|]
operator|>=
literal|0
condition|)
name|regno
operator|=
name|reg_renumber
index|[
name|regno
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|||
operator|!
operator|(
name|context
condition|?
name|REGNO_OK_FOR_INDEX_P
argument_list|(
name|regno
argument_list|)
else|:
name|REGNO_MODE_OK_FOR_BASE_P
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
operator|)
operator|)
condition|)
block|{
name|int
name|reloadnum
decl_stmt|;
comment|/* If we can output the register afterwards, do so, this 		 saves the extra update. 		 We can do so if we have an INSN - i.e. no JUMP_INSN nor 		 CALL_INSN - and it does not set CC0. 		 But don't do this if we cannot directly address the 		 memory location, since this will make it harder to 		 reuse address reloads, and increases register pressure. 		 Also don't do this if we can probably update x directly.  */
name|rtx
name|equiv
init|=
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
condition|?
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
else|:
name|reg_equiv_mem
index|[
name|regno
index|]
operator|)
decl_stmt|;
name|int
name|icode
init|=
operator|(
name|int
operator|)
name|add_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|Pmode
index|]
operator|.
name|insn_code
decl_stmt|;
if|if
condition|(
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|equiv
operator|&&
name|memory_operand
argument_list|(
name|equiv
argument_list|,
name|GET_MODE
argument_list|(
name|equiv
argument_list|)
argument_list|)
ifdef|#
directive|ifdef
name|HAVE_cc0
operator|&&
operator|!
name|sets_cc0_p
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
endif|#
directive|endif
operator|&&
operator|!
operator|(
name|icode
operator|!=
name|CODE_FOR_nothing
operator|&&
operator|(
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|equiv
operator|,
name|Pmode
operator|)
operator|)
operator|&&
operator|(
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|equiv
operator|,
name|Pmode
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* We use the original pseudo for loc, so that 		     emit_reload_insns() knows which pseudo this 		     reload refers to and updates the pseudo rtx, not 		     its equivalent memory location, as well as the 		     corresponding entry in reg_last_reload_reg.  */
name|loc
operator|=
operator|&
name|XEXP
argument_list|(
name|x_orig
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|reloadnum
operator|=
name|push_reload
argument_list|(
name|x
argument_list|,
name|x
argument_list|,
name|loc
argument_list|,
name|loc
argument_list|,
operator|(
name|context
condition|?
name|INDEX_REG_CLASS
else|:
name|MODE_BASE_REG_CLASS
argument_list|(
name|mode
argument_list|)
operator|)
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|opnum
argument_list|,
name|RELOAD_OTHER
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|reloadnum
operator|=
name|push_reload
argument_list|(
name|x
argument_list|,
name|NULL_RTX
argument_list|,
name|loc
argument_list|,
operator|(
name|rtx
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|context
condition|?
name|INDEX_REG_CLASS
else|:
name|MODE_BASE_REG_CLASS
argument_list|(
name|mode
argument_list|)
operator|)
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|opnum
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|rld
index|[
name|reloadnum
index|]
operator|.
name|inc
operator|=
name|find_inc_amount
argument_list|(
name|PATTERN
argument_list|(
name|this_insn
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x_orig
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|value
operator|=
literal|1
expr_stmt|;
block|}
name|update_auto_inc_notes
argument_list|(
name|this_insn
argument_list|,
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x_orig
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|reloadnum
argument_list|)
expr_stmt|;
block|}
return|return
name|value
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
block|{
comment|/* This is probably the result of a substitution, by eliminate_regs, 	     of an equivalent address for a pseudo that was not allocated to a 	     hard register.  Verify that the specified address is valid and 	     reload it into a register.  */
comment|/* Variable `tem' might or might not be used in FIND_REG_INC_NOTE.  */
name|rtx
name|tem
name|ATTRIBUTE_UNUSED
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|link
decl_stmt|;
name|int
name|reloadnum
decl_stmt|;
comment|/* Since we know we are going to reload this item, don't decrement 	     for the indirection level.  	     Note that this is actually conservative:  it would be slightly 	     more efficient to use the value of SPILL_INDIRECT_LEVELS from 	     reload1.c here.  */
comment|/* We can't use ADDR_TYPE (type) here, because we need to 	     write back the value after reading it, hence we actually 	     need two registers.  */
name|find_reloads_address
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|opnum
argument_list|,
name|type
argument_list|,
name|ind_levels
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|reloadnum
operator|=
name|push_reload
argument_list|(
name|x
argument_list|,
name|NULL_RTX
argument_list|,
name|loc
argument_list|,
operator|(
name|rtx
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|context
condition|?
name|INDEX_REG_CLASS
else|:
name|MODE_BASE_REG_CLASS
argument_list|(
name|mode
argument_list|)
operator|)
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|opnum
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|rld
index|[
name|reloadnum
index|]
operator|.
name|inc
operator|=
name|find_inc_amount
argument_list|(
name|PATTERN
argument_list|(
name|this_insn
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|link
operator|=
name|FIND_REG_INC_NOTE
argument_list|(
name|this_insn
argument_list|,
name|tem
argument_list|)
expr_stmt|;
if|if
condition|(
name|link
operator|!=
literal|0
condition|)
name|push_replacement
argument_list|(
operator|&
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|,
name|reloadnum
argument_list|,
name|VOIDmode
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
case|case
name|MEM
case|:
comment|/* This is probably the result of a substitution, by eliminate_regs, of 	 an equivalent address for a pseudo that was not allocated to a hard 	 register.  Verify that the specified address is valid and reload it 	 into a register.  	 Since we know we are going to reload this item, don't decrement for 	 the indirection level.  	 Note that this is actually conservative:  it would be slightly more 	 efficient to use the value of SPILL_INDIRECT_LEVELS from 	 reload1.c here.  */
name|find_reloads_address
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|loc
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|opnum
argument_list|,
name|ADDR_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|ind_levels
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|push_reload
argument_list|(
operator|*
name|loc
argument_list|,
name|NULL_RTX
argument_list|,
name|loc
argument_list|,
operator|(
name|rtx
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|context
condition|?
name|INDEX_REG_CLASS
else|:
name|MODE_BASE_REG_CLASS
argument_list|(
name|mode
argument_list|)
operator|)
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|opnum
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|REG
case|:
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|reg_equiv_constant
index|[
name|regno
index|]
operator|!=
literal|0
condition|)
block|{
name|find_reloads_address_part
argument_list|(
name|reg_equiv_constant
index|[
name|regno
index|]
argument_list|,
name|loc
argument_list|,
operator|(
name|context
condition|?
name|INDEX_REG_CLASS
else|:
name|MODE_BASE_REG_CLASS
argument_list|(
name|mode
argument_list|)
operator|)
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|opnum
argument_list|,
name|type
argument_list|,
name|ind_levels
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|#
directive|if
literal|0
comment|/* This might screw code in reload1.c to delete prior output-reload 	 that feeds this insn.  */
block|if (reg_equiv_mem[regno] != 0) 	  { 	    push_reload (reg_equiv_mem[regno], NULL_RTX, loc, (rtx*) 0, 			 (context ? INDEX_REG_CLASS : 			  MODE_BASE_REG_CLASS (mode)), 			 GET_MODE (x), VOIDmode, 0, 0, opnum, type); 	    return 1; 	  }
endif|#
directive|endif
if|if
condition|(
name|reg_equiv_memory_loc
index|[
name|regno
index|]
operator|&&
operator|(
name|reg_equiv_address
index|[
name|regno
index|]
operator|!=
literal|0
operator|||
name|num_not_at_initial_offset
operator|)
condition|)
block|{
name|rtx
name|tem
init|=
name|make_memloc
argument_list|(
name|x
argument_list|,
name|regno
argument_list|)
decl_stmt|;
if|if
condition|(
name|reg_equiv_address
index|[
name|regno
index|]
operator|!=
literal|0
operator|||
operator|!
name|rtx_equal_p
argument_list|(
name|tem
argument_list|,
name|reg_equiv_mem
index|[
name|regno
index|]
argument_list|)
condition|)
block|{
name|x
operator|=
name|tem
expr_stmt|;
name|find_reloads_address
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
operator|&
name|x
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|opnum
argument_list|,
name|ADDR_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|ind_levels
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|reg_renumber
index|[
name|regno
index|]
operator|>=
literal|0
condition|)
name|regno
operator|=
name|reg_renumber
index|[
name|regno
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|||
operator|!
operator|(
name|context
condition|?
name|REGNO_OK_FOR_INDEX_P
argument_list|(
name|regno
argument_list|)
else|:
name|REGNO_MODE_OK_FOR_BASE_P
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
operator|)
operator|)
condition|)
block|{
name|push_reload
argument_list|(
name|x
argument_list|,
name|NULL_RTX
argument_list|,
name|loc
argument_list|,
operator|(
name|rtx
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|context
condition|?
name|INDEX_REG_CLASS
else|:
name|MODE_BASE_REG_CLASS
argument_list|(
name|mode
argument_list|)
operator|)
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|opnum
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* If a register appearing in an address is the subject of a CLOBBER 	   in this insn, reload it into some other register to be safe. 	   The CLOBBER is supposed to make the register unavailable 	   from before this insn to after it.  */
if|if
condition|(
name|regno_clobbered_p
argument_list|(
name|regno
argument_list|,
name|this_insn
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|push_reload
argument_list|(
name|x
argument_list|,
name|NULL_RTX
argument_list|,
name|loc
argument_list|,
operator|(
name|rtx
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|context
condition|?
name|INDEX_REG_CLASS
else|:
name|MODE_BASE_REG_CLASS
argument_list|(
name|mode
argument_list|)
operator|)
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|opnum
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
case|case
name|SUBREG
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
comment|/* If this is a SUBREG of a hard register and the resulting register 	     is of the wrong class, reload the whole SUBREG.  This avoids 	     needless copies if SUBREG_REG is multi-word.  */
if|if
condition|(
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|int
name|regno
init|=
name|subreg_regno
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|context
condition|?
name|REGNO_OK_FOR_INDEX_P
argument_list|(
name|regno
argument_list|)
else|:
name|REGNO_MODE_OK_FOR_BASE_P
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
operator|)
condition|)
block|{
name|push_reload
argument_list|(
name|x
argument_list|,
name|NULL_RTX
argument_list|,
name|loc
argument_list|,
operator|(
name|rtx
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|context
condition|?
name|INDEX_REG_CLASS
else|:
name|MODE_BASE_REG_CLASS
argument_list|(
name|mode
argument_list|)
operator|)
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|opnum
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
comment|/* If this is a SUBREG of a pseudo-register, and the pseudo-register 	     is larger than the class size, then reload the whole SUBREG.  */
else|else
block|{
name|enum
name|reg_class
name|class
init|=
operator|(
name|context
condition|?
name|INDEX_REG_CLASS
else|:
name|MODE_BASE_REG_CLASS
argument_list|(
name|mode
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|CLASS_MAX_NREGS
argument_list|(
name|class
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|>
name|reg_class_size
index|[
name|class
index|]
condition|)
block|{
name|x
operator|=
name|find_reloads_subreg_address
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|opnum
argument_list|,
name|type
argument_list|,
name|ind_levels
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|push_reload
argument_list|(
name|x
argument_list|,
name|NULL_RTX
argument_list|,
name|loc
argument_list|,
operator|(
name|rtx
operator|*
operator|)
literal|0
argument_list|,
name|class
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|opnum
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
block|}
break|break;
default|default:
break|break;
block|}
block|{
specifier|const
name|char
modifier|*
name|fmt
init|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|find_reloads_address_1
argument_list|(
name|mode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|context
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|opnum
argument_list|,
name|type
argument_list|,
name|ind_levels
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* X, which is found at *LOC, is a part of an address that needs to be    reloaded into a register of class CLASS.  If X is a constant, or if    X is a PLUS that contains a constant, check that the constant is a    legitimate operand and that we are supposed to be able to load    it into the register.     If not, force the constant into memory and reload the MEM instead.     MODE is the mode to use, in case X is an integer constant.     OPNUM and TYPE describe the purpose of any reloads made.     IND_LEVELS says how many levels of indirect addressing this machine    supports.  */
end_comment

begin_function
specifier|static
name|void
name|find_reloads_address_part
parameter_list|(
name|x
parameter_list|,
name|loc
parameter_list|,
name|class
parameter_list|,
name|mode
parameter_list|,
name|opnum
parameter_list|,
name|type
parameter_list|,
name|ind_levels
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
modifier|*
name|loc
decl_stmt|;
name|enum
name|reg_class
name|class
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|opnum
decl_stmt|;
name|enum
name|reload_type
name|type
decl_stmt|;
name|int
name|ind_levels
decl_stmt|;
block|{
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
operator|&&
operator|(
operator|!
name|LEGITIMATE_CONSTANT_P
argument_list|(
name|x
argument_list|)
operator|||
name|PREFERRED_RELOAD_CLASS
argument_list|(
name|x
argument_list|,
name|class
argument_list|)
operator|==
name|NO_REGS
operator|)
condition|)
block|{
name|rtx
name|tem
decl_stmt|;
name|tem
operator|=
name|x
operator|=
name|force_const_mem
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|find_reloads_address
argument_list|(
name|mode
argument_list|,
operator|&
name|tem
argument_list|,
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|opnum
argument_list|,
name|type
argument_list|,
name|ind_levels
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
operator|(
operator|!
name|LEGITIMATE_CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|||
name|PREFERRED_RELOAD_CLASS
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|class
argument_list|)
operator|==
name|NO_REGS
operator|)
condition|)
block|{
name|rtx
name|tem
decl_stmt|;
name|tem
operator|=
name|force_const_mem
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|gen_rtx_PLUS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|tem
argument_list|)
expr_stmt|;
name|find_reloads_address
argument_list|(
name|mode
argument_list|,
operator|&
name|tem
argument_list|,
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|opnum
argument_list|,
name|type
argument_list|,
name|ind_levels
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|push_reload
argument_list|(
name|x
argument_list|,
name|NULL_RTX
argument_list|,
name|loc
argument_list|,
operator|(
name|rtx
operator|*
operator|)
literal|0
argument_list|,
name|class
argument_list|,
name|mode
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|opnum
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* X, a subreg of a pseudo, is a part of an address that needs to be    reloaded.     If the pseudo is equivalent to a memory location that cannot be directly    addressed, make the necessary address reloads.     If address reloads have been necessary, or if the address is changed    by register elimination, return the rtx of the memory location;    otherwise, return X.     If FORCE_REPLACE is nonzero, unconditionally replace the subreg with the    memory location.     OPNUM and TYPE identify the purpose of the reload.     IND_LEVELS says how many levels of indirect addressing are    supported at this point in the address.     INSN, if nonzero, is the insn in which we do the reload.  It is used    to determine where to put USEs for pseudos that we have to replace with    stack slots.  */
end_comment

begin_function
specifier|static
name|rtx
name|find_reloads_subreg_address
parameter_list|(
name|x
parameter_list|,
name|force_replace
parameter_list|,
name|opnum
parameter_list|,
name|type
parameter_list|,
name|ind_levels
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|int
name|force_replace
decl_stmt|;
name|int
name|opnum
decl_stmt|;
name|enum
name|reload_type
name|type
decl_stmt|;
name|int
name|ind_levels
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|reg_equiv_memory_loc
index|[
name|regno
index|]
condition|)
block|{
comment|/* If the address is not directly addressable, or if the address is not 	 offsettable, then it must be replaced.  */
if|if
condition|(
operator|!
name|force_replace
operator|&&
operator|(
name|reg_equiv_address
index|[
name|regno
index|]
operator|||
operator|!
name|offsettable_memref_p
argument_list|(
name|reg_equiv_mem
index|[
name|regno
index|]
argument_list|)
operator|)
condition|)
name|force_replace
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|force_replace
operator|||
name|num_not_at_initial_offset
condition|)
block|{
name|rtx
name|tem
init|=
name|make_memloc
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|,
name|regno
argument_list|)
decl_stmt|;
comment|/* If the address changes because of register elimination, then 	     it must be replaced.  */
if|if
condition|(
name|force_replace
operator|||
operator|!
name|rtx_equal_p
argument_list|(
name|tem
argument_list|,
name|reg_equiv_mem
index|[
name|regno
index|]
argument_list|)
condition|)
block|{
name|int
name|offset
init|=
name|SUBREG_BYTE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|unsigned
name|outer_size
init|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|inner_size
init|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
operator|=
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|tem
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If this was a paradoxical subreg that we replaced, the 		 resulting memory must be sufficiently aligned to allow 		 us to widen the mode of the memory.  */
if|if
condition|(
name|outer_size
operator|>
name|inner_size
operator|&&
name|STRICT_ALIGNMENT
condition|)
block|{
name|rtx
name|base
decl_stmt|;
name|base
operator|=
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|PLUS
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|base
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|base
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|%
name|outer_size
operator|!=
literal|0
condition|)
return|return
name|x
return|;
name|base
operator|=
name|XEXP
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|!=
name|REG
operator|||
operator|(
name|REGNO_POINTER_ALIGN
argument_list|(
name|REGNO
argument_list|(
name|base
argument_list|)
argument_list|)
operator|<
name|outer_size
operator|*
name|BITS_PER_UNIT
operator|)
condition|)
return|return
name|x
return|;
block|}
name|find_reloads_address
argument_list|(
name|GET_MODE
argument_list|(
name|tem
argument_list|)
argument_list|,
operator|&
name|tem
argument_list|,
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|opnum
argument_list|,
name|ADDR_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|ind_levels
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* If this is not a toplevel operand, find_reloads doesn't see 		 this substitution.  We have to emit a USE of the pseudo so 		 that delete_output_reload can see it.  */
if|if
condition|(
name|replace_reloads
operator|&&
name|recog_data
operator|.
name|operand
index|[
name|opnum
index|]
operator|!=
name|x
condition|)
comment|/* We mark the USE with QImode so that we recognize it 		   as one that can be safely deleted at the end of 		   reload.  */
name|PUT_MODE
argument_list|(
name|emit_insn_before
argument_list|(
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|)
argument_list|,
name|QImode
argument_list|)
expr_stmt|;
name|x
operator|=
name|tem
expr_stmt|;
block|}
block|}
block|}
return|return
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Substitute into the current INSN the registers into which we have reloaded    the things that need reloading.  The array `replacements'    contains the locations of all pointers that must be changed    and says what to replace them with.     Return the rtx that X translates into; usually X, but modified.  */
end_comment

begin_function
name|void
name|subst_reloads
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_replacements
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|replacement
modifier|*
name|r
init|=
operator|&
name|replacements
index|[
name|i
index|]
decl_stmt|;
name|rtx
name|reloadreg
init|=
name|rld
index|[
name|r
operator|->
name|what
index|]
operator|.
name|reg_rtx
decl_stmt|;
if|if
condition|(
name|reloadreg
condition|)
block|{
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
comment|/* Internal consistency test.  Check that we don't modify 	     anything in the equivalence arrays.  Whenever something from 	     those arrays needs to be reloaded, it must be unshared before 	     being substituted into; the equivalence must not be modified. 	     Otherwise, if the equivalence is used after that, it will 	     have been modified, and the thing substituted (probably a 	     register) is likely overwritten and not a usable equivalence.  */
name|int
name|check_regno
decl_stmt|;
for|for
control|(
name|check_regno
operator|=
literal|0
init|;
name|check_regno
operator|<
name|max_regno
condition|;
name|check_regno
operator|++
control|)
block|{
define|#
directive|define
name|CHECK_MODF
parameter_list|(
name|ARRAY
parameter_list|)
define|\
value|if (ARRAY[check_regno]					\&& loc_mentioned_in_p (r->where,			\ 					 ARRAY[check_regno]))		\ 		abort ()
name|CHECK_MODF
argument_list|(
name|reg_equiv_constant
argument_list|)
expr_stmt|;
name|CHECK_MODF
argument_list|(
name|reg_equiv_memory_loc
argument_list|)
expr_stmt|;
name|CHECK_MODF
argument_list|(
name|reg_equiv_address
argument_list|)
expr_stmt|;
name|CHECK_MODF
argument_list|(
name|reg_equiv_mem
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|CHECK_MODF
block|}
endif|#
directive|endif
comment|/* ENABLE_CHECKING */
comment|/* If we're replacing a LABEL_REF with a register, add a 	     REG_LABEL note to indicate to flow which label this 	     register refers to.  */
if|if
condition|(
name|GET_CODE
argument_list|(
operator|*
name|r
operator|->
name|where
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_INSN_LIST
argument_list|(
name|REG_LABEL
argument_list|,
name|XEXP
argument_list|(
operator|*
name|r
operator|->
name|where
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Encapsulate RELOADREG so its machine mode matches what 	     used to be there.  Note that gen_lowpart_common will 	     do the wrong thing if RELOADREG is multi-word.  RELOADREG 	     will always be a REG here.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|reloadreg
argument_list|)
operator|!=
name|r
operator|->
name|mode
operator|&&
name|r
operator|->
name|mode
operator|!=
name|VOIDmode
condition|)
name|reloadreg
operator|=
name|gen_rtx_REG
argument_list|(
name|r
operator|->
name|mode
argument_list|,
name|REGNO
argument_list|(
name|reloadreg
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we are putting this into a SUBREG and RELOADREG is a 	     SUBREG, we would be making nested SUBREGs, so we have to fix 	     this up.  Note that r->where ==&SUBREG_REG (*r->subreg_loc).  */
if|if
condition|(
name|r
operator|->
name|subreg_loc
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|reloadreg
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
operator|*
name|r
operator|->
name|subreg_loc
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|reloadreg
argument_list|)
argument_list|)
condition|)
operator|*
name|r
operator|->
name|subreg_loc
operator|=
name|SUBREG_REG
argument_list|(
name|reloadreg
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|final_offset
init|=
name|SUBREG_BYTE
argument_list|(
operator|*
name|r
operator|->
name|subreg_loc
argument_list|)
operator|+
name|SUBREG_BYTE
argument_list|(
name|reloadreg
argument_list|)
decl_stmt|;
comment|/* When working with SUBREGs the rule is that the byte 		     offset must be a multiple of the SUBREG's mode.  */
name|final_offset
operator|=
operator|(
name|final_offset
operator|/
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
operator|*
name|r
operator|->
name|subreg_loc
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|final_offset
operator|=
operator|(
name|final_offset
operator|*
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
operator|*
name|r
operator|->
name|subreg_loc
argument_list|)
argument_list|)
operator|)
expr_stmt|;
operator|*
name|r
operator|->
name|where
operator|=
name|SUBREG_REG
argument_list|(
name|reloadreg
argument_list|)
expr_stmt|;
name|SUBREG_BYTE
argument_list|(
operator|*
name|r
operator|->
name|subreg_loc
argument_list|)
operator|=
name|final_offset
expr_stmt|;
block|}
block|}
else|else
operator|*
name|r
operator|->
name|where
operator|=
name|reloadreg
expr_stmt|;
block|}
comment|/* If reload got no reg and isn't optional, something's wrong.  */
elseif|else
if|if
condition|(
operator|!
name|rld
index|[
name|r
operator|->
name|what
index|]
operator|.
name|optional
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make a copy of any replacements being done into X and move those    copies to locations in Y, a copy of X.  */
end_comment

begin_function
name|void
name|copy_replacements
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
comment|/* We can't support X being a SUBREG because we might then need to know its      location if something inside it was replaced.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
condition|)
name|abort
argument_list|()
expr_stmt|;
name|copy_replacements_1
argument_list|(
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|,
name|n_replacements
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|copy_replacements_1
parameter_list|(
name|px
parameter_list|,
name|py
parameter_list|,
name|orig_replacements
parameter_list|)
name|rtx
modifier|*
name|px
decl_stmt|;
name|rtx
modifier|*
name|py
decl_stmt|;
name|int
name|orig_replacements
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
name|struct
name|replacement
modifier|*
name|r
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|orig_replacements
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|replacements
index|[
name|j
index|]
operator|.
name|subreg_loc
operator|==
name|px
condition|)
block|{
name|r
operator|=
operator|&
name|replacements
index|[
name|n_replacements
operator|++
index|]
expr_stmt|;
name|r
operator|->
name|where
operator|=
name|replacements
index|[
name|j
index|]
operator|.
name|where
expr_stmt|;
name|r
operator|->
name|subreg_loc
operator|=
name|py
expr_stmt|;
name|r
operator|->
name|what
operator|=
name|replacements
index|[
name|j
index|]
operator|.
name|what
expr_stmt|;
name|r
operator|->
name|mode
operator|=
name|replacements
index|[
name|j
index|]
operator|.
name|mode
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|replacements
index|[
name|j
index|]
operator|.
name|where
operator|==
name|px
condition|)
block|{
name|r
operator|=
operator|&
name|replacements
index|[
name|n_replacements
operator|++
index|]
expr_stmt|;
name|r
operator|->
name|where
operator|=
name|py
expr_stmt|;
name|r
operator|->
name|subreg_loc
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|what
operator|=
name|replacements
index|[
name|j
index|]
operator|.
name|what
expr_stmt|;
name|r
operator|->
name|mode
operator|=
name|replacements
index|[
name|j
index|]
operator|.
name|mode
expr_stmt|;
block|}
block|}
name|x
operator|=
operator|*
name|px
expr_stmt|;
name|y
operator|=
operator|*
name|py
expr_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|copy_replacements_1
argument_list|(
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
operator|&
name|XEXP
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
argument_list|,
name|orig_replacements
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
init|;
operator|--
name|j
operator|>=
literal|0
condition|;
control|)
name|copy_replacements_1
argument_list|(
operator|&
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
operator|&
name|XVECEXP
argument_list|(
name|y
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|orig_replacements
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Change any replacements being done to *X to be done to *Y */
end_comment

begin_function
name|void
name|move_replacements
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|rtx
modifier|*
name|x
decl_stmt|;
name|rtx
modifier|*
name|y
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_replacements
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|replacements
index|[
name|i
index|]
operator|.
name|subreg_loc
operator|==
name|x
condition|)
name|replacements
index|[
name|i
index|]
operator|.
name|subreg_loc
operator|=
name|y
expr_stmt|;
elseif|else
if|if
condition|(
name|replacements
index|[
name|i
index|]
operator|.
name|where
operator|==
name|x
condition|)
block|{
name|replacements
index|[
name|i
index|]
operator|.
name|where
operator|=
name|y
expr_stmt|;
name|replacements
index|[
name|i
index|]
operator|.
name|subreg_loc
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If LOC was scheduled to be replaced by something, return the replacement.    Otherwise, return *LOC.  */
end_comment

begin_function
name|rtx
name|find_replacement
parameter_list|(
name|loc
parameter_list|)
name|rtx
modifier|*
name|loc
decl_stmt|;
block|{
name|struct
name|replacement
modifier|*
name|r
decl_stmt|;
for|for
control|(
name|r
operator|=
operator|&
name|replacements
index|[
literal|0
index|]
init|;
name|r
operator|<
operator|&
name|replacements
index|[
name|n_replacements
index|]
condition|;
name|r
operator|++
control|)
block|{
name|rtx
name|reloadreg
init|=
name|rld
index|[
name|r
operator|->
name|what
index|]
operator|.
name|reg_rtx
decl_stmt|;
if|if
condition|(
name|reloadreg
operator|&&
name|r
operator|->
name|where
operator|==
name|loc
condition|)
block|{
if|if
condition|(
name|r
operator|->
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|reloadreg
argument_list|)
operator|!=
name|r
operator|->
name|mode
condition|)
name|reloadreg
operator|=
name|gen_rtx_REG
argument_list|(
name|r
operator|->
name|mode
argument_list|,
name|REGNO
argument_list|(
name|reloadreg
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|reloadreg
return|;
block|}
elseif|else
if|if
condition|(
name|reloadreg
operator|&&
name|r
operator|->
name|subreg_loc
operator|==
name|loc
condition|)
block|{
comment|/* RELOADREG must be either a REG or a SUBREG.  	     ??? Is it actually still ever a SUBREG?  If so, why?  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|reloadreg
argument_list|)
operator|==
name|REG
condition|)
return|return
name|gen_rtx_REG
argument_list|(
name|GET_MODE
argument_list|(
operator|*
name|loc
argument_list|)
argument_list|,
operator|(
name|REGNO
argument_list|(
name|reloadreg
argument_list|)
operator|+
name|subreg_regno_offset
argument_list|(
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
operator|*
name|loc
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
operator|*
name|loc
argument_list|)
argument_list|)
argument_list|,
name|SUBREG_BYTE
argument_list|(
operator|*
name|loc
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
operator|*
name|loc
argument_list|)
argument_list|)
operator|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|reloadreg
argument_list|)
operator|==
name|GET_MODE
argument_list|(
operator|*
name|loc
argument_list|)
condition|)
return|return
name|reloadreg
return|;
else|else
block|{
name|int
name|final_offset
init|=
name|SUBREG_BYTE
argument_list|(
name|reloadreg
argument_list|)
operator|+
name|SUBREG_BYTE
argument_list|(
operator|*
name|loc
argument_list|)
decl_stmt|;
comment|/* When working with SUBREGs the rule is that the byte 		 offset must be a multiple of the SUBREG's mode.  */
name|final_offset
operator|=
operator|(
name|final_offset
operator|/
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
operator|*
name|loc
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|final_offset
operator|=
operator|(
name|final_offset
operator|*
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
operator|*
name|loc
argument_list|)
argument_list|)
operator|)
expr_stmt|;
return|return
name|gen_rtx_SUBREG
argument_list|(
name|GET_MODE
argument_list|(
operator|*
name|loc
argument_list|)
argument_list|,
name|SUBREG_REG
argument_list|(
name|reloadreg
argument_list|)
argument_list|,
name|final_offset
argument_list|)
return|;
block|}
block|}
block|}
comment|/* If *LOC is a PLUS, MINUS, or MULT, see if a replacement is scheduled for      what's inside and make a new rtl if so.  */
if|if
condition|(
name|GET_CODE
argument_list|(
operator|*
name|loc
argument_list|)
operator|==
name|PLUS
operator|||
name|GET_CODE
argument_list|(
operator|*
name|loc
argument_list|)
operator|==
name|MINUS
operator|||
name|GET_CODE
argument_list|(
operator|*
name|loc
argument_list|)
operator|==
name|MULT
condition|)
block|{
name|rtx
name|x
init|=
name|find_replacement
argument_list|(
operator|&
name|XEXP
argument_list|(
operator|*
name|loc
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|y
init|=
name|find_replacement
argument_list|(
operator|&
name|XEXP
argument_list|(
operator|*
name|loc
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|x
operator|!=
name|XEXP
argument_list|(
operator|*
name|loc
argument_list|,
literal|0
argument_list|)
operator|||
name|y
operator|!=
name|XEXP
argument_list|(
operator|*
name|loc
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|gen_rtx_fmt_ee
argument_list|(
name|GET_CODE
argument_list|(
operator|*
name|loc
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
operator|*
name|loc
argument_list|)
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
return|;
block|}
return|return
operator|*
name|loc
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if register in range [REGNO, ENDREGNO)    appears either explicitly or implicitly in X    other than being stored into (except for earlyclobber operands).     References contained within the substructure at LOC do not count.    LOC may be zero, meaning don't ignore anything.     This is similar to refers_to_regno_p in rtlanal.c except that we    look at equivalences for pseudos that didn't get hard registers.  */
end_comment

begin_function
name|int
name|refers_to_regno_for_reload_p
parameter_list|(
name|regno
parameter_list|,
name|endregno
parameter_list|,
name|x
parameter_list|,
name|loc
parameter_list|)
name|unsigned
name|int
name|regno
decl_stmt|,
name|endregno
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|rtx
modifier|*
name|loc
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|r
decl_stmt|;
name|RTX_CODE
name|code
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|repeat
label|:
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
name|r
operator|=
name|REGNO
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* If this is a pseudo, a hard register must not have been allocated. 	 X must therefore either be a constant or be in memory.  */
if|if
condition|(
name|r
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
if|if
condition|(
name|reg_equiv_memory_loc
index|[
name|r
index|]
condition|)
return|return
name|refers_to_regno_for_reload_p
argument_list|(
name|regno
argument_list|,
name|endregno
argument_list|,
name|reg_equiv_memory_loc
index|[
name|r
index|]
argument_list|,
operator|(
name|rtx
operator|*
operator|)
literal|0
argument_list|)
return|;
if|if
condition|(
name|reg_equiv_constant
index|[
name|r
index|]
condition|)
return|return
literal|0
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|endregno
operator|>
name|r
operator|&&
name|regno
operator|<
name|r
operator|+
operator|(
name|r
operator|<
name|FIRST_PSEUDO_REGISTER
condition|?
name|HARD_REGNO_NREGS
argument_list|(
name|r
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
else|:
literal|1
operator|)
operator|)
return|;
case|case
name|SUBREG
case|:
comment|/* If this is a SUBREG of a hard reg, we can see exactly which 	 registers are being modified.  Otherwise, handle normally.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|unsigned
name|int
name|inner_regno
init|=
name|subreg_regno
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|inner_endregno
init|=
name|inner_regno
operator|+
operator|(
name|inner_regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|?
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
else|:
literal|1
operator|)
decl_stmt|;
return|return
name|endregno
operator|>
name|inner_regno
operator|&&
name|regno
operator|<
name|inner_endregno
return|;
block|}
break|break;
case|case
name|CLOBBER
case|:
case|case
name|SET
case|:
if|if
condition|(
operator|&
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|!=
name|loc
comment|/* Note setting a SUBREG counts as referring to the REG it is in for 	     a pseudo but not for hard registers since we can 	     treat each word individually.  */
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|loc
operator|!=
operator|&
name|SUBREG_REG
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|refers_to_regno_for_reload_p
argument_list|(
name|regno
argument_list|,
name|endregno
argument_list|,
name|SUBREG_REG
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|loc
argument_list|)
operator|)
comment|/* If the output is an earlyclobber operand, this is 		 a conflict.  */
operator|||
operator|(
operator|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|earlyclobber_operand_p
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
operator|&&
name|refers_to_regno_for_reload_p
argument_list|(
name|regno
argument_list|,
name|endregno
argument_list|,
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|loc
argument_list|)
operator|)
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|code
operator|==
name|CLOBBER
operator|||
name|loc
operator|==
operator|&
name|SET_SRC
argument_list|(
name|x
argument_list|)
condition|)
return|return
literal|0
return|;
name|x
operator|=
name|SET_SRC
argument_list|(
name|x
argument_list|)
expr_stmt|;
goto|goto
name|repeat
goto|;
default|default:
break|break;
block|}
comment|/* X does not match, so try its subexpressions.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|&&
name|loc
operator|!=
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|repeat
goto|;
block|}
elseif|else
if|if
condition|(
name|refers_to_regno_for_reload_p
argument_list|(
name|regno
argument_list|,
name|endregno
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|loc
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|loc
operator|!=
operator|&
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
operator|&&
name|refers_to_regno_for_reload_p
argument_list|(
name|regno
argument_list|,
name|endregno
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|loc
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Nonzero if modifying X will affect IN.  If X is a register or a SUBREG,    we check if any register number in X conflicts with the relevant register    numbers.  If X is a constant, return 0.  If X is a MEM, return 1 iff IN    contains a MEM (we don't bother checking for memory addresses that can't    conflict because we expect this to be a rare case.     This function is similar to reg_overlap_mentioned_p in rtlanal.c except    that we look at equivalences for pseudos that didn't get hard registers.  */
end_comment

begin_function
name|int
name|reg_overlap_mentioned_for_reload_p
parameter_list|(
name|x
parameter_list|,
name|in
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|in
decl_stmt|;
block|{
name|int
name|regno
decl_stmt|,
name|endregno
decl_stmt|;
comment|/* Overly conservative.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
literal|'a'
condition|)
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If either argument is a constant, then modifying X can not affect IN.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
operator|||
name|CONSTANT_P
argument_list|(
name|in
argument_list|)
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|regno
operator|=
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|regno
operator|+=
name|subreg_regno_offset
argument_list|(
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|SUBREG_BYTE
argument_list|(
name|x
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
block|{
name|regno
operator|=
name|REGNO
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* If this is a pseudo, it must not have been assigned a hard register. 	 Therefore, it must either be in memory or be a constant.  */
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
if|if
condition|(
name|reg_equiv_memory_loc
index|[
name|regno
index|]
condition|)
return|return
name|refers_to_mem_for_reload_p
argument_list|(
name|in
argument_list|)
return|;
elseif|else
if|if
condition|(
name|reg_equiv_constant
index|[
name|regno
index|]
condition|)
return|return
literal|0
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
return|return
name|refers_to_mem_for_reload_p
argument_list|(
name|in
argument_list|)
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SCRATCH
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PC
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CC0
condition|)
return|return
name|reg_mentioned_p
argument_list|(
name|x
argument_list|,
name|in
argument_list|)
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
condition|)
return|return
operator|(
name|reg_overlap_mentioned_for_reload_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|in
argument_list|)
operator|||
name|reg_overlap_mentioned_for_reload_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|in
argument_list|)
operator|)
return|;
else|else
name|abort
argument_list|()
expr_stmt|;
name|endregno
operator|=
name|regno
operator|+
operator|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|?
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
else|:
literal|1
operator|)
expr_stmt|;
return|return
name|refers_to_regno_for_reload_p
argument_list|(
name|regno
argument_list|,
name|endregno
argument_list|,
name|in
argument_list|,
operator|(
name|rtx
operator|*
operator|)
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if anything in X contains a MEM.  Look also for pseudo    registers.  */
end_comment

begin_function
name|int
name|refers_to_mem_for_reload_p
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
return|return
operator|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|reg_equiv_memory_loc
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
operator|)
return|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|MEM
operator|||
name|refers_to_mem_for_reload_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
operator|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Check the insns before INSN to see if there is a suitable register    containing the same value as GOAL.    If OTHER is -1, look for a register in class CLASS.    Otherwise, just see if register number OTHER shares GOAL's value.     Return an rtx for the register found, or zero if none is found.     If RELOAD_REG_P is (short *)1,    we reject any hard reg that appears in reload_reg_rtx    because such a hard reg is also needed coming into this insn.     If RELOAD_REG_P is any other nonzero value,    it is a vector indexed by hard reg number    and we reject any hard reg whose element in the vector is nonnegative    as well as any that appears in reload_reg_rtx.     If GOAL is zero, then GOALREG is a register number; we look    for an equivalent for that register.     MODE is the machine mode of the value we want an equivalence for.    If GOAL is nonzero and not VOIDmode, then it must have mode MODE.     This function is used by jump.c as well as in the reload pass.     If GOAL is the sum of the stack pointer and a constant, we treat it    as if it were a constant except that sp is required to be unchanging.  */
end_comment

begin_function
name|rtx
name|find_equiv_reg
parameter_list|(
name|goal
parameter_list|,
name|insn
parameter_list|,
name|class
parameter_list|,
name|other
parameter_list|,
name|reload_reg_p
parameter_list|,
name|goalreg
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|goal
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|enum
name|reg_class
name|class
decl_stmt|;
name|int
name|other
decl_stmt|;
name|short
modifier|*
name|reload_reg_p
decl_stmt|;
name|int
name|goalreg
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|rtx
name|p
init|=
name|insn
decl_stmt|;
name|rtx
name|goaltry
decl_stmt|,
name|valtry
decl_stmt|,
name|value
decl_stmt|,
name|where
decl_stmt|;
name|rtx
name|pat
decl_stmt|;
name|int
name|regno
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|valueno
decl_stmt|;
name|int
name|goal_mem
init|=
literal|0
decl_stmt|;
name|int
name|goal_const
init|=
literal|0
decl_stmt|;
name|int
name|goal_mem_addr_varies
init|=
literal|0
decl_stmt|;
name|int
name|need_stable_sp
init|=
literal|0
decl_stmt|;
name|int
name|nregs
decl_stmt|;
name|int
name|valuenregs
decl_stmt|;
if|if
condition|(
name|goal
operator|==
literal|0
condition|)
name|regno
operator|=
name|goalreg
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|goal
argument_list|)
operator|==
name|REG
condition|)
name|regno
operator|=
name|REGNO
argument_list|(
name|goal
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|goal
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|goal
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|goal
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|flag_float_store
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|goal
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
return|return
literal|0
return|;
comment|/* An address with side effects must be reexecuted.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|POST_INC
case|:
case|case
name|PRE_INC
case|:
case|case
name|POST_DEC
case|:
case|case
name|PRE_DEC
case|:
case|case
name|POST_MODIFY
case|:
case|case
name|PRE_MODIFY
case|:
return|return
literal|0
return|;
default|default:
break|break;
block|}
name|goal_mem
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|goal
argument_list|)
condition|)
name|goal_const
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|goal
argument_list|)
operator|==
name|PLUS
operator|&&
name|XEXP
argument_list|(
name|goal
argument_list|,
literal|0
argument_list|)
operator|==
name|stack_pointer_rtx
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|goal
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|goal_const
operator|=
name|need_stable_sp
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|goal
argument_list|)
operator|==
name|PLUS
operator|&&
name|XEXP
argument_list|(
name|goal
argument_list|,
literal|0
argument_list|)
operator|==
name|frame_pointer_rtx
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|goal
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|goal_const
operator|=
literal|1
expr_stmt|;
else|else
return|return
literal|0
return|;
comment|/* Scan insns back from INSN, looking for one that copies      a value into or out of GOAL.      Stop and give up if we reach a label.  */
while|while
condition|(
literal|1
condition|)
block|{
name|p
operator|=
name|PREV_INSN
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CODE_LABEL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|INSN
comment|/* If we don't want spill regs ...  */
operator|&&
operator|(
operator|!
operator|(
name|reload_reg_p
operator|!=
literal|0
operator|&&
name|reload_reg_p
operator|!=
operator|(
name|short
operator|*
operator|)
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|)
comment|/* ... then ignore insns introduced by reload; they aren't 		 useful and can cause results in reload_as_needed to be 		 different from what they were when calculating the need for 		 spills.  If we notice an input-reload insn here, we will 		 reject it below, but it might hide a usable equivalent. 		 That makes bad code.  It may even abort: perhaps no reg was 		 spilled for this insn because it was assumed we would find 		 that equivalent.  */
operator|||
name|INSN_UID
argument_list|(
name|p
argument_list|)
operator|<
name|reload_first_uid
operator|)
condition|)
block|{
name|rtx
name|tem
decl_stmt|;
name|pat
operator|=
name|single_set
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* First check for something that sets some reg equal to GOAL.  */
if|if
condition|(
name|pat
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|regno
operator|>=
literal|0
operator|&&
name|true_regnum
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|==
name|regno
operator|&&
operator|(
name|valueno
operator|=
name|true_regnum
argument_list|(
name|valtry
operator|=
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|)
operator|>=
literal|0
operator|)
operator|||
operator|(
name|regno
operator|>=
literal|0
operator|&&
name|true_regnum
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|==
name|regno
operator|&&
operator|(
name|valueno
operator|=
name|true_regnum
argument_list|(
name|valtry
operator|=
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|)
operator|>=
literal|0
operator|)
operator|||
operator|(
name|goal_const
operator|&&
name|rtx_equal_p
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
name|goal
argument_list|)
comment|/* When looking for stack pointer + const, 		      make sure we don't use a stack adjust.  */
operator|&&
operator|!
name|reg_overlap_mentioned_for_reload_p
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|,
name|goal
argument_list|)
operator|&&
operator|(
name|valueno
operator|=
name|true_regnum
argument_list|(
name|valtry
operator|=
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|)
operator|>=
literal|0
operator|)
operator|||
operator|(
name|goal_mem
operator|&&
operator|(
name|valueno
operator|=
name|true_regnum
argument_list|(
name|valtry
operator|=
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|)
operator|>=
literal|0
operator|&&
name|rtx_renumbered_equal_p
argument_list|(
name|goal
argument_list|,
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|goal_mem
operator|&&
operator|(
name|valueno
operator|=
name|true_regnum
argument_list|(
name|valtry
operator|=
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|)
operator|>=
literal|0
operator|&&
name|rtx_renumbered_equal_p
argument_list|(
name|goal
argument_list|,
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|)
comment|/* If we are looking for a constant, 		     and something equivalent to that constant was copied 		     into a reg, we can use that reg.  */
operator|||
operator|(
name|goal_const
operator|&&
name|REG_NOTES
argument_list|(
name|p
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|tem
operator|=
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_EQUIV
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|goal
argument_list|)
operator|&&
operator|(
name|valueno
operator|=
name|true_regnum
argument_list|(
name|valtry
operator|=
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|)
operator|>=
literal|0
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
operator|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|goal
argument_list|)
operator|==
name|CONST_INT
operator|&&
literal|0
operator|!=
operator|(
name|goaltry
operator|=
name|operand_subword
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|)
operator|)
operator|&&
name|rtx_equal_p
argument_list|(
name|goal
argument_list|,
name|goaltry
argument_list|)
operator|&&
operator|(
name|valtry
operator|=
name|operand_subword
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|)
operator|)
operator|&&
operator|(
name|valueno
operator|=
name|true_regnum
argument_list|(
name|valtry
argument_list|)
operator|)
operator|>=
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|goal_const
operator|&&
operator|(
name|tem
operator|=
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_EQUIV
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
operator|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|goal
argument_list|)
operator|==
name|CONST_INT
operator|&&
literal|0
operator|!=
operator|(
name|goaltry
operator|=
name|operand_subword
argument_list|(
name|XEXP
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|)
operator|)
operator|&&
name|rtx_equal_p
argument_list|(
name|goal
argument_list|,
name|goaltry
argument_list|)
operator|&&
operator|(
name|valtry
operator|=
name|operand_subword
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|)
operator|)
operator|&&
operator|(
name|valueno
operator|=
name|true_regnum
argument_list|(
name|valtry
argument_list|)
operator|)
operator|>=
literal|0
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|other
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|valueno
operator|!=
name|other
condition|)
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|(
name|unsigned
operator|)
name|valueno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
continue|continue;
else|else
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|valueno
argument_list|,
name|mode
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|class
index|]
argument_list|,
name|valueno
operator|+
name|i
argument_list|)
condition|)
break|break;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
continue|continue;
block|}
name|value
operator|=
name|valtry
expr_stmt|;
name|where
operator|=
name|p
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* We found a previous insn copying GOAL into a suitable other reg VALUE      (or copying VALUE into GOAL, if GOAL is also a register).      Now verify that VALUE is really valid.  */
comment|/* VALUENO is the register number of VALUE; a hard register.  */
comment|/* Don't try to re-use something that is killed in this insn.  We want      to be able to trust REG_UNUSED notes.  */
if|if
condition|(
name|REG_NOTES
argument_list|(
name|where
argument_list|)
operator|!=
literal|0
operator|&&
name|find_reg_note
argument_list|(
name|where
argument_list|,
name|REG_UNUSED
argument_list|,
name|value
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* If we propose to get the value from the stack pointer or if GOAL is      a MEM based on the stack pointer, we need a stable SP.  */
if|if
condition|(
name|valueno
operator|==
name|STACK_POINTER_REGNUM
operator|||
name|regno
operator|==
name|STACK_POINTER_REGNUM
operator|||
operator|(
name|goal_mem
operator|&&
name|reg_overlap_mentioned_for_reload_p
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|goal
argument_list|)
operator|)
condition|)
name|need_stable_sp
operator|=
literal|1
expr_stmt|;
comment|/* Reject VALUE if the copy-insn moved the wrong sort of datum.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
operator|!=
name|mode
condition|)
return|return
literal|0
return|;
comment|/* Reject VALUE if it was loaded from GOAL      and is also a register that appears in the address of GOAL.  */
if|if
condition|(
name|goal_mem
operator|&&
name|value
operator|==
name|SET_DEST
argument_list|(
name|single_set
argument_list|(
name|where
argument_list|)
argument_list|)
operator|&&
name|refers_to_regno_for_reload_p
argument_list|(
name|valueno
argument_list|,
operator|(
name|valueno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|valueno
argument_list|,
name|mode
argument_list|)
operator|)
argument_list|,
name|goal
argument_list|,
operator|(
name|rtx
operator|*
operator|)
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Reject registers that overlap GOAL.  */
if|if
condition|(
operator|!
name|goal_mem
operator|&&
operator|!
name|goal_const
operator|&&
name|regno
operator|+
operator|(
name|int
operator|)
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
operator|>
name|valueno
operator|&&
name|regno
operator|<
name|valueno
operator|+
operator|(
name|int
operator|)
name|HARD_REGNO_NREGS
argument_list|(
name|valueno
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|0
return|;
name|nregs
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|valuenregs
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|valueno
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/* Reject VALUE if it is one of the regs reserved for reloads.      Reload1 knows how to reuse them anyway, and it would get      confused if we allocated one without its knowledge.      (Now that insns introduced by reload are ignored above,      this case shouldn't happen, but I'm not positive.)  */
if|if
condition|(
name|reload_reg_p
operator|!=
literal|0
operator|&&
name|reload_reg_p
operator|!=
operator|(
name|short
operator|*
operator|)
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|valuenregs
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|reload_reg_p
index|[
name|valueno
operator|+
name|i
index|]
operator|>=
literal|0
condition|)
return|return
literal|0
return|;
block|}
comment|/* Reject VALUE if it is a register being used for an input reload      even if it is not one of those reserved.  */
if|if
condition|(
name|reload_reg_p
operator|!=
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_reloads
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|rld
index|[
name|i
index|]
operator|.
name|reg_rtx
operator|!=
literal|0
operator|&&
name|rld
index|[
name|i
index|]
operator|.
name|in
condition|)
block|{
name|int
name|regno1
init|=
name|REGNO
argument_list|(
name|rld
index|[
name|i
index|]
operator|.
name|reg_rtx
argument_list|)
decl_stmt|;
name|int
name|nregs1
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno1
argument_list|,
name|GET_MODE
argument_list|(
name|rld
index|[
name|i
index|]
operator|.
name|reg_rtx
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|regno1
operator|<
name|valueno
operator|+
name|valuenregs
operator|&&
name|regno1
operator|+
name|nregs1
operator|>
name|valueno
condition|)
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
name|goal_mem
condition|)
comment|/* We must treat frame pointer as varying here,        since it can vary--in a nonlocal goto as generated by expand_goto.  */
name|goal_mem_addr_varies
operator|=
operator|!
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|goal
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now verify that the values of GOAL and VALUE remain unaltered      until INSN is reached.  */
name|p
operator|=
name|insn
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|p
operator|=
name|PREV_INSN
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|where
condition|)
return|return
name|value
return|;
comment|/* Don't trust the conversion past a function call 	 if either of the two is in a call-clobbered register, or memory.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|goal_mem
operator|||
name|need_stable_sp
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|regno
operator|>=
literal|0
operator|&&
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nregs
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|call_used_regs
index|[
name|regno
operator|+
name|i
index|]
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|valueno
operator|>=
literal|0
operator|&&
name|valueno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|valuenregs
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|call_used_regs
index|[
name|valueno
operator|+
name|i
index|]
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|NON_SAVING_SETJMP
if|if
condition|(
name|NON_SAVING_SETJMP
operator|&&
name|find_reg_note
argument_list|(
name|p
argument_list|,
name|REG_SETJMP
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
block|}
if|if
condition|(
name|INSN_P
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|pat
operator|=
name|PATTERN
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* Watch out for unspec_volatile, and volatile asms.  */
if|if
condition|(
name|volatile_insn_p
argument_list|(
name|pat
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* If this insn P stores in either GOAL or VALUE, return 0. 	     If GOAL is a memory ref and this insn writes memory, return 0. 	     If GOAL is a memory ref and its address is not constant, 	     and this insn P changes a register used in GOAL, return 0.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|COND_EXEC
condition|)
name|pat
operator|=
name|COND_EXEC_CODE
argument_list|(
name|pat
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SET
operator|||
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|CLOBBER
condition|)
block|{
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|pat
argument_list|)
decl_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
name|dest
operator|=
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
condition|)
block|{
name|int
name|xregno
init|=
name|REGNO
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|int
name|xnregs
decl_stmt|;
if|if
condition|(
name|REGNO
argument_list|(
name|dest
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|xnregs
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|xregno
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|xnregs
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|xregno
operator|<
name|regno
operator|+
name|nregs
operator|&&
name|xregno
operator|+
name|xnregs
operator|>
name|regno
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|xregno
operator|<
name|valueno
operator|+
name|valuenregs
operator|&&
name|xregno
operator|+
name|xnregs
operator|>
name|valueno
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|goal_mem_addr_varies
operator|&&
name|reg_overlap_mentioned_for_reload_p
argument_list|(
name|dest
argument_list|,
name|goal
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|xregno
operator|==
name|STACK_POINTER_REGNUM
operator|&&
name|need_stable_sp
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|goal_mem
operator|&&
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|push_operand
argument_list|(
name|dest
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|MEM
operator|&&
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|reg_equiv_memory_loc
index|[
name|regno
index|]
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|need_stable_sp
operator|&&
name|push_operand
argument_list|(
name|dest
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|rtx
name|v1
init|=
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|v1
argument_list|)
operator|==
name|COND_EXEC
condition|)
name|v1
operator|=
name|COND_EXEC_CODE
argument_list|(
name|v1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|v1
argument_list|)
operator|==
name|SET
operator|||
name|GET_CODE
argument_list|(
name|v1
argument_list|)
operator|==
name|CLOBBER
condition|)
block|{
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|v1
argument_list|)
decl_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
name|dest
operator|=
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
condition|)
block|{
name|int
name|xregno
init|=
name|REGNO
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|int
name|xnregs
decl_stmt|;
if|if
condition|(
name|REGNO
argument_list|(
name|dest
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|xnregs
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|xregno
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|xnregs
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|xregno
operator|<
name|regno
operator|+
name|nregs
operator|&&
name|xregno
operator|+
name|xnregs
operator|>
name|regno
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|xregno
operator|<
name|valueno
operator|+
name|valuenregs
operator|&&
name|xregno
operator|+
name|xnregs
operator|>
name|valueno
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|goal_mem_addr_varies
operator|&&
name|reg_overlap_mentioned_for_reload_p
argument_list|(
name|dest
argument_list|,
name|goal
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|xregno
operator|==
name|STACK_POINTER_REGNUM
operator|&&
name|need_stable_sp
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|goal_mem
operator|&&
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|push_operand
argument_list|(
name|dest
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|MEM
operator|&&
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|reg_equiv_memory_loc
index|[
name|regno
index|]
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|need_stable_sp
operator|&&
name|push_operand
argument_list|(
name|dest
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
block|}
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|CALL_INSN
operator|&&
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|rtx
name|link
decl_stmt|;
for|for
control|(
name|link
operator|=
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|p
argument_list|)
init|;
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
operator|!=
literal|0
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|pat
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|CLOBBER
condition|)
block|{
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|pat
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
condition|)
block|{
name|int
name|xregno
init|=
name|REGNO
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|int
name|xnregs
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|xregno
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|xregno
operator|<
name|regno
operator|+
name|nregs
operator|&&
name|xregno
operator|+
name|xnregs
operator|>
name|regno
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|xregno
operator|<
name|valueno
operator|+
name|valuenregs
operator|&&
name|xregno
operator|+
name|xnregs
operator|>
name|valueno
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|goal_mem_addr_varies
operator|&&
name|reg_overlap_mentioned_for_reload_p
argument_list|(
name|dest
argument_list|,
name|goal
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|goal_mem
operator|&&
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|push_operand
argument_list|(
name|dest
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|need_stable_sp
operator|&&
name|push_operand
argument_list|(
name|dest
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|AUTO_INC_DEC
comment|/* If this insn auto-increments or auto-decrements 	     either regno or valueno, return 0 now. 	     If GOAL is a memory ref and its address is not constant, 	     and this insn P increments a register used in GOAL, return 0.  */
block|{
name|rtx
name|link
decl_stmt|;
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|p
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_INC
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|int
name|incno
init|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|incno
operator|<
name|regno
operator|+
name|nregs
operator|&&
name|incno
operator|>=
name|regno
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|incno
operator|<
name|valueno
operator|+
name|valuenregs
operator|&&
name|incno
operator|>=
name|valueno
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|goal_mem_addr_varies
operator|&&
name|reg_overlap_mentioned_for_reload_p
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|,
name|goal
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
block|}
endif|#
directive|endif
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find a place where INCED appears in an increment or decrement operator    within X, and return the amount INCED is incremented or decremented by.    The value is always positive.  */
end_comment

begin_function
specifier|static
name|int
name|find_inc_amount
parameter_list|(
name|x
parameter_list|,
name|inced
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|inced
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|MEM
condition|)
block|{
name|rtx
name|addr
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PRE_DEC
operator|||
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|POST_DEC
operator|||
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PRE_INC
operator|||
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|POST_INC
operator|)
operator|&&
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
operator|==
name|inced
condition|)
return|return
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PRE_MODIFY
operator|||
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|POST_MODIFY
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
operator|==
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|&&
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
operator|==
name|inced
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|i
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|i
operator|<
literal|0
condition|?
operator|-
name|i
else|:
name|i
return|;
block|}
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
name|int
name|tem
init|=
name|find_inc_amount
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|inced
argument_list|)
decl_stmt|;
if|if
condition|(
name|tem
operator|!=
literal|0
condition|)
return|return
name|tem
return|;
block|}
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|int
name|tem
init|=
name|find_inc_amount
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|inced
argument_list|)
decl_stmt|;
if|if
condition|(
name|tem
operator|!=
literal|0
condition|)
return|return
name|tem
return|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if register REGNO is the subject of a clobber in insn INSN.    If SETS is nonzero, also consider SETs.  */
end_comment

begin_function
name|int
name|regno_clobbered_p
parameter_list|(
name|regno
parameter_list|,
name|insn
parameter_list|,
name|mode
parameter_list|,
name|sets
parameter_list|)
name|unsigned
name|int
name|regno
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|sets
decl_stmt|;
block|{
name|unsigned
name|int
name|nregs
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|endregno
init|=
name|regno
operator|+
name|nregs
decl_stmt|;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
operator|||
operator|(
name|sets
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|unsigned
name|int
name|test
init|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|test
operator|>=
name|regno
operator|&&
name|test
operator|<
name|endregno
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|i
init|=
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
decl_stmt|;
for|for
control|(
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|rtx
name|elt
init|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|elt
argument_list|)
operator|==
name|CLOBBER
operator|||
operator|(
name|sets
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|elt
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|unsigned
name|int
name|test
init|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|elt
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|test
operator|>=
name|regno
operator|&&
name|test
operator|<
name|endregno
condition|)
return|return
literal|1
return|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|reload_when_needed_name
index|[]
init|=
block|{
literal|"RELOAD_FOR_INPUT"
block|,
literal|"RELOAD_FOR_OUTPUT"
block|,
literal|"RELOAD_FOR_INSN"
block|,
literal|"RELOAD_FOR_INPUT_ADDRESS"
block|,
literal|"RELOAD_FOR_INPADDR_ADDRESS"
block|,
literal|"RELOAD_FOR_OUTPUT_ADDRESS"
block|,
literal|"RELOAD_FOR_OUTADDR_ADDRESS"
block|,
literal|"RELOAD_FOR_OPERAND_ADDRESS"
block|,
literal|"RELOAD_FOR_OPADDR_ADDR"
block|,
literal|"RELOAD_OTHER"
block|,
literal|"RELOAD_FOR_OTHER_ADDRESS"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|reg_class_names
index|[]
init|=
name|REG_CLASS_NAMES
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These functions are used to print the variables set by 'find_reloads' */
end_comment

begin_function
name|void
name|debug_reload_to_stream
parameter_list|(
name|f
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
block|{
name|int
name|r
decl_stmt|;
specifier|const
name|char
modifier|*
name|prefix
decl_stmt|;
if|if
condition|(
operator|!
name|f
condition|)
name|f
operator|=
name|stderr
expr_stmt|;
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
name|n_reloads
condition|;
name|r
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"Reload %d: "
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|rld
index|[
name|r
index|]
operator|.
name|in
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"reload_in (%s) = "
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|rld
index|[
name|r
index|]
operator|.
name|inmode
argument_list|)
argument_list|)
expr_stmt|;
name|print_inline_rtx
argument_list|(
name|f
argument_list|,
name|rld
index|[
name|r
index|]
operator|.
name|in
argument_list|,
literal|24
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n\t"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rld
index|[
name|r
index|]
operator|.
name|out
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"reload_out (%s) = "
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|rld
index|[
name|r
index|]
operator|.
name|outmode
argument_list|)
argument_list|)
expr_stmt|;
name|print_inline_rtx
argument_list|(
name|f
argument_list|,
name|rld
index|[
name|r
index|]
operator|.
name|out
argument_list|,
literal|24
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n\t"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s, "
argument_list|,
name|reg_class_names
index|[
operator|(
name|int
operator|)
name|rld
index|[
name|r
index|]
operator|.
name|class
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s (opnum = %d)"
argument_list|,
name|reload_when_needed_name
index|[
operator|(
name|int
operator|)
name|rld
index|[
name|r
index|]
operator|.
name|when_needed
index|]
argument_list|,
name|rld
index|[
name|r
index|]
operator|.
name|opnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|rld
index|[
name|r
index|]
operator|.
name|optional
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|", optional"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rld
index|[
name|r
index|]
operator|.
name|nongroup
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|", nongroup"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rld
index|[
name|r
index|]
operator|.
name|inc
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|", inc by %d"
argument_list|,
name|rld
index|[
name|r
index|]
operator|.
name|inc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rld
index|[
name|r
index|]
operator|.
name|nocombine
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|", can't combine"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rld
index|[
name|r
index|]
operator|.
name|secondary_p
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|", secondary_reload_p"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rld
index|[
name|r
index|]
operator|.
name|in_reg
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n\treload_in_reg: "
argument_list|)
expr_stmt|;
name|print_inline_rtx
argument_list|(
name|f
argument_list|,
name|rld
index|[
name|r
index|]
operator|.
name|in_reg
argument_list|,
literal|24
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rld
index|[
name|r
index|]
operator|.
name|out_reg
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n\treload_out_reg: "
argument_list|)
expr_stmt|;
name|print_inline_rtx
argument_list|(
name|f
argument_list|,
name|rld
index|[
name|r
index|]
operator|.
name|out_reg
argument_list|,
literal|24
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rld
index|[
name|r
index|]
operator|.
name|reg_rtx
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n\treload_reg_rtx: "
argument_list|)
expr_stmt|;
name|print_inline_rtx
argument_list|(
name|f
argument_list|,
name|rld
index|[
name|r
index|]
operator|.
name|reg_rtx
argument_list|,
literal|24
argument_list|)
expr_stmt|;
block|}
name|prefix
operator|=
literal|"\n\t"
expr_stmt|;
if|if
condition|(
name|rld
index|[
name|r
index|]
operator|.
name|secondary_in_reload
operator|!=
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%ssecondary_in_reload = %d"
argument_list|,
name|prefix
argument_list|,
name|rld
index|[
name|r
index|]
operator|.
name|secondary_in_reload
argument_list|)
expr_stmt|;
name|prefix
operator|=
literal|", "
expr_stmt|;
block|}
if|if
condition|(
name|rld
index|[
name|r
index|]
operator|.
name|secondary_out_reload
operator|!=
operator|-
literal|1
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%ssecondary_out_reload = %d\n"
argument_list|,
name|prefix
argument_list|,
name|rld
index|[
name|r
index|]
operator|.
name|secondary_out_reload
argument_list|)
expr_stmt|;
name|prefix
operator|=
literal|"\n\t"
expr_stmt|;
if|if
condition|(
name|rld
index|[
name|r
index|]
operator|.
name|secondary_in_icode
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%ssecondary_in_icode = %s"
argument_list|,
name|prefix
argument_list|,
name|insn_data
index|[
name|rld
index|[
name|r
index|]
operator|.
name|secondary_in_icode
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|prefix
operator|=
literal|", "
expr_stmt|;
block|}
if|if
condition|(
name|rld
index|[
name|r
index|]
operator|.
name|secondary_out_icode
operator|!=
name|CODE_FOR_nothing
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%ssecondary_out_icode = %s"
argument_list|,
name|prefix
argument_list|,
name|insn_data
index|[
name|rld
index|[
name|r
index|]
operator|.
name|secondary_out_icode
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|debug_reload
parameter_list|()
block|{
name|debug_reload_to_stream
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

