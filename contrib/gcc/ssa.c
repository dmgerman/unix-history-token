begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Static Single Assignment conversion routines for the GNU compiler.    Copyright (C) 2000, 2001, 2002 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* References:     Building an Optimizing Compiler    Robert Morgan    Butterworth-Heinemann, 1998     Static Single Assignment Construction    Preston Briggs, Tim Harvey, Taylor Simpson    Technical Report, Rice University, 1995    ftp://ftp.cs.rice.edu/public/preston/optimizer/SSA.ps.gz.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"varray.h"
end_include

begin_include
include|#
directive|include
file|"partition.h"
end_include

begin_include
include|#
directive|include
file|"sbitmap.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"ssa.h"
end_include

begin_comment
comment|/* TODO:      Handle subregs better, maybe.  For now, if a reg that's set in a    subreg expression is duplicated going into SSA form, an extra copy    is inserted first that copies the entire reg into the duplicate, so    that the other bits are preserved.  This isn't strictly SSA, since    at least part of the reg is assigned in more than one place (though    they are adjacent).     ??? What to do about strict_low_part.  Probably I'll have to split    them out of their current instructions first thing.     Actually the best solution may be to have a kind of "mid-level rtl"    in which the RTL encodes exactly what we want, without exposing a    lot of niggling processor details.  At some later point we lower    the representation, calling back into optabs to finish any necessary    expansion.  */
end_comment

begin_comment
comment|/* All pseudo-registers and select hard registers are converted to SSA    form.  When converting out of SSA, these select hard registers are    guaranteed to be mapped to their original register number.  Each    machine's .h file should define CONVERT_HARD_REGISTER_TO_SSA_P    indicating which hard registers should be converted.     When converting out of SSA, temporaries for all registers are    partitioned.  The partition is checked to ensure that all uses of    the same hard register in the same machine mode are in the same    class.  */
end_comment

begin_comment
comment|/* If conservative_reg_partition is non-zero, use a conservative    register partitioning algorithm (which leaves more regs after    emerging from SSA) instead of the coalescing one.  This is being    left in for a limited time only, as a debugging tool until the    coalescing algorithm is validated.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|conservative_reg_partition
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This flag is set when the CFG is in SSA form.  */
end_comment

begin_decl_stmt
name|int
name|in_ssa_form
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Element I is the single instruction that sets register I.  */
end_comment

begin_decl_stmt
name|varray_type
name|ssa_definition
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Element I-PSEUDO is the normal register that originated the ssa    register in question.  */
end_comment

begin_decl_stmt
name|varray_type
name|ssa_rename_from
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Element I is the normal register that originated the ssa    register in question.     A hash table stores the (register, rtl) pairs.  These are each    xmalloc'ed and deleted when the hash table is destroyed.  */
end_comment

begin_decl_stmt
name|htab_t
name|ssa_rename_from_ht
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The running target ssa register for a given pseudo register.    (Pseudo registers appear in only one mode.)  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|ssa_rename_to_pseudo
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Similar, but for hard registers.  A hard register can appear in    many modes, so we store an equivalent pseudo for each of the    modes.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|ssa_rename_to_hard
index|[
name|FIRST_PSEUDO_REGISTER
index|]
index|[
name|NUM_MACHINE_MODES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ssa_rename_from maps pseudo registers to the original corresponding    RTL.  It is implemented as using a hash table.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|unsigned
name|int
name|reg
decl_stmt|;
name|rtx
name|original
decl_stmt|;
block|}
name|ssa_rename_from_pair
typedef|;
end_typedef

begin_struct
struct|struct
name|ssa_rename_from_hash_table_data
block|{
name|sbitmap
name|canonical_elements
decl_stmt|;
name|partition
name|reg_partition
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|void
name|ssa_rename_from_initialize
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|ssa_rename_from_lookup
name|PARAMS
argument_list|(
operator|(
name|int
name|reg
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|original_register
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
name|regno
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ssa_rename_from_insert
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
name|reg
operator|,
name|rtx
name|r
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ssa_rename_from_free
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
name|int
argument_list|(
argument|*srf_trav
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|int
name|regno
operator|,
name|rtx
name|r
operator|,
name|sbitmap
name|canonical_elements
operator|,
name|partition
name|reg_partition
operator|)
argument_list|)
expr_stmt|;
end_typedef

begin_decl_stmt
specifier|static
name|void
name|ssa_rename_from_traverse
name|PARAMS
argument_list|(
operator|(
name|htab_trav
name|callback_function
operator|,
name|sbitmap
name|canonical_elements
operator|,
name|partition
name|reg_partition
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*static Avoid warnign message.  */
end_comment

begin_decl_stmt
name|void
name|ssa_rename_from_print
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ssa_rename_from_print_1
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|*
name|slot
operator|,
name|void
operator|*
name|data
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|hashval_t
name|ssa_rename_from_hash_function
name|PARAMS
argument_list|(
operator|(
specifier|const
name|void
operator|*
name|srfp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ssa_rename_from_equal
name|PARAMS
argument_list|(
operator|(
specifier|const
name|void
operator|*
name|srfp1
operator|,
specifier|const
name|void
operator|*
name|srfp2
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ssa_rename_from_delete
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
name|srfp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|ssa_rename_to_lookup
name|PARAMS
argument_list|(
operator|(
name|rtx
name|reg
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ssa_rename_to_insert
name|PARAMS
argument_list|(
operator|(
name|rtx
name|reg
operator|,
name|rtx
name|r
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of registers that were live on entry to the SSA routines.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|ssa_max_reg_num
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Local function prototypes.  */
end_comment

begin_struct_decl
struct_decl|struct
name|rename_context
struct_decl|;
end_struct_decl

begin_decl_stmt
specifier|static
specifier|inline
name|rtx
modifier|*
name|phi_alternative
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|compute_dominance_frontiers_1
name|PARAMS
argument_list|(
operator|(
name|sbitmap
operator|*
name|frontiers
operator|,
name|int
operator|*
name|idom
operator|,
name|int
name|bb
operator|,
name|sbitmap
name|done
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|find_evaluations_1
name|PARAMS
argument_list|(
operator|(
name|rtx
name|dest
operator|,
name|rtx
name|set
operator|,
name|void
operator|*
name|data
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|find_evaluations
name|PARAMS
argument_list|(
operator|(
name|sbitmap
operator|*
name|evals
operator|,
name|int
name|nregs
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|compute_iterated_dominance_frontiers
name|PARAMS
argument_list|(
operator|(
name|sbitmap
operator|*
name|idfs
operator|,
name|sbitmap
operator|*
name|frontiers
operator|,
name|sbitmap
operator|*
name|evals
operator|,
name|int
name|nregs
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|insert_phi_node
name|PARAMS
argument_list|(
operator|(
name|int
name|regno
operator|,
name|int
name|b
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|insert_phi_nodes
name|PARAMS
argument_list|(
operator|(
name|sbitmap
operator|*
name|idfs
operator|,
name|sbitmap
operator|*
name|evals
operator|,
name|int
name|nregs
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|create_delayed_rename
name|PARAMS
argument_list|(
operator|(
expr|struct
name|rename_context
operator|*
operator|,
name|rtx
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|apply_delayed_renames
name|PARAMS
argument_list|(
operator|(
expr|struct
name|rename_context
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rename_insn_1
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|*
name|ptr
operator|,
name|void
operator|*
name|data
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|rename_block
name|PARAMS
argument_list|(
operator|(
name|int
name|b
operator|,
name|int
operator|*
name|idom
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|rename_registers
name|PARAMS
argument_list|(
operator|(
name|int
name|nregs
operator|,
name|int
operator|*
name|idom
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|int
name|ephi_add_node
name|PARAMS
argument_list|(
operator|(
name|rtx
name|reg
operator|,
name|rtx
operator|*
name|nodes
operator|,
name|int
operator|*
name|n_nodes
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
modifier|*
name|ephi_forward
name|PARAMS
argument_list|(
operator|(
name|int
name|t
operator|,
name|sbitmap
name|visited
operator|,
name|sbitmap
operator|*
name|succ
operator|,
name|int
operator|*
name|tstack
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ephi_backward
name|PARAMS
argument_list|(
operator|(
name|int
name|t
operator|,
name|sbitmap
name|visited
operator|,
name|sbitmap
operator|*
name|pred
operator|,
name|rtx
operator|*
name|nodes
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ephi_create
name|PARAMS
argument_list|(
operator|(
name|int
name|t
operator|,
name|sbitmap
name|visited
operator|,
name|sbitmap
operator|*
name|pred
operator|,
name|sbitmap
operator|*
name|succ
operator|,
name|rtx
operator|*
name|nodes
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|eliminate_phi
name|PARAMS
argument_list|(
operator|(
name|edge
name|e
operator|,
name|partition
name|reg_partition
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|make_regs_equivalent_over_bad_edges
name|PARAMS
argument_list|(
operator|(
name|int
name|bb
operator|,
name|partition
name|reg_partition
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These are used only in the conservative register partitioning    algorithms.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|make_equivalent_phi_alternatives_equivalent
name|PARAMS
argument_list|(
operator|(
name|int
name|bb
operator|,
name|partition
name|reg_partition
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|partition
name|compute_conservative_reg_partition
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|record_canonical_element_1
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|*
name|srfp
operator|,
name|void
operator|*
name|data
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|check_hard_regs_in_partition
name|PARAMS
argument_list|(
operator|(
name|partition
name|reg_partition
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rename_equivalent_regs_in_insn
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|*
name|ptr
operator|,
name|void
operator|*
name|data
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These are used in the register coalescing algorithm.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|coalesce_if_unconflicting
name|PARAMS
argument_list|(
operator|(
name|partition
name|p
operator|,
name|conflict_graph
name|conflicts
operator|,
name|int
name|reg1
operator|,
name|int
name|reg2
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|coalesce_regs_in_copies
name|PARAMS
argument_list|(
operator|(
name|basic_block
name|bb
operator|,
name|partition
name|p
operator|,
name|conflict_graph
name|conflicts
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|coalesce_reg_in_phi
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|int
name|dest_regno
operator|,
name|int
name|src_regno
operator|,
name|void
operator|*
name|data
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|coalesce_regs_in_successor_phi_nodes
name|PARAMS
argument_list|(
operator|(
name|basic_block
name|bb
operator|,
name|partition
name|p
operator|,
name|conflict_graph
name|conflicts
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|partition
name|compute_coalesced_reg_partition
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mark_reg_in_phi
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|*
name|ptr
operator|,
name|void
operator|*
name|data
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_phi_and_copy_regs
name|PARAMS
argument_list|(
operator|(
name|regset
name|phi_set
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rename_equivalent_regs_in_insn
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|*
name|ptr
operator|,
name|void
operator|*
name|data
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|rename_equivalent_regs
name|PARAMS
argument_list|(
operator|(
name|partition
name|reg_partition
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Deal with hard registers.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|conflicting_hard_regs_p
name|PARAMS
argument_list|(
operator|(
name|int
name|reg1
operator|,
name|int
name|reg2
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ssa_rename_to maps registers and machine modes to SSA pseudo registers.  */
end_comment

begin_comment
comment|/* Find the register associated with REG in the indicated mode.  */
end_comment

begin_function
specifier|static
name|rtx
name|ssa_rename_to_lookup
parameter_list|(
name|reg
parameter_list|)
name|rtx
name|reg
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|HARD_REGISTER_P
argument_list|(
name|reg
argument_list|)
condition|)
return|return
name|ssa_rename_to_pseudo
index|[
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|-
name|FIRST_PSEUDO_REGISTER
index|]
return|;
else|else
return|return
name|ssa_rename_to_hard
index|[
name|REGNO
argument_list|(
name|reg
argument_list|)
index|]
index|[
name|GET_MODE
argument_list|(
name|reg
argument_list|)
index|]
return|;
block|}
end_function

begin_comment
comment|/* Store a new value mapping REG to R in ssa_rename_to.  */
end_comment

begin_function
specifier|static
name|void
name|ssa_rename_to_insert
parameter_list|(
name|reg
parameter_list|,
name|r
parameter_list|)
name|rtx
name|reg
decl_stmt|;
name|rtx
name|r
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|HARD_REGISTER_P
argument_list|(
name|reg
argument_list|)
condition|)
name|ssa_rename_to_pseudo
index|[
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|-
name|FIRST_PSEUDO_REGISTER
index|]
operator|=
name|r
expr_stmt|;
else|else
name|ssa_rename_to_hard
index|[
name|REGNO
argument_list|(
name|reg
argument_list|)
index|]
index|[
name|GET_MODE
argument_list|(
name|reg
argument_list|)
index|]
operator|=
name|r
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Prepare ssa_rename_from for use.  */
end_comment

begin_function
specifier|static
name|void
name|ssa_rename_from_initialize
parameter_list|()
block|{
comment|/* We use an arbitrary initial hash table size of 64.  */
name|ssa_rename_from_ht
operator|=
name|htab_create
argument_list|(
literal|64
argument_list|,
operator|&
name|ssa_rename_from_hash_function
argument_list|,
operator|&
name|ssa_rename_from_equal
argument_list|,
operator|&
name|ssa_rename_from_delete
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find the REG entry in ssa_rename_from.  Return NULL_RTX if no entry is    found.  */
end_comment

begin_function
specifier|static
name|rtx
name|ssa_rename_from_lookup
parameter_list|(
name|reg
parameter_list|)
name|int
name|reg
decl_stmt|;
block|{
name|ssa_rename_from_pair
name|srfp
decl_stmt|;
name|ssa_rename_from_pair
modifier|*
name|answer
decl_stmt|;
name|srfp
operator|.
name|reg
operator|=
name|reg
expr_stmt|;
name|srfp
operator|.
name|original
operator|=
name|NULL_RTX
expr_stmt|;
name|answer
operator|=
operator|(
name|ssa_rename_from_pair
operator|*
operator|)
name|htab_find_with_hash
argument_list|(
name|ssa_rename_from_ht
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|srfp
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return
operator|(
name|answer
operator|==
literal|0
condition|?
name|NULL_RTX
else|:
name|answer
operator|->
name|original
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Find the number of the original register specified by REGNO.  If    the register is a pseudo, return the original register's number.    Otherwise, return this register number REGNO.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|original_register
parameter_list|(
name|regno
parameter_list|)
name|unsigned
name|int
name|regno
decl_stmt|;
block|{
name|rtx
name|original_rtx
init|=
name|ssa_rename_from_lookup
argument_list|(
name|regno
argument_list|)
decl_stmt|;
return|return
name|original_rtx
operator|!=
name|NULL_RTX
condition|?
name|REGNO
argument_list|(
name|original_rtx
argument_list|)
else|:
name|regno
return|;
block|}
end_function

begin_comment
comment|/* Add mapping from R to REG to ssa_rename_from even if already present.  */
end_comment

begin_function
specifier|static
name|void
name|ssa_rename_from_insert
parameter_list|(
name|reg
parameter_list|,
name|r
parameter_list|)
name|unsigned
name|int
name|reg
decl_stmt|;
name|rtx
name|r
decl_stmt|;
block|{
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
name|ssa_rename_from_pair
modifier|*
name|srfp
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ssa_rename_from_pair
argument_list|)
argument_list|)
decl_stmt|;
name|srfp
operator|->
name|reg
operator|=
name|reg
expr_stmt|;
name|srfp
operator|->
name|original
operator|=
name|r
expr_stmt|;
name|slot
operator|=
name|htab_find_slot_with_hash
argument_list|(
name|ssa_rename_from_ht
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|srfp
argument_list|,
name|reg
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|slot
operator|!=
literal|0
condition|)
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|*
name|slot
argument_list|)
expr_stmt|;
operator|*
name|slot
operator|=
name|srfp
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Apply the CALLBACK_FUNCTION to each element in ssa_rename_from.    CANONICAL_ELEMENTS and REG_PARTITION pass data needed by the only    current use of this function.  */
end_comment

begin_function
specifier|static
name|void
name|ssa_rename_from_traverse
parameter_list|(
name|callback_function
parameter_list|,
name|canonical_elements
parameter_list|,
name|reg_partition
parameter_list|)
name|htab_trav
name|callback_function
decl_stmt|;
name|sbitmap
name|canonical_elements
decl_stmt|;
name|partition
name|reg_partition
decl_stmt|;
block|{
name|struct
name|ssa_rename_from_hash_table_data
name|srfhd
decl_stmt|;
name|srfhd
operator|.
name|canonical_elements
operator|=
name|canonical_elements
expr_stmt|;
name|srfhd
operator|.
name|reg_partition
operator|=
name|reg_partition
expr_stmt|;
name|htab_traverse
argument_list|(
name|ssa_rename_from_ht
argument_list|,
name|callback_function
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|srfhd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Destroy ssa_rename_from.  */
end_comment

begin_function
specifier|static
name|void
name|ssa_rename_from_free
parameter_list|()
block|{
name|htab_delete
argument_list|(
name|ssa_rename_from_ht
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print the contents of ssa_rename_from.  */
end_comment

begin_comment
comment|/* static  Avoid erroneous error message.  */
end_comment

begin_function
name|void
name|ssa_rename_from_print
parameter_list|()
block|{
name|printf
argument_list|(
literal|"ssa_rename_from's hash table contents:\n"
argument_list|)
expr_stmt|;
name|htab_traverse
argument_list|(
name|ssa_rename_from_ht
argument_list|,
operator|&
name|ssa_rename_from_print_1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print the contents of the hash table entry SLOT, passing the unused    sttribute DATA.  Used as a callback function with htab_traverse ().  */
end_comment

begin_function
specifier|static
name|int
name|ssa_rename_from_print_1
parameter_list|(
name|slot
parameter_list|,
name|data
parameter_list|)
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|ssa_rename_from_pair
modifier|*
name|p
init|=
operator|*
name|slot
decl_stmt|;
name|printf
argument_list|(
literal|"ssa_rename_from maps pseudo %i to original %i.\n"
argument_list|,
name|p
operator|->
name|reg
argument_list|,
name|REGNO
argument_list|(
name|p
operator|->
name|original
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Given a hash entry SRFP, yield a hash value.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|ssa_rename_from_hash_function
parameter_list|(
name|srfp
parameter_list|)
specifier|const
name|void
modifier|*
name|srfp
decl_stmt|;
block|{
return|return
operator|(
operator|(
specifier|const
name|ssa_rename_from_pair
operator|*
operator|)
name|srfp
operator|)
operator|->
name|reg
return|;
block|}
end_function

begin_comment
comment|/* Test whether two hash table entries SRFP1 and SRFP2 are equal.  */
end_comment

begin_function
specifier|static
name|int
name|ssa_rename_from_equal
parameter_list|(
name|srfp1
parameter_list|,
name|srfp2
parameter_list|)
specifier|const
name|void
modifier|*
name|srfp1
decl_stmt|;
specifier|const
name|void
modifier|*
name|srfp2
decl_stmt|;
block|{
return|return
name|ssa_rename_from_hash_function
argument_list|(
name|srfp1
argument_list|)
operator|==
name|ssa_rename_from_hash_function
argument_list|(
name|srfp2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Delete the hash table entry SRFP.  */
end_comment

begin_function
specifier|static
name|void
name|ssa_rename_from_delete
parameter_list|(
name|srfp
parameter_list|)
name|void
modifier|*
name|srfp
decl_stmt|;
block|{
name|free
argument_list|(
name|srfp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given the SET of a PHI node, return the address of the alternative    for predecessor block C.  */
end_comment

begin_function
specifier|static
specifier|inline
name|rtx
modifier|*
name|phi_alternative
parameter_list|(
name|set
parameter_list|,
name|c
parameter_list|)
name|rtx
name|set
decl_stmt|;
name|int
name|c
decl_stmt|;
block|{
name|rtvec
name|phi_vec
init|=
name|XVEC
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|v
decl_stmt|;
for|for
control|(
name|v
operator|=
name|GET_NUM_ELEM
argument_list|(
name|phi_vec
argument_list|)
operator|-
literal|2
init|;
name|v
operator|>=
literal|0
condition|;
name|v
operator|-=
literal|2
control|)
if|if
condition|(
name|INTVAL
argument_list|(
name|RTVEC_ELT
argument_list|(
name|phi_vec
argument_list|,
name|v
operator|+
literal|1
argument_list|)
argument_list|)
operator|==
name|c
condition|)
return|return
operator|&
name|RTVEC_ELT
argument_list|(
name|phi_vec
argument_list|,
name|v
argument_list|)
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Given the SET of a phi node, remove the alternative for predecessor    block C.  Return non-zero on success, or zero if no alternative is    found for C.  */
end_comment

begin_function
name|int
name|remove_phi_alternative
parameter_list|(
name|set
parameter_list|,
name|block
parameter_list|)
name|rtx
name|set
decl_stmt|;
name|basic_block
name|block
decl_stmt|;
block|{
name|rtvec
name|phi_vec
init|=
name|XVEC
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|num_elem
init|=
name|GET_NUM_ELEM
argument_list|(
name|phi_vec
argument_list|)
decl_stmt|;
name|int
name|v
decl_stmt|,
name|c
decl_stmt|;
name|c
operator|=
name|block
operator|->
name|index
expr_stmt|;
for|for
control|(
name|v
operator|=
name|num_elem
operator|-
literal|2
init|;
name|v
operator|>=
literal|0
condition|;
name|v
operator|-=
literal|2
control|)
if|if
condition|(
name|INTVAL
argument_list|(
name|RTVEC_ELT
argument_list|(
name|phi_vec
argument_list|,
name|v
operator|+
literal|1
argument_list|)
argument_list|)
operator|==
name|c
condition|)
block|{
if|if
condition|(
name|v
operator|<
name|num_elem
operator|-
literal|2
condition|)
block|{
name|RTVEC_ELT
argument_list|(
name|phi_vec
argument_list|,
name|v
argument_list|)
operator|=
name|RTVEC_ELT
argument_list|(
name|phi_vec
argument_list|,
name|num_elem
operator|-
literal|2
argument_list|)
expr_stmt|;
name|RTVEC_ELT
argument_list|(
name|phi_vec
argument_list|,
name|v
operator|+
literal|1
argument_list|)
operator|=
name|RTVEC_ELT
argument_list|(
name|phi_vec
argument_list|,
name|num_elem
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|PUT_NUM_ELEM
argument_list|(
name|phi_vec
argument_list|,
name|num_elem
operator|-
literal|2
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* For all registers, find all blocks in which they are set.     This is the transform of what would be local kill information that    we ought to be getting from flow.  */
end_comment

begin_decl_stmt
specifier|static
name|sbitmap
modifier|*
name|fe_evals
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fe_current_bb
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|find_evaluations_1
parameter_list|(
name|dest
parameter_list|,
name|set
parameter_list|,
name|data
parameter_list|)
name|rtx
name|dest
decl_stmt|;
name|rtx
name|set
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
operator|&&
name|CONVERT_REGISTER_TO_SSA_P
argument_list|(
name|REGNO
argument_list|(
name|dest
argument_list|)
argument_list|)
condition|)
name|SET_BIT
argument_list|(
name|fe_evals
index|[
name|REGNO
argument_list|(
name|dest
argument_list|)
index|]
argument_list|,
name|fe_current_bb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|find_evaluations
parameter_list|(
name|evals
parameter_list|,
name|nregs
parameter_list|)
name|sbitmap
modifier|*
name|evals
decl_stmt|;
name|int
name|nregs
decl_stmt|;
block|{
name|int
name|bb
decl_stmt|;
name|sbitmap_vector_zero
argument_list|(
name|evals
argument_list|,
name|nregs
argument_list|)
expr_stmt|;
name|fe_evals
operator|=
name|evals
expr_stmt|;
for|for
control|(
name|bb
operator|=
name|n_basic_blocks
init|;
operator|--
name|bb
operator|>=
literal|0
condition|;
control|)
block|{
name|rtx
name|p
decl_stmt|,
name|last
decl_stmt|;
name|fe_current_bb
operator|=
name|bb
expr_stmt|;
name|p
operator|=
name|BLOCK_HEAD
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|last
operator|=
name|BLOCK_END
argument_list|(
name|bb
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|INSN_P
argument_list|(
name|p
argument_list|)
condition|)
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|p
argument_list|)
argument_list|,
name|find_evaluations_1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|last
condition|)
break|break;
name|p
operator|=
name|NEXT_INSN
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Computing the Dominance Frontier:       As decribed in Morgan, section 3.5, this may be done simply by     walking the dominator tree bottom-up, computing the frontier for    the children before the parent.  When considering a block B,    there are two cases:     (1) A flow graph edge leaving B that does not lead to a child    of B in the dominator tree must be a block that is either equal    to B or not dominated by B.  Such blocks belong in the frontier    of B.     (2) Consider a block X in the frontier of one of the children C    of B.  If X is not equal to B and is not dominated by B, it    is in the frontier of B. */
end_comment

begin_function
specifier|static
name|void
name|compute_dominance_frontiers_1
parameter_list|(
name|frontiers
parameter_list|,
name|idom
parameter_list|,
name|bb
parameter_list|,
name|done
parameter_list|)
name|sbitmap
modifier|*
name|frontiers
decl_stmt|;
name|int
modifier|*
name|idom
decl_stmt|;
name|int
name|bb
decl_stmt|;
name|sbitmap
name|done
decl_stmt|;
block|{
name|basic_block
name|b
init|=
name|BASIC_BLOCK
argument_list|(
name|bb
argument_list|)
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|int
name|c
decl_stmt|;
name|SET_BIT
argument_list|(
name|done
argument_list|,
name|bb
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|frontiers
index|[
name|bb
index|]
argument_list|)
expr_stmt|;
comment|/* Do the frontier of the children first.  Not all children in the      dominator tree (blocks dominated by this one) are children in the      CFG, so check all blocks.  */
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|n_basic_blocks
condition|;
operator|++
name|c
control|)
if|if
condition|(
name|idom
index|[
name|c
index|]
operator|==
name|bb
operator|&&
operator|!
name|TEST_BIT
argument_list|(
name|done
argument_list|,
name|c
argument_list|)
condition|)
name|compute_dominance_frontiers_1
argument_list|(
name|frontiers
argument_list|,
name|idom
argument_list|,
name|c
argument_list|,
name|done
argument_list|)
expr_stmt|;
comment|/* Find blocks conforming to rule (1) above.  */
for|for
control|(
name|e
operator|=
name|b
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
block|{
if|if
condition|(
name|e
operator|->
name|dest
operator|==
name|EXIT_BLOCK_PTR
condition|)
continue|continue;
if|if
condition|(
name|idom
index|[
name|e
operator|->
name|dest
operator|->
name|index
index|]
operator|!=
name|bb
condition|)
name|SET_BIT
argument_list|(
name|frontiers
index|[
name|bb
index|]
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
comment|/* Find blocks conforming to rule (2).  */
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|n_basic_blocks
condition|;
operator|++
name|c
control|)
if|if
condition|(
name|idom
index|[
name|c
index|]
operator|==
name|bb
condition|)
block|{
name|int
name|x
decl_stmt|;
name|EXECUTE_IF_SET_IN_SBITMAP
argument_list|(
argument|frontiers[c]
argument_list|,
literal|0
argument_list|,
argument|x
argument_list|,
argument|{ 	    if (idom[x] != bb) 	      SET_BIT (frontiers[bb], x); 	  }
argument_list|)
empty_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|compute_dominance_frontiers
parameter_list|(
name|frontiers
parameter_list|,
name|idom
parameter_list|)
name|sbitmap
modifier|*
name|frontiers
decl_stmt|;
name|int
modifier|*
name|idom
decl_stmt|;
block|{
name|sbitmap
name|done
init|=
name|sbitmap_alloc
argument_list|(
name|n_basic_blocks
argument_list|)
decl_stmt|;
name|sbitmap_zero
argument_list|(
name|done
argument_list|)
expr_stmt|;
name|compute_dominance_frontiers_1
argument_list|(
name|frontiers
argument_list|,
name|idom
argument_list|,
literal|0
argument_list|,
name|done
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|done
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Computing the Iterated Dominance Frontier:     This is the set of merge points for a given register.     This is not particularly intuitive.  See section 7.1 of Morgan, in    particular figures 7.3 and 7.4 and the immediately surrounding text. */
end_comment

begin_function
specifier|static
name|void
name|compute_iterated_dominance_frontiers
parameter_list|(
name|idfs
parameter_list|,
name|frontiers
parameter_list|,
name|evals
parameter_list|,
name|nregs
parameter_list|)
name|sbitmap
modifier|*
name|idfs
decl_stmt|;
name|sbitmap
modifier|*
name|frontiers
decl_stmt|;
name|sbitmap
modifier|*
name|evals
decl_stmt|;
name|int
name|nregs
decl_stmt|;
block|{
name|sbitmap
name|worklist
decl_stmt|;
name|int
name|reg
decl_stmt|,
name|passes
init|=
literal|0
decl_stmt|;
name|worklist
operator|=
name|sbitmap_alloc
argument_list|(
name|n_basic_blocks
argument_list|)
expr_stmt|;
for|for
control|(
name|reg
operator|=
literal|0
init|;
name|reg
operator|<
name|nregs
condition|;
operator|++
name|reg
control|)
block|{
name|sbitmap
name|idf
init|=
name|idfs
index|[
name|reg
index|]
decl_stmt|;
name|int
name|b
decl_stmt|,
name|changed
decl_stmt|;
comment|/* Start the iterative process by considering those blocks that 	 evaluate REG.  We'll add their dominance frontiers to the 	 IDF, and then consider the blocks we just added.  */
name|sbitmap_copy
argument_list|(
name|worklist
argument_list|,
name|evals
index|[
name|reg
index|]
argument_list|)
expr_stmt|;
comment|/* Morgan's algorithm is incorrect here.  Blocks that evaluate 	 REG aren't necessarily in REG's IDF.  Start with an empty IDF.  */
name|sbitmap_zero
argument_list|(
name|idf
argument_list|)
expr_stmt|;
comment|/* Iterate until the worklist is empty.  */
do|do
block|{
name|changed
operator|=
literal|0
expr_stmt|;
name|passes
operator|++
expr_stmt|;
name|EXECUTE_IF_SET_IN_SBITMAP
argument_list|(
argument|worklist
argument_list|,
literal|0
argument_list|,
argument|b
argument_list|,
argument|{ 	      RESET_BIT (worklist, b);
comment|/* For each block on the worklist, add to the IDF all 		 blocks on its dominance frontier that aren't already 		 on the IDF.  Every block that's added is also added 		 to the worklist.  */
argument|sbitmap_union_of_diff (worklist, worklist, frontiers[b], idf); 	      sbitmap_a_or_b (idf, idf, frontiers[b]); 	      changed =
literal|1
argument|; 	    }
argument_list|)
empty_stmt|;
block|}
do|while
condition|(
name|changed
condition|)
do|;
block|}
name|sbitmap_free
argument_list|(
name|worklist
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Iterated dominance frontier: %d passes on %d regs.\n"
argument_list|,
name|passes
argument_list|,
name|nregs
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Insert the phi nodes.  */
end_comment

begin_function
specifier|static
name|void
name|insert_phi_node
parameter_list|(
name|regno
parameter_list|,
name|bb
parameter_list|)
name|int
name|regno
decl_stmt|,
name|bb
decl_stmt|;
block|{
name|basic_block
name|b
init|=
name|BASIC_BLOCK
argument_list|(
name|bb
argument_list|)
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|int
name|npred
decl_stmt|,
name|i
decl_stmt|;
name|rtvec
name|vec
decl_stmt|;
name|rtx
name|phi
decl_stmt|,
name|reg
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|end_p
decl_stmt|;
comment|/* Find out how many predecessors there are.  */
for|for
control|(
name|e
operator|=
name|b
operator|->
name|pred
operator|,
name|npred
operator|=
literal|0
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
if|if
condition|(
name|e
operator|->
name|src
operator|!=
name|ENTRY_BLOCK_PTR
condition|)
name|npred
operator|++
expr_stmt|;
comment|/* If this block has no "interesting" preds, then there is nothing to      do.  Consider a block that only has the entry block as a pred.  */
if|if
condition|(
name|npred
operator|==
literal|0
condition|)
return|return;
comment|/* This is the register to which the phi function will be assigned.  */
name|reg
operator|=
name|regno_reg_rtx
index|[
name|regno
index|]
expr_stmt|;
comment|/* Construct the arguments to the PHI node.  The use of pc_rtx is just      a placeholder; we'll insert the proper value in rename_registers.  */
name|vec
operator|=
name|rtvec_alloc
argument_list|(
name|npred
operator|*
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|e
operator|=
name|b
operator|->
name|pred
operator|,
name|i
operator|=
literal|0
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
operator|,
name|i
operator|+=
literal|2
control|)
if|if
condition|(
name|e
operator|->
name|src
operator|!=
name|ENTRY_BLOCK_PTR
condition|)
block|{
name|RTVEC_ELT
argument_list|(
name|vec
argument_list|,
name|i
operator|+
literal|0
argument_list|)
operator|=
name|pc_rtx
expr_stmt|;
name|RTVEC_ELT
argument_list|(
name|vec
argument_list|,
name|i
operator|+
literal|1
argument_list|)
operator|=
name|GEN_INT
argument_list|(
name|e
operator|->
name|src
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
name|phi
operator|=
name|gen_rtx_PHI
argument_list|(
name|VOIDmode
argument_list|,
name|vec
argument_list|)
expr_stmt|;
name|phi
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|phi
argument_list|)
expr_stmt|;
name|insn
operator|=
name|first_insn_after_basic_block_note
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|end_p
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
operator|==
name|b
operator|->
name|end
expr_stmt|;
name|emit_insn_before
argument_list|(
name|phi
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|end_p
condition|)
name|b
operator|->
name|end
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|insert_phi_nodes
parameter_list|(
name|idfs
parameter_list|,
name|evals
parameter_list|,
name|nregs
parameter_list|)
name|sbitmap
modifier|*
name|idfs
decl_stmt|;
name|sbitmap
modifier|*
name|evals
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|nregs
decl_stmt|;
block|{
name|int
name|reg
decl_stmt|;
for|for
control|(
name|reg
operator|=
literal|0
init|;
name|reg
operator|<
name|nregs
condition|;
operator|++
name|reg
control|)
if|if
condition|(
name|CONVERT_REGISTER_TO_SSA_P
argument_list|(
name|reg
argument_list|)
condition|)
block|{
name|int
name|b
decl_stmt|;
name|EXECUTE_IF_SET_IN_SBITMAP
argument_list|(
argument|idfs[reg]
argument_list|,
literal|0
argument_list|,
argument|b
argument_list|,
argument|{ 	  if (REGNO_REG_SET_P (BASIC_BLOCK (b)->global_live_at_start, reg)) 	    insert_phi_node (reg, b); 	}
argument_list|)
empty_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Rename the registers to conform to SSA.      This is essentially the algorithm presented in Figure 7.8 of Morgan,    with a few changes to reduce pattern search time in favour of a bit    more memory usage.  */
end_comment

begin_comment
comment|/* One of these is created for each set.  It will live in a list local    to its basic block for the duration of that block's processing.  */
end_comment

begin_struct
struct|struct
name|rename_set_data
block|{
name|struct
name|rename_set_data
modifier|*
name|next
decl_stmt|;
comment|/* This is the SET_DEST of the (first) SET that sets the REG.  */
name|rtx
modifier|*
name|reg_loc
decl_stmt|;
comment|/* This is what used to be at *REG_LOC.  */
name|rtx
name|old_reg
decl_stmt|;
comment|/* This is the REG that will replace OLD_REG.  It's set only      when the rename data is moved onto the DONE_RENAMES queue.  */
name|rtx
name|new_reg
decl_stmt|;
comment|/* This is what to restore ssa_rename_to_lookup (old_reg) to.  It is      usually the previous contents of ssa_rename_to_lookup (old_reg).  */
name|rtx
name|prev_reg
decl_stmt|;
comment|/* This is the insn that contains all the SETs of the REG.  */
name|rtx
name|set_insn
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This struct is used to pass information to callback functions while    renaming registers.  */
end_comment

begin_struct
struct|struct
name|rename_context
block|{
name|struct
name|rename_set_data
modifier|*
name|new_renames
decl_stmt|;
name|struct
name|rename_set_data
modifier|*
name|done_renames
decl_stmt|;
name|rtx
name|current_insn
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Queue the rename of *REG_LOC.  */
end_comment

begin_function
specifier|static
name|void
name|create_delayed_rename
parameter_list|(
name|c
parameter_list|,
name|reg_loc
parameter_list|)
name|struct
name|rename_context
modifier|*
name|c
decl_stmt|;
name|rtx
modifier|*
name|reg_loc
decl_stmt|;
block|{
name|struct
name|rename_set_data
modifier|*
name|r
decl_stmt|;
name|r
operator|=
operator|(
expr|struct
name|rename_set_data
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|r
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
operator|*
name|reg_loc
argument_list|)
operator|!=
name|REG
operator|||
operator|!
name|CONVERT_REGISTER_TO_SSA_P
argument_list|(
name|REGNO
argument_list|(
operator|*
name|reg_loc
argument_list|)
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|r
operator|->
name|reg_loc
operator|=
name|reg_loc
expr_stmt|;
name|r
operator|->
name|old_reg
operator|=
operator|*
name|reg_loc
expr_stmt|;
name|r
operator|->
name|prev_reg
operator|=
name|ssa_rename_to_lookup
argument_list|(
name|r
operator|->
name|old_reg
argument_list|)
expr_stmt|;
name|r
operator|->
name|set_insn
operator|=
name|c
operator|->
name|current_insn
expr_stmt|;
name|r
operator|->
name|next
operator|=
name|c
operator|->
name|new_renames
expr_stmt|;
name|c
operator|->
name|new_renames
operator|=
name|r
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is part of a rather ugly hack to allow the pre-ssa regno to be    reused.  If, during processing, a register has not yet been touched,    ssa_rename_to[regno][machno] will be NULL.  Now, in the course of pushing    and popping values from ssa_rename_to, when we would ordinarily     pop NULL back in, we pop RENAME_NO_RTX.  We treat this exactly the    same as NULL, except that it signals that the original regno has    already been reused.  */
end_comment

begin_define
define|#
directive|define
name|RENAME_NO_RTX
value|pc_rtx
end_define

begin_comment
comment|/* Move all the entries from NEW_RENAMES onto DONE_RENAMES by    applying all the renames on NEW_RENAMES.  */
end_comment

begin_function
specifier|static
name|void
name|apply_delayed_renames
parameter_list|(
name|c
parameter_list|)
name|struct
name|rename_context
modifier|*
name|c
decl_stmt|;
block|{
name|struct
name|rename_set_data
modifier|*
name|r
decl_stmt|;
name|struct
name|rename_set_data
modifier|*
name|last_r
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|r
operator|=
name|c
operator|->
name|new_renames
init|;
name|r
operator|!=
name|NULL
condition|;
name|r
operator|=
name|r
operator|->
name|next
control|)
block|{
name|int
name|new_regno
decl_stmt|;
comment|/* Failure here means that someone has a PARALLEL that sets 	 a register twice (bad!).  */
if|if
condition|(
name|ssa_rename_to_lookup
argument_list|(
name|r
operator|->
name|old_reg
argument_list|)
operator|!=
name|r
operator|->
name|prev_reg
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Failure here means we have changed REG_LOC before applying 	 the rename.  */
comment|/* For the first set we come across, reuse the original regno.  */
if|if
condition|(
name|r
operator|->
name|prev_reg
operator|==
name|NULL_RTX
operator|&&
operator|!
name|HARD_REGISTER_P
argument_list|(
name|r
operator|->
name|old_reg
argument_list|)
condition|)
block|{
name|r
operator|->
name|new_reg
operator|=
name|r
operator|->
name|old_reg
expr_stmt|;
comment|/* We want to restore RENAME_NO_RTX rather than NULL_RTX.  */
name|r
operator|->
name|prev_reg
operator|=
name|RENAME_NO_RTX
expr_stmt|;
block|}
else|else
name|r
operator|->
name|new_reg
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|r
operator|->
name|old_reg
argument_list|)
argument_list|)
expr_stmt|;
name|new_regno
operator|=
name|REGNO
argument_list|(
name|r
operator|->
name|new_reg
argument_list|)
expr_stmt|;
name|ssa_rename_to_insert
argument_list|(
name|r
operator|->
name|old_reg
argument_list|,
name|r
operator|->
name|new_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_regno
operator|>=
operator|(
name|int
operator|)
name|ssa_definition
operator|->
name|num_elements
condition|)
block|{
name|int
name|new_limit
init|=
name|new_regno
operator|*
literal|5
operator|/
literal|4
decl_stmt|;
name|VARRAY_GROW
argument_list|(
name|ssa_definition
argument_list|,
name|new_limit
argument_list|)
expr_stmt|;
block|}
name|VARRAY_RTX
argument_list|(
name|ssa_definition
argument_list|,
name|new_regno
argument_list|)
operator|=
name|r
operator|->
name|set_insn
expr_stmt|;
name|ssa_rename_from_insert
argument_list|(
name|new_regno
argument_list|,
name|r
operator|->
name|old_reg
argument_list|)
expr_stmt|;
name|last_r
operator|=
name|r
expr_stmt|;
block|}
if|if
condition|(
name|last_r
operator|!=
name|NULL
condition|)
block|{
name|last_r
operator|->
name|next
operator|=
name|c
operator|->
name|done_renames
expr_stmt|;
name|c
operator|->
name|done_renames
operator|=
name|c
operator|->
name|new_renames
expr_stmt|;
name|c
operator|->
name|new_renames
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Part one of the first step of rename_block, called through for_each_rtx.     Mark pseudos that are set for later update.  Transform uses of pseudos.  */
end_comment

begin_function
specifier|static
name|int
name|rename_insn_1
parameter_list|(
name|ptr
parameter_list|,
name|data
parameter_list|)
name|rtx
modifier|*
name|ptr
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|rtx
name|x
init|=
operator|*
name|ptr
decl_stmt|;
name|struct
name|rename_context
modifier|*
name|context
init|=
name|data
decl_stmt|;
if|if
condition|(
name|x
operator|==
name|NULL_RTX
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|SET
case|:
block|{
name|rtx
modifier|*
name|destp
init|=
operator|&
name|SET_DEST
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|x
argument_list|)
decl_stmt|;
comment|/* An assignment to a paradoxical SUBREG does not read from 	   the destination operand, and thus does not need to be 	   wrapped into a SEQUENCE when translating into SSA form. 	   We merely strip off the SUBREG and proceed normally for 	   this case.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|CONVERT_REGISTER_TO_SSA_P
argument_list|(
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|destp
operator|=
operator|&
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dest
operator|=
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Some SETs also use the REG specified in their LHS. 	   These can be detected by the presence of 	   STRICT_LOW_PART, SUBREG, SIGN_EXTRACT, and ZERO_EXTRACT 	   in the LHS.  Handle these by changing 	   (set (subreg (reg foo)) ...) 	   into 	   (sequence [(set (reg foo_1) (reg foo)) 	              (set (subreg (reg foo_1)) ...)])    	   FIXME: Much of the time this is too much.  For some constructs 	   we know that the output register is strictly an output 	   (paradoxical SUBREGs and some libcalls for example).  	   For those cases we are better off not making the false 	   dependency.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTRACT
condition|)
block|{
name|rtx
name|i
decl_stmt|,
name|reg
decl_stmt|;
name|reg
operator|=
name|dest
expr_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|ZERO_EXTRACT
condition|)
name|reg
operator|=
name|XEXP
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|REG
operator|&&
name|CONVERT_REGISTER_TO_SSA_P
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Generate (set reg reg), and do renaming on it so 		   that it becomes (set reg_1 reg_0), and we will 		   replace reg with reg_1 in the SUBREG.  */
name|struct
name|rename_set_data
modifier|*
name|saved_new_renames
decl_stmt|;
name|saved_new_renames
operator|=
name|context
operator|->
name|new_renames
expr_stmt|;
name|context
operator|->
name|new_renames
operator|=
name|NULL
expr_stmt|;
name|i
operator|=
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|reg
argument_list|)
argument_list|)
expr_stmt|;
name|for_each_rtx
argument_list|(
operator|&
name|i
argument_list|,
name|rename_insn_1
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|apply_delayed_renames
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|context
operator|->
name|new_renames
operator|=
name|saved_new_renames
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
operator|&&
name|CONVERT_REGISTER_TO_SSA_P
argument_list|(
name|REGNO
argument_list|(
name|dest
argument_list|)
argument_list|)
condition|)
block|{
comment|/* We found a genuine set of an interesting register.  Tag 	       it so that we can create a new name for it after we finish 	       processing this insn.  */
name|create_delayed_rename
argument_list|(
name|context
argument_list|,
name|destp
argument_list|)
expr_stmt|;
comment|/* Since we do not wish to (directly) traverse the 	       SET_DEST, recurse through for_each_rtx for the SET_SRC 	       and return.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SET
condition|)
name|for_each_rtx
argument_list|(
operator|&
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|rename_insn_1
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Otherwise, this was not an interesting destination.  Continue 	   on, marking uses as normal.  */
return|return
literal|0
return|;
block|}
case|case
name|REG
case|:
if|if
condition|(
name|CONVERT_REGISTER_TO_SSA_P
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
name|ssa_max_reg_num
condition|)
block|{
name|rtx
name|new_reg
init|=
name|ssa_rename_to_lookup
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|new_reg
operator|!=
name|NULL_RTX
operator|&&
name|new_reg
operator|!=
name|RENAME_NO_RTX
condition|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|new_reg
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
operator|*
name|ptr
operator|=
name|new_reg
expr_stmt|;
block|}
comment|/* Else this is a use before a set.  Warn?  */
block|}
return|return
operator|-
literal|1
return|;
case|case
name|CLOBBER
case|:
comment|/* There is considerable debate on how CLOBBERs ought to be 	 handled in SSA.  For now, we're keeping the CLOBBERs, which 	 means that we don't really have SSA form.  There are a couple 	 of proposals for how to fix this problem, but neither is 	 implemented yet.  */
block|{
name|rtx
name|dest
init|=
name|XCEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|CLOBBER
argument_list|)
decl_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|dest
argument_list|)
condition|)
block|{
if|if
condition|(
name|CONVERT_REGISTER_TO_SSA_P
argument_list|(
name|REGNO
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|dest
argument_list|)
operator|<
name|ssa_max_reg_num
condition|)
block|{
name|rtx
name|new_reg
init|=
name|ssa_rename_to_lookup
argument_list|(
name|dest
argument_list|)
decl_stmt|;
if|if
condition|(
name|new_reg
operator|!=
name|NULL_RTX
operator|&&
name|new_reg
operator|!=
name|RENAME_NO_RTX
condition|)
name|XCEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|CLOBBER
argument_list|)
operator|=
name|new_reg
expr_stmt|;
block|}
comment|/* Stop traversing.  */
return|return
operator|-
literal|1
return|;
block|}
else|else
comment|/* Continue traversing.  */
return|return
literal|0
return|;
block|}
case|case
name|PHI
case|:
comment|/* Never muck with the phi.  We do that elsewhere, special-like.  */
return|return
operator|-
literal|1
return|;
default|default:
comment|/* Anything else, continue traversing.  */
return|return
literal|0
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|rename_block
parameter_list|(
name|bb
parameter_list|,
name|idom
parameter_list|)
name|int
name|bb
decl_stmt|;
name|int
modifier|*
name|idom
decl_stmt|;
block|{
name|basic_block
name|b
init|=
name|BASIC_BLOCK
argument_list|(
name|bb
argument_list|)
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|rtx
name|insn
decl_stmt|,
name|next
decl_stmt|,
name|last
decl_stmt|;
name|struct
name|rename_set_data
modifier|*
name|set_data
init|=
name|NULL
decl_stmt|;
name|int
name|c
decl_stmt|;
comment|/* Step One: Walk the basic block, adding new names for sets and      replacing uses.  */
name|next
operator|=
name|b
operator|->
name|head
expr_stmt|;
name|last
operator|=
name|b
operator|->
name|end
expr_stmt|;
do|do
block|{
name|insn
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|struct
name|rename_context
name|context
decl_stmt|;
name|context
operator|.
name|done_renames
operator|=
name|set_data
expr_stmt|;
name|context
operator|.
name|new_renames
operator|=
name|NULL
expr_stmt|;
name|context
operator|.
name|current_insn
operator|=
name|insn
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|for_each_rtx
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|rename_insn_1
argument_list|,
operator|&
name|context
argument_list|)
expr_stmt|;
name|for_each_rtx
argument_list|(
operator|&
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|,
name|rename_insn_1
argument_list|,
operator|&
name|context
argument_list|)
expr_stmt|;
comment|/* Sometimes, we end up with a sequence of insns that 	     SSA needs to treat as a single insn.  Wrap these in a 	     SEQUENCE.  (Any notes now get attached to the SEQUENCE, 	     not to the old version inner insn.)  */
if|if
condition|(
name|get_insns
argument_list|()
operator|!=
name|NULL_RTX
condition|)
block|{
name|rtx
name|seq
decl_stmt|;
name|int
name|i
decl_stmt|;
name|emit
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|seq
operator|=
name|gen_sequence
argument_list|()
expr_stmt|;
comment|/* We really want a SEQUENCE of SETs, not a SEQUENCE 		 of INSNs.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
name|XVECEXP
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
operator|=
name|PATTERN
argument_list|(
name|XVECEXP
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|=
name|seq
expr_stmt|;
block|}
name|end_sequence
argument_list|()
expr_stmt|;
name|apply_delayed_renames
argument_list|(
operator|&
name|context
argument_list|)
expr_stmt|;
name|set_data
operator|=
name|context
operator|.
name|done_renames
expr_stmt|;
block|}
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|insn
operator|!=
name|last
condition|)
do|;
comment|/* Step Two: Update the phi nodes of this block's successors.  */
for|for
control|(
name|e
operator|=
name|b
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
block|{
if|if
condition|(
name|e
operator|->
name|dest
operator|==
name|EXIT_BLOCK_PTR
condition|)
continue|continue;
name|insn
operator|=
name|first_insn_after_basic_block_note
argument_list|(
name|e
operator|->
name|dest
argument_list|)
expr_stmt|;
while|while
condition|(
name|PHI_NODE_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|rtx
name|phi
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
comment|/* Find out which of our outgoing registers this node is 	     intended to replace.  Note that if this is not the first PHI 	     node to have been created for this register, we have to 	     jump through rename links to figure out which register 	     we're talking about.  This can easily be recognized by 	     noting that the regno is new to this pass.  */
name|reg
operator|=
name|SET_DEST
argument_list|(
name|phi
argument_list|)
expr_stmt|;
if|if
condition|(
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|>=
name|ssa_max_reg_num
condition|)
name|reg
operator|=
name|ssa_rename_from_lookup
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|==
name|NULL_RTX
condition|)
name|abort
argument_list|()
expr_stmt|;
name|reg
operator|=
name|ssa_rename_to_lookup
argument_list|(
name|reg
argument_list|)
expr_stmt|;
comment|/* It is possible for the variable to be uninitialized on 	     edges in.  Reduce the arity of the PHI so that we don't 	     consider those edges.  */
if|if
condition|(
name|reg
operator|==
name|NULL
operator|||
name|reg
operator|==
name|RENAME_NO_RTX
condition|)
block|{
if|if
condition|(
operator|!
name|remove_phi_alternative
argument_list|(
name|phi
argument_list|,
name|b
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* When we created the PHI nodes, we did not know what mode 		 the register should be.  Now that we've found an original, 		 we can fill that in.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|phi
argument_list|)
argument_list|)
operator|==
name|VOIDmode
condition|)
name|PUT_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|phi
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|phi
argument_list|)
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|reg
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
operator|*
name|phi_alternative
argument_list|(
name|phi
argument_list|,
name|bb
argument_list|)
operator|=
name|reg
expr_stmt|;
block|}
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Step Three: Do the same to the children of this block in      dominator order.  */
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|n_basic_blocks
condition|;
operator|++
name|c
control|)
if|if
condition|(
name|idom
index|[
name|c
index|]
operator|==
name|bb
condition|)
name|rename_block
argument_list|(
name|c
argument_list|,
name|idom
argument_list|)
expr_stmt|;
comment|/* Step Four: Update the sets to refer to their new register,      and restore ssa_rename_to to its previous state.  */
while|while
condition|(
name|set_data
condition|)
block|{
name|struct
name|rename_set_data
modifier|*
name|next
decl_stmt|;
name|rtx
name|old_reg
init|=
operator|*
name|set_data
operator|->
name|reg_loc
decl_stmt|;
if|if
condition|(
operator|*
name|set_data
operator|->
name|reg_loc
operator|!=
name|set_data
operator|->
name|old_reg
condition|)
name|abort
argument_list|()
expr_stmt|;
operator|*
name|set_data
operator|->
name|reg_loc
operator|=
name|set_data
operator|->
name|new_reg
expr_stmt|;
name|ssa_rename_to_insert
argument_list|(
name|old_reg
argument_list|,
name|set_data
operator|->
name|prev_reg
argument_list|)
expr_stmt|;
name|next
operator|=
name|set_data
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|set_data
argument_list|)
expr_stmt|;
name|set_data
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|rename_registers
parameter_list|(
name|nregs
parameter_list|,
name|idom
parameter_list|)
name|int
name|nregs
decl_stmt|;
name|int
modifier|*
name|idom
decl_stmt|;
block|{
name|VARRAY_RTX_INIT
argument_list|(
name|ssa_definition
argument_list|,
name|nregs
operator|*
literal|3
argument_list|,
literal|"ssa_definition"
argument_list|)
expr_stmt|;
name|ssa_rename_from_initialize
argument_list|()
expr_stmt|;
name|ssa_rename_to_pseudo
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ssa_rename_to_pseudo
argument_list|,
literal|0
argument_list|,
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ssa_rename_to_hard
argument_list|,
literal|0
argument_list|,
name|FIRST_PSEUDO_REGISTER
operator|*
name|NUM_MACHINE_MODES
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|rename_block
argument_list|(
literal|0
argument_list|,
name|idom
argument_list|)
expr_stmt|;
comment|/* ??? Update basic_block_live_at_start, and other flow info       as needed.  */
name|ssa_rename_to_pseudo
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The main entry point for moving to SSA.  */
end_comment

begin_function
name|void
name|convert_to_ssa
parameter_list|()
block|{
comment|/* Element I is the set of blocks that set register I.  */
name|sbitmap
modifier|*
name|evals
decl_stmt|;
comment|/* Dominator bitmaps.  */
name|sbitmap
modifier|*
name|dfs
decl_stmt|;
name|sbitmap
modifier|*
name|idfs
decl_stmt|;
comment|/* Element I is the immediate dominator of block I.  */
name|int
modifier|*
name|idom
decl_stmt|;
name|int
name|nregs
decl_stmt|;
comment|/* Don't do it twice.  */
if|if
condition|(
name|in_ssa_form
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Need global_live_at_{start,end} up to date.  Do not remove any      dead code.  We'll let the SSA optimizers do that.  */
name|life_analysis
argument_list|(
name|get_insns
argument_list|()
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|idom
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|n_basic_blocks
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
name|idom
argument_list|,
operator|-
literal|1
argument_list|,
operator|(
name|size_t
operator|)
name|n_basic_blocks
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|calculate_dominance_info
argument_list|(
name|idom
argument_list|,
name|NULL
argument_list|,
name|CDI_DOMINATORS
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
block|{
name|int
name|i
decl_stmt|;
name|fputs
argument_list|(
literal|";; Immediate Dominators:\n"
argument_list|,
name|rtl_dump_file
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
operator|++
name|i
control|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|";\t%3d = %3d\n"
argument_list|,
name|i
argument_list|,
name|idom
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|rtl_dump_file
argument_list|)
expr_stmt|;
block|}
comment|/* Compute dominance frontiers.  */
name|dfs
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_basic_blocks
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|compute_dominance_frontiers
argument_list|(
name|dfs
argument_list|,
name|idom
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
block|{
name|dump_sbitmap_vector
argument_list|(
name|rtl_dump_file
argument_list|,
literal|";; Dominance Frontiers:"
argument_list|,
literal|"; Basic Block"
argument_list|,
name|dfs
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|rtl_dump_file
argument_list|)
expr_stmt|;
block|}
comment|/* Compute register evaluations.  */
name|ssa_max_reg_num
operator|=
name|max_reg_num
argument_list|()
expr_stmt|;
name|nregs
operator|=
name|ssa_max_reg_num
expr_stmt|;
name|evals
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|nregs
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|find_evaluations
argument_list|(
name|evals
argument_list|,
name|nregs
argument_list|)
expr_stmt|;
comment|/* Compute the iterated dominance frontier for each register.  */
name|idfs
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|nregs
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|compute_iterated_dominance_frontiers
argument_list|(
name|idfs
argument_list|,
name|dfs
argument_list|,
name|evals
argument_list|,
name|nregs
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
block|{
name|dump_sbitmap_vector
argument_list|(
name|rtl_dump_file
argument_list|,
literal|";; Iterated Dominance Frontiers:"
argument_list|,
literal|"; Register"
argument_list|,
name|idfs
argument_list|,
name|nregs
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|rtl_dump_file
argument_list|)
expr_stmt|;
block|}
comment|/* Insert the phi nodes.  */
name|insert_phi_nodes
argument_list|(
name|idfs
argument_list|,
name|evals
argument_list|,
name|nregs
argument_list|)
expr_stmt|;
comment|/* Rename the registers to satisfy SSA.  */
name|rename_registers
argument_list|(
name|nregs
argument_list|,
name|idom
argument_list|)
expr_stmt|;
comment|/* All done!  Clean up and go home.  */
name|sbitmap_vector_free
argument_list|(
name|dfs
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|evals
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|idfs
argument_list|)
expr_stmt|;
name|in_ssa_form
operator|=
literal|1
expr_stmt|;
name|reg_scan
argument_list|(
name|get_insns
argument_list|()
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* REG is the representative temporary of its partition.  Add it to the    set of nodes to be processed, if it hasn't been already.  Return the    index of this register in the node set.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|ephi_add_node
parameter_list|(
name|reg
parameter_list|,
name|nodes
parameter_list|,
name|n_nodes
parameter_list|)
name|rtx
name|reg
decl_stmt|,
decl|*
name|nodes
decl_stmt|;
end_function

begin_decl_stmt
name|int
modifier|*
name|n_nodes
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
operator|*
name|n_nodes
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
if|if
condition|(
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|==
name|REGNO
argument_list|(
name|nodes
index|[
name|i
index|]
argument_list|)
condition|)
return|return
name|i
return|;
name|nodes
index|[
name|i
operator|=
operator|(
operator|*
name|n_nodes
operator|)
operator|++
index|]
operator|=
name|reg
expr_stmt|;
return|return
name|i
return|;
block|}
end_block

begin_comment
comment|/* Part one of the topological sort.  This is a forward (downward) search    through the graph collecting a stack of nodes to process.  Assuming no    cycles, the nodes at top of the stack when we are finished will have    no other dependencies.  */
end_comment

begin_function
specifier|static
name|int
modifier|*
name|ephi_forward
parameter_list|(
name|t
parameter_list|,
name|visited
parameter_list|,
name|succ
parameter_list|,
name|tstack
parameter_list|)
name|int
name|t
decl_stmt|;
name|sbitmap
name|visited
decl_stmt|;
name|sbitmap
modifier|*
name|succ
decl_stmt|;
name|int
modifier|*
name|tstack
decl_stmt|;
block|{
name|int
name|s
decl_stmt|;
name|SET_BIT
argument_list|(
name|visited
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_SBITMAP
argument_list|(
argument|succ[t]
argument_list|,
literal|0
argument_list|,
argument|s
argument_list|,
argument|{       if (! TEST_BIT (visited, s))         tstack = ephi_forward (s, visited, succ, tstack);     }
argument_list|)
empty_stmt|;
operator|*
name|tstack
operator|++
operator|=
name|t
expr_stmt|;
return|return
name|tstack
return|;
block|}
end_function

begin_comment
comment|/* Part two of the topological sort.  The is a backward search through    a cycle in the graph, copying the data forward as we go.  */
end_comment

begin_function
specifier|static
name|void
name|ephi_backward
parameter_list|(
name|t
parameter_list|,
name|visited
parameter_list|,
name|pred
parameter_list|,
name|nodes
parameter_list|)
name|int
name|t
decl_stmt|;
name|sbitmap
name|visited
decl_stmt|,
decl|*
name|pred
decl_stmt|;
end_function

begin_decl_stmt
name|rtx
modifier|*
name|nodes
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|p
decl_stmt|;
name|SET_BIT
argument_list|(
name|visited
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_SBITMAP
argument_list|(
argument|pred[t]
argument_list|,
literal|0
argument_list|,
argument|p
argument_list|,
argument|{       if (! TEST_BIT (visited, p)) 	{ 	  ephi_backward (p, visited, pred, nodes); 	  emit_move_insn (nodes[p], nodes[t]); 	}     }
argument_list|)
empty_stmt|;
block|}
end_block

begin_comment
comment|/* Part two of the topological sort.  Create the copy for a register    and any cycle of which it is a member.  */
end_comment

begin_function
specifier|static
name|void
name|ephi_create
parameter_list|(
name|t
parameter_list|,
name|visited
parameter_list|,
name|pred
parameter_list|,
name|succ
parameter_list|,
name|nodes
parameter_list|)
name|int
name|t
decl_stmt|;
name|sbitmap
name|visited
decl_stmt|,
decl|*
name|pred
decl_stmt|,
modifier|*
name|succ
decl_stmt|;
end_function

begin_decl_stmt
name|rtx
modifier|*
name|nodes
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|rtx
name|reg_u
init|=
name|NULL_RTX
decl_stmt|;
name|int
name|unvisited_predecessors
init|=
literal|0
decl_stmt|;
name|int
name|p
decl_stmt|;
comment|/* Iterate through the predecessor list looking for unvisited nodes.      If there are any, we have a cycle, and must deal with that.  At       the same time, look for a visited predecessor.  If there is one,      we won't need to create a temporary.  */
name|EXECUTE_IF_SET_IN_SBITMAP
argument_list|(
argument|pred[t]
argument_list|,
literal|0
argument_list|,
argument|p
argument_list|,
argument|{       if (! TEST_BIT (visited, p)) 	unvisited_predecessors =
literal|1
argument|;       else if (!reg_u) 	reg_u = nodes[p];     }
argument_list|)
empty_stmt|;
if|if
condition|(
name|unvisited_predecessors
condition|)
block|{
comment|/* We found a cycle.  Copy out one element of the ring (if necessary), 	 then traverse the ring copying as we go.  */
if|if
condition|(
operator|!
name|reg_u
condition|)
block|{
name|reg_u
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|nodes
index|[
name|t
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|reg_u
argument_list|,
name|nodes
index|[
name|t
index|]
argument_list|)
expr_stmt|;
block|}
name|EXECUTE_IF_SET_IN_SBITMAP
argument_list|(
argument|pred[t]
argument_list|,
literal|0
argument_list|,
argument|p
argument_list|,
argument|{ 	  if (! TEST_BIT (visited, p)) 	    { 	      ephi_backward (p, visited, pred, nodes); 	      emit_move_insn (nodes[p], reg_u); 	    } 	}
argument_list|)
empty_stmt|;
block|}
else|else
block|{
comment|/* No cycle.  Just copy the value from a successor.  */
name|int
name|s
decl_stmt|;
name|EXECUTE_IF_SET_IN_SBITMAP
argument_list|(
argument|succ[t]
argument_list|,
literal|0
argument_list|,
argument|s
argument_list|,
argument|{ 	  SET_BIT (visited, t); 	  emit_move_insn (nodes[t], nodes[s]); 	  return; 	}
argument_list|)
empty_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Convert the edge to normal form.  */
end_comment

begin_function
specifier|static
name|void
name|eliminate_phi
parameter_list|(
name|e
parameter_list|,
name|reg_partition
parameter_list|)
name|edge
name|e
decl_stmt|;
name|partition
name|reg_partition
decl_stmt|;
block|{
name|int
name|n_nodes
decl_stmt|;
name|sbitmap
modifier|*
name|pred
decl_stmt|,
modifier|*
name|succ
decl_stmt|;
name|sbitmap
name|visited
decl_stmt|;
name|rtx
modifier|*
name|nodes
decl_stmt|;
name|int
modifier|*
name|stack
decl_stmt|,
modifier|*
name|tstack
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Collect an upper bound on the number of registers needing processing.  */
name|insn
operator|=
name|first_insn_after_basic_block_note
argument_list|(
name|e
operator|->
name|dest
argument_list|)
expr_stmt|;
name|n_nodes
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|PHI_NODE_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|insn
operator|=
name|next_nonnote_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|n_nodes
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|n_nodes
operator|==
literal|0
condition|)
return|return;
comment|/* Build the auxiliary graph R(B).        The nodes of the graph are the members of the register partition      present in Phi(B).  There is an edge from FIND(T0)->FIND(T1) for      each T0 = PHI(...,T1,...), where T1 is for the edge from block C.  */
name|nodes
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|n_nodes
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|pred
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_nodes
argument_list|,
name|n_nodes
argument_list|)
expr_stmt|;
name|succ
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_nodes
argument_list|,
name|n_nodes
argument_list|)
expr_stmt|;
name|sbitmap_vector_zero
argument_list|(
name|pred
argument_list|,
name|n_nodes
argument_list|)
expr_stmt|;
name|sbitmap_vector_zero
argument_list|(
name|succ
argument_list|,
name|n_nodes
argument_list|)
expr_stmt|;
name|insn
operator|=
name|first_insn_after_basic_block_note
argument_list|(
name|e
operator|->
name|dest
argument_list|)
expr_stmt|;
name|n_nodes
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|PHI_NODE_P
argument_list|(
name|insn
argument_list|)
condition|;
name|insn
operator|=
name|next_nonnote_insn
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|rtx
modifier|*
name|preg
init|=
name|phi_alternative
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|)
decl_stmt|;
name|rtx
name|tgt
init|=
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
comment|/* There may be no phi alternative corresponding to this edge. 	 This indicates that the phi variable is undefined along this 	 edge.  */
if|if
condition|(
name|preg
operator|==
name|NULL
condition|)
continue|continue;
name|reg
operator|=
operator|*
name|preg
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|!=
name|REG
operator|||
name|GET_CODE
argument_list|(
name|tgt
argument_list|)
operator|!=
name|REG
condition|)
name|abort
argument_list|()
expr_stmt|;
name|reg
operator|=
name|regno_reg_rtx
index|[
name|partition_find
argument_list|(
name|reg_partition
argument_list|,
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
index|]
expr_stmt|;
name|tgt
operator|=
name|regno_reg_rtx
index|[
name|partition_find
argument_list|(
name|reg_partition
argument_list|,
name|REGNO
argument_list|(
name|tgt
argument_list|)
argument_list|)
index|]
expr_stmt|;
comment|/* If the two registers are already in the same partition,  	 nothing will need to be done.  */
if|if
condition|(
name|reg
operator|!=
name|tgt
condition|)
block|{
name|int
name|ireg
decl_stmt|,
name|itgt
decl_stmt|;
name|ireg
operator|=
name|ephi_add_node
argument_list|(
name|reg
argument_list|,
name|nodes
argument_list|,
operator|&
name|n_nodes
argument_list|)
expr_stmt|;
name|itgt
operator|=
name|ephi_add_node
argument_list|(
name|tgt
argument_list|,
name|nodes
argument_list|,
operator|&
name|n_nodes
argument_list|)
expr_stmt|;
name|SET_BIT
argument_list|(
name|pred
index|[
name|ireg
index|]
argument_list|,
name|itgt
argument_list|)
expr_stmt|;
name|SET_BIT
argument_list|(
name|succ
index|[
name|itgt
index|]
argument_list|,
name|ireg
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|n_nodes
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* Begin a topological sort of the graph.  */
name|visited
operator|=
name|sbitmap_alloc
argument_list|(
name|n_nodes
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|visited
argument_list|)
expr_stmt|;
name|tstack
operator|=
name|stack
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|n_nodes
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_nodes
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|visited
argument_list|,
name|i
argument_list|)
condition|)
name|tstack
operator|=
name|ephi_forward
argument_list|(
name|i
argument_list|,
name|visited
argument_list|,
name|succ
argument_list|,
name|tstack
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|visited
argument_list|)
expr_stmt|;
comment|/* As we find a solution to the tsort, collect the implementation       insns in a sequence.  */
name|start_sequence
argument_list|()
expr_stmt|;
while|while
condition|(
name|tstack
operator|!=
name|stack
condition|)
block|{
name|i
operator|=
operator|*
operator|--
name|tstack
expr_stmt|;
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|visited
argument_list|,
name|i
argument_list|)
condition|)
name|ephi_create
argument_list|(
name|i
argument_list|,
name|visited
argument_list|,
name|pred
argument_list|,
name|succ
argument_list|,
name|nodes
argument_list|)
expr_stmt|;
block|}
name|insn
operator|=
name|gen_sequence
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|insert_insn_on_edge
argument_list|(
name|insn
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Emitting copy on edge (%d,%d)\n"
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|visited
argument_list|)
expr_stmt|;
name|out
label|:
name|sbitmap_vector_free
argument_list|(
name|pred
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|succ
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* For basic block B, consider all phi insns which provide an    alternative corresponding to an incoming abnormal critical edge.    Place the phi alternative corresponding to that abnormal critical    edge in the same register class as the destination of the set.       From Morgan, p. 178:       For each abnormal critical edge (C, B),       if T0 = phi (T1, ..., Ti, ..., Tm) is a phi node in B,       and C is the ith predecessor of B,       then T0 and Ti must be equivalent.      Return non-zero iff any such cases were found for which the two    regs were not already in the same class.  */
end_comment

begin_function
specifier|static
name|int
name|make_regs_equivalent_over_bad_edges
parameter_list|(
name|bb
parameter_list|,
name|reg_partition
parameter_list|)
name|int
name|bb
decl_stmt|;
name|partition
name|reg_partition
decl_stmt|;
block|{
name|int
name|changed
init|=
literal|0
decl_stmt|;
name|basic_block
name|b
init|=
name|BASIC_BLOCK
argument_list|(
name|bb
argument_list|)
decl_stmt|;
name|rtx
name|phi
decl_stmt|;
comment|/* Advance to the first phi node.  */
name|phi
operator|=
name|first_insn_after_basic_block_note
argument_list|(
name|b
argument_list|)
expr_stmt|;
comment|/* Scan all the phi nodes.  */
for|for
control|(
init|;
name|PHI_NODE_P
argument_list|(
name|phi
argument_list|)
condition|;
name|phi
operator|=
name|next_nonnote_insn
argument_list|(
name|phi
argument_list|)
control|)
block|{
name|edge
name|e
decl_stmt|;
name|int
name|tgt_regno
decl_stmt|;
name|rtx
name|set
init|=
name|PATTERN
argument_list|(
name|phi
argument_list|)
decl_stmt|;
name|rtx
name|tgt
init|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
decl_stmt|;
comment|/* The set target is expected to be an SSA register.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|tgt
argument_list|)
operator|!=
name|REG
operator|||
operator|!
name|CONVERT_REGISTER_TO_SSA_P
argument_list|(
name|REGNO
argument_list|(
name|tgt
argument_list|)
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|tgt_regno
operator|=
name|REGNO
argument_list|(
name|tgt
argument_list|)
expr_stmt|;
comment|/* Scan incoming abnormal critical edges.  */
for|for
control|(
name|e
operator|=
name|b
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
if|if
condition|(
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
operator|)
operator|&&
name|EDGE_CRITICAL_P
argument_list|(
name|e
argument_list|)
condition|)
block|{
name|rtx
modifier|*
name|alt
init|=
name|phi_alternative
argument_list|(
name|set
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|)
decl_stmt|;
name|int
name|alt_regno
decl_stmt|;
comment|/* If there is no alternative corresponding to this edge, 	       the value is undefined along the edge, so just go on.  */
if|if
condition|(
name|alt
operator|==
literal|0
condition|)
continue|continue;
comment|/* The phi alternative is expected to be an SSA register.  */
if|if
condition|(
name|GET_CODE
argument_list|(
operator|*
name|alt
argument_list|)
operator|!=
name|REG
operator|||
operator|!
name|CONVERT_REGISTER_TO_SSA_P
argument_list|(
name|REGNO
argument_list|(
operator|*
name|alt
argument_list|)
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|alt_regno
operator|=
name|REGNO
argument_list|(
operator|*
name|alt
argument_list|)
expr_stmt|;
comment|/* If the set destination and the phi alternative aren't 	       already in the same class...  */
if|if
condition|(
name|partition_find
argument_list|(
name|reg_partition
argument_list|,
name|tgt_regno
argument_list|)
operator|!=
name|partition_find
argument_list|(
name|reg_partition
argument_list|,
name|alt_regno
argument_list|)
condition|)
block|{
comment|/* ... make them such.  */
if|if
condition|(
name|conflicting_hard_regs_p
argument_list|(
name|tgt_regno
argument_list|,
name|alt_regno
argument_list|)
condition|)
comment|/* It is illegal to unify a hard register with a 		     different register.  */
name|abort
argument_list|()
expr_stmt|;
name|partition_union
argument_list|(
name|reg_partition
argument_list|,
name|tgt_regno
argument_list|,
name|alt_regno
argument_list|)
expr_stmt|;
operator|++
name|changed
expr_stmt|;
block|}
block|}
block|}
return|return
name|changed
return|;
block|}
end_function

begin_comment
comment|/* Consider phi insns in basic block BB pairwise.  If the set target    of both isns are equivalent pseudos, make the corresponding phi    alternatives in each phi corresponding equivalent.     Return nonzero if any new register classes were unioned.  */
end_comment

begin_function
specifier|static
name|int
name|make_equivalent_phi_alternatives_equivalent
parameter_list|(
name|bb
parameter_list|,
name|reg_partition
parameter_list|)
name|int
name|bb
decl_stmt|;
name|partition
name|reg_partition
decl_stmt|;
block|{
name|int
name|changed
init|=
literal|0
decl_stmt|;
name|basic_block
name|b
init|=
name|BASIC_BLOCK
argument_list|(
name|bb
argument_list|)
decl_stmt|;
name|rtx
name|phi
decl_stmt|;
comment|/* Advance to the first phi node.  */
name|phi
operator|=
name|first_insn_after_basic_block_note
argument_list|(
name|b
argument_list|)
expr_stmt|;
comment|/* Scan all the phi nodes.  */
for|for
control|(
init|;
name|PHI_NODE_P
argument_list|(
name|phi
argument_list|)
condition|;
name|phi
operator|=
name|next_nonnote_insn
argument_list|(
name|phi
argument_list|)
control|)
block|{
name|rtx
name|set
init|=
name|PATTERN
argument_list|(
name|phi
argument_list|)
decl_stmt|;
comment|/* The regno of the destination of the set.  */
name|int
name|tgt_regno
init|=
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|phi
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|phi2
init|=
name|next_nonnote_insn
argument_list|(
name|phi
argument_list|)
decl_stmt|;
comment|/* Scan all phi nodes following this one.  */
for|for
control|(
init|;
name|PHI_NODE_P
argument_list|(
name|phi2
argument_list|)
condition|;
name|phi2
operator|=
name|next_nonnote_insn
argument_list|(
name|phi2
argument_list|)
control|)
block|{
name|rtx
name|set2
init|=
name|PATTERN
argument_list|(
name|phi2
argument_list|)
decl_stmt|;
comment|/* The regno of the destination of the set.  */
name|int
name|tgt2_regno
init|=
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set2
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Are the set destinations equivalent regs?  */
if|if
condition|(
name|partition_find
argument_list|(
name|reg_partition
argument_list|,
name|tgt_regno
argument_list|)
operator|==
name|partition_find
argument_list|(
name|reg_partition
argument_list|,
name|tgt2_regno
argument_list|)
condition|)
block|{
name|edge
name|e
decl_stmt|;
comment|/* Scan over edges.  */
for|for
control|(
name|e
operator|=
name|b
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
block|{
name|int
name|pred_block
init|=
name|e
operator|->
name|src
operator|->
name|index
decl_stmt|;
comment|/* Identify the phi alternatives from both phi 		     nodes corresponding to this edge.  */
name|rtx
modifier|*
name|alt
init|=
name|phi_alternative
argument_list|(
name|set
argument_list|,
name|pred_block
argument_list|)
decl_stmt|;
name|rtx
modifier|*
name|alt2
init|=
name|phi_alternative
argument_list|(
name|set2
argument_list|,
name|pred_block
argument_list|)
decl_stmt|;
comment|/* If one of the phi nodes doesn't have a 		     corresponding alternative, just skip it.  */
if|if
condition|(
name|alt
operator|==
literal|0
operator|||
name|alt2
operator|==
literal|0
condition|)
continue|continue;
comment|/* Both alternatives should be SSA registers.  */
if|if
condition|(
name|GET_CODE
argument_list|(
operator|*
name|alt
argument_list|)
operator|!=
name|REG
operator|||
operator|!
name|CONVERT_REGISTER_TO_SSA_P
argument_list|(
name|REGNO
argument_list|(
operator|*
name|alt
argument_list|)
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
operator|*
name|alt2
argument_list|)
operator|!=
name|REG
operator|||
operator|!
name|CONVERT_REGISTER_TO_SSA_P
argument_list|(
name|REGNO
argument_list|(
operator|*
name|alt2
argument_list|)
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If the alternatives aren't already in the same 		     class ...  */
if|if
condition|(
name|partition_find
argument_list|(
name|reg_partition
argument_list|,
name|REGNO
argument_list|(
operator|*
name|alt
argument_list|)
argument_list|)
operator|!=
name|partition_find
argument_list|(
name|reg_partition
argument_list|,
name|REGNO
argument_list|(
operator|*
name|alt2
argument_list|)
argument_list|)
condition|)
block|{
comment|/* ... make them so.  */
if|if
condition|(
name|conflicting_hard_regs_p
argument_list|(
name|REGNO
argument_list|(
operator|*
name|alt
argument_list|)
argument_list|,
name|REGNO
argument_list|(
operator|*
name|alt2
argument_list|)
argument_list|)
condition|)
comment|/* It is illegal to unify a hard register with 			   a different register.  */
name|abort
argument_list|()
expr_stmt|;
name|partition_union
argument_list|(
name|reg_partition
argument_list|,
name|REGNO
argument_list|(
operator|*
name|alt
argument_list|)
argument_list|,
name|REGNO
argument_list|(
operator|*
name|alt2
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|changed
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
return|return
name|changed
return|;
block|}
end_function

begin_comment
comment|/* Compute a conservative partition of outstanding pseudo registers.    See Morgan 7.3.1.  */
end_comment

begin_function
specifier|static
name|partition
name|compute_conservative_reg_partition
parameter_list|()
block|{
name|int
name|bb
decl_stmt|;
name|int
name|changed
init|=
literal|0
decl_stmt|;
comment|/* We don't actually work with hard registers, but it's easier to      carry them around anyway rather than constantly doing register      number arithmetic.  */
name|partition
name|p
init|=
name|partition_new
argument_list|(
name|ssa_definition
operator|->
name|num_elements
argument_list|)
decl_stmt|;
comment|/* The first priority is to make sure registers that might have to      be copied on abnormal critical edges are placed in the same      partition.  This saves us from having to split abnormal critical      edges.  */
for|for
control|(
name|bb
operator|=
name|n_basic_blocks
init|;
operator|--
name|bb
operator|>=
literal|0
condition|;
control|)
name|changed
operator|+=
name|make_regs_equivalent_over_bad_edges
argument_list|(
name|bb
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* Now we have to insure that corresponding arguments of phi nodes      assigning to corresponding regs are equivalent.  Iterate until      nothing changes.  */
while|while
condition|(
name|changed
operator|>
literal|0
condition|)
block|{
name|changed
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|bb
operator|=
name|n_basic_blocks
init|;
operator|--
name|bb
operator|>=
literal|0
condition|;
control|)
name|changed
operator|+=
name|make_equivalent_phi_alternatives_equivalent
argument_list|(
name|bb
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* The following functions compute a register partition that attempts    to eliminate as many reg copies and phi node copies as possible by    coalescing registers.   This is the strategy:      1. As in the conservative case, the top priority is to coalesce        registers that otherwise would cause copies to be placed on        abnormal critical edges (which isn't possible).      2. Figure out which regs are involved (in the LHS or RHS) of        copies and phi nodes.  Compute conflicts among these regs.        3. Walk around the instruction stream, placing two regs in the        same class of the partition if one appears on the LHS and the        other on the RHS of a copy or phi node and the two regs don't        conflict.  The conflict information of course needs to be        updated.        4. If anything has changed, there may be new opportunities to        coalesce regs, so go back to 2. */
end_comment

begin_comment
comment|/* If REG1 and REG2 don't conflict in CONFLICTS, place them in the    same class of partition P, if they aren't already.  Update    CONFLICTS appropriately.       Returns one if REG1 and REG2 were placed in the same class but were    not previously; zero otherwise.       See Morgan figure 11.15.  */
end_comment

begin_function
specifier|static
name|int
name|coalesce_if_unconflicting
parameter_list|(
name|p
parameter_list|,
name|conflicts
parameter_list|,
name|reg1
parameter_list|,
name|reg2
parameter_list|)
name|partition
name|p
decl_stmt|;
name|conflict_graph
name|conflicts
decl_stmt|;
name|int
name|reg1
decl_stmt|;
name|int
name|reg2
decl_stmt|;
block|{
name|int
name|reg
decl_stmt|;
comment|/* Work only on SSA registers.  */
if|if
condition|(
operator|!
name|CONVERT_REGISTER_TO_SSA_P
argument_list|(
name|reg1
argument_list|)
operator|||
operator|!
name|CONVERT_REGISTER_TO_SSA_P
argument_list|(
name|reg2
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Find the canonical regs for the classes containing REG1 and      REG2.  */
name|reg1
operator|=
name|partition_find
argument_list|(
name|p
argument_list|,
name|reg1
argument_list|)
expr_stmt|;
name|reg2
operator|=
name|partition_find
argument_list|(
name|p
argument_list|,
name|reg2
argument_list|)
expr_stmt|;
comment|/* If they're already in the same class, there's nothing to do.  */
if|if
condition|(
name|reg1
operator|==
name|reg2
condition|)
return|return
literal|0
return|;
comment|/* If the regs conflict, our hands are tied.  */
if|if
condition|(
name|conflicting_hard_regs_p
argument_list|(
name|reg1
argument_list|,
name|reg2
argument_list|)
operator|||
name|conflict_graph_conflict_p
argument_list|(
name|conflicts
argument_list|,
name|reg1
argument_list|,
name|reg2
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* We're good to go.  Put the regs in the same partition.  */
name|partition_union
argument_list|(
name|p
argument_list|,
name|reg1
argument_list|,
name|reg2
argument_list|)
expr_stmt|;
comment|/* Find the new canonical reg for the merged class.  */
name|reg
operator|=
name|partition_find
argument_list|(
name|p
argument_list|,
name|reg1
argument_list|)
expr_stmt|;
comment|/* Merge conflicts from the two previous classes.  */
name|conflict_graph_merge_regs
argument_list|(
name|conflicts
argument_list|,
name|reg
argument_list|,
name|reg1
argument_list|)
expr_stmt|;
name|conflict_graph_merge_regs
argument_list|(
name|conflicts
argument_list|,
name|reg
argument_list|,
name|reg2
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* For each register copy insn in basic block BB, place the LHS and    RHS regs in the same class in partition P if they do not conflict    according to CONFLICTS.     Returns the number of changes that were made to P.     See Morgan figure 11.14.  */
end_comment

begin_function
specifier|static
name|int
name|coalesce_regs_in_copies
parameter_list|(
name|bb
parameter_list|,
name|p
parameter_list|,
name|conflicts
parameter_list|)
name|basic_block
name|bb
decl_stmt|;
name|partition
name|p
decl_stmt|;
name|conflict_graph
name|conflicts
decl_stmt|;
block|{
name|int
name|changed
init|=
literal|0
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|rtx
name|end
init|=
name|bb
operator|->
name|end
decl_stmt|;
comment|/* Scan the instruction stream of the block.  */
for|for
control|(
name|insn
operator|=
name|bb
operator|->
name|head
init|;
name|insn
operator|!=
name|end
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|rtx
name|pattern
decl_stmt|;
name|rtx
name|src
decl_stmt|;
name|rtx
name|dest
decl_stmt|;
comment|/* If this isn't a set insn, go to the next insn.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|INSN
condition|)
continue|continue;
name|pattern
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
operator|!=
name|SET
condition|)
continue|continue;
name|src
operator|=
name|SET_SRC
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|dest
operator|=
name|SET_DEST
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
comment|/* We're only looking for copies.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|!=
name|REG
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|!=
name|REG
condition|)
continue|continue;
comment|/* Coalesce only if the reg modes are the same.  As long as 	 each reg's rtx is unique, it can have only one mode, so two 	 pseudos of different modes can't be coalesced into one.             FIXME: We can probably get around this by inserting SUBREGs          where appropriate, but for now we don't bother.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|src
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|dest
argument_list|)
condition|)
continue|continue;
comment|/* Found a copy; see if we can use the same reg for both the 	 source and destination (and thus eliminate the copy, 	 ultimately).  */
name|changed
operator|+=
name|coalesce_if_unconflicting
argument_list|(
name|p
argument_list|,
name|conflicts
argument_list|,
name|REGNO
argument_list|(
name|src
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|changed
return|;
block|}
end_function

begin_struct
struct|struct
name|phi_coalesce_context
block|{
name|partition
name|p
decl_stmt|;
name|conflict_graph
name|conflicts
decl_stmt|;
name|int
name|changed
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Callback function for for_each_successor_phi.  If the set    destination and the phi alternative regs do not conflict, place    them in the same paritition class.  DATA is a pointer to a    phi_coalesce_context struct.  */
end_comment

begin_function
specifier|static
name|int
name|coalesce_reg_in_phi
parameter_list|(
name|insn
parameter_list|,
name|dest_regno
parameter_list|,
name|src_regno
parameter_list|,
name|data
parameter_list|)
name|rtx
name|insn
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|dest_regno
decl_stmt|;
name|int
name|src_regno
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|struct
name|phi_coalesce_context
modifier|*
name|context
init|=
operator|(
expr|struct
name|phi_coalesce_context
operator|*
operator|)
name|data
decl_stmt|;
comment|/* Attempt to use the same reg, if they don't conflict.  */
name|context
operator|->
name|changed
operator|+=
name|coalesce_if_unconflicting
argument_list|(
name|context
operator|->
name|p
argument_list|,
name|context
operator|->
name|conflicts
argument_list|,
name|dest_regno
argument_list|,
name|src_regno
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* For each alternative in a phi function corresponding to basic block    BB (in phi nodes in successor block to BB), place the reg in the    phi alternative and the reg to which the phi value is set into the    same class in partition P, if allowed by CONFLICTS.       Return the number of changes that were made to P.        See Morgan figure 11.14.  */
end_comment

begin_function
specifier|static
name|int
name|coalesce_regs_in_successor_phi_nodes
parameter_list|(
name|bb
parameter_list|,
name|p
parameter_list|,
name|conflicts
parameter_list|)
name|basic_block
name|bb
decl_stmt|;
name|partition
name|p
decl_stmt|;
name|conflict_graph
name|conflicts
decl_stmt|;
block|{
name|struct
name|phi_coalesce_context
name|context
decl_stmt|;
name|context
operator|.
name|p
operator|=
name|p
expr_stmt|;
name|context
operator|.
name|conflicts
operator|=
name|conflicts
expr_stmt|;
name|context
operator|.
name|changed
operator|=
literal|0
expr_stmt|;
name|for_each_successor_phi
argument_list|(
name|bb
argument_list|,
operator|&
name|coalesce_reg_in_phi
argument_list|,
operator|&
name|context
argument_list|)
expr_stmt|;
return|return
name|context
operator|.
name|changed
return|;
block|}
end_function

begin_comment
comment|/* Compute and return a partition of pseudos.  Where possible,    non-conflicting pseudos are placed in the same class.       The caller is responsible for deallocating the returned partition.  */
end_comment

begin_function
specifier|static
name|partition
name|compute_coalesced_reg_partition
parameter_list|()
block|{
name|int
name|bb
decl_stmt|;
name|int
name|changed
init|=
literal|0
decl_stmt|;
name|regset_head
name|phi_set_head
decl_stmt|;
name|regset
name|phi_set
init|=
operator|&
name|phi_set_head
decl_stmt|;
name|partition
name|p
init|=
name|partition_new
argument_list|(
name|ssa_definition
operator|->
name|num_elements
argument_list|)
decl_stmt|;
comment|/* The first priority is to make sure registers that might have to      be copied on abnormal critical edges are placed in the same      partition.  This saves us from having to split abnormal critical      edges (which can't be done).  */
for|for
control|(
name|bb
operator|=
name|n_basic_blocks
init|;
operator|--
name|bb
operator|>=
literal|0
condition|;
control|)
name|make_regs_equivalent_over_bad_edges
argument_list|(
name|bb
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|INIT_REG_SET
argument_list|(
name|phi_set
argument_list|)
expr_stmt|;
do|do
block|{
name|conflict_graph
name|conflicts
decl_stmt|;
name|changed
operator|=
literal|0
expr_stmt|;
comment|/* Build the set of registers involved in phi nodes, either as 	 arguments to the phi function or as the target of a set.  */
name|CLEAR_REG_SET
argument_list|(
name|phi_set
argument_list|)
expr_stmt|;
name|mark_phi_and_copy_regs
argument_list|(
name|phi_set
argument_list|)
expr_stmt|;
comment|/* Compute conflicts.  */
name|conflicts
operator|=
name|conflict_graph_compute
argument_list|(
name|phi_set
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* FIXME: Better would be to process most frequently executed 	 blocks first, so that most frequently executed copies would 	 be more likely to be removed by register coalescing.  But any 	 order will generate correct, if non-optimal, results.  */
for|for
control|(
name|bb
operator|=
name|n_basic_blocks
init|;
operator|--
name|bb
operator|>=
literal|0
condition|;
control|)
block|{
name|basic_block
name|block
init|=
name|BASIC_BLOCK
argument_list|(
name|bb
argument_list|)
decl_stmt|;
name|changed
operator|+=
name|coalesce_regs_in_copies
argument_list|(
name|block
argument_list|,
name|p
argument_list|,
name|conflicts
argument_list|)
expr_stmt|;
name|changed
operator|+=
name|coalesce_regs_in_successor_phi_nodes
argument_list|(
name|block
argument_list|,
name|p
argument_list|,
name|conflicts
argument_list|)
expr_stmt|;
block|}
name|conflict_graph_delete
argument_list|(
name|conflicts
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|changed
operator|>
literal|0
condition|)
do|;
name|FREE_REG_SET
argument_list|(
name|phi_set
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Mark the regs in a phi node.  PTR is a phi expression or one of its    components (a REG or a CONST_INT).  DATA is a reg set in which to    set all regs.  Called from for_each_rtx.  */
end_comment

begin_function
specifier|static
name|int
name|mark_reg_in_phi
parameter_list|(
name|ptr
parameter_list|,
name|data
parameter_list|)
name|rtx
modifier|*
name|ptr
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|rtx
name|expr
init|=
operator|*
name|ptr
decl_stmt|;
name|regset
name|set
init|=
operator|(
name|regset
operator|)
name|data
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|expr
argument_list|)
condition|)
block|{
case|case
name|REG
case|:
name|SET_REGNO_REG_SET
argument_list|(
name|set
argument_list|,
name|REGNO
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
case|case
name|CONST_INT
case|:
case|case
name|PHI
case|:
return|return
literal|0
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Mark in PHI_SET all pseudos that are used in a phi node -- either    set from a phi expression, or used as an argument in one.  Also    mark regs that are the source or target of a reg copy.  Uses    ssa_definition.  */
end_comment

begin_function
specifier|static
name|void
name|mark_phi_and_copy_regs
parameter_list|(
name|phi_set
parameter_list|)
name|regset
name|phi_set
decl_stmt|;
block|{
name|unsigned
name|int
name|reg
decl_stmt|;
comment|/* Scan the definitions of all regs.  */
for|for
control|(
name|reg
operator|=
literal|0
init|;
name|reg
operator|<
name|VARRAY_SIZE
argument_list|(
name|ssa_definition
argument_list|)
condition|;
operator|++
name|reg
control|)
if|if
condition|(
name|CONVERT_REGISTER_TO_SSA_P
argument_list|(
name|reg
argument_list|)
condition|)
block|{
name|rtx
name|insn
init|=
name|VARRAY_RTX
argument_list|(
name|ssa_definition
argument_list|,
name|reg
argument_list|)
decl_stmt|;
name|rtx
name|pattern
decl_stmt|;
name|rtx
name|src
decl_stmt|;
if|if
condition|(
name|insn
operator|==
name|NULL
operator|||
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_DELETED
operator|)
condition|)
continue|continue;
name|pattern
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Sometimes we get PARALLEL insns.  These aren't phi nodes or 	   copies.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
operator|!=
name|SET
condition|)
continue|continue;
name|src
operator|=
name|SET_SRC
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|REG
condition|)
block|{
comment|/* It's a reg copy.  */
name|SET_REGNO_REG_SET
argument_list|(
name|phi_set
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|SET_REGNO_REG_SET
argument_list|(
name|phi_set
argument_list|,
name|REGNO
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|PHI
condition|)
block|{
comment|/* It's a phi node.  Mark the reg being set.  */
name|SET_REGNO_REG_SET
argument_list|(
name|phi_set
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Mark the regs used in the phi function.  */
name|for_each_rtx
argument_list|(
operator|&
name|src
argument_list|,
name|mark_reg_in_phi
argument_list|,
name|phi_set
argument_list|)
expr_stmt|;
block|}
comment|/* ... else nothing to do.  */
block|}
block|}
end_function

begin_comment
comment|/* Rename regs in insn PTR that are equivalent.  DATA is the register    partition which specifies equivalences.  */
end_comment

begin_function
specifier|static
name|int
name|rename_equivalent_regs_in_insn
parameter_list|(
name|ptr
parameter_list|,
name|data
parameter_list|)
name|rtx
modifier|*
name|ptr
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|rtx
name|x
init|=
operator|*
name|ptr
decl_stmt|;
name|partition
name|reg_partition
init|=
operator|(
name|partition
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|x
operator|==
name|NULL_RTX
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|REG
case|:
if|if
condition|(
name|CONVERT_REGISTER_TO_SSA_P
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|new_regno
init|=
name|partition_find
argument_list|(
name|reg_partition
argument_list|,
name|regno
argument_list|)
decl_stmt|;
name|rtx
name|canonical_element_rtx
init|=
name|ssa_rename_from_lookup
argument_list|(
name|new_regno
argument_list|)
decl_stmt|;
if|if
condition|(
name|canonical_element_rtx
operator|!=
name|NULL_RTX
operator|&&
name|HARD_REGISTER_P
argument_list|(
name|canonical_element_rtx
argument_list|)
condition|)
block|{
if|if
condition|(
name|REGNO
argument_list|(
name|canonical_element_rtx
argument_list|)
operator|!=
name|regno
condition|)
operator|*
name|ptr
operator|=
name|canonical_element_rtx
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regno
operator|!=
name|new_regno
condition|)
block|{
name|rtx
name|new_reg
init|=
name|regno_reg_rtx
index|[
name|new_regno
index|]
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|new_reg
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
operator|*
name|ptr
operator|=
name|new_reg
expr_stmt|;
block|}
block|}
return|return
operator|-
literal|1
return|;
case|case
name|PHI
case|:
comment|/* No need to rename the phi nodes.  We'll check equivalence 	 when inserting copies.  */
return|return
operator|-
literal|1
return|;
default|default:
comment|/* Anything else, continue traversing.  */
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Record the register's canonical element stored in SRFP in the    canonical_elements sbitmap packaged in DATA.  This function is used    as a callback function for traversing ssa_rename_from.  */
end_comment

begin_function
specifier|static
name|int
name|record_canonical_element_1
parameter_list|(
name|srfp
parameter_list|,
name|data
parameter_list|)
name|void
modifier|*
modifier|*
name|srfp
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|unsigned
name|int
name|reg
init|=
operator|(
operator|(
name|ssa_rename_from_pair
operator|*
operator|)
operator|*
name|srfp
operator|)
operator|->
name|reg
decl_stmt|;
name|sbitmap
name|canonical_elements
init|=
operator|(
operator|(
expr|struct
name|ssa_rename_from_hash_table_data
operator|*
operator|)
name|data
operator|)
operator|->
name|canonical_elements
decl_stmt|;
name|partition
name|reg_partition
init|=
operator|(
operator|(
expr|struct
name|ssa_rename_from_hash_table_data
operator|*
operator|)
name|data
operator|)
operator|->
name|reg_partition
decl_stmt|;
name|SET_BIT
argument_list|(
name|canonical_elements
argument_list|,
name|partition_find
argument_list|(
name|reg_partition
argument_list|,
name|reg
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* For each class in the REG_PARTITION corresponding to a particular    hard register and machine mode, check that there are no other    classes with the same hard register and machine mode.  Returns    nonzero if this is the case, i.e., the partition is acceptable.  */
end_comment

begin_function
specifier|static
name|int
name|check_hard_regs_in_partition
parameter_list|(
name|reg_partition
parameter_list|)
name|partition
name|reg_partition
decl_stmt|;
block|{
comment|/* CANONICAL_ELEMENTS has a nonzero bit if a class with the given register      number and machine mode has already been seen.  This is a      problem with the partition.  */
name|sbitmap
name|canonical_elements
decl_stmt|;
name|int
name|element_index
decl_stmt|;
name|int
name|already_seen
index|[
name|FIRST_PSEUDO_REGISTER
index|]
index|[
name|NUM_MACHINE_MODES
index|]
decl_stmt|;
name|int
name|reg
decl_stmt|;
name|int
name|mach_mode
decl_stmt|;
comment|/* Collect a list of canonical elements.  */
name|canonical_elements
operator|=
name|sbitmap_alloc
argument_list|(
name|max_reg_num
argument_list|()
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|canonical_elements
argument_list|)
expr_stmt|;
name|ssa_rename_from_traverse
argument_list|(
operator|&
name|record_canonical_element_1
argument_list|,
name|canonical_elements
argument_list|,
name|reg_partition
argument_list|)
expr_stmt|;
comment|/* We have not seen any hard register uses.  */
for|for
control|(
name|reg
operator|=
literal|0
init|;
name|reg
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
operator|++
name|reg
control|)
for|for
control|(
name|mach_mode
operator|=
literal|0
init|;
name|mach_mode
operator|<
name|NUM_MACHINE_MODES
condition|;
operator|++
name|mach_mode
control|)
name|already_seen
index|[
name|reg
index|]
index|[
name|mach_mode
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Check for classes with the same hard register and machine mode.  */
name|EXECUTE_IF_SET_IN_SBITMAP
argument_list|(
argument|canonical_elements
argument_list|,
literal|0
argument_list|,
argument|element_index
argument_list|,
argument|{     rtx hard_reg_rtx = ssa_rename_from_lookup (element_index);     if (hard_reg_rtx != NULL_RTX&& 	HARD_REGISTER_P (hard_reg_rtx)&& 	already_seen[REGNO (hard_reg_rtx)][GET_MODE (hard_reg_rtx)] !=
literal|0
argument|)
comment|/* Two distinct partition classes should be mapped to the same 	     hard register.  */
argument|return
literal|0
argument|;   }
argument_list|)
empty_stmt|;
name|sbitmap_free
argument_list|(
name|canonical_elements
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Rename regs that are equivalent in REG_PARTITION.  Also collapse    any SEQUENCE insns.  */
end_comment

begin_function
specifier|static
name|void
name|rename_equivalent_regs
parameter_list|(
name|reg_partition
parameter_list|)
name|partition
name|reg_partition
decl_stmt|;
block|{
name|int
name|bb
decl_stmt|;
for|for
control|(
name|bb
operator|=
name|n_basic_blocks
init|;
operator|--
name|bb
operator|>=
literal|0
condition|;
control|)
block|{
name|basic_block
name|b
init|=
name|BASIC_BLOCK
argument_list|(
name|bb
argument_list|)
decl_stmt|;
name|rtx
name|next
init|=
name|b
operator|->
name|head
decl_stmt|;
name|rtx
name|last
init|=
name|b
operator|->
name|end
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
do|do
block|{
name|insn
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|for_each_rtx
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|rename_equivalent_regs_in_insn
argument_list|,
name|reg_partition
argument_list|)
expr_stmt|;
name|for_each_rtx
argument_list|(
operator|&
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|,
name|rename_equivalent_regs_in_insn
argument_list|,
name|reg_partition
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
condition|)
block|{
name|rtx
name|s
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|int
name|slen
init|=
name|XVECLEN
argument_list|(
name|s
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|slen
operator|<=
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|=
name|XVECEXP
argument_list|(
name|s
argument_list|,
literal|0
argument_list|,
name|slen
operator|-
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|slen
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|emit_insn_before
argument_list|(
name|XVECEXP
argument_list|(
name|s
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|insn
operator|!=
name|last
condition|)
do|;
block|}
block|}
end_function

begin_comment
comment|/* The main entry point for moving from SSA.  */
end_comment

begin_function
name|void
name|convert_from_ssa
parameter_list|()
block|{
name|int
name|bb
decl_stmt|;
name|partition
name|reg_partition
decl_stmt|;
name|rtx
name|insns
init|=
name|get_insns
argument_list|()
decl_stmt|;
comment|/* Need global_live_at_{start,end} up to date.  There should not be      any significant dead code at this point, except perhaps dead      stores.  So do not take the time to perform dead code elimination.        Register coalescing needs death notes, so generate them.  */
name|life_analysis
argument_list|(
name|insns
argument_list|,
name|NULL
argument_list|,
name|PROP_DEATH_NOTES
argument_list|)
expr_stmt|;
comment|/* Figure out which regs in copies and phi nodes don't conflict and      therefore can be coalesced.  */
if|if
condition|(
name|conservative_reg_partition
condition|)
name|reg_partition
operator|=
name|compute_conservative_reg_partition
argument_list|()
expr_stmt|;
else|else
name|reg_partition
operator|=
name|compute_coalesced_reg_partition
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|check_hard_regs_in_partition
argument_list|(
name|reg_partition
argument_list|)
condition|)
comment|/* Two separate partitions should correspond to the same hard        register but do not.  */
name|abort
argument_list|()
expr_stmt|;
name|rename_equivalent_regs
argument_list|(
name|reg_partition
argument_list|)
expr_stmt|;
comment|/* Eliminate the PHI nodes.  */
for|for
control|(
name|bb
operator|=
name|n_basic_blocks
init|;
operator|--
name|bb
operator|>=
literal|0
condition|;
control|)
block|{
name|basic_block
name|b
init|=
name|BASIC_BLOCK
argument_list|(
name|bb
argument_list|)
decl_stmt|;
name|edge
name|e
decl_stmt|;
for|for
control|(
name|e
operator|=
name|b
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
if|if
condition|(
name|e
operator|->
name|src
operator|!=
name|ENTRY_BLOCK_PTR
condition|)
name|eliminate_phi
argument_list|(
name|e
argument_list|,
name|reg_partition
argument_list|)
expr_stmt|;
block|}
name|partition_delete
argument_list|(
name|reg_partition
argument_list|)
expr_stmt|;
comment|/* Actually delete the PHI nodes.  */
for|for
control|(
name|bb
operator|=
name|n_basic_blocks
init|;
operator|--
name|bb
operator|>=
literal|0
condition|;
control|)
block|{
name|rtx
name|insn
init|=
name|BLOCK_HEAD
argument_list|(
name|bb
argument_list|)
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* If this is a PHI node delete it.  */
if|if
condition|(
name|PHI_NODE_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
if|if
condition|(
name|insn
operator|==
name|BLOCK_END
argument_list|(
name|bb
argument_list|)
condition|)
name|BLOCK_END
argument_list|(
name|bb
argument_list|)
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|insn
operator|=
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* Since all the phi nodes come at the beginning of the 	     block, if we find an ordinary insn, we can stop looking 	     for more phi nodes.  */
elseif|else
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
break|break;
comment|/* If we've reached the end of the block, stop.  */
elseif|else
if|if
condition|(
name|insn
operator|==
name|BLOCK_END
argument_list|(
name|bb
argument_list|)
condition|)
break|break;
else|else
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Commit all the copy nodes needed to convert out of SSA form.  */
name|commit_edge_insertions
argument_list|()
expr_stmt|;
name|in_ssa_form
operator|=
literal|0
expr_stmt|;
name|count_or_remove_death_notes
argument_list|(
name|NULL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Deallocate the data structures.  */
name|VARRAY_FREE
argument_list|(
name|ssa_definition
argument_list|)
expr_stmt|;
name|ssa_rename_from_free
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Scan phi nodes in successors to BB.  For each such phi node that    has a phi alternative value corresponding to BB, invoke FN.  FN    is passed the entire phi node insn, the regno of the set    destination, the regno of the phi argument corresponding to BB,    and DATA.     If FN ever returns non-zero, stops immediately and returns this    value.  Otherwise, returns zero.  */
end_comment

begin_function
name|int
name|for_each_successor_phi
parameter_list|(
name|bb
parameter_list|,
name|fn
parameter_list|,
name|data
parameter_list|)
name|basic_block
name|bb
decl_stmt|;
name|successor_phi_fn
name|fn
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|edge
name|e
decl_stmt|;
if|if
condition|(
name|bb
operator|==
name|EXIT_BLOCK_PTR
condition|)
return|return
literal|0
return|;
comment|/* Scan outgoing edges.  */
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
operator|!=
name|NULL
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
block|{
name|rtx
name|insn
decl_stmt|;
name|basic_block
name|successor
init|=
name|e
operator|->
name|dest
decl_stmt|;
if|if
condition|(
name|successor
operator|==
name|ENTRY_BLOCK_PTR
operator|||
name|successor
operator|==
name|EXIT_BLOCK_PTR
condition|)
continue|continue;
comment|/* Advance to the first non-label insn of the successor block.  */
name|insn
operator|=
name|first_insn_after_basic_block_note
argument_list|(
name|successor
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|NULL
condition|)
continue|continue;
comment|/* Scan phi nodes in the successor.  */
for|for
control|(
init|;
name|PHI_NODE_P
argument_list|(
name|insn
argument_list|)
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|int
name|result
decl_stmt|;
name|rtx
name|phi_set
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
modifier|*
name|alternative
init|=
name|phi_alternative
argument_list|(
name|phi_set
argument_list|,
name|bb
operator|->
name|index
argument_list|)
decl_stmt|;
name|rtx
name|phi_src
decl_stmt|;
comment|/* This phi function may not have an alternative 	     corresponding to the incoming edge, indicating the 	     assigned variable is not defined along the edge.  */
if|if
condition|(
name|alternative
operator|==
name|NULL
condition|)
continue|continue;
name|phi_src
operator|=
operator|*
name|alternative
expr_stmt|;
comment|/* Invoke the callback.  */
name|result
operator|=
call|(
modifier|*
name|fn
call|)
argument_list|(
name|insn
argument_list|,
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|phi_set
argument_list|)
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|phi_src
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/* Terminate if requested.  */
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
return|return
name|result
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Assuming the ssa_rename_from mapping has been established, yields    nonzero if 1) only one SSA register of REG1 and REG2 comes from a    hard register or 2) both SSA registers REG1 and REG2 come from    different hard registers.  */
end_comment

begin_function
specifier|static
name|int
name|conflicting_hard_regs_p
parameter_list|(
name|reg1
parameter_list|,
name|reg2
parameter_list|)
name|int
name|reg1
decl_stmt|;
name|int
name|reg2
decl_stmt|;
block|{
name|int
name|orig_reg1
init|=
name|original_register
argument_list|(
name|reg1
argument_list|)
decl_stmt|;
name|int
name|orig_reg2
init|=
name|original_register
argument_list|(
name|reg2
argument_list|)
decl_stmt|;
if|if
condition|(
name|HARD_REGISTER_NUM_P
argument_list|(
name|orig_reg1
argument_list|)
operator|&&
name|HARD_REGISTER_NUM_P
argument_list|(
name|orig_reg2
argument_list|)
operator|&&
name|orig_reg1
operator|!=
name|orig_reg2
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|HARD_REGISTER_NUM_P
argument_list|(
name|orig_reg1
argument_list|)
operator|&&
operator|!
name|HARD_REGISTER_NUM_P
argument_list|(
name|orig_reg2
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|HARD_REGISTER_NUM_P
argument_list|(
name|orig_reg1
argument_list|)
operator|&&
name|HARD_REGISTER_NUM_P
argument_list|(
name|orig_reg2
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

end_unit

