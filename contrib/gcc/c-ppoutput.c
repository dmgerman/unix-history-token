begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Preprocess only, using cpplib.    Copyright (C) 1995, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004    Free Software Foundation, Inc.    Written by Per Bothner, 1994-95.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"cpplib.h"
end_include

begin_include
include|#
directive|include
file|"cpphash.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"c-common.h"
end_include

begin_comment
comment|/* For flags.  */
end_comment

begin_include
include|#
directive|include
file|"c-pragma.h"
end_include

begin_comment
comment|/* For parse_in.  */
end_comment

begin_comment
comment|/* Encapsulates state used to convert a stream of tokens into a text    file.  */
end_comment

begin_struct
specifier|static
struct|struct
block|{
name|FILE
modifier|*
name|outf
decl_stmt|;
comment|/* Stream to write to.  */
specifier|const
name|struct
name|line_map
modifier|*
name|map
decl_stmt|;
comment|/* Logical to physical line mappings.  */
specifier|const
name|cpp_token
modifier|*
name|prev
decl_stmt|;
comment|/* Previous token.  */
specifier|const
name|cpp_token
modifier|*
name|source
decl_stmt|;
comment|/* Source token for spacing.  */
name|fileline
name|line
decl_stmt|;
comment|/* Line currently being written.  */
name|unsigned
name|char
name|printed
decl_stmt|;
comment|/* Nonzero if something output at line.  */
block|}
name|print
struct|;
end_struct

begin_comment
comment|/* General output routines.  */
end_comment

begin_function_decl
specifier|static
name|void
name|scan_translation_unit
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|scan_translation_unit_trad
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|account_for_newlines
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dump_macro
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|,
name|cpp_hashnode
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_line
parameter_list|(
specifier|const
name|struct
name|line_map
modifier|*
parameter_list|,
name|fileline
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|maybe_print_line
parameter_list|(
specifier|const
name|struct
name|line_map
modifier|*
parameter_list|,
name|fileline
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Callback routines for the parser.   Most of these are active only    in specific modes.  */
end_comment

begin_function_decl
specifier|static
name|void
name|cb_line_change
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|,
specifier|const
name|cpp_token
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cb_define
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|,
name|fileline
parameter_list|,
name|cpp_hashnode
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cb_undef
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|,
name|fileline
parameter_list|,
name|cpp_hashnode
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cb_include
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|,
name|fileline
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cb_ident
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|,
name|fileline
parameter_list|,
specifier|const
name|cpp_string
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cb_def_pragma
parameter_list|(
name|cpp_reader
modifier|*
parameter_list|,
name|fileline
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Preprocess and output.  */
end_comment

begin_function
name|void
name|preprocess_file
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|)
block|{
comment|/* A successful cpp_read_main_file guarantees that we can call      cpp_scan_nooutput or cpp_get_token next.  */
if|if
condition|(
name|flag_no_output
condition|)
block|{
comment|/* Scan -included buffers, then the main file.  */
while|while
condition|(
name|pfile
operator|->
name|buffer
operator|->
name|prev
condition|)
name|cpp_scan_nooutput
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
name|cpp_scan_nooutput
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cpp_get_options
argument_list|(
name|pfile
argument_list|)
operator|->
name|traditional
condition|)
name|scan_translation_unit_trad
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
else|else
name|scan_translation_unit
argument_list|(
name|pfile
argument_list|)
expr_stmt|;
comment|/* -dM command line option.  Should this be elsewhere?  */
if|if
condition|(
name|flag_dump_macros
operator|==
literal|'M'
condition|)
name|cpp_forall_identifiers
argument_list|(
name|pfile
argument_list|,
name|dump_macro
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Flush any pending output.  */
if|if
condition|(
name|print
operator|.
name|printed
condition|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|print
operator|.
name|outf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set up the callbacks as appropriate.  */
end_comment

begin_function
name|void
name|init_pp_output
parameter_list|(
name|FILE
modifier|*
name|out_stream
parameter_list|)
block|{
name|cpp_callbacks
modifier|*
name|cb
init|=
name|cpp_get_callbacks
argument_list|(
name|parse_in
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|flag_no_output
condition|)
block|{
name|cb
operator|->
name|line_change
operator|=
name|cb_line_change
expr_stmt|;
comment|/* Don't emit #pragma or #ident directives if we are processing 	 assembly language; the assembler may choke on them.  */
if|if
condition|(
name|cpp_get_options
argument_list|(
name|parse_in
argument_list|)
operator|->
name|lang
operator|!=
name|CLK_ASM
condition|)
block|{
name|cb
operator|->
name|ident
operator|=
name|cb_ident
expr_stmt|;
name|cb
operator|->
name|def_pragma
operator|=
name|cb_def_pragma
expr_stmt|;
block|}
block|}
if|if
condition|(
name|flag_dump_includes
condition|)
name|cb
operator|->
name|include
operator|=
name|cb_include
expr_stmt|;
if|if
condition|(
name|flag_dump_macros
operator|==
literal|'N'
operator|||
name|flag_dump_macros
operator|==
literal|'D'
condition|)
block|{
name|cb
operator|->
name|define
operator|=
name|cb_define
expr_stmt|;
name|cb
operator|->
name|undef
operator|=
name|cb_undef
expr_stmt|;
block|}
comment|/* Initialize the print structure.  Setting print.line to -1 here is      a trick to guarantee that the first token of the file will cause      a linemarker to be output by maybe_print_line.  */
name|print
operator|.
name|line
operator|=
operator|(
name|fileline
operator|)
operator|-
literal|1
expr_stmt|;
name|print
operator|.
name|printed
operator|=
literal|0
expr_stmt|;
name|print
operator|.
name|prev
operator|=
literal|0
expr_stmt|;
name|print
operator|.
name|map
operator|=
literal|0
expr_stmt|;
name|print
operator|.
name|outf
operator|=
name|out_stream
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Writes out the preprocessed file, handling spacing and paste    avoidance issues.  */
end_comment

begin_function
specifier|static
name|void
name|scan_translation_unit
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|)
block|{
name|bool
name|avoid_paste
init|=
name|false
decl_stmt|;
name|print
operator|.
name|source
operator|=
name|NULL
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|const
name|cpp_token
modifier|*
name|token
init|=
name|cpp_get_token
argument_list|(
name|pfile
argument_list|)
decl_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_PADDING
condition|)
block|{
name|avoid_paste
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|print
operator|.
name|source
operator|==
name|NULL
operator|||
operator|(
operator|!
operator|(
name|print
operator|.
name|source
operator|->
name|flags
operator|&
name|PREV_WHITE
operator|)
operator|&&
name|token
operator|->
name|val
operator|.
name|source
operator|==
name|NULL
operator|)
condition|)
name|print
operator|.
name|source
operator|=
name|token
operator|->
name|val
operator|.
name|source
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_EOF
condition|)
break|break;
comment|/* Subtle logic to output a space if and only if necessary.  */
if|if
condition|(
name|avoid_paste
condition|)
block|{
if|if
condition|(
name|print
operator|.
name|source
operator|==
name|NULL
condition|)
name|print
operator|.
name|source
operator|=
name|token
expr_stmt|;
if|if
condition|(
name|print
operator|.
name|source
operator|->
name|flags
operator|&
name|PREV_WHITE
operator|||
operator|(
name|print
operator|.
name|prev
operator|&&
name|cpp_avoid_paste
argument_list|(
name|pfile
argument_list|,
name|print
operator|.
name|prev
argument_list|,
name|token
argument_list|)
operator|)
operator|||
operator|(
name|print
operator|.
name|prev
operator|==
name|NULL
operator|&&
name|token
operator|->
name|type
operator|==
name|CPP_HASH
operator|)
condition|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|print
operator|.
name|outf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|->
name|flags
operator|&
name|PREV_WHITE
condition|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|print
operator|.
name|outf
argument_list|)
expr_stmt|;
name|avoid_paste
operator|=
name|false
expr_stmt|;
name|print
operator|.
name|source
operator|=
name|NULL
expr_stmt|;
name|print
operator|.
name|prev
operator|=
name|token
expr_stmt|;
name|cpp_output_token
argument_list|(
name|token
argument_list|,
name|print
operator|.
name|outf
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_COMMENT
condition|)
name|account_for_newlines
argument_list|(
name|token
operator|->
name|val
operator|.
name|str
operator|.
name|text
argument_list|,
name|token
operator|->
name|val
operator|.
name|str
operator|.
name|len
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Adjust print.line for newlines embedded in output.  */
end_comment

begin_function
specifier|static
name|void
name|account_for_newlines
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|str
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
while|while
condition|(
name|len
operator|--
condition|)
if|if
condition|(
operator|*
name|str
operator|++
operator|==
literal|'\n'
condition|)
name|print
operator|.
name|line
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Writes out a traditionally preprocessed file.  */
end_comment

begin_function
specifier|static
name|void
name|scan_translation_unit_trad
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|)
block|{
while|while
condition|(
name|_cpp_read_logical_line_trad
argument_list|(
name|pfile
argument_list|)
condition|)
block|{
name|size_t
name|len
init|=
name|pfile
operator|->
name|out
operator|.
name|cur
operator|-
name|pfile
operator|->
name|out
operator|.
name|base
decl_stmt|;
name|maybe_print_line
argument_list|(
name|print
operator|.
name|map
argument_list|,
name|pfile
operator|->
name|out
operator|.
name|first_line
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
name|pfile
operator|->
name|out
operator|.
name|base
argument_list|,
literal|1
argument_list|,
name|len
argument_list|,
name|print
operator|.
name|outf
argument_list|)
expr_stmt|;
name|print
operator|.
name|printed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|discard_comments
argument_list|)
condition|)
name|account_for_newlines
argument_list|(
name|pfile
operator|->
name|out
operator|.
name|base
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* If the token read on logical line LINE needs to be output on a    different line to the current one, output the required newlines or    a line marker, and return 1.  Otherwise return 0.  */
end_comment

begin_function
specifier|static
name|void
name|maybe_print_line
parameter_list|(
specifier|const
name|struct
name|line_map
modifier|*
name|map
parameter_list|,
name|fileline
name|line
parameter_list|)
block|{
comment|/* End the previous line of text.  */
if|if
condition|(
name|print
operator|.
name|printed
condition|)
block|{
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|print
operator|.
name|outf
argument_list|)
expr_stmt|;
name|print
operator|.
name|line
operator|++
expr_stmt|;
name|print
operator|.
name|printed
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|line
operator|>=
name|print
operator|.
name|line
operator|&&
name|line
operator|<
name|print
operator|.
name|line
operator|+
literal|8
condition|)
block|{
while|while
condition|(
name|line
operator|>
name|print
operator|.
name|line
condition|)
block|{
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|print
operator|.
name|outf
argument_list|)
expr_stmt|;
name|print
operator|.
name|line
operator|++
expr_stmt|;
block|}
block|}
else|else
name|print_line
argument_list|(
name|map
argument_list|,
name|line
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output a line marker for logical line LINE.  Special flags are "1"    or "2" indicating entering or leaving a file.  */
end_comment

begin_function
specifier|static
name|void
name|print_line
parameter_list|(
specifier|const
name|struct
name|line_map
modifier|*
name|map
parameter_list|,
name|fileline
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|special_flags
parameter_list|)
block|{
comment|/* End any previous line of text.  */
if|if
condition|(
name|print
operator|.
name|printed
condition|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|print
operator|.
name|outf
argument_list|)
expr_stmt|;
name|print
operator|.
name|printed
operator|=
literal|0
expr_stmt|;
name|print
operator|.
name|line
operator|=
name|line
expr_stmt|;
if|if
condition|(
operator|!
name|flag_no_line_commands
condition|)
block|{
name|size_t
name|to_file_len
init|=
name|strlen
argument_list|(
name|map
operator|->
name|to_file
argument_list|)
decl_stmt|;
name|unsigned
name|char
modifier|*
name|to_file_quoted
init|=
name|alloca
argument_list|(
name|to_file_len
operator|*
literal|4
operator|+
literal|1
argument_list|)
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
comment|/* cpp_quote_string does not nul-terminate, so we have to do it 	 ourselves.  */
name|p
operator|=
name|cpp_quote_string
argument_list|(
name|to_file_quoted
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|map
operator|->
name|to_file
argument_list|,
name|to_file_len
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|fprintf
argument_list|(
name|print
operator|.
name|outf
argument_list|,
literal|"# %u \"%s\"%s"
argument_list|,
name|SOURCE_LINE
argument_list|(
name|map
argument_list|,
name|print
operator|.
name|line
argument_list|)
argument_list|,
name|to_file_quoted
argument_list|,
name|special_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|->
name|sysp
operator|==
literal|2
condition|)
name|fputs
argument_list|(
literal|" 3 4"
argument_list|,
name|print
operator|.
name|outf
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|map
operator|->
name|sysp
operator|==
literal|1
condition|)
name|fputs
argument_list|(
literal|" 3"
argument_list|,
name|print
operator|.
name|outf
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|print
operator|.
name|outf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Called when a line of output is started.  TOKEN is the first token    of the line, and at end of file will be CPP_EOF.  */
end_comment

begin_function
specifier|static
name|void
name|cb_line_change
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
specifier|const
name|cpp_token
modifier|*
name|token
parameter_list|,
name|int
name|parsing_args
parameter_list|)
block|{
if|if
condition|(
name|token
operator|->
name|type
operator|==
name|CPP_EOF
operator|||
name|parsing_args
condition|)
return|return;
name|maybe_print_line
argument_list|(
name|print
operator|.
name|map
argument_list|,
name|token
operator|->
name|line
argument_list|)
expr_stmt|;
name|print
operator|.
name|prev
operator|=
literal|0
expr_stmt|;
name|print
operator|.
name|source
operator|=
literal|0
expr_stmt|;
comment|/* Supply enough spaces to put this token in its original column,      one space per column greater than 2, since scan_translation_unit      will provide a space if PREV_WHITE.  Don't bother trying to      reconstruct tabs; we can't get it right in general, and nothing      ought to care.  Some things do care; the fault lies with them.  */
if|if
condition|(
operator|!
name|CPP_OPTION
argument_list|(
name|pfile
argument_list|,
name|traditional
argument_list|)
condition|)
block|{
name|print
operator|.
name|printed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|token
operator|->
name|col
operator|>
literal|2
condition|)
block|{
name|unsigned
name|int
name|spaces
init|=
name|token
operator|->
name|col
operator|-
literal|2
decl_stmt|;
while|while
condition|(
name|spaces
operator|--
condition|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|print
operator|.
name|outf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|cb_ident
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
name|ATTRIBUTE_UNUSED
parameter_list|,
name|fileline
name|line
parameter_list|,
specifier|const
name|cpp_string
modifier|*
name|str
parameter_list|)
block|{
name|maybe_print_line
argument_list|(
name|print
operator|.
name|map
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|print
operator|.
name|outf
argument_list|,
literal|"#ident %s\n"
argument_list|,
name|str
operator|->
name|text
argument_list|)
expr_stmt|;
name|print
operator|.
name|line
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cb_define
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|fileline
name|line
parameter_list|,
name|cpp_hashnode
modifier|*
name|node
parameter_list|)
block|{
name|maybe_print_line
argument_list|(
name|print
operator|.
name|map
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"#define "
argument_list|,
name|print
operator|.
name|outf
argument_list|)
expr_stmt|;
comment|/* 'D' is whole definition; 'N' is name only.  */
if|if
condition|(
name|flag_dump_macros
operator|==
literal|'D'
condition|)
name|fputs
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|cpp_macro_definition
argument_list|(
name|pfile
argument_list|,
name|node
argument_list|)
argument_list|,
name|print
operator|.
name|outf
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|NODE_NAME
argument_list|(
name|node
argument_list|)
argument_list|,
name|print
operator|.
name|outf
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|print
operator|.
name|outf
argument_list|)
expr_stmt|;
name|print
operator|.
name|line
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cb_undef
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
name|ATTRIBUTE_UNUSED
parameter_list|,
name|fileline
name|line
parameter_list|,
name|cpp_hashnode
modifier|*
name|node
parameter_list|)
block|{
name|maybe_print_line
argument_list|(
name|print
operator|.
name|map
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|print
operator|.
name|outf
argument_list|,
literal|"#undef %s\n"
argument_list|,
name|NODE_NAME
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|print
operator|.
name|line
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cb_include
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
name|ATTRIBUTE_UNUSED
parameter_list|,
name|fileline
name|line
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|dir
parameter_list|,
specifier|const
name|char
modifier|*
name|header
parameter_list|,
name|int
name|angle_brackets
parameter_list|)
block|{
name|maybe_print_line
argument_list|(
name|print
operator|.
name|map
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|angle_brackets
condition|)
name|fprintf
argument_list|(
name|print
operator|.
name|outf
argument_list|,
literal|"#%s<%s>\n"
argument_list|,
name|dir
argument_list|,
name|header
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|print
operator|.
name|outf
argument_list|,
literal|"#%s \"%s\"\n"
argument_list|,
name|dir
argument_list|,
name|header
argument_list|)
expr_stmt|;
name|print
operator|.
name|line
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Callback called when -fworking-director and -E to emit working    diretory in cpp output file. */
end_comment

begin_function
name|void
name|pp_dir_change
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|dir
parameter_list|)
block|{
name|size_t
name|to_file_len
init|=
name|strlen
argument_list|(
name|dir
argument_list|)
decl_stmt|;
name|unsigned
name|char
modifier|*
name|to_file_quoted
init|=
name|alloca
argument_list|(
name|to_file_len
operator|*
literal|4
operator|+
literal|1
argument_list|)
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
comment|/* cpp_quote_string does not nul-terminate, so we have to do it ourselves. */
name|p
operator|=
name|cpp_quote_string
argument_list|(
name|to_file_quoted
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|dir
argument_list|,
name|to_file_len
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|fprintf
argument_list|(
name|print
operator|.
name|outf
argument_list|,
literal|"# 1 \"%s//\"\n"
argument_list|,
name|to_file_quoted
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The file name, line number or system header flags have changed, as    described in MAP.  From this point on, the old print.map might be    pointing to freed memory, and so must not be dereferenced.  */
end_comment

begin_function
name|void
name|pp_file_change
parameter_list|(
specifier|const
name|struct
name|line_map
modifier|*
name|map
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|flags
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|flag_no_line_commands
condition|)
return|return;
if|if
condition|(
name|map
operator|!=
name|NULL
condition|)
block|{
comment|/* First time?  */
if|if
condition|(
name|print
operator|.
name|map
operator|==
name|NULL
condition|)
block|{
comment|/* Avoid printing foo.i when the main file is foo.c.  */
if|if
condition|(
operator|!
name|cpp_get_options
argument_list|(
name|parse_in
argument_list|)
operator|->
name|preprocessed
condition|)
name|print_line
argument_list|(
name|map
argument_list|,
name|map
operator|->
name|from_line
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Bring current file to correct line when entering a new file.  */
if|if
condition|(
name|map
operator|->
name|reason
operator|==
name|LC_ENTER
condition|)
name|maybe_print_line
argument_list|(
name|map
operator|-
literal|1
argument_list|,
name|map
operator|->
name|from_line
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|->
name|reason
operator|==
name|LC_ENTER
condition|)
name|flags
operator|=
literal|" 1"
expr_stmt|;
elseif|else
if|if
condition|(
name|map
operator|->
name|reason
operator|==
name|LC_LEAVE
condition|)
name|flags
operator|=
literal|" 2"
expr_stmt|;
name|print_line
argument_list|(
name|map
argument_list|,
name|map
operator|->
name|from_line
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
block|}
name|print
operator|.
name|map
operator|=
name|map
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy a #pragma directive to the preprocessed output.  */
end_comment

begin_function
specifier|static
name|void
name|cb_def_pragma
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|fileline
name|line
parameter_list|)
block|{
name|maybe_print_line
argument_list|(
name|print
operator|.
name|map
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"#pragma "
argument_list|,
name|print
operator|.
name|outf
argument_list|)
expr_stmt|;
name|cpp_output_line
argument_list|(
name|pfile
argument_list|,
name|print
operator|.
name|outf
argument_list|)
expr_stmt|;
name|print
operator|.
name|line
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump out the hash table.  */
end_comment

begin_function
specifier|static
name|int
name|dump_macro
parameter_list|(
name|cpp_reader
modifier|*
name|pfile
parameter_list|,
name|cpp_hashnode
modifier|*
name|node
parameter_list|,
name|void
modifier|*
name|v
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|node
operator|->
name|type
operator|==
name|NT_MACRO
operator|&&
operator|!
operator|(
name|node
operator|->
name|flags
operator|&
name|NODE_BUILTIN
operator|)
condition|)
block|{
name|fputs
argument_list|(
literal|"#define "
argument_list|,
name|print
operator|.
name|outf
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|cpp_macro_definition
argument_list|(
name|pfile
argument_list|,
name|node
argument_list|)
argument_list|,
name|print
operator|.
name|outf
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|print
operator|.
name|outf
argument_list|)
expr_stmt|;
name|print
operator|.
name|line
operator|++
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

end_unit

