begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* This is a software decimal floating point library.    Copyright (C) 2005, 2006 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  In addition to the permissions in the GNU General Public License, the Free Software Foundation gives you unlimited permission to link the compiled version of this file into combinations with other programs, and to distribute those combinations without any restriction coming from the use of this file.  (The General Public License restrictions do apply in other respects; for example, they cover modification of the file, and distribution when not linked into a combine executable.)  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* This implements IEEE 754R decimal floating point arithmetic, but    does not provide a mechanism for setting the rounding mode, or for    generating or handling exceptions.  Conversions between decimal    floating point types and other types depend on C library functions.     Contributed by Ben Elliston<bje@au.ibm.com>.  */
end_comment

begin_comment
comment|/* The intended way to use this file is to make two copies, add `#define '    to one copy, then compile both copies and add them to libgcc.a.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|"config/dfp-bit.h"
end_include

begin_comment
comment|/* Forward declarations.  */
end_comment

begin_if
if|#
directive|if
name|WIDTH
operator|==
literal|32
operator|||
name|WIDTH_TO
operator|==
literal|32
end_if

begin_function_decl
name|void
name|__host_to_ieee_32
parameter_list|(
name|_Decimal32
name|in
parameter_list|,
name|decimal32
modifier|*
name|out
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|__ieee_to_host_32
parameter_list|(
name|decimal32
name|in
parameter_list|,
name|_Decimal32
modifier|*
name|out
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|WIDTH
operator|==
literal|64
operator|||
name|WIDTH_TO
operator|==
literal|64
end_if

begin_function_decl
name|void
name|__host_to_ieee_64
parameter_list|(
name|_Decimal64
name|in
parameter_list|,
name|decimal64
modifier|*
name|out
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|__ieee_to_host_64
parameter_list|(
name|decimal64
name|in
parameter_list|,
name|_Decimal64
modifier|*
name|out
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|WIDTH
operator|==
literal|128
operator|||
name|WIDTH_TO
operator|==
literal|128
end_if

begin_function_decl
name|void
name|__host_to_ieee_128
parameter_list|(
name|_Decimal128
name|in
parameter_list|,
name|decimal128
modifier|*
name|out
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|__ieee_to_host_128
parameter_list|(
name|decimal128
name|in
parameter_list|,
name|_Decimal128
modifier|*
name|out
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* A pointer to a unary decNumber operation.  */
end_comment

begin_typedef
typedef|typedef
name|decNumber
modifier|*
function_decl|(
modifier|*
name|dfp_unary_func
function_decl|)
parameter_list|(
name|decNumber
modifier|*
parameter_list|,
name|decNumber
modifier|*
parameter_list|,
name|decContext
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_comment
comment|/* A pointer to a binary decNumber operation.  */
end_comment

begin_typedef
typedef|typedef
name|decNumber
modifier|*
function_decl|(
modifier|*
name|dfp_binary_func
function_decl|)
parameter_list|(
name|decNumber
modifier|*
parameter_list|,
name|decNumber
modifier|*
parameter_list|,
name|decNumber
modifier|*
parameter_list|,
name|decContext
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_function_decl
specifier|extern
name|unsigned
name|long
name|__dec_byte_swap
parameter_list|(
name|unsigned
name|long
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Unary operations.  */
end_comment

begin_function
specifier|static
specifier|inline
name|DFP_C_TYPE
name|dfp_unary_op
parameter_list|(
name|dfp_unary_func
name|op
parameter_list|,
name|DFP_C_TYPE
name|arg
parameter_list|)
block|{
name|DFP_C_TYPE
name|result
decl_stmt|;
name|decContext
name|context
decl_stmt|;
name|decNumber
name|arg1
decl_stmt|,
name|res
decl_stmt|;
name|IEEE_TYPE
name|a
decl_stmt|,
name|encoded_result
decl_stmt|;
name|HOST_TO_IEEE
argument_list|(
name|arg
argument_list|,
operator|&
name|a
argument_list|)
expr_stmt|;
name|decContextDefault
argument_list|(
operator|&
name|context
argument_list|,
name|CONTEXT_INIT
argument_list|)
expr_stmt|;
name|context
operator|.
name|round
operator|=
name|CONTEXT_ROUND
expr_stmt|;
name|TO_INTERNAL
argument_list|(
operator|&
name|a
argument_list|,
operator|&
name|arg1
argument_list|)
expr_stmt|;
comment|/* Perform the operation.  */
name|op
argument_list|(
operator|&
name|res
argument_list|,
operator|&
name|arg1
argument_list|,
operator|&
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONTEXT_TRAPS
operator|&&
name|CONTEXT_ERRORS
argument_list|(
name|context
argument_list|)
condition|)
name|DFP_RAISE
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|TO_ENCODED
argument_list|(
operator|&
name|encoded_result
argument_list|,
operator|&
name|res
argument_list|,
operator|&
name|context
argument_list|)
expr_stmt|;
name|IEEE_TO_HOST
argument_list|(
name|encoded_result
argument_list|,
operator|&
name|result
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Binary operations.  */
end_comment

begin_function
specifier|static
specifier|inline
name|DFP_C_TYPE
name|dfp_binary_op
parameter_list|(
name|dfp_binary_func
name|op
parameter_list|,
name|DFP_C_TYPE
name|arg_a
parameter_list|,
name|DFP_C_TYPE
name|arg_b
parameter_list|)
block|{
name|DFP_C_TYPE
name|result
decl_stmt|;
name|decContext
name|context
decl_stmt|;
name|decNumber
name|arg1
decl_stmt|,
name|arg2
decl_stmt|,
name|res
decl_stmt|;
name|IEEE_TYPE
name|a
decl_stmt|,
name|b
decl_stmt|,
name|encoded_result
decl_stmt|;
name|HOST_TO_IEEE
argument_list|(
name|arg_a
argument_list|,
operator|&
name|a
argument_list|)
expr_stmt|;
name|HOST_TO_IEEE
argument_list|(
name|arg_b
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
name|decContextDefault
argument_list|(
operator|&
name|context
argument_list|,
name|CONTEXT_INIT
argument_list|)
expr_stmt|;
name|context
operator|.
name|round
operator|=
name|CONTEXT_ROUND
expr_stmt|;
name|TO_INTERNAL
argument_list|(
operator|&
name|a
argument_list|,
operator|&
name|arg1
argument_list|)
expr_stmt|;
name|TO_INTERNAL
argument_list|(
operator|&
name|b
argument_list|,
operator|&
name|arg2
argument_list|)
expr_stmt|;
comment|/* Perform the operation.  */
name|op
argument_list|(
operator|&
name|res
argument_list|,
operator|&
name|arg1
argument_list|,
operator|&
name|arg2
argument_list|,
operator|&
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONTEXT_TRAPS
operator|&&
name|CONTEXT_ERRORS
argument_list|(
name|context
argument_list|)
condition|)
name|DFP_RAISE
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|TO_ENCODED
argument_list|(
operator|&
name|encoded_result
argument_list|,
operator|&
name|res
argument_list|,
operator|&
name|context
argument_list|)
expr_stmt|;
name|IEEE_TO_HOST
argument_list|(
name|encoded_result
argument_list|,
operator|&
name|result
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Comparison operations.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|dfp_compare_op
parameter_list|(
name|dfp_binary_func
name|op
parameter_list|,
name|DFP_C_TYPE
name|arg_a
parameter_list|,
name|DFP_C_TYPE
name|arg_b
parameter_list|)
block|{
name|IEEE_TYPE
name|a
decl_stmt|,
name|b
decl_stmt|;
name|decContext
name|context
decl_stmt|;
name|decNumber
name|arg1
decl_stmt|,
name|arg2
decl_stmt|,
name|res
decl_stmt|;
name|int
name|result
decl_stmt|;
name|HOST_TO_IEEE
argument_list|(
name|arg_a
argument_list|,
operator|&
name|a
argument_list|)
expr_stmt|;
name|HOST_TO_IEEE
argument_list|(
name|arg_b
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
name|decContextDefault
argument_list|(
operator|&
name|context
argument_list|,
name|CONTEXT_INIT
argument_list|)
expr_stmt|;
name|context
operator|.
name|round
operator|=
name|CONTEXT_ROUND
expr_stmt|;
name|TO_INTERNAL
argument_list|(
operator|&
name|a
argument_list|,
operator|&
name|arg1
argument_list|)
expr_stmt|;
name|TO_INTERNAL
argument_list|(
operator|&
name|b
argument_list|,
operator|&
name|arg2
argument_list|)
expr_stmt|;
comment|/* Perform the comparison.  */
name|op
argument_list|(
operator|&
name|res
argument_list|,
operator|&
name|arg1
argument_list|,
operator|&
name|arg2
argument_list|,
operator|&
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONTEXT_TRAPS
operator|&&
name|CONTEXT_ERRORS
argument_list|(
name|context
argument_list|)
condition|)
name|DFP_RAISE
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|decNumberIsNegative
argument_list|(
operator|&
name|res
argument_list|)
condition|)
name|result
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|decNumberIsZero
argument_list|(
operator|&
name|res
argument_list|)
condition|)
name|result
operator|=
literal|0
expr_stmt|;
else|else
name|result
operator|=
literal|1
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_conv_sd
argument_list|)
end_if

begin_function
name|void
name|__host_to_ieee_32
parameter_list|(
name|_Decimal32
name|in
parameter_list|,
name|decimal32
modifier|*
name|out
parameter_list|)
block|{
name|uint32_t
name|t
decl_stmt|;
if|if
condition|(
operator|!
name|LIBGCC2_FLOAT_WORDS_BIG_ENDIAN
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|t
argument_list|,
operator|&
name|in
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|t
operator|=
name|__dec_byte_swap
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|out
argument_list|,
operator|&
name|t
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
name|memcpy
argument_list|(
name|out
argument_list|,
operator|&
name|in
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|__ieee_to_host_32
parameter_list|(
name|decimal32
name|in
parameter_list|,
name|_Decimal32
modifier|*
name|out
parameter_list|)
block|{
name|uint32_t
name|t
decl_stmt|;
if|if
condition|(
operator|!
name|LIBGCC2_FLOAT_WORDS_BIG_ENDIAN
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|t
argument_list|,
operator|&
name|in
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|t
operator|=
name|__dec_byte_swap
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|out
argument_list|,
operator|&
name|t
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
name|memcpy
argument_list|(
name|out
argument_list|,
operator|&
name|in
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* L_conv_sd */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_conv_dd
argument_list|)
end_if

begin_function
specifier|static
name|void
name|__swap64
parameter_list|(
name|char
modifier|*
name|src
parameter_list|,
name|char
modifier|*
name|dst
parameter_list|)
block|{
name|uint32_t
name|t1
decl_stmt|,
name|t2
decl_stmt|;
if|if
condition|(
operator|!
name|LIBGCC2_FLOAT_WORDS_BIG_ENDIAN
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|t1
argument_list|,
name|src
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|t2
argument_list|,
name|src
operator|+
literal|4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|t1
operator|=
name|__dec_byte_swap
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|t2
operator|=
name|__dec_byte_swap
argument_list|(
name|t2
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dst
argument_list|,
operator|&
name|t2
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dst
operator|+
literal|4
argument_list|,
operator|&
name|t1
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
name|memcpy
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|__host_to_ieee_64
parameter_list|(
name|_Decimal64
name|in
parameter_list|,
name|decimal64
modifier|*
name|out
parameter_list|)
block|{
name|__swap64
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|in
argument_list|,
operator|(
name|char
operator|*
operator|)
name|out
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|__ieee_to_host_64
parameter_list|(
name|decimal64
name|in
parameter_list|,
name|_Decimal64
modifier|*
name|out
parameter_list|)
block|{
name|__swap64
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|in
argument_list|,
operator|(
name|char
operator|*
operator|)
name|out
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* L_conv_dd */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_conv_td
argument_list|)
end_if

begin_function
specifier|static
name|void
name|__swap128
parameter_list|(
name|char
modifier|*
name|src
parameter_list|,
name|char
modifier|*
name|dst
parameter_list|)
block|{
name|uint32_t
name|t1
decl_stmt|,
name|t2
decl_stmt|,
name|t3
decl_stmt|,
name|t4
decl_stmt|;
if|if
condition|(
operator|!
name|LIBGCC2_FLOAT_WORDS_BIG_ENDIAN
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|t1
argument_list|,
name|src
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|t2
argument_list|,
name|src
operator|+
literal|4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|t3
argument_list|,
name|src
operator|+
literal|8
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|t4
argument_list|,
name|src
operator|+
literal|12
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|t1
operator|=
name|__dec_byte_swap
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|t2
operator|=
name|__dec_byte_swap
argument_list|(
name|t2
argument_list|)
expr_stmt|;
name|t3
operator|=
name|__dec_byte_swap
argument_list|(
name|t3
argument_list|)
expr_stmt|;
name|t4
operator|=
name|__dec_byte_swap
argument_list|(
name|t4
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dst
argument_list|,
operator|&
name|t4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dst
operator|+
literal|4
argument_list|,
operator|&
name|t3
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dst
operator|+
literal|8
argument_list|,
operator|&
name|t2
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dst
operator|+
literal|12
argument_list|,
operator|&
name|t1
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
name|memcpy
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|__host_to_ieee_128
parameter_list|(
name|_Decimal128
name|in
parameter_list|,
name|decimal128
modifier|*
name|out
parameter_list|)
block|{
name|__swap128
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|in
argument_list|,
operator|(
name|char
operator|*
operator|)
name|out
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|__ieee_to_host_128
parameter_list|(
name|decimal128
name|in
parameter_list|,
name|_Decimal128
modifier|*
name|out
parameter_list|)
block|{
name|__swap128
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|in
argument_list|,
operator|(
name|char
operator|*
operator|)
name|out
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* L_conv_td */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_addsub_sd
argument_list|)
operator|||
name|defined
argument_list|(
name|L_addsub_dd
argument_list|)
operator|||
name|defined
argument_list|(
name|L_addsub_td
argument_list|)
end_if

begin_function
name|DFP_C_TYPE
name|DFP_ADD
parameter_list|(
name|DFP_C_TYPE
name|arg_a
parameter_list|,
name|DFP_C_TYPE
name|arg_b
parameter_list|)
block|{
return|return
name|dfp_binary_op
argument_list|(
name|decNumberAdd
argument_list|,
name|arg_a
argument_list|,
name|arg_b
argument_list|)
return|;
block|}
end_function

begin_function
name|DFP_C_TYPE
name|DFP_SUB
parameter_list|(
name|DFP_C_TYPE
name|arg_a
parameter_list|,
name|DFP_C_TYPE
name|arg_b
parameter_list|)
block|{
return|return
name|dfp_binary_op
argument_list|(
name|decNumberSubtract
argument_list|,
name|arg_a
argument_list|,
name|arg_b
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* L_addsub */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_mul_sd
argument_list|)
operator|||
name|defined
argument_list|(
name|L_mul_dd
argument_list|)
operator|||
name|defined
argument_list|(
name|L_mul_td
argument_list|)
end_if

begin_function
name|DFP_C_TYPE
name|DFP_MULTIPLY
parameter_list|(
name|DFP_C_TYPE
name|arg_a
parameter_list|,
name|DFP_C_TYPE
name|arg_b
parameter_list|)
block|{
return|return
name|dfp_binary_op
argument_list|(
name|decNumberMultiply
argument_list|,
name|arg_a
argument_list|,
name|arg_b
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* L_mul */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_div_sd
argument_list|)
operator|||
name|defined
argument_list|(
name|L_div_dd
argument_list|)
operator|||
name|defined
argument_list|(
name|L_div_td
argument_list|)
end_if

begin_function
name|DFP_C_TYPE
name|DFP_DIVIDE
parameter_list|(
name|DFP_C_TYPE
name|arg_a
parameter_list|,
name|DFP_C_TYPE
name|arg_b
parameter_list|)
block|{
return|return
name|dfp_binary_op
argument_list|(
name|decNumberDivide
argument_list|,
name|arg_a
argument_list|,
name|arg_b
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* L_div */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_eq_sd
argument_list|)
operator|||
name|defined
argument_list|(
name|L_eq_dd
argument_list|)
operator|||
name|defined
argument_list|(
name|L_eq_td
argument_list|)
end_if

begin_function
name|CMPtype
name|DFP_EQ
parameter_list|(
name|DFP_C_TYPE
name|arg_a
parameter_list|,
name|DFP_C_TYPE
name|arg_b
parameter_list|)
block|{
name|int
name|stat
decl_stmt|;
name|stat
operator|=
name|dfp_compare_op
argument_list|(
name|decNumberCompare
argument_list|,
name|arg_a
argument_list|,
name|arg_b
argument_list|)
expr_stmt|;
comment|/* For EQ return zero for true, nonzero for false.  */
return|return
name|stat
operator|!=
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* L_eq */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_ne_sd
argument_list|)
operator|||
name|defined
argument_list|(
name|L_ne_dd
argument_list|)
operator|||
name|defined
argument_list|(
name|L_ne_td
argument_list|)
end_if

begin_function
name|CMPtype
name|DFP_NE
parameter_list|(
name|DFP_C_TYPE
name|arg_a
parameter_list|,
name|DFP_C_TYPE
name|arg_b
parameter_list|)
block|{
name|int
name|stat
decl_stmt|;
name|stat
operator|=
name|dfp_compare_op
argument_list|(
name|decNumberCompare
argument_list|,
name|arg_a
argument_list|,
name|arg_b
argument_list|)
expr_stmt|;
comment|/* For NE return nonzero for true, zero for false.  */
return|return
name|stat
operator|!=
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* L_ne */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_lt_sd
argument_list|)
operator|||
name|defined
argument_list|(
name|L_lt_dd
argument_list|)
operator|||
name|defined
argument_list|(
name|L_lt_td
argument_list|)
end_if

begin_function
name|CMPtype
name|DFP_LT
parameter_list|(
name|DFP_C_TYPE
name|arg_a
parameter_list|,
name|DFP_C_TYPE
name|arg_b
parameter_list|)
block|{
name|int
name|stat
decl_stmt|;
name|stat
operator|=
name|dfp_compare_op
argument_list|(
name|decNumberCompare
argument_list|,
name|arg_a
argument_list|,
name|arg_b
argument_list|)
expr_stmt|;
comment|/* For LT return -1 (<0) for true, 1 for false.  */
return|return
operator|(
name|stat
operator|==
operator|-
literal|1
operator|)
condition|?
operator|-
literal|1
else|:
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* L_lt */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_gt_sd
argument_list|)
operator|||
name|defined
argument_list|(
name|L_gt_dd
argument_list|)
operator|||
name|defined
argument_list|(
name|L_gt_td
argument_list|)
end_if

begin_function
name|CMPtype
name|DFP_GT
parameter_list|(
name|DFP_C_TYPE
name|arg_a
parameter_list|,
name|DFP_C_TYPE
name|arg_b
parameter_list|)
block|{
name|int
name|stat
decl_stmt|;
name|stat
operator|=
name|dfp_compare_op
argument_list|(
name|decNumberCompare
argument_list|,
name|arg_a
argument_list|,
name|arg_b
argument_list|)
expr_stmt|;
comment|/* For GT return 1 (>0) for true, -1 for false.  */
return|return
operator|(
name|stat
operator|==
literal|1
operator|)
condition|?
literal|1
else|:
operator|-
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_le_sd
argument_list|)
operator|||
name|defined
argument_list|(
name|L_le_dd
argument_list|)
operator|||
name|defined
argument_list|(
name|L_le_td
argument_list|)
end_if

begin_function
name|CMPtype
name|DFP_LE
parameter_list|(
name|DFP_C_TYPE
name|arg_a
parameter_list|,
name|DFP_C_TYPE
name|arg_b
parameter_list|)
block|{
name|int
name|stat
decl_stmt|;
name|stat
operator|=
name|dfp_compare_op
argument_list|(
name|decNumberCompare
argument_list|,
name|arg_a
argument_list|,
name|arg_b
argument_list|)
expr_stmt|;
comment|/* For LE return 0 (<= 0) for true, 1 for false.  */
return|return
name|stat
operator|==
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* L_le */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_ge_sd
argument_list|)
operator|||
name|defined
argument_list|(
name|L_ge_dd
argument_list|)
operator|||
name|defined
argument_list|(
name|L_ge_td
argument_list|)
end_if

begin_function
name|CMPtype
name|DFP_GE
parameter_list|(
name|DFP_C_TYPE
name|arg_a
parameter_list|,
name|DFP_C_TYPE
name|arg_b
parameter_list|)
block|{
name|int
name|stat
decl_stmt|;
name|stat
operator|=
name|dfp_compare_op
argument_list|(
name|decNumberCompare
argument_list|,
name|arg_a
argument_list|,
name|arg_b
argument_list|)
expr_stmt|;
comment|/* For GE return 1 (>=0) for true, -1 for false.  */
return|return
operator|(
name|stat
operator|!=
operator|-
literal|1
operator|)
condition|?
literal|1
else|:
operator|-
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* L_ge */
end_comment

begin_define
define|#
directive|define
name|BUFMAX
value|128
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_sd_to_dd
argument_list|)
operator|||
name|defined
argument_list|(
name|L_sd_to_td
argument_list|)
operator|||
name|defined
argument_list|(
name|L_dd_to_sd
argument_list|)
expr|\
operator|||
name|defined
argument_list|(
name|L_dd_to_td
argument_list|)
operator|||
name|defined
argument_list|(
name|L_td_to_sd
argument_list|)
operator|||
name|defined
argument_list|(
name|L_td_to_dd
argument_list|)
end_if

begin_function
name|DFP_C_TYPE_TO
name|DFP_TO_DFP
parameter_list|(
name|DFP_C_TYPE
name|f_from
parameter_list|)
block|{
name|DFP_C_TYPE_TO
name|f_to
decl_stmt|;
name|IEEE_TYPE
name|s_from
decl_stmt|;
name|IEEE_TYPE_TO
name|s_to
decl_stmt|;
name|decNumber
name|d
decl_stmt|;
name|decContext
name|context
decl_stmt|;
name|decContextDefault
argument_list|(
operator|&
name|context
argument_list|,
name|CONTEXT_INIT
argument_list|)
expr_stmt|;
name|context
operator|.
name|round
operator|=
name|CONTEXT_ROUND
expr_stmt|;
name|HOST_TO_IEEE
argument_list|(
name|f_from
argument_list|,
operator|&
name|s_from
argument_list|)
expr_stmt|;
name|TO_INTERNAL
argument_list|(
operator|&
name|s_from
argument_list|,
operator|&
name|d
argument_list|)
expr_stmt|;
name|TO_ENCODED_TO
argument_list|(
operator|&
name|s_to
argument_list|,
operator|&
name|d
argument_list|,
operator|&
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONTEXT_TRAPS
operator|&&
operator|(
name|context
operator|.
name|status
operator|&
name|DEC_Inexact
operator|)
operator|!=
literal|0
condition|)
name|DFP_RAISE
argument_list|(
name|DEC_Inexact
argument_list|)
expr_stmt|;
name|IEEE_TO_HOST_TO
argument_list|(
name|s_to
argument_list|,
operator|&
name|f_to
argument_list|)
expr_stmt|;
return|return
name|f_to
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_sd_to_si
argument_list|)
operator|||
name|defined
argument_list|(
name|L_dd_to_si
argument_list|)
operator|||
name|defined
argument_list|(
name|L_td_to_si
argument_list|)
expr|\
operator|||
name|defined
argument_list|(
name|L_sd_to_di
argument_list|)
operator|||
name|defined
argument_list|(
name|L_dd_to_di
argument_list|)
operator|||
name|defined
argument_list|(
name|L_td_to_di
argument_list|)
expr|\
operator|||
name|defined
argument_list|(
name|L_sd_to_usi
argument_list|)
operator|||
name|defined
argument_list|(
name|L_dd_to_usi
argument_list|)
operator|||
name|defined
argument_list|(
name|L_td_to_usi
argument_list|)
expr|\
operator|||
name|defined
argument_list|(
name|L_sd_to_udi
argument_list|)
operator|||
name|defined
argument_list|(
name|L_dd_to_udi
argument_list|)
operator|||
name|defined
argument_list|(
name|L_td_to_udi
argument_list|)
end_if

begin_function
name|INT_TYPE
name|DFP_TO_INT
parameter_list|(
name|DFP_C_TYPE
name|x
parameter_list|)
block|{
comment|/* decNumber's decimal* types have the same format as C's _Decimal*      types, but they have different calling conventions.  */
name|IEEE_TYPE
name|s
decl_stmt|;
name|char
name|buf
index|[
name|BUFMAX
index|]
decl_stmt|;
name|char
modifier|*
name|pos
decl_stmt|;
name|decNumber
name|qval
decl_stmt|,
name|n1
decl_stmt|,
name|n2
decl_stmt|;
name|decContext
name|context
decl_stmt|;
name|decContextDefault
argument_list|(
operator|&
name|context
argument_list|,
name|CONTEXT_INIT
argument_list|)
expr_stmt|;
comment|/* Need non-default rounding mode here.  */
name|context
operator|.
name|round
operator|=
name|DEC_ROUND_DOWN
expr_stmt|;
name|HOST_TO_IEEE
argument_list|(
name|x
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
name|TO_INTERNAL
argument_list|(
operator|&
name|s
argument_list|,
operator|&
name|n1
argument_list|)
expr_stmt|;
comment|/* Rescale if the exponent is less than zero.  */
name|decNumberToIntegralValue
argument_list|(
operator|&
name|n2
argument_list|,
operator|&
name|n1
argument_list|,
operator|&
name|context
argument_list|)
expr_stmt|;
comment|/* Get a value to use for the quantize call.  */
name|decNumberFromString
argument_list|(
operator|&
name|qval
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|"1.0"
argument_list|,
operator|&
name|context
argument_list|)
expr_stmt|;
comment|/* Force the exponent to zero.  */
name|decNumberQuantize
argument_list|(
operator|&
name|n1
argument_list|,
operator|&
name|n2
argument_list|,
operator|&
name|qval
argument_list|,
operator|&
name|context
argument_list|)
expr_stmt|;
comment|/* This is based on text in N1107 section 5.1; it might turn out to be      undefined behavior instead.  */
if|if
condition|(
name|context
operator|.
name|status
operator|&
name|DEC_Invalid_operation
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|L_sd_to_si
argument_list|)
operator|||
name|defined
argument_list|(
name|L_dd_to_si
argument_list|)
operator|||
name|defined
argument_list|(
name|L_td_to_si
argument_list|)
if|if
condition|(
name|decNumberIsNegative
argument_list|(
operator|&
name|n2
argument_list|)
condition|)
return|return
name|INT_MIN
return|;
else|else
return|return
name|INT_MAX
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|L_sd_to_di
argument_list|)
operator|||
name|defined
argument_list|(
name|L_dd_to_di
argument_list|)
operator|||
name|defined
argument_list|(
name|L_td_to_di
argument_list|)
if|if
condition|(
name|decNumberIsNegative
argument_list|(
operator|&
name|n2
argument_list|)
condition|)
comment|/* Find a defined constant that will work here.  */
return|return
operator|(
operator|-
literal|9223372036854775807LL
operator|-
literal|1LL
operator|)
return|;
else|else
comment|/* Find a defined constant that will work here.  */
return|return
literal|9223372036854775807LL
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|L_sd_to_usi
argument_list|)
operator|||
name|defined
argument_list|(
name|L_dd_to_usi
argument_list|)
operator|||
name|defined
argument_list|(
name|L_td_to_usi
argument_list|)
return|return
name|UINT_MAX
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|L_sd_to_udi
argument_list|)
operator|||
name|defined
argument_list|(
name|L_dd_to_udi
argument_list|)
operator|||
name|defined
argument_list|(
name|L_td_to_udi
argument_list|)
comment|/* Find a defined constant that will work here.  */
return|return
literal|18446744073709551615ULL
return|;
endif|#
directive|endif
block|}
comment|/* Get a string, which at this point will not include an exponent.  */
name|decNumberToString
argument_list|(
operator|&
name|n1
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* Ignore the fractional part.  */
name|pos
operator|=
name|strchr
argument_list|(
name|buf
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
condition|)
operator|*
name|pos
operator|=
literal|0
expr_stmt|;
comment|/* Use a C library function to convert to the integral type.  */
return|return
name|STR_TO_INT
argument_list|(
name|buf
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_si_to_sd
argument_list|)
operator|||
name|defined
argument_list|(
name|L_si_to_dd
argument_list|)
operator|||
name|defined
argument_list|(
name|L_si_to_td
argument_list|)
expr|\
operator|||
name|defined
argument_list|(
name|L_di_to_sd
argument_list|)
operator|||
name|defined
argument_list|(
name|L_di_to_dd
argument_list|)
operator|||
name|defined
argument_list|(
name|L_di_to_td
argument_list|)
expr|\
operator|||
name|defined
argument_list|(
name|L_usi_to_sd
argument_list|)
operator|||
name|defined
argument_list|(
name|L_usi_to_dd
argument_list|)
operator|||
name|defined
argument_list|(
name|L_usi_to_td
argument_list|)
expr|\
operator|||
name|defined
argument_list|(
name|L_udi_to_sd
argument_list|)
operator|||
name|defined
argument_list|(
name|L_udi_to_dd
argument_list|)
operator|||
name|defined
argument_list|(
name|L_udi_to_td
argument_list|)
end_if

begin_function
name|DFP_C_TYPE
name|INT_TO_DFP
parameter_list|(
name|INT_TYPE
name|i
parameter_list|)
block|{
name|DFP_C_TYPE
name|f
decl_stmt|;
name|IEEE_TYPE
name|s
decl_stmt|;
name|char
name|buf
index|[
name|BUFMAX
index|]
decl_stmt|;
name|decContext
name|context
decl_stmt|;
name|decContextDefault
argument_list|(
operator|&
name|context
argument_list|,
name|CONTEXT_INIT
argument_list|)
expr_stmt|;
name|context
operator|.
name|round
operator|=
name|CONTEXT_ROUND
expr_stmt|;
comment|/* Use a C library function to get a floating point string.  */
name|sprintf
argument_list|(
name|buf
argument_list|,
name|INT_FMT
literal|".0"
argument_list|,
name|CAST_FOR_FMT
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Convert from the floating point string to a decimal* type.  */
name|FROM_STRING
argument_list|(
operator|&
name|s
argument_list|,
name|buf
argument_list|,
operator|&
name|context
argument_list|)
expr_stmt|;
name|IEEE_TO_HOST
argument_list|(
name|s
argument_list|,
operator|&
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONTEXT_TRAPS
operator|&&
operator|(
name|context
operator|.
name|status
operator|&
name|DEC_Inexact
operator|)
operator|!=
literal|0
condition|)
name|DFP_RAISE
argument_list|(
name|DEC_Inexact
argument_list|)
expr_stmt|;
return|return
name|f
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_sd_to_sf
argument_list|)
operator|||
name|defined
argument_list|(
name|L_dd_to_sf
argument_list|)
operator|||
name|defined
argument_list|(
name|L_td_to_sf
argument_list|)
expr|\
operator|||
name|defined
argument_list|(
name|L_sd_to_df
argument_list|)
operator|||
name|defined
argument_list|(
name|L_dd_to_df
argument_list|)
operator|||
name|defined
argument_list|(
name|L_td_to_df
argument_list|)
expr|\
operator|||
operator|(
operator|(
name|defined
argument_list|(
name|L_sd_to_xf
argument_list|)
operator|||
name|defined
argument_list|(
name|L_dd_to_xf
argument_list|)
operator|||
name|defined
argument_list|(
name|L_td_to_xf
argument_list|)
operator|)
expr|\
operator|&&
name|LIBGCC2_HAS_XF_MODE
operator|)
end_if

begin_function
name|BFP_TYPE
name|DFP_TO_BFP
parameter_list|(
name|DFP_C_TYPE
name|f
parameter_list|)
block|{
name|IEEE_TYPE
name|s
decl_stmt|;
name|char
name|buf
index|[
name|BUFMAX
index|]
decl_stmt|;
name|HOST_TO_IEEE
argument_list|(
name|f
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
comment|/* Write the value to a string.  */
name|TO_STRING
argument_list|(
operator|&
name|s
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* Read it as the binary floating point type and return that.  */
return|return
name|STR_TO_BFP
argument_list|(
name|buf
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_sf_to_sd
argument_list|)
operator|||
name|defined
argument_list|(
name|L_sf_to_dd
argument_list|)
operator|||
name|defined
argument_list|(
name|L_sf_to_td
argument_list|)
expr|\
operator|||
name|defined
argument_list|(
name|L_df_to_sd
argument_list|)
operator|||
name|defined
argument_list|(
name|L_df_to_dd
argument_list|)
operator|||
name|defined
argument_list|(
name|L_df_to_td
argument_list|)
expr|\
operator|||
operator|(
operator|(
name|defined
argument_list|(
name|L_xf_to_sd
argument_list|)
operator|||
name|defined
argument_list|(
name|L_xf_to_dd
argument_list|)
operator|||
name|defined
argument_list|(
name|L_xf_to_td
argument_list|)
operator|)
expr|\
operator|&&
name|LIBGCC2_HAS_XF_MODE
operator|)
end_if

begin_function
name|DFP_C_TYPE
name|BFP_TO_DFP
parameter_list|(
name|BFP_TYPE
name|x
parameter_list|)
block|{
name|DFP_C_TYPE
name|f
decl_stmt|;
name|IEEE_TYPE
name|s
decl_stmt|;
name|char
name|buf
index|[
name|BUFMAX
index|]
decl_stmt|;
name|decContext
name|context
decl_stmt|;
name|decContextDefault
argument_list|(
operator|&
name|context
argument_list|,
name|CONTEXT_INIT
argument_list|)
expr_stmt|;
name|context
operator|.
name|round
operator|=
name|CONTEXT_ROUND
expr_stmt|;
comment|/* Use a C library function to write the floating point value to a string.  */
ifdef|#
directive|ifdef
name|BFP_VIA_TYPE
comment|/* FIXME: Is there a better way to output an XFmode variable in C?  */
name|sprintf
argument_list|(
name|buf
argument_list|,
name|BFP_FMT
argument_list|,
operator|(
name|BFP_VIA_TYPE
operator|)
name|x
argument_list|)
expr_stmt|;
else|#
directive|else
name|sprintf
argument_list|(
name|buf
argument_list|,
name|BFP_FMT
argument_list|,
name|x
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Convert from the floating point string to a decimal* type.  */
name|FROM_STRING
argument_list|(
operator|&
name|s
argument_list|,
name|buf
argument_list|,
operator|&
name|context
argument_list|)
expr_stmt|;
name|IEEE_TO_HOST
argument_list|(
name|s
argument_list|,
operator|&
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONTEXT_TRAPS
operator|&&
operator|(
name|context
operator|.
name|status
operator|&
name|DEC_Inexact
operator|)
operator|!=
literal|0
condition|)
name|DFP_RAISE
argument_list|(
name|DEC_Inexact
argument_list|)
expr_stmt|;
return|return
name|f
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_unord_sd
argument_list|)
operator|||
name|defined
argument_list|(
name|L_unord_dd
argument_list|)
operator|||
name|defined
argument_list|(
name|L_unord_td
argument_list|)
end_if

begin_function
name|CMPtype
name|DFP_UNORD
parameter_list|(
name|DFP_C_TYPE
name|arg_a
parameter_list|,
name|DFP_C_TYPE
name|arg_b
parameter_list|)
block|{
name|decNumber
name|arg1
decl_stmt|,
name|arg2
decl_stmt|;
name|IEEE_TYPE
name|a
decl_stmt|,
name|b
decl_stmt|;
name|HOST_TO_IEEE
argument_list|(
name|arg_a
argument_list|,
operator|&
name|a
argument_list|)
expr_stmt|;
name|HOST_TO_IEEE
argument_list|(
name|arg_b
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
name|TO_INTERNAL
argument_list|(
operator|&
name|a
argument_list|,
operator|&
name|arg1
argument_list|)
expr_stmt|;
name|TO_INTERNAL
argument_list|(
operator|&
name|b
argument_list|,
operator|&
name|arg2
argument_list|)
expr_stmt|;
return|return
operator|(
name|decNumberIsNaN
argument_list|(
operator|&
name|arg1
argument_list|)
operator|||
name|decNumberIsNaN
argument_list|(
operator|&
name|arg2
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* L_unord_sd || L_unord_dd || L_unord_td */
end_comment

end_unit

