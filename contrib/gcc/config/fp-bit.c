begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* This is a software floating point library which can be used instead of    the floating point routines in libgcc1.c for targets without hardware    floating point.   Copyright (C) 1994, 1995, 1996, 1997, 1998 Free Software Foundation, Inc.  This file is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  In addition to the permissions in the GNU General Public License, the Free Software Foundation gives you unlimited permission to link the compiled version of this file with other programs, and to distribute those programs without any restriction coming from the use of this file.  (The General Public License restrictions do apply in other respects; for example, they cover modification of the file, and distribution when not linked into another program.)  This file is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* As a special exception, if you link this library with other files,    some of which are compiled with GCC, to produce an executable,    this library does not by itself cause the resulting executable    to be covered by the GNU General Public License.    This exception does not however invalidate any other reasons why    the executable file might be covered by the GNU General Public License.  */
end_comment

begin_comment
comment|/* This implements IEEE 754 format arithmetic, but does not provide a    mechanism for setting the rounding mode, or for generating or handling    exceptions.     The original code by Steve Chamberlain, hacked by Mark Eichin and Jim    Wilson, all of Cygnus Support.  */
end_comment

begin_comment
comment|/* The intended way to use this file is to make two copies, add `#define FLOAT'    to one copy, then compile both copies and add them to libgcc.a.  */
end_comment

begin_comment
comment|/* Defining FINE_GRAINED_LIBRARIES allows one to select which routines    from this file are compiled via additional -D options.     This avoids the need to pull in the entire fp emulation library    when only a small number of functions are needed.     If FINE_GRAINED_LIBRARIES is not defined, then compile every     suitable routine.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|FINE_GRAINED_LIBRARIES
end_ifndef

begin_define
define|#
directive|define
name|L_pack_df
end_define

begin_define
define|#
directive|define
name|L_unpack_df
end_define

begin_define
define|#
directive|define
name|L_pack_sf
end_define

begin_define
define|#
directive|define
name|L_unpack_sf
end_define

begin_define
define|#
directive|define
name|L_addsub_sf
end_define

begin_define
define|#
directive|define
name|L_addsub_df
end_define

begin_define
define|#
directive|define
name|L_mul_sf
end_define

begin_define
define|#
directive|define
name|L_mul_df
end_define

begin_define
define|#
directive|define
name|L_div_sf
end_define

begin_define
define|#
directive|define
name|L_div_df
end_define

begin_define
define|#
directive|define
name|L_fpcmp_parts_sf
end_define

begin_define
define|#
directive|define
name|L_fpcmp_parts_df
end_define

begin_define
define|#
directive|define
name|L_compare_sf
end_define

begin_define
define|#
directive|define
name|L_compare_df
end_define

begin_define
define|#
directive|define
name|L_eq_sf
end_define

begin_define
define|#
directive|define
name|L_eq_df
end_define

begin_define
define|#
directive|define
name|L_ne_sf
end_define

begin_define
define|#
directive|define
name|L_ne_df
end_define

begin_define
define|#
directive|define
name|L_gt_sf
end_define

begin_define
define|#
directive|define
name|L_gt_df
end_define

begin_define
define|#
directive|define
name|L_ge_sf
end_define

begin_define
define|#
directive|define
name|L_ge_df
end_define

begin_define
define|#
directive|define
name|L_lt_sf
end_define

begin_define
define|#
directive|define
name|L_lt_df
end_define

begin_define
define|#
directive|define
name|L_le_sf
end_define

begin_define
define|#
directive|define
name|L_le_df
end_define

begin_define
define|#
directive|define
name|L_si_to_sf
end_define

begin_define
define|#
directive|define
name|L_si_to_df
end_define

begin_define
define|#
directive|define
name|L_sf_to_si
end_define

begin_define
define|#
directive|define
name|L_df_to_si
end_define

begin_define
define|#
directive|define
name|L_f_to_usi
end_define

begin_define
define|#
directive|define
name|L_df_to_usi
end_define

begin_define
define|#
directive|define
name|L_negate_sf
end_define

begin_define
define|#
directive|define
name|L_negate_df
end_define

begin_define
define|#
directive|define
name|L_make_sf
end_define

begin_define
define|#
directive|define
name|L_make_df
end_define

begin_define
define|#
directive|define
name|L_sf_to_df
end_define

begin_define
define|#
directive|define
name|L_df_to_sf
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The following macros can be defined to change the behaviour of this file:    FLOAT: Implement a `float', aka SFmode, fp library.  If this is not      defined, then this file implements a `double', aka DFmode, fp library.    FLOAT_ONLY: Used with FLOAT, to implement a `float' only library, i.e.      don't include float->double conversion which requires the double library.      This is useful only for machines which can't support doubles, e.g. some      8-bit processors.    CMPtype: Specify the type that floating point compares should return.      This defaults to SItype, aka int.    US_SOFTWARE_GOFAST: This makes all entry points use the same names as the      US Software goFast library.  If this is not defined, the entry points use      the same names as libgcc1.c.    _DEBUG_BITFLOAT: This makes debugging the code a little easier, by adding      two integers to the FLO_union_type.      NO_NANS: Disable nan and infinity handling    SMALL_MACHINE: Useful when operations on QIs and HIs are faster      than on an SI */
end_comment

begin_comment
comment|/* We don't currently support extended floats (long doubles) on machines    without hardware to deal with them.     These stubs are just to keep the linker from complaining about unresolved    references which can be pulled in from libio& libstdc++, even if the    user isn't using long doubles.  However, they may generate an unresolved    external to abort if abort is not used by the function, and the stubs    are referenced from within libc, since libgcc goes before and after the    system library.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|EXTENDED_FLOAT_STUBS
end_ifdef

begin_macro
name|__truncxfsf2
argument_list|()
end_macro

begin_block
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|__extendsfxf2
argument_list|()
end_macro

begin_block
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|__addxf3
argument_list|()
end_macro

begin_block
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|__divxf3
argument_list|()
end_macro

begin_block
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|__eqxf2
argument_list|()
end_macro

begin_block
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|__extenddfxf2
argument_list|()
end_macro

begin_block
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|__gtxf2
argument_list|()
end_macro

begin_block
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|__lexf2
argument_list|()
end_macro

begin_block
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|__ltxf2
argument_list|()
end_macro

begin_block
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|__mulxf3
argument_list|()
end_macro

begin_block
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|__negxf2
argument_list|()
end_macro

begin_block
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|__nexf2
argument_list|()
end_macro

begin_block
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|__subxf3
argument_list|()
end_macro

begin_block
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|__truncxfdf2
argument_list|()
end_macro

begin_block
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|__trunctfsf2
argument_list|()
end_macro

begin_block
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|__extendsftf2
argument_list|()
end_macro

begin_block
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|__addtf3
argument_list|()
end_macro

begin_block
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|__divtf3
argument_list|()
end_macro

begin_block
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|__eqtf2
argument_list|()
end_macro

begin_block
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|__extenddftf2
argument_list|()
end_macro

begin_block
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|__gttf2
argument_list|()
end_macro

begin_block
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|__letf2
argument_list|()
end_macro

begin_block
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|__lttf2
argument_list|()
end_macro

begin_block
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|__multf3
argument_list|()
end_macro

begin_block
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|__negtf2
argument_list|()
end_macro

begin_block
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|__netf2
argument_list|()
end_macro

begin_block
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|__subtf3
argument_list|()
end_macro

begin_block
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|__trunctfdf2
argument_list|()
end_macro

begin_block
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|__gexf2
argument_list|()
end_macro

begin_block
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|__fixxfsi
argument_list|()
end_macro

begin_block
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|__floatsixf
argument_list|()
end_macro

begin_block
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !EXTENDED_FLOAT_STUBS, rest of file */
end_comment

begin_typedef
typedef|typedef
name|float
name|SFtype
name|__attribute__
typedef|((
name|mode
typedef|(
name|SF
typedef|)));
end_typedef

begin_typedef
typedef|typedef
name|float
name|DFtype
name|__attribute__
typedef|((
name|mode
typedef|(
name|DF
typedef|)));
end_typedef

begin_typedef
typedef|typedef
name|int
name|HItype
name|__attribute__
typedef|((
name|mode
typedef|(
name|HI
typedef|)));
end_typedef

begin_typedef
typedef|typedef
name|int
name|SItype
name|__attribute__
typedef|((
name|mode
typedef|(
name|SI
typedef|)));
end_typedef

begin_typedef
typedef|typedef
name|int
name|DItype
name|__attribute__
typedef|((
name|mode
typedef|(
name|DI
typedef|)));
end_typedef

begin_comment
comment|/* The type of the result of a fp compare */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CMPtype
end_ifndef

begin_define
define|#
directive|define
name|CMPtype
value|SItype
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
name|unsigned
name|int
name|UHItype
name|__attribute__
typedef|((
name|mode
typedef|(
name|HI
typedef|)));
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|int
name|USItype
name|__attribute__
typedef|((
name|mode
typedef|(
name|SI
typedef|)));
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|int
name|UDItype
name|__attribute__
typedef|((
name|mode
typedef|(
name|DI
typedef|)));
end_typedef

begin_define
define|#
directive|define
name|MAX_SI_INT
value|((SItype) ((unsigned) (~0)>>1))
end_define

begin_define
define|#
directive|define
name|MAX_USI_INT
value|((USItype) ~0)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|FLOAT_ONLY
end_ifdef

begin_define
define|#
directive|define
name|NO_DI_MODE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|FLOAT
end_ifdef

begin_define
define|#
directive|define
name|NGARDS
value|7L
end_define

begin_define
define|#
directive|define
name|GARDROUND
value|0x3f
end_define

begin_define
define|#
directive|define
name|GARDMASK
value|0x7f
end_define

begin_define
define|#
directive|define
name|GARDMSB
value|0x40
end_define

begin_define
define|#
directive|define
name|EXPBITS
value|8
end_define

begin_define
define|#
directive|define
name|EXPBIAS
value|127
end_define

begin_define
define|#
directive|define
name|FRACBITS
value|23
end_define

begin_define
define|#
directive|define
name|EXPMAX
value|(0xff)
end_define

begin_define
define|#
directive|define
name|QUIET_NAN
value|0x100000L
end_define

begin_define
define|#
directive|define
name|FRAC_NBITS
value|32
end_define

begin_define
define|#
directive|define
name|FRACHIGH
value|0x80000000L
end_define

begin_define
define|#
directive|define
name|FRACHIGH2
value|0xc0000000L
end_define

begin_define
define|#
directive|define
name|pack_d
value|__pack_f
end_define

begin_define
define|#
directive|define
name|unpack_d
value|__unpack_f
end_define

begin_define
define|#
directive|define
name|__fpcmp_parts
value|__fpcmp_parts_f
end_define

begin_typedef
typedef|typedef
name|USItype
name|fractype
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|UHItype
name|halffractype
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|SFtype
name|FLO_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|SItype
name|intfrac
typedef|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PREFIXFPDP
value|dp
end_define

begin_define
define|#
directive|define
name|PREFIXSFDF
value|df
end_define

begin_define
define|#
directive|define
name|NGARDS
value|8L
end_define

begin_define
define|#
directive|define
name|GARDROUND
value|0x7f
end_define

begin_define
define|#
directive|define
name|GARDMASK
value|0xff
end_define

begin_define
define|#
directive|define
name|GARDMSB
value|0x80
end_define

begin_define
define|#
directive|define
name|EXPBITS
value|11
end_define

begin_define
define|#
directive|define
name|EXPBIAS
value|1023
end_define

begin_define
define|#
directive|define
name|FRACBITS
value|52
end_define

begin_define
define|#
directive|define
name|EXPMAX
value|(0x7ff)
end_define

begin_define
define|#
directive|define
name|QUIET_NAN
value|0x8000000000000LL
end_define

begin_define
define|#
directive|define
name|FRAC_NBITS
value|64
end_define

begin_define
define|#
directive|define
name|FRACHIGH
value|0x8000000000000000LL
end_define

begin_define
define|#
directive|define
name|FRACHIGH2
value|0xc000000000000000LL
end_define

begin_define
define|#
directive|define
name|pack_d
value|__pack_d
end_define

begin_define
define|#
directive|define
name|unpack_d
value|__unpack_d
end_define

begin_define
define|#
directive|define
name|__fpcmp_parts
value|__fpcmp_parts_d
end_define

begin_typedef
typedef|typedef
name|UDItype
name|fractype
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|USItype
name|halffractype
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|DFtype
name|FLO_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|DItype
name|intfrac
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|US_SOFTWARE_GOFAST
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|FLOAT
end_ifdef

begin_define
define|#
directive|define
name|add
value|fpadd
end_define

begin_define
define|#
directive|define
name|sub
value|fpsub
end_define

begin_define
define|#
directive|define
name|multiply
value|fpmul
end_define

begin_define
define|#
directive|define
name|divide
value|fpdiv
end_define

begin_define
define|#
directive|define
name|compare
value|fpcmp
end_define

begin_define
define|#
directive|define
name|si_to_float
value|sitofp
end_define

begin_define
define|#
directive|define
name|float_to_si
value|fptosi
end_define

begin_define
define|#
directive|define
name|float_to_usi
value|fptoui
end_define

begin_define
define|#
directive|define
name|negate
value|__negsf2
end_define

begin_define
define|#
directive|define
name|sf_to_df
value|fptodp
end_define

begin_define
define|#
directive|define
name|dptofp
value|dptofp
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|add
value|dpadd
end_define

begin_define
define|#
directive|define
name|sub
value|dpsub
end_define

begin_define
define|#
directive|define
name|multiply
value|dpmul
end_define

begin_define
define|#
directive|define
name|divide
value|dpdiv
end_define

begin_define
define|#
directive|define
name|compare
value|dpcmp
end_define

begin_define
define|#
directive|define
name|si_to_float
value|litodp
end_define

begin_define
define|#
directive|define
name|float_to_si
value|dptoli
end_define

begin_define
define|#
directive|define
name|float_to_usi
value|dptoul
end_define

begin_define
define|#
directive|define
name|negate
value|__negdf2
end_define

begin_define
define|#
directive|define
name|df_to_sf
value|dptofp
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|FLOAT
end_ifdef

begin_define
define|#
directive|define
name|add
value|__addsf3
end_define

begin_define
define|#
directive|define
name|sub
value|__subsf3
end_define

begin_define
define|#
directive|define
name|multiply
value|__mulsf3
end_define

begin_define
define|#
directive|define
name|divide
value|__divsf3
end_define

begin_define
define|#
directive|define
name|compare
value|__cmpsf2
end_define

begin_define
define|#
directive|define
name|_eq_f2
value|__eqsf2
end_define

begin_define
define|#
directive|define
name|_ne_f2
value|__nesf2
end_define

begin_define
define|#
directive|define
name|_gt_f2
value|__gtsf2
end_define

begin_define
define|#
directive|define
name|_ge_f2
value|__gesf2
end_define

begin_define
define|#
directive|define
name|_lt_f2
value|__ltsf2
end_define

begin_define
define|#
directive|define
name|_le_f2
value|__lesf2
end_define

begin_define
define|#
directive|define
name|si_to_float
value|__floatsisf
end_define

begin_define
define|#
directive|define
name|float_to_si
value|__fixsfsi
end_define

begin_define
define|#
directive|define
name|float_to_usi
value|__fixunssfsi
end_define

begin_define
define|#
directive|define
name|negate
value|__negsf2
end_define

begin_define
define|#
directive|define
name|sf_to_df
value|__extendsfdf2
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|add
value|__adddf3
end_define

begin_define
define|#
directive|define
name|sub
value|__subdf3
end_define

begin_define
define|#
directive|define
name|multiply
value|__muldf3
end_define

begin_define
define|#
directive|define
name|divide
value|__divdf3
end_define

begin_define
define|#
directive|define
name|compare
value|__cmpdf2
end_define

begin_define
define|#
directive|define
name|_eq_f2
value|__eqdf2
end_define

begin_define
define|#
directive|define
name|_ne_f2
value|__nedf2
end_define

begin_define
define|#
directive|define
name|_gt_f2
value|__gtdf2
end_define

begin_define
define|#
directive|define
name|_ge_f2
value|__gedf2
end_define

begin_define
define|#
directive|define
name|_lt_f2
value|__ltdf2
end_define

begin_define
define|#
directive|define
name|_le_f2
value|__ledf2
end_define

begin_define
define|#
directive|define
name|si_to_float
value|__floatsidf
end_define

begin_define
define|#
directive|define
name|float_to_si
value|__fixdfsi
end_define

begin_define
define|#
directive|define
name|float_to_usi
value|__fixunsdfsi
end_define

begin_define
define|#
directive|define
name|negate
value|__negdf2
end_define

begin_define
define|#
directive|define
name|df_to_sf
value|__truncdfsf2
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|INLINE
end_ifndef

begin_define
define|#
directive|define
name|INLINE
value|__inline__
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Preserve the sticky-bit when shifting fractions to the right.  */
end_comment

begin_define
define|#
directive|define
name|LSHIFT
parameter_list|(
name|a
parameter_list|)
value|{ a = (a& 1) | (a>> 1); }
end_define

begin_comment
comment|/* numeric parameters */
end_comment

begin_comment
comment|/* F_D_BITOFF is the number of bits offset between the MSB of the mantissa    of a float and of a double. Assumes there are only two float types.    (double::FRAC_BITS+double::NGARDS-(float::FRAC_BITS-float::NGARDS))  */
end_comment

begin_define
define|#
directive|define
name|F_D_BITOFF
value|(52+8-(23+7))
end_define

begin_define
define|#
directive|define
name|NORMAL_EXPMIN
value|(-(EXPBIAS)+1)
end_define

begin_define
define|#
directive|define
name|IMPLICIT_1
value|(1LL<<(FRACBITS+NGARDS))
end_define

begin_define
define|#
directive|define
name|IMPLICIT_2
value|(1LL<<(FRACBITS+1+NGARDS))
end_define

begin_comment
comment|/* common types */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|CLASS_SNAN
block|,
name|CLASS_QNAN
block|,
name|CLASS_ZERO
block|,
name|CLASS_NUMBER
block|,
name|CLASS_INFINITY
block|}
name|fp_class_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
ifdef|#
directive|ifdef
name|SMALL_MACHINE
name|char
name|class
decl_stmt|;
name|unsigned
name|char
name|sign
decl_stmt|;
name|short
name|normal_exp
decl_stmt|;
else|#
directive|else
name|fp_class_type
name|class
decl_stmt|;
name|unsigned
name|int
name|sign
decl_stmt|;
name|int
name|normal_exp
decl_stmt|;
endif|#
directive|endif
union|union
block|{
name|fractype
name|ll
decl_stmt|;
name|halffractype
name|l
index|[
literal|2
index|]
decl_stmt|;
block|}
name|fraction
union|;
block|}
name|fp_number_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
union|union
block|{
name|FLO_type
name|value
decl_stmt|;
name|fractype
name|value_raw
decl_stmt|;
ifndef|#
directive|ifndef
name|FLOAT
name|halffractype
name|words
index|[
literal|2
index|]
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|FLOAT_BIT_ORDER_MISMATCH
struct|struct
block|{
name|fractype
name|fraction
range|:
name|FRACBITS
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|exp
range|:
name|EXPBITS
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|sign
range|:
literal|1
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
decl_stmt|;
block|}
name|bits
struct|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|_DEBUG_BITFLOAT
struct|struct
block|{
name|unsigned
name|int
name|sign
range|:
literal|1
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|exp
range|:
name|EXPBITS
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
decl_stmt|;
name|fractype
name|fraction
range|:
name|FRACBITS
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
decl_stmt|;
block|}
name|bits_big_endian
struct|;
struct|struct
block|{
name|fractype
name|fraction
range|:
name|FRACBITS
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|exp
range|:
name|EXPBITS
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|sign
range|:
literal|1
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
decl_stmt|;
block|}
name|bits_little_endian
struct|;
endif|#
directive|endif
block|}
name|FLO_union_type
typedef|;
end_typedef

begin_comment
comment|/* end of header */
end_comment

begin_comment
comment|/* IEEE "special" number predicates */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|NO_NANS
end_ifdef

begin_define
define|#
directive|define
name|nan
parameter_list|()
value|0
end_define

begin_define
define|#
directive|define
name|isnan
parameter_list|(
name|x
parameter_list|)
value|0
end_define

begin_define
define|#
directive|define
name|isinf
parameter_list|(
name|x
parameter_list|)
value|0
end_define

begin_else
else|#
directive|else
end_else

begin_function
name|INLINE
specifier|static
name|fp_number_type
modifier|*
name|nan
parameter_list|()
block|{
specifier|static
name|fp_number_type
name|thenan
decl_stmt|;
return|return
operator|&
name|thenan
return|;
block|}
end_function

begin_function
name|INLINE
specifier|static
name|int
name|isnan
parameter_list|(
name|fp_number_type
modifier|*
name|x
parameter_list|)
block|{
return|return
name|x
operator|->
name|class
operator|==
name|CLASS_SNAN
operator|||
name|x
operator|->
name|class
operator|==
name|CLASS_QNAN
return|;
block|}
end_function

begin_function
name|INLINE
specifier|static
name|int
name|isinf
parameter_list|(
name|fp_number_type
modifier|*
name|x
parameter_list|)
block|{
return|return
name|x
operator|->
name|class
operator|==
name|CLASS_INFINITY
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|INLINE
specifier|static
name|int
name|iszero
parameter_list|(
name|fp_number_type
modifier|*
name|x
parameter_list|)
block|{
return|return
name|x
operator|->
name|class
operator|==
name|CLASS_ZERO
return|;
block|}
end_function

begin_function
name|INLINE
specifier|static
name|void
name|flip_sign
parameter_list|(
name|fp_number_type
modifier|*
name|x
parameter_list|)
block|{
name|x
operator|->
name|sign
operator|=
operator|!
name|x
operator|->
name|sign
expr_stmt|;
block|}
end_function

begin_function_decl
specifier|extern
name|FLO_type
name|pack_d
parameter_list|(
name|fp_number_type
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_pack_df
argument_list|)
operator|||
name|defined
argument_list|(
name|L_pack_sf
argument_list|)
end_if

begin_function
name|FLO_type
name|pack_d
parameter_list|(
name|fp_number_type
modifier|*
name|src
parameter_list|)
block|{
name|FLO_union_type
name|dst
decl_stmt|;
name|fractype
name|fraction
init|=
name|src
operator|->
name|fraction
operator|.
name|ll
decl_stmt|;
comment|/* wasn't unsigned before? */
name|int
name|sign
init|=
name|src
operator|->
name|sign
decl_stmt|;
name|int
name|exp
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|isnan
argument_list|(
name|src
argument_list|)
condition|)
block|{
name|exp
operator|=
name|EXPMAX
expr_stmt|;
if|if
condition|(
name|src
operator|->
name|class
operator|==
name|CLASS_QNAN
operator|||
literal|1
condition|)
block|{
name|fraction
operator||=
name|QUIET_NAN
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|isinf
argument_list|(
name|src
argument_list|)
condition|)
block|{
name|exp
operator|=
name|EXPMAX
expr_stmt|;
name|fraction
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|iszero
argument_list|(
name|src
argument_list|)
condition|)
block|{
name|exp
operator|=
literal|0
expr_stmt|;
name|fraction
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fraction
operator|==
literal|0
condition|)
block|{
name|exp
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|src
operator|->
name|normal_exp
operator|<
name|NORMAL_EXPMIN
condition|)
block|{
comment|/* This number's exponent is too low to fit into the bits 	     available in the number, so we'll store 0 in the exponent and 	     shift the fraction to the right to make up for it.  */
name|int
name|shift
init|=
name|NORMAL_EXPMIN
operator|-
name|src
operator|->
name|normal_exp
decl_stmt|;
name|exp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|shift
operator|>
name|FRAC_NBITS
operator|-
name|NGARDS
condition|)
block|{
comment|/* No point shifting, since it's more that 64 out.  */
name|fraction
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Shift by the value */
name|fraction
operator|>>=
name|shift
expr_stmt|;
block|}
name|fraction
operator|>>=
name|NGARDS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|src
operator|->
name|normal_exp
operator|>
name|EXPBIAS
condition|)
block|{
name|exp
operator|=
name|EXPMAX
expr_stmt|;
name|fraction
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|exp
operator|=
name|src
operator|->
name|normal_exp
operator|+
name|EXPBIAS
expr_stmt|;
comment|/* IF the gard bits are the all zero, but the first, then we're 	     half way between two numbers, choose the one which makes the 	     lsb of the answer 0.  */
if|if
condition|(
operator|(
name|fraction
operator|&
name|GARDMASK
operator|)
operator|==
name|GARDMSB
condition|)
block|{
if|if
condition|(
name|fraction
operator|&
operator|(
literal|1
operator|<<
name|NGARDS
operator|)
condition|)
name|fraction
operator|+=
name|GARDROUND
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Add a one to the guards to round up */
name|fraction
operator|+=
name|GARDROUND
expr_stmt|;
block|}
if|if
condition|(
name|fraction
operator|>=
name|IMPLICIT_2
condition|)
block|{
name|fraction
operator|>>=
literal|1
expr_stmt|;
name|exp
operator|+=
literal|1
expr_stmt|;
block|}
name|fraction
operator|>>=
name|NGARDS
expr_stmt|;
block|}
block|}
comment|/* We previously used bitfields to store the number, but this doesn't      handle little/big endian systems conveniently, so use shifts and      masks */
ifdef|#
directive|ifdef
name|FLOAT_BIT_ORDER_MISMATCH
name|dst
operator|.
name|bits
operator|.
name|fraction
operator|=
name|fraction
expr_stmt|;
name|dst
operator|.
name|bits
operator|.
name|exp
operator|=
name|exp
expr_stmt|;
name|dst
operator|.
name|bits
operator|.
name|sign
operator|=
name|sign
expr_stmt|;
else|#
directive|else
name|dst
operator|.
name|value_raw
operator|=
name|fraction
operator|&
operator|(
operator|(
operator|(
operator|(
name|fractype
operator|)
literal|1
operator|)
operator|<<
name|FRACBITS
operator|)
operator|-
operator|(
name|fractype
operator|)
literal|1
operator|)
expr_stmt|;
name|dst
operator|.
name|value_raw
operator||=
operator|(
call|(
name|fractype
call|)
argument_list|(
name|exp
operator|&
operator|(
operator|(
literal|1
operator|<<
name|EXPBITS
operator|)
operator|-
literal|1
operator|)
argument_list|)
operator|)
operator|<<
name|FRACBITS
expr_stmt|;
name|dst
operator|.
name|value_raw
operator||=
operator|(
call|(
name|fractype
call|)
argument_list|(
name|sign
operator|&
literal|1
argument_list|)
operator|)
operator|<<
operator|(
name|FRACBITS
operator||
name|EXPBITS
operator|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|FLOAT_WORD_ORDER_MISMATCH
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|FLOAT
argument_list|)
block|{
name|halffractype
name|tmp
init|=
name|dst
operator|.
name|words
index|[
literal|0
index|]
decl_stmt|;
name|dst
operator|.
name|words
index|[
literal|0
index|]
operator|=
name|dst
operator|.
name|words
index|[
literal|1
index|]
expr_stmt|;
name|dst
operator|.
name|words
index|[
literal|1
index|]
operator|=
name|tmp
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|dst
operator|.
name|value
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|extern
name|void
name|unpack_d
parameter_list|(
name|FLO_union_type
modifier|*
parameter_list|,
name|fp_number_type
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_unpack_df
argument_list|)
operator|||
name|defined
argument_list|(
name|L_unpack_sf
argument_list|)
end_if

begin_function
name|void
name|unpack_d
parameter_list|(
name|FLO_union_type
modifier|*
name|src
parameter_list|,
name|fp_number_type
modifier|*
name|dst
parameter_list|)
block|{
comment|/* We previously used bitfields to store the number, but this doesn't      handle little/big endian systems conveniently, so use shifts and      masks */
name|fractype
name|fraction
decl_stmt|;
name|int
name|exp
decl_stmt|;
name|int
name|sign
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|FLOAT_WORD_ORDER_MISMATCH
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|FLOAT
argument_list|)
name|FLO_union_type
name|swapped
decl_stmt|;
name|swapped
operator|.
name|words
index|[
literal|0
index|]
operator|=
name|src
operator|->
name|words
index|[
literal|1
index|]
expr_stmt|;
name|swapped
operator|.
name|words
index|[
literal|1
index|]
operator|=
name|src
operator|->
name|words
index|[
literal|0
index|]
expr_stmt|;
name|src
operator|=
operator|&
name|swapped
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|FLOAT_BIT_ORDER_MISMATCH
name|fraction
operator|=
name|src
operator|->
name|bits
operator|.
name|fraction
expr_stmt|;
name|exp
operator|=
name|src
operator|->
name|bits
operator|.
name|exp
expr_stmt|;
name|sign
operator|=
name|src
operator|->
name|bits
operator|.
name|sign
expr_stmt|;
else|#
directive|else
name|fraction
operator|=
name|src
operator|->
name|value_raw
operator|&
operator|(
operator|(
operator|(
operator|(
name|fractype
operator|)
literal|1
operator|)
operator|<<
name|FRACBITS
operator|)
operator|-
operator|(
name|fractype
operator|)
literal|1
operator|)
expr_stmt|;
name|exp
operator|=
operator|(
call|(
name|int
call|)
argument_list|(
name|src
operator|->
name|value_raw
operator|>>
name|FRACBITS
argument_list|)
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
name|EXPBITS
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|sign
operator|=
operator|(
call|(
name|int
call|)
argument_list|(
name|src
operator|->
name|value_raw
operator|>>
operator|(
name|FRACBITS
operator|+
name|EXPBITS
operator|)
argument_list|)
operator|)
operator|&
literal|1
expr_stmt|;
endif|#
directive|endif
name|dst
operator|->
name|sign
operator|=
name|sign
expr_stmt|;
if|if
condition|(
name|exp
operator|==
literal|0
condition|)
block|{
comment|/* Hmm.  Looks like 0 */
if|if
condition|(
name|fraction
operator|==
literal|0
condition|)
block|{
comment|/* tastes like zero */
name|dst
operator|->
name|class
operator|=
name|CLASS_ZERO
expr_stmt|;
block|}
else|else
block|{
comment|/* Zero exponent with non zero fraction - it's denormalized, 	     so there isn't a leading implicit one - we'll shift it so 	     it gets one.  */
name|dst
operator|->
name|normal_exp
operator|=
name|exp
operator|-
name|EXPBIAS
operator|+
literal|1
expr_stmt|;
name|fraction
operator|<<=
name|NGARDS
expr_stmt|;
name|dst
operator|->
name|class
operator|=
name|CLASS_NUMBER
expr_stmt|;
if|#
directive|if
literal|1
while|while
condition|(
name|fraction
operator|<
name|IMPLICIT_1
condition|)
block|{
name|fraction
operator|<<=
literal|1
expr_stmt|;
name|dst
operator|->
name|normal_exp
operator|--
expr_stmt|;
block|}
endif|#
directive|endif
name|dst
operator|->
name|fraction
operator|.
name|ll
operator|=
name|fraction
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|exp
operator|==
name|EXPMAX
condition|)
block|{
comment|/* Huge exponent*/
if|if
condition|(
name|fraction
operator|==
literal|0
condition|)
block|{
comment|/* Attached to a zero fraction - means infinity */
name|dst
operator|->
name|class
operator|=
name|CLASS_INFINITY
expr_stmt|;
block|}
else|else
block|{
comment|/* Non zero fraction, means nan */
if|if
condition|(
name|fraction
operator|&
name|QUIET_NAN
condition|)
block|{
name|dst
operator|->
name|class
operator|=
name|CLASS_QNAN
expr_stmt|;
block|}
else|else
block|{
name|dst
operator|->
name|class
operator|=
name|CLASS_SNAN
expr_stmt|;
block|}
comment|/* Keep the fraction part as the nan number */
name|dst
operator|->
name|fraction
operator|.
name|ll
operator|=
name|fraction
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Nothing strange about this number */
name|dst
operator|->
name|normal_exp
operator|=
name|exp
operator|-
name|EXPBIAS
expr_stmt|;
name|dst
operator|->
name|class
operator|=
name|CLASS_NUMBER
expr_stmt|;
name|dst
operator|->
name|fraction
operator|.
name|ll
operator|=
operator|(
name|fraction
operator|<<
name|NGARDS
operator|)
operator||
name|IMPLICIT_1
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_addsub_sf
argument_list|)
operator|||
name|defined
argument_list|(
name|L_addsub_df
argument_list|)
end_if

begin_function
specifier|static
name|fp_number_type
modifier|*
name|_fpadd_parts
parameter_list|(
name|fp_number_type
modifier|*
name|a
parameter_list|,
name|fp_number_type
modifier|*
name|b
parameter_list|,
name|fp_number_type
modifier|*
name|tmp
parameter_list|)
block|{
name|intfrac
name|tfraction
decl_stmt|;
comment|/* Put commonly used fields in local variables.  */
name|int
name|a_normal_exp
decl_stmt|;
name|int
name|b_normal_exp
decl_stmt|;
name|fractype
name|a_fraction
decl_stmt|;
name|fractype
name|b_fraction
decl_stmt|;
if|if
condition|(
name|isnan
argument_list|(
name|a
argument_list|)
condition|)
block|{
return|return
name|a
return|;
block|}
if|if
condition|(
name|isnan
argument_list|(
name|b
argument_list|)
condition|)
block|{
return|return
name|b
return|;
block|}
if|if
condition|(
name|isinf
argument_list|(
name|a
argument_list|)
condition|)
block|{
comment|/* Adding infinities with opposite signs yields a NaN.  */
if|if
condition|(
name|isinf
argument_list|(
name|b
argument_list|)
operator|&&
name|a
operator|->
name|sign
operator|!=
name|b
operator|->
name|sign
condition|)
return|return
name|nan
argument_list|()
return|;
return|return
name|a
return|;
block|}
if|if
condition|(
name|isinf
argument_list|(
name|b
argument_list|)
condition|)
block|{
return|return
name|b
return|;
block|}
if|if
condition|(
name|iszero
argument_list|(
name|b
argument_list|)
condition|)
block|{
if|if
condition|(
name|iszero
argument_list|(
name|a
argument_list|)
condition|)
block|{
operator|*
name|tmp
operator|=
operator|*
name|a
expr_stmt|;
name|tmp
operator|->
name|sign
operator|=
name|a
operator|->
name|sign
operator|&
name|b
operator|->
name|sign
expr_stmt|;
return|return
name|tmp
return|;
block|}
return|return
name|a
return|;
block|}
if|if
condition|(
name|iszero
argument_list|(
name|a
argument_list|)
condition|)
block|{
return|return
name|b
return|;
block|}
comment|/* Got two numbers. shift the smaller and increment the exponent till      they're the same */
block|{
name|int
name|diff
decl_stmt|;
name|a_normal_exp
operator|=
name|a
operator|->
name|normal_exp
expr_stmt|;
name|b_normal_exp
operator|=
name|b
operator|->
name|normal_exp
expr_stmt|;
name|a_fraction
operator|=
name|a
operator|->
name|fraction
operator|.
name|ll
expr_stmt|;
name|b_fraction
operator|=
name|b
operator|->
name|fraction
operator|.
name|ll
expr_stmt|;
name|diff
operator|=
name|a_normal_exp
operator|-
name|b_normal_exp
expr_stmt|;
if|if
condition|(
name|diff
operator|<
literal|0
condition|)
name|diff
operator|=
operator|-
name|diff
expr_stmt|;
if|if
condition|(
name|diff
operator|<
name|FRAC_NBITS
condition|)
block|{
comment|/* ??? This does shifts one bit at a time.  Optimize.  */
while|while
condition|(
name|a_normal_exp
operator|>
name|b_normal_exp
condition|)
block|{
name|b_normal_exp
operator|++
expr_stmt|;
name|LSHIFT
argument_list|(
name|b_fraction
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|b_normal_exp
operator|>
name|a_normal_exp
condition|)
block|{
name|a_normal_exp
operator|++
expr_stmt|;
name|LSHIFT
argument_list|(
name|a_fraction
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Somethings's up.. choose the biggest */
if|if
condition|(
name|a_normal_exp
operator|>
name|b_normal_exp
condition|)
block|{
name|b_normal_exp
operator|=
name|a_normal_exp
expr_stmt|;
name|b_fraction
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|a_normal_exp
operator|=
name|b_normal_exp
expr_stmt|;
name|a_fraction
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|a
operator|->
name|sign
operator|!=
name|b
operator|->
name|sign
condition|)
block|{
if|if
condition|(
name|a
operator|->
name|sign
condition|)
block|{
name|tfraction
operator|=
operator|-
name|a_fraction
operator|+
name|b_fraction
expr_stmt|;
block|}
else|else
block|{
name|tfraction
operator|=
name|a_fraction
operator|-
name|b_fraction
expr_stmt|;
block|}
if|if
condition|(
name|tfraction
operator|>=
literal|0
condition|)
block|{
name|tmp
operator|->
name|sign
operator|=
literal|0
expr_stmt|;
name|tmp
operator|->
name|normal_exp
operator|=
name|a_normal_exp
expr_stmt|;
name|tmp
operator|->
name|fraction
operator|.
name|ll
operator|=
name|tfraction
expr_stmt|;
block|}
else|else
block|{
name|tmp
operator|->
name|sign
operator|=
literal|1
expr_stmt|;
name|tmp
operator|->
name|normal_exp
operator|=
name|a_normal_exp
expr_stmt|;
name|tmp
operator|->
name|fraction
operator|.
name|ll
operator|=
operator|-
name|tfraction
expr_stmt|;
block|}
comment|/* and renormalize it */
while|while
condition|(
name|tmp
operator|->
name|fraction
operator|.
name|ll
operator|<
name|IMPLICIT_1
operator|&&
name|tmp
operator|->
name|fraction
operator|.
name|ll
condition|)
block|{
name|tmp
operator|->
name|fraction
operator|.
name|ll
operator|<<=
literal|1
expr_stmt|;
name|tmp
operator|->
name|normal_exp
operator|--
expr_stmt|;
block|}
block|}
else|else
block|{
name|tmp
operator|->
name|sign
operator|=
name|a
operator|->
name|sign
expr_stmt|;
name|tmp
operator|->
name|normal_exp
operator|=
name|a_normal_exp
expr_stmt|;
name|tmp
operator|->
name|fraction
operator|.
name|ll
operator|=
name|a_fraction
operator|+
name|b_fraction
expr_stmt|;
block|}
name|tmp
operator|->
name|class
operator|=
name|CLASS_NUMBER
expr_stmt|;
comment|/* Now the fraction is added, we have to shift down to renormalize the      number */
if|if
condition|(
name|tmp
operator|->
name|fraction
operator|.
name|ll
operator|>=
name|IMPLICIT_2
condition|)
block|{
name|LSHIFT
argument_list|(
name|tmp
operator|->
name|fraction
operator|.
name|ll
argument_list|)
expr_stmt|;
name|tmp
operator|->
name|normal_exp
operator|++
expr_stmt|;
block|}
return|return
name|tmp
return|;
block|}
end_function

begin_function
name|FLO_type
name|add
parameter_list|(
name|FLO_type
name|arg_a
parameter_list|,
name|FLO_type
name|arg_b
parameter_list|)
block|{
name|fp_number_type
name|a
decl_stmt|;
name|fp_number_type
name|b
decl_stmt|;
name|fp_number_type
name|tmp
decl_stmt|;
name|fp_number_type
modifier|*
name|res
decl_stmt|;
name|unpack_d
argument_list|(
operator|(
name|FLO_union_type
operator|*
operator|)
operator|&
name|arg_a
argument_list|,
operator|&
name|a
argument_list|)
expr_stmt|;
name|unpack_d
argument_list|(
operator|(
name|FLO_union_type
operator|*
operator|)
operator|&
name|arg_b
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
name|res
operator|=
name|_fpadd_parts
argument_list|(
operator|&
name|a
argument_list|,
operator|&
name|b
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
return|return
name|pack_d
argument_list|(
name|res
argument_list|)
return|;
block|}
end_function

begin_function
name|FLO_type
name|sub
parameter_list|(
name|FLO_type
name|arg_a
parameter_list|,
name|FLO_type
name|arg_b
parameter_list|)
block|{
name|fp_number_type
name|a
decl_stmt|;
name|fp_number_type
name|b
decl_stmt|;
name|fp_number_type
name|tmp
decl_stmt|;
name|fp_number_type
modifier|*
name|res
decl_stmt|;
name|unpack_d
argument_list|(
operator|(
name|FLO_union_type
operator|*
operator|)
operator|&
name|arg_a
argument_list|,
operator|&
name|a
argument_list|)
expr_stmt|;
name|unpack_d
argument_list|(
operator|(
name|FLO_union_type
operator|*
operator|)
operator|&
name|arg_b
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
name|b
operator|.
name|sign
operator|^=
literal|1
expr_stmt|;
name|res
operator|=
name|_fpadd_parts
argument_list|(
operator|&
name|a
argument_list|,
operator|&
name|b
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
return|return
name|pack_d
argument_list|(
name|res
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_mul_sf
argument_list|)
operator|||
name|defined
argument_list|(
name|L_mul_df
argument_list|)
end_if

begin_function
specifier|static
name|INLINE
name|fp_number_type
modifier|*
name|_fpmul_parts
parameter_list|(
name|fp_number_type
modifier|*
name|a
parameter_list|,
name|fp_number_type
modifier|*
name|b
parameter_list|,
name|fp_number_type
modifier|*
name|tmp
parameter_list|)
block|{
name|fractype
name|low
init|=
literal|0
decl_stmt|;
name|fractype
name|high
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|isnan
argument_list|(
name|a
argument_list|)
condition|)
block|{
name|a
operator|->
name|sign
operator|=
name|a
operator|->
name|sign
operator|!=
name|b
operator|->
name|sign
expr_stmt|;
return|return
name|a
return|;
block|}
if|if
condition|(
name|isnan
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|b
operator|->
name|sign
operator|=
name|a
operator|->
name|sign
operator|!=
name|b
operator|->
name|sign
expr_stmt|;
return|return
name|b
return|;
block|}
if|if
condition|(
name|isinf
argument_list|(
name|a
argument_list|)
condition|)
block|{
if|if
condition|(
name|iszero
argument_list|(
name|b
argument_list|)
condition|)
return|return
name|nan
argument_list|()
return|;
name|a
operator|->
name|sign
operator|=
name|a
operator|->
name|sign
operator|!=
name|b
operator|->
name|sign
expr_stmt|;
return|return
name|a
return|;
block|}
if|if
condition|(
name|isinf
argument_list|(
name|b
argument_list|)
condition|)
block|{
if|if
condition|(
name|iszero
argument_list|(
name|a
argument_list|)
condition|)
block|{
return|return
name|nan
argument_list|()
return|;
block|}
name|b
operator|->
name|sign
operator|=
name|a
operator|->
name|sign
operator|!=
name|b
operator|->
name|sign
expr_stmt|;
return|return
name|b
return|;
block|}
if|if
condition|(
name|iszero
argument_list|(
name|a
argument_list|)
condition|)
block|{
name|a
operator|->
name|sign
operator|=
name|a
operator|->
name|sign
operator|!=
name|b
operator|->
name|sign
expr_stmt|;
return|return
name|a
return|;
block|}
if|if
condition|(
name|iszero
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|b
operator|->
name|sign
operator|=
name|a
operator|->
name|sign
operator|!=
name|b
operator|->
name|sign
expr_stmt|;
return|return
name|b
return|;
block|}
comment|/* Calculate the mantissa by multiplying both 64bit numbers to get a      128 bit number */
block|{
if|#
directive|if
name|defined
argument_list|(
name|NO_DI_MODE
argument_list|)
block|{
name|fractype
name|x
init|=
name|a
operator|->
name|fraction
operator|.
name|ll
decl_stmt|;
name|fractype
name|ylow
init|=
name|b
operator|->
name|fraction
operator|.
name|ll
decl_stmt|;
name|fractype
name|yhigh
init|=
literal|0
decl_stmt|;
name|int
name|bit
decl_stmt|;
comment|/* ??? This does multiplies one bit at a time.  Optimize.  */
for|for
control|(
name|bit
operator|=
literal|0
init|;
name|bit
operator|<
name|FRAC_NBITS
condition|;
name|bit
operator|++
control|)
block|{
name|int
name|carry
decl_stmt|;
if|if
condition|(
name|x
operator|&
literal|1
condition|)
block|{
name|carry
operator|=
operator|(
name|low
operator|+=
name|ylow
operator|)
operator|<
name|ylow
expr_stmt|;
name|high
operator|+=
name|yhigh
operator|+
name|carry
expr_stmt|;
block|}
name|yhigh
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|ylow
operator|&
name|FRACHIGH
condition|)
block|{
name|yhigh
operator||=
literal|1
expr_stmt|;
block|}
name|ylow
operator|<<=
literal|1
expr_stmt|;
name|x
operator|>>=
literal|1
expr_stmt|;
block|}
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|FLOAT
argument_list|)
block|{
comment|/* Multiplying two 32 bit numbers to get a 64 bit number  on          a machine with DI, so we're safe */
name|DItype
name|answer
init|=
call|(
name|DItype
call|)
argument_list|(
name|a
operator|->
name|fraction
operator|.
name|ll
argument_list|)
operator|*
call|(
name|DItype
call|)
argument_list|(
name|b
operator|->
name|fraction
operator|.
name|ll
argument_list|)
decl_stmt|;
name|high
operator|=
name|answer
operator|>>
literal|32
expr_stmt|;
name|low
operator|=
name|answer
expr_stmt|;
block|}
else|#
directive|else
comment|/* Doing a 64*64 to 128 */
block|{
name|UDItype
name|nl
init|=
name|a
operator|->
name|fraction
operator|.
name|ll
operator|&
literal|0xffffffff
decl_stmt|;
name|UDItype
name|nh
init|=
name|a
operator|->
name|fraction
operator|.
name|ll
operator|>>
literal|32
decl_stmt|;
name|UDItype
name|ml
init|=
name|b
operator|->
name|fraction
operator|.
name|ll
operator|&
literal|0xffffffff
decl_stmt|;
name|UDItype
name|mh
init|=
name|b
operator|->
name|fraction
operator|.
name|ll
operator|>>
literal|32
decl_stmt|;
name|UDItype
name|pp_ll
init|=
name|ml
operator|*
name|nl
decl_stmt|;
name|UDItype
name|pp_hl
init|=
name|mh
operator|*
name|nl
decl_stmt|;
name|UDItype
name|pp_lh
init|=
name|ml
operator|*
name|nh
decl_stmt|;
name|UDItype
name|pp_hh
init|=
name|mh
operator|*
name|nh
decl_stmt|;
name|UDItype
name|res2
init|=
literal|0
decl_stmt|;
name|UDItype
name|res0
init|=
literal|0
decl_stmt|;
name|UDItype
name|ps_hh__
init|=
name|pp_hl
operator|+
name|pp_lh
decl_stmt|;
if|if
condition|(
name|ps_hh__
operator|<
name|pp_hl
condition|)
name|res2
operator|+=
literal|0x100000000LL
expr_stmt|;
name|pp_hl
operator|=
operator|(
name|ps_hh__
operator|<<
literal|32
operator|)
operator|&
literal|0xffffffff00000000LL
expr_stmt|;
name|res0
operator|=
name|pp_ll
operator|+
name|pp_hl
expr_stmt|;
if|if
condition|(
name|res0
operator|<
name|pp_ll
condition|)
name|res2
operator|++
expr_stmt|;
name|res2
operator|+=
operator|(
operator|(
name|ps_hh__
operator|>>
literal|32
operator|)
operator|&
literal|0xffffffffL
operator|)
operator|+
name|pp_hh
expr_stmt|;
name|high
operator|=
name|res2
expr_stmt|;
name|low
operator|=
name|res0
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|tmp
operator|->
name|normal_exp
operator|=
name|a
operator|->
name|normal_exp
operator|+
name|b
operator|->
name|normal_exp
expr_stmt|;
name|tmp
operator|->
name|sign
operator|=
name|a
operator|->
name|sign
operator|!=
name|b
operator|->
name|sign
expr_stmt|;
ifdef|#
directive|ifdef
name|FLOAT
name|tmp
operator|->
name|normal_exp
operator|+=
literal|2
expr_stmt|;
comment|/* ??????????????? */
else|#
directive|else
name|tmp
operator|->
name|normal_exp
operator|+=
literal|4
expr_stmt|;
comment|/* ??????????????? */
endif|#
directive|endif
while|while
condition|(
name|high
operator|>=
name|IMPLICIT_2
condition|)
block|{
name|tmp
operator|->
name|normal_exp
operator|++
expr_stmt|;
if|if
condition|(
name|high
operator|&
literal|1
condition|)
block|{
name|low
operator|>>=
literal|1
expr_stmt|;
name|low
operator||=
name|FRACHIGH
expr_stmt|;
block|}
name|high
operator|>>=
literal|1
expr_stmt|;
block|}
while|while
condition|(
name|high
operator|<
name|IMPLICIT_1
condition|)
block|{
name|tmp
operator|->
name|normal_exp
operator|--
expr_stmt|;
name|high
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|low
operator|&
name|FRACHIGH
condition|)
name|high
operator||=
literal|1
expr_stmt|;
name|low
operator|<<=
literal|1
expr_stmt|;
block|}
comment|/* rounding is tricky. if we only round if it won't make us round later. */
if|#
directive|if
literal|0
block|if (low& FRACHIGH2)     {       if (((high& GARDMASK) != GARDMSB)&& (((high + 1)& GARDMASK) == GARDMSB)) 	{
comment|/* don't round, it gets done again later. */
block|}       else 	{ 	  high++; 	}     }
endif|#
directive|endif
if|if
condition|(
operator|(
name|high
operator|&
name|GARDMASK
operator|)
operator|==
name|GARDMSB
condition|)
block|{
if|if
condition|(
name|high
operator|&
operator|(
literal|1
operator|<<
name|NGARDS
operator|)
condition|)
block|{
comment|/* half way, so round to even */
name|high
operator|+=
name|GARDROUND
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|low
condition|)
block|{
comment|/* but we really weren't half way */
name|high
operator|+=
name|GARDROUND
operator|+
literal|1
expr_stmt|;
block|}
block|}
name|tmp
operator|->
name|fraction
operator|.
name|ll
operator|=
name|high
expr_stmt|;
name|tmp
operator|->
name|class
operator|=
name|CLASS_NUMBER
expr_stmt|;
return|return
name|tmp
return|;
block|}
end_function

begin_function
name|FLO_type
name|multiply
parameter_list|(
name|FLO_type
name|arg_a
parameter_list|,
name|FLO_type
name|arg_b
parameter_list|)
block|{
name|fp_number_type
name|a
decl_stmt|;
name|fp_number_type
name|b
decl_stmt|;
name|fp_number_type
name|tmp
decl_stmt|;
name|fp_number_type
modifier|*
name|res
decl_stmt|;
name|unpack_d
argument_list|(
operator|(
name|FLO_union_type
operator|*
operator|)
operator|&
name|arg_a
argument_list|,
operator|&
name|a
argument_list|)
expr_stmt|;
name|unpack_d
argument_list|(
operator|(
name|FLO_union_type
operator|*
operator|)
operator|&
name|arg_b
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
name|res
operator|=
name|_fpmul_parts
argument_list|(
operator|&
name|a
argument_list|,
operator|&
name|b
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
return|return
name|pack_d
argument_list|(
name|res
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_div_sf
argument_list|)
operator|||
name|defined
argument_list|(
name|L_div_df
argument_list|)
end_if

begin_function
specifier|static
name|INLINE
name|fp_number_type
modifier|*
name|_fpdiv_parts
parameter_list|(
name|fp_number_type
modifier|*
name|a
parameter_list|,
name|fp_number_type
modifier|*
name|b
parameter_list|)
block|{
name|fractype
name|bit
decl_stmt|;
name|fractype
name|numerator
decl_stmt|;
name|fractype
name|denominator
decl_stmt|;
name|fractype
name|quotient
decl_stmt|;
if|if
condition|(
name|isnan
argument_list|(
name|a
argument_list|)
condition|)
block|{
return|return
name|a
return|;
block|}
if|if
condition|(
name|isnan
argument_list|(
name|b
argument_list|)
condition|)
block|{
return|return
name|b
return|;
block|}
name|a
operator|->
name|sign
operator|=
name|a
operator|->
name|sign
operator|^
name|b
operator|->
name|sign
expr_stmt|;
if|if
condition|(
name|isinf
argument_list|(
name|a
argument_list|)
operator|||
name|iszero
argument_list|(
name|a
argument_list|)
condition|)
block|{
if|if
condition|(
name|a
operator|->
name|class
operator|==
name|b
operator|->
name|class
condition|)
return|return
name|nan
argument_list|()
return|;
return|return
name|a
return|;
block|}
if|if
condition|(
name|isinf
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|a
operator|->
name|fraction
operator|.
name|ll
operator|=
literal|0
expr_stmt|;
name|a
operator|->
name|normal_exp
operator|=
literal|0
expr_stmt|;
return|return
name|a
return|;
block|}
if|if
condition|(
name|iszero
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|a
operator|->
name|class
operator|=
name|CLASS_INFINITY
expr_stmt|;
return|return
name|a
return|;
block|}
comment|/* Calculate the mantissa by multiplying both 64bit numbers to get a      128 bit number */
block|{
comment|/* quotient =        ( numerator / denominator) * 2^(numerator exponent -  denominator exponent)      */
name|a
operator|->
name|normal_exp
operator|=
name|a
operator|->
name|normal_exp
operator|-
name|b
operator|->
name|normal_exp
expr_stmt|;
name|numerator
operator|=
name|a
operator|->
name|fraction
operator|.
name|ll
expr_stmt|;
name|denominator
operator|=
name|b
operator|->
name|fraction
operator|.
name|ll
expr_stmt|;
if|if
condition|(
name|numerator
operator|<
name|denominator
condition|)
block|{
comment|/* Fraction will be less than 1.0 */
name|numerator
operator|*=
literal|2
expr_stmt|;
name|a
operator|->
name|normal_exp
operator|--
expr_stmt|;
block|}
name|bit
operator|=
name|IMPLICIT_1
expr_stmt|;
name|quotient
operator|=
literal|0
expr_stmt|;
comment|/* ??? Does divide one bit at a time.  Optimize.  */
while|while
condition|(
name|bit
condition|)
block|{
if|if
condition|(
name|numerator
operator|>=
name|denominator
condition|)
block|{
name|quotient
operator||=
name|bit
expr_stmt|;
name|numerator
operator|-=
name|denominator
expr_stmt|;
block|}
name|bit
operator|>>=
literal|1
expr_stmt|;
name|numerator
operator|*=
literal|2
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|quotient
operator|&
name|GARDMASK
operator|)
operator|==
name|GARDMSB
condition|)
block|{
if|if
condition|(
name|quotient
operator|&
operator|(
literal|1
operator|<<
name|NGARDS
operator|)
condition|)
block|{
comment|/* half way, so round to even */
name|quotient
operator|+=
name|GARDROUND
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|numerator
condition|)
block|{
comment|/* but we really weren't half way, more bits exist */
name|quotient
operator|+=
name|GARDROUND
operator|+
literal|1
expr_stmt|;
block|}
block|}
name|a
operator|->
name|fraction
operator|.
name|ll
operator|=
name|quotient
expr_stmt|;
return|return
operator|(
name|a
operator|)
return|;
block|}
block|}
end_function

begin_function
name|FLO_type
name|divide
parameter_list|(
name|FLO_type
name|arg_a
parameter_list|,
name|FLO_type
name|arg_b
parameter_list|)
block|{
name|fp_number_type
name|a
decl_stmt|;
name|fp_number_type
name|b
decl_stmt|;
name|fp_number_type
modifier|*
name|res
decl_stmt|;
name|unpack_d
argument_list|(
operator|(
name|FLO_union_type
operator|*
operator|)
operator|&
name|arg_a
argument_list|,
operator|&
name|a
argument_list|)
expr_stmt|;
name|unpack_d
argument_list|(
operator|(
name|FLO_union_type
operator|*
operator|)
operator|&
name|arg_b
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
name|res
operator|=
name|_fpdiv_parts
argument_list|(
operator|&
name|a
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
return|return
name|pack_d
argument_list|(
name|res
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|int
name|__fpcmp_parts
parameter_list|(
name|fp_number_type
modifier|*
name|a
parameter_list|,
name|fp_number_type
modifier|*
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_fpcmp_parts_sf
argument_list|)
operator|||
name|defined
argument_list|(
name|L_fpcmp_parts_df
argument_list|)
end_if

begin_comment
comment|/* according to the demo, fpcmp returns a comparison with 0... thus    a<b -> -1    a==b -> 0    a>b -> +1  */
end_comment

begin_function
name|int
name|__fpcmp_parts
parameter_list|(
name|fp_number_type
modifier|*
name|a
parameter_list|,
name|fp_number_type
modifier|*
name|b
parameter_list|)
block|{
if|#
directive|if
literal|0
comment|/* either nan -> unordered. Must be checked outside of this routine. */
block|if (isnan (a)&& isnan (b))     {       return 1;
comment|/* still unordered! */
block|}
endif|#
directive|endif
if|if
condition|(
name|isnan
argument_list|(
name|a
argument_list|)
operator|||
name|isnan
argument_list|(
name|b
argument_list|)
condition|)
block|{
return|return
literal|1
return|;
comment|/* how to indicate unordered compare? */
block|}
if|if
condition|(
name|isinf
argument_list|(
name|a
argument_list|)
operator|&&
name|isinf
argument_list|(
name|b
argument_list|)
condition|)
block|{
comment|/* +inf> -inf, but +inf != +inf */
comment|/* b    \a| +inf(0)| -inf(1)        ______\+--------+--------        +inf(0)| a==b(0)| a<b(-1)        -------+--------+--------        -inf(1)| a>b(1) | a==b(0)        -------+--------+--------        So since unordered must be non zero, just line up the columns...        */
return|return
name|b
operator|->
name|sign
operator|-
name|a
operator|->
name|sign
return|;
block|}
comment|/* but not both... */
if|if
condition|(
name|isinf
argument_list|(
name|a
argument_list|)
condition|)
block|{
return|return
name|a
operator|->
name|sign
condition|?
operator|-
literal|1
else|:
literal|1
return|;
block|}
if|if
condition|(
name|isinf
argument_list|(
name|b
argument_list|)
condition|)
block|{
return|return
name|b
operator|->
name|sign
condition|?
literal|1
else|:
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|iszero
argument_list|(
name|a
argument_list|)
operator|&&
name|iszero
argument_list|(
name|b
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
name|iszero
argument_list|(
name|a
argument_list|)
condition|)
block|{
return|return
name|b
operator|->
name|sign
condition|?
literal|1
else|:
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|iszero
argument_list|(
name|b
argument_list|)
condition|)
block|{
return|return
name|a
operator|->
name|sign
condition|?
operator|-
literal|1
else|:
literal|1
return|;
block|}
comment|/* now both are "normal". */
if|if
condition|(
name|a
operator|->
name|sign
operator|!=
name|b
operator|->
name|sign
condition|)
block|{
comment|/* opposite signs */
return|return
name|a
operator|->
name|sign
condition|?
operator|-
literal|1
else|:
literal|1
return|;
block|}
comment|/* same sign; exponents? */
if|if
condition|(
name|a
operator|->
name|normal_exp
operator|>
name|b
operator|->
name|normal_exp
condition|)
block|{
return|return
name|a
operator|->
name|sign
condition|?
operator|-
literal|1
else|:
literal|1
return|;
block|}
if|if
condition|(
name|a
operator|->
name|normal_exp
operator|<
name|b
operator|->
name|normal_exp
condition|)
block|{
return|return
name|a
operator|->
name|sign
condition|?
literal|1
else|:
operator|-
literal|1
return|;
block|}
comment|/* same exponents; check size. */
if|if
condition|(
name|a
operator|->
name|fraction
operator|.
name|ll
operator|>
name|b
operator|->
name|fraction
operator|.
name|ll
condition|)
block|{
return|return
name|a
operator|->
name|sign
condition|?
operator|-
literal|1
else|:
literal|1
return|;
block|}
if|if
condition|(
name|a
operator|->
name|fraction
operator|.
name|ll
operator|<
name|b
operator|->
name|fraction
operator|.
name|ll
condition|)
block|{
return|return
name|a
operator|->
name|sign
condition|?
literal|1
else|:
operator|-
literal|1
return|;
block|}
comment|/* after all that, they're equal. */
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_compare_sf
argument_list|)
operator|||
name|defined
argument_list|(
name|L_compare_df
argument_list|)
end_if

begin_function
name|CMPtype
name|compare
parameter_list|(
name|FLO_type
name|arg_a
parameter_list|,
name|FLO_type
name|arg_b
parameter_list|)
block|{
name|fp_number_type
name|a
decl_stmt|;
name|fp_number_type
name|b
decl_stmt|;
name|unpack_d
argument_list|(
operator|(
name|FLO_union_type
operator|*
operator|)
operator|&
name|arg_a
argument_list|,
operator|&
name|a
argument_list|)
expr_stmt|;
name|unpack_d
argument_list|(
operator|(
name|FLO_union_type
operator|*
operator|)
operator|&
name|arg_b
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
return|return
name|__fpcmp_parts
argument_list|(
operator|&
name|a
argument_list|,
operator|&
name|b
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|US_SOFTWARE_GOFAST
end_ifndef

begin_comment
comment|/* These should be optimized for their specific tasks someday.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_eq_sf
argument_list|)
operator|||
name|defined
argument_list|(
name|L_eq_df
argument_list|)
end_if

begin_function
name|CMPtype
name|_eq_f2
parameter_list|(
name|FLO_type
name|arg_a
parameter_list|,
name|FLO_type
name|arg_b
parameter_list|)
block|{
name|fp_number_type
name|a
decl_stmt|;
name|fp_number_type
name|b
decl_stmt|;
name|unpack_d
argument_list|(
operator|(
name|FLO_union_type
operator|*
operator|)
operator|&
name|arg_a
argument_list|,
operator|&
name|a
argument_list|)
expr_stmt|;
name|unpack_d
argument_list|(
operator|(
name|FLO_union_type
operator|*
operator|)
operator|&
name|arg_b
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|isnan
argument_list|(
operator|&
name|a
argument_list|)
operator|||
name|isnan
argument_list|(
operator|&
name|b
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* false, truth == 0 */
return|return
name|__fpcmp_parts
argument_list|(
operator|&
name|a
argument_list|,
operator|&
name|b
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_ne_sf
argument_list|)
operator|||
name|defined
argument_list|(
name|L_ne_df
argument_list|)
end_if

begin_function
name|CMPtype
name|_ne_f2
parameter_list|(
name|FLO_type
name|arg_a
parameter_list|,
name|FLO_type
name|arg_b
parameter_list|)
block|{
name|fp_number_type
name|a
decl_stmt|;
name|fp_number_type
name|b
decl_stmt|;
name|unpack_d
argument_list|(
operator|(
name|FLO_union_type
operator|*
operator|)
operator|&
name|arg_a
argument_list|,
operator|&
name|a
argument_list|)
expr_stmt|;
name|unpack_d
argument_list|(
operator|(
name|FLO_union_type
operator|*
operator|)
operator|&
name|arg_b
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|isnan
argument_list|(
operator|&
name|a
argument_list|)
operator|||
name|isnan
argument_list|(
operator|&
name|b
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* true, truth != 0 */
return|return
name|__fpcmp_parts
argument_list|(
operator|&
name|a
argument_list|,
operator|&
name|b
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_gt_sf
argument_list|)
operator|||
name|defined
argument_list|(
name|L_gt_df
argument_list|)
end_if

begin_function
name|CMPtype
name|_gt_f2
parameter_list|(
name|FLO_type
name|arg_a
parameter_list|,
name|FLO_type
name|arg_b
parameter_list|)
block|{
name|fp_number_type
name|a
decl_stmt|;
name|fp_number_type
name|b
decl_stmt|;
name|unpack_d
argument_list|(
operator|(
name|FLO_union_type
operator|*
operator|)
operator|&
name|arg_a
argument_list|,
operator|&
name|a
argument_list|)
expr_stmt|;
name|unpack_d
argument_list|(
operator|(
name|FLO_union_type
operator|*
operator|)
operator|&
name|arg_b
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|isnan
argument_list|(
operator|&
name|a
argument_list|)
operator|||
name|isnan
argument_list|(
operator|&
name|b
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* false, truth> 0 */
return|return
name|__fpcmp_parts
argument_list|(
operator|&
name|a
argument_list|,
operator|&
name|b
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_ge_sf
argument_list|)
operator|||
name|defined
argument_list|(
name|L_ge_df
argument_list|)
end_if

begin_function
name|CMPtype
name|_ge_f2
parameter_list|(
name|FLO_type
name|arg_a
parameter_list|,
name|FLO_type
name|arg_b
parameter_list|)
block|{
name|fp_number_type
name|a
decl_stmt|;
name|fp_number_type
name|b
decl_stmt|;
name|unpack_d
argument_list|(
operator|(
name|FLO_union_type
operator|*
operator|)
operator|&
name|arg_a
argument_list|,
operator|&
name|a
argument_list|)
expr_stmt|;
name|unpack_d
argument_list|(
operator|(
name|FLO_union_type
operator|*
operator|)
operator|&
name|arg_b
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|isnan
argument_list|(
operator|&
name|a
argument_list|)
operator|||
name|isnan
argument_list|(
operator|&
name|b
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* false, truth>= 0 */
return|return
name|__fpcmp_parts
argument_list|(
operator|&
name|a
argument_list|,
operator|&
name|b
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_lt_sf
argument_list|)
operator|||
name|defined
argument_list|(
name|L_lt_df
argument_list|)
end_if

begin_function
name|CMPtype
name|_lt_f2
parameter_list|(
name|FLO_type
name|arg_a
parameter_list|,
name|FLO_type
name|arg_b
parameter_list|)
block|{
name|fp_number_type
name|a
decl_stmt|;
name|fp_number_type
name|b
decl_stmt|;
name|unpack_d
argument_list|(
operator|(
name|FLO_union_type
operator|*
operator|)
operator|&
name|arg_a
argument_list|,
operator|&
name|a
argument_list|)
expr_stmt|;
name|unpack_d
argument_list|(
operator|(
name|FLO_union_type
operator|*
operator|)
operator|&
name|arg_b
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|isnan
argument_list|(
operator|&
name|a
argument_list|)
operator|||
name|isnan
argument_list|(
operator|&
name|b
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* false, truth< 0 */
return|return
name|__fpcmp_parts
argument_list|(
operator|&
name|a
argument_list|,
operator|&
name|b
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_le_sf
argument_list|)
operator|||
name|defined
argument_list|(
name|L_le_df
argument_list|)
end_if

begin_function
name|CMPtype
name|_le_f2
parameter_list|(
name|FLO_type
name|arg_a
parameter_list|,
name|FLO_type
name|arg_b
parameter_list|)
block|{
name|fp_number_type
name|a
decl_stmt|;
name|fp_number_type
name|b
decl_stmt|;
name|unpack_d
argument_list|(
operator|(
name|FLO_union_type
operator|*
operator|)
operator|&
name|arg_a
argument_list|,
operator|&
name|a
argument_list|)
expr_stmt|;
name|unpack_d
argument_list|(
operator|(
name|FLO_union_type
operator|*
operator|)
operator|&
name|arg_b
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|isnan
argument_list|(
operator|&
name|a
argument_list|)
operator|||
name|isnan
argument_list|(
operator|&
name|b
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* false, truth<= 0 */
return|return
name|__fpcmp_parts
argument_list|(
operator|&
name|a
argument_list|,
operator|&
name|b
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! US_SOFTWARE_GOFAST */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_si_to_sf
argument_list|)
operator|||
name|defined
argument_list|(
name|L_si_to_df
argument_list|)
end_if

begin_function
name|FLO_type
name|si_to_float
parameter_list|(
name|SItype
name|arg_a
parameter_list|)
block|{
name|fp_number_type
name|in
decl_stmt|;
name|in
operator|.
name|class
operator|=
name|CLASS_NUMBER
expr_stmt|;
name|in
operator|.
name|sign
operator|=
name|arg_a
operator|<
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|arg_a
condition|)
block|{
name|in
operator|.
name|class
operator|=
name|CLASS_ZERO
expr_stmt|;
block|}
else|else
block|{
name|in
operator|.
name|normal_exp
operator|=
name|FRACBITS
operator|+
name|NGARDS
expr_stmt|;
if|if
condition|(
name|in
operator|.
name|sign
condition|)
block|{
comment|/* Special case for minint, since there is no +ve integer 	     representation for it */
if|if
condition|(
name|arg_a
operator|==
operator|(
name|SItype
operator|)
literal|0x80000000
condition|)
block|{
return|return
operator|-
literal|2147483648.0
return|;
block|}
name|in
operator|.
name|fraction
operator|.
name|ll
operator|=
operator|(
operator|-
name|arg_a
operator|)
expr_stmt|;
block|}
else|else
name|in
operator|.
name|fraction
operator|.
name|ll
operator|=
name|arg_a
expr_stmt|;
while|while
condition|(
name|in
operator|.
name|fraction
operator|.
name|ll
operator|<
operator|(
literal|1LL
operator|<<
operator|(
name|FRACBITS
operator|+
name|NGARDS
operator|)
operator|)
condition|)
block|{
name|in
operator|.
name|fraction
operator|.
name|ll
operator|<<=
literal|1
expr_stmt|;
name|in
operator|.
name|normal_exp
operator|-=
literal|1
expr_stmt|;
block|}
block|}
return|return
name|pack_d
argument_list|(
operator|&
name|in
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_sf_to_si
argument_list|)
operator|||
name|defined
argument_list|(
name|L_df_to_si
argument_list|)
end_if

begin_function
name|SItype
name|float_to_si
parameter_list|(
name|FLO_type
name|arg_a
parameter_list|)
block|{
name|fp_number_type
name|a
decl_stmt|;
name|SItype
name|tmp
decl_stmt|;
name|unpack_d
argument_list|(
operator|(
name|FLO_union_type
operator|*
operator|)
operator|&
name|arg_a
argument_list|,
operator|&
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|iszero
argument_list|(
operator|&
name|a
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|isnan
argument_list|(
operator|&
name|a
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* get reasonable MAX_SI_INT... */
if|if
condition|(
name|isinf
argument_list|(
operator|&
name|a
argument_list|)
condition|)
return|return
name|a
operator|.
name|sign
condition|?
operator|(
operator|-
name|MAX_SI_INT
operator|)
operator|-
literal|1
else|:
name|MAX_SI_INT
return|;
comment|/* it is a number, but a small one */
if|if
condition|(
name|a
operator|.
name|normal_exp
operator|<
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|a
operator|.
name|normal_exp
operator|>
literal|30
condition|)
return|return
name|a
operator|.
name|sign
condition|?
operator|(
operator|-
name|MAX_SI_INT
operator|)
operator|-
literal|1
else|:
name|MAX_SI_INT
return|;
name|tmp
operator|=
name|a
operator|.
name|fraction
operator|.
name|ll
operator|>>
operator|(
operator|(
name|FRACBITS
operator|+
name|NGARDS
operator|)
operator|-
name|a
operator|.
name|normal_exp
operator|)
expr_stmt|;
return|return
name|a
operator|.
name|sign
condition|?
operator|(
operator|-
name|tmp
operator|)
else|:
operator|(
name|tmp
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_sf_to_usi
argument_list|)
operator|||
name|defined
argument_list|(
name|L_df_to_usi
argument_list|)
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|US_SOFTWARE_GOFAST
end_ifdef

begin_comment
comment|/* While libgcc2.c defines its own __fixunssfsi and __fixunsdfsi routines,    we also define them for GOFAST because the ones in libgcc2.c have the    wrong names and I'd rather define these here and keep GOFAST CYG-LOC's    out of libgcc2.c.  We can't define these here if not GOFAST because then    there'd be duplicate copies.  */
end_comment

begin_function
name|USItype
name|float_to_usi
parameter_list|(
name|FLO_type
name|arg_a
parameter_list|)
block|{
name|fp_number_type
name|a
decl_stmt|;
name|unpack_d
argument_list|(
operator|(
name|FLO_union_type
operator|*
operator|)
operator|&
name|arg_a
argument_list|,
operator|&
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|iszero
argument_list|(
operator|&
name|a
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|isnan
argument_list|(
operator|&
name|a
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* it is a negative number */
if|if
condition|(
name|a
operator|.
name|sign
condition|)
return|return
literal|0
return|;
comment|/* get reasonable MAX_USI_INT... */
if|if
condition|(
name|isinf
argument_list|(
operator|&
name|a
argument_list|)
condition|)
return|return
name|MAX_USI_INT
return|;
comment|/* it is a number, but a small one */
if|if
condition|(
name|a
operator|.
name|normal_exp
operator|<
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|a
operator|.
name|normal_exp
operator|>
literal|31
condition|)
return|return
name|MAX_USI_INT
return|;
elseif|else
if|if
condition|(
name|a
operator|.
name|normal_exp
operator|>
operator|(
name|FRACBITS
operator|+
name|NGARDS
operator|)
condition|)
return|return
name|a
operator|.
name|fraction
operator|.
name|ll
operator|<<
operator|(
name|a
operator|.
name|normal_exp
operator|-
operator|(
name|FRACBITS
operator|+
name|NGARDS
operator|)
operator|)
return|;
else|else
return|return
name|a
operator|.
name|fraction
operator|.
name|ll
operator|>>
operator|(
operator|(
name|FRACBITS
operator|+
name|NGARDS
operator|)
operator|-
name|a
operator|.
name|normal_exp
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_negate_sf
argument_list|)
operator|||
name|defined
argument_list|(
name|L_negate_df
argument_list|)
end_if

begin_function
name|FLO_type
name|negate
parameter_list|(
name|FLO_type
name|arg_a
parameter_list|)
block|{
name|fp_number_type
name|a
decl_stmt|;
name|unpack_d
argument_list|(
operator|(
name|FLO_union_type
operator|*
operator|)
operator|&
name|arg_a
argument_list|,
operator|&
name|a
argument_list|)
expr_stmt|;
name|flip_sign
argument_list|(
operator|&
name|a
argument_list|)
expr_stmt|;
return|return
name|pack_d
argument_list|(
operator|&
name|a
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|FLOAT
end_ifdef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_make_sf
argument_list|)
end_if

begin_function
name|SFtype
name|__make_fp
parameter_list|(
name|fp_class_type
name|class
parameter_list|,
name|unsigned
name|int
name|sign
parameter_list|,
name|int
name|exp
parameter_list|,
name|USItype
name|frac
parameter_list|)
block|{
name|fp_number_type
name|in
decl_stmt|;
name|in
operator|.
name|class
operator|=
name|class
expr_stmt|;
name|in
operator|.
name|sign
operator|=
name|sign
expr_stmt|;
name|in
operator|.
name|normal_exp
operator|=
name|exp
expr_stmt|;
name|in
operator|.
name|fraction
operator|.
name|ll
operator|=
name|frac
expr_stmt|;
return|return
name|pack_d
argument_list|(
operator|&
name|in
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|FLOAT_ONLY
end_ifndef

begin_comment
comment|/* This enables one to build an fp library that supports float but not double.    Otherwise, we would get an undefined reference to __make_dp.    This is needed for some 8-bit ports that can't handle well values that    are 8-bytes in size, so we just don't support double for them at all.  */
end_comment

begin_function_decl
specifier|extern
name|DFtype
name|__make_dp
parameter_list|(
name|fp_class_type
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|int
parameter_list|,
name|UDItype
name|frac
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_sf_to_df
argument_list|)
end_if

begin_function
name|DFtype
name|sf_to_df
parameter_list|(
name|SFtype
name|arg_a
parameter_list|)
block|{
name|fp_number_type
name|in
decl_stmt|;
name|unpack_d
argument_list|(
operator|(
name|FLO_union_type
operator|*
operator|)
operator|&
name|arg_a
argument_list|,
operator|&
name|in
argument_list|)
expr_stmt|;
return|return
name|__make_dp
argument_list|(
name|in
operator|.
name|class
argument_list|,
name|in
operator|.
name|sign
argument_list|,
name|in
operator|.
name|normal_exp
argument_list|,
operator|(
operator|(
name|UDItype
operator|)
name|in
operator|.
name|fraction
operator|.
name|ll
operator|)
operator|<<
name|F_D_BITOFF
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|FLOAT
end_ifndef

begin_function_decl
specifier|extern
name|SFtype
name|__make_fp
parameter_list|(
name|fp_class_type
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|int
parameter_list|,
name|USItype
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_make_df
argument_list|)
end_if

begin_function
name|DFtype
name|__make_dp
parameter_list|(
name|fp_class_type
name|class
parameter_list|,
name|unsigned
name|int
name|sign
parameter_list|,
name|int
name|exp
parameter_list|,
name|UDItype
name|frac
parameter_list|)
block|{
name|fp_number_type
name|in
decl_stmt|;
name|in
operator|.
name|class
operator|=
name|class
expr_stmt|;
name|in
operator|.
name|sign
operator|=
name|sign
expr_stmt|;
name|in
operator|.
name|normal_exp
operator|=
name|exp
expr_stmt|;
name|in
operator|.
name|fraction
operator|.
name|ll
operator|=
name|frac
expr_stmt|;
return|return
name|pack_d
argument_list|(
operator|&
name|in
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_df_to_sf
argument_list|)
end_if

begin_function
name|SFtype
name|df_to_sf
parameter_list|(
name|DFtype
name|arg_a
parameter_list|)
block|{
name|fp_number_type
name|in
decl_stmt|;
name|USItype
name|sffrac
decl_stmt|;
name|unpack_d
argument_list|(
operator|(
name|FLO_union_type
operator|*
operator|)
operator|&
name|arg_a
argument_list|,
operator|&
name|in
argument_list|)
expr_stmt|;
name|sffrac
operator|=
name|in
operator|.
name|fraction
operator|.
name|ll
operator|>>
name|F_D_BITOFF
expr_stmt|;
comment|/* We set the lowest guard bit in SFFRAC if we discarded any non      zero bits.  */
if|if
condition|(
operator|(
name|in
operator|.
name|fraction
operator|.
name|ll
operator|&
operator|(
operator|(
operator|(
name|USItype
operator|)
literal|1
operator|<<
name|F_D_BITOFF
operator|)
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
name|sffrac
operator||=
literal|1
expr_stmt|;
return|return
name|__make_fp
argument_list|(
name|in
operator|.
name|class
argument_list|,
name|in
operator|.
name|sign
argument_list|,
name|in
operator|.
name|normal_exp
argument_list|,
name|sffrac
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !EXTENDED_FLOAT_STUBS */
end_comment

end_unit

