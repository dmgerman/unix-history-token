begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* This is a software floating point library which can be used    for targets without hardware floating point.     Copyright (C) 1994, 1995, 1996, 1997, 1998, 2000, 2001    Free Software Foundation, Inc.  This file is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  In addition to the permissions in the GNU General Public License, the Free Software Foundation gives you unlimited permission to link the compiled version of this file with other programs, and to distribute those programs without any restriction coming from the use of this file.  (The General Public License restrictions do apply in other respects; for example, they cover modification of the file, and distribution when not linked into another program.)  This file is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* As a special exception, if you link this library with other files,    some of which are compiled with GCC, to produce an executable,    this library does not by itself cause the resulting executable    to be covered by the GNU General Public License.    This exception does not however invalidate any other reasons why    the executable file might be covered by the GNU General Public License.  */
end_comment

begin_comment
comment|/* This implements IEEE 754 format arithmetic, but does not provide a    mechanism for setting the rounding mode, or for generating or handling    exceptions.     The original code by Steve Chamberlain, hacked by Mark Eichin and Jim    Wilson, all of Cygnus Support.  */
end_comment

begin_comment
comment|/* The intended way to use this file is to make two copies, add `#define FLOAT'    to one copy, then compile both copies and add them to libgcc.a.  */
end_comment

begin_include
include|#
directive|include
file|"tconfig.h"
end_include

begin_include
include|#
directive|include
file|"fp-bit.h"
end_include

begin_comment
comment|/* The following macros can be defined to change the behaviour of this file:    FLOAT: Implement a `float', aka SFmode, fp library.  If this is not      defined, then this file implements a `double', aka DFmode, fp library.    FLOAT_ONLY: Used with FLOAT, to implement a `float' only library, i.e.      don't include float->double conversion which requires the double library.      This is useful only for machines which can't support doubles, e.g. some      8-bit processors.    CMPtype: Specify the type that floating point compares should return.      This defaults to SItype, aka int.    US_SOFTWARE_GOFAST: This makes all entry points use the same names as the      US Software goFast library.    _DEBUG_BITFLOAT: This makes debugging the code a little easier, by adding      two integers to the FLO_union_type.    NO_DENORMALS: Disable handling of denormals.    NO_NANS: Disable nan and infinity handling    SMALL_MACHINE: Useful when operations on QIs and HIs are faster      than on an SI */
end_comment

begin_comment
comment|/* We don't currently support extended floats (long doubles) on machines    without hardware to deal with them.     These stubs are just to keep the linker from complaining about unresolved    references which can be pulled in from libio& libstdc++, even if the    user isn't using long doubles.  However, they may generate an unresolved    external to abort if abort is not used by the function, and the stubs    are referenced from within libc, since libgcc goes before and after the    system library.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|EXTENDED_FLOAT_STUBS
end_ifdef

begin_macro
name|__truncxfsf2
argument_list|()
end_macro

begin_block
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|__extendsfxf2
argument_list|()
end_macro

begin_block
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|__addxf3
argument_list|()
end_macro

begin_block
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|__divxf3
argument_list|()
end_macro

begin_block
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|__eqxf2
argument_list|()
end_macro

begin_block
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|__extenddfxf2
argument_list|()
end_macro

begin_block
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|__gtxf2
argument_list|()
end_macro

begin_block
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|__lexf2
argument_list|()
end_macro

begin_block
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|__ltxf2
argument_list|()
end_macro

begin_block
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|__mulxf3
argument_list|()
end_macro

begin_block
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|__negxf2
argument_list|()
end_macro

begin_block
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|__nexf2
argument_list|()
end_macro

begin_block
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|__subxf3
argument_list|()
end_macro

begin_block
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|__truncxfdf2
argument_list|()
end_macro

begin_block
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|__trunctfsf2
argument_list|()
end_macro

begin_block
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|__extendsftf2
argument_list|()
end_macro

begin_block
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|__addtf3
argument_list|()
end_macro

begin_block
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|__divtf3
argument_list|()
end_macro

begin_block
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|__eqtf2
argument_list|()
end_macro

begin_block
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|__extenddftf2
argument_list|()
end_macro

begin_block
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|__gttf2
argument_list|()
end_macro

begin_block
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|__letf2
argument_list|()
end_macro

begin_block
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|__lttf2
argument_list|()
end_macro

begin_block
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|__multf3
argument_list|()
end_macro

begin_block
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|__negtf2
argument_list|()
end_macro

begin_block
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|__netf2
argument_list|()
end_macro

begin_block
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|__subtf3
argument_list|()
end_macro

begin_block
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|__trunctfdf2
argument_list|()
end_macro

begin_block
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|__gexf2
argument_list|()
end_macro

begin_block
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|__fixxfsi
argument_list|()
end_macro

begin_block
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|__floatsixf
argument_list|()
end_macro

begin_block
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !EXTENDED_FLOAT_STUBS, rest of file */
end_comment

begin_comment
comment|/* IEEE "special" number predicates */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|NO_NANS
end_ifdef

begin_define
define|#
directive|define
name|nan
parameter_list|()
value|0
end_define

begin_define
define|#
directive|define
name|isnan
parameter_list|(
name|x
parameter_list|)
value|0
end_define

begin_define
define|#
directive|define
name|isinf
parameter_list|(
name|x
parameter_list|)
value|0
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|defined
name|L_thenan_sf
end_if

begin_decl_stmt
specifier|const
name|fp_number_type
name|__thenan_sf
init|=
block|{
name|CLASS_SNAN
block|,
literal|0
block|,
literal|0
block|,
block|{
operator|(
name|fractype
operator|)
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_elif
elif|#
directive|elif
name|defined
name|L_thenan_df
end_elif

begin_decl_stmt
specifier|const
name|fp_number_type
name|__thenan_df
init|=
block|{
name|CLASS_SNAN
block|,
literal|0
block|,
literal|0
block|,
block|{
operator|(
name|fractype
operator|)
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_elif
elif|#
directive|elif
name|defined
name|FLOAT
end_elif

begin_decl_stmt
specifier|extern
specifier|const
name|fp_number_type
name|__thenan_sf
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|extern
specifier|const
name|fp_number_type
name|__thenan_df
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|INLINE
specifier|static
name|fp_number_type
modifier|*
name|nan
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Discard the const qualifier... */
ifdef|#
directive|ifdef
name|FLOAT
return|return
operator|(
name|fp_number_type
operator|*
operator|)
operator|(
operator|&
name|__thenan_sf
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|fp_number_type
operator|*
operator|)
operator|(
operator|&
name|__thenan_df
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|INLINE
specifier|static
name|int
name|isnan
parameter_list|(
name|fp_number_type
modifier|*
name|x
parameter_list|)
block|{
return|return
name|x
operator|->
name|class
operator|==
name|CLASS_SNAN
operator|||
name|x
operator|->
name|class
operator|==
name|CLASS_QNAN
return|;
block|}
end_function

begin_function
name|INLINE
specifier|static
name|int
name|isinf
parameter_list|(
name|fp_number_type
modifier|*
name|x
parameter_list|)
block|{
return|return
name|x
operator|->
name|class
operator|==
name|CLASS_INFINITY
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NO_NANS */
end_comment

begin_function
name|INLINE
specifier|static
name|int
name|iszero
parameter_list|(
name|fp_number_type
modifier|*
name|x
parameter_list|)
block|{
return|return
name|x
operator|->
name|class
operator|==
name|CLASS_ZERO
return|;
block|}
end_function

begin_function
name|INLINE
specifier|static
name|void
name|flip_sign
parameter_list|(
name|fp_number_type
modifier|*
name|x
parameter_list|)
block|{
name|x
operator|->
name|sign
operator|=
operator|!
name|x
operator|->
name|sign
expr_stmt|;
block|}
end_function

begin_function_decl
specifier|extern
name|FLO_type
name|pack_d
parameter_list|(
name|fp_number_type
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_pack_df
argument_list|)
operator|||
name|defined
argument_list|(
name|L_pack_sf
argument_list|)
end_if

begin_function
name|FLO_type
name|pack_d
parameter_list|(
name|fp_number_type
modifier|*
name|src
parameter_list|)
block|{
name|FLO_union_type
name|dst
decl_stmt|;
name|fractype
name|fraction
init|=
name|src
operator|->
name|fraction
operator|.
name|ll
decl_stmt|;
comment|/* wasn't unsigned before? */
name|int
name|sign
init|=
name|src
operator|->
name|sign
decl_stmt|;
name|int
name|exp
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|isnan
argument_list|(
name|src
argument_list|)
condition|)
block|{
name|exp
operator|=
name|EXPMAX
expr_stmt|;
if|if
condition|(
name|src
operator|->
name|class
operator|==
name|CLASS_QNAN
operator|||
literal|1
condition|)
block|{
name|fraction
operator||=
name|QUIET_NAN
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|isinf
argument_list|(
name|src
argument_list|)
condition|)
block|{
name|exp
operator|=
name|EXPMAX
expr_stmt|;
name|fraction
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|iszero
argument_list|(
name|src
argument_list|)
condition|)
block|{
name|exp
operator|=
literal|0
expr_stmt|;
name|fraction
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fraction
operator|==
literal|0
condition|)
block|{
name|exp
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|src
operator|->
name|normal_exp
operator|<
name|NORMAL_EXPMIN
condition|)
block|{
comment|/* This number's exponent is too low to fit into the bits 	     available in the number, so we'll store 0 in the exponent and 	     shift the fraction to the right to make up for it.  */
name|int
name|shift
init|=
name|NORMAL_EXPMIN
operator|-
name|src
operator|->
name|normal_exp
decl_stmt|;
name|exp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|shift
operator|>
name|FRAC_NBITS
operator|-
name|NGARDS
condition|)
block|{
comment|/* No point shifting, since it's more that 64 out.  */
name|fraction
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|int
name|lowbit
init|=
operator|(
name|fraction
operator|&
operator|(
operator|(
operator|(
name|fractype
operator|)
literal|1
operator|<<
name|shift
operator|)
operator|-
literal|1
operator|)
operator|)
condition|?
literal|1
else|:
literal|0
decl_stmt|;
name|fraction
operator|=
operator|(
name|fraction
operator|>>
name|shift
operator|)
operator||
name|lowbit
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|fraction
operator|&
name|GARDMASK
operator|)
operator|==
name|GARDMSB
condition|)
block|{
if|if
condition|(
operator|(
name|fraction
operator|&
operator|(
literal|1
operator|<<
name|NGARDS
operator|)
operator|)
condition|)
name|fraction
operator|+=
name|GARDROUND
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Add to the guards to round up.  */
name|fraction
operator|+=
name|GARDROUND
expr_stmt|;
block|}
comment|/* Perhaps the rounding means we now need to change the              exponent, because the fraction is no longer denormal.  */
if|if
condition|(
name|fraction
operator|>=
name|IMPLICIT_1
condition|)
block|{
name|exp
operator|+=
literal|1
expr_stmt|;
block|}
name|fraction
operator|>>=
name|NGARDS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|src
operator|->
name|normal_exp
operator|>
name|EXPBIAS
condition|)
block|{
name|exp
operator|=
name|EXPMAX
expr_stmt|;
name|fraction
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|exp
operator|=
name|src
operator|->
name|normal_exp
operator|+
name|EXPBIAS
expr_stmt|;
comment|/* IF the gard bits are the all zero, but the first, then we're 	     half way between two numbers, choose the one which makes the 	     lsb of the answer 0.  */
if|if
condition|(
operator|(
name|fraction
operator|&
name|GARDMASK
operator|)
operator|==
name|GARDMSB
condition|)
block|{
if|if
condition|(
name|fraction
operator|&
operator|(
literal|1
operator|<<
name|NGARDS
operator|)
condition|)
name|fraction
operator|+=
name|GARDROUND
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Add a one to the guards to round up */
name|fraction
operator|+=
name|GARDROUND
expr_stmt|;
block|}
if|if
condition|(
name|fraction
operator|>=
name|IMPLICIT_2
condition|)
block|{
name|fraction
operator|>>=
literal|1
expr_stmt|;
name|exp
operator|+=
literal|1
expr_stmt|;
block|}
name|fraction
operator|>>=
name|NGARDS
expr_stmt|;
block|}
block|}
comment|/* We previously used bitfields to store the number, but this doesn't      handle little/big endian systems conveniently, so use shifts and      masks */
ifdef|#
directive|ifdef
name|FLOAT_BIT_ORDER_MISMATCH
name|dst
operator|.
name|bits
operator|.
name|fraction
operator|=
name|fraction
expr_stmt|;
name|dst
operator|.
name|bits
operator|.
name|exp
operator|=
name|exp
expr_stmt|;
name|dst
operator|.
name|bits
operator|.
name|sign
operator|=
name|sign
expr_stmt|;
else|#
directive|else
name|dst
operator|.
name|value_raw
operator|=
name|fraction
operator|&
operator|(
operator|(
operator|(
operator|(
name|fractype
operator|)
literal|1
operator|)
operator|<<
name|FRACBITS
operator|)
operator|-
operator|(
name|fractype
operator|)
literal|1
operator|)
expr_stmt|;
name|dst
operator|.
name|value_raw
operator||=
operator|(
call|(
name|fractype
call|)
argument_list|(
name|exp
operator|&
operator|(
operator|(
literal|1
operator|<<
name|EXPBITS
operator|)
operator|-
literal|1
operator|)
argument_list|)
operator|)
operator|<<
name|FRACBITS
expr_stmt|;
name|dst
operator|.
name|value_raw
operator||=
operator|(
call|(
name|fractype
call|)
argument_list|(
name|sign
operator|&
literal|1
argument_list|)
operator|)
operator|<<
operator|(
name|FRACBITS
operator||
name|EXPBITS
operator|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|FLOAT_WORD_ORDER_MISMATCH
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|FLOAT
argument_list|)
block|{
name|halffractype
name|tmp
init|=
name|dst
operator|.
name|words
index|[
literal|0
index|]
decl_stmt|;
name|dst
operator|.
name|words
index|[
literal|0
index|]
operator|=
name|dst
operator|.
name|words
index|[
literal|1
index|]
expr_stmt|;
name|dst
operator|.
name|words
index|[
literal|1
index|]
operator|=
name|tmp
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|dst
operator|.
name|value
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_unpack_df
argument_list|)
operator|||
name|defined
argument_list|(
name|L_unpack_sf
argument_list|)
end_if

begin_function
name|void
name|unpack_d
parameter_list|(
name|FLO_union_type
modifier|*
name|src
parameter_list|,
name|fp_number_type
modifier|*
name|dst
parameter_list|)
block|{
comment|/* We previously used bitfields to store the number, but this doesn't      handle little/big endian systems conveniently, so use shifts and      masks */
name|fractype
name|fraction
decl_stmt|;
name|int
name|exp
decl_stmt|;
name|int
name|sign
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|FLOAT_WORD_ORDER_MISMATCH
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|FLOAT
argument_list|)
name|FLO_union_type
name|swapped
decl_stmt|;
name|swapped
operator|.
name|words
index|[
literal|0
index|]
operator|=
name|src
operator|->
name|words
index|[
literal|1
index|]
expr_stmt|;
name|swapped
operator|.
name|words
index|[
literal|1
index|]
operator|=
name|src
operator|->
name|words
index|[
literal|0
index|]
expr_stmt|;
name|src
operator|=
operator|&
name|swapped
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|FLOAT_BIT_ORDER_MISMATCH
name|fraction
operator|=
name|src
operator|->
name|bits
operator|.
name|fraction
expr_stmt|;
name|exp
operator|=
name|src
operator|->
name|bits
operator|.
name|exp
expr_stmt|;
name|sign
operator|=
name|src
operator|->
name|bits
operator|.
name|sign
expr_stmt|;
else|#
directive|else
name|fraction
operator|=
name|src
operator|->
name|value_raw
operator|&
operator|(
operator|(
operator|(
operator|(
name|fractype
operator|)
literal|1
operator|)
operator|<<
name|FRACBITS
operator|)
operator|-
operator|(
name|fractype
operator|)
literal|1
operator|)
expr_stmt|;
name|exp
operator|=
operator|(
call|(
name|int
call|)
argument_list|(
name|src
operator|->
name|value_raw
operator|>>
name|FRACBITS
argument_list|)
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
name|EXPBITS
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|sign
operator|=
operator|(
call|(
name|int
call|)
argument_list|(
name|src
operator|->
name|value_raw
operator|>>
operator|(
name|FRACBITS
operator|+
name|EXPBITS
operator|)
argument_list|)
operator|)
operator|&
literal|1
expr_stmt|;
endif|#
directive|endif
name|dst
operator|->
name|sign
operator|=
name|sign
expr_stmt|;
if|if
condition|(
name|exp
operator|==
literal|0
condition|)
block|{
comment|/* Hmm.  Looks like 0 */
if|if
condition|(
name|fraction
operator|==
literal|0
ifdef|#
directive|ifdef
name|NO_DENORMALS
operator|||
literal|1
endif|#
directive|endif
condition|)
block|{
comment|/* tastes like zero */
name|dst
operator|->
name|class
operator|=
name|CLASS_ZERO
expr_stmt|;
block|}
else|else
block|{
comment|/* Zero exponent with non zero fraction - it's denormalized, 	     so there isn't a leading implicit one - we'll shift it so 	     it gets one.  */
name|dst
operator|->
name|normal_exp
operator|=
name|exp
operator|-
name|EXPBIAS
operator|+
literal|1
expr_stmt|;
name|fraction
operator|<<=
name|NGARDS
expr_stmt|;
name|dst
operator|->
name|class
operator|=
name|CLASS_NUMBER
expr_stmt|;
if|#
directive|if
literal|1
while|while
condition|(
name|fraction
operator|<
name|IMPLICIT_1
condition|)
block|{
name|fraction
operator|<<=
literal|1
expr_stmt|;
name|dst
operator|->
name|normal_exp
operator|--
expr_stmt|;
block|}
endif|#
directive|endif
name|dst
operator|->
name|fraction
operator|.
name|ll
operator|=
name|fraction
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|exp
operator|==
name|EXPMAX
condition|)
block|{
comment|/* Huge exponent*/
if|if
condition|(
name|fraction
operator|==
literal|0
condition|)
block|{
comment|/* Attached to a zero fraction - means infinity */
name|dst
operator|->
name|class
operator|=
name|CLASS_INFINITY
expr_stmt|;
block|}
else|else
block|{
comment|/* Non zero fraction, means nan */
if|if
condition|(
name|fraction
operator|&
name|QUIET_NAN
condition|)
block|{
name|dst
operator|->
name|class
operator|=
name|CLASS_QNAN
expr_stmt|;
block|}
else|else
block|{
name|dst
operator|->
name|class
operator|=
name|CLASS_SNAN
expr_stmt|;
block|}
comment|/* Keep the fraction part as the nan number */
name|dst
operator|->
name|fraction
operator|.
name|ll
operator|=
name|fraction
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Nothing strange about this number */
name|dst
operator|->
name|normal_exp
operator|=
name|exp
operator|-
name|EXPBIAS
expr_stmt|;
name|dst
operator|->
name|class
operator|=
name|CLASS_NUMBER
expr_stmt|;
name|dst
operator|->
name|fraction
operator|.
name|ll
operator|=
operator|(
name|fraction
operator|<<
name|NGARDS
operator|)
operator||
name|IMPLICIT_1
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* L_unpack_df || L_unpack_sf */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_addsub_sf
argument_list|)
operator|||
name|defined
argument_list|(
name|L_addsub_df
argument_list|)
end_if

begin_function
specifier|static
name|fp_number_type
modifier|*
name|_fpadd_parts
parameter_list|(
name|fp_number_type
modifier|*
name|a
parameter_list|,
name|fp_number_type
modifier|*
name|b
parameter_list|,
name|fp_number_type
modifier|*
name|tmp
parameter_list|)
block|{
name|intfrac
name|tfraction
decl_stmt|;
comment|/* Put commonly used fields in local variables.  */
name|int
name|a_normal_exp
decl_stmt|;
name|int
name|b_normal_exp
decl_stmt|;
name|fractype
name|a_fraction
decl_stmt|;
name|fractype
name|b_fraction
decl_stmt|;
if|if
condition|(
name|isnan
argument_list|(
name|a
argument_list|)
condition|)
block|{
return|return
name|a
return|;
block|}
if|if
condition|(
name|isnan
argument_list|(
name|b
argument_list|)
condition|)
block|{
return|return
name|b
return|;
block|}
if|if
condition|(
name|isinf
argument_list|(
name|a
argument_list|)
condition|)
block|{
comment|/* Adding infinities with opposite signs yields a NaN.  */
if|if
condition|(
name|isinf
argument_list|(
name|b
argument_list|)
operator|&&
name|a
operator|->
name|sign
operator|!=
name|b
operator|->
name|sign
condition|)
return|return
name|nan
argument_list|()
return|;
return|return
name|a
return|;
block|}
if|if
condition|(
name|isinf
argument_list|(
name|b
argument_list|)
condition|)
block|{
return|return
name|b
return|;
block|}
if|if
condition|(
name|iszero
argument_list|(
name|b
argument_list|)
condition|)
block|{
if|if
condition|(
name|iszero
argument_list|(
name|a
argument_list|)
condition|)
block|{
operator|*
name|tmp
operator|=
operator|*
name|a
expr_stmt|;
name|tmp
operator|->
name|sign
operator|=
name|a
operator|->
name|sign
operator|&
name|b
operator|->
name|sign
expr_stmt|;
return|return
name|tmp
return|;
block|}
return|return
name|a
return|;
block|}
if|if
condition|(
name|iszero
argument_list|(
name|a
argument_list|)
condition|)
block|{
return|return
name|b
return|;
block|}
comment|/* Got two numbers. shift the smaller and increment the exponent till      they're the same */
block|{
name|int
name|diff
decl_stmt|;
name|a_normal_exp
operator|=
name|a
operator|->
name|normal_exp
expr_stmt|;
name|b_normal_exp
operator|=
name|b
operator|->
name|normal_exp
expr_stmt|;
name|a_fraction
operator|=
name|a
operator|->
name|fraction
operator|.
name|ll
expr_stmt|;
name|b_fraction
operator|=
name|b
operator|->
name|fraction
operator|.
name|ll
expr_stmt|;
name|diff
operator|=
name|a_normal_exp
operator|-
name|b_normal_exp
expr_stmt|;
if|if
condition|(
name|diff
operator|<
literal|0
condition|)
name|diff
operator|=
operator|-
name|diff
expr_stmt|;
if|if
condition|(
name|diff
operator|<
name|FRAC_NBITS
condition|)
block|{
comment|/* ??? This does shifts one bit at a time.  Optimize.  */
while|while
condition|(
name|a_normal_exp
operator|>
name|b_normal_exp
condition|)
block|{
name|b_normal_exp
operator|++
expr_stmt|;
name|LSHIFT
argument_list|(
name|b_fraction
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|b_normal_exp
operator|>
name|a_normal_exp
condition|)
block|{
name|a_normal_exp
operator|++
expr_stmt|;
name|LSHIFT
argument_list|(
name|a_fraction
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Somethings's up.. choose the biggest */
if|if
condition|(
name|a_normal_exp
operator|>
name|b_normal_exp
condition|)
block|{
name|b_normal_exp
operator|=
name|a_normal_exp
expr_stmt|;
name|b_fraction
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|a_normal_exp
operator|=
name|b_normal_exp
expr_stmt|;
name|a_fraction
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|a
operator|->
name|sign
operator|!=
name|b
operator|->
name|sign
condition|)
block|{
if|if
condition|(
name|a
operator|->
name|sign
condition|)
block|{
name|tfraction
operator|=
operator|-
name|a_fraction
operator|+
name|b_fraction
expr_stmt|;
block|}
else|else
block|{
name|tfraction
operator|=
name|a_fraction
operator|-
name|b_fraction
expr_stmt|;
block|}
if|if
condition|(
name|tfraction
operator|>=
literal|0
condition|)
block|{
name|tmp
operator|->
name|sign
operator|=
literal|0
expr_stmt|;
name|tmp
operator|->
name|normal_exp
operator|=
name|a_normal_exp
expr_stmt|;
name|tmp
operator|->
name|fraction
operator|.
name|ll
operator|=
name|tfraction
expr_stmt|;
block|}
else|else
block|{
name|tmp
operator|->
name|sign
operator|=
literal|1
expr_stmt|;
name|tmp
operator|->
name|normal_exp
operator|=
name|a_normal_exp
expr_stmt|;
name|tmp
operator|->
name|fraction
operator|.
name|ll
operator|=
operator|-
name|tfraction
expr_stmt|;
block|}
comment|/* and renormalize it */
while|while
condition|(
name|tmp
operator|->
name|fraction
operator|.
name|ll
operator|<
name|IMPLICIT_1
operator|&&
name|tmp
operator|->
name|fraction
operator|.
name|ll
condition|)
block|{
name|tmp
operator|->
name|fraction
operator|.
name|ll
operator|<<=
literal|1
expr_stmt|;
name|tmp
operator|->
name|normal_exp
operator|--
expr_stmt|;
block|}
block|}
else|else
block|{
name|tmp
operator|->
name|sign
operator|=
name|a
operator|->
name|sign
expr_stmt|;
name|tmp
operator|->
name|normal_exp
operator|=
name|a_normal_exp
expr_stmt|;
name|tmp
operator|->
name|fraction
operator|.
name|ll
operator|=
name|a_fraction
operator|+
name|b_fraction
expr_stmt|;
block|}
name|tmp
operator|->
name|class
operator|=
name|CLASS_NUMBER
expr_stmt|;
comment|/* Now the fraction is added, we have to shift down to renormalize the      number */
if|if
condition|(
name|tmp
operator|->
name|fraction
operator|.
name|ll
operator|>=
name|IMPLICIT_2
condition|)
block|{
name|LSHIFT
argument_list|(
name|tmp
operator|->
name|fraction
operator|.
name|ll
argument_list|)
expr_stmt|;
name|tmp
operator|->
name|normal_exp
operator|++
expr_stmt|;
block|}
return|return
name|tmp
return|;
block|}
end_function

begin_function
name|FLO_type
name|add
parameter_list|(
name|FLO_type
name|arg_a
parameter_list|,
name|FLO_type
name|arg_b
parameter_list|)
block|{
name|fp_number_type
name|a
decl_stmt|;
name|fp_number_type
name|b
decl_stmt|;
name|fp_number_type
name|tmp
decl_stmt|;
name|fp_number_type
modifier|*
name|res
decl_stmt|;
name|FLO_union_type
name|au
decl_stmt|,
name|bu
decl_stmt|;
name|au
operator|.
name|value
operator|=
name|arg_a
expr_stmt|;
name|bu
operator|.
name|value
operator|=
name|arg_b
expr_stmt|;
name|unpack_d
argument_list|(
operator|&
name|au
argument_list|,
operator|&
name|a
argument_list|)
expr_stmt|;
name|unpack_d
argument_list|(
operator|&
name|bu
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
name|res
operator|=
name|_fpadd_parts
argument_list|(
operator|&
name|a
argument_list|,
operator|&
name|b
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
return|return
name|pack_d
argument_list|(
name|res
argument_list|)
return|;
block|}
end_function

begin_function
name|FLO_type
name|sub
parameter_list|(
name|FLO_type
name|arg_a
parameter_list|,
name|FLO_type
name|arg_b
parameter_list|)
block|{
name|fp_number_type
name|a
decl_stmt|;
name|fp_number_type
name|b
decl_stmt|;
name|fp_number_type
name|tmp
decl_stmt|;
name|fp_number_type
modifier|*
name|res
decl_stmt|;
name|FLO_union_type
name|au
decl_stmt|,
name|bu
decl_stmt|;
name|au
operator|.
name|value
operator|=
name|arg_a
expr_stmt|;
name|bu
operator|.
name|value
operator|=
name|arg_b
expr_stmt|;
name|unpack_d
argument_list|(
operator|&
name|au
argument_list|,
operator|&
name|a
argument_list|)
expr_stmt|;
name|unpack_d
argument_list|(
operator|&
name|bu
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
name|b
operator|.
name|sign
operator|^=
literal|1
expr_stmt|;
name|res
operator|=
name|_fpadd_parts
argument_list|(
operator|&
name|a
argument_list|,
operator|&
name|b
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
return|return
name|pack_d
argument_list|(
name|res
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* L_addsub_sf || L_addsub_df */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_mul_sf
argument_list|)
operator|||
name|defined
argument_list|(
name|L_mul_df
argument_list|)
end_if

begin_function
specifier|static
name|INLINE
name|fp_number_type
modifier|*
name|_fpmul_parts
parameter_list|(
name|fp_number_type
modifier|*
name|a
parameter_list|,
name|fp_number_type
modifier|*
name|b
parameter_list|,
name|fp_number_type
modifier|*
name|tmp
parameter_list|)
block|{
name|fractype
name|low
init|=
literal|0
decl_stmt|;
name|fractype
name|high
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|isnan
argument_list|(
name|a
argument_list|)
condition|)
block|{
name|a
operator|->
name|sign
operator|=
name|a
operator|->
name|sign
operator|!=
name|b
operator|->
name|sign
expr_stmt|;
return|return
name|a
return|;
block|}
if|if
condition|(
name|isnan
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|b
operator|->
name|sign
operator|=
name|a
operator|->
name|sign
operator|!=
name|b
operator|->
name|sign
expr_stmt|;
return|return
name|b
return|;
block|}
if|if
condition|(
name|isinf
argument_list|(
name|a
argument_list|)
condition|)
block|{
if|if
condition|(
name|iszero
argument_list|(
name|b
argument_list|)
condition|)
return|return
name|nan
argument_list|()
return|;
name|a
operator|->
name|sign
operator|=
name|a
operator|->
name|sign
operator|!=
name|b
operator|->
name|sign
expr_stmt|;
return|return
name|a
return|;
block|}
if|if
condition|(
name|isinf
argument_list|(
name|b
argument_list|)
condition|)
block|{
if|if
condition|(
name|iszero
argument_list|(
name|a
argument_list|)
condition|)
block|{
return|return
name|nan
argument_list|()
return|;
block|}
name|b
operator|->
name|sign
operator|=
name|a
operator|->
name|sign
operator|!=
name|b
operator|->
name|sign
expr_stmt|;
return|return
name|b
return|;
block|}
if|if
condition|(
name|iszero
argument_list|(
name|a
argument_list|)
condition|)
block|{
name|a
operator|->
name|sign
operator|=
name|a
operator|->
name|sign
operator|!=
name|b
operator|->
name|sign
expr_stmt|;
return|return
name|a
return|;
block|}
if|if
condition|(
name|iszero
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|b
operator|->
name|sign
operator|=
name|a
operator|->
name|sign
operator|!=
name|b
operator|->
name|sign
expr_stmt|;
return|return
name|b
return|;
block|}
comment|/* Calculate the mantissa by multiplying both numbers to get a      twice-as-wide number.  */
block|{
if|#
directive|if
name|defined
argument_list|(
name|NO_DI_MODE
argument_list|)
block|{
name|fractype
name|x
init|=
name|a
operator|->
name|fraction
operator|.
name|ll
decl_stmt|;
name|fractype
name|ylow
init|=
name|b
operator|->
name|fraction
operator|.
name|ll
decl_stmt|;
name|fractype
name|yhigh
init|=
literal|0
decl_stmt|;
name|int
name|bit
decl_stmt|;
comment|/* ??? This does multiplies one bit at a time.  Optimize.  */
for|for
control|(
name|bit
operator|=
literal|0
init|;
name|bit
operator|<
name|FRAC_NBITS
condition|;
name|bit
operator|++
control|)
block|{
name|int
name|carry
decl_stmt|;
if|if
condition|(
name|x
operator|&
literal|1
condition|)
block|{
name|carry
operator|=
operator|(
name|low
operator|+=
name|ylow
operator|)
operator|<
name|ylow
expr_stmt|;
name|high
operator|+=
name|yhigh
operator|+
name|carry
expr_stmt|;
block|}
name|yhigh
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|ylow
operator|&
name|FRACHIGH
condition|)
block|{
name|yhigh
operator||=
literal|1
expr_stmt|;
block|}
name|ylow
operator|<<=
literal|1
expr_stmt|;
name|x
operator|>>=
literal|1
expr_stmt|;
block|}
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|FLOAT
argument_list|)
comment|/* Multiplying two USIs to get a UDI, we're safe.  */
block|{
name|UDItype
name|answer
init|=
operator|(
name|UDItype
operator|)
name|a
operator|->
name|fraction
operator|.
name|ll
operator|*
operator|(
name|UDItype
operator|)
name|b
operator|->
name|fraction
operator|.
name|ll
decl_stmt|;
name|high
operator|=
name|answer
operator|>>
name|BITS_PER_SI
expr_stmt|;
name|low
operator|=
name|answer
expr_stmt|;
block|}
else|#
directive|else
comment|/* fractype is DImode, but we need the result to be twice as wide.        Assuming a widening multiply from DImode to TImode is not        available, build one by hand.  */
block|{
name|USItype
name|nl
init|=
name|a
operator|->
name|fraction
operator|.
name|ll
decl_stmt|;
name|USItype
name|nh
init|=
name|a
operator|->
name|fraction
operator|.
name|ll
operator|>>
name|BITS_PER_SI
decl_stmt|;
name|USItype
name|ml
init|=
name|b
operator|->
name|fraction
operator|.
name|ll
decl_stmt|;
name|USItype
name|mh
init|=
name|b
operator|->
name|fraction
operator|.
name|ll
operator|>>
name|BITS_PER_SI
decl_stmt|;
name|UDItype
name|pp_ll
init|=
operator|(
name|UDItype
operator|)
name|ml
operator|*
name|nl
decl_stmt|;
name|UDItype
name|pp_hl
init|=
operator|(
name|UDItype
operator|)
name|mh
operator|*
name|nl
decl_stmt|;
name|UDItype
name|pp_lh
init|=
operator|(
name|UDItype
operator|)
name|ml
operator|*
name|nh
decl_stmt|;
name|UDItype
name|pp_hh
init|=
operator|(
name|UDItype
operator|)
name|mh
operator|*
name|nh
decl_stmt|;
name|UDItype
name|res2
init|=
literal|0
decl_stmt|;
name|UDItype
name|res0
init|=
literal|0
decl_stmt|;
name|UDItype
name|ps_hh__
init|=
name|pp_hl
operator|+
name|pp_lh
decl_stmt|;
if|if
condition|(
name|ps_hh__
operator|<
name|pp_hl
condition|)
name|res2
operator|+=
operator|(
name|UDItype
operator|)
literal|1
operator|<<
name|BITS_PER_SI
expr_stmt|;
name|pp_hl
operator|=
operator|(
name|UDItype
operator|)
operator|(
name|USItype
operator|)
name|ps_hh__
operator|<<
name|BITS_PER_SI
expr_stmt|;
name|res0
operator|=
name|pp_ll
operator|+
name|pp_hl
expr_stmt|;
if|if
condition|(
name|res0
operator|<
name|pp_ll
condition|)
name|res2
operator|++
expr_stmt|;
name|res2
operator|+=
operator|(
name|ps_hh__
operator|>>
name|BITS_PER_SI
operator|)
operator|+
name|pp_hh
expr_stmt|;
name|high
operator|=
name|res2
expr_stmt|;
name|low
operator|=
name|res0
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|tmp
operator|->
name|normal_exp
operator|=
name|a
operator|->
name|normal_exp
operator|+
name|b
operator|->
name|normal_exp
expr_stmt|;
name|tmp
operator|->
name|sign
operator|=
name|a
operator|->
name|sign
operator|!=
name|b
operator|->
name|sign
expr_stmt|;
ifdef|#
directive|ifdef
name|FLOAT
name|tmp
operator|->
name|normal_exp
operator|+=
literal|2
expr_stmt|;
comment|/* ??????????????? */
else|#
directive|else
name|tmp
operator|->
name|normal_exp
operator|+=
literal|4
expr_stmt|;
comment|/* ??????????????? */
endif|#
directive|endif
while|while
condition|(
name|high
operator|>=
name|IMPLICIT_2
condition|)
block|{
name|tmp
operator|->
name|normal_exp
operator|++
expr_stmt|;
if|if
condition|(
name|high
operator|&
literal|1
condition|)
block|{
name|low
operator|>>=
literal|1
expr_stmt|;
name|low
operator||=
name|FRACHIGH
expr_stmt|;
block|}
name|high
operator|>>=
literal|1
expr_stmt|;
block|}
while|while
condition|(
name|high
operator|<
name|IMPLICIT_1
condition|)
block|{
name|tmp
operator|->
name|normal_exp
operator|--
expr_stmt|;
name|high
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|low
operator|&
name|FRACHIGH
condition|)
name|high
operator||=
literal|1
expr_stmt|;
name|low
operator|<<=
literal|1
expr_stmt|;
block|}
comment|/* rounding is tricky. if we only round if it won't make us round later. */
if|#
directive|if
literal|0
block|if (low& FRACHIGH2)     {       if (((high& GARDMASK) != GARDMSB)&& (((high + 1)& GARDMASK) == GARDMSB)) 	{
comment|/* don't round, it gets done again later. */
block|}       else 	{ 	  high++; 	}     }
endif|#
directive|endif
if|if
condition|(
operator|(
name|high
operator|&
name|GARDMASK
operator|)
operator|==
name|GARDMSB
condition|)
block|{
if|if
condition|(
name|high
operator|&
operator|(
literal|1
operator|<<
name|NGARDS
operator|)
condition|)
block|{
comment|/* half way, so round to even */
name|high
operator|+=
name|GARDROUND
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|low
condition|)
block|{
comment|/* but we really weren't half way */
name|high
operator|+=
name|GARDROUND
operator|+
literal|1
expr_stmt|;
block|}
block|}
name|tmp
operator|->
name|fraction
operator|.
name|ll
operator|=
name|high
expr_stmt|;
name|tmp
operator|->
name|class
operator|=
name|CLASS_NUMBER
expr_stmt|;
return|return
name|tmp
return|;
block|}
end_function

begin_function
name|FLO_type
name|multiply
parameter_list|(
name|FLO_type
name|arg_a
parameter_list|,
name|FLO_type
name|arg_b
parameter_list|)
block|{
name|fp_number_type
name|a
decl_stmt|;
name|fp_number_type
name|b
decl_stmt|;
name|fp_number_type
name|tmp
decl_stmt|;
name|fp_number_type
modifier|*
name|res
decl_stmt|;
name|FLO_union_type
name|au
decl_stmt|,
name|bu
decl_stmt|;
name|au
operator|.
name|value
operator|=
name|arg_a
expr_stmt|;
name|bu
operator|.
name|value
operator|=
name|arg_b
expr_stmt|;
name|unpack_d
argument_list|(
operator|&
name|au
argument_list|,
operator|&
name|a
argument_list|)
expr_stmt|;
name|unpack_d
argument_list|(
operator|&
name|bu
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
name|res
operator|=
name|_fpmul_parts
argument_list|(
operator|&
name|a
argument_list|,
operator|&
name|b
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
return|return
name|pack_d
argument_list|(
name|res
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* L_mul_sf || L_mul_df */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_div_sf
argument_list|)
operator|||
name|defined
argument_list|(
name|L_div_df
argument_list|)
end_if

begin_function
specifier|static
name|INLINE
name|fp_number_type
modifier|*
name|_fpdiv_parts
parameter_list|(
name|fp_number_type
modifier|*
name|a
parameter_list|,
name|fp_number_type
modifier|*
name|b
parameter_list|)
block|{
name|fractype
name|bit
decl_stmt|;
name|fractype
name|numerator
decl_stmt|;
name|fractype
name|denominator
decl_stmt|;
name|fractype
name|quotient
decl_stmt|;
if|if
condition|(
name|isnan
argument_list|(
name|a
argument_list|)
condition|)
block|{
return|return
name|a
return|;
block|}
if|if
condition|(
name|isnan
argument_list|(
name|b
argument_list|)
condition|)
block|{
return|return
name|b
return|;
block|}
name|a
operator|->
name|sign
operator|=
name|a
operator|->
name|sign
operator|^
name|b
operator|->
name|sign
expr_stmt|;
if|if
condition|(
name|isinf
argument_list|(
name|a
argument_list|)
operator|||
name|iszero
argument_list|(
name|a
argument_list|)
condition|)
block|{
if|if
condition|(
name|a
operator|->
name|class
operator|==
name|b
operator|->
name|class
condition|)
return|return
name|nan
argument_list|()
return|;
return|return
name|a
return|;
block|}
if|if
condition|(
name|isinf
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|a
operator|->
name|fraction
operator|.
name|ll
operator|=
literal|0
expr_stmt|;
name|a
operator|->
name|normal_exp
operator|=
literal|0
expr_stmt|;
return|return
name|a
return|;
block|}
if|if
condition|(
name|iszero
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|a
operator|->
name|class
operator|=
name|CLASS_INFINITY
expr_stmt|;
return|return
name|a
return|;
block|}
comment|/* Calculate the mantissa by multiplying both 64bit numbers to get a      128 bit number */
block|{
comment|/* quotient =        ( numerator / denominator) * 2^(numerator exponent -  denominator exponent)      */
name|a
operator|->
name|normal_exp
operator|=
name|a
operator|->
name|normal_exp
operator|-
name|b
operator|->
name|normal_exp
expr_stmt|;
name|numerator
operator|=
name|a
operator|->
name|fraction
operator|.
name|ll
expr_stmt|;
name|denominator
operator|=
name|b
operator|->
name|fraction
operator|.
name|ll
expr_stmt|;
if|if
condition|(
name|numerator
operator|<
name|denominator
condition|)
block|{
comment|/* Fraction will be less than 1.0 */
name|numerator
operator|*=
literal|2
expr_stmt|;
name|a
operator|->
name|normal_exp
operator|--
expr_stmt|;
block|}
name|bit
operator|=
name|IMPLICIT_1
expr_stmt|;
name|quotient
operator|=
literal|0
expr_stmt|;
comment|/* ??? Does divide one bit at a time.  Optimize.  */
while|while
condition|(
name|bit
condition|)
block|{
if|if
condition|(
name|numerator
operator|>=
name|denominator
condition|)
block|{
name|quotient
operator||=
name|bit
expr_stmt|;
name|numerator
operator|-=
name|denominator
expr_stmt|;
block|}
name|bit
operator|>>=
literal|1
expr_stmt|;
name|numerator
operator|*=
literal|2
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|quotient
operator|&
name|GARDMASK
operator|)
operator|==
name|GARDMSB
condition|)
block|{
if|if
condition|(
name|quotient
operator|&
operator|(
literal|1
operator|<<
name|NGARDS
operator|)
condition|)
block|{
comment|/* half way, so round to even */
name|quotient
operator|+=
name|GARDROUND
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|numerator
condition|)
block|{
comment|/* but we really weren't half way, more bits exist */
name|quotient
operator|+=
name|GARDROUND
operator|+
literal|1
expr_stmt|;
block|}
block|}
name|a
operator|->
name|fraction
operator|.
name|ll
operator|=
name|quotient
expr_stmt|;
return|return
operator|(
name|a
operator|)
return|;
block|}
block|}
end_function

begin_function
name|FLO_type
name|divide
parameter_list|(
name|FLO_type
name|arg_a
parameter_list|,
name|FLO_type
name|arg_b
parameter_list|)
block|{
name|fp_number_type
name|a
decl_stmt|;
name|fp_number_type
name|b
decl_stmt|;
name|fp_number_type
modifier|*
name|res
decl_stmt|;
name|FLO_union_type
name|au
decl_stmt|,
name|bu
decl_stmt|;
name|au
operator|.
name|value
operator|=
name|arg_a
expr_stmt|;
name|bu
operator|.
name|value
operator|=
name|arg_b
expr_stmt|;
name|unpack_d
argument_list|(
operator|&
name|au
argument_list|,
operator|&
name|a
argument_list|)
expr_stmt|;
name|unpack_d
argument_list|(
operator|&
name|bu
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
name|res
operator|=
name|_fpdiv_parts
argument_list|(
operator|&
name|a
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
return|return
name|pack_d
argument_list|(
name|res
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* L_div_sf || L_div_df */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_fpcmp_parts_sf
argument_list|)
operator|||
name|defined
argument_list|(
name|L_fpcmp_parts_df
argument_list|)
end_if

begin_comment
comment|/* according to the demo, fpcmp returns a comparison with 0... thus    a<b -> -1    a==b -> 0    a>b -> +1  */
end_comment

begin_function
name|int
name|__fpcmp_parts
parameter_list|(
name|fp_number_type
modifier|*
name|a
parameter_list|,
name|fp_number_type
modifier|*
name|b
parameter_list|)
block|{
if|#
directive|if
literal|0
comment|/* either nan -> unordered. Must be checked outside of this routine. */
block|if (isnan (a)&& isnan (b))     {       return 1;
comment|/* still unordered! */
block|}
endif|#
directive|endif
if|if
condition|(
name|isnan
argument_list|(
name|a
argument_list|)
operator|||
name|isnan
argument_list|(
name|b
argument_list|)
condition|)
block|{
return|return
literal|1
return|;
comment|/* how to indicate unordered compare? */
block|}
if|if
condition|(
name|isinf
argument_list|(
name|a
argument_list|)
operator|&&
name|isinf
argument_list|(
name|b
argument_list|)
condition|)
block|{
comment|/* +inf> -inf, but +inf != +inf */
comment|/* b    \a| +inf(0)| -inf(1)        ______\+--------+--------        +inf(0)| a==b(0)| a<b(-1)        -------+--------+--------        -inf(1)| a>b(1) | a==b(0)        -------+--------+--------        So since unordered must be non zero, just line up the columns...        */
return|return
name|b
operator|->
name|sign
operator|-
name|a
operator|->
name|sign
return|;
block|}
comment|/* but not both... */
if|if
condition|(
name|isinf
argument_list|(
name|a
argument_list|)
condition|)
block|{
return|return
name|a
operator|->
name|sign
condition|?
operator|-
literal|1
else|:
literal|1
return|;
block|}
if|if
condition|(
name|isinf
argument_list|(
name|b
argument_list|)
condition|)
block|{
return|return
name|b
operator|->
name|sign
condition|?
literal|1
else|:
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|iszero
argument_list|(
name|a
argument_list|)
operator|&&
name|iszero
argument_list|(
name|b
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
name|iszero
argument_list|(
name|a
argument_list|)
condition|)
block|{
return|return
name|b
operator|->
name|sign
condition|?
literal|1
else|:
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|iszero
argument_list|(
name|b
argument_list|)
condition|)
block|{
return|return
name|a
operator|->
name|sign
condition|?
operator|-
literal|1
else|:
literal|1
return|;
block|}
comment|/* now both are "normal". */
if|if
condition|(
name|a
operator|->
name|sign
operator|!=
name|b
operator|->
name|sign
condition|)
block|{
comment|/* opposite signs */
return|return
name|a
operator|->
name|sign
condition|?
operator|-
literal|1
else|:
literal|1
return|;
block|}
comment|/* same sign; exponents? */
if|if
condition|(
name|a
operator|->
name|normal_exp
operator|>
name|b
operator|->
name|normal_exp
condition|)
block|{
return|return
name|a
operator|->
name|sign
condition|?
operator|-
literal|1
else|:
literal|1
return|;
block|}
if|if
condition|(
name|a
operator|->
name|normal_exp
operator|<
name|b
operator|->
name|normal_exp
condition|)
block|{
return|return
name|a
operator|->
name|sign
condition|?
literal|1
else|:
operator|-
literal|1
return|;
block|}
comment|/* same exponents; check size. */
if|if
condition|(
name|a
operator|->
name|fraction
operator|.
name|ll
operator|>
name|b
operator|->
name|fraction
operator|.
name|ll
condition|)
block|{
return|return
name|a
operator|->
name|sign
condition|?
operator|-
literal|1
else|:
literal|1
return|;
block|}
if|if
condition|(
name|a
operator|->
name|fraction
operator|.
name|ll
operator|<
name|b
operator|->
name|fraction
operator|.
name|ll
condition|)
block|{
return|return
name|a
operator|->
name|sign
condition|?
literal|1
else|:
operator|-
literal|1
return|;
block|}
comment|/* after all that, they're equal. */
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_compare_sf
argument_list|)
operator|||
name|defined
argument_list|(
name|L_compare_df
argument_list|)
end_if

begin_function
name|CMPtype
name|compare
parameter_list|(
name|FLO_type
name|arg_a
parameter_list|,
name|FLO_type
name|arg_b
parameter_list|)
block|{
name|fp_number_type
name|a
decl_stmt|;
name|fp_number_type
name|b
decl_stmt|;
name|FLO_union_type
name|au
decl_stmt|,
name|bu
decl_stmt|;
name|au
operator|.
name|value
operator|=
name|arg_a
expr_stmt|;
name|bu
operator|.
name|value
operator|=
name|arg_b
expr_stmt|;
name|unpack_d
argument_list|(
operator|&
name|au
argument_list|,
operator|&
name|a
argument_list|)
expr_stmt|;
name|unpack_d
argument_list|(
operator|&
name|bu
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
return|return
name|__fpcmp_parts
argument_list|(
operator|&
name|a
argument_list|,
operator|&
name|b
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* L_compare_sf || L_compare_df */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|US_SOFTWARE_GOFAST
end_ifndef

begin_comment
comment|/* These should be optimized for their specific tasks someday.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_eq_sf
argument_list|)
operator|||
name|defined
argument_list|(
name|L_eq_df
argument_list|)
end_if

begin_function
name|CMPtype
name|_eq_f2
parameter_list|(
name|FLO_type
name|arg_a
parameter_list|,
name|FLO_type
name|arg_b
parameter_list|)
block|{
name|fp_number_type
name|a
decl_stmt|;
name|fp_number_type
name|b
decl_stmt|;
name|FLO_union_type
name|au
decl_stmt|,
name|bu
decl_stmt|;
name|au
operator|.
name|value
operator|=
name|arg_a
expr_stmt|;
name|bu
operator|.
name|value
operator|=
name|arg_b
expr_stmt|;
name|unpack_d
argument_list|(
operator|&
name|au
argument_list|,
operator|&
name|a
argument_list|)
expr_stmt|;
name|unpack_d
argument_list|(
operator|&
name|bu
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|isnan
argument_list|(
operator|&
name|a
argument_list|)
operator|||
name|isnan
argument_list|(
operator|&
name|b
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* false, truth == 0 */
return|return
name|__fpcmp_parts
argument_list|(
operator|&
name|a
argument_list|,
operator|&
name|b
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* L_eq_sf || L_eq_df */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_ne_sf
argument_list|)
operator|||
name|defined
argument_list|(
name|L_ne_df
argument_list|)
end_if

begin_function
name|CMPtype
name|_ne_f2
parameter_list|(
name|FLO_type
name|arg_a
parameter_list|,
name|FLO_type
name|arg_b
parameter_list|)
block|{
name|fp_number_type
name|a
decl_stmt|;
name|fp_number_type
name|b
decl_stmt|;
name|FLO_union_type
name|au
decl_stmt|,
name|bu
decl_stmt|;
name|au
operator|.
name|value
operator|=
name|arg_a
expr_stmt|;
name|bu
operator|.
name|value
operator|=
name|arg_b
expr_stmt|;
name|unpack_d
argument_list|(
operator|&
name|au
argument_list|,
operator|&
name|a
argument_list|)
expr_stmt|;
name|unpack_d
argument_list|(
operator|&
name|bu
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|isnan
argument_list|(
operator|&
name|a
argument_list|)
operator|||
name|isnan
argument_list|(
operator|&
name|b
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* true, truth != 0 */
return|return
name|__fpcmp_parts
argument_list|(
operator|&
name|a
argument_list|,
operator|&
name|b
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* L_ne_sf || L_ne_df */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_gt_sf
argument_list|)
operator|||
name|defined
argument_list|(
name|L_gt_df
argument_list|)
end_if

begin_function
name|CMPtype
name|_gt_f2
parameter_list|(
name|FLO_type
name|arg_a
parameter_list|,
name|FLO_type
name|arg_b
parameter_list|)
block|{
name|fp_number_type
name|a
decl_stmt|;
name|fp_number_type
name|b
decl_stmt|;
name|FLO_union_type
name|au
decl_stmt|,
name|bu
decl_stmt|;
name|au
operator|.
name|value
operator|=
name|arg_a
expr_stmt|;
name|bu
operator|.
name|value
operator|=
name|arg_b
expr_stmt|;
name|unpack_d
argument_list|(
operator|&
name|au
argument_list|,
operator|&
name|a
argument_list|)
expr_stmt|;
name|unpack_d
argument_list|(
operator|&
name|bu
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|isnan
argument_list|(
operator|&
name|a
argument_list|)
operator|||
name|isnan
argument_list|(
operator|&
name|b
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* false, truth> 0 */
return|return
name|__fpcmp_parts
argument_list|(
operator|&
name|a
argument_list|,
operator|&
name|b
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* L_gt_sf || L_gt_df */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_ge_sf
argument_list|)
operator|||
name|defined
argument_list|(
name|L_ge_df
argument_list|)
end_if

begin_function
name|CMPtype
name|_ge_f2
parameter_list|(
name|FLO_type
name|arg_a
parameter_list|,
name|FLO_type
name|arg_b
parameter_list|)
block|{
name|fp_number_type
name|a
decl_stmt|;
name|fp_number_type
name|b
decl_stmt|;
name|FLO_union_type
name|au
decl_stmt|,
name|bu
decl_stmt|;
name|au
operator|.
name|value
operator|=
name|arg_a
expr_stmt|;
name|bu
operator|.
name|value
operator|=
name|arg_b
expr_stmt|;
name|unpack_d
argument_list|(
operator|&
name|au
argument_list|,
operator|&
name|a
argument_list|)
expr_stmt|;
name|unpack_d
argument_list|(
operator|&
name|bu
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|isnan
argument_list|(
operator|&
name|a
argument_list|)
operator|||
name|isnan
argument_list|(
operator|&
name|b
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* false, truth>= 0 */
return|return
name|__fpcmp_parts
argument_list|(
operator|&
name|a
argument_list|,
operator|&
name|b
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* L_ge_sf || L_ge_df */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_lt_sf
argument_list|)
operator|||
name|defined
argument_list|(
name|L_lt_df
argument_list|)
end_if

begin_function
name|CMPtype
name|_lt_f2
parameter_list|(
name|FLO_type
name|arg_a
parameter_list|,
name|FLO_type
name|arg_b
parameter_list|)
block|{
name|fp_number_type
name|a
decl_stmt|;
name|fp_number_type
name|b
decl_stmt|;
name|FLO_union_type
name|au
decl_stmt|,
name|bu
decl_stmt|;
name|au
operator|.
name|value
operator|=
name|arg_a
expr_stmt|;
name|bu
operator|.
name|value
operator|=
name|arg_b
expr_stmt|;
name|unpack_d
argument_list|(
operator|&
name|au
argument_list|,
operator|&
name|a
argument_list|)
expr_stmt|;
name|unpack_d
argument_list|(
operator|&
name|bu
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|isnan
argument_list|(
operator|&
name|a
argument_list|)
operator|||
name|isnan
argument_list|(
operator|&
name|b
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* false, truth< 0 */
return|return
name|__fpcmp_parts
argument_list|(
operator|&
name|a
argument_list|,
operator|&
name|b
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* L_lt_sf || L_lt_df */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_le_sf
argument_list|)
operator|||
name|defined
argument_list|(
name|L_le_df
argument_list|)
end_if

begin_function
name|CMPtype
name|_le_f2
parameter_list|(
name|FLO_type
name|arg_a
parameter_list|,
name|FLO_type
name|arg_b
parameter_list|)
block|{
name|fp_number_type
name|a
decl_stmt|;
name|fp_number_type
name|b
decl_stmt|;
name|FLO_union_type
name|au
decl_stmt|,
name|bu
decl_stmt|;
name|au
operator|.
name|value
operator|=
name|arg_a
expr_stmt|;
name|bu
operator|.
name|value
operator|=
name|arg_b
expr_stmt|;
name|unpack_d
argument_list|(
operator|&
name|au
argument_list|,
operator|&
name|a
argument_list|)
expr_stmt|;
name|unpack_d
argument_list|(
operator|&
name|bu
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|isnan
argument_list|(
operator|&
name|a
argument_list|)
operator|||
name|isnan
argument_list|(
operator|&
name|b
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* false, truth<= 0 */
return|return
name|__fpcmp_parts
argument_list|(
operator|&
name|a
argument_list|,
operator|&
name|b
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* L_le_sf || L_le_df */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_unord_sf
argument_list|)
operator|||
name|defined
argument_list|(
name|L_unord_df
argument_list|)
end_if

begin_function
name|CMPtype
name|_unord_f2
parameter_list|(
name|FLO_type
name|arg_a
parameter_list|,
name|FLO_type
name|arg_b
parameter_list|)
block|{
name|fp_number_type
name|a
decl_stmt|;
name|fp_number_type
name|b
decl_stmt|;
name|FLO_union_type
name|au
decl_stmt|,
name|bu
decl_stmt|;
name|au
operator|.
name|value
operator|=
name|arg_a
expr_stmt|;
name|bu
operator|.
name|value
operator|=
name|arg_b
expr_stmt|;
name|unpack_d
argument_list|(
operator|&
name|au
argument_list|,
operator|&
name|a
argument_list|)
expr_stmt|;
name|unpack_d
argument_list|(
operator|&
name|bu
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
return|return
operator|(
name|isnan
argument_list|(
operator|&
name|a
argument_list|)
operator|||
name|isnan
argument_list|(
operator|&
name|b
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* L_unord_sf || L_unord_df */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! US_SOFTWARE_GOFAST */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_si_to_sf
argument_list|)
operator|||
name|defined
argument_list|(
name|L_si_to_df
argument_list|)
end_if

begin_function
name|FLO_type
name|si_to_float
parameter_list|(
name|SItype
name|arg_a
parameter_list|)
block|{
name|fp_number_type
name|in
decl_stmt|;
name|in
operator|.
name|class
operator|=
name|CLASS_NUMBER
expr_stmt|;
name|in
operator|.
name|sign
operator|=
name|arg_a
operator|<
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|arg_a
condition|)
block|{
name|in
operator|.
name|class
operator|=
name|CLASS_ZERO
expr_stmt|;
block|}
else|else
block|{
name|in
operator|.
name|normal_exp
operator|=
name|FRACBITS
operator|+
name|NGARDS
expr_stmt|;
if|if
condition|(
name|in
operator|.
name|sign
condition|)
block|{
comment|/* Special case for minint, since there is no +ve integer 	     representation for it */
if|if
condition|(
name|arg_a
operator|==
operator|(
operator|-
name|MAX_SI_INT
operator|-
literal|1
operator|)
condition|)
block|{
return|return
call|(
name|FLO_type
call|)
argument_list|(
operator|-
name|MAX_SI_INT
operator|-
literal|1
argument_list|)
return|;
block|}
name|in
operator|.
name|fraction
operator|.
name|ll
operator|=
operator|(
operator|-
name|arg_a
operator|)
expr_stmt|;
block|}
else|else
name|in
operator|.
name|fraction
operator|.
name|ll
operator|=
name|arg_a
expr_stmt|;
while|while
condition|(
name|in
operator|.
name|fraction
operator|.
name|ll
operator|<
operator|(
literal|1LL
operator|<<
operator|(
name|FRACBITS
operator|+
name|NGARDS
operator|)
operator|)
condition|)
block|{
name|in
operator|.
name|fraction
operator|.
name|ll
operator|<<=
literal|1
expr_stmt|;
name|in
operator|.
name|normal_exp
operator|-=
literal|1
expr_stmt|;
block|}
block|}
return|return
name|pack_d
argument_list|(
operator|&
name|in
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* L_si_to_sf || L_si_to_df */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_usi_to_sf
argument_list|)
operator|||
name|defined
argument_list|(
name|L_usi_to_df
argument_list|)
end_if

begin_function
name|FLO_type
name|usi_to_float
parameter_list|(
name|USItype
name|arg_a
parameter_list|)
block|{
name|fp_number_type
name|in
decl_stmt|;
name|in
operator|.
name|sign
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|arg_a
condition|)
block|{
name|in
operator|.
name|class
operator|=
name|CLASS_ZERO
expr_stmt|;
block|}
else|else
block|{
name|in
operator|.
name|class
operator|=
name|CLASS_NUMBER
expr_stmt|;
name|in
operator|.
name|normal_exp
operator|=
name|FRACBITS
operator|+
name|NGARDS
expr_stmt|;
name|in
operator|.
name|fraction
operator|.
name|ll
operator|=
name|arg_a
expr_stmt|;
while|while
condition|(
name|in
operator|.
name|fraction
operator|.
name|ll
operator|>
operator|(
literal|1LL
operator|<<
operator|(
name|FRACBITS
operator|+
name|NGARDS
operator|)
operator|)
condition|)
block|{
name|in
operator|.
name|fraction
operator|.
name|ll
operator|>>=
literal|1
expr_stmt|;
name|in
operator|.
name|normal_exp
operator|+=
literal|1
expr_stmt|;
block|}
while|while
condition|(
name|in
operator|.
name|fraction
operator|.
name|ll
operator|<
operator|(
literal|1LL
operator|<<
operator|(
name|FRACBITS
operator|+
name|NGARDS
operator|)
operator|)
condition|)
block|{
name|in
operator|.
name|fraction
operator|.
name|ll
operator|<<=
literal|1
expr_stmt|;
name|in
operator|.
name|normal_exp
operator|-=
literal|1
expr_stmt|;
block|}
block|}
return|return
name|pack_d
argument_list|(
operator|&
name|in
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_sf_to_si
argument_list|)
operator|||
name|defined
argument_list|(
name|L_df_to_si
argument_list|)
end_if

begin_function
name|SItype
name|float_to_si
parameter_list|(
name|FLO_type
name|arg_a
parameter_list|)
block|{
name|fp_number_type
name|a
decl_stmt|;
name|SItype
name|tmp
decl_stmt|;
name|FLO_union_type
name|au
decl_stmt|;
name|au
operator|.
name|value
operator|=
name|arg_a
expr_stmt|;
name|unpack_d
argument_list|(
operator|&
name|au
argument_list|,
operator|&
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|iszero
argument_list|(
operator|&
name|a
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|isnan
argument_list|(
operator|&
name|a
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* get reasonable MAX_SI_INT... */
if|if
condition|(
name|isinf
argument_list|(
operator|&
name|a
argument_list|)
condition|)
return|return
name|a
operator|.
name|sign
condition|?
operator|(
operator|-
name|MAX_SI_INT
operator|)
operator|-
literal|1
else|:
name|MAX_SI_INT
return|;
comment|/* it is a number, but a small one */
if|if
condition|(
name|a
operator|.
name|normal_exp
operator|<
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|a
operator|.
name|normal_exp
operator|>
name|BITS_PER_SI
operator|-
literal|2
condition|)
return|return
name|a
operator|.
name|sign
condition|?
operator|(
operator|-
name|MAX_SI_INT
operator|)
operator|-
literal|1
else|:
name|MAX_SI_INT
return|;
name|tmp
operator|=
name|a
operator|.
name|fraction
operator|.
name|ll
operator|>>
operator|(
operator|(
name|FRACBITS
operator|+
name|NGARDS
operator|)
operator|-
name|a
operator|.
name|normal_exp
operator|)
expr_stmt|;
return|return
name|a
operator|.
name|sign
condition|?
operator|(
operator|-
name|tmp
operator|)
else|:
operator|(
name|tmp
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* L_sf_to_si || L_df_to_si */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_sf_to_usi
argument_list|)
operator|||
name|defined
argument_list|(
name|L_df_to_usi
argument_list|)
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|US_SOFTWARE_GOFAST
end_ifdef

begin_comment
comment|/* While libgcc2.c defines its own __fixunssfsi and __fixunsdfsi routines,    we also define them for GOFAST because the ones in libgcc2.c have the    wrong names and I'd rather define these here and keep GOFAST CYG-LOC's    out of libgcc2.c.  We can't define these here if not GOFAST because then    there'd be duplicate copies.  */
end_comment

begin_function
name|USItype
name|float_to_usi
parameter_list|(
name|FLO_type
name|arg_a
parameter_list|)
block|{
name|fp_number_type
name|a
decl_stmt|;
name|FLO_union_type
name|au
decl_stmt|;
name|au
operator|.
name|value
operator|=
name|arg_a
expr_stmt|;
name|unpack_d
argument_list|(
operator|&
name|au
argument_list|,
operator|&
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|iszero
argument_list|(
operator|&
name|a
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|isnan
argument_list|(
operator|&
name|a
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* it is a negative number */
if|if
condition|(
name|a
operator|.
name|sign
condition|)
return|return
literal|0
return|;
comment|/* get reasonable MAX_USI_INT... */
if|if
condition|(
name|isinf
argument_list|(
operator|&
name|a
argument_list|)
condition|)
return|return
name|MAX_USI_INT
return|;
comment|/* it is a number, but a small one */
if|if
condition|(
name|a
operator|.
name|normal_exp
operator|<
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|a
operator|.
name|normal_exp
operator|>
name|BITS_PER_SI
operator|-
literal|1
condition|)
return|return
name|MAX_USI_INT
return|;
elseif|else
if|if
condition|(
name|a
operator|.
name|normal_exp
operator|>
operator|(
name|FRACBITS
operator|+
name|NGARDS
operator|)
condition|)
return|return
name|a
operator|.
name|fraction
operator|.
name|ll
operator|<<
operator|(
name|a
operator|.
name|normal_exp
operator|-
operator|(
name|FRACBITS
operator|+
name|NGARDS
operator|)
operator|)
return|;
else|else
return|return
name|a
operator|.
name|fraction
operator|.
name|ll
operator|>>
operator|(
operator|(
name|FRACBITS
operator|+
name|NGARDS
operator|)
operator|-
name|a
operator|.
name|normal_exp
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* US_SOFTWARE_GOFAST */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* L_sf_to_usi || L_df_to_usi */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_negate_sf
argument_list|)
operator|||
name|defined
argument_list|(
name|L_negate_df
argument_list|)
end_if

begin_function
name|FLO_type
name|negate
parameter_list|(
name|FLO_type
name|arg_a
parameter_list|)
block|{
name|fp_number_type
name|a
decl_stmt|;
name|FLO_union_type
name|au
decl_stmt|;
name|au
operator|.
name|value
operator|=
name|arg_a
expr_stmt|;
name|unpack_d
argument_list|(
operator|&
name|au
argument_list|,
operator|&
name|a
argument_list|)
expr_stmt|;
name|flip_sign
argument_list|(
operator|&
name|a
argument_list|)
expr_stmt|;
return|return
name|pack_d
argument_list|(
operator|&
name|a
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* L_negate_sf || L_negate_df */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|FLOAT
end_ifdef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_make_sf
argument_list|)
end_if

begin_function
name|SFtype
name|__make_fp
parameter_list|(
name|fp_class_type
name|class
parameter_list|,
name|unsigned
name|int
name|sign
parameter_list|,
name|int
name|exp
parameter_list|,
name|USItype
name|frac
parameter_list|)
block|{
name|fp_number_type
name|in
decl_stmt|;
name|in
operator|.
name|class
operator|=
name|class
expr_stmt|;
name|in
operator|.
name|sign
operator|=
name|sign
expr_stmt|;
name|in
operator|.
name|normal_exp
operator|=
name|exp
expr_stmt|;
name|in
operator|.
name|fraction
operator|.
name|ll
operator|=
name|frac
expr_stmt|;
return|return
name|pack_d
argument_list|(
operator|&
name|in
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* L_make_sf */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|FLOAT_ONLY
end_ifndef

begin_comment
comment|/* This enables one to build an fp library that supports float but not double.    Otherwise, we would get an undefined reference to __make_dp.    This is needed for some 8-bit ports that can't handle well values that    are 8-bytes in size, so we just don't support double for them at all.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_sf_to_df
argument_list|)
end_if

begin_function
name|DFtype
name|sf_to_df
parameter_list|(
name|SFtype
name|arg_a
parameter_list|)
block|{
name|fp_number_type
name|in
decl_stmt|;
name|FLO_union_type
name|au
decl_stmt|;
name|au
operator|.
name|value
operator|=
name|arg_a
expr_stmt|;
name|unpack_d
argument_list|(
operator|&
name|au
argument_list|,
operator|&
name|in
argument_list|)
expr_stmt|;
return|return
name|__make_dp
argument_list|(
name|in
operator|.
name|class
argument_list|,
name|in
operator|.
name|sign
argument_list|,
name|in
operator|.
name|normal_exp
argument_list|,
operator|(
operator|(
name|UDItype
operator|)
name|in
operator|.
name|fraction
operator|.
name|ll
operator|)
operator|<<
name|F_D_BITOFF
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* L_sf_to_df */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! FLOAT_ONLY */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FLOAT */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|FLOAT
end_ifndef

begin_function_decl
specifier|extern
name|SFtype
name|__make_fp
parameter_list|(
name|fp_class_type
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|int
parameter_list|,
name|USItype
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_make_df
argument_list|)
end_if

begin_function
name|DFtype
name|__make_dp
parameter_list|(
name|fp_class_type
name|class
parameter_list|,
name|unsigned
name|int
name|sign
parameter_list|,
name|int
name|exp
parameter_list|,
name|UDItype
name|frac
parameter_list|)
block|{
name|fp_number_type
name|in
decl_stmt|;
name|in
operator|.
name|class
operator|=
name|class
expr_stmt|;
name|in
operator|.
name|sign
operator|=
name|sign
expr_stmt|;
name|in
operator|.
name|normal_exp
operator|=
name|exp
expr_stmt|;
name|in
operator|.
name|fraction
operator|.
name|ll
operator|=
name|frac
expr_stmt|;
return|return
name|pack_d
argument_list|(
operator|&
name|in
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* L_make_df */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_df_to_sf
argument_list|)
end_if

begin_function
name|SFtype
name|df_to_sf
parameter_list|(
name|DFtype
name|arg_a
parameter_list|)
block|{
name|fp_number_type
name|in
decl_stmt|;
name|USItype
name|sffrac
decl_stmt|;
name|FLO_union_type
name|au
decl_stmt|;
name|au
operator|.
name|value
operator|=
name|arg_a
expr_stmt|;
name|unpack_d
argument_list|(
operator|&
name|au
argument_list|,
operator|&
name|in
argument_list|)
expr_stmt|;
name|sffrac
operator|=
name|in
operator|.
name|fraction
operator|.
name|ll
operator|>>
name|F_D_BITOFF
expr_stmt|;
comment|/* We set the lowest guard bit in SFFRAC if we discarded any non      zero bits.  */
if|if
condition|(
operator|(
name|in
operator|.
name|fraction
operator|.
name|ll
operator|&
operator|(
operator|(
operator|(
name|USItype
operator|)
literal|1
operator|<<
name|F_D_BITOFF
operator|)
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
name|sffrac
operator||=
literal|1
expr_stmt|;
return|return
name|__make_fp
argument_list|(
name|in
operator|.
name|class
argument_list|,
name|in
operator|.
name|sign
argument_list|,
name|in
operator|.
name|normal_exp
argument_list|,
name|sffrac
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* L_df_to_sf */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! FLOAT */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !EXTENDED_FLOAT_STUBS */
end_comment

end_unit

