begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* This is a software floating point library which can be used    for targets without hardware floating point.     Copyright (C) 1994, 1995, 1996, 1997, 1998, 2000, 2001, 2002, 2003, 2004    Free Software Foundation, Inc.  This file is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  In addition to the permissions in the GNU General Public License, the Free Software Foundation gives you unlimited permission to link the compiled version of this file with other programs, and to distribute those programs without any restriction coming from the use of this file.  (The General Public License restrictions do apply in other respects; for example, they cover modification of the file, and distribution when not linked into another program.)  This file is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* As a special exception, if you link this library with other files,    some of which are compiled with GCC, to produce an executable,    this library does not by itself cause the resulting executable    to be covered by the GNU General Public License.    This exception does not however invalidate any other reasons why    the executable file might be covered by the GNU General Public License.  */
end_comment

begin_comment
comment|/* This implements IEEE 754 format arithmetic, but does not provide a    mechanism for setting the rounding mode, or for generating or handling    exceptions.     The original code by Steve Chamberlain, hacked by Mark Eichin and Jim    Wilson, all of Cygnus Support.  */
end_comment

begin_comment
comment|/* The intended way to use this file is to make two copies, add `#define FLOAT'    to one copy, then compile both copies and add them to libgcc.a.  */
end_comment

begin_include
include|#
directive|include
file|"tconfig.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"config/fp-bit.h"
end_include

begin_comment
comment|/* The following macros can be defined to change the behavior of this file:    FLOAT: Implement a `float', aka SFmode, fp library.  If this is not      defined, then this file implements a `double', aka DFmode, fp library.    FLOAT_ONLY: Used with FLOAT, to implement a `float' only library, i.e.      don't include float->double conversion which requires the double library.      This is useful only for machines which can't support doubles, e.g. some      8-bit processors.    CMPtype: Specify the type that floating point compares should return.      This defaults to SItype, aka int.    US_SOFTWARE_GOFAST: This makes all entry points use the same names as the      US Software goFast library.    _DEBUG_BITFLOAT: This makes debugging the code a little easier, by adding      two integers to the FLO_union_type.    NO_DENORMALS: Disable handling of denormals.    NO_NANS: Disable nan and infinity handling    SMALL_MACHINE: Useful when operations on QIs and HIs are faster      than on an SI */
end_comment

begin_comment
comment|/* We don't currently support extended floats (long doubles) on machines    without hardware to deal with them.     These stubs are just to keep the linker from complaining about unresolved    references which can be pulled in from libio& libstdc++, even if the    user isn't using long doubles.  However, they may generate an unresolved    external to abort if abort is not used by the function, and the stubs    are referenced from within libc, since libgcc goes before and after the    system library.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DECLARE_LIBRARY_RENAMES
end_ifdef

begin_function_decl
name|DECLARE_LIBRARY_RENAMES
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EXTENDED_FLOAT_STUBS
specifier|extern
name|void
name|abort
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|__extendsfxf2
parameter_list|(
name|void
parameter_list|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|__extenddfxf2
parameter_list|(
name|void
parameter_list|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|__truncxfdf2
parameter_list|(
name|void
parameter_list|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|__truncxfsf2
parameter_list|(
name|void
parameter_list|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|__fixxfsi
parameter_list|(
name|void
parameter_list|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|__floatsixf
parameter_list|(
name|void
parameter_list|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|__addxf3
parameter_list|(
name|void
parameter_list|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|__subxf3
parameter_list|(
name|void
parameter_list|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|__mulxf3
parameter_list|(
name|void
parameter_list|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|__divxf3
parameter_list|(
name|void
parameter_list|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|__negxf2
parameter_list|(
name|void
parameter_list|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|__eqxf2
parameter_list|(
name|void
parameter_list|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|__nexf2
parameter_list|(
name|void
parameter_list|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|__gtxf2
parameter_list|(
name|void
parameter_list|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|__gexf2
parameter_list|(
name|void
parameter_list|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|__lexf2
parameter_list|(
name|void
parameter_list|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|__ltxf2
parameter_list|(
name|void
parameter_list|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|__extendsftf2
parameter_list|(
name|void
parameter_list|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|__extenddftf2
parameter_list|(
name|void
parameter_list|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|__trunctfdf2
parameter_list|(
name|void
parameter_list|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|__trunctfsf2
parameter_list|(
name|void
parameter_list|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|__fixtfsi
parameter_list|(
name|void
parameter_list|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|__floatsitf
parameter_list|(
name|void
parameter_list|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|__addtf3
parameter_list|(
name|void
parameter_list|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|__subtf3
parameter_list|(
name|void
parameter_list|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|__multf3
parameter_list|(
name|void
parameter_list|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|__divtf3
parameter_list|(
name|void
parameter_list|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|__negtf2
parameter_list|(
name|void
parameter_list|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|__eqtf2
parameter_list|(
name|void
parameter_list|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|__netf2
parameter_list|(
name|void
parameter_list|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|__gttf2
parameter_list|(
name|void
parameter_list|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|__getf2
parameter_list|(
name|void
parameter_list|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|__letf2
parameter_list|(
name|void
parameter_list|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|__lttf2
parameter_list|(
name|void
parameter_list|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !EXTENDED_FLOAT_STUBS, rest of file */
end_comment

begin_comment
comment|/* IEEE "special" number predicates */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|NO_NANS
end_ifdef

begin_define
define|#
directive|define
name|nan
parameter_list|()
value|0
end_define

begin_define
define|#
directive|define
name|isnan
parameter_list|(
name|x
parameter_list|)
value|0
end_define

begin_define
define|#
directive|define
name|isinf
parameter_list|(
name|x
parameter_list|)
value|0
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|defined
name|L_thenan_sf
end_if

begin_decl_stmt
specifier|const
name|fp_number_type
name|__thenan_sf
init|=
block|{
name|CLASS_SNAN
block|,
literal|0
block|,
literal|0
block|,
block|{
operator|(
name|fractype
operator|)
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_elif
elif|#
directive|elif
name|defined
name|L_thenan_df
end_elif

begin_decl_stmt
specifier|const
name|fp_number_type
name|__thenan_df
init|=
block|{
name|CLASS_SNAN
block|,
literal|0
block|,
literal|0
block|,
block|{
operator|(
name|fractype
operator|)
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_elif
elif|#
directive|elif
name|defined
name|L_thenan_tf
end_elif

begin_decl_stmt
specifier|const
name|fp_number_type
name|__thenan_tf
init|=
block|{
name|CLASS_SNAN
block|,
literal|0
block|,
literal|0
block|,
block|{
operator|(
name|fractype
operator|)
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_elif
elif|#
directive|elif
name|defined
name|TFLOAT
end_elif

begin_decl_stmt
specifier|extern
specifier|const
name|fp_number_type
name|__thenan_tf
decl_stmt|;
end_decl_stmt

begin_elif
elif|#
directive|elif
name|defined
name|FLOAT
end_elif

begin_decl_stmt
specifier|extern
specifier|const
name|fp_number_type
name|__thenan_sf
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|extern
specifier|const
name|fp_number_type
name|__thenan_df
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|INLINE
specifier|static
name|fp_number_type
modifier|*
name|nan
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Discard the const qualifier...  */
ifdef|#
directive|ifdef
name|TFLOAT
return|return
operator|(
name|fp_number_type
operator|*
operator|)
operator|(
operator|&
name|__thenan_tf
operator|)
return|;
elif|#
directive|elif
name|defined
name|FLOAT
return|return
operator|(
name|fp_number_type
operator|*
operator|)
operator|(
operator|&
name|__thenan_sf
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|fp_number_type
operator|*
operator|)
operator|(
operator|&
name|__thenan_df
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|INLINE
specifier|static
name|int
name|isnan
parameter_list|(
name|fp_number_type
modifier|*
name|x
parameter_list|)
block|{
return|return
name|x
operator|->
name|class
operator|==
name|CLASS_SNAN
operator|||
name|x
operator|->
name|class
operator|==
name|CLASS_QNAN
return|;
block|}
end_function

begin_function
name|INLINE
specifier|static
name|int
name|isinf
parameter_list|(
name|fp_number_type
modifier|*
name|x
parameter_list|)
block|{
return|return
name|x
operator|->
name|class
operator|==
name|CLASS_INFINITY
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NO_NANS */
end_comment

begin_function
name|INLINE
specifier|static
name|int
name|iszero
parameter_list|(
name|fp_number_type
modifier|*
name|x
parameter_list|)
block|{
return|return
name|x
operator|->
name|class
operator|==
name|CLASS_ZERO
return|;
block|}
end_function

begin_function
name|INLINE
specifier|static
name|void
name|flip_sign
parameter_list|(
name|fp_number_type
modifier|*
name|x
parameter_list|)
block|{
name|x
operator|->
name|sign
operator|=
operator|!
name|x
operator|->
name|sign
expr_stmt|;
block|}
end_function

begin_function_decl
specifier|extern
name|FLO_type
name|pack_d
parameter_list|(
name|fp_number_type
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_pack_df
argument_list|)
operator|||
name|defined
argument_list|(
name|L_pack_sf
argument_list|)
operator|||
name|defined
argument_list|(
name|L_pack_tf
argument_list|)
end_if

begin_function
name|FLO_type
name|pack_d
parameter_list|(
name|fp_number_type
modifier|*
name|src
parameter_list|)
block|{
name|FLO_union_type
name|dst
decl_stmt|;
name|fractype
name|fraction
init|=
name|src
operator|->
name|fraction
operator|.
name|ll
decl_stmt|;
comment|/* wasn't unsigned before? */
name|int
name|sign
init|=
name|src
operator|->
name|sign
decl_stmt|;
name|int
name|exp
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|LARGEST_EXPONENT_IS_NORMAL
argument_list|(
name|FRAC_NBITS
argument_list|)
operator|&&
operator|(
name|isnan
argument_list|(
name|src
argument_list|)
operator|||
name|isinf
argument_list|(
name|src
argument_list|)
operator|)
condition|)
block|{
comment|/* We can't represent these values accurately.  By using the 	 largest possible magnitude, we guarantee that the conversion 	 of infinity is at least as big as any finite number.  */
name|exp
operator|=
name|EXPMAX
expr_stmt|;
name|fraction
operator|=
operator|(
operator|(
name|fractype
operator|)
literal|1
operator|<<
name|FRACBITS
operator|)
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isnan
argument_list|(
name|src
argument_list|)
condition|)
block|{
name|exp
operator|=
name|EXPMAX
expr_stmt|;
if|if
condition|(
name|src
operator|->
name|class
operator|==
name|CLASS_QNAN
operator|||
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|QUIET_NAN_NEGATED
name|fraction
operator||=
name|QUIET_NAN
operator|-
literal|1
expr_stmt|;
else|#
directive|else
name|fraction
operator||=
name|QUIET_NAN
expr_stmt|;
endif|#
directive|endif
block|}
block|}
elseif|else
if|if
condition|(
name|isinf
argument_list|(
name|src
argument_list|)
condition|)
block|{
name|exp
operator|=
name|EXPMAX
expr_stmt|;
name|fraction
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|iszero
argument_list|(
name|src
argument_list|)
condition|)
block|{
name|exp
operator|=
literal|0
expr_stmt|;
name|fraction
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fraction
operator|==
literal|0
condition|)
block|{
name|exp
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|src
operator|->
name|normal_exp
operator|<
name|NORMAL_EXPMIN
condition|)
block|{
ifdef|#
directive|ifdef
name|NO_DENORMALS
comment|/* Go straight to a zero representation if denormals are not  	     supported.  The denormal handling would be harmless but  	     isn't unnecessary.  */
name|exp
operator|=
literal|0
expr_stmt|;
name|fraction
operator|=
literal|0
expr_stmt|;
else|#
directive|else
comment|/* NO_DENORMALS */
comment|/* This number's exponent is too low to fit into the bits 	     available in the number, so we'll store 0 in the exponent and 	     shift the fraction to the right to make up for it.  */
name|int
name|shift
init|=
name|NORMAL_EXPMIN
operator|-
name|src
operator|->
name|normal_exp
decl_stmt|;
name|exp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|shift
operator|>
name|FRAC_NBITS
operator|-
name|NGARDS
condition|)
block|{
comment|/* No point shifting, since it's more that 64 out.  */
name|fraction
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|int
name|lowbit
init|=
operator|(
name|fraction
operator|&
operator|(
operator|(
operator|(
name|fractype
operator|)
literal|1
operator|<<
name|shift
operator|)
operator|-
literal|1
operator|)
operator|)
condition|?
literal|1
else|:
literal|0
decl_stmt|;
name|fraction
operator|=
operator|(
name|fraction
operator|>>
name|shift
operator|)
operator||
name|lowbit
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|fraction
operator|&
name|GARDMASK
operator|)
operator|==
name|GARDMSB
condition|)
block|{
if|if
condition|(
operator|(
name|fraction
operator|&
operator|(
literal|1
operator|<<
name|NGARDS
operator|)
operator|)
condition|)
name|fraction
operator|+=
name|GARDROUND
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Add to the guards to round up.  */
name|fraction
operator|+=
name|GARDROUND
expr_stmt|;
block|}
comment|/* Perhaps the rounding means we now need to change the              exponent, because the fraction is no longer denormal.  */
if|if
condition|(
name|fraction
operator|>=
name|IMPLICIT_1
condition|)
block|{
name|exp
operator|+=
literal|1
expr_stmt|;
block|}
name|fraction
operator|>>=
name|NGARDS
expr_stmt|;
endif|#
directive|endif
comment|/* NO_DENORMALS */
block|}
elseif|else
if|if
condition|(
operator|!
name|LARGEST_EXPONENT_IS_NORMAL
argument_list|(
name|FRAC_NBITS
argument_list|)
operator|&&
name|src
operator|->
name|normal_exp
operator|>
name|EXPBIAS
condition|)
block|{
name|exp
operator|=
name|EXPMAX
expr_stmt|;
name|fraction
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|exp
operator|=
name|src
operator|->
name|normal_exp
operator|+
name|EXPBIAS
expr_stmt|;
if|if
condition|(
operator|!
name|ROUND_TOWARDS_ZERO
condition|)
block|{
comment|/* IF the gard bits are the all zero, but the first, then we're 		 half way between two numbers, choose the one which makes the 		 lsb of the answer 0.  */
if|if
condition|(
operator|(
name|fraction
operator|&
name|GARDMASK
operator|)
operator|==
name|GARDMSB
condition|)
block|{
if|if
condition|(
name|fraction
operator|&
operator|(
literal|1
operator|<<
name|NGARDS
operator|)
condition|)
name|fraction
operator|+=
name|GARDROUND
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Add a one to the guards to round up */
name|fraction
operator|+=
name|GARDROUND
expr_stmt|;
block|}
if|if
condition|(
name|fraction
operator|>=
name|IMPLICIT_2
condition|)
block|{
name|fraction
operator|>>=
literal|1
expr_stmt|;
name|exp
operator|+=
literal|1
expr_stmt|;
block|}
block|}
name|fraction
operator|>>=
name|NGARDS
expr_stmt|;
if|if
condition|(
name|LARGEST_EXPONENT_IS_NORMAL
argument_list|(
name|FRAC_NBITS
argument_list|)
operator|&&
name|exp
operator|>
name|EXPMAX
condition|)
block|{
comment|/* Saturate on overflow.  */
name|exp
operator|=
name|EXPMAX
expr_stmt|;
name|fraction
operator|=
operator|(
operator|(
name|fractype
operator|)
literal|1
operator|<<
name|FRACBITS
operator|)
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/* We previously used bitfields to store the number, but this doesn't      handle little/big endian systems conveniently, so use shifts and      masks */
ifdef|#
directive|ifdef
name|FLOAT_BIT_ORDER_MISMATCH
name|dst
operator|.
name|bits
operator|.
name|fraction
operator|=
name|fraction
expr_stmt|;
name|dst
operator|.
name|bits
operator|.
name|exp
operator|=
name|exp
expr_stmt|;
name|dst
operator|.
name|bits
operator|.
name|sign
operator|=
name|sign
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|defined
name|TFLOAT
operator|&&
name|defined
name|HALFFRACBITS
block|{
name|halffractype
name|high
decl_stmt|,
name|low
decl_stmt|,
name|unity
decl_stmt|;
name|int
name|lowsign
decl_stmt|,
name|lowexp
decl_stmt|;
name|unity
operator|=
operator|(
name|halffractype
operator|)
literal|1
operator|<<
name|HALFFRACBITS
expr_stmt|;
comment|/* Set HIGH to the high double's significand, masking out the implicit 1.       Set LOW to the low double's full significand.  */
name|high
operator|=
operator|(
name|fraction
operator|>>
operator|(
name|FRACBITS
operator|-
name|HALFFRACBITS
operator|)
operator|)
operator|&
operator|(
name|unity
operator|-
literal|1
operator|)
expr_stmt|;
name|low
operator|=
name|fraction
operator|&
operator|(
name|unity
operator|*
literal|2
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* Get the initial sign and exponent of the low double.  */
name|lowexp
operator|=
name|exp
operator|-
name|HALFFRACBITS
operator|-
literal|1
expr_stmt|;
name|lowsign
operator|=
name|sign
expr_stmt|;
comment|/* HIGH should be rounded like a normal double, making |LOW|<=       0.5 ULP of HIGH.  Assume round-to-nearest.  */
if|if
condition|(
name|exp
operator|<
name|EXPMAX
condition|)
if|if
condition|(
name|low
operator|>
name|unity
operator|||
operator|(
name|low
operator|==
name|unity
operator|&&
operator|(
name|high
operator|&
literal|1
operator|)
operator|==
literal|1
operator|)
condition|)
block|{
comment|/* Round HIGH up and adjust LOW to match.  */
name|high
operator|++
expr_stmt|;
if|if
condition|(
name|high
operator|==
name|unity
condition|)
block|{
comment|/* May make it infinite, but that's OK.  */
name|high
operator|=
literal|0
expr_stmt|;
name|exp
operator|++
expr_stmt|;
block|}
name|low
operator|=
name|unity
operator|*
literal|2
operator|-
name|low
expr_stmt|;
name|lowsign
operator|^=
literal|1
expr_stmt|;
block|}
name|high
operator||=
operator|(
name|halffractype
operator|)
name|exp
operator|<<
name|HALFFRACBITS
expr_stmt|;
name|high
operator||=
operator|(
name|halffractype
operator|)
name|sign
operator|<<
operator|(
name|HALFFRACBITS
operator|+
name|EXPBITS
operator|)
expr_stmt|;
if|if
condition|(
name|exp
operator|==
name|EXPMAX
operator|||
name|exp
operator|==
literal|0
operator|||
name|low
operator|==
literal|0
condition|)
name|low
operator|=
literal|0
expr_stmt|;
else|else
block|{
while|while
condition|(
name|lowexp
operator|>
literal|0
operator|&&
name|low
operator|<
name|unity
condition|)
block|{
name|low
operator|<<=
literal|1
expr_stmt|;
name|lowexp
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|lowexp
operator|<=
literal|0
condition|)
block|{
name|halffractype
name|roundmsb
decl_stmt|,
name|round
decl_stmt|;
name|int
name|shift
decl_stmt|;
name|shift
operator|=
literal|1
operator|-
name|lowexp
expr_stmt|;
name|roundmsb
operator|=
operator|(
literal|1
operator|<<
operator|(
name|shift
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|round
operator|=
name|low
operator|&
operator|(
operator|(
name|roundmsb
operator|<<
literal|1
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|low
operator|>>=
name|shift
expr_stmt|;
name|lowexp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|round
operator|>
name|roundmsb
operator|||
operator|(
name|round
operator|==
name|roundmsb
operator|&&
operator|(
name|low
operator|&
literal|1
operator|)
operator|==
literal|1
operator|)
condition|)
block|{
name|low
operator|++
expr_stmt|;
if|if
condition|(
name|low
operator|==
name|unity
condition|)
comment|/* LOW rounds up to the smallest normal number.  */
name|lowexp
operator|++
expr_stmt|;
block|}
block|}
name|low
operator|&=
name|unity
operator|-
literal|1
expr_stmt|;
name|low
operator||=
operator|(
name|halffractype
operator|)
name|lowexp
operator|<<
name|HALFFRACBITS
expr_stmt|;
name|low
operator||=
operator|(
name|halffractype
operator|)
name|lowsign
operator|<<
operator|(
name|HALFFRACBITS
operator|+
name|EXPBITS
operator|)
expr_stmt|;
block|}
name|dst
operator|.
name|value_raw
operator|=
operator|(
operator|(
name|fractype
operator|)
name|high
operator|<<
name|HALFSHIFT
operator|)
operator||
name|low
expr_stmt|;
block|}
else|#
directive|else
name|dst
operator|.
name|value_raw
operator|=
name|fraction
operator|&
operator|(
operator|(
operator|(
operator|(
name|fractype
operator|)
literal|1
operator|)
operator|<<
name|FRACBITS
operator|)
operator|-
operator|(
name|fractype
operator|)
literal|1
operator|)
expr_stmt|;
name|dst
operator|.
name|value_raw
operator||=
operator|(
call|(
name|fractype
call|)
argument_list|(
name|exp
operator|&
operator|(
operator|(
literal|1
operator|<<
name|EXPBITS
operator|)
operator|-
literal|1
operator|)
argument_list|)
operator|)
operator|<<
name|FRACBITS
expr_stmt|;
name|dst
operator|.
name|value_raw
operator||=
operator|(
call|(
name|fractype
call|)
argument_list|(
name|sign
operator|&
literal|1
argument_list|)
operator|)
operator|<<
operator|(
name|FRACBITS
operator||
name|EXPBITS
operator|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|FLOAT_WORD_ORDER_MISMATCH
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|FLOAT
argument_list|)
ifdef|#
directive|ifdef
name|TFLOAT
block|{
name|qrtrfractype
name|tmp1
init|=
name|dst
operator|.
name|words
index|[
literal|0
index|]
decl_stmt|;
name|qrtrfractype
name|tmp2
init|=
name|dst
operator|.
name|words
index|[
literal|1
index|]
decl_stmt|;
name|dst
operator|.
name|words
index|[
literal|0
index|]
operator|=
name|dst
operator|.
name|words
index|[
literal|3
index|]
expr_stmt|;
name|dst
operator|.
name|words
index|[
literal|1
index|]
operator|=
name|dst
operator|.
name|words
index|[
literal|2
index|]
expr_stmt|;
name|dst
operator|.
name|words
index|[
literal|2
index|]
operator|=
name|tmp2
expr_stmt|;
name|dst
operator|.
name|words
index|[
literal|3
index|]
operator|=
name|tmp1
expr_stmt|;
block|}
else|#
directive|else
block|{
name|halffractype
name|tmp
init|=
name|dst
operator|.
name|words
index|[
literal|0
index|]
decl_stmt|;
name|dst
operator|.
name|words
index|[
literal|0
index|]
operator|=
name|dst
operator|.
name|words
index|[
literal|1
index|]
expr_stmt|;
name|dst
operator|.
name|words
index|[
literal|1
index|]
operator|=
name|tmp
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
return|return
name|dst
operator|.
name|value
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_unpack_df
argument_list|)
operator|||
name|defined
argument_list|(
name|L_unpack_sf
argument_list|)
operator|||
name|defined
argument_list|(
name|L_unpack_tf
argument_list|)
end_if

begin_function
name|void
name|unpack_d
parameter_list|(
name|FLO_union_type
modifier|*
name|src
parameter_list|,
name|fp_number_type
modifier|*
name|dst
parameter_list|)
block|{
comment|/* We previously used bitfields to store the number, but this doesn't      handle little/big endian systems conveniently, so use shifts and      masks */
name|fractype
name|fraction
decl_stmt|;
name|int
name|exp
decl_stmt|;
name|int
name|sign
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|FLOAT_WORD_ORDER_MISMATCH
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|FLOAT
argument_list|)
name|FLO_union_type
name|swapped
decl_stmt|;
ifdef|#
directive|ifdef
name|TFLOAT
name|swapped
operator|.
name|words
index|[
literal|0
index|]
operator|=
name|src
operator|->
name|words
index|[
literal|3
index|]
expr_stmt|;
name|swapped
operator|.
name|words
index|[
literal|1
index|]
operator|=
name|src
operator|->
name|words
index|[
literal|2
index|]
expr_stmt|;
name|swapped
operator|.
name|words
index|[
literal|2
index|]
operator|=
name|src
operator|->
name|words
index|[
literal|1
index|]
expr_stmt|;
name|swapped
operator|.
name|words
index|[
literal|3
index|]
operator|=
name|src
operator|->
name|words
index|[
literal|0
index|]
expr_stmt|;
else|#
directive|else
name|swapped
operator|.
name|words
index|[
literal|0
index|]
operator|=
name|src
operator|->
name|words
index|[
literal|1
index|]
expr_stmt|;
name|swapped
operator|.
name|words
index|[
literal|1
index|]
operator|=
name|src
operator|->
name|words
index|[
literal|0
index|]
expr_stmt|;
endif|#
directive|endif
name|src
operator|=
operator|&
name|swapped
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|FLOAT_BIT_ORDER_MISMATCH
name|fraction
operator|=
name|src
operator|->
name|bits
operator|.
name|fraction
expr_stmt|;
name|exp
operator|=
name|src
operator|->
name|bits
operator|.
name|exp
expr_stmt|;
name|sign
operator|=
name|src
operator|->
name|bits
operator|.
name|sign
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|defined
name|TFLOAT
operator|&&
name|defined
name|HALFFRACBITS
block|{
name|halffractype
name|high
decl_stmt|,
name|low
decl_stmt|;
name|high
operator|=
name|src
operator|->
name|value_raw
operator|>>
name|HALFSHIFT
expr_stmt|;
name|low
operator|=
name|src
operator|->
name|value_raw
operator|&
operator|(
operator|(
operator|(
name|fractype
operator|)
literal|1
operator|<<
name|HALFSHIFT
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|fraction
operator|=
name|high
operator|&
operator|(
operator|(
operator|(
operator|(
name|fractype
operator|)
literal|1
operator|)
operator|<<
name|HALFFRACBITS
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|fraction
operator|<<=
name|FRACBITS
operator|-
name|HALFFRACBITS
expr_stmt|;
name|exp
operator|=
operator|(
call|(
name|int
call|)
argument_list|(
name|high
operator|>>
name|HALFFRACBITS
argument_list|)
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
name|EXPBITS
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|sign
operator|=
operator|(
call|(
name|int
call|)
argument_list|(
name|high
operator|>>
operator|(
operator|(
operator|(
name|HALFFRACBITS
operator|+
name|EXPBITS
operator|)
operator|)
operator|)
argument_list|)
operator|)
operator|&
literal|1
expr_stmt|;
if|if
condition|(
name|exp
operator|!=
name|EXPMAX
operator|&&
name|exp
operator|!=
literal|0
operator|&&
name|low
operator|!=
literal|0
condition|)
block|{
name|int
name|lowexp
init|=
operator|(
call|(
name|int
call|)
argument_list|(
name|low
operator|>>
name|HALFFRACBITS
argument_list|)
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
name|EXPBITS
operator|)
operator|-
literal|1
operator|)
decl_stmt|;
name|int
name|lowsign
init|=
operator|(
call|(
name|int
call|)
argument_list|(
name|low
operator|>>
operator|(
operator|(
operator|(
name|HALFFRACBITS
operator|+
name|EXPBITS
operator|)
operator|)
operator|)
argument_list|)
operator|)
operator|&
literal|1
decl_stmt|;
name|int
name|shift
decl_stmt|;
name|fractype
name|xlow
decl_stmt|;
name|xlow
operator|=
name|low
operator|&
operator|(
operator|(
operator|(
operator|(
name|fractype
operator|)
literal|1
operator|)
operator|<<
name|HALFFRACBITS
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|lowexp
condition|)
name|xlow
operator||=
operator|(
operator|(
operator|(
name|halffractype
operator|)
literal|1
operator|)
operator|<<
name|HALFFRACBITS
operator|)
expr_stmt|;
else|else
name|lowexp
operator|=
literal|1
expr_stmt|;
name|shift
operator|=
operator|(
name|FRACBITS
operator|-
name|HALFFRACBITS
operator|)
operator|-
operator|(
name|exp
operator|-
name|lowexp
operator|)
expr_stmt|;
if|if
condition|(
name|shift
operator|>
literal|0
condition|)
name|xlow
operator|<<=
name|shift
expr_stmt|;
elseif|else
if|if
condition|(
name|shift
operator|<
literal|0
condition|)
name|xlow
operator|>>=
operator|-
name|shift
expr_stmt|;
if|if
condition|(
name|sign
operator|==
name|lowsign
condition|)
name|fraction
operator|+=
name|xlow
expr_stmt|;
elseif|else
if|if
condition|(
name|fraction
operator|>=
name|xlow
condition|)
name|fraction
operator|-=
name|xlow
expr_stmt|;
else|else
block|{
comment|/* The high part is a power of two but the full number is lower. 	      This code will leave the implicit 1 in FRACTION, but we'd 	      have added that below anyway.  */
name|fraction
operator|=
operator|(
operator|(
operator|(
name|fractype
operator|)
literal|1
operator|<<
name|FRACBITS
operator|)
operator|-
name|xlow
operator|)
operator|<<
literal|1
expr_stmt|;
name|exp
operator|--
expr_stmt|;
block|}
block|}
block|}
else|#
directive|else
name|fraction
operator|=
name|src
operator|->
name|value_raw
operator|&
operator|(
operator|(
operator|(
operator|(
name|fractype
operator|)
literal|1
operator|)
operator|<<
name|FRACBITS
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|exp
operator|=
operator|(
call|(
name|int
call|)
argument_list|(
name|src
operator|->
name|value_raw
operator|>>
name|FRACBITS
argument_list|)
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
name|EXPBITS
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|sign
operator|=
operator|(
call|(
name|int
call|)
argument_list|(
name|src
operator|->
name|value_raw
operator|>>
operator|(
name|FRACBITS
operator|+
name|EXPBITS
operator|)
argument_list|)
operator|)
operator|&
literal|1
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|dst
operator|->
name|sign
operator|=
name|sign
expr_stmt|;
if|if
condition|(
name|exp
operator|==
literal|0
condition|)
block|{
comment|/* Hmm.  Looks like 0 */
if|if
condition|(
name|fraction
operator|==
literal|0
ifdef|#
directive|ifdef
name|NO_DENORMALS
operator|||
literal|1
endif|#
directive|endif
condition|)
block|{
comment|/* tastes like zero */
name|dst
operator|->
name|class
operator|=
name|CLASS_ZERO
expr_stmt|;
block|}
else|else
block|{
comment|/* Zero exponent with nonzero fraction - it's denormalized, 	     so there isn't a leading implicit one - we'll shift it so 	     it gets one.  */
name|dst
operator|->
name|normal_exp
operator|=
name|exp
operator|-
name|EXPBIAS
operator|+
literal|1
expr_stmt|;
name|fraction
operator|<<=
name|NGARDS
expr_stmt|;
name|dst
operator|->
name|class
operator|=
name|CLASS_NUMBER
expr_stmt|;
if|#
directive|if
literal|1
while|while
condition|(
name|fraction
operator|<
name|IMPLICIT_1
condition|)
block|{
name|fraction
operator|<<=
literal|1
expr_stmt|;
name|dst
operator|->
name|normal_exp
operator|--
expr_stmt|;
block|}
endif|#
directive|endif
name|dst
operator|->
name|fraction
operator|.
name|ll
operator|=
name|fraction
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|LARGEST_EXPONENT_IS_NORMAL
argument_list|(
name|FRAC_NBITS
argument_list|)
operator|&&
name|exp
operator|==
name|EXPMAX
condition|)
block|{
comment|/* Huge exponent*/
if|if
condition|(
name|fraction
operator|==
literal|0
condition|)
block|{
comment|/* Attached to a zero fraction - means infinity */
name|dst
operator|->
name|class
operator|=
name|CLASS_INFINITY
expr_stmt|;
block|}
else|else
block|{
comment|/* Nonzero fraction, means nan */
ifdef|#
directive|ifdef
name|QUIET_NAN_NEGATED
if|if
condition|(
operator|(
name|fraction
operator|&
name|QUIET_NAN
operator|)
operator|==
literal|0
condition|)
else|#
directive|else
if|if
condition|(
name|fraction
operator|&
name|QUIET_NAN
condition|)
endif|#
directive|endif
block|{
name|dst
operator|->
name|class
operator|=
name|CLASS_QNAN
expr_stmt|;
block|}
else|else
block|{
name|dst
operator|->
name|class
operator|=
name|CLASS_SNAN
expr_stmt|;
block|}
comment|/* Keep the fraction part as the nan number */
name|dst
operator|->
name|fraction
operator|.
name|ll
operator|=
name|fraction
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Nothing strange about this number */
name|dst
operator|->
name|normal_exp
operator|=
name|exp
operator|-
name|EXPBIAS
expr_stmt|;
name|dst
operator|->
name|class
operator|=
name|CLASS_NUMBER
expr_stmt|;
name|dst
operator|->
name|fraction
operator|.
name|ll
operator|=
operator|(
name|fraction
operator|<<
name|NGARDS
operator|)
operator||
name|IMPLICIT_1
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* L_unpack_df || L_unpack_sf */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_addsub_sf
argument_list|)
operator|||
name|defined
argument_list|(
name|L_addsub_df
argument_list|)
operator|||
name|defined
argument_list|(
name|L_addsub_tf
argument_list|)
end_if

begin_function
specifier|static
name|fp_number_type
modifier|*
name|_fpadd_parts
parameter_list|(
name|fp_number_type
modifier|*
name|a
parameter_list|,
name|fp_number_type
modifier|*
name|b
parameter_list|,
name|fp_number_type
modifier|*
name|tmp
parameter_list|)
block|{
name|intfrac
name|tfraction
decl_stmt|;
comment|/* Put commonly used fields in local variables.  */
name|int
name|a_normal_exp
decl_stmt|;
name|int
name|b_normal_exp
decl_stmt|;
name|fractype
name|a_fraction
decl_stmt|;
name|fractype
name|b_fraction
decl_stmt|;
if|if
condition|(
name|isnan
argument_list|(
name|a
argument_list|)
condition|)
block|{
return|return
name|a
return|;
block|}
if|if
condition|(
name|isnan
argument_list|(
name|b
argument_list|)
condition|)
block|{
return|return
name|b
return|;
block|}
if|if
condition|(
name|isinf
argument_list|(
name|a
argument_list|)
condition|)
block|{
comment|/* Adding infinities with opposite signs yields a NaN.  */
if|if
condition|(
name|isinf
argument_list|(
name|b
argument_list|)
operator|&&
name|a
operator|->
name|sign
operator|!=
name|b
operator|->
name|sign
condition|)
return|return
name|nan
argument_list|()
return|;
return|return
name|a
return|;
block|}
if|if
condition|(
name|isinf
argument_list|(
name|b
argument_list|)
condition|)
block|{
return|return
name|b
return|;
block|}
if|if
condition|(
name|iszero
argument_list|(
name|b
argument_list|)
condition|)
block|{
if|if
condition|(
name|iszero
argument_list|(
name|a
argument_list|)
condition|)
block|{
operator|*
name|tmp
operator|=
operator|*
name|a
expr_stmt|;
name|tmp
operator|->
name|sign
operator|=
name|a
operator|->
name|sign
operator|&
name|b
operator|->
name|sign
expr_stmt|;
return|return
name|tmp
return|;
block|}
return|return
name|a
return|;
block|}
if|if
condition|(
name|iszero
argument_list|(
name|a
argument_list|)
condition|)
block|{
return|return
name|b
return|;
block|}
comment|/* Got two numbers. shift the smaller and increment the exponent till      they're the same */
block|{
name|int
name|diff
decl_stmt|;
name|a_normal_exp
operator|=
name|a
operator|->
name|normal_exp
expr_stmt|;
name|b_normal_exp
operator|=
name|b
operator|->
name|normal_exp
expr_stmt|;
name|a_fraction
operator|=
name|a
operator|->
name|fraction
operator|.
name|ll
expr_stmt|;
name|b_fraction
operator|=
name|b
operator|->
name|fraction
operator|.
name|ll
expr_stmt|;
name|diff
operator|=
name|a_normal_exp
operator|-
name|b_normal_exp
expr_stmt|;
if|if
condition|(
name|diff
operator|<
literal|0
condition|)
name|diff
operator|=
operator|-
name|diff
expr_stmt|;
if|if
condition|(
name|diff
operator|<
name|FRAC_NBITS
condition|)
block|{
comment|/* ??? This does shifts one bit at a time.  Optimize.  */
while|while
condition|(
name|a_normal_exp
operator|>
name|b_normal_exp
condition|)
block|{
name|b_normal_exp
operator|++
expr_stmt|;
name|LSHIFT
argument_list|(
name|b_fraction
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|b_normal_exp
operator|>
name|a_normal_exp
condition|)
block|{
name|a_normal_exp
operator|++
expr_stmt|;
name|LSHIFT
argument_list|(
name|a_fraction
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Somethings's up.. choose the biggest */
if|if
condition|(
name|a_normal_exp
operator|>
name|b_normal_exp
condition|)
block|{
name|b_normal_exp
operator|=
name|a_normal_exp
expr_stmt|;
name|b_fraction
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|a_normal_exp
operator|=
name|b_normal_exp
expr_stmt|;
name|a_fraction
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|a
operator|->
name|sign
operator|!=
name|b
operator|->
name|sign
condition|)
block|{
if|if
condition|(
name|a
operator|->
name|sign
condition|)
block|{
name|tfraction
operator|=
operator|-
name|a_fraction
operator|+
name|b_fraction
expr_stmt|;
block|}
else|else
block|{
name|tfraction
operator|=
name|a_fraction
operator|-
name|b_fraction
expr_stmt|;
block|}
if|if
condition|(
name|tfraction
operator|>=
literal|0
condition|)
block|{
name|tmp
operator|->
name|sign
operator|=
literal|0
expr_stmt|;
name|tmp
operator|->
name|normal_exp
operator|=
name|a_normal_exp
expr_stmt|;
name|tmp
operator|->
name|fraction
operator|.
name|ll
operator|=
name|tfraction
expr_stmt|;
block|}
else|else
block|{
name|tmp
operator|->
name|sign
operator|=
literal|1
expr_stmt|;
name|tmp
operator|->
name|normal_exp
operator|=
name|a_normal_exp
expr_stmt|;
name|tmp
operator|->
name|fraction
operator|.
name|ll
operator|=
operator|-
name|tfraction
expr_stmt|;
block|}
comment|/* and renormalize it */
while|while
condition|(
name|tmp
operator|->
name|fraction
operator|.
name|ll
operator|<
name|IMPLICIT_1
operator|&&
name|tmp
operator|->
name|fraction
operator|.
name|ll
condition|)
block|{
name|tmp
operator|->
name|fraction
operator|.
name|ll
operator|<<=
literal|1
expr_stmt|;
name|tmp
operator|->
name|normal_exp
operator|--
expr_stmt|;
block|}
block|}
else|else
block|{
name|tmp
operator|->
name|sign
operator|=
name|a
operator|->
name|sign
expr_stmt|;
name|tmp
operator|->
name|normal_exp
operator|=
name|a_normal_exp
expr_stmt|;
name|tmp
operator|->
name|fraction
operator|.
name|ll
operator|=
name|a_fraction
operator|+
name|b_fraction
expr_stmt|;
block|}
name|tmp
operator|->
name|class
operator|=
name|CLASS_NUMBER
expr_stmt|;
comment|/* Now the fraction is added, we have to shift down to renormalize the      number */
if|if
condition|(
name|tmp
operator|->
name|fraction
operator|.
name|ll
operator|>=
name|IMPLICIT_2
condition|)
block|{
name|LSHIFT
argument_list|(
name|tmp
operator|->
name|fraction
operator|.
name|ll
argument_list|)
expr_stmt|;
name|tmp
operator|->
name|normal_exp
operator|++
expr_stmt|;
block|}
return|return
name|tmp
return|;
block|}
end_function

begin_function
name|FLO_type
name|add
parameter_list|(
name|FLO_type
name|arg_a
parameter_list|,
name|FLO_type
name|arg_b
parameter_list|)
block|{
name|fp_number_type
name|a
decl_stmt|;
name|fp_number_type
name|b
decl_stmt|;
name|fp_number_type
name|tmp
decl_stmt|;
name|fp_number_type
modifier|*
name|res
decl_stmt|;
name|FLO_union_type
name|au
decl_stmt|,
name|bu
decl_stmt|;
name|au
operator|.
name|value
operator|=
name|arg_a
expr_stmt|;
name|bu
operator|.
name|value
operator|=
name|arg_b
expr_stmt|;
name|unpack_d
argument_list|(
operator|&
name|au
argument_list|,
operator|&
name|a
argument_list|)
expr_stmt|;
name|unpack_d
argument_list|(
operator|&
name|bu
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
name|res
operator|=
name|_fpadd_parts
argument_list|(
operator|&
name|a
argument_list|,
operator|&
name|b
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
return|return
name|pack_d
argument_list|(
name|res
argument_list|)
return|;
block|}
end_function

begin_function
name|FLO_type
name|sub
parameter_list|(
name|FLO_type
name|arg_a
parameter_list|,
name|FLO_type
name|arg_b
parameter_list|)
block|{
name|fp_number_type
name|a
decl_stmt|;
name|fp_number_type
name|b
decl_stmt|;
name|fp_number_type
name|tmp
decl_stmt|;
name|fp_number_type
modifier|*
name|res
decl_stmt|;
name|FLO_union_type
name|au
decl_stmt|,
name|bu
decl_stmt|;
name|au
operator|.
name|value
operator|=
name|arg_a
expr_stmt|;
name|bu
operator|.
name|value
operator|=
name|arg_b
expr_stmt|;
name|unpack_d
argument_list|(
operator|&
name|au
argument_list|,
operator|&
name|a
argument_list|)
expr_stmt|;
name|unpack_d
argument_list|(
operator|&
name|bu
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
name|b
operator|.
name|sign
operator|^=
literal|1
expr_stmt|;
name|res
operator|=
name|_fpadd_parts
argument_list|(
operator|&
name|a
argument_list|,
operator|&
name|b
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
return|return
name|pack_d
argument_list|(
name|res
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* L_addsub_sf || L_addsub_df */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_mul_sf
argument_list|)
operator|||
name|defined
argument_list|(
name|L_mul_df
argument_list|)
operator|||
name|defined
argument_list|(
name|L_mul_tf
argument_list|)
end_if

begin_expr_stmt
specifier|static
specifier|inline
name|__attribute__
argument_list|(
argument|(__always_inline__)
argument_list|)
name|fp_number_type
operator|*
name|_fpmul_parts
argument_list|(
argument|fp_number_type *  a
argument_list|,
argument|fp_number_type *  b
argument_list|,
argument|fp_number_type * tmp
argument_list|)
block|{
name|fractype
name|low
operator|=
literal|0
block|;
name|fractype
name|high
operator|=
literal|0
block|;
if|if
condition|(
name|isnan
argument_list|(
name|a
argument_list|)
condition|)
block|{
name|a
operator|->
name|sign
operator|=
name|a
operator|->
name|sign
operator|!=
name|b
operator|->
name|sign
expr_stmt|;
return|return
name|a
return|;
block|}
end_expr_stmt

begin_if
if|if
condition|(
name|isnan
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|b
operator|->
name|sign
operator|=
name|a
operator|->
name|sign
operator|!=
name|b
operator|->
name|sign
expr_stmt|;
return|return
name|b
return|;
block|}
end_if

begin_if
if|if
condition|(
name|isinf
argument_list|(
name|a
argument_list|)
condition|)
block|{
if|if
condition|(
name|iszero
argument_list|(
name|b
argument_list|)
condition|)
return|return
name|nan
argument_list|()
return|;
name|a
operator|->
name|sign
operator|=
name|a
operator|->
name|sign
operator|!=
name|b
operator|->
name|sign
expr_stmt|;
return|return
name|a
return|;
block|}
end_if

begin_if
if|if
condition|(
name|isinf
argument_list|(
name|b
argument_list|)
condition|)
block|{
if|if
condition|(
name|iszero
argument_list|(
name|a
argument_list|)
condition|)
block|{
return|return
name|nan
argument_list|()
return|;
block|}
name|b
operator|->
name|sign
operator|=
name|a
operator|->
name|sign
operator|!=
name|b
operator|->
name|sign
expr_stmt|;
return|return
name|b
return|;
block|}
end_if

begin_if
if|if
condition|(
name|iszero
argument_list|(
name|a
argument_list|)
condition|)
block|{
name|a
operator|->
name|sign
operator|=
name|a
operator|->
name|sign
operator|!=
name|b
operator|->
name|sign
expr_stmt|;
return|return
name|a
return|;
block|}
end_if

begin_if
if|if
condition|(
name|iszero
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|b
operator|->
name|sign
operator|=
name|a
operator|->
name|sign
operator|!=
name|b
operator|->
name|sign
expr_stmt|;
return|return
name|b
return|;
block|}
end_if

begin_comment
comment|/* Calculate the mantissa by multiplying both numbers to get a      twice-as-wide number.  */
end_comment

begin_block
block|{
if|#
directive|if
name|defined
argument_list|(
name|NO_DI_MODE
argument_list|)
operator|||
name|defined
argument_list|(
name|TFLOAT
argument_list|)
block|{
name|fractype
name|x
init|=
name|a
operator|->
name|fraction
operator|.
name|ll
decl_stmt|;
name|fractype
name|ylow
init|=
name|b
operator|->
name|fraction
operator|.
name|ll
decl_stmt|;
name|fractype
name|yhigh
init|=
literal|0
decl_stmt|;
name|int
name|bit
decl_stmt|;
comment|/* ??? This does multiplies one bit at a time.  Optimize.  */
for|for
control|(
name|bit
operator|=
literal|0
init|;
name|bit
operator|<
name|FRAC_NBITS
condition|;
name|bit
operator|++
control|)
block|{
name|int
name|carry
decl_stmt|;
if|if
condition|(
name|x
operator|&
literal|1
condition|)
block|{
name|carry
operator|=
operator|(
name|low
operator|+=
name|ylow
operator|)
operator|<
name|ylow
expr_stmt|;
name|high
operator|+=
name|yhigh
operator|+
name|carry
expr_stmt|;
block|}
name|yhigh
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|ylow
operator|&
name|FRACHIGH
condition|)
block|{
name|yhigh
operator||=
literal|1
expr_stmt|;
block|}
name|ylow
operator|<<=
literal|1
expr_stmt|;
name|x
operator|>>=
literal|1
expr_stmt|;
block|}
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|FLOAT
argument_list|)
comment|/* Multiplying two USIs to get a UDI, we're safe.  */
block|{
name|UDItype
name|answer
init|=
operator|(
name|UDItype
operator|)
name|a
operator|->
name|fraction
operator|.
name|ll
operator|*
operator|(
name|UDItype
operator|)
name|b
operator|->
name|fraction
operator|.
name|ll
decl_stmt|;
name|high
operator|=
name|answer
operator|>>
name|BITS_PER_SI
expr_stmt|;
name|low
operator|=
name|answer
expr_stmt|;
block|}
else|#
directive|else
comment|/* fractype is DImode, but we need the result to be twice as wide.        Assuming a widening multiply from DImode to TImode is not        available, build one by hand.  */
block|{
name|USItype
name|nl
init|=
name|a
operator|->
name|fraction
operator|.
name|ll
decl_stmt|;
name|USItype
name|nh
init|=
name|a
operator|->
name|fraction
operator|.
name|ll
operator|>>
name|BITS_PER_SI
decl_stmt|;
name|USItype
name|ml
init|=
name|b
operator|->
name|fraction
operator|.
name|ll
decl_stmt|;
name|USItype
name|mh
init|=
name|b
operator|->
name|fraction
operator|.
name|ll
operator|>>
name|BITS_PER_SI
decl_stmt|;
name|UDItype
name|pp_ll
init|=
operator|(
name|UDItype
operator|)
name|ml
operator|*
name|nl
decl_stmt|;
name|UDItype
name|pp_hl
init|=
operator|(
name|UDItype
operator|)
name|mh
operator|*
name|nl
decl_stmt|;
name|UDItype
name|pp_lh
init|=
operator|(
name|UDItype
operator|)
name|ml
operator|*
name|nh
decl_stmt|;
name|UDItype
name|pp_hh
init|=
operator|(
name|UDItype
operator|)
name|mh
operator|*
name|nh
decl_stmt|;
name|UDItype
name|res2
init|=
literal|0
decl_stmt|;
name|UDItype
name|res0
init|=
literal|0
decl_stmt|;
name|UDItype
name|ps_hh__
init|=
name|pp_hl
operator|+
name|pp_lh
decl_stmt|;
if|if
condition|(
name|ps_hh__
operator|<
name|pp_hl
condition|)
name|res2
operator|+=
operator|(
name|UDItype
operator|)
literal|1
operator|<<
name|BITS_PER_SI
expr_stmt|;
name|pp_hl
operator|=
operator|(
name|UDItype
operator|)
operator|(
name|USItype
operator|)
name|ps_hh__
operator|<<
name|BITS_PER_SI
expr_stmt|;
name|res0
operator|=
name|pp_ll
operator|+
name|pp_hl
expr_stmt|;
if|if
condition|(
name|res0
operator|<
name|pp_ll
condition|)
name|res2
operator|++
expr_stmt|;
name|res2
operator|+=
operator|(
name|ps_hh__
operator|>>
name|BITS_PER_SI
operator|)
operator|+
name|pp_hh
expr_stmt|;
name|high
operator|=
name|res2
expr_stmt|;
name|low
operator|=
name|res0
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_block

begin_expr_stmt
name|tmp
operator|->
name|normal_exp
operator|=
name|a
operator|->
name|normal_exp
operator|+
name|b
operator|->
name|normal_exp
operator|+
name|FRAC_NBITS
operator|-
operator|(
name|FRACBITS
operator|+
name|NGARDS
operator|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|tmp
operator|->
name|sign
operator|=
name|a
operator|->
name|sign
operator|!=
name|b
operator|->
name|sign
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
name|high
operator|>=
name|IMPLICIT_2
condition|)
block|{
name|tmp
operator|->
name|normal_exp
operator|++
expr_stmt|;
if|if
condition|(
name|high
operator|&
literal|1
condition|)
block|{
name|low
operator|>>=
literal|1
expr_stmt|;
name|low
operator||=
name|FRACHIGH
expr_stmt|;
block|}
name|high
operator|>>=
literal|1
expr_stmt|;
block|}
end_while

begin_while
while|while
condition|(
name|high
operator|<
name|IMPLICIT_1
condition|)
block|{
name|tmp
operator|->
name|normal_exp
operator|--
expr_stmt|;
name|high
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|low
operator|&
name|FRACHIGH
condition|)
name|high
operator||=
literal|1
expr_stmt|;
name|low
operator|<<=
literal|1
expr_stmt|;
block|}
end_while

begin_comment
comment|/* rounding is tricky. if we only round if it won't make us round later.  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|if (low& FRACHIGH2)     {       if (((high& GARDMASK) != GARDMSB)&& (((high + 1)& GARDMASK) == GARDMSB)) 	{
comment|/* don't round, it gets done again later.  */
end_comment

begin_endif
unit|}       else 	{ 	  high++; 	}     }
endif|#
directive|endif
end_endif

begin_if
if|if
condition|(
operator|!
name|ROUND_TOWARDS_ZERO
operator|&&
operator|(
name|high
operator|&
name|GARDMASK
operator|)
operator|==
name|GARDMSB
condition|)
block|{
if|if
condition|(
name|high
operator|&
operator|(
literal|1
operator|<<
name|NGARDS
operator|)
condition|)
block|{
comment|/* half way, so round to even */
name|high
operator|+=
name|GARDROUND
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|low
condition|)
block|{
comment|/* but we really weren't half way */
name|high
operator|+=
name|GARDROUND
operator|+
literal|1
expr_stmt|;
block|}
block|}
end_if

begin_expr_stmt
name|tmp
operator|->
name|fraction
operator|.
name|ll
operator|=
name|high
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|tmp
operator|->
name|class
operator|=
name|CLASS_NUMBER
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|tmp
return|;
end_return

begin_macro
unit|}  FLO_type
name|multiply
argument_list|(
argument|FLO_type arg_a
argument_list|,
argument|FLO_type arg_b
argument_list|)
end_macro

begin_block
block|{
name|fp_number_type
name|a
decl_stmt|;
name|fp_number_type
name|b
decl_stmt|;
name|fp_number_type
name|tmp
decl_stmt|;
name|fp_number_type
modifier|*
name|res
decl_stmt|;
name|FLO_union_type
name|au
decl_stmt|,
name|bu
decl_stmt|;
name|au
operator|.
name|value
operator|=
name|arg_a
expr_stmt|;
name|bu
operator|.
name|value
operator|=
name|arg_b
expr_stmt|;
name|unpack_d
argument_list|(
operator|&
name|au
argument_list|,
operator|&
name|a
argument_list|)
expr_stmt|;
name|unpack_d
argument_list|(
operator|&
name|bu
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
name|res
operator|=
name|_fpmul_parts
argument_list|(
operator|&
name|a
argument_list|,
operator|&
name|b
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
return|return
name|pack_d
argument_list|(
name|res
argument_list|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* L_mul_sf || L_mul_df */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_div_sf
argument_list|)
operator|||
name|defined
argument_list|(
name|L_div_df
argument_list|)
operator|||
name|defined
argument_list|(
name|L_div_tf
argument_list|)
end_if

begin_expr_stmt
specifier|static
specifier|inline
name|__attribute__
argument_list|(
argument|(__always_inline__)
argument_list|)
name|fp_number_type
operator|*
name|_fpdiv_parts
argument_list|(
argument|fp_number_type * a
argument_list|,
argument|fp_number_type * b
argument_list|)
block|{
name|fractype
name|bit
block|;
name|fractype
name|numerator
block|;
name|fractype
name|denominator
block|;
name|fractype
name|quotient
block|;
if|if
condition|(
name|isnan
argument_list|(
name|a
argument_list|)
condition|)
block|{
return|return
name|a
return|;
block|}
end_expr_stmt

begin_if
if|if
condition|(
name|isnan
argument_list|(
name|b
argument_list|)
condition|)
block|{
return|return
name|b
return|;
block|}
end_if

begin_expr_stmt
name|a
operator|->
name|sign
operator|=
name|a
operator|->
name|sign
operator|^
name|b
operator|->
name|sign
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|isinf
argument_list|(
name|a
argument_list|)
operator|||
name|iszero
argument_list|(
name|a
argument_list|)
condition|)
block|{
if|if
condition|(
name|a
operator|->
name|class
operator|==
name|b
operator|->
name|class
condition|)
return|return
name|nan
argument_list|()
return|;
return|return
name|a
return|;
block|}
end_if

begin_if
if|if
condition|(
name|isinf
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|a
operator|->
name|fraction
operator|.
name|ll
operator|=
literal|0
expr_stmt|;
name|a
operator|->
name|normal_exp
operator|=
literal|0
expr_stmt|;
return|return
name|a
return|;
block|}
end_if

begin_if
if|if
condition|(
name|iszero
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|a
operator|->
name|class
operator|=
name|CLASS_INFINITY
expr_stmt|;
return|return
name|a
return|;
block|}
end_if

begin_comment
comment|/* Calculate the mantissa by multiplying both 64bit numbers to get a      128 bit number */
end_comment

begin_block
block|{
comment|/* quotient =        ( numerator / denominator) * 2^(numerator exponent -  denominator exponent)      */
name|a
operator|->
name|normal_exp
operator|=
name|a
operator|->
name|normal_exp
operator|-
name|b
operator|->
name|normal_exp
expr_stmt|;
name|numerator
operator|=
name|a
operator|->
name|fraction
operator|.
name|ll
expr_stmt|;
name|denominator
operator|=
name|b
operator|->
name|fraction
operator|.
name|ll
expr_stmt|;
if|if
condition|(
name|numerator
operator|<
name|denominator
condition|)
block|{
comment|/* Fraction will be less than 1.0 */
name|numerator
operator|*=
literal|2
expr_stmt|;
name|a
operator|->
name|normal_exp
operator|--
expr_stmt|;
block|}
name|bit
operator|=
name|IMPLICIT_1
expr_stmt|;
name|quotient
operator|=
literal|0
expr_stmt|;
comment|/* ??? Does divide one bit at a time.  Optimize.  */
while|while
condition|(
name|bit
condition|)
block|{
if|if
condition|(
name|numerator
operator|>=
name|denominator
condition|)
block|{
name|quotient
operator||=
name|bit
expr_stmt|;
name|numerator
operator|-=
name|denominator
expr_stmt|;
block|}
name|bit
operator|>>=
literal|1
expr_stmt|;
name|numerator
operator|*=
literal|2
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ROUND_TOWARDS_ZERO
operator|&&
operator|(
name|quotient
operator|&
name|GARDMASK
operator|)
operator|==
name|GARDMSB
condition|)
block|{
if|if
condition|(
name|quotient
operator|&
operator|(
literal|1
operator|<<
name|NGARDS
operator|)
condition|)
block|{
comment|/* half way, so round to even */
name|quotient
operator|+=
name|GARDROUND
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|numerator
condition|)
block|{
comment|/* but we really weren't half way, more bits exist */
name|quotient
operator|+=
name|GARDROUND
operator|+
literal|1
expr_stmt|;
block|}
block|}
name|a
operator|->
name|fraction
operator|.
name|ll
operator|=
name|quotient
expr_stmt|;
return|return
operator|(
name|a
operator|)
return|;
block|}
end_block

begin_macro
unit|}  FLO_type
name|divide
argument_list|(
argument|FLO_type arg_a
argument_list|,
argument|FLO_type arg_b
argument_list|)
end_macro

begin_block
block|{
name|fp_number_type
name|a
decl_stmt|;
name|fp_number_type
name|b
decl_stmt|;
name|fp_number_type
modifier|*
name|res
decl_stmt|;
name|FLO_union_type
name|au
decl_stmt|,
name|bu
decl_stmt|;
name|au
operator|.
name|value
operator|=
name|arg_a
expr_stmt|;
name|bu
operator|.
name|value
operator|=
name|arg_b
expr_stmt|;
name|unpack_d
argument_list|(
operator|&
name|au
argument_list|,
operator|&
name|a
argument_list|)
expr_stmt|;
name|unpack_d
argument_list|(
operator|&
name|bu
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
name|res
operator|=
name|_fpdiv_parts
argument_list|(
operator|&
name|a
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
return|return
name|pack_d
argument_list|(
name|res
argument_list|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* L_div_sf || L_div_df */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_fpcmp_parts_sf
argument_list|)
operator|||
name|defined
argument_list|(
name|L_fpcmp_parts_df
argument_list|)
expr|\
operator|||
name|defined
argument_list|(
name|L_fpcmp_parts_tf
argument_list|)
end_if

begin_comment
comment|/* according to the demo, fpcmp returns a comparison with 0... thus    a<b -> -1    a==b -> 0    a>b -> +1  */
end_comment

begin_function
name|int
name|__fpcmp_parts
parameter_list|(
name|fp_number_type
modifier|*
name|a
parameter_list|,
name|fp_number_type
modifier|*
name|b
parameter_list|)
block|{
if|#
directive|if
literal|0
comment|/* either nan -> unordered. Must be checked outside of this routine.  */
block|if (isnan (a)&& isnan (b))     {       return 1;
comment|/* still unordered! */
block|}
endif|#
directive|endif
if|if
condition|(
name|isnan
argument_list|(
name|a
argument_list|)
operator|||
name|isnan
argument_list|(
name|b
argument_list|)
condition|)
block|{
return|return
literal|1
return|;
comment|/* how to indicate unordered compare? */
block|}
if|if
condition|(
name|isinf
argument_list|(
name|a
argument_list|)
operator|&&
name|isinf
argument_list|(
name|b
argument_list|)
condition|)
block|{
comment|/* +inf> -inf, but +inf != +inf */
comment|/* b    \a| +inf(0)| -inf(1)        ______\+--------+--------        +inf(0)| a==b(0)| a<b(-1)        -------+--------+--------        -inf(1)| a>b(1) | a==b(0)        -------+--------+--------        So since unordered must be nonzero, just line up the columns...        */
return|return
name|b
operator|->
name|sign
operator|-
name|a
operator|->
name|sign
return|;
block|}
comment|/* but not both...  */
if|if
condition|(
name|isinf
argument_list|(
name|a
argument_list|)
condition|)
block|{
return|return
name|a
operator|->
name|sign
condition|?
operator|-
literal|1
else|:
literal|1
return|;
block|}
if|if
condition|(
name|isinf
argument_list|(
name|b
argument_list|)
condition|)
block|{
return|return
name|b
operator|->
name|sign
condition|?
literal|1
else|:
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|iszero
argument_list|(
name|a
argument_list|)
operator|&&
name|iszero
argument_list|(
name|b
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
name|iszero
argument_list|(
name|a
argument_list|)
condition|)
block|{
return|return
name|b
operator|->
name|sign
condition|?
literal|1
else|:
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|iszero
argument_list|(
name|b
argument_list|)
condition|)
block|{
return|return
name|a
operator|->
name|sign
condition|?
operator|-
literal|1
else|:
literal|1
return|;
block|}
comment|/* now both are "normal".  */
if|if
condition|(
name|a
operator|->
name|sign
operator|!=
name|b
operator|->
name|sign
condition|)
block|{
comment|/* opposite signs */
return|return
name|a
operator|->
name|sign
condition|?
operator|-
literal|1
else|:
literal|1
return|;
block|}
comment|/* same sign; exponents? */
if|if
condition|(
name|a
operator|->
name|normal_exp
operator|>
name|b
operator|->
name|normal_exp
condition|)
block|{
return|return
name|a
operator|->
name|sign
condition|?
operator|-
literal|1
else|:
literal|1
return|;
block|}
if|if
condition|(
name|a
operator|->
name|normal_exp
operator|<
name|b
operator|->
name|normal_exp
condition|)
block|{
return|return
name|a
operator|->
name|sign
condition|?
literal|1
else|:
operator|-
literal|1
return|;
block|}
comment|/* same exponents; check size.  */
if|if
condition|(
name|a
operator|->
name|fraction
operator|.
name|ll
operator|>
name|b
operator|->
name|fraction
operator|.
name|ll
condition|)
block|{
return|return
name|a
operator|->
name|sign
condition|?
operator|-
literal|1
else|:
literal|1
return|;
block|}
if|if
condition|(
name|a
operator|->
name|fraction
operator|.
name|ll
operator|<
name|b
operator|->
name|fraction
operator|.
name|ll
condition|)
block|{
return|return
name|a
operator|->
name|sign
condition|?
literal|1
else|:
operator|-
literal|1
return|;
block|}
comment|/* after all that, they're equal.  */
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_compare_sf
argument_list|)
operator|||
name|defined
argument_list|(
name|L_compare_df
argument_list|)
operator|||
name|defined
argument_list|(
name|L_compoare_tf
argument_list|)
end_if

begin_function
name|CMPtype
name|compare
parameter_list|(
name|FLO_type
name|arg_a
parameter_list|,
name|FLO_type
name|arg_b
parameter_list|)
block|{
name|fp_number_type
name|a
decl_stmt|;
name|fp_number_type
name|b
decl_stmt|;
name|FLO_union_type
name|au
decl_stmt|,
name|bu
decl_stmt|;
name|au
operator|.
name|value
operator|=
name|arg_a
expr_stmt|;
name|bu
operator|.
name|value
operator|=
name|arg_b
expr_stmt|;
name|unpack_d
argument_list|(
operator|&
name|au
argument_list|,
operator|&
name|a
argument_list|)
expr_stmt|;
name|unpack_d
argument_list|(
operator|&
name|bu
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
return|return
name|__fpcmp_parts
argument_list|(
operator|&
name|a
argument_list|,
operator|&
name|b
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* L_compare_sf || L_compare_df */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|US_SOFTWARE_GOFAST
end_ifndef

begin_comment
comment|/* These should be optimized for their specific tasks someday.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_eq_sf
argument_list|)
operator|||
name|defined
argument_list|(
name|L_eq_df
argument_list|)
operator|||
name|defined
argument_list|(
name|L_eq_tf
argument_list|)
end_if

begin_function
name|CMPtype
name|_eq_f2
parameter_list|(
name|FLO_type
name|arg_a
parameter_list|,
name|FLO_type
name|arg_b
parameter_list|)
block|{
name|fp_number_type
name|a
decl_stmt|;
name|fp_number_type
name|b
decl_stmt|;
name|FLO_union_type
name|au
decl_stmt|,
name|bu
decl_stmt|;
name|au
operator|.
name|value
operator|=
name|arg_a
expr_stmt|;
name|bu
operator|.
name|value
operator|=
name|arg_b
expr_stmt|;
name|unpack_d
argument_list|(
operator|&
name|au
argument_list|,
operator|&
name|a
argument_list|)
expr_stmt|;
name|unpack_d
argument_list|(
operator|&
name|bu
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|isnan
argument_list|(
operator|&
name|a
argument_list|)
operator|||
name|isnan
argument_list|(
operator|&
name|b
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* false, truth == 0 */
return|return
name|__fpcmp_parts
argument_list|(
operator|&
name|a
argument_list|,
operator|&
name|b
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* L_eq_sf || L_eq_df */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_ne_sf
argument_list|)
operator|||
name|defined
argument_list|(
name|L_ne_df
argument_list|)
operator|||
name|defined
argument_list|(
name|L_ne_tf
argument_list|)
end_if

begin_function
name|CMPtype
name|_ne_f2
parameter_list|(
name|FLO_type
name|arg_a
parameter_list|,
name|FLO_type
name|arg_b
parameter_list|)
block|{
name|fp_number_type
name|a
decl_stmt|;
name|fp_number_type
name|b
decl_stmt|;
name|FLO_union_type
name|au
decl_stmt|,
name|bu
decl_stmt|;
name|au
operator|.
name|value
operator|=
name|arg_a
expr_stmt|;
name|bu
operator|.
name|value
operator|=
name|arg_b
expr_stmt|;
name|unpack_d
argument_list|(
operator|&
name|au
argument_list|,
operator|&
name|a
argument_list|)
expr_stmt|;
name|unpack_d
argument_list|(
operator|&
name|bu
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|isnan
argument_list|(
operator|&
name|a
argument_list|)
operator|||
name|isnan
argument_list|(
operator|&
name|b
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* true, truth != 0 */
return|return
name|__fpcmp_parts
argument_list|(
operator|&
name|a
argument_list|,
operator|&
name|b
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* L_ne_sf || L_ne_df */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_gt_sf
argument_list|)
operator|||
name|defined
argument_list|(
name|L_gt_df
argument_list|)
operator|||
name|defined
argument_list|(
name|L_gt_tf
argument_list|)
end_if

begin_function
name|CMPtype
name|_gt_f2
parameter_list|(
name|FLO_type
name|arg_a
parameter_list|,
name|FLO_type
name|arg_b
parameter_list|)
block|{
name|fp_number_type
name|a
decl_stmt|;
name|fp_number_type
name|b
decl_stmt|;
name|FLO_union_type
name|au
decl_stmt|,
name|bu
decl_stmt|;
name|au
operator|.
name|value
operator|=
name|arg_a
expr_stmt|;
name|bu
operator|.
name|value
operator|=
name|arg_b
expr_stmt|;
name|unpack_d
argument_list|(
operator|&
name|au
argument_list|,
operator|&
name|a
argument_list|)
expr_stmt|;
name|unpack_d
argument_list|(
operator|&
name|bu
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|isnan
argument_list|(
operator|&
name|a
argument_list|)
operator|||
name|isnan
argument_list|(
operator|&
name|b
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* false, truth> 0 */
return|return
name|__fpcmp_parts
argument_list|(
operator|&
name|a
argument_list|,
operator|&
name|b
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* L_gt_sf || L_gt_df */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_ge_sf
argument_list|)
operator|||
name|defined
argument_list|(
name|L_ge_df
argument_list|)
operator|||
name|defined
argument_list|(
name|L_ge_tf
argument_list|)
end_if

begin_function
name|CMPtype
name|_ge_f2
parameter_list|(
name|FLO_type
name|arg_a
parameter_list|,
name|FLO_type
name|arg_b
parameter_list|)
block|{
name|fp_number_type
name|a
decl_stmt|;
name|fp_number_type
name|b
decl_stmt|;
name|FLO_union_type
name|au
decl_stmt|,
name|bu
decl_stmt|;
name|au
operator|.
name|value
operator|=
name|arg_a
expr_stmt|;
name|bu
operator|.
name|value
operator|=
name|arg_b
expr_stmt|;
name|unpack_d
argument_list|(
operator|&
name|au
argument_list|,
operator|&
name|a
argument_list|)
expr_stmt|;
name|unpack_d
argument_list|(
operator|&
name|bu
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|isnan
argument_list|(
operator|&
name|a
argument_list|)
operator|||
name|isnan
argument_list|(
operator|&
name|b
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* false, truth>= 0 */
return|return
name|__fpcmp_parts
argument_list|(
operator|&
name|a
argument_list|,
operator|&
name|b
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* L_ge_sf || L_ge_df */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_lt_sf
argument_list|)
operator|||
name|defined
argument_list|(
name|L_lt_df
argument_list|)
operator|||
name|defined
argument_list|(
name|L_lt_tf
argument_list|)
end_if

begin_function
name|CMPtype
name|_lt_f2
parameter_list|(
name|FLO_type
name|arg_a
parameter_list|,
name|FLO_type
name|arg_b
parameter_list|)
block|{
name|fp_number_type
name|a
decl_stmt|;
name|fp_number_type
name|b
decl_stmt|;
name|FLO_union_type
name|au
decl_stmt|,
name|bu
decl_stmt|;
name|au
operator|.
name|value
operator|=
name|arg_a
expr_stmt|;
name|bu
operator|.
name|value
operator|=
name|arg_b
expr_stmt|;
name|unpack_d
argument_list|(
operator|&
name|au
argument_list|,
operator|&
name|a
argument_list|)
expr_stmt|;
name|unpack_d
argument_list|(
operator|&
name|bu
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|isnan
argument_list|(
operator|&
name|a
argument_list|)
operator|||
name|isnan
argument_list|(
operator|&
name|b
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* false, truth< 0 */
return|return
name|__fpcmp_parts
argument_list|(
operator|&
name|a
argument_list|,
operator|&
name|b
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* L_lt_sf || L_lt_df */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_le_sf
argument_list|)
operator|||
name|defined
argument_list|(
name|L_le_df
argument_list|)
operator|||
name|defined
argument_list|(
name|L_le_tf
argument_list|)
end_if

begin_function
name|CMPtype
name|_le_f2
parameter_list|(
name|FLO_type
name|arg_a
parameter_list|,
name|FLO_type
name|arg_b
parameter_list|)
block|{
name|fp_number_type
name|a
decl_stmt|;
name|fp_number_type
name|b
decl_stmt|;
name|FLO_union_type
name|au
decl_stmt|,
name|bu
decl_stmt|;
name|au
operator|.
name|value
operator|=
name|arg_a
expr_stmt|;
name|bu
operator|.
name|value
operator|=
name|arg_b
expr_stmt|;
name|unpack_d
argument_list|(
operator|&
name|au
argument_list|,
operator|&
name|a
argument_list|)
expr_stmt|;
name|unpack_d
argument_list|(
operator|&
name|bu
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|isnan
argument_list|(
operator|&
name|a
argument_list|)
operator|||
name|isnan
argument_list|(
operator|&
name|b
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* false, truth<= 0 */
return|return
name|__fpcmp_parts
argument_list|(
operator|&
name|a
argument_list|,
operator|&
name|b
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* L_le_sf || L_le_df */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! US_SOFTWARE_GOFAST */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_unord_sf
argument_list|)
operator|||
name|defined
argument_list|(
name|L_unord_df
argument_list|)
operator|||
name|defined
argument_list|(
name|L_unord_tf
argument_list|)
end_if

begin_function
name|CMPtype
name|_unord_f2
parameter_list|(
name|FLO_type
name|arg_a
parameter_list|,
name|FLO_type
name|arg_b
parameter_list|)
block|{
name|fp_number_type
name|a
decl_stmt|;
name|fp_number_type
name|b
decl_stmt|;
name|FLO_union_type
name|au
decl_stmt|,
name|bu
decl_stmt|;
name|au
operator|.
name|value
operator|=
name|arg_a
expr_stmt|;
name|bu
operator|.
name|value
operator|=
name|arg_b
expr_stmt|;
name|unpack_d
argument_list|(
operator|&
name|au
argument_list|,
operator|&
name|a
argument_list|)
expr_stmt|;
name|unpack_d
argument_list|(
operator|&
name|bu
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
return|return
operator|(
name|isnan
argument_list|(
operator|&
name|a
argument_list|)
operator|||
name|isnan
argument_list|(
operator|&
name|b
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* L_unord_sf || L_unord_df */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_si_to_sf
argument_list|)
operator|||
name|defined
argument_list|(
name|L_si_to_df
argument_list|)
operator|||
name|defined
argument_list|(
name|L_si_to_tf
argument_list|)
end_if

begin_function
name|FLO_type
name|si_to_float
parameter_list|(
name|SItype
name|arg_a
parameter_list|)
block|{
name|fp_number_type
name|in
decl_stmt|;
name|in
operator|.
name|class
operator|=
name|CLASS_NUMBER
expr_stmt|;
name|in
operator|.
name|sign
operator|=
name|arg_a
operator|<
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|arg_a
condition|)
block|{
name|in
operator|.
name|class
operator|=
name|CLASS_ZERO
expr_stmt|;
block|}
else|else
block|{
name|in
operator|.
name|normal_exp
operator|=
name|FRACBITS
operator|+
name|NGARDS
expr_stmt|;
if|if
condition|(
name|in
operator|.
name|sign
condition|)
block|{
comment|/* Special case for minint, since there is no +ve integer 	     representation for it */
if|if
condition|(
name|arg_a
operator|==
operator|(
operator|-
name|MAX_SI_INT
operator|-
literal|1
operator|)
condition|)
block|{
return|return
call|(
name|FLO_type
call|)
argument_list|(
operator|-
name|MAX_SI_INT
operator|-
literal|1
argument_list|)
return|;
block|}
name|in
operator|.
name|fraction
operator|.
name|ll
operator|=
operator|(
operator|-
name|arg_a
operator|)
expr_stmt|;
block|}
else|else
name|in
operator|.
name|fraction
operator|.
name|ll
operator|=
name|arg_a
expr_stmt|;
while|while
condition|(
name|in
operator|.
name|fraction
operator|.
name|ll
operator|<
operator|(
operator|(
name|fractype
operator|)
literal|1
operator|<<
operator|(
name|FRACBITS
operator|+
name|NGARDS
operator|)
operator|)
condition|)
block|{
name|in
operator|.
name|fraction
operator|.
name|ll
operator|<<=
literal|1
expr_stmt|;
name|in
operator|.
name|normal_exp
operator|-=
literal|1
expr_stmt|;
block|}
block|}
return|return
name|pack_d
argument_list|(
operator|&
name|in
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* L_si_to_sf || L_si_to_df */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_usi_to_sf
argument_list|)
operator|||
name|defined
argument_list|(
name|L_usi_to_df
argument_list|)
operator|||
name|defined
argument_list|(
name|L_usi_to_tf
argument_list|)
end_if

begin_function
name|FLO_type
name|usi_to_float
parameter_list|(
name|USItype
name|arg_a
parameter_list|)
block|{
name|fp_number_type
name|in
decl_stmt|;
name|in
operator|.
name|sign
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|arg_a
condition|)
block|{
name|in
operator|.
name|class
operator|=
name|CLASS_ZERO
expr_stmt|;
block|}
else|else
block|{
name|in
operator|.
name|class
operator|=
name|CLASS_NUMBER
expr_stmt|;
name|in
operator|.
name|normal_exp
operator|=
name|FRACBITS
operator|+
name|NGARDS
expr_stmt|;
name|in
operator|.
name|fraction
operator|.
name|ll
operator|=
name|arg_a
expr_stmt|;
while|while
condition|(
name|in
operator|.
name|fraction
operator|.
name|ll
operator|>
operator|(
operator|(
name|fractype
operator|)
literal|1
operator|<<
operator|(
name|FRACBITS
operator|+
name|NGARDS
operator|)
operator|)
condition|)
block|{
name|in
operator|.
name|fraction
operator|.
name|ll
operator|>>=
literal|1
expr_stmt|;
name|in
operator|.
name|normal_exp
operator|+=
literal|1
expr_stmt|;
block|}
while|while
condition|(
name|in
operator|.
name|fraction
operator|.
name|ll
operator|<
operator|(
operator|(
name|fractype
operator|)
literal|1
operator|<<
operator|(
name|FRACBITS
operator|+
name|NGARDS
operator|)
operator|)
condition|)
block|{
name|in
operator|.
name|fraction
operator|.
name|ll
operator|<<=
literal|1
expr_stmt|;
name|in
operator|.
name|normal_exp
operator|-=
literal|1
expr_stmt|;
block|}
block|}
return|return
name|pack_d
argument_list|(
operator|&
name|in
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_sf_to_si
argument_list|)
operator|||
name|defined
argument_list|(
name|L_df_to_si
argument_list|)
operator|||
name|defined
argument_list|(
name|L_tf_to_si
argument_list|)
end_if

begin_function
name|SItype
name|float_to_si
parameter_list|(
name|FLO_type
name|arg_a
parameter_list|)
block|{
name|fp_number_type
name|a
decl_stmt|;
name|SItype
name|tmp
decl_stmt|;
name|FLO_union_type
name|au
decl_stmt|;
name|au
operator|.
name|value
operator|=
name|arg_a
expr_stmt|;
name|unpack_d
argument_list|(
operator|&
name|au
argument_list|,
operator|&
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|iszero
argument_list|(
operator|&
name|a
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|isnan
argument_list|(
operator|&
name|a
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* get reasonable MAX_SI_INT...  */
if|if
condition|(
name|isinf
argument_list|(
operator|&
name|a
argument_list|)
condition|)
return|return
name|a
operator|.
name|sign
condition|?
operator|(
operator|-
name|MAX_SI_INT
operator|)
operator|-
literal|1
else|:
name|MAX_SI_INT
return|;
comment|/* it is a number, but a small one */
if|if
condition|(
name|a
operator|.
name|normal_exp
operator|<
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|a
operator|.
name|normal_exp
operator|>
name|BITS_PER_SI
operator|-
literal|2
condition|)
return|return
name|a
operator|.
name|sign
condition|?
operator|(
operator|-
name|MAX_SI_INT
operator|)
operator|-
literal|1
else|:
name|MAX_SI_INT
return|;
name|tmp
operator|=
name|a
operator|.
name|fraction
operator|.
name|ll
operator|>>
operator|(
operator|(
name|FRACBITS
operator|+
name|NGARDS
operator|)
operator|-
name|a
operator|.
name|normal_exp
operator|)
expr_stmt|;
return|return
name|a
operator|.
name|sign
condition|?
operator|(
operator|-
name|tmp
operator|)
else|:
operator|(
name|tmp
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* L_sf_to_si || L_df_to_si */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_sf_to_usi
argument_list|)
operator|||
name|defined
argument_list|(
name|L_df_to_usi
argument_list|)
operator|||
name|defined
argument_list|(
name|L_tf_to_usi
argument_list|)
end_if

begin_if
if|#
directive|if
name|defined
name|US_SOFTWARE_GOFAST
operator|||
name|defined
argument_list|(
name|L_tf_to_usi
argument_list|)
end_if

begin_comment
comment|/* While libgcc2.c defines its own __fixunssfsi and __fixunsdfsi routines,    we also define them for GOFAST because the ones in libgcc2.c have the    wrong names and I'd rather define these here and keep GOFAST CYG-LOC's    out of libgcc2.c.  We can't define these here if not GOFAST because then    there'd be duplicate copies.  */
end_comment

begin_function
name|USItype
name|float_to_usi
parameter_list|(
name|FLO_type
name|arg_a
parameter_list|)
block|{
name|fp_number_type
name|a
decl_stmt|;
name|FLO_union_type
name|au
decl_stmt|;
name|au
operator|.
name|value
operator|=
name|arg_a
expr_stmt|;
name|unpack_d
argument_list|(
operator|&
name|au
argument_list|,
operator|&
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|iszero
argument_list|(
operator|&
name|a
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|isnan
argument_list|(
operator|&
name|a
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* it is a negative number */
if|if
condition|(
name|a
operator|.
name|sign
condition|)
return|return
literal|0
return|;
comment|/* get reasonable MAX_USI_INT...  */
if|if
condition|(
name|isinf
argument_list|(
operator|&
name|a
argument_list|)
condition|)
return|return
name|MAX_USI_INT
return|;
comment|/* it is a number, but a small one */
if|if
condition|(
name|a
operator|.
name|normal_exp
operator|<
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|a
operator|.
name|normal_exp
operator|>
name|BITS_PER_SI
operator|-
literal|1
condition|)
return|return
name|MAX_USI_INT
return|;
elseif|else
if|if
condition|(
name|a
operator|.
name|normal_exp
operator|>
operator|(
name|FRACBITS
operator|+
name|NGARDS
operator|)
condition|)
return|return
name|a
operator|.
name|fraction
operator|.
name|ll
operator|<<
operator|(
name|a
operator|.
name|normal_exp
operator|-
operator|(
name|FRACBITS
operator|+
name|NGARDS
operator|)
operator|)
return|;
else|else
return|return
name|a
operator|.
name|fraction
operator|.
name|ll
operator|>>
operator|(
operator|(
name|FRACBITS
operator|+
name|NGARDS
operator|)
operator|-
name|a
operator|.
name|normal_exp
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* US_SOFTWARE_GOFAST */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* L_sf_to_usi || L_df_to_usi */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_negate_sf
argument_list|)
operator|||
name|defined
argument_list|(
name|L_negate_df
argument_list|)
operator|||
name|defined
argument_list|(
name|L_negate_tf
argument_list|)
end_if

begin_function
name|FLO_type
name|negate
parameter_list|(
name|FLO_type
name|arg_a
parameter_list|)
block|{
name|fp_number_type
name|a
decl_stmt|;
name|FLO_union_type
name|au
decl_stmt|;
name|au
operator|.
name|value
operator|=
name|arg_a
expr_stmt|;
name|unpack_d
argument_list|(
operator|&
name|au
argument_list|,
operator|&
name|a
argument_list|)
expr_stmt|;
name|flip_sign
argument_list|(
operator|&
name|a
argument_list|)
expr_stmt|;
return|return
name|pack_d
argument_list|(
operator|&
name|a
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* L_negate_sf || L_negate_df */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|FLOAT
end_ifdef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_make_sf
argument_list|)
end_if

begin_function
name|SFtype
name|__make_fp
parameter_list|(
name|fp_class_type
name|class
parameter_list|,
name|unsigned
name|int
name|sign
parameter_list|,
name|int
name|exp
parameter_list|,
name|USItype
name|frac
parameter_list|)
block|{
name|fp_number_type
name|in
decl_stmt|;
name|in
operator|.
name|class
operator|=
name|class
expr_stmt|;
name|in
operator|.
name|sign
operator|=
name|sign
expr_stmt|;
name|in
operator|.
name|normal_exp
operator|=
name|exp
expr_stmt|;
name|in
operator|.
name|fraction
operator|.
name|ll
operator|=
name|frac
expr_stmt|;
return|return
name|pack_d
argument_list|(
operator|&
name|in
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* L_make_sf */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|FLOAT_ONLY
end_ifndef

begin_comment
comment|/* This enables one to build an fp library that supports float but not double.    Otherwise, we would get an undefined reference to __make_dp.    This is needed for some 8-bit ports that can't handle well values that    are 8-bytes in size, so we just don't support double for them at all.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_sf_to_df
argument_list|)
end_if

begin_function
name|DFtype
name|sf_to_df
parameter_list|(
name|SFtype
name|arg_a
parameter_list|)
block|{
name|fp_number_type
name|in
decl_stmt|;
name|FLO_union_type
name|au
decl_stmt|;
name|au
operator|.
name|value
operator|=
name|arg_a
expr_stmt|;
name|unpack_d
argument_list|(
operator|&
name|au
argument_list|,
operator|&
name|in
argument_list|)
expr_stmt|;
return|return
name|__make_dp
argument_list|(
name|in
operator|.
name|class
argument_list|,
name|in
operator|.
name|sign
argument_list|,
name|in
operator|.
name|normal_exp
argument_list|,
operator|(
operator|(
name|UDItype
operator|)
name|in
operator|.
name|fraction
operator|.
name|ll
operator|)
operator|<<
name|F_D_BITOFF
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* L_sf_to_df */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_sf_to_tf
argument_list|)
operator|&&
name|defined
argument_list|(
name|TMODES
argument_list|)
end_if

begin_function
name|TFtype
name|sf_to_tf
parameter_list|(
name|SFtype
name|arg_a
parameter_list|)
block|{
name|fp_number_type
name|in
decl_stmt|;
name|FLO_union_type
name|au
decl_stmt|;
name|au
operator|.
name|value
operator|=
name|arg_a
expr_stmt|;
name|unpack_d
argument_list|(
operator|&
name|au
argument_list|,
operator|&
name|in
argument_list|)
expr_stmt|;
return|return
name|__make_tp
argument_list|(
name|in
operator|.
name|class
argument_list|,
name|in
operator|.
name|sign
argument_list|,
name|in
operator|.
name|normal_exp
argument_list|,
operator|(
operator|(
name|UTItype
operator|)
name|in
operator|.
name|fraction
operator|.
name|ll
operator|)
operator|<<
name|F_T_BITOFF
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* L_sf_to_df */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! FLOAT_ONLY */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FLOAT */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|FLOAT
end_ifndef

begin_function_decl
specifier|extern
name|SFtype
name|__make_fp
parameter_list|(
name|fp_class_type
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|int
parameter_list|,
name|USItype
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_make_df
argument_list|)
end_if

begin_function
name|DFtype
name|__make_dp
parameter_list|(
name|fp_class_type
name|class
parameter_list|,
name|unsigned
name|int
name|sign
parameter_list|,
name|int
name|exp
parameter_list|,
name|UDItype
name|frac
parameter_list|)
block|{
name|fp_number_type
name|in
decl_stmt|;
name|in
operator|.
name|class
operator|=
name|class
expr_stmt|;
name|in
operator|.
name|sign
operator|=
name|sign
expr_stmt|;
name|in
operator|.
name|normal_exp
operator|=
name|exp
expr_stmt|;
name|in
operator|.
name|fraction
operator|.
name|ll
operator|=
name|frac
expr_stmt|;
return|return
name|pack_d
argument_list|(
operator|&
name|in
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* L_make_df */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_df_to_sf
argument_list|)
end_if

begin_function
name|SFtype
name|df_to_sf
parameter_list|(
name|DFtype
name|arg_a
parameter_list|)
block|{
name|fp_number_type
name|in
decl_stmt|;
name|USItype
name|sffrac
decl_stmt|;
name|FLO_union_type
name|au
decl_stmt|;
name|au
operator|.
name|value
operator|=
name|arg_a
expr_stmt|;
name|unpack_d
argument_list|(
operator|&
name|au
argument_list|,
operator|&
name|in
argument_list|)
expr_stmt|;
name|sffrac
operator|=
name|in
operator|.
name|fraction
operator|.
name|ll
operator|>>
name|F_D_BITOFF
expr_stmt|;
comment|/* We set the lowest guard bit in SFFRAC if we discarded any non      zero bits.  */
if|if
condition|(
operator|(
name|in
operator|.
name|fraction
operator|.
name|ll
operator|&
operator|(
operator|(
operator|(
name|USItype
operator|)
literal|1
operator|<<
name|F_D_BITOFF
operator|)
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
name|sffrac
operator||=
literal|1
expr_stmt|;
return|return
name|__make_fp
argument_list|(
name|in
operator|.
name|class
argument_list|,
name|in
operator|.
name|sign
argument_list|,
name|in
operator|.
name|normal_exp
argument_list|,
name|sffrac
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* L_df_to_sf */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_df_to_tf
argument_list|)
operator|&&
name|defined
argument_list|(
name|TMODES
argument_list|)
expr|\
operator|&&
operator|!
name|defined
argument_list|(
name|FLOAT
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|TFLOAT
argument_list|)
end_if

begin_function
name|TFtype
name|df_to_tf
parameter_list|(
name|DFtype
name|arg_a
parameter_list|)
block|{
name|fp_number_type
name|in
decl_stmt|;
name|FLO_union_type
name|au
decl_stmt|;
name|au
operator|.
name|value
operator|=
name|arg_a
expr_stmt|;
name|unpack_d
argument_list|(
operator|&
name|au
argument_list|,
operator|&
name|in
argument_list|)
expr_stmt|;
return|return
name|__make_tp
argument_list|(
name|in
operator|.
name|class
argument_list|,
name|in
operator|.
name|sign
argument_list|,
name|in
operator|.
name|normal_exp
argument_list|,
operator|(
operator|(
name|UTItype
operator|)
name|in
operator|.
name|fraction
operator|.
name|ll
operator|)
operator|<<
name|D_T_BITOFF
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* L_sf_to_df */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TFLOAT
end_ifdef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_make_tf
argument_list|)
end_if

begin_function
name|TFtype
name|__make_tp
parameter_list|(
name|fp_class_type
name|class
parameter_list|,
name|unsigned
name|int
name|sign
parameter_list|,
name|int
name|exp
parameter_list|,
name|UTItype
name|frac
parameter_list|)
block|{
name|fp_number_type
name|in
decl_stmt|;
name|in
operator|.
name|class
operator|=
name|class
expr_stmt|;
name|in
operator|.
name|sign
operator|=
name|sign
expr_stmt|;
name|in
operator|.
name|normal_exp
operator|=
name|exp
expr_stmt|;
name|in
operator|.
name|fraction
operator|.
name|ll
operator|=
name|frac
expr_stmt|;
return|return
name|pack_d
argument_list|(
operator|&
name|in
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* L_make_tf */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_tf_to_df
argument_list|)
end_if

begin_function
name|DFtype
name|tf_to_df
parameter_list|(
name|TFtype
name|arg_a
parameter_list|)
block|{
name|fp_number_type
name|in
decl_stmt|;
name|UDItype
name|sffrac
decl_stmt|;
name|FLO_union_type
name|au
decl_stmt|;
name|au
operator|.
name|value
operator|=
name|arg_a
expr_stmt|;
name|unpack_d
argument_list|(
operator|&
name|au
argument_list|,
operator|&
name|in
argument_list|)
expr_stmt|;
name|sffrac
operator|=
name|in
operator|.
name|fraction
operator|.
name|ll
operator|>>
name|D_T_BITOFF
expr_stmt|;
comment|/* We set the lowest guard bit in SFFRAC if we discarded any non      zero bits.  */
if|if
condition|(
operator|(
name|in
operator|.
name|fraction
operator|.
name|ll
operator|&
operator|(
operator|(
operator|(
name|UTItype
operator|)
literal|1
operator|<<
name|D_T_BITOFF
operator|)
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
name|sffrac
operator||=
literal|1
expr_stmt|;
return|return
name|__make_dp
argument_list|(
name|in
operator|.
name|class
argument_list|,
name|in
operator|.
name|sign
argument_list|,
name|in
operator|.
name|normal_exp
argument_list|,
name|sffrac
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* L_tf_to_df */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_tf_to_sf
argument_list|)
end_if

begin_function
name|SFtype
name|tf_to_sf
parameter_list|(
name|TFtype
name|arg_a
parameter_list|)
block|{
name|fp_number_type
name|in
decl_stmt|;
name|USItype
name|sffrac
decl_stmt|;
name|FLO_union_type
name|au
decl_stmt|;
name|au
operator|.
name|value
operator|=
name|arg_a
expr_stmt|;
name|unpack_d
argument_list|(
operator|&
name|au
argument_list|,
operator|&
name|in
argument_list|)
expr_stmt|;
name|sffrac
operator|=
name|in
operator|.
name|fraction
operator|.
name|ll
operator|>>
name|F_T_BITOFF
expr_stmt|;
comment|/* We set the lowest guard bit in SFFRAC if we discarded any non      zero bits.  */
if|if
condition|(
operator|(
name|in
operator|.
name|fraction
operator|.
name|ll
operator|&
operator|(
operator|(
operator|(
name|UTItype
operator|)
literal|1
operator|<<
name|F_T_BITOFF
operator|)
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
name|sffrac
operator||=
literal|1
expr_stmt|;
return|return
name|__make_fp
argument_list|(
name|in
operator|.
name|class
argument_list|,
name|in
operator|.
name|sign
argument_list|,
name|in
operator|.
name|normal_exp
argument_list|,
name|sffrac
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* L_tf_to_sf */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TFLOAT */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! FLOAT */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !EXTENDED_FLOAT_STUBS */
end_comment

end_unit

