begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Implementation of W32-specific threads compatibility routines for    libgcc2.  */
end_comment

begin_comment
comment|/* Copyright (C) 1999, 2000, 2002, 2004 Free Software Foundation, Inc.    Contributed by Mumit Khan<khan@xraylith.wisc.edu>.    Modified and moved to separate file by Danny Smith<dannysmith@users.sourceforge.net>.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* As a special exception, if you link this library with other files,    some of which are compiled with GCC, to produce an executable,    this library does not by itself cause the resulting executable    to be covered by the GNU General Public License.    This exception does not however invalidate any other reasons why    the executable file might be covered by the GNU General Public License.  */
end_comment

begin_include
include|#
directive|include
file|<windows.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|__GTHREAD_HIDE_WIN32API
end_ifndef

begin_define
define|#
directive|define
name|__GTHREAD_HIDE_WIN32API
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|__GTHREAD_I486_INLINE_LOCK_PRIMITIVES
end_undef

begin_define
define|#
directive|define
name|__GTHREAD_I486_INLINE_LOCK_PRIMITIVES
end_define

begin_include
include|#
directive|include
file|<gthr-win32.h>
end_include

begin_comment
comment|/* Windows32 threads specific definitions. The windows32 threading model    does not map well into pthread-inspired gcc's threading model, and so     there are caveats one needs to be aware of.     1. The destructor supplied to __gthread_key_create is ignored for       generic x86-win32 ports. This will certainly cause memory leaks        due to unreclaimed eh contexts (sizeof (eh_context) is at least        24 bytes for x86 currently).        This memory leak may be significant for long-running applications       that make heavy use of C++ EH.        However, Mingw runtime (version 0.3 or newer) provides a mechanism       to emulate pthreads key dtors; the runtime provides a special DLL,       linked in if -mthreads option is specified, that runs the dtors in       the reverse order of registration when each thread exits. If       -mthreads option is not given, a stub is linked in instead of the       DLL, which results in memory leak. Other x86-win32 ports can use        the same technique of course to avoid the leak.     2. The error codes returned are non-POSIX like, and cast into ints.       This may cause incorrect error return due to truncation values on        hw where sizeof (DWORD)> sizeof (int).        3. We are currently using a special mutex instead of the Critical       Sections, since Win9x does not support TryEnterCriticalSection       (while NT does).       The basic framework should work well enough. In the long term, GCC    needs to use Structured Exception Handling on Windows32.  */
end_comment

begin_function
name|int
name|__gthr_win32_once
parameter_list|(
name|__gthread_once_t
modifier|*
name|once
parameter_list|,
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|void
parameter_list|)
parameter_list|)
block|{
if|if
condition|(
name|once
operator|==
name|NULL
operator|||
name|func
operator|==
name|NULL
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
operator|!
name|once
operator|->
name|done
condition|)
block|{
if|if
condition|(
name|InterlockedIncrement
argument_list|(
operator|&
operator|(
name|once
operator|->
name|started
operator|)
argument_list|)
operator|==
literal|0
condition|)
block|{
call|(
modifier|*
name|func
call|)
argument_list|()
expr_stmt|;
name|once
operator|->
name|done
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
comment|/* Another thread is currently executing the code, so wait for it  	     to finish; yield the CPU in the meantime.  If performance  	     does become an issue, the solution is to use an Event that  	     we wait on here (and set above), but that implies a place to  	     create the event before this routine is called.  */
while|while
condition|(
operator|!
name|once
operator|->
name|done
condition|)
name|Sleep
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Windows32 thread local keys don't support destructors; this leads to    leaks, especially in threaded applications making extensive use of     C++ EH. Mingw uses a thread-support DLL to work-around this problem.  */
end_comment

begin_function
name|int
name|__gthr_win32_key_create
parameter_list|(
name|__gthread_key_t
modifier|*
name|key
parameter_list|,
name|void
function_decl|(
modifier|*
name|dtor
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|)
block|{
name|int
name|status
init|=
literal|0
decl_stmt|;
name|DWORD
name|tls_index
init|=
name|TlsAlloc
argument_list|()
decl_stmt|;
if|if
condition|(
name|tls_index
operator|!=
literal|0xFFFFFFFF
condition|)
block|{
operator|*
name|key
operator|=
name|tls_index
expr_stmt|;
ifdef|#
directive|ifdef
name|MINGW32_SUPPORTS_MT_EH
comment|/* Mingw runtime will run the dtors in reverse order for each thread          when the thread exits.  */
name|status
operator|=
name|__mingwthr_key_dtor
argument_list|(
operator|*
name|key
argument_list|,
name|dtor
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|status
operator|=
operator|(
name|int
operator|)
name|GetLastError
argument_list|()
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_function
name|int
name|__gthr_win32_key_delete
parameter_list|(
name|__gthread_key_t
name|key
parameter_list|)
block|{
return|return
operator|(
name|TlsFree
argument_list|(
name|key
argument_list|)
operator|!=
literal|0
operator|)
condition|?
literal|0
else|:
operator|(
name|int
operator|)
name|GetLastError
argument_list|()
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|__gthr_win32_getspecific
parameter_list|(
name|__gthread_key_t
name|key
parameter_list|)
block|{
name|DWORD
name|lasterror
decl_stmt|;
name|void
modifier|*
name|ptr
decl_stmt|;
name|lasterror
operator|=
name|GetLastError
argument_list|()
expr_stmt|;
name|ptr
operator|=
name|TlsGetValue
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|SetLastError
argument_list|(
name|lasterror
argument_list|)
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
name|int
name|__gthr_win32_setspecific
parameter_list|(
name|__gthread_key_t
name|key
parameter_list|,
specifier|const
name|void
modifier|*
name|ptr
parameter_list|)
block|{
return|return
operator|(
name|TlsSetValue
argument_list|(
name|key
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ptr
argument_list|)
operator|!=
literal|0
operator|)
condition|?
literal|0
else|:
operator|(
name|int
operator|)
name|GetLastError
argument_list|()
return|;
block|}
end_function

begin_function
name|void
name|__gthr_win32_mutex_init_function
parameter_list|(
name|__gthread_mutex_t
modifier|*
name|mutex
parameter_list|)
block|{
name|mutex
operator|->
name|counter
operator|=
operator|-
literal|1
expr_stmt|;
name|mutex
operator|->
name|sema
operator|=
name|CreateSemaphore
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
literal|65535
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|__gthr_win32_mutex_lock
parameter_list|(
name|__gthread_mutex_t
modifier|*
name|mutex
parameter_list|)
block|{
if|if
condition|(
name|InterlockedIncrement
argument_list|(
operator|&
name|mutex
operator|->
name|counter
argument_list|)
operator|==
literal|0
operator|||
name|WaitForSingleObject
argument_list|(
name|mutex
operator|->
name|sema
argument_list|,
name|INFINITE
argument_list|)
operator|==
name|WAIT_OBJECT_0
condition|)
return|return
literal|0
return|;
else|else
block|{
comment|/* WaitForSingleObject returns WAIT_FAILED, and we can only do          some best-effort cleanup here.  */
name|InterlockedDecrement
argument_list|(
operator|&
name|mutex
operator|->
name|counter
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
end_function

begin_function
name|int
name|__gthr_win32_mutex_trylock
parameter_list|(
name|__gthread_mutex_t
modifier|*
name|mutex
parameter_list|)
block|{
if|if
condition|(
name|__GTHR_W32_InterlockedCompareExchange
argument_list|(
operator|&
name|mutex
operator|->
name|counter
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|0
return|;
else|else
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|__gthr_win32_mutex_unlock
parameter_list|(
name|__gthread_mutex_t
modifier|*
name|mutex
parameter_list|)
block|{
if|if
condition|(
name|InterlockedDecrement
argument_list|(
operator|&
name|mutex
operator|->
name|counter
argument_list|)
operator|>=
literal|0
condition|)
return|return
name|ReleaseSemaphore
argument_list|(
name|mutex
operator|->
name|sema
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
condition|?
literal|0
else|:
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

end_unit

