begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Subroutines for insn-output.c for Windows NT.    Contributed by Douglas Rupp (drupp@cs.washington.edu)    Copyright (C) 1995, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,    2005, 2006  Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_comment
comment|/* i386/PE specific attribute support.     i386/PE has two new attributes:    dllexport - for exporting a function/variable that will live in a dll    dllimport - for importing a function/variable from a dll     Microsoft allows multiple declspecs in one __declspec, separating    them with spaces.  We do NOT support this.  Instead, use __declspec    multiple times. */
end_comment

begin_function_decl
specifier|static
name|tree
name|associated_type
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|gen_stdcall_or_fastcall_suffix
parameter_list|(
name|tree
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|i386_pe_dllexport_p
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|i386_pe_dllimport_p
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|i386_pe_mark_dllexport
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|i386_pe_mark_dllimport
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* This is we how mark internal identifiers with dllimport or dllexport    attributes.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DLL_IMPORT_PREFIX
end_ifndef

begin_define
define|#
directive|define
name|DLL_IMPORT_PREFIX
value|"#i."
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DLL_EXPORT_PREFIX
end_ifndef

begin_define
define|#
directive|define
name|DLL_EXPORT_PREFIX
value|"#e."
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Handle a "shared" attribute;    arguments as in struct attribute_spec.handler.  */
end_comment

begin_function
name|tree
name|ix86_handle_shared_attribute
parameter_list|(
name|tree
modifier|*
name|node
parameter_list|,
name|tree
name|name
parameter_list|,
name|tree
name|args
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|flags
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bool
modifier|*
name|no_add_attrs
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|!=
name|VAR_DECL
condition|)
block|{
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"%qs attribute only applies to variables"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle a "selectany" attribute;    arguments as in struct attribute_spec.handler.  */
end_comment

begin_function
name|tree
name|ix86_handle_selectany_attribute
parameter_list|(
name|tree
modifier|*
name|node
parameter_list|,
name|tree
name|name
parameter_list|,
name|tree
name|args
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|flags
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bool
modifier|*
name|no_add_attrs
parameter_list|)
block|{
comment|/* The attribute applies only to objects that are initialized and have      external linkage.  However, we may not know about initialization      until the language frontend has processed the decl. We'll check for      initialization later in encode_section_info.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|!=
name|VAR_DECL
operator|||
operator|!
name|TREE_PUBLIC
argument_list|(
operator|*
name|node
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%qs attribute applies only to initialized variables"
literal|" with external linkage"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the type that we should use to determine if DECL is    imported or exported.  */
end_comment

begin_function
specifier|static
name|tree
name|associated_type
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
return|return
operator|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|&&
name|TYPE_P
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|)
condition|?
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
else|:
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Return true if DECL is a dllexport'd object.  */
end_comment

begin_function
specifier|static
name|bool
name|i386_pe_dllexport_p
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|VAR_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
return|return
name|false
return|;
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"dllexport"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* Also mark class members of exported classes with dllexport.  */
if|if
condition|(
name|associated_type
argument_list|(
name|decl
argument_list|)
operator|&&
name|lookup_attribute
argument_list|(
literal|"dllexport"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|associated_type
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|i386_pe_type_dllexport_p
argument_list|(
name|decl
argument_list|)
return|;
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|i386_pe_dllimport_p
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|VAR_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
return|return
name|false
return|;
comment|/* Lookup the attribute in addition to checking the DECL_DLLIMPORT_P flag.      We may need to override an earlier decision.  */
if|if
condition|(
name|DECL_DLLIMPORT_P
argument_list|(
name|decl
argument_list|)
operator|&&
name|lookup_attribute
argument_list|(
literal|"dllimport"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Make a final check to see if this is a definition before we generate           RTL for an indirect reference.  */
if|if
condition|(
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%q+D: definition is marked as dllimport"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|DECL_DLLIMPORT_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
comment|/* The DECL_DLLIMPORT_P flag was set for decls in the class definition      by  targetm.cxx.adjust_class_at_definition.  Check again to emit      warnings if the class attribute has been overridden by an      out-of-class definition.  */
elseif|else
if|if
condition|(
name|associated_type
argument_list|(
name|decl
argument_list|)
operator|&&
name|lookup_attribute
argument_list|(
literal|"dllimport"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|associated_type
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|i386_pe_type_dllimport_p
argument_list|(
name|decl
argument_list|)
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Handle the -mno-fun-dllimport target switch.  */
end_comment

begin_function
name|bool
name|i386_pe_valid_dllimport_attribute_p
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
if|if
condition|(
name|TARGET_NOP_FUN_DLLIMPORT
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if SYMBOL is marked as being dllexport'd.  */
end_comment

begin_function
name|int
name|i386_pe_dllexport_name_p
parameter_list|(
specifier|const
name|char
modifier|*
name|symbol
parameter_list|)
block|{
return|return
operator|(
name|strncmp
argument_list|(
name|DLL_EXPORT_PREFIX
argument_list|,
name|symbol
argument_list|,
name|strlen
argument_list|(
name|DLL_EXPORT_PREFIX
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if SYMBOL is marked as being dllimport'd.  */
end_comment

begin_function
name|int
name|i386_pe_dllimport_name_p
parameter_list|(
specifier|const
name|char
modifier|*
name|symbol
parameter_list|)
block|{
return|return
operator|(
name|strncmp
argument_list|(
name|DLL_IMPORT_PREFIX
argument_list|,
name|symbol
argument_list|,
name|strlen
argument_list|(
name|DLL_IMPORT_PREFIX
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Mark a DECL as being dllexport'd.    Note that we override the previous setting (e.g.: dllimport).  */
end_comment

begin_function
specifier|static
name|void
name|i386_pe_mark_dllexport
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|oldname
decl_stmt|;
name|char
modifier|*
name|newname
decl_stmt|;
name|rtx
name|rtlname
decl_stmt|;
name|rtx
name|symref
decl_stmt|;
name|tree
name|idp
decl_stmt|;
name|rtlname
operator|=
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|rtlname
argument_list|)
operator|==
name|MEM
condition|)
name|rtlname
operator|=
name|XEXP
argument_list|(
name|rtlname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|rtlname
argument_list|)
operator|==
name|SYMBOL_REF
argument_list|)
expr_stmt|;
name|oldname
operator|=
name|XSTR
argument_list|(
name|rtlname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i386_pe_dllimport_name_p
argument_list|(
name|oldname
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"inconsistent dll linkage for %q+D, dllexport assumed"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* Remove DLL_IMPORT_PREFIX.  */
name|oldname
operator|+=
name|strlen
argument_list|(
name|DLL_IMPORT_PREFIX
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i386_pe_dllexport_name_p
argument_list|(
name|oldname
argument_list|)
condition|)
return|return;
comment|/*  already done  */
name|newname
operator|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|DLL_EXPORT_PREFIX
argument_list|)
operator|+
name|strlen
argument_list|(
name|oldname
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|newname
argument_list|,
literal|"%s%s"
argument_list|,
name|DLL_EXPORT_PREFIX
argument_list|,
name|oldname
argument_list|)
expr_stmt|;
comment|/* We pass newname through get_identifier to ensure it has a unique      address.  RTL processing can sometimes peek inside the symbol ref      and compare the string's addresses to see if two symbols are      identical.  */
name|idp
operator|=
name|get_identifier
argument_list|(
name|newname
argument_list|)
expr_stmt|;
name|symref
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|idp
argument_list|)
argument_list|)
expr_stmt|;
name|SET_SYMBOL_REF_DECL
argument_list|(
name|symref
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|=
name|symref
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Mark a DECL as being dllimport'd.  */
end_comment

begin_function
specifier|static
name|void
name|i386_pe_mark_dllimport
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|oldname
decl_stmt|;
name|char
modifier|*
name|newname
decl_stmt|;
name|tree
name|idp
decl_stmt|;
name|rtx
name|rtlname
decl_stmt|,
name|newrtl
decl_stmt|;
name|rtx
name|symref
decl_stmt|;
name|rtlname
operator|=
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|rtlname
argument_list|)
operator|==
name|MEM
condition|)
name|rtlname
operator|=
name|XEXP
argument_list|(
name|rtlname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|rtlname
argument_list|)
operator|==
name|SYMBOL_REF
argument_list|)
expr_stmt|;
name|oldname
operator|=
name|XSTR
argument_list|(
name|rtlname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i386_pe_dllexport_name_p
argument_list|(
name|oldname
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%qs declared as both exported to and imported from a DLL"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|i386_pe_dllimport_name_p
argument_list|(
name|oldname
argument_list|)
condition|)
block|{
comment|/* Already done, but do a sanity check to prevent assembler 	 errors.  */
name|gcc_assert
argument_list|(
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_DLLIMPORT_P
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|newname
operator|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|DLL_IMPORT_PREFIX
argument_list|)
operator|+
name|strlen
argument_list|(
name|oldname
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|newname
argument_list|,
literal|"%s%s"
argument_list|,
name|DLL_IMPORT_PREFIX
argument_list|,
name|oldname
argument_list|)
expr_stmt|;
comment|/* We pass newname through get_identifier to ensure it has a unique      address.  RTL processing can sometimes peek inside the symbol ref      and compare the string's addresses to see if two symbols are      identical.  */
name|idp
operator|=
name|get_identifier
argument_list|(
name|newname
argument_list|)
expr_stmt|;
name|symref
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|idp
argument_list|)
argument_list|)
expr_stmt|;
name|SET_SYMBOL_REF_DECL
argument_list|(
name|symref
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|newrtl
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|symref
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|=
name|newrtl
expr_stmt|;
name|DECL_DLLIMPORT_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return string which is the former assembler name modified with a    suffix consisting of an atsign (@) followed by the number of bytes of    arguments.  If FASTCALL is true, also add the FASTCALL_PREFIX.  */
end_comment

begin_function
specifier|static
name|tree
name|gen_stdcall_or_fastcall_suffix
parameter_list|(
name|tree
name|decl
parameter_list|,
name|bool
name|fastcall
parameter_list|)
block|{
name|int
name|total
init|=
literal|0
decl_stmt|;
comment|/* ??? This probably should use XSTR (XEXP (DECL_RTL (decl), 0), 0) instead      of DECL_ASSEMBLER_NAME.  */
specifier|const
name|char
modifier|*
name|asmname
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
name|newsym
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|tree
name|formal_type
decl_stmt|;
comment|/* Do not change the identifier if a verbatim asmspec or already done. */
if|if
condition|(
operator|*
name|asmname
operator|==
literal|'*'
operator|||
name|strchr
argument_list|(
name|asmname
argument_list|,
literal|'@'
argument_list|)
condition|)
return|return
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
return|;
name|formal_type
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|formal_type
operator|!=
name|NULL_TREE
condition|)
block|{
comment|/* These attributes are ignored for variadic functions in 	 i386.c:ix86_return_pops_args. For compatibility with MS          compiler do not add @0 suffix here.  */
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|tree_last
argument_list|(
name|formal_type
argument_list|)
argument_list|)
operator|!=
name|void_type_node
condition|)
return|return
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
return|;
comment|/* Quit if we hit an incomplete type.  Error is reported          by convert_arguments in c-typeck.c or cp/typeck.c.  */
while|while
condition|(
name|TREE_VALUE
argument_list|(
name|formal_type
argument_list|)
operator|!=
name|void_type_node
operator|&&
name|COMPLETE_TYPE_P
argument_list|(
name|TREE_VALUE
argument_list|(
name|formal_type
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|parm_size
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_VALUE
argument_list|(
name|formal_type
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Must round up to include padding.  This is done the same 	       way as in store_one_arg.  */
name|parm_size
operator|=
operator|(
operator|(
name|parm_size
operator|+
name|PARM_BOUNDARY
operator|-
literal|1
operator|)
operator|/
name|PARM_BOUNDARY
operator|*
name|PARM_BOUNDARY
operator|)
expr_stmt|;
name|total
operator|+=
name|parm_size
expr_stmt|;
name|formal_type
operator|=
name|TREE_CHAIN
argument_list|(
name|formal_type
argument_list|)
expr_stmt|;
block|\ 	}
block|}
comment|/* Assume max of 8 base 10 digits in the suffix.  */
name|newsym
operator|=
name|alloca
argument_list|(
literal|1
operator|+
name|strlen
argument_list|(
name|asmname
argument_list|)
operator|+
literal|1
operator|+
literal|8
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p
operator|=
name|newsym
expr_stmt|;
if|if
condition|(
name|fastcall
condition|)
operator|*
name|p
operator|++
operator|=
name|FASTCALL_PREFIX
expr_stmt|;
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"%s@%d"
argument_list|,
name|asmname
argument_list|,
name|total
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
return|return
name|get_identifier
argument_list|(
name|newsym
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|i386_pe_encode_section_info
parameter_list|(
name|tree
name|decl
parameter_list|,
name|rtx
name|rtl
parameter_list|,
name|int
name|first
parameter_list|)
block|{
name|default_encode_section_info
argument_list|(
name|decl
argument_list|,
name|rtl
argument_list|,
name|first
argument_list|)
expr_stmt|;
if|if
condition|(
name|first
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|tree
name|type_attributes
init|=
name|TYPE_ATTRIBUTES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|newid
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"stdcall"
argument_list|,
name|type_attributes
argument_list|)
condition|)
name|newid
operator|=
name|gen_stdcall_or_fastcall_suffix
argument_list|(
name|decl
argument_list|,
name|false
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"fastcall"
argument_list|,
name|type_attributes
argument_list|)
condition|)
name|newid
operator|=
name|gen_stdcall_or_fastcall_suffix
argument_list|(
name|decl
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|newid
operator|!=
name|NULL_TREE
condition|)
block|{
name|rtx
name|rtlname
init|=
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|rtlname
argument_list|)
operator|==
name|MEM
condition|)
name|rtlname
operator|=
name|XEXP
argument_list|(
name|rtlname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XSTR
argument_list|(
name|rtlname
argument_list|,
literal|0
argument_list|)
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|newid
argument_list|)
expr_stmt|;
comment|/* These attributes must be present on first declaration, 	     change_decl_assembler_name will warn if they are added 	     later and the decl has been referenced, but duplicate_decls 	     should catch the mismatch before this is called.  */
name|change_decl_assembler_name
argument_list|(
name|decl
argument_list|,
name|newid
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|lookup_attribute
argument_list|(
literal|"selectany"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
comment|/* If an object is initialized with a ctor, the static 	     initialization and destruction code for it is present in 	     each unit defining the object.  The code that calls the 	     ctor is protected by a link-once guard variable, so that 	     the object still has link-once semantics,  */
operator|||
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|make_decl_one_only
argument_list|(
name|decl
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"%q+D:'selectany' attribute applies only to initialized objects"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
comment|/* Mark the decl so we can tell from the rtl whether the object is      dllexport'd or dllimport'd.  tree.c: merge_dllimport_decl_attributes      handles dllexport/dllimport override semantics.  */
if|if
condition|(
name|i386_pe_dllexport_p
argument_list|(
name|decl
argument_list|)
condition|)
name|i386_pe_mark_dllexport
argument_list|(
name|decl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i386_pe_dllimport_p
argument_list|(
name|decl
argument_list|)
condition|)
name|i386_pe_mark_dllimport
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* It might be that DECL has been declared as dllimport, but a      subsequent definition nullified that.  Assert that      tree.c: merge_dllimport_decl_attributes has removed the attribute      before the RTL name was marked with the DLL_IMPORT_PREFIX.  */
else|else
name|gcc_assert
argument_list|(
operator|!
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|)
operator|&&
name|rtl
operator|!=
name|NULL_RTX
operator|&&
name|GET_CODE
argument_list|(
name|rtl
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|i386_pe_dllimport_name_p
argument_list|(
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Strip only the leading encoding, leaving the stdcall suffix and fastcall    prefix if it exists.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|i386_pe_strip_name_encoding
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|str
argument_list|,
name|DLL_IMPORT_PREFIX
argument_list|,
name|strlen
argument_list|(
name|DLL_IMPORT_PREFIX
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|str
operator|+=
name|strlen
argument_list|(
name|DLL_IMPORT_PREFIX
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|str
argument_list|,
name|DLL_EXPORT_PREFIX
argument_list|,
name|strlen
argument_list|(
name|DLL_EXPORT_PREFIX
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|str
operator|+=
name|strlen
argument_list|(
name|DLL_EXPORT_PREFIX
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
literal|'*'
condition|)
name|str
operator|+=
literal|1
expr_stmt|;
return|return
name|str
return|;
block|}
end_function

begin_comment
comment|/* Also strip the fastcall prefix and stdcall suffix.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|i386_pe_strip_name_encoding_full
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|i386_pe_strip_name_encoding
argument_list|(
name|str
argument_list|)
decl_stmt|;
comment|/* Strip leading '@' on fastcall symbols.  */
if|if
condition|(
operator|*
name|name
operator|==
literal|'@'
condition|)
name|name
operator|++
expr_stmt|;
comment|/* Strip trailing "@n".  */
name|p
operator|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
return|return
name|ggc_alloc_string
argument_list|(
name|name
argument_list|,
name|p
operator|-
name|name
argument_list|)
return|;
return|return
name|name
return|;
block|}
end_function

begin_comment
comment|/* Output a reference to a label. Fastcall symbols are prefixed with @,    whereas symbols for functions using other calling conventions don't    have a prefix (unless they are marked dllimport or dllexport).  */
end_comment

begin_function
name|void
name|i386_pe_output_labelref
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
name|DLL_IMPORT_PREFIX
argument_list|,
name|strlen
argument_list|(
name|DLL_IMPORT_PREFIX
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
comment|/* A dll import */
block|{
if|if
condition|(
name|name
index|[
name|strlen
argument_list|(
name|DLL_IMPORT_PREFIX
argument_list|)
index|]
operator|==
name|FASTCALL_PREFIX
condition|)
comment|/* A dllimport fastcall symbol.  */
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"__imp_%s"
argument_list|,
name|i386_pe_strip_name_encoding
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* A dllimport non-fastcall symbol.  */
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"__imp__%s"
argument_list|,
name|i386_pe_strip_name_encoding
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|name
index|[
literal|0
index|]
operator|==
name|FASTCALL_PREFIX
operator|)
operator|||
operator|(
name|strncmp
argument_list|(
name|name
argument_list|,
name|DLL_EXPORT_PREFIX
argument_list|,
name|strlen
argument_list|(
name|DLL_EXPORT_PREFIX
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
name|name
index|[
name|strlen
argument_list|(
name|DLL_EXPORT_PREFIX
argument_list|)
index|]
operator|==
name|FASTCALL_PREFIX
operator|)
condition|)
comment|/* A fastcall symbol.  */
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|i386_pe_strip_name_encoding
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Everything else.  */
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%s%s"
argument_list|,
name|USER_LABEL_PREFIX
argument_list|,
name|i386_pe_strip_name_encoding
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|i386_pe_unique_section
parameter_list|(
name|tree
name|decl
parameter_list|,
name|int
name|reloc
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|prefix
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|name
operator|=
name|i386_pe_strip_name_encoding_full
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* The object is put in, for example, section .text$foo.      The linker will then ultimately place them in .text      (everything from the $ on is stripped). Don't put      read-only data in .rdata section to avoid a PE linker      bug when .rdata$* grouped sections are used in code      without a .rdata section.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|prefix
operator|=
literal|".text$"
expr_stmt|;
elseif|else
if|if
condition|(
name|decl_readonly_section
argument_list|(
name|decl
argument_list|,
name|reloc
argument_list|)
condition|)
name|prefix
operator|=
literal|".rdata$"
expr_stmt|;
else|else
name|prefix
operator|=
literal|".data$"
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
name|string
operator|=
name|alloca
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"%s%s"
argument_list|,
name|prefix
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|DECL_SECTION_NAME
argument_list|(
name|decl
argument_list|)
operator|=
name|build_string
argument_list|(
name|len
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Select a set of attributes for section NAME based on the properties    of DECL and whether or not RELOC indicates that DECL's initializer    might contain runtime relocations.     We make the section read-only and executable for a function decl,    read-only for a const data decl, and writable for a non-const data decl.     If the section has already been defined, to not allow it to have    different attributes, as (1) this is ambiguous since we're not seeing    all the declarations up front and (2) some assemblers (e.g. SVR4)    do not recognize section redefinitions.  */
end_comment

begin_comment
comment|/* ??? This differs from the "standard" PE implementation in that we    handle the SHARED variable attribute.  Should this be done for all    PE targets?  */
end_comment

begin_define
define|#
directive|define
name|SECTION_PE_SHARED
value|SECTION_MACH_DEP
end_define

begin_function
name|unsigned
name|int
name|i386_pe_section_type_flags
parameter_list|(
name|tree
name|decl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|reloc
parameter_list|)
block|{
specifier|static
name|htab_t
name|htab
decl_stmt|;
name|unsigned
name|int
name|flags
decl_stmt|;
name|unsigned
name|int
modifier|*
modifier|*
name|slot
decl_stmt|;
comment|/* The names we put in the hashtable will always be the unique      versions given to us by the stringtable, so we can just use      their addresses as the keys.  */
if|if
condition|(
operator|!
name|htab
condition|)
name|htab
operator|=
name|htab_create
argument_list|(
literal|31
argument_list|,
name|htab_hash_pointer
argument_list|,
name|htab_eq_pointer
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|flags
operator|=
name|SECTION_CODE
expr_stmt|;
elseif|else
if|if
condition|(
name|decl
operator|&&
name|decl_readonly_section
argument_list|(
name|decl
argument_list|,
name|reloc
argument_list|)
condition|)
name|flags
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|flags
operator|=
name|SECTION_WRITE
expr_stmt|;
if|if
condition|(
name|decl
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|lookup_attribute
argument_list|(
literal|"shared"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|flags
operator||=
name|SECTION_PE_SHARED
expr_stmt|;
block|}
if|if
condition|(
name|decl
operator|&&
name|DECL_ONE_ONLY
argument_list|(
name|decl
argument_list|)
condition|)
name|flags
operator||=
name|SECTION_LINKONCE
expr_stmt|;
comment|/* See if we already have an entry for this section.  */
name|slot
operator|=
operator|(
name|unsigned
name|int
operator|*
operator|*
operator|)
name|htab_find_slot
argument_list|(
name|htab
argument_list|,
name|name
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|slot
condition|)
block|{
operator|*
name|slot
operator|=
operator|(
name|unsigned
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
argument_list|)
expr_stmt|;
operator|*
operator|*
name|slot
operator|=
name|flags
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|decl
operator|&&
operator|*
operator|*
name|slot
operator|!=
name|flags
condition|)
name|error
argument_list|(
literal|"%q+D causes a section type conflict"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
return|return
name|flags
return|;
block|}
end_function

begin_function
name|void
name|i386_pe_asm_named_section
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|,
name|tree
name|decl
parameter_list|)
block|{
name|char
name|flagchars
index|[
literal|8
index|]
decl_stmt|,
modifier|*
name|f
init|=
name|flagchars
decl_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|SECTION_CODE
operator||
name|SECTION_WRITE
operator|)
operator|)
operator|==
literal|0
condition|)
comment|/* readonly data */
block|{
operator|*
name|f
operator|++
operator|=
literal|'d'
expr_stmt|;
comment|/* This is necessary for older versions of gas.  */
operator|*
name|f
operator|++
operator|=
literal|'r'
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|flags
operator|&
name|SECTION_CODE
condition|)
operator|*
name|f
operator|++
operator|=
literal|'x'
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SECTION_WRITE
condition|)
operator|*
name|f
operator|++
operator|=
literal|'w'
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SECTION_PE_SHARED
condition|)
operator|*
name|f
operator|++
operator|=
literal|'s'
expr_stmt|;
block|}
operator|*
name|f
operator|=
literal|'\0'
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.section\t%s,\"%s\"\n"
argument_list|,
name|name
argument_list|,
name|flagchars
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SECTION_LINKONCE
condition|)
block|{
comment|/* Functions may have been compiled at various levels of 	 optimization so we can't use `same_size' here. 	 Instead, have the linker pick one, without warning. 	 If 'selectany' attribute has been specified,  MS compiler 	 sets 'discard' characteristic, rather than telling linker 	 to warn of size or content mismatch, so do the same.  */
name|bool
name|discard
init|=
operator|(
name|flags
operator|&
name|SECTION_CODE
operator|)
operator|||
name|lookup_attribute
argument_list|(
literal|"selectany"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.linkonce %s\n"
argument_list|,
operator|(
name|discard
condition|?
literal|"discard"
else|:
literal|"same_size"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The Microsoft linker requires that every function be marked as    DT_FCN.  When using gas on cygwin, we must emit appropriate .type    directives.  */
end_comment

begin_include
include|#
directive|include
file|"gsyms.h"
end_include

begin_comment
comment|/* Mark a function appropriately.  This should only be called for    functions for which we are not emitting COFF debugging information.    FILE is the assembler output file, NAME is the name of the    function, and PUBLIC is nonzero if the function is globally    visible.  */
end_comment

begin_function
name|void
name|i386_pe_declare_function_type
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|public
parameter_list|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.def\t"
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";\t.scl\t%d;\t.type\t%d;\t.endef\n"
argument_list|,
name|public
condition|?
operator|(
name|int
operator|)
name|C_EXT
else|:
operator|(
name|int
operator|)
name|C_STAT
argument_list|,
operator|(
name|int
operator|)
name|DT_FCN
operator|<<
name|N_BTSHFT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Keep a list of external functions.  */
end_comment

begin_decl_stmt
name|struct
name|extern_list
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
name|struct
name|extern_list
modifier|*
name|next
decl_stmt|;
name|tree
name|decl
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
expr|struct
name|extern_list
operator|*
name|extern_head
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Assemble an external function reference.  We need to keep a list of    these, so that we can output the function types at the end of the    assembly.  We can't output the types now, because we might see a    definition of the function later on and emit debugging information    for it then.  */
end_comment

begin_function
name|void
name|i386_pe_record_external_function
parameter_list|(
name|tree
name|decl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|extern_list
modifier|*
name|p
decl_stmt|;
name|p
operator|=
operator|(
expr|struct
name|extern_list
operator|*
operator|)
name|ggc_alloc
argument_list|(
sizeof|sizeof
expr|*
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|extern_head
expr_stmt|;
name|p
operator|->
name|decl
operator|=
name|decl
expr_stmt|;
name|p
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|extern_head
operator|=
name|p
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Keep a list of exported symbols.  */
end_comment

begin_decl_stmt
name|struct
name|export_list
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
name|struct
name|export_list
modifier|*
name|next
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|is_data
decl_stmt|;
comment|/* used to type tag exported symbols.  */
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
expr|struct
name|export_list
operator|*
name|export_head
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Assemble an export symbol entry.  We need to keep a list of    these, so that we can output the export list at the end of the    assembly.  We used to output these export symbols in each function,    but that causes problems with GNU ld when the sections are    linkonce.  */
end_comment

begin_function
name|void
name|i386_pe_record_exported_symbol
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|is_data
parameter_list|)
block|{
name|struct
name|export_list
modifier|*
name|p
decl_stmt|;
name|p
operator|=
operator|(
expr|struct
name|export_list
operator|*
operator|)
name|ggc_alloc
argument_list|(
sizeof|sizeof
expr|*
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|export_head
expr_stmt|;
name|p
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|p
operator|->
name|is_data
operator|=
name|is_data
expr_stmt|;
name|export_head
operator|=
name|p
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is called at the end of assembly.  For each external function    which has not been defined, we output a declaration now.  We also    output the .drectve section.  */
end_comment

begin_function
name|void
name|i386_pe_file_end
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|extern_list
modifier|*
name|p
decl_stmt|;
name|ix86_file_end
argument_list|()
expr_stmt|;
for|for
control|(
name|p
operator|=
name|extern_head
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|tree
name|decl
decl_stmt|;
name|decl
operator|=
name|p
operator|->
name|decl
expr_stmt|;
comment|/* Positively ensure only one declaration for any given symbol.  */
if|if
condition|(
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_SYMBOL_REFERENCED
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|i386_pe_declare_function_type
argument_list|(
name|asm_out_file
argument_list|,
name|p
operator|->
name|name
argument_list|,
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|export_head
condition|)
block|{
name|struct
name|export_list
modifier|*
name|q
decl_stmt|;
name|drectve_section
argument_list|()
expr_stmt|;
for|for
control|(
name|q
operator|=
name|export_head
init|;
name|q
operator|!=
name|NULL
condition|;
name|q
operator|=
name|q
operator|->
name|next
control|)
block|{
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.ascii \" -export:%s%s\"\n"
argument_list|,
name|i386_pe_strip_name_encoding
argument_list|(
name|q
operator|->
name|name
argument_list|)
argument_list|,
operator|(
name|q
operator|->
name|is_data
operator|)
condition|?
literal|",data"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_include
include|#
directive|include
file|"gt-winnt.h"
end_include

end_unit

