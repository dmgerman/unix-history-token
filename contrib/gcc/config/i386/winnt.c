begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Subroutines for insn-output.c for Windows NT.    Contributed by Douglas Rupp (drupp@cs.washington.edu)    Copyright (C) 1995, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004    Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_comment
comment|/* i386/PE specific attribute support.     i386/PE has two new attributes:    dllexport - for exporting a function/variable that will live in a dll    dllimport - for importing a function/variable from a dll     Microsoft allows multiple declspecs in one __declspec, separating    them with spaces.  We do NOT support this.  Instead, use __declspec    multiple times. */
end_comment

begin_function_decl
specifier|static
name|tree
name|associated_type
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|gen_stdcall_suffix
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|gen_fastcall_suffix
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|i386_pe_dllexport_p
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|i386_pe_dllimport_p
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|i386_pe_mark_dllexport
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|i386_pe_mark_dllimport
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* This is we how mark internal identifiers with dllimport or dllexport    attributes.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DLL_IMPORT_PREFIX
end_ifndef

begin_define
define|#
directive|define
name|DLL_IMPORT_PREFIX
value|"#i."
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DLL_EXPORT_PREFIX
end_ifndef

begin_define
define|#
directive|define
name|DLL_EXPORT_PREFIX
value|"#e."
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Handle a "dllimport" or "dllexport" attribute;    arguments as in struct attribute_spec.handler.  */
end_comment

begin_function
name|tree
name|ix86_handle_dll_attribute
parameter_list|(
name|tree
modifier|*
name|pnode
parameter_list|,
name|tree
name|name
parameter_list|,
name|tree
name|args
parameter_list|,
name|int
name|flags
parameter_list|,
name|bool
modifier|*
name|no_add_attrs
parameter_list|)
block|{
name|tree
name|node
init|=
operator|*
name|pnode
decl_stmt|;
comment|/* These attributes may apply to structure and union types being created,      but otherwise should pass to the declaration involved.  */
if|if
condition|(
operator|!
name|DECL_P
argument_list|(
name|node
argument_list|)
condition|)
block|{
if|if
condition|(
name|flags
operator|&
operator|(
operator|(
name|int
operator|)
name|ATTR_FLAG_DECL_NEXT
operator||
operator|(
name|int
operator|)
name|ATTR_FLAG_FUNCTION_NEXT
operator||
operator|(
name|int
operator|)
name|ATTR_FLAG_ARRAY_NEXT
operator|)
condition|)
block|{
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
return|return
name|tree_cons
argument_list|(
name|name
argument_list|,
name|args
argument_list|,
name|NULL_TREE
argument_list|)
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|!=
name|RECORD_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|!=
name|UNION_TYPE
condition|)
block|{
name|warning
argument_list|(
literal|"`%s' attribute ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
comment|/* Report error on dllimport ambiguities seen now before they cause      any damage.  */
elseif|else
if|if
condition|(
name|is_attribute_p
argument_list|(
literal|"dllimport"
argument_list|,
name|name
argument_list|)
condition|)
block|{
comment|/* Like MS, treat definition of dllimported variables and 	 non-inlined functions on declaration as syntax errors. 	 We allow the attribute for function definitions if declared 	 inline, but just ignore it in i386_pe_dllimport_p.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|node
argument_list|)
operator|&&
operator|!
name|DECL_INLINE
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%Jfunction `%D' definition is marked dllimport."
argument_list|,
name|node
argument_list|,
name|node
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%Jvariable `%D' definition is marked dllimport."
argument_list|,
name|node
argument_list|,
name|node
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
comment|/* `extern' needn't be specified with dllimport. 	     Specify `extern' now and hope for the best.  Sigh.  */
name|DECL_EXTERNAL
argument_list|(
name|node
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Also, implicitly give dllimport'd variables declared within 	     a function global scope, unless declared static.  */
if|if
condition|(
name|current_function_decl
operator|!=
name|NULL_TREE
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
name|node
argument_list|)
condition|)
name|TREE_PUBLIC
argument_list|(
name|node
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/*  Report error if symbol is not accessible at global scope.  */
if|if
condition|(
operator|!
name|TREE_PUBLIC
argument_list|(
name|node
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|FUNCTION_DECL
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"%Jexternal linkage required for symbol '%D' because of "
literal|"'%s' attribute."
argument_list|,
name|node
argument_list|,
name|node
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle a "shared" attribute;    arguments as in struct attribute_spec.handler.  */
end_comment

begin_function
name|tree
name|ix86_handle_shared_attribute
parameter_list|(
name|tree
modifier|*
name|node
parameter_list|,
name|tree
name|name
parameter_list|,
name|tree
name|args
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|flags
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bool
modifier|*
name|no_add_attrs
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|!=
name|VAR_DECL
condition|)
block|{
name|warning
argument_list|(
literal|"`%s' attribute only applies to variables"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the type that we should use to determine if DECL is    imported or exported.  */
end_comment

begin_function
specifier|static
name|tree
name|associated_type
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|tree
name|t
init|=
name|NULL_TREE
decl_stmt|;
comment|/* In the C++ frontend, DECL_CONTEXT for a method doesn't actually refer      to the containing class.  So we look at the 'this' arg.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
comment|/* Artificial methods are not affected by the import/export status 	 of their class unless they are COMDAT.  Implicit copy ctor's and 	 dtor's are not affected by class status but virtual and 	 non-virtual thunks are.  */
if|if
condition|(
operator|!
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|||
name|DECL_COMDAT
argument_list|(
name|decl
argument_list|)
condition|)
name|t
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'t'
condition|)
name|t
operator|=
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if DECL is a dllexport'd object.  */
end_comment

begin_function
specifier|static
name|int
name|i386_pe_dllexport_p
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|tree
name|exp
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|VAR_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
return|return
literal|0
return|;
name|exp
operator|=
name|lookup_attribute
argument_list|(
literal|"dllexport"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
condition|)
return|return
literal|1
return|;
comment|/* Class members get the dllexport status of their class.  */
if|if
condition|(
name|associated_type
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|exp
operator|=
name|lookup_attribute
argument_list|(
literal|"dllexport"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|associated_type
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if DECL is a dllimport'd object.  */
end_comment

begin_function
specifier|static
name|int
name|i386_pe_dllimport_p
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|tree
name|imp
decl_stmt|;
name|int
name|context_imp
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|TARGET_NOP_FUN_DLLIMPORT
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|VAR_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
return|return
literal|0
return|;
name|imp
operator|=
name|lookup_attribute
argument_list|(
literal|"dllimport"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Class members get the dllimport status of their class.  */
if|if
condition|(
operator|!
name|imp
operator|&&
name|associated_type
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|imp
operator|=
name|lookup_attribute
argument_list|(
literal|"dllimport"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|associated_type
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|imp
condition|)
name|context_imp
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|imp
condition|)
block|{
comment|/* Don't mark defined functions as dllimport.  If the definition 	 itself was marked with dllimport, than ix86_handle_dll_attribute 	 reports an error. This handles the case when the definition 	 overrides an earlier declaration.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_INLINE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* Don't warn about artificial methods.  */
if|if
condition|(
operator|!
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
condition|)
name|warning
argument_list|(
literal|"%Jfunction '%D' is defined after prior declaration "
literal|"as dllimport: attribute ignored"
argument_list|,
name|decl
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* We ignore the dllimport attribute for inline member functions. 	 This differs from MSVC behavior which treats it like GNUC 	 'extern inline' extension.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_INLINE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|extra_warnings
condition|)
name|warning
argument_list|(
literal|"%Jinline function '%D' is declared as dllimport: "
literal|"attribute ignored."
argument_list|,
name|decl
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/*  Don't allow definitions of static data members in dllimport class, 	  Just ignore attribute for vtable data.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|context_imp
condition|)
block|{
if|if
condition|(
operator|!
name|DECL_VIRTUAL_P
argument_list|(
name|decl
argument_list|)
condition|)
name|error
argument_list|(
literal|"%Jdefinition of static data member '%D' of "
literal|"dllimport'd class."
argument_list|,
name|decl
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Since we can't treat a pointer to a dllimport'd symbol as a 	 constant address, we turn off the attribute on C++ virtual 	 methods to allow creation of vtables using thunks.  Don't mark 	 artificial methods either (in associated_type, only COMDAT 	 artificial method get import status from class context).  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
operator|&&
operator|(
name|DECL_VIRTUAL_P
argument_list|(
name|decl
argument_list|)
operator|||
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if SYMBOL is marked as being dllexport'd.  */
end_comment

begin_function
name|int
name|i386_pe_dllexport_name_p
parameter_list|(
specifier|const
name|char
modifier|*
name|symbol
parameter_list|)
block|{
return|return
operator|(
name|strncmp
argument_list|(
name|DLL_EXPORT_PREFIX
argument_list|,
name|symbol
argument_list|,
name|strlen
argument_list|(
name|DLL_EXPORT_PREFIX
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if SYMBOL is marked as being dllimport'd.  */
end_comment

begin_function
name|int
name|i386_pe_dllimport_name_p
parameter_list|(
specifier|const
name|char
modifier|*
name|symbol
parameter_list|)
block|{
return|return
operator|(
name|strncmp
argument_list|(
name|DLL_IMPORT_PREFIX
argument_list|,
name|symbol
argument_list|,
name|strlen
argument_list|(
name|DLL_IMPORT_PREFIX
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Mark a DECL as being dllexport'd.    Note that we override the previous setting (eg: dllimport).  */
end_comment

begin_function
specifier|static
name|void
name|i386_pe_mark_dllexport
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|oldname
decl_stmt|;
name|char
modifier|*
name|newname
decl_stmt|;
name|rtx
name|rtlname
decl_stmt|;
name|tree
name|idp
decl_stmt|;
name|rtlname
operator|=
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|rtlname
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
name|oldname
operator|=
name|XSTR
argument_list|(
name|rtlname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|rtlname
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|rtlname
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
name|oldname
operator|=
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|rtlname
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|i386_pe_dllimport_name_p
argument_list|(
name|oldname
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"%Jinconsistent dll linkage for '%D', dllexport assumed."
argument_list|,
name|decl
argument_list|,
name|decl
argument_list|)
expr_stmt|;
comment|/* Remove DLL_IMPORT_PREFIX.  */
name|oldname
operator|+=
name|strlen
argument_list|(
name|DLL_IMPORT_PREFIX
argument_list|)
expr_stmt|;
name|DECL_NON_ADDR_CONST_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i386_pe_dllexport_name_p
argument_list|(
name|oldname
argument_list|)
condition|)
return|return;
comment|/*  already done  */
name|newname
operator|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|DLL_EXPORT_PREFIX
argument_list|)
operator|+
name|strlen
argument_list|(
name|oldname
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|newname
argument_list|,
literal|"%s%s"
argument_list|,
name|DLL_EXPORT_PREFIX
argument_list|,
name|oldname
argument_list|)
expr_stmt|;
comment|/* We pass newname through get_identifier to ensure it has a unique      address.  RTL processing can sometimes peek inside the symbol ref      and compare the string's addresses to see if two symbols are      identical.  */
name|idp
operator|=
name|get_identifier
argument_list|(
name|newname
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|idp
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Mark a DECL as being dllimport'd.  */
end_comment

begin_function
specifier|static
name|void
name|i386_pe_mark_dllimport
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|oldname
decl_stmt|;
name|char
modifier|*
name|newname
decl_stmt|;
name|tree
name|idp
decl_stmt|;
name|rtx
name|rtlname
decl_stmt|,
name|newrtl
decl_stmt|;
name|rtlname
operator|=
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|rtlname
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
name|oldname
operator|=
name|XSTR
argument_list|(
name|rtlname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|rtlname
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|rtlname
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
name|oldname
operator|=
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|rtlname
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|i386_pe_dllexport_name_p
argument_list|(
name|oldname
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"`%s' declared as both exported to and imported from a DLL"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|i386_pe_dllimport_name_p
argument_list|(
name|oldname
argument_list|)
condition|)
block|{
comment|/* Already done, but do a sanity check to prevent assembler errors.  */
if|if
condition|(
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|||
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%Jfailure in redeclaration of '%D': dllimport'd "
literal|"symbol lacks external linkage."
argument_list|,
name|decl
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
return|return;
block|}
name|newname
operator|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|DLL_IMPORT_PREFIX
argument_list|)
operator|+
name|strlen
argument_list|(
name|oldname
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|newname
argument_list|,
literal|"%s%s"
argument_list|,
name|DLL_IMPORT_PREFIX
argument_list|,
name|oldname
argument_list|)
expr_stmt|;
comment|/* We pass newname through get_identifier to ensure it has a unique      address.  RTL processing can sometimes peek inside the symbol ref      and compare the string's addresses to see if two symbols are      identical.  */
name|idp
operator|=
name|get_identifier
argument_list|(
name|newname
argument_list|)
expr_stmt|;
name|newrtl
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|Pmode
argument_list|,
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|idp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|=
name|newrtl
expr_stmt|;
comment|/* Can't treat a pointer to this as a constant address */
name|DECL_NON_ADDR_CONST_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return string which is the former assembler name modified with a    prefix consisting of FASTCALL_PREFIX and a suffix consisting of an    atsign (@) followed by the number of bytes of arguments.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|gen_fastcall_suffix
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|int
name|total
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|asmname
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
name|newsym
decl_stmt|;
if|if
condition|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|tree_last
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|==
name|void_type_node
condition|)
block|{
name|tree
name|formal_type
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Quit if we hit an incomplete type.  Error is reported 	   by convert_arguments in c-typeck.c or cp/typeck.c.  */
while|while
condition|(
name|TREE_VALUE
argument_list|(
name|formal_type
argument_list|)
operator|!=
name|void_type_node
operator|&&
name|COMPLETE_TYPE_P
argument_list|(
name|TREE_VALUE
argument_list|(
name|formal_type
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|parm_size
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_VALUE
argument_list|(
name|formal_type
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Must round up to include padding.  This is done the same 	       way as in store_one_arg.  */
name|parm_size
operator|=
operator|(
operator|(
name|parm_size
operator|+
name|PARM_BOUNDARY
operator|-
literal|1
operator|)
operator|/
name|PARM_BOUNDARY
operator|*
name|PARM_BOUNDARY
operator|)
expr_stmt|;
name|total
operator|+=
name|parm_size
expr_stmt|;
name|formal_type
operator|=
name|TREE_CHAIN
argument_list|(
name|formal_type
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Assume max of 8 base 10 digits in the suffix.  */
name|newsym
operator|=
name|xmalloc
argument_list|(
literal|1
operator|+
name|strlen
argument_list|(
name|asmname
argument_list|)
operator|+
literal|1
operator|+
literal|8
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|newsym
argument_list|,
literal|"%c%s@%d"
argument_list|,
name|FASTCALL_PREFIX
argument_list|,
name|asmname
argument_list|,
name|total
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
return|return
name|IDENTIFIER_POINTER
argument_list|(
name|get_identifier
argument_list|(
name|newsym
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return string which is the former assembler name modified with a    suffix consisting of an atsign (@) followed by the number of bytes of    arguments */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|gen_stdcall_suffix
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|int
name|total
init|=
literal|0
decl_stmt|;
comment|/* ??? This probably should use XSTR (XEXP (DECL_RTL (decl), 0), 0) instead      of DECL_ASSEMBLER_NAME.  */
specifier|const
name|char
modifier|*
name|asmname
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
name|newsym
decl_stmt|;
if|if
condition|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|tree_last
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|==
name|void_type_node
condition|)
block|{
name|tree
name|formal_type
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Quit if we hit an incomplete type.  Error is reported 	   by convert_arguments in c-typeck.c or cp/typeck.c.  */
while|while
condition|(
name|TREE_VALUE
argument_list|(
name|formal_type
argument_list|)
operator|!=
name|void_type_node
operator|&&
name|COMPLETE_TYPE_P
argument_list|(
name|TREE_VALUE
argument_list|(
name|formal_type
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|parm_size
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_VALUE
argument_list|(
name|formal_type
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Must round up to include padding.  This is done the same 	       way as in store_one_arg.  */
name|parm_size
operator|=
operator|(
operator|(
name|parm_size
operator|+
name|PARM_BOUNDARY
operator|-
literal|1
operator|)
operator|/
name|PARM_BOUNDARY
operator|*
name|PARM_BOUNDARY
operator|)
expr_stmt|;
name|total
operator|+=
name|parm_size
expr_stmt|;
name|formal_type
operator|=
name|TREE_CHAIN
argument_list|(
name|formal_type
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Assume max of 8 base 10 digits in the suffix.  */
name|newsym
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|asmname
argument_list|)
operator|+
literal|1
operator|+
literal|8
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|newsym
argument_list|,
literal|"%s@%d"
argument_list|,
name|asmname
argument_list|,
name|total
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
return|return
name|IDENTIFIER_POINTER
argument_list|(
name|get_identifier
argument_list|(
name|newsym
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|i386_pe_encode_section_info
parameter_list|(
name|tree
name|decl
parameter_list|,
name|rtx
name|rtl
parameter_list|,
name|int
name|first
parameter_list|)
block|{
name|default_encode_section_info
argument_list|(
name|decl
argument_list|,
name|rtl
argument_list|,
name|first
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"stdcall"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
condition|)
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
name|gen_stdcall_suffix
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"fastcall"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
condition|)
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
name|gen_fastcall_suffix
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Mark the decl so we can tell from the rtl whether the object is      dllexport'd or dllimport'd.  This also handles dllexport/dllimport      override semantics.  */
if|if
condition|(
name|i386_pe_dllexport_p
argument_list|(
name|decl
argument_list|)
condition|)
name|i386_pe_mark_dllexport
argument_list|(
name|decl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i386_pe_dllimport_p
argument_list|(
name|decl
argument_list|)
condition|)
name|i386_pe_mark_dllimport
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* It might be that DECL has already been marked as dllimport, but a      subsequent definition nullified that.  The attribute is gone but      DECL_RTL still has (DLL_IMPORT_PREFIX) prefixed. We need to remove      that. Ditto for the DECL_NON_ADDR_CONST_P flag.  */
elseif|else
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|)
operator|&&
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL_RTX
operator|&&
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|i386_pe_dllimport_name_p
argument_list|(
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|oldname
init|=
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* Remove DLL_IMPORT_PREFIX.  */
name|tree
name|idp
init|=
name|get_identifier
argument_list|(
name|oldname
operator|+
name|strlen
argument_list|(
name|DLL_IMPORT_PREFIX
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|newrtl
init|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|idp
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|||
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
name|warning
argument_list|(
literal|"%J'%D' defined locally after being "
literal|"referenced with dllimport linkage"
argument_list|,
name|decl
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"%J'%D' redeclared without dllimport attribute "
literal|"after being referenced with dllimport linkage"
argument_list|,
name|decl
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|=
name|newrtl
expr_stmt|;
name|DECL_NON_ADDR_CONST_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* We previously set TREE_PUBLIC and DECL_EXTERNAL. 	 We leave these alone for now.  */
block|}
block|}
end_function

begin_comment
comment|/* Strip only the leading encoding, leaving the stdcall suffix and fastcall    prefix if it exists.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|i386_pe_strip_name_encoding
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|str
argument_list|,
name|DLL_IMPORT_PREFIX
argument_list|,
name|strlen
argument_list|(
name|DLL_IMPORT_PREFIX
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|str
operator|+=
name|strlen
argument_list|(
name|DLL_IMPORT_PREFIX
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|str
argument_list|,
name|DLL_EXPORT_PREFIX
argument_list|,
name|strlen
argument_list|(
name|DLL_EXPORT_PREFIX
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|str
operator|+=
name|strlen
argument_list|(
name|DLL_EXPORT_PREFIX
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
literal|'*'
condition|)
name|str
operator|+=
literal|1
expr_stmt|;
return|return
name|str
return|;
block|}
end_function

begin_comment
comment|/* Also strip the stdcall suffix.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|i386_pe_strip_name_encoding_full
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|i386_pe_strip_name_encoding
argument_list|(
name|str
argument_list|)
decl_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
return|return
name|ggc_alloc_string
argument_list|(
name|name
argument_list|,
name|p
operator|-
name|name
argument_list|)
return|;
return|return
name|name
return|;
block|}
end_function

begin_comment
comment|/* Output a reference to a label. Fastcall symbols are prefixed with @,    whereas symbols for functions using other calling conventions don't    have a prefix (unless they are marked dllimport or dllexport).  */
end_comment

begin_function
name|void
name|i386_pe_output_labelref
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
name|DLL_IMPORT_PREFIX
argument_list|,
name|strlen
argument_list|(
name|DLL_IMPORT_PREFIX
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
comment|/* A dll import */
block|{
if|if
condition|(
name|name
index|[
name|strlen
argument_list|(
name|DLL_IMPORT_PREFIX
argument_list|)
index|]
operator|==
name|FASTCALL_PREFIX
condition|)
comment|/* A dllimport fastcall symbol.  */
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"__imp_%s"
argument_list|,
name|i386_pe_strip_name_encoding
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* A dllimport non-fastcall symbol.  */
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"__imp__%s"
argument_list|,
name|i386_pe_strip_name_encoding
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|name
index|[
literal|0
index|]
operator|==
name|FASTCALL_PREFIX
operator|)
operator|||
operator|(
name|strncmp
argument_list|(
name|name
argument_list|,
name|DLL_EXPORT_PREFIX
argument_list|,
name|strlen
argument_list|(
name|DLL_EXPORT_PREFIX
argument_list|)
operator|==
literal|0
operator|&&
name|name
index|[
name|strlen
argument_list|(
name|DLL_EXPORT_PREFIX
argument_list|)
index|]
operator|==
name|FASTCALL_PREFIX
argument_list|)
operator|)
condition|)
comment|/* A fastcall symbol.  */
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|i386_pe_strip_name_encoding
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Everything else.  */
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%s%s"
argument_list|,
name|USER_LABEL_PREFIX
argument_list|,
name|i386_pe_strip_name_encoding
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|i386_pe_unique_section
parameter_list|(
name|tree
name|decl
parameter_list|,
name|int
name|reloc
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|prefix
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|name
operator|=
name|i386_pe_strip_name_encoding_full
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* The object is put in, for example, section .text$foo.      The linker will then ultimately place them in .text      (everything from the $ on is stripped). Don't put      read-only data in .rdata section to avoid a PE linker      bug when .rdata$* grouped sections are used in code      without a .rdata section.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|prefix
operator|=
literal|".text$"
expr_stmt|;
elseif|else
if|if
condition|(
name|decl_readonly_section
argument_list|(
name|decl
argument_list|,
name|reloc
argument_list|)
condition|)
name|prefix
operator|=
literal|".rdata$"
expr_stmt|;
else|else
name|prefix
operator|=
literal|".data$"
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
name|string
operator|=
name|alloca
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"%s%s"
argument_list|,
name|prefix
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|DECL_SECTION_NAME
argument_list|(
name|decl
argument_list|)
operator|=
name|build_string
argument_list|(
name|len
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Select a set of attributes for section NAME based on the properties    of DECL and whether or not RELOC indicates that DECL's initializer    might contain runtime relocations.     We make the section read-only and executable for a function decl,    read-only for a const data decl, and writable for a non-const data decl.     If the section has already been defined, to not allow it to have    different attributes, as (1) this is ambiguous since we're not seeing    all the declarations up front and (2) some assemblers (e.g. SVR4)    do not recognize section redefinitions.  */
end_comment

begin_comment
comment|/* ??? This differs from the "standard" PE implementation in that we    handle the SHARED variable attribute.  Should this be done for all    PE targets?  */
end_comment

begin_define
define|#
directive|define
name|SECTION_PE_SHARED
value|SECTION_MACH_DEP
end_define

begin_function
name|unsigned
name|int
name|i386_pe_section_type_flags
parameter_list|(
name|tree
name|decl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|reloc
parameter_list|)
block|{
specifier|static
name|htab_t
name|htab
decl_stmt|;
name|unsigned
name|int
name|flags
decl_stmt|;
name|unsigned
name|int
modifier|*
modifier|*
name|slot
decl_stmt|;
comment|/* The names we put in the hashtable will always be the unique      versions gived to us by the stringtable, so we can just use      their addresses as the keys.  */
if|if
condition|(
operator|!
name|htab
condition|)
name|htab
operator|=
name|htab_create
argument_list|(
literal|31
argument_list|,
name|htab_hash_pointer
argument_list|,
name|htab_eq_pointer
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|flags
operator|=
name|SECTION_CODE
expr_stmt|;
elseif|else
if|if
condition|(
name|decl
operator|&&
name|decl_readonly_section
argument_list|(
name|decl
argument_list|,
name|reloc
argument_list|)
condition|)
name|flags
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|flags
operator|=
name|SECTION_WRITE
expr_stmt|;
if|if
condition|(
name|decl
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|lookup_attribute
argument_list|(
literal|"shared"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|flags
operator||=
name|SECTION_PE_SHARED
expr_stmt|;
block|}
if|if
condition|(
name|decl
operator|&&
name|DECL_ONE_ONLY
argument_list|(
name|decl
argument_list|)
condition|)
name|flags
operator||=
name|SECTION_LINKONCE
expr_stmt|;
comment|/* See if we already have an entry for this section.  */
name|slot
operator|=
operator|(
name|unsigned
name|int
operator|*
operator|*
operator|)
name|htab_find_slot
argument_list|(
name|htab
argument_list|,
name|name
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|slot
condition|)
block|{
operator|*
name|slot
operator|=
operator|(
name|unsigned
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
argument_list|)
expr_stmt|;
operator|*
operator|*
name|slot
operator|=
name|flags
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|decl
operator|&&
operator|*
operator|*
name|slot
operator|!=
name|flags
condition|)
name|error
argument_list|(
literal|"%J'%D' causes a section type conflict"
argument_list|,
name|decl
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
return|return
name|flags
return|;
block|}
end_function

begin_function
name|void
name|i386_pe_asm_named_section
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|)
block|{
name|char
name|flagchars
index|[
literal|8
index|]
decl_stmt|,
modifier|*
name|f
init|=
name|flagchars
decl_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|SECTION_CODE
operator||
name|SECTION_WRITE
operator|)
operator|)
operator|==
literal|0
condition|)
comment|/* readonly data */
block|{
operator|*
name|f
operator|++
operator|=
literal|'d'
expr_stmt|;
comment|/* This is necessary for older versions of gas.  */
operator|*
name|f
operator|++
operator|=
literal|'r'
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|flags
operator|&
name|SECTION_CODE
condition|)
operator|*
name|f
operator|++
operator|=
literal|'x'
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SECTION_WRITE
condition|)
operator|*
name|f
operator|++
operator|=
literal|'w'
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SECTION_PE_SHARED
condition|)
operator|*
name|f
operator|++
operator|=
literal|'s'
expr_stmt|;
block|}
operator|*
name|f
operator|=
literal|'\0'
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.section\t%s,\"%s\"\n"
argument_list|,
name|name
argument_list|,
name|flagchars
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SECTION_LINKONCE
condition|)
block|{
comment|/* Functions may have been compiled at various levels of          optimization so we can't use `same_size' here.          Instead, have the linker pick one.  */
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.linkonce %s\n"
argument_list|,
operator|(
name|flags
operator|&
name|SECTION_CODE
condition|?
literal|"discard"
else|:
literal|"same_size"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The Microsoft linker requires that every function be marked as    DT_FCN.  When using gas on cygwin, we must emit appropriate .type    directives.  */
end_comment

begin_include
include|#
directive|include
file|"gsyms.h"
end_include

begin_comment
comment|/* Mark a function appropriately.  This should only be called for    functions for which we are not emitting COFF debugging information.    FILE is the assembler output file, NAME is the name of the    function, and PUBLIC is nonzero if the function is globally    visible.  */
end_comment

begin_function
name|void
name|i386_pe_declare_function_type
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|public
parameter_list|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.def\t"
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";\t.scl\t%d;\t.type\t%d;\t.endef\n"
argument_list|,
name|public
condition|?
operator|(
name|int
operator|)
name|C_EXT
else|:
operator|(
name|int
operator|)
name|C_STAT
argument_list|,
operator|(
name|int
operator|)
name|DT_FCN
operator|<<
name|N_BTSHFT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Keep a list of external functions.  */
end_comment

begin_struct
struct|struct
name|extern_list
block|{
name|struct
name|extern_list
modifier|*
name|next
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|extern_list
modifier|*
name|extern_head
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Assemble an external function reference.  We need to keep a list of    these, so that we can output the function types at the end of the    assembly.  We can't output the types now, because we might see a    definition of the function later on and emit debugging information    for it then.  */
end_comment

begin_function
name|void
name|i386_pe_record_external_function
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|extern_list
modifier|*
name|p
decl_stmt|;
name|p
operator|=
operator|(
expr|struct
name|extern_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|extern_head
expr_stmt|;
name|p
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|extern_head
operator|=
name|p
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Keep a list of exported symbols.  */
end_comment

begin_struct
struct|struct
name|export_list
block|{
name|struct
name|export_list
modifier|*
name|next
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|is_data
decl_stmt|;
comment|/* used to type tag exported symbols.  */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|export_list
modifier|*
name|export_head
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Assemble an export symbol entry.  We need to keep a list of    these, so that we can output the export list at the end of the    assembly.  We used to output these export symbols in each function,    but that causes problems with GNU ld when the sections are    linkonce.  */
end_comment

begin_function
name|void
name|i386_pe_record_exported_symbol
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|is_data
parameter_list|)
block|{
name|struct
name|export_list
modifier|*
name|p
decl_stmt|;
name|p
operator|=
operator|(
expr|struct
name|export_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|export_head
expr_stmt|;
name|p
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|p
operator|->
name|is_data
operator|=
name|is_data
expr_stmt|;
name|export_head
operator|=
name|p
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is called at the end of assembly.  For each external function    which has not been defined, we output a declaration now.  We also    output the .drectve section.  */
end_comment

begin_function
name|void
name|i386_pe_file_end
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|extern_list
modifier|*
name|p
decl_stmt|;
name|ix86_file_end
argument_list|()
expr_stmt|;
for|for
control|(
name|p
operator|=
name|extern_head
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|tree
name|decl
decl_stmt|;
name|decl
operator|=
name|get_identifier
argument_list|(
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* Positively ensure only one declaration for any given symbol.  */
if|if
condition|(
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_SYMBOL_REFERENCED
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|i386_pe_declare_function_type
argument_list|(
name|asm_out_file
argument_list|,
name|p
operator|->
name|name
argument_list|,
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|export_head
condition|)
block|{
name|struct
name|export_list
modifier|*
name|q
decl_stmt|;
name|drectve_section
argument_list|()
expr_stmt|;
for|for
control|(
name|q
operator|=
name|export_head
init|;
name|q
operator|!=
name|NULL
condition|;
name|q
operator|=
name|q
operator|->
name|next
control|)
block|{
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.ascii \" -export:%s%s\"\n"
argument_list|,
name|i386_pe_strip_name_encoding
argument_list|(
name|q
operator|->
name|name
argument_list|)
argument_list|,
operator|(
name|q
operator|->
name|is_data
operator|)
condition|?
literal|",data"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

