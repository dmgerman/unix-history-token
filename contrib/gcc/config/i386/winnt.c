begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Subroutines for insn-output.c for Windows NT.    Contributed by Douglas Rupp (drupp@cs.washington.edu)    Copyright (C) 1995, 1997, 1998, 1999, 2000, 2001, 2002    Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_comment
comment|/* i386/PE specific attribute support.     i386/PE has two new attributes:    dllexport - for exporting a function/variable that will live in a dll    dllimport - for importing a function/variable from a dll     Microsoft allows multiple declspecs in one __declspec, separating    them with spaces.  We do NOT support this.  Instead, use __declspec    multiple times. */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|associated_type
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|gen_stdcall_suffix
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|i386_pe_dllexport_p
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|i386_pe_dllimport_p
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|i386_pe_mark_dllexport
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|i386_pe_mark_dllimport
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Handle a "dllimport" or "dllexport" attribute;    arguments as in struct attribute_spec.handler.  */
end_comment

begin_function
name|tree
name|ix86_handle_dll_attribute
parameter_list|(
name|node
parameter_list|,
name|name
parameter_list|,
name|args
parameter_list|,
name|flags
parameter_list|,
name|no_add_attrs
parameter_list|)
name|tree
modifier|*
name|node
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|tree
name|args
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|bool
modifier|*
name|no_add_attrs
decl_stmt|;
block|{
comment|/* These attributes may apply to structure and union types being created,      but otherwise should pass to the declaration involved.  */
if|if
condition|(
operator|!
name|DECL_P
argument_list|(
operator|*
name|node
argument_list|)
condition|)
block|{
if|if
condition|(
name|flags
operator|&
operator|(
operator|(
name|int
operator|)
name|ATTR_FLAG_DECL_NEXT
operator||
operator|(
name|int
operator|)
name|ATTR_FLAG_FUNCTION_NEXT
operator||
operator|(
name|int
operator|)
name|ATTR_FLAG_ARRAY_NEXT
operator|)
condition|)
block|{
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
return|return
name|tree_cons
argument_list|(
name|name
argument_list|,
name|args
argument_list|,
name|NULL_TREE
argument_list|)
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|!=
name|RECORD_TYPE
operator|&&
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|!=
name|UNION_TYPE
condition|)
block|{
name|warning
argument_list|(
literal|"`%s' attribute ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
block|}
comment|/* `extern' needn't be specified with dllimport.      Specify `extern' now and hope for the best.  Sigh.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|is_attribute_p
argument_list|(
literal|"dllimport"
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|DECL_EXTERNAL
argument_list|(
operator|*
name|node
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
operator|*
name|node
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle a "shared" attribute;    arguments as in struct attribute_spec.handler.  */
end_comment

begin_function
name|tree
name|ix86_handle_shared_attribute
parameter_list|(
name|node
parameter_list|,
name|name
parameter_list|,
name|args
parameter_list|,
name|flags
parameter_list|,
name|no_add_attrs
parameter_list|)
name|tree
modifier|*
name|node
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|tree
name|args
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|flags
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bool
modifier|*
name|no_add_attrs
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|!=
name|VAR_DECL
condition|)
block|{
name|warning
argument_list|(
literal|"`%s' attribute only applies to variables"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the type that we should use to determine if DECL is    imported or exported.  */
end_comment

begin_function
specifier|static
name|tree
name|associated_type
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|tree
name|t
init|=
name|NULL_TREE
decl_stmt|;
comment|/* In the C++ frontend, DECL_CONTEXT for a method doesn't actually refer      to the containing class.  So we look at the 'this' arg.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
comment|/* Artificial methods are not affected by the import/export status of 	 their class unless they are virtual.  */
if|if
condition|(
operator|!
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|||
name|DECL_VINDEX
argument_list|(
name|decl
argument_list|)
condition|)
name|t
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'t'
condition|)
name|t
operator|=
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if DECL is a dllexport'd object.  */
end_comment

begin_function
name|int
name|i386_pe_dllexport_p
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|tree
name|exp
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|VAR_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
return|return
literal|0
return|;
name|exp
operator|=
name|lookup_attribute
argument_list|(
literal|"dllexport"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
condition|)
return|return
literal|1
return|;
comment|/* Class members get the dllexport status of their class.  */
if|if
condition|(
name|associated_type
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|exp
operator|=
name|lookup_attribute
argument_list|(
literal|"dllexport"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|associated_type
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if DECL is a dllimport'd object.  */
end_comment

begin_function
name|int
name|i386_pe_dllimport_p
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|tree
name|imp
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|TARGET_NOP_FUN_DLLIMPORT
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|VAR_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
return|return
literal|0
return|;
name|imp
operator|=
name|lookup_attribute
argument_list|(
literal|"dllimport"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|imp
condition|)
return|return
literal|1
return|;
comment|/* Class members get the dllimport status of their class.  */
if|if
condition|(
name|associated_type
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|imp
operator|=
name|lookup_attribute
argument_list|(
literal|"dllimport"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|associated_type
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|imp
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if SYMBOL is marked as being dllexport'd.  */
end_comment

begin_function
name|int
name|i386_pe_dllexport_name_p
parameter_list|(
name|symbol
parameter_list|)
specifier|const
name|char
modifier|*
name|symbol
decl_stmt|;
block|{
return|return
name|symbol
index|[
literal|0
index|]
operator|==
name|DLL_IMPORT_EXPORT_PREFIX
operator|&&
name|symbol
index|[
literal|1
index|]
operator|==
literal|'e'
operator|&&
name|symbol
index|[
literal|2
index|]
operator|==
literal|'.'
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if SYMBOL is marked as being dllimport'd.  */
end_comment

begin_function
name|int
name|i386_pe_dllimport_name_p
parameter_list|(
name|symbol
parameter_list|)
specifier|const
name|char
modifier|*
name|symbol
decl_stmt|;
block|{
return|return
name|symbol
index|[
literal|0
index|]
operator|==
name|DLL_IMPORT_EXPORT_PREFIX
operator|&&
name|symbol
index|[
literal|1
index|]
operator|==
literal|'i'
operator|&&
name|symbol
index|[
literal|2
index|]
operator|==
literal|'.'
return|;
block|}
end_function

begin_comment
comment|/* Mark a DECL as being dllexport'd.    Note that we override the previous setting (eg: dllimport).  */
end_comment

begin_function
name|void
name|i386_pe_mark_dllexport
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|oldname
decl_stmt|;
name|char
modifier|*
name|newname
decl_stmt|;
name|rtx
name|rtlname
decl_stmt|;
name|tree
name|idp
decl_stmt|;
name|rtlname
operator|=
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|rtlname
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
name|oldname
operator|=
name|XSTR
argument_list|(
name|rtlname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|rtlname
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|rtlname
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
name|oldname
operator|=
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|rtlname
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|i386_pe_dllimport_name_p
argument_list|(
name|oldname
argument_list|)
condition|)
name|oldname
operator|+=
literal|9
expr_stmt|;
elseif|else
if|if
condition|(
name|i386_pe_dllexport_name_p
argument_list|(
name|oldname
argument_list|)
condition|)
return|return;
comment|/* already done */
name|newname
operator|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|oldname
argument_list|)
operator|+
literal|4
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|newname
argument_list|,
literal|"%ce.%s"
argument_list|,
name|DLL_IMPORT_EXPORT_PREFIX
argument_list|,
name|oldname
argument_list|)
expr_stmt|;
comment|/* We pass newname through get_identifier to ensure it has a unique      address.  RTL processing can sometimes peek inside the symbol ref      and compare the string's addresses to see if two symbols are      identical.  */
name|idp
operator|=
name|get_identifier
argument_list|(
name|newname
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|idp
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Mark a DECL as being dllimport'd.  */
end_comment

begin_function
name|void
name|i386_pe_mark_dllimport
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|oldname
decl_stmt|;
name|char
modifier|*
name|newname
decl_stmt|;
name|tree
name|idp
decl_stmt|;
name|rtx
name|rtlname
decl_stmt|,
name|newrtl
decl_stmt|;
name|rtlname
operator|=
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|rtlname
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
name|oldname
operator|=
name|XSTR
argument_list|(
name|rtlname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|rtlname
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|rtlname
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
name|oldname
operator|=
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|rtlname
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|i386_pe_dllexport_name_p
argument_list|(
name|oldname
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"`%s' declared as both exported to and imported from a DLL"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|i386_pe_dllimport_name_p
argument_list|(
name|oldname
argument_list|)
condition|)
block|{
comment|/* Already done, but force correct linkage since the redeclaration           might have omitted explicit extern.  Sigh.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
comment|/* ??? Is this test for vtables needed?  */
operator|&&
operator|!
name|DECL_VIRTUAL_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
return|return;
block|}
comment|/* ??? One can well ask why we're making these checks here,      and that would be a good question.  */
comment|/* Imported variables can't be initialized. Note that C++ classes      are marked initial, so we need to check.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
operator|!
name|DECL_VIRTUAL_P
argument_list|(
name|decl
argument_list|)
operator|&&
operator|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"initialized variable `%s' is marked dllimport"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Nor can they be static.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
comment|/* ??? Is this test for vtables needed?  */
operator|&&
operator|!
name|DECL_VIRTUAL_P
argument_list|(
name|decl
argument_list|)
operator|&&
literal|0
comment|/*???*/
condition|)
block|{
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"static variable `%s' is marked dllimport"
argument_list|)
expr_stmt|;
return|return;
block|}
name|newname
operator|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|oldname
argument_list|)
operator|+
literal|11
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|newname
argument_list|,
literal|"%ci._imp__%s"
argument_list|,
name|DLL_IMPORT_EXPORT_PREFIX
argument_list|,
name|oldname
argument_list|)
expr_stmt|;
comment|/* We pass newname through get_identifier to ensure it has a unique      address.  RTL processing can sometimes peek inside the symbol ref      and compare the string's addresses to see if two symbols are      identical.  */
name|idp
operator|=
name|get_identifier
argument_list|(
name|newname
argument_list|)
expr_stmt|;
name|newrtl
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|Pmode
argument_list|,
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|idp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|=
name|newrtl
expr_stmt|;
comment|/* Can't treat a pointer to this as a constant address */
name|DECL_NON_ADDR_CONST_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return string which is the former assembler name modified with a     suffix consisting of an atsign (@) followed by the number of bytes of     arguments */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|gen_stdcall_suffix
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|int
name|total
init|=
literal|0
decl_stmt|;
comment|/* ??? This probably should use XSTR (XEXP (DECL_RTL (decl), 0), 0) instead      of DECL_ASSEMBLER_NAME.  */
specifier|const
name|char
modifier|*
name|asmname
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
name|newsym
decl_stmt|;
if|if
condition|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|tree_last
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|==
name|void_type_node
condition|)
block|{
name|tree
name|formal_type
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
name|TREE_VALUE
argument_list|(
name|formal_type
argument_list|)
operator|!=
name|void_type_node
condition|)
block|{
name|int
name|parm_size
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_VALUE
argument_list|(
name|formal_type
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Must round up to include padding.  This is done the same 	       way as in store_one_arg.  */
name|parm_size
operator|=
operator|(
operator|(
name|parm_size
operator|+
name|PARM_BOUNDARY
operator|-
literal|1
operator|)
operator|/
name|PARM_BOUNDARY
operator|*
name|PARM_BOUNDARY
operator|)
expr_stmt|;
name|total
operator|+=
name|parm_size
expr_stmt|;
name|formal_type
operator|=
name|TREE_CHAIN
argument_list|(
name|formal_type
argument_list|)
expr_stmt|;
block|}
block|}
name|newsym
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|asmname
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|newsym
argument_list|,
literal|"%s@%d"
argument_list|,
name|asmname
argument_list|,
name|total
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
return|return
name|IDENTIFIER_POINTER
argument_list|(
name|get_identifier
argument_list|(
name|newsym
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|i386_pe_encode_section_info
parameter_list|(
name|decl
parameter_list|,
name|first
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|int
name|first
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|first
condition|)
return|return;
comment|/* This bit is copied from i386.h.  */
if|if
condition|(
name|optimize
operator|>
literal|0
operator|&&
name|TREE_CONSTANT
argument_list|(
name|decl
argument_list|)
operator|&&
operator|(
operator|!
name|flag_writable_strings
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|STRING_CST
operator|)
condition|)
block|{
name|rtx
name|rtl
init|=
operator|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
literal|'d'
condition|?
name|TREE_CST_RTL
argument_list|(
name|decl
argument_list|)
else|:
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|)
decl_stmt|;
name|SYMBOL_REF_FLAG
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"stdcall"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
condition|)
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
name|gen_stdcall_suffix
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Mark the decl so we can tell from the rtl whether the object is      dllexport'd or dllimport'd.  */
if|if
condition|(
name|i386_pe_dllexport_p
argument_list|(
name|decl
argument_list|)
condition|)
name|i386_pe_mark_dllexport
argument_list|(
name|decl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i386_pe_dllimport_p
argument_list|(
name|decl
argument_list|)
condition|)
name|i386_pe_mark_dllimport
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* It might be that DECL has already been marked as dllimport, but a      subsequent definition nullified that.  The attribute is gone but      DECL_RTL still has (DLL_IMPORT_EXPORT_PREFIX)i._imp__foo.  We need      to remove that. Ditto for the DECL_NON_ADDR_CONST_P flag.  */
elseif|else
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|)
operator|&&
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL_RTX
operator|&&
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|i386_pe_dllimport_name_p
argument_list|(
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|oldname
init|=
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|idp
init|=
name|get_identifier
argument_list|(
name|oldname
operator|+
literal|9
argument_list|)
decl_stmt|;
name|rtx
name|newrtl
init|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|idp
argument_list|)
argument_list|)
decl_stmt|;
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|=
name|newrtl
expr_stmt|;
name|DECL_NON_ADDR_CONST_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* We previously set TREE_PUBLIC and DECL_EXTERNAL. 	 We leave these alone for now.  */
block|}
block|}
end_function

begin_comment
comment|/* Strip only the leading encoding, leaving the stdcall suffix.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|i386_pe_strip_name_encoding
parameter_list|(
name|str
parameter_list|)
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
block|{
if|if
condition|(
operator|*
name|str
operator|==
name|DLL_IMPORT_EXPORT_PREFIX
condition|)
name|str
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
literal|'*'
condition|)
name|str
operator|+=
literal|1
expr_stmt|;
return|return
name|str
return|;
block|}
end_function

begin_comment
comment|/* Also strip the stdcall suffix.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|i386_pe_strip_name_encoding_full
parameter_list|(
name|str
parameter_list|)
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|i386_pe_strip_name_encoding
argument_list|(
name|str
argument_list|)
decl_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
return|return
name|ggc_alloc_string
argument_list|(
name|name
argument_list|,
name|p
operator|-
name|name
argument_list|)
return|;
return|return
name|name
return|;
block|}
end_function

begin_function
name|void
name|i386_pe_unique_section
parameter_list|(
name|decl
parameter_list|,
name|reloc
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|int
name|reloc
decl_stmt|;
block|{
name|int
name|len
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|prefix
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|name
operator|=
name|i386_pe_strip_name_encoding_full
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* The object is put in, for example, section .text$foo.      The linker will then ultimately place them in .text      (everything from the $ on is stripped). Don't put      read-only data in .rdata section to avoid a PE linker       bug when .rdata$* grouped sections are used in code      without a .rdata section.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|prefix
operator|=
literal|".text$"
expr_stmt|;
elseif|else
if|if
condition|(
name|decl_readonly_section
argument_list|(
name|decl
argument_list|,
name|reloc
argument_list|)
condition|)
name|prefix
operator|=
literal|".rdata$"
expr_stmt|;
else|else
name|prefix
operator|=
literal|".data$"
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
name|string
operator|=
name|alloca
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"%s%s"
argument_list|,
name|prefix
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|DECL_SECTION_NAME
argument_list|(
name|decl
argument_list|)
operator|=
name|build_string
argument_list|(
name|len
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Select a set of attributes for section NAME based on the properties    of DECL and whether or not RELOC indicates that DECL's initializer    might contain runtime relocations.     We make the section read-only and executable for a function decl,    read-only for a const data decl, and writable for a non-const data decl.     If the section has already been defined, to not allow it to have    different attributes, as (1) this is ambiguous since we're not seeing    all the declarations up front and (2) some assemblers (e.g. SVR4)    do not recoginize section redefinitions.  */
end_comment

begin_comment
comment|/* ??? This differs from the "standard" PE implementation in that we    handle the SHARED variable attribute.  Should this be done for all    PE targets?  */
end_comment

begin_define
define|#
directive|define
name|SECTION_PE_SHARED
value|SECTION_MACH_DEP
end_define

begin_function
name|unsigned
name|int
name|i386_pe_section_type_flags
parameter_list|(
name|decl
parameter_list|,
name|name
parameter_list|,
name|reloc
parameter_list|)
name|tree
name|decl
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|reloc
decl_stmt|;
block|{
specifier|static
name|htab_t
name|htab
decl_stmt|;
name|unsigned
name|int
name|flags
decl_stmt|;
name|unsigned
name|int
modifier|*
modifier|*
name|slot
decl_stmt|;
comment|/* The names we put in the hashtable will always be the unique      versions gived to us by the stringtable, so we can just use      their addresses as the keys.  */
if|if
condition|(
operator|!
name|htab
condition|)
name|htab
operator|=
name|htab_create
argument_list|(
literal|31
argument_list|,
name|htab_hash_pointer
argument_list|,
name|htab_eq_pointer
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|flags
operator|=
name|SECTION_CODE
expr_stmt|;
elseif|else
if|if
condition|(
name|decl
operator|&&
name|decl_readonly_section
argument_list|(
name|decl
argument_list|,
name|reloc
argument_list|)
condition|)
name|flags
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|flags
operator|=
name|SECTION_WRITE
expr_stmt|;
if|if
condition|(
name|decl
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|lookup_attribute
argument_list|(
literal|"shared"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|flags
operator||=
name|SECTION_PE_SHARED
expr_stmt|;
block|}
if|if
condition|(
name|decl
operator|&&
name|DECL_ONE_ONLY
argument_list|(
name|decl
argument_list|)
condition|)
name|flags
operator||=
name|SECTION_LINKONCE
expr_stmt|;
comment|/* See if we already have an entry for this section.  */
name|slot
operator|=
operator|(
name|unsigned
name|int
operator|*
operator|*
operator|)
name|htab_find_slot
argument_list|(
name|htab
argument_list|,
name|name
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|slot
condition|)
block|{
operator|*
name|slot
operator|=
operator|(
name|unsigned
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
argument_list|)
expr_stmt|;
operator|*
operator|*
name|slot
operator|=
name|flags
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|decl
operator|&&
operator|*
operator|*
name|slot
operator|!=
name|flags
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"%s causes a section type conflict"
argument_list|)
expr_stmt|;
block|}
return|return
name|flags
return|;
block|}
end_function

begin_function
name|void
name|i386_pe_asm_named_section
parameter_list|(
name|name
parameter_list|,
name|flags
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|int
name|flags
decl_stmt|;
block|{
name|char
name|flagchars
index|[
literal|8
index|]
decl_stmt|,
modifier|*
name|f
init|=
name|flagchars
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|SECTION_CODE
condition|)
operator|*
name|f
operator|++
operator|=
literal|'x'
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SECTION_WRITE
condition|)
operator|*
name|f
operator|++
operator|=
literal|'w'
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SECTION_PE_SHARED
condition|)
operator|*
name|f
operator|++
operator|=
literal|'s'
expr_stmt|;
operator|*
name|f
operator|=
literal|'\0'
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.section\t%s,\"%s\"\n"
argument_list|,
name|name
argument_list|,
name|flagchars
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SECTION_LINKONCE
condition|)
block|{
comment|/* Functions may have been compiled at various levels of          optimization so we can't use `same_size' here.          Instead, have the linker pick one.  */
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.linkonce %s\n"
argument_list|,
operator|(
name|flags
operator|&
name|SECTION_CODE
condition|?
literal|"discard"
else|:
literal|"same_size"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The Microsoft linker requires that every function be marked as    DT_FCN.  When using gas on cygwin, we must emit appropriate .type    directives.  */
end_comment

begin_include
include|#
directive|include
file|"gsyms.h"
end_include

begin_comment
comment|/* Mark a function appropriately.  This should only be called for    functions for which we are not emitting COFF debugging information.    FILE is the assembler output file, NAME is the name of the    function, and PUBLIC is nonzero if the function is globally    visible.  */
end_comment

begin_function
name|void
name|i386_pe_declare_function_type
parameter_list|(
name|file
parameter_list|,
name|name
parameter_list|,
name|public
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|public
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.def\t"
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";\t.scl\t%d;\t.type\t%d;\t.endef\n"
argument_list|,
name|public
condition|?
operator|(
name|int
operator|)
name|C_EXT
else|:
operator|(
name|int
operator|)
name|C_STAT
argument_list|,
operator|(
name|int
operator|)
name|DT_FCN
operator|<<
name|N_BTSHFT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Keep a list of external functions.  */
end_comment

begin_struct
struct|struct
name|extern_list
block|{
name|struct
name|extern_list
modifier|*
name|next
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|extern_list
modifier|*
name|extern_head
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Assemble an external function reference.  We need to keep a list of    these, so that we can output the function types at the end of the    assembly.  We can't output the types now, because we might see a    definition of the function later on and emit debugging information    for it then.  */
end_comment

begin_function
name|void
name|i386_pe_record_external_function
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|extern_list
modifier|*
name|p
decl_stmt|;
name|p
operator|=
operator|(
expr|struct
name|extern_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|extern_head
expr_stmt|;
name|p
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|extern_head
operator|=
name|p
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Keep a list of exported symbols.  */
end_comment

begin_struct
struct|struct
name|export_list
block|{
name|struct
name|export_list
modifier|*
name|next
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|is_data
decl_stmt|;
comment|/* used to type tag exported symbols.  */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|export_list
modifier|*
name|export_head
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Assemble an export symbol entry.  We need to keep a list of    these, so that we can output the export list at the end of the    assembly.  We used to output these export symbols in each function,    but that causes problems with GNU ld when the sections are     linkonce.  */
end_comment

begin_function
name|void
name|i386_pe_record_exported_symbol
parameter_list|(
name|name
parameter_list|,
name|is_data
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|is_data
decl_stmt|;
block|{
name|struct
name|export_list
modifier|*
name|p
decl_stmt|;
name|p
operator|=
operator|(
expr|struct
name|export_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|export_head
expr_stmt|;
name|p
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|p
operator|->
name|is_data
operator|=
name|is_data
expr_stmt|;
name|export_head
operator|=
name|p
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is called at the end of assembly.  For each external function    which has not been defined, we output a declaration now.  We also    output the .drectve section.  */
end_comment

begin_function
name|void
name|i386_pe_asm_file_end
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|struct
name|extern_list
modifier|*
name|p
decl_stmt|;
name|ix86_asm_file_end
argument_list|(
name|file
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|extern_head
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|tree
name|decl
decl_stmt|;
name|decl
operator|=
name|get_identifier
argument_list|(
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* Positively ensure only one declaration for any given symbol.  */
if|if
condition|(
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_SYMBOL_REFERENCED
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|i386_pe_declare_function_type
argument_list|(
name|file
argument_list|,
name|p
operator|->
name|name
argument_list|,
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|export_head
condition|)
block|{
name|struct
name|export_list
modifier|*
name|q
decl_stmt|;
name|drectve_section
argument_list|()
expr_stmt|;
for|for
control|(
name|q
operator|=
name|export_head
init|;
name|q
operator|!=
name|NULL
condition|;
name|q
operator|=
name|q
operator|->
name|next
control|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.ascii \" -export:%s%s\"\n"
argument_list|,
name|i386_pe_strip_name_encoding
argument_list|(
name|q
operator|->
name|name
argument_list|)
argument_list|,
operator|(
name|q
operator|->
name|is_data
operator|)
condition|?
literal|",data"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

