begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Subroutines for insn-output.c for Intel X86.    Copyright (C) 1988, 92, 94-98, 1999 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"conditions.h"
end_include

begin_include
include|#
directive|include
file|"insn-flags.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|EXTRA_CONSTRAINT
end_ifdef

begin_comment
comment|/* If EXTRA_CONSTRAINT is defined, then the 'S'    constraint in REG_CLASS_FROM_LETTER will no longer work, and various    asm statements that need 'S' for class SIREG will break.  */
end_comment

begin_decl_stmt
name|error
name|EXTRA_CONSTRAINT
name|conflicts
name|with
name|S
name|constraint
name|letter
comment|/* The previous line used to be #error, but some compilers barf    even if the conditional was untrue.  */
endif|#
directive|endif
ifndef|#
directive|ifndef
name|CHECK_STACK_LIMIT
define|#
directive|define
name|CHECK_STACK_LIMIT
value|-1
endif|#
directive|endif
define|#
directive|define
name|PIC_REG_USED
define|\
value|(flag_pic&& (current_function_uses_pic_offset_table	\ 		|| current_function_uses_const_pool	\ 		|| profile_flag || profile_block_flag))
comment|/* Type of an operand for ix86_{binary,unary}_operator_ok */
type|enum
name|reg_mem
block|{
name|reg_p
operator|,
name|mem_p
operator|,
name|imm_p
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* Processor costs (relative to an add) */
end_comment

begin_decl_stmt
name|struct
name|processor_costs
name|i386_cost
init|=
block|{
comment|/* 386 specific costs */
literal|1
block|,
comment|/* cost of an add instruction */
literal|1
block|,
comment|/* cost of a lea instruction */
literal|3
block|,
comment|/* variable shift costs */
literal|2
block|,
comment|/* constant shift costs */
literal|6
block|,
comment|/* cost of starting a multiply */
literal|1
block|,
comment|/* cost of multiply per each bit set */
literal|23
comment|/* cost of a divide/mod */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|processor_costs
name|i486_cost
init|=
block|{
comment|/* 486 specific costs */
literal|1
block|,
comment|/* cost of an add instruction */
literal|1
block|,
comment|/* cost of a lea instruction */
literal|3
block|,
comment|/* variable shift costs */
literal|2
block|,
comment|/* constant shift costs */
literal|12
block|,
comment|/* cost of starting a multiply */
literal|1
block|,
comment|/* cost of multiply per each bit set */
literal|40
comment|/* cost of a divide/mod */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|processor_costs
name|pentium_cost
init|=
block|{
literal|1
block|,
comment|/* cost of an add instruction */
literal|1
block|,
comment|/* cost of a lea instruction */
literal|4
block|,
comment|/* variable shift costs */
literal|1
block|,
comment|/* constant shift costs */
literal|11
block|,
comment|/* cost of starting a multiply */
literal|0
block|,
comment|/* cost of multiply per each bit set */
literal|25
comment|/* cost of a divide/mod */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|processor_costs
name|pentiumpro_cost
init|=
block|{
literal|1
block|,
comment|/* cost of an add instruction */
literal|1
block|,
comment|/* cost of a lea instruction */
literal|3
block|,
comment|/* variable shift costs */
literal|1
block|,
comment|/* constant shift costs */
literal|4
block|,
comment|/* cost of starting a multiply */
literal|0
block|,
comment|/* cost of multiply per each bit set */
literal|17
comment|/* cost of a divide/mod */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We use decoding time together with execution time.     To get correct vale add 1 for short decodable, 2 for long decodable    and 4 for vector decodable instruction to execution time and divide    by two (because CPU is able to do two insns at a time). */
end_comment

begin_decl_stmt
name|struct
name|processor_costs
name|k6_cost
init|=
block|{
literal|1
block|,
comment|/* cost of an add instruction */
literal|1
block|,
comment|/* cost of a lea instruction */
literal|1
block|,
comment|/* variable shift costs */
literal|1
block|,
comment|/* constant shift costs */
literal|3
block|,
comment|/* cost of starting a multiply */
literal|0
block|,
comment|/* cost of multiply per each bit set */
literal|20
comment|/* cost of a divide/mod */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|processor_costs
modifier|*
name|ix86_cost
init|=
operator|&
name|pentium_cost
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Processor feature/optimization bitmasks.  */
end_comment

begin_define
define|#
directive|define
name|m_386
value|(1<<PROCESSOR_I386)
end_define

begin_define
define|#
directive|define
name|m_486
value|(1<<PROCESSOR_I486)
end_define

begin_define
define|#
directive|define
name|m_PENT
value|(1<<PROCESSOR_PENTIUM)
end_define

begin_define
define|#
directive|define
name|m_PPRO
value|(1<<PROCESSOR_PENTIUMPRO)
end_define

begin_define
define|#
directive|define
name|m_K6
value|(1<<PROCESSOR_K6)
end_define

begin_decl_stmt
specifier|const
name|int
name|x86_use_leave
init|=
name|m_386
operator||
name|m_K6
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_push_memory
init|=
name|m_386
operator||
name|m_K6
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_zero_extend_with_and
init|=
name|m_486
operator||
name|m_PENT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_movx
init|=
name|m_386
operator||
name|m_PPRO
operator||
name|m_K6
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_double_with_add
init|=
operator|~
operator|(
name|m_386
operator||
name|m_PENT
operator||
name|m_PPRO
operator|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_use_bit_test
init|=
name|m_386
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_unroll_strlen
init|=
name|m_486
operator||
name|m_PENT
operator||
name|m_PPRO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_use_q_reg
init|=
name|m_PENT
operator||
name|m_PPRO
operator||
name|m_K6
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_use_any_reg
init|=
name|m_486
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_cmove
init|=
name|m_PPRO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_deep_branch
init|=
name|m_PPRO
operator||
name|m_K6
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|AT_BP
parameter_list|(
name|mode
parameter_list|)
value|(gen_rtx_MEM ((mode), frame_pointer_rtx))
end_define

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|asm_out_file
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|char
modifier|*
name|strcat
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|ix86_epilogue
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ix86_prologue
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|singlemove_string
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|output_move_const_single
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|output_fp_cc0_set
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|char
modifier|*
name|hi_reg_name
index|[]
init|=
name|HI_REGISTER_NAMES
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|qi_reg_name
index|[]
init|=
name|QI_REGISTER_NAMES
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|qi_high_reg_name
index|[]
init|=
name|QI_HIGH_REGISTER_NAMES
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Array of the smallest class containing reg number REGNO, indexed by    REGNO.  Used by REGNO_REG_CLASS in i386.h. */
end_comment

begin_decl_stmt
name|enum
name|reg_class
name|regclass_map
index|[
name|FIRST_PSEUDO_REGISTER
index|]
init|=
block|{
comment|/* ax, dx, cx, bx */
name|AREG
block|,
name|DREG
block|,
name|CREG
block|,
name|BREG
block|,
comment|/* si, di, bp, sp */
name|SIREG
block|,
name|DIREG
block|,
name|INDEX_REGS
block|,
name|GENERAL_REGS
block|,
comment|/* FP registers */
name|FP_TOP_REG
block|,
name|FP_SECOND_REG
block|,
name|FLOAT_REGS
block|,
name|FLOAT_REGS
block|,
name|FLOAT_REGS
block|,
name|FLOAT_REGS
block|,
name|FLOAT_REGS
block|,
name|FLOAT_REGS
block|,
comment|/* arg pointer */
name|INDEX_REGS
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Test and compare insns in i386.md store the information needed to    generate branch and scc insns here.  */
end_comment

begin_decl_stmt
name|struct
name|rtx_def
modifier|*
name|i386_compare_op0
init|=
name|NULL_RTX
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rtx_def
modifier|*
name|i386_compare_op1
init|=
name|NULL_RTX
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rtx_def
modifier|*
argument_list|(
operator|*
name|i386_compare_gen
argument_list|)
argument_list|()
decl_stmt|,
modifier|*
argument_list|(
operator|*
name|i386_compare_gen_eq
argument_list|)
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* which cpu are we scheduling for */
end_comment

begin_decl_stmt
name|enum
name|processor_type
name|ix86_cpu
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* which instruction set architecture to use.  */
end_comment

begin_decl_stmt
name|int
name|ix86_arch
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Strings to hold which cpu and instruction set architecture  to use.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|ix86_cpu_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for -mcpu=<xxx> */
end_comment

begin_decl_stmt
name|char
modifier|*
name|ix86_arch_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for -march=<xxx> */
end_comment

begin_comment
comment|/* Register allocation order */
end_comment

begin_decl_stmt
name|char
modifier|*
name|i386_reg_alloc_order
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|regs_allocated
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # of registers to use to pass arguments. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|i386_regparm_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* i386_regparm_string as a number */
end_comment

begin_decl_stmt
name|int
name|i386_regparm
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Alignment to use for loops and jumps:  */
end_comment

begin_comment
comment|/* Power of two alignment for loops. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|i386_align_loops_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Power of two alignment for non-loop jumps. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|i386_align_jumps_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Power of two alignment for stack boundary in bytes.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|i386_preferred_stack_boundary_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Preferred alignment for stack boundary in bits.  */
end_comment

begin_decl_stmt
name|int
name|i386_preferred_stack_boundary
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Values 1-5: see jump.c */
end_comment

begin_decl_stmt
name|int
name|i386_branch_cost
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|i386_branch_cost_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Power of two alignment for functions. */
end_comment

begin_decl_stmt
name|int
name|i386_align_funcs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|i386_align_funcs_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Power of two alignment for loops. */
end_comment

begin_decl_stmt
name|int
name|i386_align_loops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Power of two alignment for non-loop jumps. */
end_comment

begin_decl_stmt
name|int
name|i386_align_jumps
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Sometimes certain combinations of command options do not make    sense on a particular target machine.  You can define a macro    `OVERRIDE_OPTIONS' to take account of this.  This macro, if    defined, is executed once just after all the command options have    been parsed.     Don't use this macro to turn on various extra optimizations for    `-O'.  That is what `OPTIMIZATION_OPTIONS' is for.  */
end_comment

begin_function
name|void
name|override_options
parameter_list|()
block|{
name|int
name|ch
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|def_align
decl_stmt|;
specifier|static
struct|struct
name|ptt
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Canonical processor name.  */
name|enum
name|processor_type
name|processor
decl_stmt|;
comment|/* Processor type enum value.  */
name|struct
name|processor_costs
modifier|*
name|cost
decl_stmt|;
comment|/* Processor costs */
name|int
name|target_enable
decl_stmt|;
comment|/* Target flags to enable.  */
name|int
name|target_disable
decl_stmt|;
comment|/* Target flags to disable.  */
block|}
name|processor_target_table
index|[]
init|=
block|{
block|{
name|PROCESSOR_I386_STRING
block|,
name|PROCESSOR_I386
block|,
operator|&
name|i386_cost
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|PROCESSOR_I486_STRING
block|,
name|PROCESSOR_I486
block|,
operator|&
name|i486_cost
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|PROCESSOR_I586_STRING
block|,
name|PROCESSOR_PENTIUM
block|,
operator|&
name|pentium_cost
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|PROCESSOR_PENTIUM_STRING
block|,
name|PROCESSOR_PENTIUM
block|,
operator|&
name|pentium_cost
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|PROCESSOR_I686_STRING
block|,
name|PROCESSOR_PENTIUMPRO
block|,
operator|&
name|pentiumpro_cost
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|PROCESSOR_PENTIUMPRO_STRING
block|,
name|PROCESSOR_PENTIUMPRO
block|,
operator|&
name|pentiumpro_cost
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|PROCESSOR_K6_STRING
block|,
name|PROCESSOR_K6
block|,
operator|&
name|k6_cost
block|,
literal|0
block|,
literal|0
block|}
block|}
struct|;
name|int
name|ptt_size
init|=
sizeof|sizeof
argument_list|(
name|processor_target_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|ptt
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|SUBTARGET_OVERRIDE_OPTIONS
name|SUBTARGET_OVERRIDE_OPTIONS
expr_stmt|;
endif|#
directive|endif
comment|/* Validate registers in register allocation order.  */
if|if
condition|(
name|i386_reg_alloc_order
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|ch
operator|=
name|i386_reg_alloc_order
index|[
name|i
index|]
operator|)
operator|!=
literal|'\0'
condition|;
name|i
operator|++
control|)
block|{
name|int
name|regno
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'a'
case|:
name|regno
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|regno
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|regno
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|regno
operator|=
literal|3
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|regno
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|regno
operator|=
literal|5
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
name|regno
operator|=
literal|6
expr_stmt|;
break|break;
default|default:
name|fatal
argument_list|(
literal|"Register '%c' is unknown"
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|regs_allocated
index|[
name|regno
index|]
condition|)
name|fatal
argument_list|(
literal|"Register '%c' already specified in allocation order"
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|regs_allocated
index|[
name|regno
index|]
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ix86_arch_string
operator|==
literal|0
condition|)
block|{
name|ix86_arch_string
operator|=
name|PROCESSOR_PENTIUM_STRING
expr_stmt|;
if|if
condition|(
name|ix86_cpu_string
operator|==
literal|0
condition|)
name|ix86_cpu_string
operator|=
name|PROCESSOR_DEFAULT_STRING
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ptt_size
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ix86_arch_string
argument_list|,
name|processor_target_table
index|[
name|i
index|]
operator|.
name|name
argument_list|)
condition|)
block|{
name|ix86_arch
operator|=
name|processor_target_table
index|[
name|i
index|]
operator|.
name|processor
expr_stmt|;
if|if
condition|(
name|ix86_cpu_string
operator|==
literal|0
condition|)
name|ix86_cpu_string
operator|=
name|processor_target_table
index|[
name|i
index|]
operator|.
name|name
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|ptt_size
condition|)
block|{
name|error
argument_list|(
literal|"bad value (%s) for -march= switch"
argument_list|,
name|ix86_arch_string
argument_list|)
expr_stmt|;
name|ix86_arch_string
operator|=
name|PROCESSOR_PENTIUM_STRING
expr_stmt|;
name|ix86_arch
operator|=
name|PROCESSOR_DEFAULT
expr_stmt|;
block|}
if|if
condition|(
name|ix86_cpu_string
operator|==
literal|0
condition|)
name|ix86_cpu_string
operator|=
name|PROCESSOR_DEFAULT_STRING
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ptt_size
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ix86_cpu_string
argument_list|,
name|processor_target_table
index|[
name|j
index|]
operator|.
name|name
argument_list|)
condition|)
block|{
name|ix86_cpu
operator|=
name|processor_target_table
index|[
name|j
index|]
operator|.
name|processor
expr_stmt|;
name|ix86_cost
operator|=
name|processor_target_table
index|[
name|j
index|]
operator|.
name|cost
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|j
operator|&&
operator|(
name|int
operator|)
name|ix86_arch
operator|>=
operator|(
name|int
operator|)
name|PROCESSOR_K6
condition|)
name|error
argument_list|(
literal|"-mcpu=%s does not support -march=%s"
argument_list|,
name|ix86_cpu_string
argument_list|,
name|ix86_arch_string
argument_list|)
expr_stmt|;
name|target_flags
operator||=
name|processor_target_table
index|[
name|j
index|]
operator|.
name|target_enable
expr_stmt|;
name|target_flags
operator|&=
operator|~
name|processor_target_table
index|[
name|j
index|]
operator|.
name|target_disable
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|j
operator|==
name|ptt_size
condition|)
block|{
name|error
argument_list|(
literal|"bad value (%s) for -mcpu= switch"
argument_list|,
name|ix86_cpu_string
argument_list|)
expr_stmt|;
name|ix86_cpu_string
operator|=
name|PROCESSOR_DEFAULT_STRING
expr_stmt|;
name|ix86_cpu
operator|=
name|PROCESSOR_DEFAULT
expr_stmt|;
block|}
comment|/* Validate -mregparm= value. */
if|if
condition|(
name|i386_regparm_string
condition|)
block|{
name|i386_regparm
operator|=
name|atoi
argument_list|(
name|i386_regparm_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|i386_regparm
operator|<
literal|0
operator|||
name|i386_regparm
operator|>
name|REGPARM_MAX
condition|)
name|fatal
argument_list|(
literal|"-mregparm=%d is not between 0 and %d"
argument_list|,
name|i386_regparm
argument_list|,
name|REGPARM_MAX
argument_list|)
expr_stmt|;
block|}
comment|/* The 486 suffers more from non-aligned cache line fills, and the      larger code size results in a larger cache foot-print and more misses.      The 486 has a 16 byte cache line, pentium and pentiumpro have a 32 byte      cache line.  */
name|def_align
operator|=
operator|(
name|TARGET_486
operator|)
condition|?
literal|4
else|:
literal|2
expr_stmt|;
comment|/* Validate -malign-loops= value, or provide default.  */
ifdef|#
directive|ifdef
name|ASM_OUTPUT_MAX_SKIP_ALIGN
name|i386_align_loops
operator|=
literal|4
expr_stmt|;
else|#
directive|else
name|i386_align_loops
operator|=
literal|2
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|i386_align_loops_string
condition|)
block|{
name|i386_align_loops
operator|=
name|atoi
argument_list|(
name|i386_align_loops_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|i386_align_loops
operator|<
literal|0
operator|||
name|i386_align_loops
operator|>
name|MAX_CODE_ALIGN
condition|)
name|fatal
argument_list|(
literal|"-malign-loops=%d is not between 0 and %d"
argument_list|,
name|i386_align_loops
argument_list|,
name|MAX_CODE_ALIGN
argument_list|)
expr_stmt|;
block|}
comment|/* Validate -malign-jumps= value, or provide default.  */
ifdef|#
directive|ifdef
name|ASM_OUTPUT_MAX_SKIP_ALIGN
name|i386_align_jumps
operator|=
literal|4
expr_stmt|;
else|#
directive|else
name|i386_align_jumps
operator|=
name|def_align
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|i386_align_jumps_string
condition|)
block|{
name|i386_align_jumps
operator|=
name|atoi
argument_list|(
name|i386_align_jumps_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|i386_align_jumps
operator|<
literal|0
operator|||
name|i386_align_jumps
operator|>
name|MAX_CODE_ALIGN
condition|)
name|fatal
argument_list|(
literal|"-malign-jumps=%d is not between 0 and %d"
argument_list|,
name|i386_align_jumps
argument_list|,
name|MAX_CODE_ALIGN
argument_list|)
expr_stmt|;
block|}
comment|/* Validate -malign-functions= value, or provide default. */
name|i386_align_funcs
operator|=
name|def_align
expr_stmt|;
if|if
condition|(
name|i386_align_funcs_string
condition|)
block|{
name|i386_align_funcs
operator|=
name|atoi
argument_list|(
name|i386_align_funcs_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|i386_align_funcs
operator|<
literal|0
operator|||
name|i386_align_funcs
operator|>
name|MAX_CODE_ALIGN
condition|)
name|fatal
argument_list|(
literal|"-malign-functions=%d is not between 0 and %d"
argument_list|,
name|i386_align_funcs
argument_list|,
name|MAX_CODE_ALIGN
argument_list|)
expr_stmt|;
block|}
comment|/* Validate -mpreferred_stack_boundary= value, or provide default.      The default of 128 bits is for Pentium III's SSE __m128.  */
name|i386_preferred_stack_boundary
operator|=
literal|128
expr_stmt|;
if|if
condition|(
name|i386_preferred_stack_boundary_string
condition|)
block|{
name|i
operator|=
name|atoi
argument_list|(
name|i386_preferred_stack_boundary_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|2
operator|||
name|i
operator|>
literal|31
condition|)
name|fatal
argument_list|(
literal|"-mpreferred_stack_boundary=%d is not between 2 and 31"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|i386_preferred_stack_boundary
operator|=
operator|(
literal|1
operator|<<
name|i
operator|)
operator|*
name|BITS_PER_UNIT
expr_stmt|;
block|}
comment|/* Validate -mbranch-cost= value, or provide default. */
name|i386_branch_cost
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|i386_branch_cost_string
condition|)
block|{
name|i386_branch_cost
operator|=
name|atoi
argument_list|(
name|i386_branch_cost_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|i386_branch_cost
operator|<
literal|0
operator|||
name|i386_branch_cost
operator|>
literal|5
condition|)
name|fatal
argument_list|(
literal|"-mbranch-cost=%d is not between 0 and 5"
argument_list|,
name|i386_branch_cost
argument_list|)
expr_stmt|;
block|}
comment|/* Keep nonleaf frame pointers.  */
if|if
condition|(
name|TARGET_OMIT_LEAF_FRAME_POINTER
condition|)
name|flag_omit_frame_pointer
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A C statement (sans semicolon) to choose the order in which to    allocate hard registers for pseudo-registers local to a basic    block.     Store the desired register order in the array `reg_alloc_order'.    Element 0 should be the register to allocate first; element 1, the    next register; and so on.     The macro body should not assume anything about the contents of    `reg_alloc_order' before execution of the macro.     On most machines, it is not necessary to define this macro.  */
end_comment

begin_function
name|void
name|order_regs_for_local_alloc
parameter_list|()
block|{
name|int
name|i
decl_stmt|,
name|ch
decl_stmt|,
name|order
decl_stmt|;
comment|/* User specified the register allocation order.  */
if|if
condition|(
name|i386_reg_alloc_order
condition|)
block|{
for|for
control|(
name|i
operator|=
name|order
operator|=
literal|0
init|;
operator|(
name|ch
operator|=
name|i386_reg_alloc_order
index|[
name|i
index|]
operator|)
operator|!=
literal|'\0'
condition|;
name|i
operator|++
control|)
block|{
name|int
name|regno
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'a'
case|:
name|regno
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|regno
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|regno
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|regno
operator|=
literal|3
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|regno
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|regno
operator|=
literal|5
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
name|regno
operator|=
literal|6
expr_stmt|;
break|break;
block|}
name|reg_alloc_order
index|[
name|order
operator|++
index|]
operator|=
name|regno
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|regs_allocated
index|[
name|i
index|]
condition|)
name|reg_alloc_order
index|[
name|order
operator|++
index|]
operator|=
name|i
expr_stmt|;
block|}
block|}
comment|/* If user did not specify a register allocation order, use natural order. */
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
name|reg_alloc_order
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|optimization_options
parameter_list|(
name|level
parameter_list|,
name|size
parameter_list|)
name|int
name|level
decl_stmt|;
name|int
name|size
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
comment|/* For -O2 and beyond, turn off -fschedule-insns by default.  It tends to      make the problem with not enough registers even worse.  */
ifdef|#
directive|ifdef
name|INSN_SCHEDULING
if|if
condition|(
name|level
operator|>
literal|1
condition|)
name|flag_schedule_insns
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Sign-extend a 16-bit constant */
end_comment

begin_function
name|struct
name|rtx_def
modifier|*
name|i386_sext16_if_const
parameter_list|(
name|op
parameter_list|)
name|struct
name|rtx_def
modifier|*
name|op
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|HOST_WIDE_INT
name|val
init|=
name|INTVAL
argument_list|(
name|op
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|sext_val
decl_stmt|;
if|if
condition|(
name|val
operator|&
literal|0x8000
condition|)
name|sext_val
operator|=
name|val
operator||
operator|~
literal|0xffff
expr_stmt|;
else|else
name|sext_val
operator|=
name|val
operator|&
literal|0xffff
expr_stmt|;
if|if
condition|(
name|sext_val
operator|!=
name|val
condition|)
name|op
operator|=
name|GEN_INT
argument_list|(
name|sext_val
argument_list|)
expr_stmt|;
block|}
return|return
name|op
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if the rtx is aligned */
end_comment

begin_function
specifier|static
name|int
name|i386_aligned_reg_p
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
return|return
operator|(
name|regno
operator|==
name|STACK_POINTER_REGNUM
operator|||
operator|(
operator|!
name|flag_omit_frame_pointer
operator|&&
name|regno
operator|==
name|FRAME_POINTER_REGNUM
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|i386_aligned_p
parameter_list|(
name|op
parameter_list|)
name|rtx
name|op
decl_stmt|;
block|{
comment|/* Registers and immediate operands are always "aligned". */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|MEM
condition|)
return|return
literal|1
return|;
comment|/* Don't even try to do any aligned optimizations with volatiles. */
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Get address of memory operand. */
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|CONST_INT
case|:
if|if
condition|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|&
literal|3
condition|)
break|break;
return|return
literal|1
return|;
comment|/* Match "reg + offset" */
case|case
name|PLUS
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
break|break;
if|if
condition|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&
literal|3
condition|)
break|break;
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|REG
condition|)
break|break;
comment|/* ... fall through ... */
case|case
name|REG
case|:
return|return
name|i386_aligned_reg_p
argument_list|(
name|REGNO
argument_list|(
name|op
argument_list|)
argument_list|)
return|;
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if INSN looks like it won't compute useful cc bits    as a side effect.  This information is only a hint. */
end_comment

begin_function
name|int
name|i386_cc_probably_useless_p
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
return|return
operator|!
name|next_cc0_user
argument_list|(
name|insn
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if IDENTIFIER with arguments ARGS is a valid machine specific    attribute for DECL.  The attributes in ATTRIBUTES have previously been    assigned to DECL.  */
end_comment

begin_function
name|int
name|i386_valid_decl_attribute_p
parameter_list|(
name|decl
parameter_list|,
name|attributes
parameter_list|,
name|identifier
parameter_list|,
name|args
parameter_list|)
name|tree
name|decl
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|tree
name|attributes
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|tree
name|identifier
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|tree
name|args
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if IDENTIFIER with arguments ARGS is a valid machine specific    attribute for TYPE.  The attributes in ATTRIBUTES have previously been    assigned to TYPE.  */
end_comment

begin_function
name|int
name|i386_valid_type_attribute_p
parameter_list|(
name|type
parameter_list|,
name|attributes
parameter_list|,
name|identifier
parameter_list|,
name|args
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
name|attributes
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|tree
name|identifier
decl_stmt|;
name|tree
name|args
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|FUNCTION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|METHOD_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|FIELD_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
return|return
literal|0
return|;
comment|/* Stdcall attribute says callee is responsible for popping arguments      if they are not variable.  */
if|if
condition|(
name|is_attribute_p
argument_list|(
literal|"stdcall"
argument_list|,
name|identifier
argument_list|)
condition|)
return|return
operator|(
name|args
operator|==
name|NULL_TREE
operator|)
return|;
comment|/* Cdecl attribute says the callee is a normal C declaration. */
if|if
condition|(
name|is_attribute_p
argument_list|(
literal|"cdecl"
argument_list|,
name|identifier
argument_list|)
condition|)
return|return
operator|(
name|args
operator|==
name|NULL_TREE
operator|)
return|;
comment|/* Regparm attribute specifies how many integer arguments are to be      passed in registers. */
if|if
condition|(
name|is_attribute_p
argument_list|(
literal|"regparm"
argument_list|,
name|identifier
argument_list|)
condition|)
block|{
name|tree
name|cst
decl_stmt|;
if|if
condition|(
operator|!
name|args
operator|||
name|TREE_CODE
argument_list|(
name|args
argument_list|)
operator|!=
name|TREE_LIST
operator|||
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
operator|!=
name|NULL_TREE
operator|||
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
operator|==
name|NULL_TREE
condition|)
return|return
literal|0
return|;
name|cst
operator|=
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cst
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_INT_CST_HIGH
argument_list|(
name|cst
argument_list|)
operator|!=
literal|0
operator|||
name|TREE_INT_CST_LOW
argument_list|(
name|cst
argument_list|)
operator|<
literal|0
operator|||
name|TREE_INT_CST_LOW
argument_list|(
name|cst
argument_list|)
operator|>
name|REGPARM_MAX
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 0 if the attributes for two types are incompatible, 1 if they    are compatible, and 2 if they are nearly compatible (which causes a    warning to be generated).  */
end_comment

begin_function
name|int
name|i386_comp_type_attributes
parameter_list|(
name|type1
parameter_list|,
name|type2
parameter_list|)
name|tree
name|type1
decl_stmt|;
name|tree
name|type2
decl_stmt|;
block|{
comment|/* Check for mismatch of non-default calling convention. */
name|char
modifier|*
name|rtdstr
init|=
name|TARGET_RTD
condition|?
literal|"cdecl"
else|:
literal|"stdcall"
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type1
argument_list|)
operator|!=
name|FUNCTION_TYPE
condition|)
return|return
literal|1
return|;
comment|/* Check for mismatched return types (cdecl vs stdcall).  */
if|if
condition|(
operator|!
name|lookup_attribute
argument_list|(
name|rtdstr
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|type1
argument_list|)
argument_list|)
operator|!=
operator|!
name|lookup_attribute
argument_list|(
name|rtdstr
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|type2
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Value is the number of bytes of arguments automatically    popped when returning from a subroutine call.    FUNDECL is the declaration node of the function (as a tree),    FUNTYPE is the data type of the function (as a tree),    or for a library call it is an identifier node for the subroutine name.    SIZE is the number of bytes of arguments passed on the stack.     On the 80386, the RTD insn may be used to pop them if the number      of args is fixed, but if the number is variable then the caller      must pop them all.  RTD can't be used for library calls now      because the library is compiled with the Unix compiler.    Use of RTD is a selectable option, since it is incompatible with    standard Unix calling sequences.  If the option is not selected,    the caller must always pop the args.     The attribute stdcall is equivalent to RTD on a per module basis.  */
end_comment

begin_function
name|int
name|i386_return_pops_args
parameter_list|(
name|fundecl
parameter_list|,
name|funtype
parameter_list|,
name|size
parameter_list|)
name|tree
name|fundecl
decl_stmt|;
name|tree
name|funtype
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|int
name|rtd
init|=
name|TARGET_RTD
operator|&&
operator|(
operator|!
name|fundecl
operator|||
name|TREE_CODE
argument_list|(
name|fundecl
argument_list|)
operator|!=
name|IDENTIFIER_NODE
operator|)
decl_stmt|;
comment|/* Cdecl functions override -mrtd, and never pop the stack. */
if|if
condition|(
operator|!
name|lookup_attribute
argument_list|(
literal|"cdecl"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|funtype
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Stdcall functions will pop the stack if not variable args. */
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"stdcall"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|funtype
argument_list|)
argument_list|)
condition|)
name|rtd
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|rtd
operator|&&
operator|(
name|TYPE_ARG_TYPES
argument_list|(
name|funtype
argument_list|)
operator|==
name|NULL_TREE
operator|||
operator|(
name|TREE_VALUE
argument_list|(
name|tree_last
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|funtype
argument_list|)
argument_list|)
argument_list|)
operator|==
name|void_type_node
operator|)
operator|)
condition|)
return|return
name|size
return|;
block|}
comment|/* Lose any fake structure return argument.  */
if|if
condition|(
name|aggregate_value_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|funtype
argument_list|)
argument_list|)
condition|)
return|return
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Argument support functions.  */
end_comment

begin_comment
comment|/* Initialize a variable CUM of type CUMULATIVE_ARGS    for a call to a function whose data type is FNTYPE.    For a library call, FNTYPE is 0.  */
end_comment

begin_function
name|void
name|init_cumulative_args
parameter_list|(
name|cum
parameter_list|,
name|fntype
parameter_list|,
name|libname
parameter_list|)
name|CUMULATIVE_ARGS
modifier|*
name|cum
decl_stmt|;
comment|/* Argument info to initialize */
name|tree
name|fntype
decl_stmt|;
comment|/* tree ptr for function decl */
name|rtx
name|libname
decl_stmt|;
comment|/* SYMBOL_REF of library name or 0 */
block|{
specifier|static
name|CUMULATIVE_ARGS
name|zero_cum
decl_stmt|;
name|tree
name|param
decl_stmt|,
name|next_param
decl_stmt|;
if|if
condition|(
name|TARGET_DEBUG_ARG
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ninit_cumulative_args ("
argument_list|)
expr_stmt|;
if|if
condition|(
name|fntype
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"fntype code = %s, ret code = %s"
argument_list|,
name|tree_code_name
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|fntype
argument_list|)
index|]
argument_list|,
name|tree_code_name
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|)
index|]
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"no fntype"
argument_list|)
expr_stmt|;
if|if
condition|(
name|libname
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|", libname = %s"
argument_list|,
name|XSTR
argument_list|(
name|libname
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|cum
operator|=
name|zero_cum
expr_stmt|;
comment|/* Set up the number of registers to use for passing arguments.  */
name|cum
operator|->
name|nregs
operator|=
name|i386_regparm
expr_stmt|;
if|if
condition|(
name|fntype
condition|)
block|{
name|tree
name|attr
init|=
name|lookup_attribute
argument_list|(
literal|"regparm"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|fntype
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|attr
condition|)
name|cum
operator|->
name|nregs
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_VALUE
argument_list|(
name|attr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Determine if this function has variable arguments.  This is      indicated by the last argument being 'void_type_mode' if there      are no variable arguments.  If there are variable arguments, then      we won't pass anything in registers */
if|if
condition|(
name|cum
operator|->
name|nregs
condition|)
block|{
for|for
control|(
name|param
operator|=
operator|(
name|fntype
operator|)
condition|?
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
else|:
literal|0
init|;
name|param
operator|!=
literal|0
condition|;
name|param
operator|=
name|next_param
control|)
block|{
name|next_param
operator|=
name|TREE_CHAIN
argument_list|(
name|param
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_param
operator|==
literal|0
operator|&&
name|TREE_VALUE
argument_list|(
name|param
argument_list|)
operator|!=
name|void_type_node
condition|)
name|cum
operator|->
name|nregs
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TARGET_DEBUG_ARG
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|", nregs=%d )\n"
argument_list|,
name|cum
operator|->
name|nregs
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Update the data in CUM to advance over an argument    of mode MODE and data type TYPE.    (TYPE is null for libcalls where that information may not be available.)  */
end_comment

begin_function
name|void
name|function_arg_advance
parameter_list|(
name|cum
parameter_list|,
name|mode
parameter_list|,
name|type
parameter_list|,
name|named
parameter_list|)
name|CUMULATIVE_ARGS
modifier|*
name|cum
decl_stmt|;
comment|/* current arg information */
name|enum
name|machine_mode
name|mode
decl_stmt|;
comment|/* current arg mode */
name|tree
name|type
decl_stmt|;
comment|/* type of the argument or 0 if lib support */
name|int
name|named
decl_stmt|;
comment|/* whether or not the argument was named */
block|{
name|int
name|bytes
init|=
operator|(
name|mode
operator|==
name|BLKmode
operator|)
condition|?
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
else|:
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|int
name|words
init|=
operator|(
name|bytes
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
decl_stmt|;
if|if
condition|(
name|TARGET_DEBUG_ARG
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"function_adv (sz=%d, wds=%2d, nregs=%d, mode=%s, named=%d)\n\n"
argument_list|,
name|words
argument_list|,
name|cum
operator|->
name|words
argument_list|,
name|cum
operator|->
name|nregs
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|mode
argument_list|)
argument_list|,
name|named
argument_list|)
expr_stmt|;
name|cum
operator|->
name|words
operator|+=
name|words
expr_stmt|;
name|cum
operator|->
name|nregs
operator|-=
name|words
expr_stmt|;
name|cum
operator|->
name|regno
operator|+=
name|words
expr_stmt|;
if|if
condition|(
name|cum
operator|->
name|nregs
operator|<=
literal|0
condition|)
block|{
name|cum
operator|->
name|nregs
operator|=
literal|0
expr_stmt|;
name|cum
operator|->
name|regno
operator|=
literal|0
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* Define where to put the arguments to a function.    Value is zero to push the argument on the stack,    or a hard register in which to store the argument.     MODE is the argument's machine mode.    TYPE is the data type of the argument (as a tree).     This is null for libcalls where that information may     not be available.    CUM is a variable of type CUMULATIVE_ARGS which gives info about     the preceding args and about the function being called.    NAMED is nonzero if this argument is a named parameter     (otherwise it is an extra parameter matching an ellipsis).  */
end_comment

begin_function
name|struct
name|rtx_def
modifier|*
name|function_arg
parameter_list|(
name|cum
parameter_list|,
name|mode
parameter_list|,
name|type
parameter_list|,
name|named
parameter_list|)
name|CUMULATIVE_ARGS
modifier|*
name|cum
decl_stmt|;
comment|/* current arg information */
name|enum
name|machine_mode
name|mode
decl_stmt|;
comment|/* current arg mode */
name|tree
name|type
decl_stmt|;
comment|/* type of the argument or 0 if lib support */
name|int
name|named
decl_stmt|;
comment|/* != 0 for normal args, == 0 for ... args */
block|{
name|rtx
name|ret
init|=
name|NULL_RTX
decl_stmt|;
name|int
name|bytes
init|=
operator|(
name|mode
operator|==
name|BLKmode
operator|)
condition|?
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
else|:
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|int
name|words
init|=
operator|(
name|bytes
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
decl_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
comment|/* For now, pass fp/complex values on the stack. */
default|default:
break|break;
case|case
name|BLKmode
case|:
case|case
name|DImode
case|:
case|case
name|SImode
case|:
case|case
name|HImode
case|:
case|case
name|QImode
case|:
if|if
condition|(
name|words
operator|<=
name|cum
operator|->
name|nregs
condition|)
name|ret
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|cum
operator|->
name|regno
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|TARGET_DEBUG_ARG
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"function_arg (size=%d, wds=%2d, nregs=%d, mode=%4s, named=%d"
argument_list|,
name|words
argument_list|,
name|cum
operator|->
name|words
argument_list|,
name|cum
operator|->
name|nregs
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|mode
argument_list|)
argument_list|,
name|named
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|", reg=%%e%s"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|ret
argument_list|)
index|]
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|", stack"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" )\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* For an arg passed partly in registers and partly in memory,    this is the number of registers used.    For args passed entirely in registers or entirely in memory, zero.  */
end_comment

begin_function
name|int
name|function_arg_partial_nregs
parameter_list|(
name|cum
parameter_list|,
name|mode
parameter_list|,
name|type
parameter_list|,
name|named
parameter_list|)
name|CUMULATIVE_ARGS
modifier|*
name|cum
name|ATTRIBUTE_UNUSED
decl_stmt|;
comment|/* current arg information */
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
comment|/* current arg mode */
name|tree
name|type
name|ATTRIBUTE_UNUSED
decl_stmt|;
comment|/* type of the argument or 0 if lib support */
name|int
name|named
name|ATTRIBUTE_UNUSED
decl_stmt|;
comment|/* != 0 for normal args, == 0 for ... args */
block|{
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|char
modifier|*
name|singlemove_string
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
name|rtx
name|x
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|x
operator|=
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_DEC
condition|)
block|{
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|!=
name|stack_pointer_rtx
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
literal|"push%L1 %1"
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
return|return
name|output_move_const_single
argument_list|(
name|operands
argument_list|)
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|REG
condition|)
return|return
name|AS2
argument_list|(
name|mov
operator|%
name|L0
argument_list|,
operator|%
literal|1
argument_list|,
operator|%
literal|0
argument_list|)
return|;
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
return|return
name|AS2
argument_list|(
name|mov
operator|%
name|L0
argument_list|,
operator|%
literal|1
argument_list|,
operator|%
literal|0
argument_list|)
return|;
else|else
block|{
name|output_asm_insn
argument_list|(
literal|"push%L1 %1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return
literal|"pop%L0 %0"
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output an insn to add the constant N to the register X.  */
end_comment

begin_function
specifier|static
name|void
name|asm_add
parameter_list|(
name|n
parameter_list|,
name|x
parameter_list|)
name|int
name|n
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
name|rtx
name|xops
index|[
literal|2
index|]
decl_stmt|;
name|xops
index|[
literal|0
index|]
operator|=
name|x
expr_stmt|;
if|if
condition|(
name|n
operator|==
operator|-
literal|1
condition|)
name|output_asm_insn
argument_list|(
name|AS1
argument_list|(
name|dec
operator|%
name|L0
argument_list|,
operator|%
literal|0
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|n
operator|==
literal|1
condition|)
name|output_asm_insn
argument_list|(
name|AS1
argument_list|(
name|inc
operator|%
name|L0
argument_list|,
operator|%
literal|0
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|n
operator|<
literal|0
operator|||
name|n
operator|==
literal|128
condition|)
block|{
name|xops
index|[
literal|1
index|]
operator|=
name|GEN_INT
argument_list|(
operator|-
name|n
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|sub
operator|%
name|L0
argument_list|,
operator|%
literal|1
argument_list|,
operator|%
literal|0
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|xops
index|[
literal|1
index|]
operator|=
name|GEN_INT
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|add
operator|%
name|L0
argument_list|,
operator|%
literal|1
argument_list|,
operator|%
literal|0
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output assembler code to perform a doubleword move insn    with operands OPERANDS.  */
end_comment

begin_function
name|char
modifier|*
name|output_move_double
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
enum|enum
block|{
name|REGOP
block|,
name|OFFSOP
block|,
name|MEMOP
block|,
name|PUSHOP
block|,
name|POPOP
block|,
name|CNSTOP
block|,
name|RNDOP
block|}
name|optype0
enum|,
name|optype1
expr_stmt|;
name|rtx
name|latehalf
index|[
literal|2
index|]
decl_stmt|;
name|rtx
name|middlehalf
index|[
literal|2
index|]
decl_stmt|;
name|rtx
name|xops
index|[
literal|2
index|]
decl_stmt|;
name|int
name|dest_overlapped_low
init|=
literal|0
decl_stmt|;
name|int
name|size
init|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|)
decl_stmt|;
name|middlehalf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|middlehalf
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* First classify both operands.  */
if|if
condition|(
name|REG_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
name|optype0
operator|=
name|REGOP
expr_stmt|;
elseif|else
if|if
condition|(
name|offsettable_memref_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
name|optype0
operator|=
name|OFFSOP
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|POST_INC
condition|)
name|optype0
operator|=
name|POPOP
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_DEC
condition|)
name|optype0
operator|=
name|PUSHOP
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|MEM
condition|)
name|optype0
operator|=
name|MEMOP
expr_stmt|;
else|else
name|optype0
operator|=
name|RNDOP
expr_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
name|optype1
operator|=
name|REGOP
expr_stmt|;
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
name|optype1
operator|=
name|CNSTOP
expr_stmt|;
elseif|else
if|if
condition|(
name|offsettable_memref_p
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
name|optype1
operator|=
name|OFFSOP
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|POST_INC
condition|)
name|optype1
operator|=
name|POPOP
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_DEC
condition|)
name|optype1
operator|=
name|PUSHOP
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|MEM
condition|)
name|optype1
operator|=
name|MEMOP
expr_stmt|;
else|else
name|optype1
operator|=
name|RNDOP
expr_stmt|;
comment|/* Check for the cases that are not supposed to happen      either due to the operand constraints or the fact      that all memory operands on the x86 are offsettable.      Abort if we get one, because generating code for these      cases is painful.  */
if|if
condition|(
name|optype0
operator|==
name|RNDOP
operator|||
name|optype1
operator|==
name|RNDOP
operator|||
name|optype0
operator|==
name|MEMOP
operator|||
name|optype1
operator|==
name|MEMOP
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If one operand is decrementing and one is incrementing      decrement the former register explicitly      and change that operand into ordinary indexing.  */
if|if
condition|(
name|optype0
operator|==
name|PUSHOP
operator|&&
name|optype1
operator|==
name|POPOP
condition|)
block|{
comment|/* ??? Can this ever happen on i386? */
name|operands
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|asm_add
argument_list|(
operator|-
name|size
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|XFmode
condition|)
name|operands
index|[
literal|0
index|]
operator|=
name|gen_rtx_MEM
argument_list|(
name|XFmode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|DFmode
condition|)
name|operands
index|[
literal|0
index|]
operator|=
name|gen_rtx_MEM
argument_list|(
name|DFmode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
else|else
name|operands
index|[
literal|0
index|]
operator|=
name|gen_rtx_MEM
argument_list|(
name|DImode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|optype0
operator|=
name|OFFSOP
expr_stmt|;
block|}
if|if
condition|(
name|optype0
operator|==
name|POPOP
operator|&&
name|optype1
operator|==
name|PUSHOP
condition|)
block|{
comment|/* ??? Can this ever happen on i386? */
name|operands
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|asm_add
argument_list|(
operator|-
name|size
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|XFmode
condition|)
name|operands
index|[
literal|1
index|]
operator|=
name|gen_rtx_MEM
argument_list|(
name|XFmode
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|DFmode
condition|)
name|operands
index|[
literal|1
index|]
operator|=
name|gen_rtx_MEM
argument_list|(
name|DFmode
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
name|operands
index|[
literal|1
index|]
operator|=
name|gen_rtx_MEM
argument_list|(
name|DImode
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|optype1
operator|=
name|OFFSOP
expr_stmt|;
block|}
comment|/* Ok, we can do one word at a time.      Normally we do the low-numbered word first,      but if either operand is autodecrementing then we      do the high-numbered word first.       In either case, set up in LATEHALF the operands to use      for the high-numbered word and in some cases alter the      operands in OPERANDS to be suitable for the low-numbered word.  */
if|if
condition|(
name|size
operator|==
literal|12
condition|)
block|{
if|if
condition|(
name|optype0
operator|==
name|REGOP
condition|)
block|{
name|middlehalf
index|[
literal|0
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|latehalf
index|[
literal|0
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|optype0
operator|==
name|OFFSOP
condition|)
block|{
name|middlehalf
index|[
literal|0
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|latehalf
index|[
literal|0
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|middlehalf
index|[
literal|0
index|]
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
name|latehalf
index|[
literal|0
index|]
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
block|}
if|if
condition|(
name|optype1
operator|==
name|REGOP
condition|)
block|{
name|middlehalf
index|[
literal|1
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|latehalf
index|[
literal|1
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|optype1
operator|==
name|OFFSOP
condition|)
block|{
name|middlehalf
index|[
literal|1
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|latehalf
index|[
literal|1
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|optype1
operator|==
name|CNSTOP
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|long
name|l
index|[
literal|3
index|]
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|r
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|REAL_VALUE_TO_TARGET_LONG_DOUBLE
argument_list|(
name|r
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|GEN_INT
argument_list|(
name|l
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|middlehalf
index|[
literal|1
index|]
operator|=
name|GEN_INT
argument_list|(
name|l
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|latehalf
index|[
literal|1
index|]
operator|=
name|GEN_INT
argument_list|(
name|l
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
comment|/* No non-CONST_DOUBLE constant should ever appear here.  */
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|middlehalf
index|[
literal|1
index|]
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
name|latehalf
index|[
literal|1
index|]
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Size is not 12. */
if|if
condition|(
name|optype0
operator|==
name|REGOP
condition|)
name|latehalf
index|[
literal|0
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|optype0
operator|==
name|OFFSOP
condition|)
name|latehalf
index|[
literal|0
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
else|else
name|latehalf
index|[
literal|0
index|]
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|optype1
operator|==
name|REGOP
condition|)
name|latehalf
index|[
literal|1
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|optype1
operator|==
name|OFFSOP
condition|)
name|latehalf
index|[
literal|1
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|optype1
operator|==
name|CNSTOP
condition|)
name|split_double
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
operator|&
name|operands
index|[
literal|1
index|]
argument_list|,
operator|&
name|latehalf
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
name|latehalf
index|[
literal|1
index|]
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
block|}
comment|/* If insn is effectively movd N (sp),-(sp) then we will do the      high word first.  We should use the adjusted operand 1      (which is N+4 (sp) or N+8 (sp))      for the low word and middle word as well,      to compensate for the first decrement of sp.  */
if|if
condition|(
name|optype0
operator|==
name|PUSHOP
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|STACK_POINTER_REGNUM
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
name|middlehalf
index|[
literal|1
index|]
operator|=
name|operands
index|[
literal|1
index|]
operator|=
name|latehalf
index|[
literal|1
index|]
expr_stmt|;
comment|/* For (set (reg:DI N) (mem:DI ... (reg:SI N) ...)),      if the upper part of reg N does not appear in the MEM, arrange to      emit the move late-half first.  Otherwise, compute the MEM address      into the upper part of N and use that as a pointer to the memory      operand.  */
if|if
condition|(
name|optype0
operator|==
name|REGOP
operator|&&
name|optype1
operator|==
name|OFFSOP
condition|)
block|{
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|reg_mentioned_p
argument_list|(
name|latehalf
index|[
literal|0
index|]
argument_list|,
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
comment|/* If both halves of dest are used in the src memory address, 	     compute the address into latehalf of dest.  */
name|compadr
label|:
name|xops
index|[
literal|0
index|]
operator|=
name|latehalf
index|[
literal|0
index|]
expr_stmt|;
name|xops
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|lea
operator|%
name|L0
argument_list|,
operator|%
name|a1
argument_list|,
operator|%
literal|0
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|XFmode
condition|)
block|{
name|operands
index|[
literal|1
index|]
operator|=
name|gen_rtx_MEM
argument_list|(
name|XFmode
argument_list|,
name|latehalf
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|middlehalf
index|[
literal|1
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|size
operator|-
literal|8
argument_list|)
expr_stmt|;
name|latehalf
index|[
literal|1
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|size
operator|-
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|operands
index|[
literal|1
index|]
operator|=
name|gen_rtx_MEM
argument_list|(
name|DImode
argument_list|,
name|latehalf
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|latehalf
index|[
literal|1
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|size
operator|-
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|size
operator|==
literal|12
operator|&&
name|reg_mentioned_p
argument_list|(
name|middlehalf
index|[
literal|0
index|]
argument_list|,
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Check for two regs used by both source and dest. */
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
name|reg_mentioned_p
argument_list|(
name|latehalf
index|[
literal|0
index|]
argument_list|,
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
goto|goto
name|compadr
goto|;
comment|/* Only the middle reg conflicts; simply put it last. */
name|output_asm_insn
argument_list|(
name|singlemove_string
argument_list|(
name|operands
argument_list|)
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|singlemove_string
argument_list|(
name|latehalf
argument_list|)
argument_list|,
name|latehalf
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|singlemove_string
argument_list|(
name|middlehalf
argument_list|)
argument_list|,
name|middlehalf
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
elseif|else
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
comment|/* If the low half of dest is mentioned in the source memory 	   address, the arrange to emit the move late half first.  */
name|dest_overlapped_low
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If one or both operands autodecrementing,      do the two words, high-numbered first.  */
comment|/* Likewise,  the first move would clobber the source of the second one,      do them in the other order.  This happens only for registers;      such overlap can't happen in memory unless the user explicitly      sets it up, and that is an undefined circumstance.  */
if|#
directive|if
literal|0
block|if (optype0 == PUSHOP || optype1 == PUSHOP       || (optype0 == REGOP&& optype1 == REGOP&& REGNO (operands[0]) == REGNO (latehalf[1]))       || dest_overlapped_low)
endif|#
directive|endif
if|if
condition|(
name|optype0
operator|==
name|PUSHOP
operator|||
name|optype1
operator|==
name|PUSHOP
operator|||
operator|(
name|optype0
operator|==
name|REGOP
operator|&&
name|optype1
operator|==
name|REGOP
operator|&&
operator|(
operator|(
name|middlehalf
index|[
literal|1
index|]
operator|&&
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|REGNO
argument_list|(
name|middlehalf
index|[
literal|1
index|]
argument_list|)
operator|)
operator|||
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|REGNO
argument_list|(
name|latehalf
index|[
literal|1
index|]
argument_list|)
operator|)
operator|)
operator|||
name|dest_overlapped_low
condition|)
block|{
comment|/* Do the high-numbered word.  */
name|output_asm_insn
argument_list|(
name|singlemove_string
argument_list|(
name|latehalf
argument_list|)
argument_list|,
name|latehalf
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|12
condition|)
name|output_asm_insn
argument_list|(
name|singlemove_string
argument_list|(
name|middlehalf
argument_list|)
argument_list|,
name|middlehalf
argument_list|)
expr_stmt|;
comment|/* Do low-numbered word.  */
return|return
name|singlemove_string
argument_list|(
name|operands
argument_list|)
return|;
block|}
comment|/* Normal case: do the two words, low-numbered first.  */
name|output_asm_insn
argument_list|(
name|singlemove_string
argument_list|(
name|operands
argument_list|)
argument_list|,
name|operands
argument_list|)
expr_stmt|;
comment|/* Do the middle one of the three words for long double */
if|if
condition|(
name|size
operator|==
literal|12
condition|)
name|output_asm_insn
argument_list|(
name|singlemove_string
argument_list|(
name|middlehalf
argument_list|)
argument_list|,
name|middlehalf
argument_list|)
expr_stmt|;
comment|/* Do the high-numbered word.  */
name|output_asm_insn
argument_list|(
name|singlemove_string
argument_list|(
name|latehalf
argument_list|)
argument_list|,
name|latehalf
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
end_function

begin_escape
end_escape

begin_define
define|#
directive|define
name|MAX_TMPS
value|2
end_define

begin_comment
comment|/* max temporary registers used */
end_comment

begin_comment
comment|/* Output the appropriate code to move push memory on the stack */
end_comment

begin_function
name|char
modifier|*
name|output_move_pushmem
parameter_list|(
name|operands
parameter_list|,
name|insn
parameter_list|,
name|length
parameter_list|,
name|tmp_start
parameter_list|,
name|n_operands
parameter_list|)
name|rtx
name|operands
index|[]
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|length
decl_stmt|;
name|int
name|tmp_start
decl_stmt|;
name|int
name|n_operands
decl_stmt|;
block|{
struct|struct
block|{
name|char
modifier|*
name|load
decl_stmt|;
name|char
modifier|*
name|push
decl_stmt|;
name|rtx
name|xops
index|[
literal|2
index|]
decl_stmt|;
block|}
name|tmp_info
index|[
name|MAX_TMPS
index|]
struct|;
name|rtx
name|src
init|=
name|operands
index|[
literal|1
index|]
decl_stmt|;
name|int
name|max_tmps
init|=
literal|0
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|int
name|stack_p
init|=
name|reg_overlap_mentioned_p
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|src
argument_list|)
decl_stmt|;
name|int
name|stack_offset
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|num_tmps
decl_stmt|;
name|rtx
name|xops
index|[
literal|1
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|offsettable_memref_p
argument_list|(
name|src
argument_list|)
condition|)
name|fatal_insn
argument_list|(
literal|"Source is not offsettable"
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|length
operator|&
literal|3
operator|)
operator|!=
literal|0
condition|)
name|fatal_insn
argument_list|(
literal|"Pushing non-word aligned size"
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* Figure out which temporary registers we have available */
for|for
control|(
name|i
operator|=
name|tmp_start
init|;
name|i
operator|<
name|n_operands
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|)
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|,
name|src
argument_list|)
condition|)
continue|continue;
name|tmp_info
index|[
name|max_tmps
operator|++
index|]
operator|.
name|xops
index|[
literal|1
index|]
operator|=
name|operands
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|max_tmps
operator|==
name|MAX_TMPS
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|max_tmps
operator|==
literal|0
condition|)
for|for
control|(
name|offset
operator|=
name|length
operator|-
literal|4
init|;
name|offset
operator|>=
literal|0
condition|;
name|offset
operator|-=
literal|4
control|)
block|{
name|xops
index|[
literal|0
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|src
argument_list|,
name|offset
operator|+
name|stack_offset
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS1
argument_list|(
name|push
operator|%
name|L0
argument_list|,
operator|%
literal|0
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
if|if
condition|(
name|stack_p
condition|)
name|stack_offset
operator|+=
literal|4
expr_stmt|;
block|}
else|else
for|for
control|(
name|offset
operator|=
name|length
operator|-
literal|4
init|;
name|offset
operator|>=
literal|0
condition|;
control|)
block|{
for|for
control|(
name|num_tmps
operator|=
literal|0
init|;
name|num_tmps
operator|<
name|max_tmps
operator|&&
name|offset
operator|>=
literal|0
condition|;
name|num_tmps
operator|++
control|)
block|{
name|tmp_info
index|[
name|num_tmps
index|]
operator|.
name|load
operator|=
name|AS2
argument_list|(
name|mov
operator|%
name|L0
argument_list|,
operator|%
literal|0
argument_list|,
operator|%
literal|1
argument_list|)
expr_stmt|;
name|tmp_info
index|[
name|num_tmps
index|]
operator|.
name|push
operator|=
name|AS1
argument_list|(
name|push
operator|%
name|L0
argument_list|,
operator|%
literal|1
argument_list|)
expr_stmt|;
name|tmp_info
index|[
name|num_tmps
index|]
operator|.
name|xops
index|[
literal|0
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|src
argument_list|,
name|offset
operator|+
name|stack_offset
argument_list|)
expr_stmt|;
name|offset
operator|-=
literal|4
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_tmps
condition|;
name|i
operator|++
control|)
name|output_asm_insn
argument_list|(
name|tmp_info
index|[
name|i
index|]
operator|.
name|load
argument_list|,
name|tmp_info
index|[
name|i
index|]
operator|.
name|xops
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_tmps
condition|;
name|i
operator|++
control|)
name|output_asm_insn
argument_list|(
name|tmp_info
index|[
name|i
index|]
operator|.
name|push
argument_list|,
name|tmp_info
index|[
name|i
index|]
operator|.
name|xops
argument_list|)
expr_stmt|;
if|if
condition|(
name|stack_p
condition|)
name|stack_offset
operator|+=
literal|4
operator|*
name|num_tmps
expr_stmt|;
block|}
return|return
literal|""
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|int
name|standard_80387_constant_p
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|REAL_IS_NOT_DOUBLE
argument_list|)
operator|||
name|defined
argument_list|(
name|REAL_ARITHMETIC
argument_list|)
name|REAL_VALUE_TYPE
name|d
decl_stmt|;
name|jmp_buf
name|handler
decl_stmt|;
name|int
name|is0
decl_stmt|,
name|is1
decl_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|handler
argument_list|)
condition|)
return|return
literal|0
return|;
name|set_float_handler
argument_list|(
name|handler
argument_list|)
expr_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|d
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|is0
operator|=
name|REAL_VALUES_EQUAL
argument_list|(
name|d
argument_list|,
name|dconst0
argument_list|)
operator|&&
operator|!
name|REAL_VALUE_MINUS_ZERO
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|is1
operator|=
name|REAL_VALUES_EQUAL
argument_list|(
name|d
argument_list|,
name|dconst1
argument_list|)
expr_stmt|;
name|set_float_handler
argument_list|(
name|NULL_PTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|is0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|is1
condition|)
return|return
literal|2
return|;
comment|/* Note that on the 80387, other constants, such as pi,      are much slower to load as standard constants      than to load from doubles in memory!  */
comment|/* ??? Not true on K6: all constants are equal cost.  */
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|output_move_const_single
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
if|if
condition|(
name|FP_REG_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|int
name|conval
init|=
name|standard_80387_constant_p
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|conval
operator|==
literal|1
condition|)
return|return
literal|"fldz"
return|;
if|if
condition|(
name|conval
operator|==
literal|2
condition|)
return|return
literal|"fld1"
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|long
name|l
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|XFmode
condition|)
name|abort
argument_list|()
expr_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|r
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|REAL_VALUE_TO_TARGET_SINGLE
argument_list|(
name|r
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|GEN_INT
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
return|return
name|singlemove_string
argument_list|(
name|operands
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Returns 1 if OP is either a symbol reference or a sum of a symbol    reference and a constant.  */
end_comment

begin_function
name|int
name|symbolic_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
return|return
literal|1
return|;
case|case
name|CONST
case|:
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|)
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return nonzero if OP is a constant shift count small enough to    encode into an lea instruction.  */
end_comment

begin_function
name|int
name|small_shift_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|>
literal|0
operator|&&
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<
literal|4
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Test for a valid operand for a call instruction.    Don't allow the arg pointer register or virtual regs    since they may change into reg + const, which the patterns    can't handle yet.  */
end_comment

begin_function
name|int
name|call_insn_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
operator|(
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
comment|/* This makes a difference for PIC.  */
operator|&&
name|general_operand
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
operator|!=
name|arg_pointer_rtx
operator|&&
operator|!
operator|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<=
name|LAST_VIRTUAL_REGISTER
operator|)
operator|)
operator|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Like call_insn_operand but allow (mem (symbol_ref ...))    even if pic.  */
end_comment

begin_function
name|int
name|expander_call_insn_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
operator|!=
name|arg_pointer_rtx
operator|&&
operator|!
operator|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<=
name|LAST_VIRTUAL_REGISTER
operator|)
operator|)
operator|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a comparison operator that can use the condition code    generated by an arithmetic operation. */
end_comment

begin_function
name|int
name|arithmetic_comparison_operator
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
decl_stmt|;
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|!=
literal|'<'
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|code
operator|!=
name|GT
operator|&&
name|code
operator|!=
name|LE
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ix86_logical_operator
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|AND
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|IOR
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|XOR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Returns 1 if OP contains a symbol reference */
end_comment

begin_function
name|int
name|symbolic_reference_mentioned_p
parameter_list|(
name|op
parameter_list|)
name|rtx
name|op
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|LABEL_REF
condition|)
return|return
literal|1
return|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|op
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|symbolic_reference_mentioned_p
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|&&
name|symbolic_reference_mentioned_p
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Attempt to expand a binary operator.  Make the expansion closer to the    actual machine, then just general_operand, which will allow 3 separate    memory references (one output, two input) in a single insn.  Return    whether the insn fails, or succeeds.  */
end_comment

begin_function
name|int
name|ix86_expand_binary_operator
parameter_list|(
name|code
parameter_list|,
name|mode
parameter_list|,
name|operands
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|operands
index|[]
decl_stmt|;
block|{
name|int
name|modified
decl_stmt|;
comment|/* Recognize<var1> =<value><op><var1> for commutative operators */
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'c'
operator|&&
operator|(
name|rtx_equal_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|)
operator|||
name|immediate_operand
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|mode
argument_list|)
operator|)
condition|)
block|{
name|rtx
name|temp
init|=
name|operands
index|[
literal|1
index|]
decl_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|operands
index|[
literal|2
index|]
expr_stmt|;
name|operands
index|[
literal|2
index|]
operator|=
name|temp
expr_stmt|;
block|}
comment|/* If optimizing, copy to regs to improve CSE */
if|if
condition|(
name|TARGET_PSEUDO
operator|&&
name|optimize
operator|&&
operator|(
operator|(
name|reload_in_progress
operator||
name|reload_completed
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|rtx_equal_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
name|operands
index|[
literal|1
index|]
operator|=
name|force_reg
argument_list|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|==
name|MEM
condition|)
name|operands
index|[
literal|2
index|]
operator|=
name|force_reg
argument_list|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|code
operator|==
name|MINUS
condition|)
block|{
name|rtx
name|temp
init|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|temp
expr_stmt|;
return|return
name|TRUE
return|;
block|}
block|}
if|if
condition|(
operator|!
name|ix86_binary_operator_ok
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|operands
argument_list|)
condition|)
block|{
comment|/* If not optimizing, try to make a valid insn (optimize code 	 previously did this above to improve chances of CSE) */
if|if
condition|(
operator|(
operator|!
name|TARGET_PSEUDO
operator|||
operator|!
name|optimize
operator|)
operator|&&
operator|(
operator|(
name|reload_in_progress
operator||
name|reload_completed
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|MEM
operator|||
name|GET_CODE
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|==
name|MEM
operator|)
condition|)
block|{
name|modified
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|rtx_equal_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|operands
index|[
literal|1
index|]
operator|=
name|force_reg
argument_list|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|modified
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|operands
index|[
literal|2
index|]
operator|=
name|force_reg
argument_list|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|modified
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|code
operator|==
name|MINUS
condition|)
block|{
name|rtx
name|temp
init|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|temp
expr_stmt|;
return|return
name|TRUE
return|;
block|}
if|if
condition|(
name|modified
operator|&&
operator|!
name|ix86_binary_operator_ok
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|operands
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
else|else
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return TRUE or FALSE depending on whether the binary operator meets the    appropriate constraints.  */
end_comment

begin_function
name|int
name|ix86_binary_operator_ok
parameter_list|(
name|code
parameter_list|,
name|mode
parameter_list|,
name|operands
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|rtx
name|operands
index|[
literal|3
index|]
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|!=
name|MEM
operator|||
name|GET_CODE
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|!=
name|MEM
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'c'
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Attempt to expand a unary operator.  Make the expansion closer to the    actual machine, then just general_operand, which will allow 2 separate    memory references (one output, one input) in a single insn.  Return    whether the insn fails, or succeeds.  */
end_comment

begin_function
name|int
name|ix86_expand_unary_operator
parameter_list|(
name|code
parameter_list|,
name|mode
parameter_list|,
name|operands
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|operands
index|[]
decl_stmt|;
block|{
comment|/* If optimizing, copy to regs to improve CSE */
if|if
condition|(
name|TARGET_PSEUDO
operator|&&
name|optimize
operator|&&
operator|(
operator|(
name|reload_in_progress
operator||
name|reload_completed
operator|)
operator|==
literal|0
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|MEM
condition|)
name|operands
index|[
literal|1
index|]
operator|=
name|force_reg
argument_list|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ix86_unary_operator_ok
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|operands
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
operator|!
name|TARGET_PSEUDO
operator|||
name|optimize
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|reload_in_progress
operator||
name|reload_completed
operator|)
operator|==
literal|0
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|operands
index|[
literal|1
index|]
operator|=
name|force_reg
argument_list|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ix86_unary_operator_ok
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|operands
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
else|else
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return TRUE or FALSE depending on whether the unary operator meets the    appropriate constraints.  */
end_comment

begin_function
name|int
name|ix86_unary_operator_ok
parameter_list|(
name|code
parameter_list|,
name|mode
parameter_list|,
name|operands
parameter_list|)
name|enum
name|rtx_code
name|code
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|rtx
name|operands
index|[
literal|2
index|]
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|rtx
name|pic_label_rtx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|pic_label_name
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pic_label_no
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This function generates code for -fpic that loads %ebx with    the return address of the caller and then returns.  */
end_comment

begin_function
name|void
name|asm_output_function_prefix
parameter_list|(
name|file
parameter_list|,
name|name
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|name
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|rtx
name|xops
index|[
literal|2
index|]
decl_stmt|;
name|xops
index|[
literal|0
index|]
operator|=
name|pic_offset_table_rtx
expr_stmt|;
name|xops
index|[
literal|1
index|]
operator|=
name|stack_pointer_rtx
expr_stmt|;
comment|/* Deep branch prediction favors having a return for every call. */
if|if
condition|(
name|PIC_REG_USED
operator|&&
name|TARGET_DEEP_BRANCH_PREDICTION
condition|)
block|{
name|tree
name|prologue_node
decl_stmt|;
if|if
condition|(
name|pic_label_rtx
operator|==
literal|0
condition|)
block|{
name|pic_label_rtx
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|pic_label_name
argument_list|,
literal|"LPR"
argument_list|,
name|pic_label_no
operator|++
argument_list|)
expr_stmt|;
name|LABEL_NAME
argument_list|(
name|pic_label_rtx
argument_list|)
operator|=
name|pic_label_name
expr_stmt|;
block|}
name|prologue_node
operator|=
name|make_node
argument_list|(
name|FUNCTION_DECL
argument_list|)
expr_stmt|;
name|DECL_RESULT
argument_list|(
name|prologue_node
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* This used to call ASM_DECLARE_FUNCTION_NAME() but since it's an 	 internal (non-global) label that's being emitted, it didn't make 	 sense to have .type information for local labels.   This caused 	 the SCO OpenServer 5.0.4 ELF assembler grief (why are you giving   	 me debug info for a label that you're declaring non-global?) this 	 was changed to call ASM_OUTPUT_LABEL() instead. */
name|ASM_OUTPUT_LABEL
argument_list|(
name|file
argument_list|,
name|pic_label_name
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"movl (%1),%0"
argument_list|,
name|xops
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ret"
argument_list|,
name|xops
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Generate the assembly code for function entry.    FILE is an stdio stream to output the code to.    SIZE is an int: how many units of temporary storage to allocate. */
end_comment

begin_function
name|void
name|function_prologue
parameter_list|(
name|file
parameter_list|,
name|size
parameter_list|)
name|FILE
modifier|*
name|file
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|size
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|TARGET_SCHEDULE_PROLOGUE
condition|)
block|{
name|pic_label_rtx
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|ix86_prologue
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Expand the prologue into a bunch of separate insns. */
end_comment

begin_function
name|void
name|ix86_expand_prologue
parameter_list|()
block|{
if|if
condition|(
operator|!
name|TARGET_SCHEDULE_PROLOGUE
condition|)
return|return;
name|ix86_prologue
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|load_pic_register
parameter_list|(
name|do_rtl
parameter_list|)
name|int
name|do_rtl
decl_stmt|;
block|{
name|rtx
name|xops
index|[
literal|4
index|]
decl_stmt|;
if|if
condition|(
name|TARGET_DEEP_BRANCH_PREDICTION
condition|)
block|{
name|xops
index|[
literal|0
index|]
operator|=
name|pic_offset_table_rtx
expr_stmt|;
if|if
condition|(
name|pic_label_rtx
operator|==
literal|0
condition|)
block|{
name|pic_label_rtx
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|pic_label_name
argument_list|,
literal|"LPR"
argument_list|,
name|pic_label_no
operator|++
argument_list|)
expr_stmt|;
name|LABEL_NAME
argument_list|(
name|pic_label_rtx
argument_list|)
operator|=
name|pic_label_name
expr_stmt|;
block|}
name|xops
index|[
literal|1
index|]
operator|=
name|gen_rtx_MEM
argument_list|(
name|QImode
argument_list|,
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
name|LABEL_NAME
argument_list|(
name|pic_label_rtx
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_rtl
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_prologue_get_pc
argument_list|(
name|xops
index|[
literal|0
index|]
argument_list|,
name|xops
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_prologue_set_got
argument_list|(
name|xops
index|[
literal|0
index|]
argument_list|,
ifdef|#
directive|ifdef
name|YES_UNDERSCORES
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
literal|"$__GLOBAL_OFFSET_TABLE_"
argument_list|)
argument_list|,
else|#
directive|else
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
literal|"$_GLOBAL_OFFSET_TABLE_"
argument_list|)
argument_list|,
endif|#
directive|endif
name|xops
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|output_asm_insn
argument_list|(
name|AS1
argument_list|(
name|call
argument_list|,
operator|%
name|X1
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"addl $%__GLOBAL_OFFSET_TABLE_,%0"
argument_list|,
name|xops
argument_list|)
expr_stmt|;
name|pic_label_rtx
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|xops
index|[
literal|0
index|]
operator|=
name|pic_offset_table_rtx
expr_stmt|;
name|xops
index|[
literal|1
index|]
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
if|if
condition|(
name|do_rtl
condition|)
block|{
comment|/* We can't put a raw CODE_LABEL into the RTL, and we can't emit 	     a new CODE_LABEL after reload, so we need a single pattern to 	     emit the 3 necessary instructions.  */
name|emit_insn
argument_list|(
name|gen_prologue_get_pc_and_set_got
argument_list|(
name|xops
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|output_asm_insn
argument_list|(
name|AS1
argument_list|(
name|call
argument_list|,
operator|%
name|P1
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|asm_out_file
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|xops
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS1
argument_list|(
name|pop
operator|%
name|L0
argument_list|,
operator|%
literal|0
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"addl $%__GLOBAL_OFFSET_TABLE_+[.-%P1],%0"
argument_list|,
name|xops
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* When -fpic, we must emit a scheduling barrier, so that the instruction      that restores %ebx (which is PIC_OFFSET_TABLE_REGNUM), does not get      moved before any instruction which implicitly uses the got.   */
if|if
condition|(
name|do_rtl
condition|)
name|emit_insn
argument_list|(
name|gen_blockage
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute the size of local storage taking into consideration the    desired stack alignment which is to be maintained.  Also determine    the number of registers saved below the local storage.  */
end_comment

begin_function
name|HOST_WIDE_INT
name|ix86_compute_frame_size
parameter_list|(
name|size
parameter_list|,
name|nregs_on_stack
parameter_list|)
name|HOST_WIDE_INT
name|size
decl_stmt|;
name|int
modifier|*
name|nregs_on_stack
decl_stmt|;
block|{
name|int
name|limit
decl_stmt|;
name|int
name|nregs
decl_stmt|;
name|int
name|regno
decl_stmt|;
name|int
name|padding
decl_stmt|;
name|int
name|pic_reg_used
init|=
name|PIC_REG_USED
decl_stmt|;
name|HOST_WIDE_INT
name|total_size
decl_stmt|;
name|limit
operator|=
name|frame_pointer_needed
condition|?
name|FRAME_POINTER_REGNUM
else|:
name|STACK_POINTER_REGNUM
expr_stmt|;
name|nregs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|regno
operator|=
name|limit
operator|-
literal|1
init|;
name|regno
operator|>=
literal|0
condition|;
name|regno
operator|--
control|)
if|if
condition|(
operator|(
name|regs_ever_live
index|[
name|regno
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|regno
index|]
operator|)
operator|||
operator|(
name|regno
operator|==
name|PIC_OFFSET_TABLE_REGNUM
operator|&&
name|pic_reg_used
operator|)
condition|)
name|nregs
operator|++
expr_stmt|;
name|padding
operator|=
literal|0
expr_stmt|;
name|total_size
operator|=
name|size
operator|+
operator|(
name|nregs
operator|*
name|UNITS_PER_WORD
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PREFERRED_STACK_BOUNDARY
block|{
name|int
name|offset
decl_stmt|;
name|int
name|preferred_alignment
init|=
name|PREFERRED_STACK_BOUNDARY
operator|/
name|BITS_PER_UNIT
decl_stmt|;
name|offset
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|frame_pointer_needed
condition|)
name|offset
operator|+=
name|UNITS_PER_WORD
expr_stmt|;
name|total_size
operator|+=
name|offset
expr_stmt|;
name|padding
operator|=
operator|(
operator|(
name|total_size
operator|+
name|preferred_alignment
operator|-
literal|1
operator|)
operator|&
operator|-
name|preferred_alignment
operator|)
operator|-
name|total_size
expr_stmt|;
if|if
condition|(
name|padding
operator|<
operator|(
operator|(
operator|(
name|offset
operator|+
name|preferred_alignment
operator|-
literal|1
operator|)
operator|&
operator|-
name|preferred_alignment
operator|)
operator|-
name|offset
operator|)
condition|)
name|padding
operator|+=
name|preferred_alignment
expr_stmt|;
comment|/* Don't bother aligning the stack of a leaf function        which doesn't allocate any stack slots.  */
if|if
condition|(
name|size
operator|==
literal|0
operator|&&
name|current_function_is_leaf
condition|)
name|padding
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|nregs_on_stack
condition|)
operator|*
name|nregs_on_stack
operator|=
name|nregs
expr_stmt|;
return|return
name|size
operator|+
name|padding
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ix86_prologue
parameter_list|(
name|do_rtl
parameter_list|)
name|int
name|do_rtl
decl_stmt|;
block|{
specifier|register
name|int
name|regno
decl_stmt|;
name|int
name|limit
decl_stmt|;
name|rtx
name|xops
index|[
literal|4
index|]
decl_stmt|;
name|int
name|pic_reg_used
init|=
name|PIC_REG_USED
decl_stmt|;
name|HOST_WIDE_INT
name|tsize
init|=
name|ix86_compute_frame_size
argument_list|(
name|get_frame_size
argument_list|()
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|cfa_offset
init|=
name|INCOMING_FRAME_SP_OFFSET
decl_stmt|,
name|cfa_store_offset
init|=
name|cfa_offset
decl_stmt|;
name|xops
index|[
literal|0
index|]
operator|=
name|stack_pointer_rtx
expr_stmt|;
name|xops
index|[
literal|1
index|]
operator|=
name|frame_pointer_rtx
expr_stmt|;
name|xops
index|[
literal|2
index|]
operator|=
name|GEN_INT
argument_list|(
name|tsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
if|if
condition|(
name|do_rtl
condition|)
block|{
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|gen_rtx
argument_list|(
name|PRE_DEC
argument_list|,
name|SImode
argument_list|,
name|stack_pointer_rtx
argument_list|)
argument_list|)
argument_list|,
name|frame_pointer_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|xops
index|[
literal|1
index|]
argument_list|,
name|xops
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|output_asm_insn
argument_list|(
literal|"push%L1 %1"
argument_list|,
name|xops
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INCOMING_RETURN_ADDR_RTX
if|if
condition|(
name|dwarf2out_do_frame
argument_list|()
condition|)
block|{
name|char
modifier|*
name|l
init|=
name|dwarf2out_cfi_label
argument_list|()
decl_stmt|;
name|cfa_store_offset
operator|+=
literal|4
expr_stmt|;
name|cfa_offset
operator|=
name|cfa_store_offset
expr_stmt|;
name|dwarf2out_def_cfa
argument_list|(
name|l
argument_list|,
name|STACK_POINTER_REGNUM
argument_list|,
name|cfa_offset
argument_list|)
expr_stmt|;
name|dwarf2out_reg_save
argument_list|(
name|l
argument_list|,
name|FRAME_POINTER_REGNUM
argument_list|,
operator|-
name|cfa_store_offset
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|mov
operator|%
name|L0
argument_list|,
operator|%
literal|0
argument_list|,
operator|%
literal|1
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INCOMING_RETURN_ADDR_RTX
if|if
condition|(
name|dwarf2out_do_frame
argument_list|()
condition|)
name|dwarf2out_def_cfa
argument_list|(
literal|""
argument_list|,
name|FRAME_POINTER_REGNUM
argument_list|,
name|cfa_offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
if|if
condition|(
name|tsize
operator|==
literal|0
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|TARGET_STACK_PROBE
operator|||
name|tsize
operator|<
name|CHECK_STACK_LIMIT
condition|)
block|{
if|if
condition|(
name|do_rtl
condition|)
block|{
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_prologue_set_stack_ptr
argument_list|(
name|xops
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|sub
operator|%
name|L0
argument_list|,
operator|%
literal|2
argument_list|,
operator|%
literal|0
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INCOMING_RETURN_ADDR_RTX
if|if
condition|(
name|dwarf2out_do_frame
argument_list|()
condition|)
block|{
name|cfa_store_offset
operator|+=
name|tsize
expr_stmt|;
if|if
condition|(
operator|!
name|frame_pointer_needed
condition|)
block|{
name|cfa_offset
operator|=
name|cfa_store_offset
expr_stmt|;
name|dwarf2out_def_cfa
argument_list|(
literal|""
argument_list|,
name|STACK_POINTER_REGNUM
argument_list|,
name|cfa_offset
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
block|}
else|else
block|{
name|xops
index|[
literal|3
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_rtl
condition|)
name|emit_move_insn
argument_list|(
name|xops
index|[
literal|3
index|]
argument_list|,
name|xops
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
else|else
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|mov
operator|%
name|L0
argument_list|,
operator|%
literal|2
argument_list|,
operator|%
literal|3
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
name|xops
index|[
literal|3
index|]
operator|=
name|gen_rtx_MEM
argument_list|(
name|FUNCTION_MODE
argument_list|,
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"_alloca"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_rtl
condition|)
name|emit_call_insn
argument_list|(
name|gen_rtx
argument_list|(
name|CALL
argument_list|,
name|VOIDmode
argument_list|,
name|xops
index|[
literal|3
index|]
argument_list|,
name|const0_rtx
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|output_asm_insn
argument_list|(
name|AS1
argument_list|(
name|call
argument_list|,
operator|%
name|P3
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
block|}
comment|/* Note If use enter it is NOT reversed args.      This one is not reversed from intel!!      I think enter is slower.  Also sdb doesn't like it.      But if you want it the code is:      {      xops[3] = const0_rtx;      output_asm_insn ("enter %2,%3", xops);      }      */
name|limit
operator|=
operator|(
name|frame_pointer_needed
condition|?
name|FRAME_POINTER_REGNUM
else|:
name|STACK_POINTER_REGNUM
operator|)
expr_stmt|;
for|for
control|(
name|regno
operator|=
name|limit
operator|-
literal|1
init|;
name|regno
operator|>=
literal|0
condition|;
name|regno
operator|--
control|)
if|if
condition|(
operator|(
name|regs_ever_live
index|[
name|regno
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|regno
index|]
operator|)
operator|||
operator|(
name|regno
operator|==
name|PIC_OFFSET_TABLE_REGNUM
operator|&&
name|pic_reg_used
operator|)
condition|)
block|{
name|xops
index|[
literal|0
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_rtl
condition|)
block|{
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|gen_rtx
argument_list|(
name|PRE_DEC
argument_list|,
name|SImode
argument_list|,
name|stack_pointer_rtx
argument_list|)
argument_list|)
argument_list|,
name|xops
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|output_asm_insn
argument_list|(
literal|"push%L0 %0"
argument_list|,
name|xops
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INCOMING_RETURN_ADDR_RTX
if|if
condition|(
name|dwarf2out_do_frame
argument_list|()
condition|)
block|{
name|char
modifier|*
name|l
init|=
name|dwarf2out_cfi_label
argument_list|()
decl_stmt|;
name|cfa_store_offset
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
operator|!
name|frame_pointer_needed
condition|)
block|{
name|cfa_offset
operator|=
name|cfa_store_offset
expr_stmt|;
name|dwarf2out_def_cfa
argument_list|(
name|l
argument_list|,
name|STACK_POINTER_REGNUM
argument_list|,
name|cfa_offset
argument_list|)
expr_stmt|;
block|}
name|dwarf2out_reg_save
argument_list|(
name|l
argument_list|,
name|regno
argument_list|,
operator|-
name|cfa_store_offset
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
ifdef|#
directive|ifdef
name|SUBTARGET_PROLOGUE
name|SUBTARGET_PROLOGUE
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pic_reg_used
condition|)
name|load_pic_register
argument_list|(
name|do_rtl
argument_list|)
expr_stmt|;
comment|/* If we are profiling, make sure no instructions are scheduled before      the call to mcount.  However, if -fpic, the above call will have      done that.  */
if|if
condition|(
operator|(
name|profile_flag
operator|||
name|profile_block_flag
operator|)
operator|&&
operator|!
name|pic_reg_used
operator|&&
name|do_rtl
condition|)
name|emit_insn
argument_list|(
name|gen_blockage
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return 1 if it is appropriate to emit `ret' instructions in the    body of a function.  Do this only if the epilogue is simple, needing a    couple of insns.  Prior to reloading, we can't tell how many registers    must be saved, so return 0 then.  Return 0 if there is no frame    marker to de-allocate.     If NON_SAVING_SETJMP is defined and true, then it is not possible    for the epilogue to be simple, so return 0.  This is a special case    since NON_SAVING_SETJMP will not cause regs_ever_live to change    until final, but jump_optimize may need to know sooner if a    `return' is OK.  */
end_comment

begin_function
name|int
name|ix86_can_use_return_insn_p
parameter_list|()
block|{
name|int
name|regno
decl_stmt|;
name|int
name|nregs
init|=
literal|0
decl_stmt|;
name|int
name|reglimit
init|=
operator|(
name|frame_pointer_needed
condition|?
name|FRAME_POINTER_REGNUM
else|:
name|STACK_POINTER_REGNUM
operator|)
decl_stmt|;
ifdef|#
directive|ifdef
name|TARGET_PROFILER_EPILOGUE
if|if
condition|(
name|TARGET_PROFILER_EPILOGUE
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NON_SAVING_SETJMP
if|if
condition|(
name|NON_SAVING_SETJMP
operator|&&
name|current_function_calls_setjmp
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|reload_completed
condition|)
return|return
literal|0
return|;
for|for
control|(
name|regno
operator|=
name|reglimit
operator|-
literal|1
init|;
name|regno
operator|>=
literal|0
condition|;
name|regno
operator|--
control|)
if|if
condition|(
operator|(
name|regs_ever_live
index|[
name|regno
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|regno
index|]
operator|)
operator|||
operator|(
name|regno
operator|==
name|PIC_OFFSET_TABLE_REGNUM
operator|&&
name|PIC_REG_USED
operator|)
condition|)
name|nregs
operator|++
expr_stmt|;
return|return
name|nregs
operator|==
literal|0
operator|||
operator|!
name|frame_pointer_needed
return|;
block|}
end_function

begin_comment
comment|/* This function generates the assembly code for function exit.    FILE is an stdio stream to output the code to.    SIZE is an int: how many units of temporary storage to deallocate. */
end_comment

begin_function
name|void
name|function_epilogue
parameter_list|(
name|file
parameter_list|,
name|size
parameter_list|)
name|FILE
modifier|*
name|file
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|size
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return;
block|}
end_function

begin_comment
comment|/* Restore function stack, frame, and registers. */
end_comment

begin_function
name|void
name|ix86_expand_epilogue
parameter_list|()
block|{
name|ix86_epilogue
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ix86_epilogue
parameter_list|(
name|do_rtl
parameter_list|)
name|int
name|do_rtl
decl_stmt|;
block|{
specifier|register
name|int
name|regno
decl_stmt|;
specifier|register
name|int
name|limit
decl_stmt|;
name|int
name|nregs
decl_stmt|;
name|rtx
name|xops
index|[
literal|3
index|]
decl_stmt|;
name|int
name|pic_reg_used
init|=
name|PIC_REG_USED
decl_stmt|;
name|int
name|sp_valid
init|=
operator|!
name|frame_pointer_needed
operator|||
name|current_function_sp_is_unchanging
decl_stmt|;
name|HOST_WIDE_INT
name|offset
decl_stmt|;
name|HOST_WIDE_INT
name|tsize
init|=
name|ix86_compute_frame_size
argument_list|(
name|get_frame_size
argument_list|()
argument_list|,
operator|&
name|nregs
argument_list|)
decl_stmt|;
comment|/* sp is often unreliable so we may have to go off the frame pointer. */
name|offset
operator|=
operator|-
operator|(
name|tsize
operator|+
name|nregs
operator|*
name|UNITS_PER_WORD
operator|)
expr_stmt|;
name|xops
index|[
literal|2
index|]
operator|=
name|stack_pointer_rtx
expr_stmt|;
comment|/* When -fpic, we must emit a scheduling barrier, so that the instruction      that restores %ebx (which is PIC_OFFSET_TABLE_REGNUM), does not get      moved before any instruction which implicitly uses the got.  This      includes any instruction which uses a SYMBOL_REF or a LABEL_REF.       Alternatively, this could be fixed by making the dependence on the      PIC_OFFSET_TABLE_REGNUM explicit in the RTL.  */
if|if
condition|(
name|flag_pic
operator|||
name|profile_flag
operator|||
name|profile_block_flag
condition|)
name|emit_insn
argument_list|(
name|gen_blockage
argument_list|()
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FUNCTION_PROFILER_EPILOGUE
name|FUNCTION_PROFILER_EPILOGUE
argument_list|(
name|asm_out_file
argument_list|,
name|do_rtl
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If we're only restoring one register and sp is not valid then      using a move instruction to restore the register since it's      less work than reloading sp and popping the register.  Otherwise,      restore sp (if necessary) and pop the registers. */
name|limit
operator|=
name|frame_pointer_needed
condition|?
name|FRAME_POINTER_REGNUM
else|:
name|STACK_POINTER_REGNUM
expr_stmt|;
if|if
condition|(
name|nregs
operator|>
literal|1
operator|||
name|sp_valid
condition|)
block|{
if|if
condition|(
operator|!
name|sp_valid
condition|)
block|{
name|xops
index|[
literal|0
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|AT_BP
argument_list|(
name|QImode
argument_list|)
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_rtl
condition|)
name|emit_insn
argument_list|(
name|gen_movsi_lea
argument_list|(
name|xops
index|[
literal|2
index|]
argument_list|,
name|XEXP
argument_list|(
name|xops
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|lea
operator|%
name|L2
argument_list|,
operator|%
literal|0
argument_list|,
operator|%
literal|2
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|limit
condition|;
name|regno
operator|++
control|)
if|if
condition|(
operator|(
name|regs_ever_live
index|[
name|regno
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|regno
index|]
operator|)
operator|||
operator|(
name|regno
operator|==
name|PIC_OFFSET_TABLE_REGNUM
operator|&&
name|pic_reg_used
operator|)
condition|)
block|{
name|xops
index|[
literal|0
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_rtl
condition|)
name|emit_insn
argument_list|(
name|gen_pop
argument_list|(
name|xops
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|output_asm_insn
argument_list|(
literal|"pop%L0 %0"
argument_list|,
name|xops
argument_list|)
expr_stmt|;
block|}
block|}
else|else
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|limit
condition|;
name|regno
operator|++
control|)
if|if
condition|(
operator|(
name|regs_ever_live
index|[
name|regno
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|regno
index|]
operator|)
operator|||
operator|(
name|regno
operator|==
name|PIC_OFFSET_TABLE_REGNUM
operator|&&
name|pic_reg_used
operator|)
condition|)
block|{
name|xops
index|[
literal|0
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|xops
index|[
literal|1
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|AT_BP
argument_list|(
name|Pmode
argument_list|)
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_rtl
condition|)
name|emit_move_insn
argument_list|(
name|xops
index|[
literal|0
index|]
argument_list|,
name|xops
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|mov
operator|%
name|L0
argument_list|,
operator|%
literal|1
argument_list|,
operator|%
literal|0
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
comment|/* If not an i386, mov& pop is faster than "leave". */
if|if
condition|(
name|TARGET_USE_LEAVE
condition|)
block|{
if|if
condition|(
name|do_rtl
condition|)
name|emit_insn
argument_list|(
name|gen_leave
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|output_asm_insn
argument_list|(
literal|"leave"
argument_list|,
name|xops
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xops
index|[
literal|0
index|]
operator|=
name|frame_pointer_rtx
expr_stmt|;
name|xops
index|[
literal|1
index|]
operator|=
name|stack_pointer_rtx
expr_stmt|;
if|if
condition|(
name|do_rtl
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_epilogue_set_stack_ptr
argument_list|()
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_pop
argument_list|(
name|xops
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|mov
operator|%
name|L2
argument_list|,
operator|%
literal|0
argument_list|,
operator|%
literal|2
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"pop%L0 %0"
argument_list|,
name|xops
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|tsize
condition|)
block|{
comment|/* Intel's docs say that for 4 or 8 bytes of stack frame one should 	 use `pop' and not `add'.  */
name|int
name|use_pop
init|=
name|tsize
operator|==
literal|4
decl_stmt|;
comment|/* Use two pops only for the Pentium processors.  */
if|if
condition|(
name|tsize
operator|==
literal|8
operator|&&
operator|!
name|TARGET_386
operator|&&
operator|!
name|TARGET_486
condition|)
block|{
name|rtx
name|retval
init|=
name|current_function_return_rtx
decl_stmt|;
name|xops
index|[
literal|1
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* %edx */
comment|/* This case is a bit more complex.  Since we cannot pop into 	     %ecx twice we need a second register.  But this is only 	     available if the return value is not of DImode in which 	     case the %edx register is not available.  */
name|use_pop
operator|=
operator|(
name|retval
operator|==
name|NULL
operator|||
operator|!
name|reg_overlap_mentioned_p
argument_list|(
name|xops
index|[
literal|1
index|]
argument_list|,
name|retval
argument_list|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|use_pop
condition|)
block|{
name|xops
index|[
literal|0
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* %ecx */
if|if
condition|(
name|do_rtl
condition|)
block|{
comment|/* We have to prevent the two pops here from being scheduled. 		 GCC otherwise would try in some situation to put other 		 instructions in between them which has a bad effect.  */
name|emit_insn
argument_list|(
name|gen_blockage
argument_list|()
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_pop
argument_list|(
name|xops
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tsize
operator|==
literal|8
condition|)
name|emit_insn
argument_list|(
name|gen_pop
argument_list|(
name|xops
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|output_asm_insn
argument_list|(
literal|"pop%L0 %0"
argument_list|,
name|xops
argument_list|)
expr_stmt|;
if|if
condition|(
name|tsize
operator|==
literal|8
condition|)
name|output_asm_insn
argument_list|(
literal|"pop%L1 %1"
argument_list|,
name|xops
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* If there is no frame pointer, we must still release the frame. */
name|xops
index|[
literal|0
index|]
operator|=
name|GEN_INT
argument_list|(
name|tsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_rtl
condition|)
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|xops
index|[
literal|2
index|]
argument_list|,
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|SImode
argument_list|,
name|xops
index|[
literal|2
index|]
argument_list|,
name|xops
index|[
literal|0
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|add
operator|%
name|L2
argument_list|,
operator|%
literal|0
argument_list|,
operator|%
literal|2
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|FUNCTION_BLOCK_PROFILER_EXIT
if|if
condition|(
name|profile_block_flag
operator|==
literal|2
condition|)
block|{
comment|/* XXX this is hosed like FUNCTION_PROFILER_EPILOGUE () was.  */
name|FUNCTION_BLOCK_PROFILER_EXIT
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|current_function_pops_args
operator|&&
name|current_function_args_size
condition|)
block|{
name|xops
index|[
literal|1
index|]
operator|=
name|GEN_INT
argument_list|(
name|current_function_pops_args
argument_list|)
expr_stmt|;
comment|/* i386 can only pop 32K bytes (maybe 64K?  Is it signed?).  If 	 asked to pop more, pop return address, do explicit add, and jump 	 indirectly to the caller. */
if|if
condition|(
name|current_function_pops_args
operator|>=
literal|32768
condition|)
block|{
comment|/* ??? Which register to use here? */
name|xops
index|[
literal|0
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_rtl
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_pop
argument_list|(
name|xops
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|xops
index|[
literal|2
index|]
argument_list|,
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|SImode
argument_list|,
name|xops
index|[
literal|1
index|]
argument_list|,
name|xops
index|[
literal|2
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|xops
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|output_asm_insn
argument_list|(
literal|"pop%L0 %0"
argument_list|,
name|xops
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|add
operator|%
name|L2
argument_list|,
operator|%
literal|1
argument_list|,
operator|%
literal|2
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"jmp %*%0"
argument_list|,
name|xops
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|do_rtl
condition|)
name|emit_jump_insn
argument_list|(
name|gen_return_pop_internal
argument_list|(
name|xops
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|output_asm_insn
argument_list|(
literal|"ret %1"
argument_list|,
name|xops
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|do_rtl
condition|)
name|emit_jump_insn
argument_list|(
name|gen_return_internal
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|output_asm_insn
argument_list|(
literal|"ret"
argument_list|,
name|xops
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression    that is a valid memory address for an instruction.    The MODE argument is the machine mode for the MEM expression    that wants to use this address.     On x86, legitimate addresses are: 	base				movl (base),reg 	displacement			movl disp,reg 	base + displacement		movl disp(base),reg 	index + base			movl (base,index),reg 	(index + base) + displacement	movl disp(base,index),reg 	index*scale			movl (,index,scale),reg 	index*scale + disp		movl disp(,index,scale),reg 	index*scale + base 		movl (base,index,scale),reg 	(index*scale + base) + disp	movl disp(base,index,scale),reg  	In each case, scale can be 1, 2, 4, 8.  */
end_comment

begin_comment
comment|/* This is exactly the same as print_operand_addr, except that    it recognizes addresses instead of printing them.     It only recognizes address in canonical form.  LEGITIMIZE_ADDRESS should    convert common non-canonical forms to canonical form so that they will    be recognized.  */
end_comment

begin_define
define|#
directive|define
name|ADDR_INVALID
parameter_list|(
name|msg
parameter_list|,
name|insn
parameter_list|)
define|\
value|do {									\   if (TARGET_DEBUG_ADDR)						\     {									\       fprintf (stderr, msg);						\       debug_rtx (insn);							\     }									\ } while (0)
end_define

begin_function
name|int
name|legitimate_pic_address_disp_p
parameter_list|(
name|disp
parameter_list|)
specifier|register
name|rtx
name|disp
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|!=
name|CONST
condition|)
return|return
literal|0
return|;
name|disp
operator|=
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|==
name|PLUS
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
literal|0
return|;
name|disp
operator|=
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|!=
name|UNSPEC
operator|||
name|XVECLEN
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
operator|!=
literal|1
condition|)
return|return
literal|0
return|;
comment|/* Must be @GOT or @GOTOFF.  */
if|if
condition|(
name|XINT
argument_list|(
name|disp
argument_list|,
literal|1
argument_list|)
operator|!=
literal|6
operator|&&
name|XINT
argument_list|(
name|disp
argument_list|,
literal|1
argument_list|)
operator|!=
literal|7
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|SYMBOL_REF
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|LABEL_REF
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|legitimate_address_p
parameter_list|(
name|mode
parameter_list|,
name|addr
parameter_list|,
name|strict
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
specifier|register
name|rtx
name|addr
decl_stmt|;
name|int
name|strict
decl_stmt|;
block|{
name|rtx
name|base
init|=
name|NULL_RTX
decl_stmt|;
name|rtx
name|indx
init|=
name|NULL_RTX
decl_stmt|;
name|rtx
name|scale
init|=
name|NULL_RTX
decl_stmt|;
name|rtx
name|disp
init|=
name|NULL_RTX
decl_stmt|;
if|if
condition|(
name|TARGET_DEBUG_ADDR
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n======\nGO_IF_LEGITIMATE_ADDRESS, mode = %s, strict = %d\n"
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|mode
argument_list|)
argument_list|,
name|strict
argument_list|)
expr_stmt|;
name|debug_rtx
argument_list|(
name|addr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|SUBREG
condition|)
name|base
operator|=
name|addr
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|rtx
name|op0
init|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|enum
name|rtx_code
name|code0
init|=
name|GET_CODE
argument_list|(
name|op0
argument_list|)
decl_stmt|;
name|enum
name|rtx_code
name|code1
init|=
name|GET_CODE
argument_list|(
name|op1
argument_list|)
decl_stmt|;
if|if
condition|(
name|code0
operator|==
name|REG
operator|||
name|code0
operator|==
name|SUBREG
condition|)
block|{
if|if
condition|(
name|code1
operator|==
name|REG
operator|||
name|code1
operator|==
name|SUBREG
condition|)
block|{
name|indx
operator|=
name|op0
expr_stmt|;
comment|/* index + base */
name|base
operator|=
name|op1
expr_stmt|;
block|}
else|else
block|{
name|base
operator|=
name|op0
expr_stmt|;
comment|/* base + displacement */
name|disp
operator|=
name|op1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|code0
operator|==
name|MULT
condition|)
block|{
name|indx
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|scale
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|code1
operator|==
name|REG
operator|||
name|code1
operator|==
name|SUBREG
condition|)
name|base
operator|=
name|op1
expr_stmt|;
comment|/* index*scale + base */
else|else
name|disp
operator|=
name|op1
expr_stmt|;
comment|/* index*scale + disp */
block|}
elseif|else
if|if
condition|(
name|code0
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MULT
condition|)
block|{
name|indx
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* index*scale + base + disp */
name|scale
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|base
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|disp
operator|=
name|op1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code0
operator|==
name|PLUS
condition|)
block|{
name|indx
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* index + base + disp */
name|base
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|disp
operator|=
name|op1
expr_stmt|;
block|}
else|else
block|{
name|ADDR_INVALID
argument_list|(
literal|"PLUS subcode is not valid.\n"
argument_list|,
name|op0
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|MULT
condition|)
block|{
name|indx
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* index*scale */
name|scale
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|disp
operator|=
name|addr
expr_stmt|;
comment|/* displacement */
comment|/* Allow arg pointer and stack pointer as index if there is not scaling */
if|if
condition|(
name|base
operator|&&
name|indx
operator|&&
operator|!
name|scale
operator|&&
operator|(
name|indx
operator|==
name|arg_pointer_rtx
operator|||
name|indx
operator|==
name|stack_pointer_rtx
operator|)
condition|)
block|{
name|rtx
name|tmp
init|=
name|base
decl_stmt|;
name|base
operator|=
name|indx
expr_stmt|;
name|indx
operator|=
name|tmp
expr_stmt|;
block|}
comment|/* Validate base register:       Don't allow SUBREG's here, it can lead to spill failures when the base      is one word out of a two word structure, which is represented internally      as a DImode int.  */
if|if
condition|(
name|base
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|!=
name|REG
condition|)
block|{
name|ADDR_INVALID
argument_list|(
literal|"Base is not a register.\n"
argument_list|,
name|base
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|GET_MODE
argument_list|(
name|base
argument_list|)
operator|!=
name|Pmode
condition|)
block|{
name|ADDR_INVALID
argument_list|(
literal|"Base is not in Pmode.\n"
argument_list|,
name|base
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|(
name|strict
operator|&&
operator|!
name|REG_OK_FOR_BASE_STRICT_P
argument_list|(
name|base
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|strict
operator|&&
operator|!
name|REG_OK_FOR_BASE_NONSTRICT_P
argument_list|(
name|base
argument_list|)
operator|)
condition|)
block|{
name|ADDR_INVALID
argument_list|(
literal|"Base is not valid.\n"
argument_list|,
name|base
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
comment|/* Validate index register:       Don't allow SUBREG's here, it can lead to spill failures when the index      is one word out of a two word structure, which is represented internally      as a DImode int.  */
if|if
condition|(
name|indx
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|indx
argument_list|)
operator|!=
name|REG
condition|)
block|{
name|ADDR_INVALID
argument_list|(
literal|"Index is not a register.\n"
argument_list|,
name|indx
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|GET_MODE
argument_list|(
name|indx
argument_list|)
operator|!=
name|Pmode
condition|)
block|{
name|ADDR_INVALID
argument_list|(
literal|"Index is not in Pmode.\n"
argument_list|,
name|indx
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|(
name|strict
operator|&&
operator|!
name|REG_OK_FOR_INDEX_STRICT_P
argument_list|(
name|indx
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|strict
operator|&&
operator|!
name|REG_OK_FOR_INDEX_NONSTRICT_P
argument_list|(
name|indx
argument_list|)
operator|)
condition|)
block|{
name|ADDR_INVALID
argument_list|(
literal|"Index is not valid.\n"
argument_list|,
name|indx
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|scale
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* scale w/o index invalid */
comment|/* Validate scale factor: */
if|if
condition|(
name|scale
condition|)
block|{
name|HOST_WIDE_INT
name|value
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|scale
argument_list|)
operator|!=
name|CONST_INT
condition|)
block|{
name|ADDR_INVALID
argument_list|(
literal|"Scale is not valid.\n"
argument_list|,
name|scale
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|value
operator|=
name|INTVAL
argument_list|(
name|scale
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|1
operator|&&
name|value
operator|!=
literal|2
operator|&&
name|value
operator|!=
literal|4
operator|&&
name|value
operator|!=
literal|8
condition|)
block|{
name|ADDR_INVALID
argument_list|(
literal|"Scale is not a good multiplier.\n"
argument_list|,
name|scale
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
comment|/* Validate displacement.  */
if|if
condition|(
name|disp
condition|)
block|{
if|if
condition|(
operator|!
name|CONSTANT_ADDRESS_P
argument_list|(
name|disp
argument_list|)
condition|)
block|{
name|ADDR_INVALID
argument_list|(
literal|"Displacement is not valid.\n"
argument_list|,
name|disp
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
name|ADDR_INVALID
argument_list|(
literal|"Displacement is a const_double.\n"
argument_list|,
name|disp
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|flag_pic
operator|&&
name|SYMBOLIC_CONST
argument_list|(
name|disp
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|legitimate_pic_address_disp_p
argument_list|(
name|disp
argument_list|)
condition|)
block|{
name|ADDR_INVALID
argument_list|(
literal|"Displacement is an invalid PIC construct.\n"
argument_list|,
name|disp
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|base
operator|!=
name|pic_offset_table_rtx
operator|&&
operator|(
name|indx
operator|!=
name|pic_offset_table_rtx
operator|||
name|scale
operator|!=
name|NULL_RTX
operator|)
condition|)
block|{
name|ADDR_INVALID
argument_list|(
literal|"PIC displacement against invalid base.\n"
argument_list|,
name|disp
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|HALF_PIC_P
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|HALF_PIC_ADDRESS_P
argument_list|(
name|disp
argument_list|)
operator|||
operator|(
name|base
operator|!=
name|NULL_RTX
operator|||
name|indx
operator|!=
name|NULL_RTX
operator|)
condition|)
block|{
name|ADDR_INVALID
argument_list|(
literal|"Displacement is an invalid half-pic reference.\n"
argument_list|,
name|disp
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
block|}
if|if
condition|(
name|TARGET_DEBUG_ADDR
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Address is valid.\n"
argument_list|)
expr_stmt|;
comment|/* Everything looks valid, return true */
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a legitimate reference for ORIG (an address) using the    register REG.  If REG is 0, a new pseudo is generated.     There are two types of references that must be handled:     1. Global data references must load the address from the GOT, via       the PIC reg.  An insn is emitted to do this load, and the reg is       returned.     2. Static data references, constant pool addresses, and code labels       compute the address as an offset from the GOT, whose base is in       the PIC reg.  Static data objects have SYMBOL_REF_FLAG set to       differentiate them from global data objects.  The returned       address is the PIC reg + an unspec constant.     GO_IF_LEGITIMATE_ADDRESS rejects symbolic references unless the PIC    reg also appears in the address.  */
end_comment

begin_function
name|rtx
name|legitimize_pic_address
parameter_list|(
name|orig
parameter_list|,
name|reg
parameter_list|)
name|rtx
name|orig
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
block|{
name|rtx
name|addr
init|=
name|orig
decl_stmt|;
name|rtx
name|new
init|=
name|orig
decl_stmt|;
name|rtx
name|base
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|LABEL_REF
operator|||
operator|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
operator|(
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|addr
argument_list|)
operator|||
name|SYMBOL_REF_FLAG
argument_list|(
name|addr
argument_list|)
operator|)
operator|)
condition|)
block|{
comment|/* This symbol may be referenced via a displacement from the PIC 	 base address (@GOTOFF).  */
name|current_function_uses_pic_offset_table
operator|=
literal|1
expr_stmt|;
name|new
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|addr
argument_list|)
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_CONST
argument_list|(
name|VOIDmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
literal|0
condition|)
block|{
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|reg
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
block|{
comment|/* This symbol must be referenced via a load from the 	 Global Offset Table (@GOT). */
name|current_function_uses_pic_offset_table
operator|=
literal|1
expr_stmt|;
name|new
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|addr
argument_list|)
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_CONST
argument_list|(
name|VOIDmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|new
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|reg
operator|==
literal|0
condition|)
name|reg
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|reg
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|CONST
condition|)
block|{
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|UNSPEC
condition|)
block|{
comment|/* Check that the unspec is one of the ones we generate?  */
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|!=
name|PLUS
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|rtx
name|op0
init|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
decl_stmt|,
name|op1
init|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* Check first to see if this is a constant offset from a @GOTOFF 	     symbol reference.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|LABEL_REF
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
operator|(
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|op0
argument_list|)
operator|||
name|SYMBOL_REF_FLAG
argument_list|(
name|op0
argument_list|)
operator|)
operator|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|current_function_uses_pic_offset_table
operator|=
literal|1
expr_stmt|;
name|new
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|op0
argument_list|)
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_PLUS
argument_list|(
name|VOIDmode
argument_list|,
name|new
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_CONST
argument_list|(
name|VOIDmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
literal|0
condition|)
block|{
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|reg
expr_stmt|;
block|}
block|}
else|else
block|{
name|base
operator|=
name|legitimize_pic_address
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|new
operator|=
name|legitimize_pic_address
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|,
name|base
operator|==
name|reg
condition|?
name|NULL_RTX
else|:
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|new
argument_list|)
operator|==
name|CONST_INT
condition|)
name|new
operator|=
name|plus_constant
argument_list|(
name|base
argument_list|,
name|INTVAL
argument_list|(
name|new
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|new
argument_list|)
operator|==
name|PLUS
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|new
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|base
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|base
argument_list|,
name|XEXP
argument_list|(
name|new
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|=
name|XEXP
argument_list|(
name|new
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|new
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|base
argument_list|,
name|new
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|new
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit insns to move operands[1] into operands[0].  */
end_comment

begin_function
name|void
name|emit_pic_move
parameter_list|(
name|operands
parameter_list|,
name|mode
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|rtx
name|temp
init|=
name|reload_in_progress
condition|?
name|operands
index|[
literal|0
index|]
else|:
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|MEM
operator|&&
name|SYMBOLIC_CONST
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
name|operands
index|[
literal|1
index|]
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
name|operands
index|[
literal|1
index|]
operator|=
name|legitimize_pic_address
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Try machine-dependent ways of modifying an illegitimate address    to be legitimate.  If we find one, return the new, valid address.    This macro is used in only one place: `memory_address' in explow.c.     OLDX is the address as it was before break_out_memory_refs was called.    In some cases it is useful to look at this to decide what needs to be done.     MODE and WIN are passed so that this macro can use    GO_IF_LEGITIMATE_ADDRESS.     It is always safe for this macro to do nothing.  It exists to recognize    opportunities to optimize the output.     For the 80386, we handle X+REG by loading X into a register R and    using R+REG.  R will go in a general reg and indexing will be used.    However, if REG is a broken-out memory address or multiplication,    nothing needs to be done because REG can certainly go in a general reg.     When -fpic is used, special handling is needed for symbolic references.    See comments by legitimize_pic_address in i386.c for details.  */
end_comment

begin_function
name|rtx
name|legitimize_address
parameter_list|(
name|x
parameter_list|,
name|oldx
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|x
decl_stmt|;
specifier|register
name|rtx
name|oldx
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|int
name|changed
init|=
literal|0
decl_stmt|;
name|unsigned
name|log
decl_stmt|;
if|if
condition|(
name|TARGET_DEBUG_ADDR
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n==========\nLEGITIMIZE_ADDRESS, mode = %s\n"
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
name|debug_rtx
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_pic
operator|&&
name|SYMBOLIC_CONST
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|legitimize_pic_address
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
return|;
comment|/* Canonicalize shifts by 0, 1, 2, 3 into multiply */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|ASHIFT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|log
operator|=
operator|(
name|unsigned
operator|)
name|exact_log2
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|<
literal|4
condition|)
block|{
name|changed
operator|=
literal|1
expr_stmt|;
name|x
operator|=
name|gen_rtx_MULT
argument_list|(
name|Pmode
argument_list|,
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
literal|1
operator|<<
name|log
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
condition|)
block|{
comment|/* Canonicalize shifts by 0, 1, 2, 3 into multiply. */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ASHIFT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|log
operator|=
operator|(
name|unsigned
operator|)
name|exact_log2
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|<
literal|4
condition|)
block|{
name|changed
operator|=
literal|1
expr_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|MULT
argument_list|,
name|Pmode
argument_list|,
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
literal|1
operator|<<
name|log
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|ASHIFT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|log
operator|=
operator|(
name|unsigned
operator|)
name|exact_log2
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|<
literal|4
condition|)
block|{
name|changed
operator|=
literal|1
expr_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|MULT
argument_list|,
name|Pmode
argument_list|,
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
literal|1
operator|<<
name|log
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Put multiply first if it isn't already. */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|MULT
condition|)
block|{
name|rtx
name|tmp
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|=
name|tmp
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Canonicalize (plus (mult (reg) (const)) (plus (reg) (const))) 	 into (plus (plus (mult (reg) (const)) (reg)) (const)).  This can be 	 created by virtual register instantiation, register elimination, and 	 similar optimizations.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MULT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|changed
operator|=
literal|1
expr_stmt|;
name|x
operator|=
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Canonicalize 	 (plus (plus (mult (reg) (const)) (plus (reg) (const))) const) 	 into (plus (plus (mult (reg) (const)) (reg)) (const)).  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MULT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|constant
decl_stmt|;
name|rtx
name|other
init|=
name|NULL_RTX
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|constant
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|other
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|constant
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|other
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|constant
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|constant
condition|)
block|{
name|changed
operator|=
literal|1
expr_stmt|;
name|x
operator|=
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|plus_constant
argument_list|(
name|other
argument_list|,
name|INTVAL
argument_list|(
name|constant
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|changed
operator|&&
name|legitimate_address_p
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
name|FALSE
argument_list|)
condition|)
return|return
name|x
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MULT
condition|)
block|{
name|changed
operator|=
literal|1
expr_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|MULT
condition|)
block|{
name|changed
operator|=
literal|1
expr_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|=
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|changed
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
return|return
name|x
return|;
if|if
condition|(
name|flag_pic
operator|&&
name|SYMBOLIC_CONST
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|changed
operator|=
literal|1
expr_stmt|;
name|x
operator|=
name|legitimize_pic_address
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|changed
operator|&&
name|legitimate_address_p
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
name|FALSE
argument_list|)
condition|)
return|return
name|x
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
specifier|register
name|rtx
name|temp
init|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
specifier|register
name|rtx
name|val
init|=
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|temp
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|!=
name|temp
condition|)
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|=
name|temp
expr_stmt|;
return|return
name|x
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
specifier|register
name|rtx
name|temp
init|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
specifier|register
name|rtx
name|val
init|=
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|temp
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|!=
name|temp
condition|)
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|temp
expr_stmt|;
return|return
name|x
return|;
block|}
block|}
return|return
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print an integer constant expression in assembler syntax.  Addition    and subtraction are the only arithmetic that may appear in these    expressions.  FILE is the stdio stream to write to, X is the rtx, and    CODE is the operand print code from the output string.  */
end_comment

begin_function
specifier|static
name|void
name|output_pic_addr_const
parameter_list|(
name|file
parameter_list|,
name|x
parameter_list|,
name|code
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|int
name|code
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|PC
case|:
if|if
condition|(
name|flag_pic
condition|)
name|putc
argument_list|(
literal|'.'
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
break|break;
case|case
name|SYMBOL_REF
case|:
name|assemble_name
argument_list|(
name|file
argument_list|,
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ASM_HACK_SYMBOLREF_CODE
name|ASM_HACK_SYMBOLREF_CODE
argument_list|(
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|code
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|code
operator|==
literal|'P'
operator|&&
operator|!
name|SYMBOL_REF_FLAG
argument_list|(
name|x
argument_list|)
condition|)
name|fputs
argument_list|(
literal|"@PLT"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|LABEL_REF
case|:
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* FALLTHRU */
case|case
name|CODE_LABEL
case|:
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|asm_out_file
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST_INT
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST
case|:
comment|/* This used to output parentheses around the expression, 	 but that does not work on the 386 (either ATT or BSD assembler).  */
name|output_pic_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|code
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST_DOUBLE
case|:
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|VOIDmode
condition|)
block|{
comment|/* We can use %d if the number is<32 bits and positive.  */
if|if
condition|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
operator|||
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0x%lx%08lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* We can't handle floating point constants; 	   PRINT_OPERAND must handle them.  */
name|output_operand_lossage
argument_list|(
literal|"floating constant misused"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PLUS
case|:
comment|/* Some assemblers need integer constants to appear first.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|output_pic_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"+"
argument_list|)
expr_stmt|;
name|output_pic_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|code
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|output_pic_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"+"
argument_list|)
expr_stmt|;
name|output_pic_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|code
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
break|break;
case|case
name|MINUS
case|:
name|output_pic_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
name|output_pic_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|code
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSPEC
case|:
if|if
condition|(
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|!=
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
name|output_pic_addr_const
argument_list|(
name|file
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|code
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|XINT
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|)
block|{
case|case
literal|6
case|:
name|fputs
argument_list|(
literal|"@GOT"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
literal|7
case|:
name|fputs
argument_list|(
literal|"@GOTOFF"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|fputs
argument_list|(
literal|"@PLT"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
default|default:
name|output_operand_lossage
argument_list|(
literal|"invalid UNSPEC as operand"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|output_operand_lossage
argument_list|(
literal|"invalid expression as operand"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|put_jump_code
parameter_list|(
name|code
parameter_list|,
name|reverse
parameter_list|,
name|file
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
name|int
name|reverse
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|int
name|flags
init|=
name|cc_prev_status
operator|.
name|flags
decl_stmt|;
name|int
name|ieee
init|=
operator|(
name|TARGET_IEEE_FP
operator|&&
operator|(
name|flags
operator|&
name|CC_IN_80387
operator|)
operator|&&
operator|!
operator|(
name|cc_prev_status
operator|.
name|flags
operator|&
name|CC_FCOMI
operator|)
operator|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|suffix
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|CC_Z_IN_NOT_C
condition|)
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EQ
case|:
name|fputs
argument_list|(
name|reverse
condition|?
literal|"c"
else|:
literal|"nc"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
name|NE
case|:
name|fputs
argument_list|(
name|reverse
condition|?
literal|"nc"
else|:
literal|"c"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|ieee
condition|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LE
case|:
name|suffix
operator|=
name|reverse
condition|?
literal|"ae"
else|:
literal|"b"
expr_stmt|;
break|break;
case|case
name|GT
case|:
case|case
name|LT
case|:
case|case
name|GE
case|:
name|suffix
operator|=
name|reverse
condition|?
literal|"ne"
else|:
literal|"e"
expr_stmt|;
break|break;
case|case
name|EQ
case|:
name|suffix
operator|=
name|reverse
condition|?
literal|"ne"
else|:
literal|"e"
expr_stmt|;
break|break;
case|case
name|NE
case|:
name|suffix
operator|=
name|reverse
condition|?
literal|"e"
else|:
literal|"ne"
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|fputs
argument_list|(
name|suffix
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|flags
operator|&
name|CC_TEST_AX
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|CC_NO_OVERFLOW
operator|)
operator|&&
operator|(
name|code
operator|==
name|LE
operator|||
name|code
operator|==
name|GT
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|reverse
condition|)
name|code
operator|=
name|reverse_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EQ
case|:
name|suffix
operator|=
literal|"e"
expr_stmt|;
break|break;
case|case
name|NE
case|:
name|suffix
operator|=
literal|"ne"
expr_stmt|;
break|break;
case|case
name|GT
case|:
name|suffix
operator|=
name|flags
operator|&
name|CC_IN_80387
condition|?
literal|"a"
else|:
literal|"g"
expr_stmt|;
break|break;
case|case
name|GTU
case|:
name|suffix
operator|=
literal|"a"
expr_stmt|;
break|break;
case|case
name|LT
case|:
if|if
condition|(
name|flags
operator|&
name|CC_NO_OVERFLOW
condition|)
name|suffix
operator|=
literal|"s"
expr_stmt|;
else|else
name|suffix
operator|=
name|flags
operator|&
name|CC_IN_80387
condition|?
literal|"b"
else|:
literal|"l"
expr_stmt|;
break|break;
case|case
name|LTU
case|:
name|suffix
operator|=
literal|"b"
expr_stmt|;
break|break;
case|case
name|GE
case|:
if|if
condition|(
name|flags
operator|&
name|CC_NO_OVERFLOW
condition|)
name|suffix
operator|=
literal|"ns"
expr_stmt|;
else|else
name|suffix
operator|=
name|flags
operator|&
name|CC_IN_80387
condition|?
literal|"ae"
else|:
literal|"ge"
expr_stmt|;
break|break;
case|case
name|GEU
case|:
name|suffix
operator|=
literal|"ae"
expr_stmt|;
break|break;
case|case
name|LE
case|:
name|suffix
operator|=
name|flags
operator|&
name|CC_IN_80387
condition|?
literal|"be"
else|:
literal|"le"
expr_stmt|;
break|break;
case|case
name|LEU
case|:
name|suffix
operator|=
literal|"be"
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|fputs
argument_list|(
name|suffix
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Append the correct conditional move suffix which corresponds to CODE.  */
end_comment

begin_function
specifier|static
name|void
name|put_condition_code
parameter_list|(
name|code
parameter_list|,
name|reverse_cc
parameter_list|,
name|mode
parameter_list|,
name|file
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
name|int
name|reverse_cc
decl_stmt|;
name|enum
name|mode_class
name|mode
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|int
name|ieee
init|=
operator|(
name|TARGET_IEEE_FP
operator|&&
operator|(
name|cc_prev_status
operator|.
name|flags
operator|&
name|CC_IN_80387
operator|)
operator|&&
operator|!
operator|(
name|cc_prev_status
operator|.
name|flags
operator|&
name|CC_FCOMI
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|reverse_cc
operator|&&
operator|!
name|ieee
condition|)
name|code
operator|=
name|reverse_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|MODE_INT
condition|)
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|NE
case|:
if|if
condition|(
name|cc_prev_status
operator|.
name|flags
operator|&
name|CC_Z_IN_NOT_C
condition|)
name|fputs
argument_list|(
literal|"b"
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
literal|"ne"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
name|EQ
case|:
if|if
condition|(
name|cc_prev_status
operator|.
name|flags
operator|&
name|CC_Z_IN_NOT_C
condition|)
name|fputs
argument_list|(
literal|"ae"
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
literal|"e"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
name|GE
case|:
if|if
condition|(
name|cc_prev_status
operator|.
name|flags
operator|&
name|CC_NO_OVERFLOW
condition|)
name|fputs
argument_list|(
literal|"ns"
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
literal|"ge"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
name|GT
case|:
name|fputs
argument_list|(
literal|"g"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
name|LE
case|:
name|fputs
argument_list|(
literal|"le"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
name|LT
case|:
if|if
condition|(
name|cc_prev_status
operator|.
name|flags
operator|&
name|CC_NO_OVERFLOW
condition|)
name|fputs
argument_list|(
literal|"s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
literal|"l"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
name|GEU
case|:
name|fputs
argument_list|(
literal|"ae"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
name|GTU
case|:
name|fputs
argument_list|(
literal|"a"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
name|LEU
case|:
name|fputs
argument_list|(
literal|"be"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
name|LTU
case|:
name|fputs
argument_list|(
literal|"b"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
default|default:
name|output_operand_lossage
argument_list|(
literal|"Invalid %%C operand"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|MODE_FLOAT
condition|)
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|NE
case|:
name|fputs
argument_list|(
name|ieee
condition|?
operator|(
name|reverse_cc
condition|?
literal|"ne"
else|:
literal|"e"
operator|)
else|:
literal|"ne"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
name|EQ
case|:
name|fputs
argument_list|(
name|ieee
condition|?
operator|(
name|reverse_cc
condition|?
literal|"ne"
else|:
literal|"e"
operator|)
else|:
literal|"e"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
name|GE
case|:
name|fputs
argument_list|(
name|ieee
condition|?
operator|(
name|reverse_cc
condition|?
literal|"ne"
else|:
literal|"e"
operator|)
else|:
literal|"nb"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
name|GT
case|:
name|fputs
argument_list|(
name|ieee
condition|?
operator|(
name|reverse_cc
condition|?
literal|"ne"
else|:
literal|"e"
operator|)
else|:
literal|"nbe"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
name|LE
case|:
name|fputs
argument_list|(
name|ieee
condition|?
operator|(
name|reverse_cc
condition|?
literal|"nb"
else|:
literal|"b"
operator|)
else|:
literal|"be"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
name|LT
case|:
name|fputs
argument_list|(
name|ieee
condition|?
operator|(
name|reverse_cc
condition|?
literal|"ne"
else|:
literal|"e"
operator|)
else|:
literal|"b"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
name|GEU
case|:
name|fputs
argument_list|(
name|ieee
condition|?
operator|(
name|reverse_cc
condition|?
literal|"ne"
else|:
literal|"e"
operator|)
else|:
literal|"nb"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
name|GTU
case|:
name|fputs
argument_list|(
name|ieee
condition|?
operator|(
name|reverse_cc
condition|?
literal|"ne"
else|:
literal|"e"
operator|)
else|:
literal|"nbe"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
name|LEU
case|:
name|fputs
argument_list|(
name|ieee
condition|?
operator|(
name|reverse_cc
condition|?
literal|"nb"
else|:
literal|"b"
operator|)
else|:
literal|"be"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
name|LTU
case|:
name|fputs
argument_list|(
name|ieee
condition|?
operator|(
name|reverse_cc
condition|?
literal|"ne"
else|:
literal|"e"
operator|)
else|:
literal|"b"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
default|default:
name|output_operand_lossage
argument_list|(
literal|"Invalid %%C operand"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Meaning of CODE:    L,W,B,Q,S,T -- print the opcode suffix for specified size of operand.    C -- print opcode suffix for set/cmov insn.    c -- like C, but print reversed condition    F -- print opcode suffix for fcmov insn.    f -- like F, but print reversed condition    D -- print the opcode suffix for a jump    d -- like D, but print reversed condition    R -- print the prefix for register names.    z -- print the opcode suffix for the size of the current operand.    * -- print a star (in certain assembler syntax)    w -- print the operand as if it's a "word" (HImode) even if it isn't.    J -- print the appropriate jump operand.    s -- print a shift double count, followed by the assemblers argument 	delimiter.    b -- print the QImode name of the register for the indicated operand. 	%b0 would print %al if operands[0] is reg 0.    w --  likewise, print the HImode name of the register.    k --  likewise, print the SImode name of the register.    h --  print the QImode name for a "high" register, either ah, bh, ch or dh.    y --  print "st(0)" instead of "st" as a register.    P --  print as a PIC constant     _ --  output "_" if YES_UNDERSCORES */
end_comment

begin_function
name|void
name|print_operand
parameter_list|(
name|file
parameter_list|,
name|x
parameter_list|,
name|code
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|int
name|code
decl_stmt|;
block|{
if|if
condition|(
name|code
condition|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
literal|'*'
case|:
if|if
condition|(
name|USE_STAR
condition|)
name|putc
argument_list|(
literal|'*'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'_'
case|:
ifdef|#
directive|ifdef
name|YES_UNDERSCORES
name|putc
argument_list|(
literal|'_'
argument_list|,
name|file
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
case|case
literal|'L'
case|:
name|PUT_OP_SIZE
argument_list|(
name|code
argument_list|,
literal|'l'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'W'
case|:
name|PUT_OP_SIZE
argument_list|(
name|code
argument_list|,
literal|'w'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'B'
case|:
name|PUT_OP_SIZE
argument_list|(
name|code
argument_list|,
literal|'b'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'Q'
case|:
name|PUT_OP_SIZE
argument_list|(
name|code
argument_list|,
literal|'l'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'S'
case|:
name|PUT_OP_SIZE
argument_list|(
name|code
argument_list|,
literal|'s'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'T'
case|:
name|PUT_OP_SIZE
argument_list|(
name|code
argument_list|,
literal|'t'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'z'
case|:
comment|/* 387 opcodes don't get size suffixes if the operands are 	     registers. */
if|if
condition|(
name|STACK_REG_P
argument_list|(
name|x
argument_list|)
condition|)
return|return;
comment|/* this is the size of op from size of operand */
switch|switch
condition|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
block|{
case|case
literal|2
case|:
ifdef|#
directive|ifdef
name|HAVE_GAS_FILDS_FISTS
name|PUT_OP_SIZE
argument_list|(
literal|'W'
argument_list|,
literal|'s'
argument_list|,
name|file
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
case|case
literal|4
case|:
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|SFmode
condition|)
block|{
name|PUT_OP_SIZE
argument_list|(
literal|'S'
argument_list|,
literal|'s'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|PUT_OP_SIZE
argument_list|(
literal|'L'
argument_list|,
literal|'l'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|12
case|:
name|PUT_OP_SIZE
argument_list|(
literal|'T'
argument_list|,
literal|'t'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|8
case|:
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MODE_INT
condition|)
block|{
ifdef|#
directive|ifdef
name|GAS_MNEMONICS
name|PUT_OP_SIZE
argument_list|(
literal|'Q'
argument_list|,
literal|'q'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
else|#
directive|else
name|PUT_OP_SIZE
argument_list|(
literal|'Q'
argument_list|,
literal|'l'
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* Fall through */
endif|#
directive|endif
block|}
name|PUT_OP_SIZE
argument_list|(
literal|'Q'
argument_list|,
literal|'l'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
case|case
literal|'b'
case|:
case|case
literal|'w'
case|:
case|case
literal|'k'
case|:
case|case
literal|'h'
case|:
case|case
literal|'y'
case|:
case|case
literal|'P'
case|:
case|case
literal|'X'
case|:
break|break;
case|case
literal|'J'
case|:
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
comment|/* These conditions are appropriate for testing the result 		 of an arithmetic operation, not for a compare operation. 	         Cases GE, LT assume CC_NO_OVERFLOW true. All cases assume 		 CC_Z_IN_NOT_C false and not floating point.  */
case|case
name|NE
case|:
name|fputs
argument_list|(
literal|"jne"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
name|EQ
case|:
name|fputs
argument_list|(
literal|"je"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
name|GE
case|:
name|fputs
argument_list|(
literal|"jns"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
name|LT
case|:
name|fputs
argument_list|(
literal|"js"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
name|GEU
case|:
name|fputs
argument_list|(
literal|"jmp"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
name|GTU
case|:
name|fputs
argument_list|(
literal|"jne"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
name|LEU
case|:
name|fputs
argument_list|(
literal|"je"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
name|LTU
case|:
name|fputs
argument_list|(
literal|"#branch never"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
comment|/* no matching branches for GT nor LE */
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
case|case
literal|'s'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
operator|||
operator|!
name|SHIFT_DOUBLE_OMITS_COUNT
condition|)
block|{
name|PRINT_OPERAND
argument_list|(
name|file
argument_list|,
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|AS2C
argument_list|(,)
operator|+
literal|1
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
literal|'D'
case|:
name|put_jump_code
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'d'
case|:
name|put_jump_code
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|,
literal|1
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
comment|/* This is used by the conditional move instructions.  */
case|case
literal|'C'
case|:
name|put_condition_code
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|,
name|MODE_INT
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
comment|/* Like above, but reverse condition */
case|case
literal|'c'
case|:
name|put_condition_code
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|,
literal|1
argument_list|,
name|MODE_INT
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'F'
case|:
name|put_condition_code
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|,
name|MODE_FLOAT
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
comment|/* Like above, but reverse condition */
case|case
literal|'f'
case|:
name|put_condition_code
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|,
literal|1
argument_list|,
name|MODE_FLOAT
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
default|default:
block|{
name|char
name|str
index|[
literal|50
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|str
argument_list|,
literal|"invalid operand code `%c'"
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|output_operand_lossage
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
block|{
name|PRINT_REG
argument_list|(
name|x
argument_list|,
name|code
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|PRINT_PTR
argument_list|(
name|x
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|flag_pic
condition|)
name|output_pic_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|code
argument_list|)
expr_stmt|;
else|else
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|output_address
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|SFmode
condition|)
block|{
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|long
name|l
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|r
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|REAL_VALUE_TO_TARGET_SINGLE
argument_list|(
name|r
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|PRINT_IMMED_PREFIX
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0x%lx"
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
comment|/* These float cases don't actually occur as immediate operands. */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|DFmode
condition|)
block|{
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|char
name|dstr
index|[
literal|30
index|]
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|r
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|REAL_VALUE_TO_DECIMAL
argument_list|(
name|r
argument_list|,
literal|"%.22e"
argument_list|,
name|dstr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|dstr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|XFmode
condition|)
block|{
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|char
name|dstr
index|[
literal|30
index|]
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|r
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|REAL_VALUE_TO_DECIMAL
argument_list|(
name|r
argument_list|,
literal|"%.22e"
argument_list|,
name|dstr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|dstr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|code
operator|!=
literal|'P'
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
name|PRINT_IMMED_PREFIX
argument_list|(
name|file
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LABEL_REF
condition|)
name|PRINT_OFFSET_PREFIX
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_pic
condition|)
name|output_pic_addr_const
argument_list|(
name|file
argument_list|,
name|x
argument_list|,
name|code
argument_list|)
expr_stmt|;
else|else
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print a memory operand whose address is ADDR.  */
end_comment

begin_function
name|void
name|print_operand_address
parameter_list|(
name|file
parameter_list|,
name|addr
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
specifier|register
name|rtx
name|addr
decl_stmt|;
block|{
specifier|register
name|rtx
name|reg1
decl_stmt|,
name|reg2
decl_stmt|,
name|breg
decl_stmt|,
name|ireg
decl_stmt|;
name|rtx
name|offset
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
condition|)
block|{
case|case
name|REG
case|:
comment|/* ESI addressing makes instruction vector decoded on the K6.  We can 	 avoid this by ESI+0 addressing.  */
if|if
condition|(
name|REGNO_REG_CLASS
argument_list|(
name|REGNO
argument_list|(
name|addr
argument_list|)
argument_list|)
operator|==
name|SIREG
operator|&&
name|ix86_cpu
operator|==
name|PROCESSOR_K6
operator|&&
operator|!
name|optimize_size
condition|)
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|ADDR_BEG
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%se"
argument_list|,
name|RP
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|hi_reg_name
index|[
name|REGNO
argument_list|(
name|addr
argument_list|)
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|ADDR_END
argument_list|(
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|PLUS
case|:
name|reg1
operator|=
literal|0
expr_stmt|;
name|reg2
operator|=
literal|0
expr_stmt|;
name|ireg
operator|=
literal|0
expr_stmt|;
name|breg
operator|=
literal|0
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|offset
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|offset
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|!=
name|PLUS
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MULT
condition|)
name|reg1
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
operator|,
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|MULT
condition|)
name|reg1
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
operator|,
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|reg1
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
operator|,
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|reg1
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
operator|,
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|MULT
condition|)
block|{
if|if
condition|(
name|reg1
operator|==
literal|0
condition|)
name|reg1
operator|=
name|addr
expr_stmt|;
else|else
name|reg2
operator|=
name|addr
expr_stmt|;
name|addr
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|offset
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|addr
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|addr
operator|=
name|offset
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|reg1
operator|&&
name|GET_CODE
argument_list|(
name|reg1
argument_list|)
operator|==
name|MULT
operator|)
operator|||
operator|(
name|reg2
operator|!=
literal|0
operator|&&
name|REGNO_OK_FOR_BASE_P
argument_list|(
name|REGNO
argument_list|(
name|reg2
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|breg
operator|=
name|reg2
expr_stmt|;
name|ireg
operator|=
name|reg1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reg1
operator|!=
literal|0
operator|&&
name|REGNO_OK_FOR_BASE_P
argument_list|(
name|REGNO
argument_list|(
name|reg1
argument_list|)
argument_list|)
condition|)
block|{
name|breg
operator|=
name|reg1
expr_stmt|;
name|ireg
operator|=
name|reg2
expr_stmt|;
block|}
if|if
condition|(
name|ireg
operator|!=
literal|0
operator|||
name|breg
operator|!=
literal|0
condition|)
block|{
name|int
name|scale
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|addr
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|flag_pic
condition|)
name|output_pic_addr_const
argument_list|(
name|file
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|LABEL_REF
condition|)
name|output_asm_label
argument_list|(
name|addr
argument_list|)
expr_stmt|;
else|else
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ireg
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|ireg
argument_list|)
operator|==
name|MULT
condition|)
block|{
name|scale
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|ireg
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|ireg
operator|=
name|XEXP
argument_list|(
name|ireg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* The stack pointer can only appear as a base register, 	     never an index register, so exchange the regs if it is wrong. */
if|if
condition|(
name|scale
operator|==
literal|1
operator|&&
name|ireg
operator|&&
name|REGNO
argument_list|(
name|ireg
argument_list|)
operator|==
name|STACK_POINTER_REGNUM
condition|)
block|{
name|rtx
name|tmp
decl_stmt|;
name|tmp
operator|=
name|breg
expr_stmt|;
name|breg
operator|=
name|ireg
expr_stmt|;
name|ireg
operator|=
name|tmp
expr_stmt|;
block|}
comment|/* output breg+ireg*scale */
name|PRINT_B_I_S
argument_list|(
name|breg
argument_list|,
name|ireg
argument_list|,
name|scale
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|MULT
case|:
block|{
name|int
name|scale
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|scale
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|ireg
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|scale
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|ireg
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* (reg,reg,) is shorter than (,reg,2).  */
if|if
condition|(
name|scale
operator|==
literal|2
condition|)
block|{
name|PRINT_B_I_S
argument_list|(
name|ireg
argument_list|,
name|ireg
argument_list|,
literal|1
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|PRINT_B_I_S
argument_list|(
name|NULL_RTX
argument_list|,
name|ireg
argument_list|,
name|scale
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|addr
argument_list|)
operator|<
literal|0x8000
operator|&&
name|INTVAL
argument_list|(
name|addr
argument_list|)
operator|>=
operator|-
literal|0x8000
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
operator|(
name|int
operator|)
name|INTVAL
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|flag_pic
condition|)
name|output_pic_addr_const
argument_list|(
name|file
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Set the cc_status for the results of an insn whose pattern is EXP.    On the 80386, we assume that only test and compare insns, as well    as SI, HI,& DI mode ADD, SUB, NEG, AND, IOR, XOR, BSF, ASHIFT,    ASHIFTRT, and LSHIFTRT instructions set the condition codes usefully.    Also, we assume that jumps, moves and sCOND don't affect the condition    codes.  All else clobbers the condition codes, by assumption.     We assume that ALL integer add, minus, etc. instructions effect the    condition codes.  This MUST be consistent with i386.md.     We don't record any float test or compare - the redundant test&    compare check in final.c does not handle stack-like regs correctly. */
end_comment

begin_function
name|void
name|notice_update_cc
parameter_list|(
name|exp
parameter_list|)
name|rtx
name|exp
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|SET
condition|)
block|{
comment|/* Jumps do not alter the cc's.  */
if|if
condition|(
name|SET_DEST
argument_list|(
name|exp
argument_list|)
operator|==
name|pc_rtx
condition|)
return|return;
comment|/* Moving register or memory into a register: 	 it doesn't alter the cc's, but it might invalidate 	 the RTX's which we remember the cc's came from. 	 (Note that moving a constant 0 or 1 MAY set the cc's).  */
if|if
condition|(
name|REG_P
argument_list|(
name|SET_DEST
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|&&
operator|(
name|REG_P
argument_list|(
name|SET_SRC
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|MEM
operator|||
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'<'
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|IF_THEN_ELSE
operator|)
condition|)
block|{
if|if
condition|(
name|cc_status
operator|.
name|value1
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|SET_DEST
argument_list|(
name|exp
argument_list|)
argument_list|,
name|cc_status
operator|.
name|value1
argument_list|)
condition|)
name|cc_status
operator|.
name|value1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cc_status
operator|.
name|value2
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|SET_DEST
argument_list|(
name|exp
argument_list|)
argument_list|,
name|cc_status
operator|.
name|value2
argument_list|)
condition|)
name|cc_status
operator|.
name|value2
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* Moving register into memory doesn't alter the cc's. 	 It may invalidate the RTX's which we remember the cc's came from.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
name|REG_P
argument_list|(
name|SET_SRC
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|||
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'<'
operator|)
condition|)
block|{
if|if
condition|(
name|cc_status
operator|.
name|value1
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|SET_DEST
argument_list|(
name|exp
argument_list|)
argument_list|,
name|cc_status
operator|.
name|value1
argument_list|)
condition|)
name|cc_status
operator|.
name|value1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cc_status
operator|.
name|value2
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|SET_DEST
argument_list|(
name|exp
argument_list|)
argument_list|,
name|cc_status
operator|.
name|value2
argument_list|)
condition|)
name|cc_status
operator|.
name|value2
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* Function calls clobber the cc's.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|CALL
condition|)
block|{
name|CC_STATUS_INIT
expr_stmt|;
return|return;
block|}
comment|/* Tests and compares set the cc's in predictable ways.  */
elseif|else
if|if
condition|(
name|SET_DEST
argument_list|(
name|exp
argument_list|)
operator|==
name|cc0_rtx
condition|)
block|{
name|CC_STATUS_INIT
expr_stmt|;
name|cc_status
operator|.
name|value1
operator|=
name|SET_SRC
argument_list|(
name|exp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Certain instructions effect the condition codes. */
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|SImode
operator|||
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|HImode
operator|||
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|QImode
condition|)
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|ASHIFTRT
case|:
case|case
name|LSHIFTRT
case|:
case|case
name|ASHIFT
case|:
comment|/* Shifts on the 386 don't set the condition codes if the 	       shift count is zero. */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|exp
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
block|{
name|CC_STATUS_INIT
expr_stmt|;
break|break;
block|}
comment|/* We assume that the CONST_INT is non-zero (this rtx would 	       have been deleted if it were zero. */
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
case|case
name|NEG
case|:
case|case
name|AND
case|:
case|case
name|IOR
case|:
case|case
name|XOR
case|:
name|cc_status
operator|.
name|flags
operator|=
name|CC_NO_OVERFLOW
expr_stmt|;
name|cc_status
operator|.
name|value1
operator|=
name|SET_SRC
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|cc_status
operator|.
name|value2
operator|=
name|SET_DEST
argument_list|(
name|exp
argument_list|)
expr_stmt|;
break|break;
comment|/* This is the bsf pattern used by ffs.  */
case|case
name|UNSPEC
case|:
if|if
condition|(
name|XINT
argument_list|(
name|SET_SRC
argument_list|(
name|exp
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
literal|5
condition|)
block|{
comment|/* Only the Z flag is defined after bsf.  */
name|cc_status
operator|.
name|flags
operator|=
name|CC_NOT_POSITIVE
operator||
name|CC_NOT_NEGATIVE
operator||
name|CC_NO_OVERFLOW
expr_stmt|;
name|cc_status
operator|.
name|value1
operator|=
name|XVECEXP
argument_list|(
name|SET_SRC
argument_list|(
name|exp
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cc_status
operator|.
name|value2
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* FALLTHRU */
default|default:
name|CC_STATUS_INIT
expr_stmt|;
block|}
else|else
block|{
name|CC_STATUS_INIT
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
block|{
if|if
condition|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|pc_rtx
condition|)
return|return;
if|if
condition|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|cc0_rtx
condition|)
block|{
name|CC_STATUS_INIT
expr_stmt|;
if|if
condition|(
name|stack_regs_mentioned_p
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|cc_status
operator|.
name|flags
operator||=
name|CC_IN_80387
expr_stmt|;
if|if
condition|(
name|TARGET_CMOVE
operator|&&
name|stack_regs_mentioned_p
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|cc_status
operator|.
name|flags
operator||=
name|CC_FCOMI
expr_stmt|;
block|}
else|else
name|cc_status
operator|.
name|value1
operator|=
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|CC_STATUS_INIT
expr_stmt|;
block|}
else|else
block|{
name|CC_STATUS_INIT
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Split one or more DImode RTL references into pairs of SImode    references.  The RTL can be REG, offsettable MEM, integer constant, or    CONST_DOUBLE.  "operands" is a pointer to an array of DImode RTL to    split and "num" is its length.  lo_half and hi_half are output arrays    that parallel "operands". */
end_comment

begin_decl_stmt
name|void
name|split_di
argument_list|(
name|operands
argument_list|,
name|num
argument_list|,
name|lo_half
argument_list|,
name|hi_half
argument_list|)
name|rtx
name|operands
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|num
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|lo_half
index|[]
decl_stmt|,
name|hi_half
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
name|num
operator|--
condition|)
block|{
name|rtx
name|op
init|=
name|operands
index|[
name|num
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|reload_completed
condition|)
block|{
name|lo_half
index|[
name|num
index|]
operator|=
name|gen_lowpart
argument_list|(
name|SImode
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|hi_half
index|[
name|num
index|]
operator|=
name|gen_highpart
argument_list|(
name|SImode
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
condition|)
block|{
name|lo_half
index|[
name|num
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
name|hi_half
index|[
name|num
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|op
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
condition|)
name|split_double
argument_list|(
name|op
argument_list|,
operator|&
name|lo_half
index|[
name|num
index|]
argument_list|,
operator|&
name|hi_half
index|[
name|num
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|offsettable_memref_p
argument_list|(
name|op
argument_list|)
condition|)
block|{
name|rtx
name|lo_addr
init|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|hi_addr
init|=
name|XEXP
argument_list|(
name|adj_offsettable_operand
argument_list|(
name|op
argument_list|,
literal|4
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|lo_half
index|[
name|num
index|]
operator|=
name|change_address
argument_list|(
name|op
argument_list|,
name|SImode
argument_list|,
name|lo_addr
argument_list|)
expr_stmt|;
name|hi_half
index|[
name|num
index|]
operator|=
name|change_address
argument_list|(
name|op
argument_list|,
name|SImode
argument_list|,
name|hi_addr
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Return 1 if this is a valid binary operation on a 387.    OP is the expression matched, and MODE is its mode. */
end_comment

begin_function
name|int
name|binary_387_op
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
case|case
name|MULT
case|:
case|case
name|DIV
case|:
return|return
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if this is a valid shift or rotate operation on a 386.    OP is the expression matched, and MODE is its mode. */
end_comment

begin_function
name|int
name|shift_op
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|rtx
name|operand
init|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|operand
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|||
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|!=
name|MODE_INT
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|ASHIFT
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|ASHIFTRT
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|LSHIFTRT
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|ROTATE
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|ROTATERT
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is COMPARE rtx with mode VOIDmode.    MODE is not used.  */
end_comment

begin_function
name|int
name|VOIDmode_compare_op
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|COMPARE
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output code to perform a 387 binary operation in INSN, one of PLUS,    MINUS, MULT or DIV.  OPERANDS are the insn operands, where operands[3]    is the expression of the binary operation.  The output may either be    emitted here, or returned to the caller, like all output_* functions.     There is no guarantee that the operands are the same mode, as they    might be within FLOAT or FLOAT_EXTEND expressions. */
end_comment

begin_function
name|char
modifier|*
name|output_387_binary_op
parameter_list|(
name|insn
parameter_list|,
name|operands
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
name|rtx
name|temp
decl_stmt|;
name|char
modifier|*
name|base_op
decl_stmt|;
specifier|static
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
case|case
name|PLUS
case|:
name|base_op
operator|=
literal|"fadd"
expr_stmt|;
break|break;
case|case
name|MINUS
case|:
name|base_op
operator|=
literal|"fsub"
expr_stmt|;
break|break;
case|case
name|MULT
case|:
name|base_op
operator|=
literal|"fmul"
expr_stmt|;
break|break;
case|case
name|DIV
case|:
name|base_op
operator|=
literal|"fdiv"
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|buf
argument_list|,
name|base_op
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
case|case
name|MULT
case|:
case|case
name|PLUS
case|:
if|if
condition|(
name|REG_P
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|REGNO
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
name|temp
operator|=
name|operands
index|[
literal|2
index|]
expr_stmt|;
name|operands
index|[
literal|2
index|]
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|temp
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|==
name|MEM
condition|)
return|return
name|strcat
argument_list|(
name|buf
argument_list|,
name|AS1
argument_list|(
operator|%
name|z2
argument_list|,
operator|%
literal|2
argument_list|)
argument_list|)
return|;
if|if
condition|(
operator|!
name|STACK_REG_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|||
operator|!
name|STACK_REG_P
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|STACK_TOP_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
name|strcat
argument_list|(
name|buf
argument_list|,
name|AS2
argument_list|(
name|p
argument_list|,
operator|%
literal|0
argument_list|,
operator|%
literal|2
argument_list|)
argument_list|)
return|;
else|else
return|return
name|strcat
argument_list|(
name|buf
argument_list|,
name|AS2
argument_list|(
name|p
argument_list|,
operator|%
literal|2
argument_list|,
operator|%
literal|0
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|STACK_TOP_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
name|strcat
argument_list|(
name|buf
argument_list|,
name|AS2C
argument_list|(
operator|%
name|y2
argument_list|,
operator|%
literal|0
argument_list|)
argument_list|)
return|;
else|else
return|return
name|strcat
argument_list|(
name|buf
argument_list|,
name|AS2C
argument_list|(
operator|%
literal|2
argument_list|,
operator|%
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|MINUS
case|:
case|case
name|DIV
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|MEM
condition|)
return|return
name|strcat
argument_list|(
name|buf
argument_list|,
name|AS1
argument_list|(
name|r
operator|%
name|z1
argument_list|,
operator|%
literal|1
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|==
name|MEM
condition|)
return|return
name|strcat
argument_list|(
name|buf
argument_list|,
name|AS1
argument_list|(
operator|%
name|z2
argument_list|,
operator|%
literal|2
argument_list|)
argument_list|)
return|;
if|if
condition|(
operator|!
name|STACK_REG_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|||
operator|!
name|STACK_REG_P
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|STACK_TOP_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
name|strcat
argument_list|(
name|buf
argument_list|,
name|AS2
argument_list|(
name|p
argument_list|,
operator|%
literal|0
argument_list|,
operator|%
literal|2
argument_list|)
argument_list|)
return|;
else|else
return|return
name|strcat
argument_list|(
name|buf
argument_list|,
name|AS2
argument_list|(
name|rp
argument_list|,
operator|%
literal|2
argument_list|,
operator|%
literal|0
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|STACK_TOP_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
name|strcat
argument_list|(
name|buf
argument_list|,
name|AS2
argument_list|(
name|rp
argument_list|,
operator|%
literal|0
argument_list|,
operator|%
literal|1
argument_list|)
argument_list|)
return|;
else|else
return|return
name|strcat
argument_list|(
name|buf
argument_list|,
name|AS2
argument_list|(
name|p
argument_list|,
operator|%
literal|1
argument_list|,
operator|%
literal|0
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|STACK_TOP_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|STACK_TOP_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
return|return
name|strcat
argument_list|(
name|buf
argument_list|,
name|AS2C
argument_list|(
operator|%
name|y2
argument_list|,
operator|%
literal|0
argument_list|)
argument_list|)
return|;
else|else
return|return
name|strcat
argument_list|(
name|buf
argument_list|,
name|AS2
argument_list|(
name|r
argument_list|,
operator|%
name|y1
argument_list|,
operator|%
literal|0
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|STACK_TOP_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
return|return
name|strcat
argument_list|(
name|buf
argument_list|,
name|AS2C
argument_list|(
operator|%
literal|1
argument_list|,
operator|%
literal|0
argument_list|)
argument_list|)
return|;
else|else
return|return
name|strcat
argument_list|(
name|buf
argument_list|,
name|AS2
argument_list|(
name|r
argument_list|,
operator|%
literal|2
argument_list|,
operator|%
literal|0
argument_list|)
argument_list|)
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output code for INSN to convert a float to a signed int.  OPERANDS    are the insn operands.  The input may be SFmode, DFmode, or XFmode    and the output operand may be SImode or DImode.  As a special case,    make sure that the 387 stack top dies if the output mode is DImode,    because the hardware requires this.  */
end_comment

begin_function
name|char
modifier|*
name|output_fix_trunc
parameter_list|(
name|insn
parameter_list|,
name|operands
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
name|int
name|stack_top_dies
init|=
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|FIRST_STACK_REG
argument_list|)
operator|!=
literal|0
decl_stmt|;
name|rtx
name|xops
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|STACK_TOP_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|DImode
operator|&&
operator|!
name|stack_top_dies
condition|)
name|abort
argument_list|()
expr_stmt|;
name|xops
index|[
literal|0
index|]
operator|=
name|GEN_INT
argument_list|(
literal|0x0c00
argument_list|)
expr_stmt|;
name|xops
index|[
literal|1
index|]
operator|=
name|operands
index|[
literal|5
index|]
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS1
argument_list|(
name|fnstc
operator|%
name|W2
argument_list|,
operator|%
literal|2
argument_list|)
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|mov
operator|%
name|W5
argument_list|,
operator|%
literal|2
argument_list|,
operator|%
name|w5
argument_list|)
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|or
operator|%
name|W1
argument_list|,
operator|%
literal|0
argument_list|,
operator|%
name|w1
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|mov
operator|%
name|W3
argument_list|,
operator|%
name|w5
argument_list|,
operator|%
literal|3
argument_list|)
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS1
argument_list|(
name|fldc
operator|%
name|W3
argument_list|,
operator|%
literal|3
argument_list|)
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|xops
index|[
literal|0
index|]
operator|=
name|NON_STACK_REG_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|?
name|operands
index|[
literal|4
index|]
else|:
name|operands
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|stack_top_dies
condition|)
name|output_asm_insn
argument_list|(
name|AS1
argument_list|(
name|fistp
operator|%
name|z0
argument_list|,
operator|%
name|y0
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
else|else
name|output_asm_insn
argument_list|(
name|AS1
argument_list|(
name|fist
operator|%
name|z0
argument_list|,
operator|%
name|y0
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
if|if
condition|(
name|NON_STACK_REG_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|SImode
condition|)
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|mov
operator|%
name|L0
argument_list|,
operator|%
literal|4
argument_list|,
operator|%
literal|0
argument_list|)
argument_list|,
name|operands
argument_list|)
expr_stmt|;
else|else
block|{
name|xops
index|[
literal|0
index|]
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
name|xops
index|[
literal|1
index|]
operator|=
name|operands
index|[
literal|4
index|]
expr_stmt|;
name|output_asm_insn
argument_list|(
name|output_move_double
argument_list|(
name|xops
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|AS1
argument_list|(
name|fldc
operator|%
name|W2
argument_list|,
operator|%
literal|2
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output code for INSN to extend a float.  OPERANDS are the insn    operands.  The output may be DFmode or XFmode and the input operand    may be SFmode or DFmode.  Operands 2 and 3 are scratch memory and    are only necessary if operands 0 or 1 are non-stack registers.  */
end_comment

begin_function
name|void
name|output_float_extend
parameter_list|(
name|insn
parameter_list|,
name|operands
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
name|int
name|stack_top_dies
init|=
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|FIRST_STACK_REG
argument_list|)
operator|!=
literal|0
decl_stmt|;
name|rtx
name|xops
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|STACK_TOP_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|&&
operator|!
name|STACK_TOP_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|STACK_TOP_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|&&
name|STACK_TOP_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|&&
name|stack_top_dies
condition|)
return|return;
if|if
condition|(
name|STACK_TOP_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|NON_STACK_REG_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|SFmode
condition|)
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|mov
operator|%
name|L0
argument_list|,
operator|%
literal|1
argument_list|,
operator|%
literal|2
argument_list|)
argument_list|,
name|operands
argument_list|)
expr_stmt|;
else|else
block|{
name|xops
index|[
literal|0
index|]
operator|=
name|operands
index|[
literal|2
index|]
expr_stmt|;
name|xops
index|[
literal|1
index|]
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
name|output_asm_insn
argument_list|(
name|output_move_double
argument_list|(
name|xops
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
block|}
block|}
name|xops
index|[
literal|0
index|]
operator|=
name|NON_STACK_REG_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|?
name|operands
index|[
literal|2
index|]
else|:
name|operands
index|[
literal|1
index|]
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS1
argument_list|(
name|fld
operator|%
name|z0
argument_list|,
operator|%
name|y0
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xops
index|[
literal|0
index|]
operator|=
name|NON_STACK_REG_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|?
name|operands
index|[
literal|3
index|]
else|:
name|operands
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|stack_top_dies
operator|||
operator|(
name|GET_CODE
argument_list|(
name|xops
index|[
literal|0
index|]
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_MODE
argument_list|(
name|xops
index|[
literal|0
index|]
argument_list|)
operator|==
name|XFmode
operator|)
condition|)
block|{
name|output_asm_insn
argument_list|(
name|AS1
argument_list|(
name|fstp
operator|%
name|z0
argument_list|,
operator|%
name|y0
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stack_top_dies
condition|)
name|output_asm_insn
argument_list|(
name|AS1
argument_list|(
name|fld
operator|%
name|z0
argument_list|,
operator|%
name|y0
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
block|}
else|else
name|output_asm_insn
argument_list|(
name|AS1
argument_list|(
name|fst
operator|%
name|z0
argument_list|,
operator|%
name|y0
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
if|if
condition|(
name|NON_STACK_REG_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|xops
index|[
literal|0
index|]
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
name|xops
index|[
literal|1
index|]
operator|=
name|operands
index|[
literal|3
index|]
expr_stmt|;
name|output_asm_insn
argument_list|(
name|output_move_double
argument_list|(
name|xops
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output code for INSN to compare OPERANDS.  The two operands might    not have the same mode: one might be within a FLOAT or FLOAT_EXTEND    expression.  If the compare is in mode CCFPEQmode, use an opcode that    will not fault if a qNaN is present. */
end_comment

begin_function
name|char
modifier|*
name|output_float_compare
parameter_list|(
name|insn
parameter_list|,
name|operands
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
name|int
name|stack_top_dies
decl_stmt|;
name|rtx
name|body
init|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|unordered_compare
init|=
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|CCFPEQmode
decl_stmt|;
name|rtx
name|tmp
decl_stmt|;
name|int
name|cc0_set
init|=
literal|1
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|TARGET_CMOVE
operator|&&
name|STACK_REG_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|&&
name|STACK_REG_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|cc_status
operator|.
name|flags
operator||=
name|CC_FCOMI
expr_stmt|;
name|cc_prev_status
operator|.
name|flags
operator|&=
operator|~
name|CC_TEST_AX
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|STACK_TOP_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|tmp
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
name|operands
index|[
literal|0
index|]
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|tmp
expr_stmt|;
name|cc_status
operator|.
name|flags
operator||=
name|CC_REVERSED
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|STACK_TOP_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|stack_top_dies
operator|=
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|FIRST_STACK_REG
argument_list|)
operator|!=
literal|0
expr_stmt|;
if|if
condition|(
name|STACK_REG_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|&&
name|stack_top_dies
operator|&&
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|FIRST_STACK_REG
operator|+
literal|1
condition|)
block|{
comment|/* If both the top of the 387 stack dies, and the other operand 	 is also a stack register that dies, then this must be a 	 `fcompp' float compare */
if|if
condition|(
name|unordered_compare
condition|)
block|{
if|if
condition|(
name|cc_status
operator|.
name|flags
operator|&
name|CC_FCOMI
condition|)
block|{
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|fucomip
argument_list|,
operator|%
name|y1
argument_list|,
operator|%
literal|0
argument_list|)
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS1
argument_list|(
name|fstp
argument_list|,
operator|%
name|y0
argument_list|)
argument_list|,
name|operands
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TARGET_IEEE_FP
condition|)
name|cc0_set
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|output_asm_insn
argument_list|(
literal|"fucompp"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|cc_status
operator|.
name|flags
operator|&
name|CC_FCOMI
condition|)
block|{
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|fcomip
argument_list|,
operator|%
name|y1
argument_list|,
operator|%
literal|0
argument_list|)
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS1
argument_list|(
name|fstp
argument_list|,
operator|%
name|y0
argument_list|)
argument_list|,
name|operands
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TARGET_IEEE_FP
condition|)
name|cc0_set
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|output_asm_insn
argument_list|(
literal|"fcompp"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
specifier|static
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
comment|/* Decide if this is a float compare or an unordered float compare. */
if|if
condition|(
name|unordered_compare
condition|)
name|strcpy
argument_list|(
name|buf
argument_list|,
operator|(
name|cc_status
operator|.
name|flags
operator|&
name|CC_FCOMI
operator|)
condition|?
literal|"fucomi"
else|:
literal|"fucom"
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|buf
argument_list|,
operator|(
name|cc_status
operator|.
name|flags
operator|&
name|CC_FCOMI
operator|)
condition|?
literal|"fcomi"
else|:
literal|"fcom"
argument_list|)
expr_stmt|;
comment|/* Modify the opcode if the 387 stack is to be popped. */
if|if
condition|(
name|stack_top_dies
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"p"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc_status
operator|.
name|flags
operator|&
name|CC_FCOMI
condition|)
block|{
name|output_asm_insn
argument_list|(
name|strcat
argument_list|(
name|buf
argument_list|,
name|AS2
argument_list|(
operator|%
name|z1
argument_list|,
operator|%
name|y1
argument_list|,
operator|%
literal|0
argument_list|)
argument_list|)
argument_list|,
name|operands
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TARGET_IEEE_FP
condition|)
name|cc0_set
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|output_asm_insn
argument_list|(
name|strcat
argument_list|(
name|buf
argument_list|,
name|AS1
argument_list|(
operator|%
name|z1
argument_list|,
operator|%
name|y1
argument_list|)
argument_list|)
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
comment|/* Now retrieve the condition code. */
if|if
condition|(
name|cc0_set
condition|)
block|{
name|char
modifier|*
name|r
init|=
name|output_fp_cc0_set
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
index|[
literal|0
index|]
condition|)
name|output_asm_insn
argument_list|(
name|r
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
comment|/* We emit fstp instruction after integer comparsions to improve      scheduling. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|STACK_REG_P
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|)
operator|&&
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|)
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|)
operator|!=
name|FIRST_STACK_REG
operator|&&
operator|(
operator|!
name|stack_top_dies
operator|||
name|REGNO
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|)
operator|!=
name|FIRST_STACK_REG
operator|+
literal|1
operator|)
condition|)
block|{
name|rtx
name|xexp
index|[
literal|2
index|]
decl_stmt|;
name|xexp
index|[
literal|0
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|DFmode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|)
operator|-
operator|(
name|stack_top_dies
operator|!=
literal|0
operator|)
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS1
argument_list|(
name|fstp
argument_list|,
operator|%
name|y0
argument_list|)
argument_list|,
name|xexp
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|""
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output opcodes to transfer the results of FP compare or test INSN    from the FPU to the CPU flags.  If TARGET_IEEE_FP, ensure that if the    result of the compare or test is unordered, no comparison operator    succeeds except NE.  Return an output template, if any.  */
end_comment

begin_function
name|char
modifier|*
name|output_fp_cc0_set
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|xops
index|[
literal|3
index|]
decl_stmt|;
name|rtx
name|next
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|cc_status
operator|.
name|flags
operator|&
name|CC_FCOMI
operator|)
condition|)
block|{
name|xops
index|[
literal|0
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|HImode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS1
argument_list|(
name|fnsts
operator|%
name|W0
argument_list|,
operator|%
literal|0
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TARGET_IEEE_FP
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|cc_status
operator|.
name|flags
operator|&
name|CC_REVERSED
operator|)
condition|)
block|{
name|next
operator|=
name|next_cc0_user
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|)
operator|==
name|pc_rtx
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|)
argument_list|)
operator|==
name|IF_THEN_ELSE
condition|)
name|code
operator|=
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
name|code
operator|=
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
return|return
literal|"sahf"
return|;
if|if
condition|(
name|code
operator|==
name|GT
operator|||
name|code
operator|==
name|LT
operator|||
name|code
operator|==
name|EQ
operator|||
name|code
operator|==
name|NE
operator|||
name|code
operator|==
name|LE
operator|||
name|code
operator|==
name|GE
condition|)
block|{
comment|/* We will test eax directly. */
name|cc_status
operator|.
name|flags
operator||=
name|CC_TEST_AX
expr_stmt|;
return|return
literal|""
return|;
block|}
block|}
return|return
literal|"sahf"
return|;
block|}
name|next
operator|=
name|next_cc0_user
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|==
name|NULL_RTX
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|)
operator|==
name|pc_rtx
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|)
argument_list|)
operator|==
name|IF_THEN_ELSE
condition|)
name|code
operator|=
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|)
argument_list|)
operator|==
name|IF_THEN_ELSE
condition|)
name|code
operator|=
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|code
operator|=
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|IF_THEN_ELSE
condition|)
name|code
operator|=
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|code
operator|=
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|cc_status
operator|.
name|flags
operator|&
name|CC_FCOMI
condition|)
block|{
comment|/* It is very tricky. We have to do it right. */
name|xops
index|[
literal|0
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|QImode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|GT
case|:
case|case
name|GE
case|:
break|break;
case|case
name|LT
case|:
name|output_asm_insn
argument_list|(
name|AS1
argument_list|(
name|setb
argument_list|,
operator|%
name|b0
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS1
argument_list|(
name|setp
argument_list|,
operator|%
name|h0
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|cmp
operator|%
name|B0
argument_list|,
operator|%
name|b0
argument_list|,
operator|%
name|h0
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
break|break;
case|case
name|LE
case|:
name|output_asm_insn
argument_list|(
name|AS1
argument_list|(
name|setbe
argument_list|,
operator|%
name|b0
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS1
argument_list|(
name|setnp
argument_list|,
operator|%
name|h0
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|xor
operator|%
name|B0
argument_list|,
operator|%
name|b0
argument_list|,
operator|%
name|h0
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
break|break;
case|case
name|EQ
case|:
case|case
name|NE
case|:
name|output_asm_insn
argument_list|(
name|AS1
argument_list|(
name|setne
argument_list|,
operator|%
name|b0
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS1
argument_list|(
name|setp
argument_list|,
operator|%
name|h0
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|or
operator|%
name|B0
argument_list|,
operator|%
name|b0
argument_list|,
operator|%
name|h0
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
break|break;
case|case
name|GTU
case|:
case|case
name|LTU
case|:
case|case
name|GEU
case|:
case|case
name|LEU
case|:
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|xops
index|[
literal|0
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|QImode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|GT
case|:
name|xops
index|[
literal|1
index|]
operator|=
name|GEN_INT
argument_list|(
literal|0x45
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|and
operator|%
name|B0
argument_list|,
operator|%
literal|1
argument_list|,
operator|%
name|h0
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
comment|/* je label */
break|break;
case|case
name|LT
case|:
name|xops
index|[
literal|1
index|]
operator|=
name|GEN_INT
argument_list|(
literal|0x45
argument_list|)
expr_stmt|;
name|xops
index|[
literal|2
index|]
operator|=
name|GEN_INT
argument_list|(
literal|0x01
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|and
operator|%
name|B0
argument_list|,
operator|%
literal|1
argument_list|,
operator|%
name|h0
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|cmp
operator|%
name|B0
argument_list|,
operator|%
literal|2
argument_list|,
operator|%
name|h0
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
comment|/* je label */
break|break;
case|case
name|GE
case|:
name|xops
index|[
literal|1
index|]
operator|=
name|GEN_INT
argument_list|(
literal|0x05
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|and
operator|%
name|B0
argument_list|,
operator|%
literal|1
argument_list|,
operator|%
name|h0
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
comment|/* je label */
break|break;
case|case
name|LE
case|:
name|xops
index|[
literal|1
index|]
operator|=
name|GEN_INT
argument_list|(
literal|0x45
argument_list|)
expr_stmt|;
name|xops
index|[
literal|2
index|]
operator|=
name|GEN_INT
argument_list|(
literal|0x40
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|and
operator|%
name|B0
argument_list|,
operator|%
literal|1
argument_list|,
operator|%
name|h0
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS1
argument_list|(
name|dec
operator|%
name|B0
argument_list|,
operator|%
name|h0
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|cmp
operator|%
name|B0
argument_list|,
operator|%
literal|2
argument_list|,
operator|%
name|h0
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
comment|/* jb label */
break|break;
case|case
name|EQ
case|:
name|xops
index|[
literal|1
index|]
operator|=
name|GEN_INT
argument_list|(
literal|0x45
argument_list|)
expr_stmt|;
name|xops
index|[
literal|2
index|]
operator|=
name|GEN_INT
argument_list|(
literal|0x40
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|and
operator|%
name|B0
argument_list|,
operator|%
literal|1
argument_list|,
operator|%
name|h0
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|cmp
operator|%
name|B0
argument_list|,
operator|%
literal|2
argument_list|,
operator|%
name|h0
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
comment|/* je label */
break|break;
case|case
name|NE
case|:
name|xops
index|[
literal|1
index|]
operator|=
name|GEN_INT
argument_list|(
literal|0x44
argument_list|)
expr_stmt|;
name|xops
index|[
literal|2
index|]
operator|=
name|GEN_INT
argument_list|(
literal|0x40
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|and
operator|%
name|B0
argument_list|,
operator|%
literal|1
argument_list|,
operator|%
name|h0
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|xor
operator|%
name|B0
argument_list|,
operator|%
literal|2
argument_list|,
operator|%
name|h0
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
comment|/* jne label */
break|break;
case|case
name|GTU
case|:
case|case
name|LTU
case|:
case|case
name|GEU
case|:
case|case
name|LEU
case|:
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
return|return
literal|""
return|;
block|}
end_function

begin_escape
end_escape

begin_define
define|#
directive|define
name|MAX_386_STACK_LOCALS
value|2
end_define

begin_decl_stmt
specifier|static
name|rtx
name|i386_stack_locals
index|[
operator|(
name|int
operator|)
name|MAX_MACHINE_MODE
index|]
index|[
name|MAX_386_STACK_LOCALS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Define the structure for the machine field in struct function.  */
end_comment

begin_struct
struct|struct
name|machine_function
block|{
name|rtx
name|i386_stack_locals
index|[
operator|(
name|int
operator|)
name|MAX_MACHINE_MODE
index|]
index|[
name|MAX_386_STACK_LOCALS
index|]
decl_stmt|;
name|rtx
name|pic_label_rtx
decl_stmt|;
name|char
name|pic_label_name
index|[
literal|256
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Functions to save and restore i386_stack_locals.    These will be called, via pointer variables,    from push_function_context and pop_function_context.  */
end_comment

begin_function
name|void
name|save_386_machine_status
parameter_list|(
name|p
parameter_list|)
name|struct
name|function
modifier|*
name|p
decl_stmt|;
block|{
name|p
operator|->
name|machine
operator|=
operator|(
expr|struct
name|machine_function
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|machine_function
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|i386_stack_locals
argument_list|,
operator|(
name|char
operator|*
operator|)
name|p
operator|->
name|machine
operator|->
name|i386_stack_locals
argument_list|,
sizeof|sizeof
name|i386_stack_locals
argument_list|)
expr_stmt|;
name|p
operator|->
name|machine
operator|->
name|pic_label_rtx
operator|=
name|pic_label_rtx
expr_stmt|;
name|bcopy
argument_list|(
name|pic_label_name
argument_list|,
name|p
operator|->
name|machine
operator|->
name|pic_label_name
argument_list|,
literal|256
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|restore_386_machine_status
parameter_list|(
name|p
parameter_list|)
name|struct
name|function
modifier|*
name|p
decl_stmt|;
block|{
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
operator|->
name|machine
operator|->
name|i386_stack_locals
argument_list|,
operator|(
name|char
operator|*
operator|)
name|i386_stack_locals
argument_list|,
sizeof|sizeof
name|i386_stack_locals
argument_list|)
expr_stmt|;
name|pic_label_rtx
operator|=
name|p
operator|->
name|machine
operator|->
name|pic_label_rtx
expr_stmt|;
name|bcopy
argument_list|(
name|p
operator|->
name|machine
operator|->
name|pic_label_name
argument_list|,
name|pic_label_name
argument_list|,
literal|256
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
operator|->
name|machine
argument_list|)
expr_stmt|;
name|p
operator|->
name|machine
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clear stack slot assignments remembered from previous functions.    This is called from INIT_EXPANDERS once before RTL is emitted for each    function.  */
end_comment

begin_function
name|void
name|clear_386_stack_locals
parameter_list|()
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|n
decl_stmt|;
for|for
control|(
name|mode
operator|=
name|VOIDmode
init|;
operator|(
name|int
operator|)
name|mode
operator|<
operator|(
name|int
operator|)
name|MAX_MACHINE_MODE
condition|;
name|mode
operator|=
operator|(
expr|enum
name|machine_mode
operator|)
operator|(
operator|(
name|int
operator|)
name|mode
operator|+
literal|1
operator|)
control|)
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|MAX_386_STACK_LOCALS
condition|;
name|n
operator|++
control|)
name|i386_stack_locals
index|[
operator|(
name|int
operator|)
name|mode
index|]
index|[
name|n
index|]
operator|=
name|NULL_RTX
expr_stmt|;
name|pic_label_rtx
operator|=
name|NULL_RTX
expr_stmt|;
name|bzero
argument_list|(
name|pic_label_name
argument_list|,
literal|256
argument_list|)
expr_stmt|;
comment|/* Arrange to save and restore i386_stack_locals around nested functions.  */
name|save_machine_status
operator|=
name|save_386_machine_status
expr_stmt|;
name|restore_machine_status
operator|=
name|restore_386_machine_status
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a MEM corresponding to a stack slot with mode MODE.    Allocate a new slot if necessary.     The RTL for a function can have several slots available: N is    which slot to use.  */
end_comment

begin_function
name|rtx
name|assign_386_stack_local
parameter_list|(
name|mode
parameter_list|,
name|n
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
if|if
condition|(
name|n
operator|<
literal|0
operator|||
name|n
operator|>=
name|MAX_386_STACK_LOCALS
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|i386_stack_locals
index|[
operator|(
name|int
operator|)
name|mode
index|]
index|[
name|n
index|]
operator|==
name|NULL_RTX
condition|)
name|i386_stack_locals
index|[
operator|(
name|int
operator|)
name|mode
index|]
index|[
name|n
index|]
operator|=
name|assign_stack_local
argument_list|(
name|mode
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|i386_stack_locals
index|[
operator|(
name|int
operator|)
name|mode
index|]
index|[
name|n
index|]
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|int
name|is_mul
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MULT
operator|)
return|;
block|}
end_function

begin_function
name|int
name|is_div
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|DIV
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|NOTYET
end_ifdef

begin_comment
comment|/* Create a new copy of an rtx.    Recursively copies the operands of the rtx,    except for those few rtx codes that are sharable.    Doesn't share CONST  */
end_comment

begin_function
name|rtx
name|copy_all_rtx
parameter_list|(
name|orig
parameter_list|)
specifier|register
name|rtx
name|orig
decl_stmt|;
block|{
specifier|register
name|rtx
name|copy
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|RTX_CODE
name|code
decl_stmt|;
specifier|register
name|char
modifier|*
name|format_ptr
decl_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|orig
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
case|case
name|QUEUED
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CODE_LABEL
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|SCRATCH
case|:
comment|/* SCRATCH must be shared because they represent distinct values. */
return|return
name|orig
return|;
if|#
directive|if
literal|0
block|case CONST:
comment|/* CONST can be shared if it contains a SYMBOL_REF.  If it contains 	 a LABEL_REF, it isn't sharable.  */
block|if (GET_CODE (XEXP (orig, 0)) == PLUS&& GET_CODE (XEXP (XEXP (orig, 0), 0)) == SYMBOL_REF&& GET_CODE (XEXP (XEXP (orig, 0), 1)) == CONST_INT) 	return orig;       break;
endif|#
directive|endif
comment|/* A MEM with a constant address is not sharable.  The problem is that 	 the constant address may need to be reloaded.  If the mem is shared, 	 then reloading one copy of this mem will cause all copies to appear 	 to have been reloaded.  */
block|}
name|copy
operator|=
name|rtx_alloc
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|copy
argument_list|,
name|GET_MODE
argument_list|(
name|orig
argument_list|)
argument_list|)
expr_stmt|;
name|copy
operator|->
name|in_struct
operator|=
name|orig
operator|->
name|in_struct
expr_stmt|;
name|copy
operator|->
name|volatil
operator|=
name|orig
operator|->
name|volatil
expr_stmt|;
name|copy
operator|->
name|unchanging
operator|=
name|orig
operator|->
name|unchanging
expr_stmt|;
name|copy
operator|->
name|integrated
operator|=
name|orig
operator|->
name|integrated
expr_stmt|;
comment|/* intel1 */
name|copy
operator|->
name|is_spill_rtx
operator|=
name|orig
operator|->
name|is_spill_rtx
expr_stmt|;
name|format_ptr
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|copy
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|copy
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|format_ptr
operator|++
condition|)
block|{
case|case
literal|'e'
case|:
name|XEXP
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|XEXP
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|XEXP
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
operator|!=
name|NULL
condition|)
name|XEXP
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|copy_rtx
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'u'
case|:
name|XEXP
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|XEXP
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
case|case
literal|'V'
case|:
name|XVEC
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|XVEC
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|XVEC
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|XVEC
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|rtvec_alloc
argument_list|(
name|XVECLEN
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|XVECEXP
argument_list|(
name|copy
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
operator|=
name|copy_rtx
argument_list|(
name|XVECEXP
argument_list|(
name|orig
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'w'
case|:
name|XWINT
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|XWINT
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|XINT
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|XINT
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
name|XSTR
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|XSTR
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|copy
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Try to rewrite a memory address to make it valid */
end_comment

begin_function
name|void
name|rewrite_address
parameter_list|(
name|mem_rtx
parameter_list|)
name|rtx
name|mem_rtx
decl_stmt|;
block|{
name|rtx
name|index_rtx
decl_stmt|,
name|base_rtx
decl_stmt|,
name|offset_rtx
decl_stmt|,
name|scale_rtx
decl_stmt|,
name|ret_rtx
decl_stmt|;
name|int
name|scale
init|=
literal|1
decl_stmt|;
name|int
name|offset_adjust
init|=
literal|0
decl_stmt|;
name|int
name|was_only_offset
init|=
literal|0
decl_stmt|;
name|rtx
name|mem_addr
init|=
name|XEXP
argument_list|(
name|mem_rtx
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|char
modifier|*
name|storage
init|=
name|oballoc
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|int
name|in_struct
init|=
literal|0
decl_stmt|;
name|int
name|is_spill_rtx
init|=
literal|0
decl_stmt|;
name|in_struct
operator|=
name|MEM_IN_STRUCT_P
argument_list|(
name|mem_rtx
argument_list|)
expr_stmt|;
name|is_spill_rtx
operator|=
name|RTX_IS_SPILL_P
argument_list|(
name|mem_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|mem_addr
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|mem_addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|mem_addr
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
comment|/* This part is utilized by the combiner. */
name|ret_rtx
operator|=
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|GET_MODE
argument_list|(
name|mem_addr
argument_list|)
argument_list|,
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|mem_addr
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|mem_addr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|mem_addr
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|mem_addr
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|memory_address_p
argument_list|(
name|GET_MODE
argument_list|(
name|mem_rtx
argument_list|)
argument_list|,
name|ret_rtx
argument_list|)
condition|)
block|{
name|XEXP
argument_list|(
name|mem_rtx
argument_list|,
literal|0
argument_list|)
operator|=
name|ret_rtx
expr_stmt|;
name|RTX_IS_SPILL_P
argument_list|(
name|ret_rtx
argument_list|)
operator|=
name|is_spill_rtx
expr_stmt|;
return|return;
block|}
name|obfree
argument_list|(
name|storage
argument_list|)
expr_stmt|;
block|}
comment|/* This part is utilized by loop.c.      If the address contains PLUS (reg,const) and this pattern is invalid      in this case - try to rewrite the address to make it valid. */
name|storage
operator|=
name|oballoc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|index_rtx
operator|=
name|base_rtx
operator|=
name|offset_rtx
operator|=
name|NULL
expr_stmt|;
comment|/* Find the base index and offset elements of the memory address. */
if|if
condition|(
name|GET_CODE
argument_list|(
name|mem_addr
argument_list|)
operator|==
name|PLUS
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|mem_addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|mem_addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|base_rtx
operator|=
name|XEXP
argument_list|(
name|mem_addr
argument_list|,
literal|1
argument_list|)
operator|,
name|index_rtx
operator|=
name|XEXP
argument_list|(
name|mem_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|base_rtx
operator|=
name|XEXP
argument_list|(
name|mem_addr
argument_list|,
literal|0
argument_list|)
operator|,
name|offset_rtx
operator|=
name|XEXP
argument_list|(
name|mem_addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|mem_addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MULT
condition|)
block|{
name|index_rtx
operator|=
name|XEXP
argument_list|(
name|mem_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|mem_addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|base_rtx
operator|=
name|XEXP
argument_list|(
name|mem_addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|offset_rtx
operator|=
name|XEXP
argument_list|(
name|mem_addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|mem_addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|mem_addr
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|mem_addr
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MULT
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|mem_addr
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|mem_addr
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|mem_addr
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|mem_addr
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|mem_addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
block|{
name|index_rtx
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|mem_addr
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|offset_rtx
operator|=
name|XEXP
argument_list|(
name|mem_addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|base_rtx
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|mem_addr
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|offset_adjust
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|mem_addr
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|offset_rtx
operator|=
name|XEXP
argument_list|(
name|mem_addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|index_rtx
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|mem_addr
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|base_rtx
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|mem_addr
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|mem_addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|was_only_offset
operator|=
literal|1
expr_stmt|;
name|index_rtx
operator|=
name|NULL
expr_stmt|;
name|base_rtx
operator|=
name|NULL
expr_stmt|;
name|offset_rtx
operator|=
name|XEXP
argument_list|(
name|mem_addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|offset_adjust
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|mem_addr
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset_adjust
operator|==
literal|0
condition|)
block|{
name|XEXP
argument_list|(
name|mem_rtx
argument_list|,
literal|0
argument_list|)
operator|=
name|offset_rtx
expr_stmt|;
name|RTX_IS_SPILL_P
argument_list|(
name|XEXP
argument_list|(
name|mem_rtx
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
name|is_spill_rtx
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|obfree
argument_list|(
name|storage
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|mem_addr
argument_list|)
operator|==
name|MULT
condition|)
name|index_rtx
operator|=
name|mem_addr
expr_stmt|;
else|else
block|{
name|obfree
argument_list|(
name|storage
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|index_rtx
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|index_rtx
argument_list|)
operator|==
name|MULT
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|index_rtx
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
block|{
name|obfree
argument_list|(
name|storage
argument_list|)
expr_stmt|;
return|return;
block|}
name|scale_rtx
operator|=
name|XEXP
argument_list|(
name|index_rtx
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|scale
operator|=
name|INTVAL
argument_list|(
name|scale_rtx
argument_list|)
expr_stmt|;
name|index_rtx
operator|=
name|copy_all_rtx
argument_list|(
name|XEXP
argument_list|(
name|index_rtx
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Now find which of the elements are invalid and try to fix them. */
if|if
condition|(
name|index_rtx
operator|&&
name|GET_CODE
argument_list|(
name|index_rtx
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|base_rtx
operator|==
name|NULL
condition|)
block|{
name|offset_adjust
operator|=
name|INTVAL
argument_list|(
name|index_rtx
argument_list|)
operator|*
name|scale
expr_stmt|;
if|if
condition|(
name|offset_rtx
operator|!=
literal|0
operator|&&
name|CONSTANT_P
argument_list|(
name|offset_rtx
argument_list|)
condition|)
name|offset_rtx
operator|=
name|plus_constant
argument_list|(
name|offset_rtx
argument_list|,
name|offset_adjust
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|offset_rtx
operator|==
literal|0
condition|)
name|offset_rtx
operator|=
name|const0_rtx
expr_stmt|;
name|RTX_IS_SPILL_P
argument_list|(
name|XEXP
argument_list|(
name|mem_rtx
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
name|is_spill_rtx
expr_stmt|;
name|XEXP
argument_list|(
name|mem_rtx
argument_list|,
literal|0
argument_list|)
operator|=
name|offset_rtx
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|base_rtx
operator|&&
name|GET_CODE
argument_list|(
name|base_rtx
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|base_rtx
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|base_rtx
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|offset_adjust
operator|+=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|base_rtx
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|base_rtx
operator|=
name|copy_all_rtx
argument_list|(
name|XEXP
argument_list|(
name|base_rtx
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|base_rtx
operator|&&
name|GET_CODE
argument_list|(
name|base_rtx
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|offset_adjust
operator|+=
name|INTVAL
argument_list|(
name|base_rtx
argument_list|)
expr_stmt|;
name|base_rtx
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|index_rtx
operator|&&
name|GET_CODE
argument_list|(
name|index_rtx
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|index_rtx
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|index_rtx
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|offset_adjust
operator|+=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|index_rtx
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|*
name|scale
expr_stmt|;
name|index_rtx
operator|=
name|copy_all_rtx
argument_list|(
name|XEXP
argument_list|(
name|index_rtx
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|index_rtx
condition|)
block|{
if|if
condition|(
operator|!
name|LEGITIMATE_INDEX_P
argument_list|(
name|index_rtx
argument_list|)
operator|&&
operator|!
operator|(
name|index_rtx
operator|==
name|stack_pointer_rtx
operator|&&
name|scale
operator|==
literal|1
operator|&&
name|base_rtx
operator|==
name|NULL
operator|)
condition|)
block|{
name|obfree
argument_list|(
name|storage
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|base_rtx
condition|)
block|{
if|if
condition|(
operator|!
name|LEGITIMATE_INDEX_P
argument_list|(
name|base_rtx
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|base_rtx
argument_list|)
operator|!=
name|REG
condition|)
block|{
name|obfree
argument_list|(
name|storage
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|offset_adjust
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|offset_rtx
operator|!=
literal|0
operator|&&
name|CONSTANT_P
argument_list|(
name|offset_rtx
argument_list|)
condition|)
name|offset_rtx
operator|=
name|plus_constant
argument_list|(
name|offset_rtx
argument_list|,
name|offset_adjust
argument_list|)
expr_stmt|;
else|else
name|offset_rtx
operator|=
name|const0_rtx
expr_stmt|;
if|if
condition|(
name|index_rtx
condition|)
block|{
if|if
condition|(
name|base_rtx
condition|)
block|{
if|if
condition|(
name|scale
operator|!=
literal|1
condition|)
block|{
name|ret_rtx
operator|=
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|GET_MODE
argument_list|(
name|base_rtx
argument_list|)
argument_list|,
name|gen_rtx
argument_list|(
name|MULT
argument_list|,
name|GET_MODE
argument_list|(
name|index_rtx
argument_list|)
argument_list|,
name|index_rtx
argument_list|,
name|scale_rtx
argument_list|)
argument_list|,
name|base_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|offset_rtx
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|INTVAL
argument_list|(
name|offset_rtx
argument_list|)
operator|!=
literal|0
condition|)
name|ret_rtx
operator|=
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|GET_MODE
argument_list|(
name|ret_rtx
argument_list|)
argument_list|,
name|ret_rtx
argument_list|,
name|offset_rtx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret_rtx
operator|=
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|GET_MODE
argument_list|(
name|index_rtx
argument_list|)
argument_list|,
name|index_rtx
argument_list|,
name|base_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|offset_rtx
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|INTVAL
argument_list|(
name|offset_rtx
argument_list|)
operator|!=
literal|0
condition|)
name|ret_rtx
operator|=
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|GET_MODE
argument_list|(
name|ret_rtx
argument_list|)
argument_list|,
name|ret_rtx
argument_list|,
name|offset_rtx
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|scale
operator|!=
literal|1
condition|)
block|{
name|ret_rtx
operator|=
name|gen_rtx
argument_list|(
name|MULT
argument_list|,
name|GET_MODE
argument_list|(
name|index_rtx
argument_list|)
argument_list|,
name|index_rtx
argument_list|,
name|scale_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|offset_rtx
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|INTVAL
argument_list|(
name|offset_rtx
argument_list|)
operator|!=
literal|0
condition|)
name|ret_rtx
operator|=
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|GET_MODE
argument_list|(
name|ret_rtx
argument_list|)
argument_list|,
name|ret_rtx
argument_list|,
name|offset_rtx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|offset_rtx
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|offset_rtx
argument_list|)
operator|==
literal|0
condition|)
name|ret_rtx
operator|=
name|index_rtx
expr_stmt|;
else|else
name|ret_rtx
operator|=
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|GET_MODE
argument_list|(
name|index_rtx
argument_list|)
argument_list|,
name|index_rtx
argument_list|,
name|offset_rtx
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|base_rtx
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|offset_rtx
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|offset_rtx
argument_list|)
operator|==
literal|0
condition|)
name|ret_rtx
operator|=
name|base_rtx
expr_stmt|;
else|else
name|ret_rtx
operator|=
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|GET_MODE
argument_list|(
name|base_rtx
argument_list|)
argument_list|,
name|base_rtx
argument_list|,
name|offset_rtx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|was_only_offset
condition|)
name|ret_rtx
operator|=
name|offset_rtx
expr_stmt|;
else|else
block|{
name|obfree
argument_list|(
name|storage
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|XEXP
argument_list|(
name|mem_rtx
argument_list|,
literal|0
argument_list|)
operator|=
name|ret_rtx
expr_stmt|;
name|RTX_IS_SPILL_P
argument_list|(
name|XEXP
argument_list|(
name|mem_rtx
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
name|is_spill_rtx
expr_stmt|;
return|return;
block|}
else|else
block|{
name|obfree
argument_list|(
name|storage
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOTYET */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Return 1 if the first insn to set cc before INSN also sets the register    REG_RTX; otherwise return 0. */
end_comment

begin_function
name|int
name|last_to_set_cc
parameter_list|(
name|reg_rtx
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|reg_rtx
decl_stmt|,
name|insn
decl_stmt|;
block|{
name|rtx
name|prev_insn
init|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
while|while
condition|(
name|prev_insn
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|prev_insn
argument_list|)
operator|==
name|NOTE
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|prev_insn
argument_list|)
operator|==
name|INSN
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|prev_insn
argument_list|)
argument_list|)
operator|!=
name|SET
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|prev_insn
argument_list|)
argument_list|)
argument_list|,
name|reg_rtx
argument_list|)
condition|)
block|{
if|if
condition|(
name|sets_condition_code
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|prev_insn
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|doesnt_set_condition_code
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|prev_insn
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
return|return
operator|(
literal|0
operator|)
return|;
name|prev_insn
operator|=
name|PREV_INSN
argument_list|(
name|prev_insn
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|int
name|doesnt_set_condition_code
parameter_list|(
name|pat
parameter_list|)
name|rtx
name|pat
decl_stmt|;
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
condition|)
block|{
case|case
name|MEM
case|:
case|case
name|REG
case|:
return|return
literal|1
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
name|int
name|sets_condition_code
parameter_list|(
name|pat
parameter_list|)
name|rtx
name|pat
decl_stmt|;
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
condition|)
block|{
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
case|case
name|AND
case|:
case|case
name|IOR
case|:
case|case
name|XOR
case|:
case|case
name|NOT
case|:
case|case
name|NEG
case|:
case|case
name|MULT
case|:
case|case
name|DIV
case|:
case|case
name|MOD
case|:
case|case
name|UDIV
case|:
case|case
name|UMOD
case|:
return|return
literal|1
return|;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
name|int
name|str_immediate_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<=
literal|32
operator|&&
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|>=
literal|0
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|int
name|is_fp_insn
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
operator|(
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|DFmode
operator|||
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|SFmode
operator|||
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|XFmode
operator|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the mode of the SET_DEST of insn is floating point    and it is not an fld or a move from memory to memory.    Otherwise return 0 */
end_comment

begin_function
name|int
name|is_fp_dest
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
operator|(
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|DFmode
operator|||
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|SFmode
operator|||
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|XFmode
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|>=
name|FIRST_FLOAT_REG
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|MEM
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if the mode of the SET_DEST of INSN is floating point and is    memory and the source is a register.  */
end_comment

begin_function
name|int
name|is_fp_store
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
operator|(
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|DFmode
operator|||
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|SFmode
operator|||
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|XFmode
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if DEP_INSN sets a register which INSN uses as a base    or index to reference memory.    otherwise return 0 */
end_comment

begin_function
name|int
name|agi_dependent
parameter_list|(
name|insn
parameter_list|,
name|dep_insn
parameter_list|)
name|rtx
name|insn
decl_stmt|,
name|dep_insn
decl_stmt|;
block|{
name|int
name|push
init|=
literal|0
decl_stmt|,
name|push_dep
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dep_insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|dep_insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|dep_insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|reg_mentioned_in_mem
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|dep_insn
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|push_operand
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
argument_list|)
condition|)
name|push
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dep_insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|dep_insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|dep_insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|push_operand
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|dep_insn
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|dep_insn
argument_list|)
argument_list|)
argument_list|)
argument_list|)
condition|)
name|push_dep
operator|=
literal|1
expr_stmt|;
comment|/* CPUs contain special hardware to allow two pushes.  */
if|if
condition|(
name|push
operator|&&
name|push_dep
condition|)
return|return
literal|0
return|;
comment|/* Push operation implicitly change stack pointer causing AGI stalls.  */
if|if
condition|(
name|push_dep
operator|&&
name|reg_mentioned_in_mem
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|insn
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Push also implicitly read stack pointer.  */
if|if
condition|(
name|push
operator|&&
name|modified_in_p
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|dep_insn
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if reg is used in rtl as a base or index for a memory ref    otherwise return 0. */
end_comment

begin_function
name|int
name|reg_mentioned_in_mem
parameter_list|(
name|reg
parameter_list|,
name|rtl
parameter_list|)
name|rtx
name|reg
decl_stmt|,
name|rtl
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
if|if
condition|(
name|rtl
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|rtl
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|HIGH
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|SUBREG
case|:
return|return
literal|0
return|;
default|default:
break|break;
block|}
if|if
condition|(
name|code
operator|==
name|MEM
operator|&&
name|reg_mentioned_p
argument_list|(
name|reg
argument_list|,
name|rtl
argument_list|)
condition|)
return|return
literal|1
return|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|rtl
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|reg_mentioned_in_mem
argument_list|(
name|reg
argument_list|,
name|XVECEXP
argument_list|(
name|rtl
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|&&
name|reg_mentioned_in_mem
argument_list|(
name|reg
argument_list|,
name|XEXP
argument_list|(
name|rtl
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output the appropriate insns for doing strlen if not just doing repnz; scasb     operands[0] = result, initialized with the startaddress    operands[1] = alignment of the address.    operands[2] = scratch register, initialized with the startaddress when    		 not aligned, otherwise undefined     This is just the body. It needs the initialisations mentioned above and    some address computing at the end.  These things are done in i386.md.  */
end_comment

begin_function
name|char
modifier|*
name|output_strlen_unroll
parameter_list|(
name|operands
parameter_list|)
name|rtx
name|operands
index|[]
decl_stmt|;
block|{
name|rtx
name|xops
index|[
literal|18
index|]
decl_stmt|;
name|xops
index|[
literal|0
index|]
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
comment|/* Result */
comment|/*        operands[1];                 * Alignment */
name|xops
index|[
literal|1
index|]
operator|=
name|operands
index|[
literal|2
index|]
expr_stmt|;
comment|/* Scratch */
name|xops
index|[
literal|2
index|]
operator|=
name|GEN_INT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|xops
index|[
literal|3
index|]
operator|=
name|GEN_INT
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|xops
index|[
literal|4
index|]
operator|=
name|GEN_INT
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|xops
index|[
literal|5
index|]
operator|=
name|GEN_INT
argument_list|(
literal|4
argument_list|)
expr_stmt|;
comment|/* xops[6] = gen_label_rtx ();	 * label when aligned to 3-byte */
comment|/* xops[7] = gen_label_rtx ();	 * label when aligned to 2-byte */
name|xops
index|[
literal|8
index|]
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
comment|/* label of main loop */
if|if
condition|(
name|TARGET_USE_Q_REG
operator|&&
name|QI_REG_P
argument_list|(
name|xops
index|[
literal|1
index|]
argument_list|)
condition|)
name|xops
index|[
literal|9
index|]
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
comment|/* pentium optimisation */
name|xops
index|[
literal|10
index|]
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
comment|/* end label 2 */
name|xops
index|[
literal|11
index|]
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
comment|/* end label 1 */
name|xops
index|[
literal|12
index|]
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
comment|/* end label */
comment|/* xops[13]				 * Temporary used */
name|xops
index|[
literal|14
index|]
operator|=
name|GEN_INT
argument_list|(
literal|0xff
argument_list|)
expr_stmt|;
name|xops
index|[
literal|15
index|]
operator|=
name|GEN_INT
argument_list|(
literal|0xff00
argument_list|)
expr_stmt|;
name|xops
index|[
literal|16
index|]
operator|=
name|GEN_INT
argument_list|(
literal|0xff0000
argument_list|)
expr_stmt|;
name|xops
index|[
literal|17
index|]
operator|=
name|GEN_INT
argument_list|(
literal|0xff000000
argument_list|)
expr_stmt|;
comment|/* Loop to check 1..3 bytes for null to get an aligned pointer.  */
comment|/* Is there a known alignment and is it less than 4?  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|INTVAL
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|<
literal|4
condition|)
block|{
comment|/* Is there a known alignment and is it not 2? */
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|INTVAL
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|!=
literal|2
condition|)
block|{
name|xops
index|[
literal|6
index|]
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
comment|/* Label when aligned to 3-byte */
name|xops
index|[
literal|7
index|]
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
comment|/* Label when aligned to 2-byte */
comment|/* Leave just the 3 lower bits. 	     If this is a q-register, then the high part is used later 	     therefore use andl rather than andb. */
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|and
operator|%
name|L1
argument_list|,
operator|%
literal|4
argument_list|,
operator|%
literal|1
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
comment|/* Is aligned to 4-byte address when zero */
name|output_asm_insn
argument_list|(
name|AS1
argument_list|(
name|je
argument_list|,
operator|%
name|l8
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
comment|/* Side-effect even Parity when %eax == 3 */
name|output_asm_insn
argument_list|(
name|AS1
argument_list|(
name|jp
argument_list|,
operator|%
literal|6
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
comment|/* Is it aligned to 2 bytes ? */
if|if
condition|(
name|QI_REG_P
argument_list|(
name|xops
index|[
literal|1
index|]
argument_list|)
condition|)
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|cmp
operator|%
name|L1
argument_list|,
operator|%
literal|3
argument_list|,
operator|%
literal|1
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
else|else
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|cmp
operator|%
name|L1
argument_list|,
operator|%
literal|3
argument_list|,
operator|%
literal|1
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS1
argument_list|(
name|je
argument_list|,
operator|%
literal|7
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Since the alignment is 2, we have to check 2 or 0 bytes; 	     check if is aligned to 4 - byte.  */
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|and
operator|%
name|L1
argument_list|,
operator|%
literal|3
argument_list|,
operator|%
literal|1
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
comment|/* Is aligned to 4-byte address when zero */
name|output_asm_insn
argument_list|(
name|AS1
argument_list|(
name|je
argument_list|,
operator|%
name|l8
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
block|}
name|xops
index|[
literal|13
index|]
operator|=
name|gen_rtx_MEM
argument_list|(
name|QImode
argument_list|,
name|xops
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* Now compare the bytes; compare with the high part of a q-reg 	 gives shorter code. */
if|if
condition|(
name|QI_REG_P
argument_list|(
name|xops
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
comment|/* Compare the first n unaligned byte on a byte per byte basis. */
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|cmp
operator|%
name|B1
argument_list|,
operator|%
name|h1
argument_list|,
operator|%
literal|13
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
comment|/* When zero we reached the end. */
name|output_asm_insn
argument_list|(
name|AS1
argument_list|(
name|je
argument_list|,
operator|%
name|l12
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
comment|/* Increment the address. */
name|output_asm_insn
argument_list|(
name|AS1
argument_list|(
name|inc
operator|%
name|L0
argument_list|,
operator|%
literal|0
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
comment|/* Not needed with an alignment of 2 */
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|INTVAL
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|!=
literal|2
condition|)
block|{
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|asm_out_file
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|xops
index|[
literal|7
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|cmp
operator|%
name|B1
argument_list|,
operator|%
name|h1
argument_list|,
operator|%
literal|13
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS1
argument_list|(
name|je
argument_list|,
operator|%
name|l12
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS1
argument_list|(
name|inc
operator|%
name|L0
argument_list|,
operator|%
literal|0
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|asm_out_file
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|xops
index|[
literal|6
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|cmp
operator|%
name|B1
argument_list|,
operator|%
name|h1
argument_list|,
operator|%
literal|13
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|cmp
operator|%
name|B13
argument_list|,
operator|%
literal|2
argument_list|,
operator|%
literal|13
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS1
argument_list|(
name|je
argument_list|,
operator|%
name|l12
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS1
argument_list|(
name|inc
operator|%
name|L0
argument_list|,
operator|%
literal|0
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
comment|/* Not needed with an alignment of 2 */
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|INTVAL
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|!=
literal|2
condition|)
block|{
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|asm_out_file
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|xops
index|[
literal|7
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|cmp
operator|%
name|B13
argument_list|,
operator|%
literal|2
argument_list|,
operator|%
literal|13
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS1
argument_list|(
name|je
argument_list|,
operator|%
name|l12
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS1
argument_list|(
name|inc
operator|%
name|L0
argument_list|,
operator|%
literal|0
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|asm_out_file
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|xops
index|[
literal|6
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|cmp
operator|%
name|B13
argument_list|,
operator|%
literal|2
argument_list|,
operator|%
literal|13
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
block|}
name|output_asm_insn
argument_list|(
name|AS1
argument_list|(
name|je
argument_list|,
operator|%
name|l12
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS1
argument_list|(
name|inc
operator|%
name|L0
argument_list|,
operator|%
literal|0
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
block|}
comment|/* Generate loop to check 4 bytes at a time.  It is not a good idea to        align this loop.  It gives only huge programs, but does not help to        speed up.  */
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|asm_out_file
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|xops
index|[
literal|8
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|xops
index|[
literal|13
index|]
operator|=
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|xops
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|mov
operator|%
name|L1
argument_list|,
operator|%
literal|13
argument_list|,
operator|%
literal|1
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
if|if
condition|(
name|QI_REG_P
argument_list|(
name|xops
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
comment|/* On i586 it is faster to combine the hi- and lo- part as 	 a kind of lookahead.  If anding both yields zero, then one 	 of both *could* be zero, otherwise none of both is zero; 	 this saves one instruction, on i486 this is slower 	 tested with P-90, i486DX2-66, AMD486DX2-66  */
if|if
condition|(
name|TARGET_PENTIUM
condition|)
block|{
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|test
operator|%
name|B1
argument_list|,
operator|%
name|h1
argument_list|,
operator|%
name|b1
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS1
argument_list|(
name|jne
argument_list|,
operator|%
name|l9
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
block|}
comment|/* Check first byte. */
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|test
operator|%
name|B1
argument_list|,
operator|%
name|b1
argument_list|,
operator|%
name|b1
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS1
argument_list|(
name|je
argument_list|,
operator|%
name|l12
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
comment|/* Check second byte. */
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|test
operator|%
name|B1
argument_list|,
operator|%
name|h1
argument_list|,
operator|%
name|h1
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS1
argument_list|(
name|je
argument_list|,
operator|%
name|l11
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_PENTIUM
condition|)
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|asm_out_file
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|xops
index|[
literal|9
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Check first byte. */
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|test
operator|%
name|L1
argument_list|,
operator|%
literal|14
argument_list|,
operator|%
literal|1
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS1
argument_list|(
name|je
argument_list|,
operator|%
name|l12
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
comment|/* Check second byte. */
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|test
operator|%
name|L1
argument_list|,
operator|%
literal|15
argument_list|,
operator|%
literal|1
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS1
argument_list|(
name|je
argument_list|,
operator|%
name|l11
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
block|}
comment|/* Check third byte. */
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|test
operator|%
name|L1
argument_list|,
operator|%
literal|16
argument_list|,
operator|%
literal|1
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS1
argument_list|(
name|je
argument_list|,
operator|%
name|l10
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
comment|/* Check fourth byte and increment address. */
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|add
operator|%
name|L0
argument_list|,
operator|%
literal|5
argument_list|,
operator|%
literal|0
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|test
operator|%
name|L1
argument_list|,
operator|%
literal|17
argument_list|,
operator|%
literal|1
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS1
argument_list|(
name|jne
argument_list|,
operator|%
name|l8
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
comment|/* Now generate fixups when the compare stops within a 4-byte word. */
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|sub
operator|%
name|L0
argument_list|,
operator|%
literal|4
argument_list|,
operator|%
literal|0
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|asm_out_file
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|xops
index|[
literal|10
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS1
argument_list|(
name|inc
operator|%
name|L0
argument_list|,
operator|%
literal|0
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|asm_out_file
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|xops
index|[
literal|11
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS1
argument_list|(
name|inc
operator|%
name|L0
argument_list|,
operator|%
literal|0
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|asm_out_file
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|xops
index|[
literal|12
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|output_fp_conditional_move
parameter_list|(
name|which_alternative
parameter_list|,
name|operands
parameter_list|)
name|int
name|which_alternative
decl_stmt|;
name|rtx
name|operands
index|[]
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
comment|/* This should never happen.  */
if|if
condition|(
operator|!
operator|(
name|cc_prev_status
operator|.
name|flags
operator|&
name|CC_IN_80387
operator|)
operator|&&
operator|(
name|code
operator|==
name|GT
operator|||
name|code
operator|==
name|LE
operator|||
name|code
operator|==
name|GE
operator|||
name|code
operator|==
name|LT
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|which_alternative
condition|)
block|{
case|case
literal|0
case|:
comment|/* r<- cond ? arg : r */
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|fcmov
operator|%
name|F1
argument_list|,
operator|%
literal|2
argument_list|,
operator|%
literal|0
argument_list|)
argument_list|,
name|operands
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* r<- cond ? r : arg */
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|fcmov
operator|%
name|f1
argument_list|,
operator|%
literal|3
argument_list|,
operator|%
literal|0
argument_list|)
argument_list|,
name|operands
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
literal|""
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|output_int_conditional_move
parameter_list|(
name|which_alternative
parameter_list|,
name|operands
parameter_list|)
name|int
name|which_alternative
decl_stmt|;
name|rtx
name|operands
index|[]
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
comment|/* This is very tricky. We have to do it right. For a code segement      like:  	int foo, bar; 	.... 	foo = foo - x; 	if (foo>= 0) 	  bar = y;       final_scan_insn () may delete the insn which sets CC. We have to      tell final_scan_insn () if it should be reinserted. When CODE is      GT or LE, we have to check the CC_NO_OVERFLOW bit and return      NULL_PTR to tell final to reinsert the test insn because the      conditional move cannot be handled properly without it. */
if|if
condition|(
operator|(
name|code
operator|==
name|GT
operator|||
name|code
operator|==
name|LE
operator|)
operator|&&
operator|(
name|cc_prev_status
operator|.
name|flags
operator|&
name|CC_NO_OVERFLOW
operator|)
condition|)
return|return
name|NULL_PTR
return|;
switch|switch
condition|(
name|which_alternative
condition|)
block|{
case|case
literal|0
case|:
comment|/* r<- cond ? arg : r */
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|cmov
operator|%
name|C1
argument_list|,
operator|%
literal|2
argument_list|,
operator|%
literal|0
argument_list|)
argument_list|,
name|operands
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* r<- cond ? r : arg */
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|cmov
operator|%
name|c1
argument_list|,
operator|%
literal|3
argument_list|,
operator|%
literal|0
argument_list|)
argument_list|,
name|operands
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
literal|""
return|;
block|}
end_function

begin_function
name|int
name|x86_adjust_cost
parameter_list|(
name|insn
parameter_list|,
name|link
parameter_list|,
name|dep_insn
parameter_list|,
name|cost
parameter_list|)
name|rtx
name|insn
decl_stmt|,
name|link
decl_stmt|,
name|dep_insn
decl_stmt|;
name|int
name|cost
decl_stmt|;
block|{
name|rtx
name|next_inst
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dep_insn
argument_list|)
operator|==
name|CALL_INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dep_insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|dep_insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|dep_insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
operator|!
name|reg_overlap_mentioned_p
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|dep_insn
argument_list|)
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* ??? */
switch|switch
condition|(
name|ix86_cpu
condition|)
block|{
case|case
name|PROCESSOR_PENTIUM
case|:
if|if
condition|(
name|cost
operator|!=
literal|0
operator|&&
name|is_fp_insn
argument_list|(
name|insn
argument_list|)
operator|&&
name|is_fp_insn
argument_list|(
name|dep_insn
argument_list|)
operator|&&
operator|!
name|is_fp_dest
argument_list|(
name|dep_insn
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|agi_dependent
argument_list|(
name|insn
argument_list|,
name|dep_insn
argument_list|)
condition|)
return|return
name|cost
condition|?
name|cost
operator|+
literal|1
else|:
literal|2
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|cc0_rtx
operator|&&
operator|(
name|next_inst
operator|=
name|next_nonnote_insn
argument_list|(
name|insn
argument_list|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|next_inst
argument_list|)
operator|==
name|JUMP_INSN
condition|)
comment|/* compare probably paired with jump */
return|return
literal|0
return|;
comment|/* Stores stalls one cycle longer than other insns.  */
if|if
condition|(
name|is_fp_insn
argument_list|(
name|insn
argument_list|)
operator|&&
name|cost
operator|&&
name|is_fp_store
argument_list|(
name|dep_insn
argument_list|)
condition|)
name|cost
operator|++
expr_stmt|;
break|break;
case|case
name|PROCESSOR_K6
case|:
default|default:
if|if
condition|(
operator|!
name|is_fp_dest
argument_list|(
name|dep_insn
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|agi_dependent
argument_list|(
name|insn
argument_list|,
name|dep_insn
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TARGET_486
condition|)
return|return
literal|2
return|;
block|}
elseif|else
if|if
condition|(
name|is_fp_store
argument_list|(
name|insn
argument_list|)
operator|&&
name|is_fp_insn
argument_list|(
name|dep_insn
argument_list|)
operator|&&
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|&&
name|NEXT_INSN
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|&&
name|NEXT_INSN
argument_list|(
name|NEXT_INSN
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|INSN
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|NEXT_INSN
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|JUMP_INSN
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|NEXT_INSN
argument_list|(
name|NEXT_INSN
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|==
name|NOTE
operator|)
operator|&&
operator|(
name|NOTE_LINE_NUMBER
argument_list|(
name|NEXT_INSN
argument_list|(
name|NEXT_INSN
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|==
name|NOTE_INSN_LOOP_END
operator|)
condition|)
return|return
literal|3
return|;
break|break;
block|}
return|return
name|cost
return|;
block|}
end_function

begin_comment
comment|/* Output assembly code for a left shift.     Always use "sal" when shifting a memory operand or for a non constant    shift count.     When optimizing for size, we know that src == dest, and we should always    use "sal".  If src != dest, then copy src to dest and use "sal".        Pentium and PPro (speed):       When src == dest, use "add" for a shift counts of one, else use      "sal".  If we modeled Pentium AGI stalls and U/V pipelining better we      would want to generate lea for some shifts on the Pentium.       When src != dest, use "lea" for small shift counts.  Otherwise,      copy src to dest and use the normal shifting code.  Exception for      TARGET_DOUBLE_WITH_ADD.  */
end_comment

begin_function
name|char
modifier|*
name|output_ashl
parameter_list|(
name|insn
parameter_list|,
name|operands
parameter_list|)
name|rtx
name|insn
decl_stmt|,
decl|*
name|operands
decl_stmt|;
end_function

begin_block
block|{
comment|/* Handle case where srcreg != dstreg.  */
if|if
condition|(
name|REG_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|!=
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|TARGET_DOUBLE_WITH_ADD
operator|&&
name|INTVAL
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|==
literal|1
condition|)
switch|switch
condition|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
case|case
name|SImode
case|:
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|mov
operator|%
name|L0
argument_list|,
operator|%
literal|1
argument_list|,
operator|%
literal|0
argument_list|)
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return
name|AS2
argument_list|(
name|add
operator|%
name|L0
argument_list|,
operator|%
literal|1
argument_list|,
operator|%
literal|0
argument_list|)
return|;
case|case
name|HImode
case|:
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|mov
operator|%
name|L0
argument_list|,
operator|%
name|k1
argument_list|,
operator|%
name|k0
argument_list|)
argument_list|,
name|operands
argument_list|)
expr_stmt|;
if|if
condition|(
name|i386_cc_probably_useless_p
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|CC_STATUS_INIT
expr_stmt|;
return|return
name|AS2
argument_list|(
name|add
operator|%
name|L0
argument_list|,
operator|%
name|k1
argument_list|,
operator|%
name|k0
argument_list|)
return|;
block|}
return|return
name|AS2
argument_list|(
name|add
operator|%
name|W0
argument_list|,
operator|%
name|k1
argument_list|,
operator|%
name|k0
argument_list|)
return|;
case|case
name|QImode
case|:
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|mov
operator|%
name|B0
argument_list|,
operator|%
literal|1
argument_list|,
operator|%
literal|0
argument_list|)
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return
name|AS2
argument_list|(
name|add
operator|%
name|B0
argument_list|,
operator|%
literal|1
argument_list|,
operator|%
literal|0
argument_list|)
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|CC_STATUS_INIT
expr_stmt|;
comment|/* This should be extremely rare (impossible?).  We can not encode a 	     shift of the stack pointer using an lea instruction.  So copy the 	     stack pointer into the destination register and use an lea.  */
if|if
condition|(
name|operands
index|[
literal|1
index|]
operator|==
name|stack_pointer_rtx
condition|)
block|{
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|mov
operator|%
name|L0
argument_list|,
operator|%
name|k1
argument_list|,
operator|%
name|k0
argument_list|)
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
block|}
comment|/* For shifts up to and including 3 bits, use lea.  */
name|operands
index|[
literal|1
index|]
operator|=
name|gen_rtx_MULT
argument_list|(
name|SImode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
literal|1
operator|<<
name|INTVAL
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|AS2
argument_list|(
name|lea
operator|%
name|L0
argument_list|,
operator|%
name|a1
argument_list|,
operator|%
name|k0
argument_list|)
return|;
block|}
block|}
comment|/* Source and destination match.  */
comment|/* Handle variable shift.  */
if|if
condition|(
name|REG_P
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
condition|)
switch|switch
condition|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
case|case
name|SImode
case|:
return|return
name|AS2
argument_list|(
name|sal
operator|%
name|L0
argument_list|,
operator|%
name|b2
argument_list|,
operator|%
literal|0
argument_list|)
return|;
case|case
name|HImode
case|:
if|if
condition|(
name|REG_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|&&
name|i386_cc_probably_useless_p
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|CC_STATUS_INIT
expr_stmt|;
return|return
name|AS2
argument_list|(
name|sal
operator|%
name|L0
argument_list|,
operator|%
name|b2
argument_list|,
operator|%
name|k0
argument_list|)
return|;
block|}
else|else
return|return
name|AS2
argument_list|(
name|sal
operator|%
name|W0
argument_list|,
operator|%
name|b2
argument_list|,
operator|%
literal|0
argument_list|)
return|;
case|case
name|QImode
case|:
return|return
name|AS2
argument_list|(
name|sal
operator|%
name|B0
argument_list|,
operator|%
name|b2
argument_list|,
operator|%
literal|0
argument_list|)
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Always perform shift by 1 using an add instruction.  */
if|if
condition|(
name|REG_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|&&
name|operands
index|[
literal|2
index|]
operator|==
name|const1_rtx
condition|)
switch|switch
condition|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
case|case
name|SImode
case|:
return|return
name|AS2
argument_list|(
name|add
operator|%
name|L0
argument_list|,
operator|%
literal|0
argument_list|,
operator|%
literal|0
argument_list|)
return|;
case|case
name|HImode
case|:
if|if
condition|(
name|REG_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|&&
name|i386_cc_probably_useless_p
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|CC_STATUS_INIT
expr_stmt|;
return|return
name|AS2
argument_list|(
name|add
operator|%
name|L0
argument_list|,
operator|%
name|k0
argument_list|,
operator|%
name|k0
argument_list|)
return|;
block|}
else|else
return|return
name|AS2
argument_list|(
name|add
operator|%
name|W0
argument_list|,
operator|%
literal|0
argument_list|,
operator|%
literal|0
argument_list|)
return|;
case|case
name|QImode
case|:
return|return
name|AS2
argument_list|(
name|add
operator|%
name|B0
argument_list|,
operator|%
literal|0
argument_list|,
operator|%
literal|0
argument_list|)
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* ??? Currently disabled.  Because our model of Pentium is far from being      exact, this change will need some benchmarking.  */
comment|/* Shift reg by 2 or 3 use an lea instruction for Pentium if this is      insn is expected to issue into the V pipe (the insn's mode will be      TImode for a U pipe, and !TImode for a V pipe instruction).  */
block|if (! optimize_size&& REG_P (operands[0])&& GET_CODE (operands[2]) == CONST_INT&& INTVAL (operands[2])<= 3&& (int)ix86_cpu == (int)PROCESSOR_PENTIUM&& GET_MODE (insn) != TImode)     {       CC_STATUS_INIT;       operands[1] = gen_rtx_MULT (SImode, gen_rtx_REG (SImode, REGNO (operands[1])), 				  GEN_INT (1<< INTVAL (operands[2])));       return AS2 (lea%L0,%a1,%0);     }
endif|#
directive|endif
comment|/* Otherwise use a shift instruction.  */
switch|switch
condition|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
case|case
name|SImode
case|:
return|return
name|AS2
argument_list|(
name|sal
operator|%
name|L0
argument_list|,
operator|%
literal|2
argument_list|,
operator|%
literal|0
argument_list|)
return|;
case|case
name|HImode
case|:
if|if
condition|(
name|REG_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|&&
name|i386_cc_probably_useless_p
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|CC_STATUS_INIT
expr_stmt|;
return|return
name|AS2
argument_list|(
name|sal
operator|%
name|L0
argument_list|,
operator|%
literal|2
argument_list|,
operator|%
name|k0
argument_list|)
return|;
block|}
else|else
return|return
name|AS2
argument_list|(
name|sal
operator|%
name|W0
argument_list|,
operator|%
literal|2
argument_list|,
operator|%
literal|0
argument_list|)
return|;
case|case
name|QImode
case|:
return|return
name|AS2
argument_list|(
name|sal
operator|%
name|B0
argument_list|,
operator|%
literal|2
argument_list|,
operator|%
literal|0
argument_list|)
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Given the memory address ADDR, calculate the length of the address or    the length of just the displacement (controlled by DISP_LENGTH).       The length returned does not include the one-byte modrm, opcode,    or prefix.  */
end_comment

begin_function
name|int
name|memory_address_info
parameter_list|(
name|addr
parameter_list|,
name|disp_length
parameter_list|)
name|rtx
name|addr
decl_stmt|;
name|int
name|disp_length
decl_stmt|;
block|{
name|rtx
name|base
decl_stmt|,
name|index
decl_stmt|,
name|disp
decl_stmt|,
name|scale
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PRE_DEC
operator|||
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|POST_INC
condition|)
return|return
literal|0
return|;
comment|/* Register Indirect.  */
if|if
condition|(
name|register_operand
argument_list|(
name|addr
argument_list|,
name|Pmode
argument_list|)
condition|)
block|{
comment|/* Special cases: ebp and esp need the two-byte modrm form.   	 We change [ESI] to [ESI+0] on the K6 when not optimizing 	 for size.  */
if|if
condition|(
name|addr
operator|==
name|stack_pointer_rtx
operator|||
name|addr
operator|==
name|arg_pointer_rtx
operator|||
name|addr
operator|==
name|frame_pointer_rtx
operator|||
operator|(
name|REGNO_REG_CLASS
argument_list|(
name|REGNO
argument_list|(
name|addr
argument_list|)
argument_list|)
operator|==
name|SIREG
operator|&&
name|ix86_cpu
operator|==
name|PROCESSOR_K6
operator|&&
operator|!
name|optimize_size
operator|)
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
comment|/* Direct Addressing.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|addr
argument_list|)
condition|)
return|return
literal|4
return|;
name|index
operator|=
name|base
operator|=
name|disp
operator|=
name|scale
operator|=
name|NULL_RTX
expr_stmt|;
name|op0
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
condition|)
block|{
if|if
condition|(
name|register_operand
argument_list|(
name|op0
argument_list|,
name|Pmode
argument_list|)
condition|)
block|{
if|if
condition|(
name|register_operand
argument_list|(
name|op1
argument_list|,
name|Pmode
argument_list|)
condition|)
name|index
operator|=
name|op0
operator|,
name|base
operator|=
name|op1
expr_stmt|;
else|else
name|base
operator|=
name|op0
operator|,
name|disp
operator|=
name|op1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|MULT
condition|)
block|{
name|index
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|scale
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|register_operand
argument_list|(
name|op1
argument_list|,
name|Pmode
argument_list|)
condition|)
name|base
operator|=
name|op1
expr_stmt|;
else|else
name|disp
operator|=
name|op1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MULT
condition|)
block|{
name|index
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|scale
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|base
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|disp
operator|=
name|op1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|index
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|base
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|disp
operator|=
name|op1
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|MULT
comment|/* We're called for lea too, which implements ashift on occasion.  */
operator|||
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|ASHIFT
condition|)
block|{
name|index
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|scale
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* Allow arg pointer and stack pointer as index if there is not scaling */
if|if
condition|(
name|base
operator|&&
name|index
operator|&&
operator|!
name|scale
operator|&&
operator|(
name|index
operator|==
name|stack_pointer_rtx
operator|||
name|index
operator|==
name|arg_pointer_rtx
operator|||
name|index
operator|==
name|frame_pointer_rtx
operator|)
condition|)
block|{
name|rtx
name|tmp
init|=
name|base
decl_stmt|;
name|base
operator|=
name|index
expr_stmt|;
name|index
operator|=
name|tmp
expr_stmt|;
block|}
comment|/* Special case: ebp cannot be encoded as a base without a displacement.  */
if|if
condition|(
name|base
operator|==
name|frame_pointer_rtx
operator|&&
operator|!
name|disp
condition|)
name|disp
operator|=
name|const0_rtx
expr_stmt|;
comment|/* Scaling can not be encoded without base or displacement.        Except for scale == 1 where we can encode reg + reg instead of reg * 2.  */
if|if
condition|(
operator|!
name|base
operator|&&
name|index
operator|&&
operator|(
operator|!
name|scale
operator|||
name|GET_CODE
argument_list|(
name|scale
argument_list|)
operator|!=
name|CONST_INT
operator|||
operator|(
name|INTVAL
argument_list|(
name|scale
argument_list|)
operator|!=
literal|1
operator|)
operator|)
condition|)
name|disp
operator|=
name|const0_rtx
expr_stmt|;
comment|/* Find the length of the displacement constant.  */
name|len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|disp
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|INTVAL
argument_list|(
name|disp
argument_list|)
argument_list|,
literal|'K'
argument_list|)
condition|)
name|len
operator|=
literal|1
expr_stmt|;
else|else
name|len
operator|=
literal|4
expr_stmt|;
block|}
comment|/* An index requires the two-byte modrm form.  Not important      if we are computing just length of the displacement.  */
if|if
condition|(
name|index
operator|&&
operator|!
name|disp_length
condition|)
name|len
operator|+=
literal|1
expr_stmt|;
return|return
name|len
return|;
block|}
end_function

end_unit

