begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Subroutines used for code generation on IA-32.    Copyright (C) 1988, 1992, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,    2002, 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"conditions.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"insn-codes.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"optabs.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"target-def.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"cgraph.h"
end_include

begin_include
include|#
directive|include
file|"tree-gimple.h"
end_include

begin_include
include|#
directive|include
file|"dwarf2.h"
end_include

begin_include
include|#
directive|include
file|"tm-constrs.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|CHECK_STACK_LIMIT
end_ifndef

begin_define
define|#
directive|define
name|CHECK_STACK_LIMIT
value|(-1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Return index of given mode in mult and division cost tables.  */
end_comment

begin_define
define|#
directive|define
name|MODE_INDEX
parameter_list|(
name|mode
parameter_list|)
define|\
value|((mode) == QImode ? 0						\    : (mode) == HImode ? 1					\    : (mode) == SImode ? 2					\    : (mode) == DImode ? 3					\    : 4)
end_define

begin_comment
comment|/* Processor costs (relative to an add) */
end_comment

begin_comment
comment|/* We assume COSTS_N_INSNS is defined as (N)*4 and an addition is 2 bytes.  */
end_comment

begin_define
define|#
directive|define
name|COSTS_N_BYTES
parameter_list|(
name|N
parameter_list|)
value|((N) * 2)
end_define

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|processor_costs
name|size_cost
init|=
block|{
comment|/* costs for tuning for size */
name|COSTS_N_BYTES
argument_list|(
literal|2
argument_list|)
block|,
comment|/* cost of an add instruction */
name|COSTS_N_BYTES
argument_list|(
literal|3
argument_list|)
block|,
comment|/* cost of a lea instruction */
name|COSTS_N_BYTES
argument_list|(
literal|2
argument_list|)
block|,
comment|/* variable shift costs */
name|COSTS_N_BYTES
argument_list|(
literal|3
argument_list|)
block|,
comment|/* constant shift costs */
block|{
name|COSTS_N_BYTES
argument_list|(
literal|3
argument_list|)
block|,
comment|/* cost of starting multiply for QI */
name|COSTS_N_BYTES
argument_list|(
literal|3
argument_list|)
block|,
comment|/*                               HI */
name|COSTS_N_BYTES
argument_list|(
literal|3
argument_list|)
block|,
comment|/*                               SI */
name|COSTS_N_BYTES
argument_list|(
literal|3
argument_list|)
block|,
comment|/*                               DI */
name|COSTS_N_BYTES
argument_list|(
literal|5
argument_list|)
block|}
block|,
comment|/*                            other */
literal|0
block|,
comment|/* cost of multiply per each bit set */
block|{
name|COSTS_N_BYTES
argument_list|(
literal|3
argument_list|)
block|,
comment|/* cost of a divide/mod for QI */
name|COSTS_N_BYTES
argument_list|(
literal|3
argument_list|)
block|,
comment|/*                          HI */
name|COSTS_N_BYTES
argument_list|(
literal|3
argument_list|)
block|,
comment|/*                          SI */
name|COSTS_N_BYTES
argument_list|(
literal|3
argument_list|)
block|,
comment|/*                          DI */
name|COSTS_N_BYTES
argument_list|(
literal|5
argument_list|)
block|}
block|,
comment|/*                       other */
name|COSTS_N_BYTES
argument_list|(
literal|3
argument_list|)
block|,
comment|/* cost of movsx */
name|COSTS_N_BYTES
argument_list|(
literal|3
argument_list|)
block|,
comment|/* cost of movzx */
literal|0
block|,
comment|/* "large" insn */
literal|2
block|,
comment|/* MOVE_RATIO */
literal|2
block|,
comment|/* cost for loading QImode using movzbl */
block|{
literal|2
block|,
literal|2
block|,
literal|2
block|}
block|,
comment|/* cost of loading integer registers 					   in QImode, HImode and SImode. 					   Relative to reg-reg move (2).  */
block|{
literal|2
block|,
literal|2
block|,
literal|2
block|}
block|,
comment|/* cost of storing integer registers */
literal|2
block|,
comment|/* cost of reg,reg fld/fst */
block|{
literal|2
block|,
literal|2
block|,
literal|2
block|}
block|,
comment|/* cost of loading fp registers 					   in SFmode, DFmode and XFmode */
block|{
literal|2
block|,
literal|2
block|,
literal|2
block|}
block|,
comment|/* cost of storing fp registers 					   in SFmode, DFmode and XFmode */
literal|3
block|,
comment|/* cost of moving MMX register */
block|{
literal|3
block|,
literal|3
block|}
block|,
comment|/* cost of loading MMX registers 					   in SImode and DImode */
block|{
literal|3
block|,
literal|3
block|}
block|,
comment|/* cost of storing MMX registers 					   in SImode and DImode */
literal|3
block|,
comment|/* cost of moving SSE register */
block|{
literal|3
block|,
literal|3
block|,
literal|3
block|}
block|,
comment|/* cost of loading SSE registers 					   in SImode, DImode and TImode */
block|{
literal|3
block|,
literal|3
block|,
literal|3
block|}
block|,
comment|/* cost of storing SSE registers 					   in SImode, DImode and TImode */
literal|3
block|,
comment|/* MMX or SSE register to integer */
literal|0
block|,
comment|/* size of prefetch block */
literal|0
block|,
comment|/* number of parallel prefetches */
literal|2
block|,
comment|/* Branch cost */
name|COSTS_N_BYTES
argument_list|(
literal|2
argument_list|)
block|,
comment|/* cost of FADD and FSUB insns.  */
name|COSTS_N_BYTES
argument_list|(
literal|2
argument_list|)
block|,
comment|/* cost of FMUL instruction.  */
name|COSTS_N_BYTES
argument_list|(
literal|2
argument_list|)
block|,
comment|/* cost of FDIV instruction.  */
name|COSTS_N_BYTES
argument_list|(
literal|2
argument_list|)
block|,
comment|/* cost of FABS instruction.  */
name|COSTS_N_BYTES
argument_list|(
literal|2
argument_list|)
block|,
comment|/* cost of FCHS instruction.  */
name|COSTS_N_BYTES
argument_list|(
literal|2
argument_list|)
block|,
comment|/* cost of FSQRT instruction.  */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Processor costs (relative to an add) */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|processor_costs
name|i386_cost
init|=
block|{
comment|/* 386 specific costs */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* cost of an add instruction */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* cost of a lea instruction */
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
block|,
comment|/* variable shift costs */
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
block|,
comment|/* constant shift costs */
block|{
name|COSTS_N_INSNS
argument_list|(
literal|6
argument_list|)
block|,
comment|/* cost of starting multiply for QI */
name|COSTS_N_INSNS
argument_list|(
literal|6
argument_list|)
block|,
comment|/*                               HI */
name|COSTS_N_INSNS
argument_list|(
literal|6
argument_list|)
block|,
comment|/*                               SI */
name|COSTS_N_INSNS
argument_list|(
literal|6
argument_list|)
block|,
comment|/*                               DI */
name|COSTS_N_INSNS
argument_list|(
literal|6
argument_list|)
block|}
block|,
comment|/*                               other */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* cost of multiply per each bit set */
block|{
name|COSTS_N_INSNS
argument_list|(
literal|23
argument_list|)
block|,
comment|/* cost of a divide/mod for QI */
name|COSTS_N_INSNS
argument_list|(
literal|23
argument_list|)
block|,
comment|/*                          HI */
name|COSTS_N_INSNS
argument_list|(
literal|23
argument_list|)
block|,
comment|/*                          SI */
name|COSTS_N_INSNS
argument_list|(
literal|23
argument_list|)
block|,
comment|/*                          DI */
name|COSTS_N_INSNS
argument_list|(
literal|23
argument_list|)
block|}
block|,
comment|/*                          other */
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
block|,
comment|/* cost of movsx */
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
block|,
comment|/* cost of movzx */
literal|15
block|,
comment|/* "large" insn */
literal|3
block|,
comment|/* MOVE_RATIO */
literal|4
block|,
comment|/* cost for loading QImode using movzbl */
block|{
literal|2
block|,
literal|4
block|,
literal|2
block|}
block|,
comment|/* cost of loading integer registers 					   in QImode, HImode and SImode. 					   Relative to reg-reg move (2).  */
block|{
literal|2
block|,
literal|4
block|,
literal|2
block|}
block|,
comment|/* cost of storing integer registers */
literal|2
block|,
comment|/* cost of reg,reg fld/fst */
block|{
literal|8
block|,
literal|8
block|,
literal|8
block|}
block|,
comment|/* cost of loading fp registers 					   in SFmode, DFmode and XFmode */
block|{
literal|8
block|,
literal|8
block|,
literal|8
block|}
block|,
comment|/* cost of storing fp registers 					   in SFmode, DFmode and XFmode */
literal|2
block|,
comment|/* cost of moving MMX register */
block|{
literal|4
block|,
literal|8
block|}
block|,
comment|/* cost of loading MMX registers 					   in SImode and DImode */
block|{
literal|4
block|,
literal|8
block|}
block|,
comment|/* cost of storing MMX registers 					   in SImode and DImode */
literal|2
block|,
comment|/* cost of moving SSE register */
block|{
literal|4
block|,
literal|8
block|,
literal|16
block|}
block|,
comment|/* cost of loading SSE registers 					   in SImode, DImode and TImode */
block|{
literal|4
block|,
literal|8
block|,
literal|16
block|}
block|,
comment|/* cost of storing SSE registers 					   in SImode, DImode and TImode */
literal|3
block|,
comment|/* MMX or SSE register to integer */
literal|0
block|,
comment|/* size of prefetch block */
literal|0
block|,
comment|/* number of parallel prefetches */
literal|1
block|,
comment|/* Branch cost */
name|COSTS_N_INSNS
argument_list|(
literal|23
argument_list|)
block|,
comment|/* cost of FADD and FSUB insns.  */
name|COSTS_N_INSNS
argument_list|(
literal|27
argument_list|)
block|,
comment|/* cost of FMUL instruction.  */
name|COSTS_N_INSNS
argument_list|(
literal|88
argument_list|)
block|,
comment|/* cost of FDIV instruction.  */
name|COSTS_N_INSNS
argument_list|(
literal|22
argument_list|)
block|,
comment|/* cost of FABS instruction.  */
name|COSTS_N_INSNS
argument_list|(
literal|24
argument_list|)
block|,
comment|/* cost of FCHS instruction.  */
name|COSTS_N_INSNS
argument_list|(
literal|122
argument_list|)
block|,
comment|/* cost of FSQRT instruction.  */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|processor_costs
name|i486_cost
init|=
block|{
comment|/* 486 specific costs */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* cost of an add instruction */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* cost of a lea instruction */
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
block|,
comment|/* variable shift costs */
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
block|,
comment|/* constant shift costs */
block|{
name|COSTS_N_INSNS
argument_list|(
literal|12
argument_list|)
block|,
comment|/* cost of starting multiply for QI */
name|COSTS_N_INSNS
argument_list|(
literal|12
argument_list|)
block|,
comment|/*                               HI */
name|COSTS_N_INSNS
argument_list|(
literal|12
argument_list|)
block|,
comment|/*                               SI */
name|COSTS_N_INSNS
argument_list|(
literal|12
argument_list|)
block|,
comment|/*                               DI */
name|COSTS_N_INSNS
argument_list|(
literal|12
argument_list|)
block|}
block|,
comment|/*                               other */
literal|1
block|,
comment|/* cost of multiply per each bit set */
block|{
name|COSTS_N_INSNS
argument_list|(
literal|40
argument_list|)
block|,
comment|/* cost of a divide/mod for QI */
name|COSTS_N_INSNS
argument_list|(
literal|40
argument_list|)
block|,
comment|/*                          HI */
name|COSTS_N_INSNS
argument_list|(
literal|40
argument_list|)
block|,
comment|/*                          SI */
name|COSTS_N_INSNS
argument_list|(
literal|40
argument_list|)
block|,
comment|/*                          DI */
name|COSTS_N_INSNS
argument_list|(
literal|40
argument_list|)
block|}
block|,
comment|/*                          other */
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
block|,
comment|/* cost of movsx */
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
block|,
comment|/* cost of movzx */
literal|15
block|,
comment|/* "large" insn */
literal|3
block|,
comment|/* MOVE_RATIO */
literal|4
block|,
comment|/* cost for loading QImode using movzbl */
block|{
literal|2
block|,
literal|4
block|,
literal|2
block|}
block|,
comment|/* cost of loading integer registers 					   in QImode, HImode and SImode. 					   Relative to reg-reg move (2).  */
block|{
literal|2
block|,
literal|4
block|,
literal|2
block|}
block|,
comment|/* cost of storing integer registers */
literal|2
block|,
comment|/* cost of reg,reg fld/fst */
block|{
literal|8
block|,
literal|8
block|,
literal|8
block|}
block|,
comment|/* cost of loading fp registers 					   in SFmode, DFmode and XFmode */
block|{
literal|8
block|,
literal|8
block|,
literal|8
block|}
block|,
comment|/* cost of storing fp registers 					   in SFmode, DFmode and XFmode */
literal|2
block|,
comment|/* cost of moving MMX register */
block|{
literal|4
block|,
literal|8
block|}
block|,
comment|/* cost of loading MMX registers 					   in SImode and DImode */
block|{
literal|4
block|,
literal|8
block|}
block|,
comment|/* cost of storing MMX registers 					   in SImode and DImode */
literal|2
block|,
comment|/* cost of moving SSE register */
block|{
literal|4
block|,
literal|8
block|,
literal|16
block|}
block|,
comment|/* cost of loading SSE registers 					   in SImode, DImode and TImode */
block|{
literal|4
block|,
literal|8
block|,
literal|16
block|}
block|,
comment|/* cost of storing SSE registers 					   in SImode, DImode and TImode */
literal|3
block|,
comment|/* MMX or SSE register to integer */
literal|0
block|,
comment|/* size of prefetch block */
literal|0
block|,
comment|/* number of parallel prefetches */
literal|1
block|,
comment|/* Branch cost */
name|COSTS_N_INSNS
argument_list|(
literal|8
argument_list|)
block|,
comment|/* cost of FADD and FSUB insns.  */
name|COSTS_N_INSNS
argument_list|(
literal|16
argument_list|)
block|,
comment|/* cost of FMUL instruction.  */
name|COSTS_N_INSNS
argument_list|(
literal|73
argument_list|)
block|,
comment|/* cost of FDIV instruction.  */
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
block|,
comment|/* cost of FABS instruction.  */
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
block|,
comment|/* cost of FCHS instruction.  */
name|COSTS_N_INSNS
argument_list|(
literal|83
argument_list|)
block|,
comment|/* cost of FSQRT instruction.  */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|processor_costs
name|pentium_cost
init|=
block|{
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* cost of an add instruction */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* cost of a lea instruction */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* variable shift costs */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* constant shift costs */
block|{
name|COSTS_N_INSNS
argument_list|(
literal|11
argument_list|)
block|,
comment|/* cost of starting multiply for QI */
name|COSTS_N_INSNS
argument_list|(
literal|11
argument_list|)
block|,
comment|/*                               HI */
name|COSTS_N_INSNS
argument_list|(
literal|11
argument_list|)
block|,
comment|/*                               SI */
name|COSTS_N_INSNS
argument_list|(
literal|11
argument_list|)
block|,
comment|/*                               DI */
name|COSTS_N_INSNS
argument_list|(
literal|11
argument_list|)
block|}
block|,
comment|/*                               other */
literal|0
block|,
comment|/* cost of multiply per each bit set */
block|{
name|COSTS_N_INSNS
argument_list|(
literal|25
argument_list|)
block|,
comment|/* cost of a divide/mod for QI */
name|COSTS_N_INSNS
argument_list|(
literal|25
argument_list|)
block|,
comment|/*                          HI */
name|COSTS_N_INSNS
argument_list|(
literal|25
argument_list|)
block|,
comment|/*                          SI */
name|COSTS_N_INSNS
argument_list|(
literal|25
argument_list|)
block|,
comment|/*                          DI */
name|COSTS_N_INSNS
argument_list|(
literal|25
argument_list|)
block|}
block|,
comment|/*                          other */
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
block|,
comment|/* cost of movsx */
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
block|,
comment|/* cost of movzx */
literal|8
block|,
comment|/* "large" insn */
literal|6
block|,
comment|/* MOVE_RATIO */
literal|6
block|,
comment|/* cost for loading QImode using movzbl */
block|{
literal|2
block|,
literal|4
block|,
literal|2
block|}
block|,
comment|/* cost of loading integer registers 					   in QImode, HImode and SImode. 					   Relative to reg-reg move (2).  */
block|{
literal|2
block|,
literal|4
block|,
literal|2
block|}
block|,
comment|/* cost of storing integer registers */
literal|2
block|,
comment|/* cost of reg,reg fld/fst */
block|{
literal|2
block|,
literal|2
block|,
literal|6
block|}
block|,
comment|/* cost of loading fp registers 					   in SFmode, DFmode and XFmode */
block|{
literal|4
block|,
literal|4
block|,
literal|6
block|}
block|,
comment|/* cost of storing fp registers 					   in SFmode, DFmode and XFmode */
literal|8
block|,
comment|/* cost of moving MMX register */
block|{
literal|8
block|,
literal|8
block|}
block|,
comment|/* cost of loading MMX registers 					   in SImode and DImode */
block|{
literal|8
block|,
literal|8
block|}
block|,
comment|/* cost of storing MMX registers 					   in SImode and DImode */
literal|2
block|,
comment|/* cost of moving SSE register */
block|{
literal|4
block|,
literal|8
block|,
literal|16
block|}
block|,
comment|/* cost of loading SSE registers 					   in SImode, DImode and TImode */
block|{
literal|4
block|,
literal|8
block|,
literal|16
block|}
block|,
comment|/* cost of storing SSE registers 					   in SImode, DImode and TImode */
literal|3
block|,
comment|/* MMX or SSE register to integer */
literal|0
block|,
comment|/* size of prefetch block */
literal|0
block|,
comment|/* number of parallel prefetches */
literal|2
block|,
comment|/* Branch cost */
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
block|,
comment|/* cost of FADD and FSUB insns.  */
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
block|,
comment|/* cost of FMUL instruction.  */
name|COSTS_N_INSNS
argument_list|(
literal|39
argument_list|)
block|,
comment|/* cost of FDIV instruction.  */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* cost of FABS instruction.  */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* cost of FCHS instruction.  */
name|COSTS_N_INSNS
argument_list|(
literal|70
argument_list|)
block|,
comment|/* cost of FSQRT instruction.  */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|processor_costs
name|pentiumpro_cost
init|=
block|{
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* cost of an add instruction */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* cost of a lea instruction */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* variable shift costs */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* constant shift costs */
block|{
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* cost of starting multiply for QI */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/*                               HI */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/*                               SI */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/*                               DI */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|}
block|,
comment|/*                               other */
literal|0
block|,
comment|/* cost of multiply per each bit set */
block|{
name|COSTS_N_INSNS
argument_list|(
literal|17
argument_list|)
block|,
comment|/* cost of a divide/mod for QI */
name|COSTS_N_INSNS
argument_list|(
literal|17
argument_list|)
block|,
comment|/*                          HI */
name|COSTS_N_INSNS
argument_list|(
literal|17
argument_list|)
block|,
comment|/*                          SI */
name|COSTS_N_INSNS
argument_list|(
literal|17
argument_list|)
block|,
comment|/*                          DI */
name|COSTS_N_INSNS
argument_list|(
literal|17
argument_list|)
block|}
block|,
comment|/*                          other */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* cost of movsx */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* cost of movzx */
literal|8
block|,
comment|/* "large" insn */
literal|6
block|,
comment|/* MOVE_RATIO */
literal|2
block|,
comment|/* cost for loading QImode using movzbl */
block|{
literal|4
block|,
literal|4
block|,
literal|4
block|}
block|,
comment|/* cost of loading integer registers 					   in QImode, HImode and SImode. 					   Relative to reg-reg move (2).  */
block|{
literal|2
block|,
literal|2
block|,
literal|2
block|}
block|,
comment|/* cost of storing integer registers */
literal|2
block|,
comment|/* cost of reg,reg fld/fst */
block|{
literal|2
block|,
literal|2
block|,
literal|6
block|}
block|,
comment|/* cost of loading fp registers 					   in SFmode, DFmode and XFmode */
block|{
literal|4
block|,
literal|4
block|,
literal|6
block|}
block|,
comment|/* cost of storing fp registers 					   in SFmode, DFmode and XFmode */
literal|2
block|,
comment|/* cost of moving MMX register */
block|{
literal|2
block|,
literal|2
block|}
block|,
comment|/* cost of loading MMX registers 					   in SImode and DImode */
block|{
literal|2
block|,
literal|2
block|}
block|,
comment|/* cost of storing MMX registers 					   in SImode and DImode */
literal|2
block|,
comment|/* cost of moving SSE register */
block|{
literal|2
block|,
literal|2
block|,
literal|8
block|}
block|,
comment|/* cost of loading SSE registers 					   in SImode, DImode and TImode */
block|{
literal|2
block|,
literal|2
block|,
literal|8
block|}
block|,
comment|/* cost of storing SSE registers 					   in SImode, DImode and TImode */
literal|3
block|,
comment|/* MMX or SSE register to integer */
literal|32
block|,
comment|/* size of prefetch block */
literal|6
block|,
comment|/* number of parallel prefetches */
literal|2
block|,
comment|/* Branch cost */
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
block|,
comment|/* cost of FADD and FSUB insns.  */
name|COSTS_N_INSNS
argument_list|(
literal|5
argument_list|)
block|,
comment|/* cost of FMUL instruction.  */
name|COSTS_N_INSNS
argument_list|(
literal|56
argument_list|)
block|,
comment|/* cost of FDIV instruction.  */
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
block|,
comment|/* cost of FABS instruction.  */
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
block|,
comment|/* cost of FCHS instruction.  */
name|COSTS_N_INSNS
argument_list|(
literal|56
argument_list|)
block|,
comment|/* cost of FSQRT instruction.  */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|processor_costs
name|k6_cost
init|=
block|{
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* cost of an add instruction */
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
block|,
comment|/* cost of a lea instruction */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* variable shift costs */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* constant shift costs */
block|{
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
block|,
comment|/* cost of starting multiply for QI */
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
block|,
comment|/*                               HI */
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
block|,
comment|/*                               SI */
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
block|,
comment|/*                               DI */
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
block|}
block|,
comment|/*                               other */
literal|0
block|,
comment|/* cost of multiply per each bit set */
block|{
name|COSTS_N_INSNS
argument_list|(
literal|18
argument_list|)
block|,
comment|/* cost of a divide/mod for QI */
name|COSTS_N_INSNS
argument_list|(
literal|18
argument_list|)
block|,
comment|/*                          HI */
name|COSTS_N_INSNS
argument_list|(
literal|18
argument_list|)
block|,
comment|/*                          SI */
name|COSTS_N_INSNS
argument_list|(
literal|18
argument_list|)
block|,
comment|/*                          DI */
name|COSTS_N_INSNS
argument_list|(
literal|18
argument_list|)
block|}
block|,
comment|/*                          other */
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
block|,
comment|/* cost of movsx */
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
block|,
comment|/* cost of movzx */
literal|8
block|,
comment|/* "large" insn */
literal|4
block|,
comment|/* MOVE_RATIO */
literal|3
block|,
comment|/* cost for loading QImode using movzbl */
block|{
literal|4
block|,
literal|5
block|,
literal|4
block|}
block|,
comment|/* cost of loading integer registers 					   in QImode, HImode and SImode. 					   Relative to reg-reg move (2).  */
block|{
literal|2
block|,
literal|3
block|,
literal|2
block|}
block|,
comment|/* cost of storing integer registers */
literal|4
block|,
comment|/* cost of reg,reg fld/fst */
block|{
literal|6
block|,
literal|6
block|,
literal|6
block|}
block|,
comment|/* cost of loading fp registers 					   in SFmode, DFmode and XFmode */
block|{
literal|4
block|,
literal|4
block|,
literal|4
block|}
block|,
comment|/* cost of storing fp registers 					   in SFmode, DFmode and XFmode */
literal|2
block|,
comment|/* cost of moving MMX register */
block|{
literal|2
block|,
literal|2
block|}
block|,
comment|/* cost of loading MMX registers 					   in SImode and DImode */
block|{
literal|2
block|,
literal|2
block|}
block|,
comment|/* cost of storing MMX registers 					   in SImode and DImode */
literal|2
block|,
comment|/* cost of moving SSE register */
block|{
literal|2
block|,
literal|2
block|,
literal|8
block|}
block|,
comment|/* cost of loading SSE registers 					   in SImode, DImode and TImode */
block|{
literal|2
block|,
literal|2
block|,
literal|8
block|}
block|,
comment|/* cost of storing SSE registers 					   in SImode, DImode and TImode */
literal|6
block|,
comment|/* MMX or SSE register to integer */
literal|32
block|,
comment|/* size of prefetch block */
literal|1
block|,
comment|/* number of parallel prefetches */
literal|1
block|,
comment|/* Branch cost */
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
block|,
comment|/* cost of FADD and FSUB insns.  */
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
block|,
comment|/* cost of FMUL instruction.  */
name|COSTS_N_INSNS
argument_list|(
literal|56
argument_list|)
block|,
comment|/* cost of FDIV instruction.  */
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
block|,
comment|/* cost of FABS instruction.  */
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
block|,
comment|/* cost of FCHS instruction.  */
name|COSTS_N_INSNS
argument_list|(
literal|56
argument_list|)
block|,
comment|/* cost of FSQRT instruction.  */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|processor_costs
name|athlon_cost
init|=
block|{
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* cost of an add instruction */
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
block|,
comment|/* cost of a lea instruction */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* variable shift costs */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* constant shift costs */
block|{
name|COSTS_N_INSNS
argument_list|(
literal|5
argument_list|)
block|,
comment|/* cost of starting multiply for QI */
name|COSTS_N_INSNS
argument_list|(
literal|5
argument_list|)
block|,
comment|/*                               HI */
name|COSTS_N_INSNS
argument_list|(
literal|5
argument_list|)
block|,
comment|/*                               SI */
name|COSTS_N_INSNS
argument_list|(
literal|5
argument_list|)
block|,
comment|/*                               DI */
name|COSTS_N_INSNS
argument_list|(
literal|5
argument_list|)
block|}
block|,
comment|/*                               other */
literal|0
block|,
comment|/* cost of multiply per each bit set */
block|{
name|COSTS_N_INSNS
argument_list|(
literal|18
argument_list|)
block|,
comment|/* cost of a divide/mod for QI */
name|COSTS_N_INSNS
argument_list|(
literal|26
argument_list|)
block|,
comment|/*                          HI */
name|COSTS_N_INSNS
argument_list|(
literal|42
argument_list|)
block|,
comment|/*                          SI */
name|COSTS_N_INSNS
argument_list|(
literal|74
argument_list|)
block|,
comment|/*                          DI */
name|COSTS_N_INSNS
argument_list|(
literal|74
argument_list|)
block|}
block|,
comment|/*                          other */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* cost of movsx */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* cost of movzx */
literal|8
block|,
comment|/* "large" insn */
literal|9
block|,
comment|/* MOVE_RATIO */
literal|4
block|,
comment|/* cost for loading QImode using movzbl */
block|{
literal|3
block|,
literal|4
block|,
literal|3
block|}
block|,
comment|/* cost of loading integer registers 					   in QImode, HImode and SImode. 					   Relative to reg-reg move (2).  */
block|{
literal|3
block|,
literal|4
block|,
literal|3
block|}
block|,
comment|/* cost of storing integer registers */
literal|4
block|,
comment|/* cost of reg,reg fld/fst */
block|{
literal|4
block|,
literal|4
block|,
literal|12
block|}
block|,
comment|/* cost of loading fp registers 					   in SFmode, DFmode and XFmode */
block|{
literal|6
block|,
literal|6
block|,
literal|8
block|}
block|,
comment|/* cost of storing fp registers 					   in SFmode, DFmode and XFmode */
literal|2
block|,
comment|/* cost of moving MMX register */
block|{
literal|4
block|,
literal|4
block|}
block|,
comment|/* cost of loading MMX registers 					   in SImode and DImode */
block|{
literal|4
block|,
literal|4
block|}
block|,
comment|/* cost of storing MMX registers 					   in SImode and DImode */
literal|2
block|,
comment|/* cost of moving SSE register */
block|{
literal|4
block|,
literal|4
block|,
literal|6
block|}
block|,
comment|/* cost of loading SSE registers 					   in SImode, DImode and TImode */
block|{
literal|4
block|,
literal|4
block|,
literal|5
block|}
block|,
comment|/* cost of storing SSE registers 					   in SImode, DImode and TImode */
literal|5
block|,
comment|/* MMX or SSE register to integer */
literal|64
block|,
comment|/* size of prefetch block */
literal|6
block|,
comment|/* number of parallel prefetches */
literal|5
block|,
comment|/* Branch cost */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* cost of FADD and FSUB insns.  */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* cost of FMUL instruction.  */
name|COSTS_N_INSNS
argument_list|(
literal|24
argument_list|)
block|,
comment|/* cost of FDIV instruction.  */
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
block|,
comment|/* cost of FABS instruction.  */
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
block|,
comment|/* cost of FCHS instruction.  */
name|COSTS_N_INSNS
argument_list|(
literal|35
argument_list|)
block|,
comment|/* cost of FSQRT instruction.  */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|processor_costs
name|k8_cost
init|=
block|{
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* cost of an add instruction */
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
block|,
comment|/* cost of a lea instruction */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* variable shift costs */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* constant shift costs */
block|{
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
block|,
comment|/* cost of starting multiply for QI */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/*                               HI */
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
block|,
comment|/*                               SI */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/*                               DI */
name|COSTS_N_INSNS
argument_list|(
literal|5
argument_list|)
block|}
block|,
comment|/*                               other */
literal|0
block|,
comment|/* cost of multiply per each bit set */
block|{
name|COSTS_N_INSNS
argument_list|(
literal|18
argument_list|)
block|,
comment|/* cost of a divide/mod for QI */
name|COSTS_N_INSNS
argument_list|(
literal|26
argument_list|)
block|,
comment|/*                          HI */
name|COSTS_N_INSNS
argument_list|(
literal|42
argument_list|)
block|,
comment|/*                          SI */
name|COSTS_N_INSNS
argument_list|(
literal|74
argument_list|)
block|,
comment|/*                          DI */
name|COSTS_N_INSNS
argument_list|(
literal|74
argument_list|)
block|}
block|,
comment|/*                          other */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* cost of movsx */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* cost of movzx */
literal|8
block|,
comment|/* "large" insn */
literal|9
block|,
comment|/* MOVE_RATIO */
literal|4
block|,
comment|/* cost for loading QImode using movzbl */
block|{
literal|3
block|,
literal|4
block|,
literal|3
block|}
block|,
comment|/* cost of loading integer registers 					   in QImode, HImode and SImode. 					   Relative to reg-reg move (2).  */
block|{
literal|3
block|,
literal|4
block|,
literal|3
block|}
block|,
comment|/* cost of storing integer registers */
literal|4
block|,
comment|/* cost of reg,reg fld/fst */
block|{
literal|4
block|,
literal|4
block|,
literal|12
block|}
block|,
comment|/* cost of loading fp registers 					   in SFmode, DFmode and XFmode */
block|{
literal|6
block|,
literal|6
block|,
literal|8
block|}
block|,
comment|/* cost of storing fp registers 					   in SFmode, DFmode and XFmode */
literal|2
block|,
comment|/* cost of moving MMX register */
block|{
literal|3
block|,
literal|3
block|}
block|,
comment|/* cost of loading MMX registers 					   in SImode and DImode */
block|{
literal|4
block|,
literal|4
block|}
block|,
comment|/* cost of storing MMX registers 					   in SImode and DImode */
literal|2
block|,
comment|/* cost of moving SSE register */
block|{
literal|4
block|,
literal|3
block|,
literal|6
block|}
block|,
comment|/* cost of loading SSE registers 					   in SImode, DImode and TImode */
block|{
literal|4
block|,
literal|4
block|,
literal|5
block|}
block|,
comment|/* cost of storing SSE registers 					   in SImode, DImode and TImode */
literal|5
block|,
comment|/* MMX or SSE register to integer */
literal|64
block|,
comment|/* size of prefetch block */
literal|6
block|,
comment|/* number of parallel prefetches */
literal|5
block|,
comment|/* Branch cost */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* cost of FADD and FSUB insns.  */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* cost of FMUL instruction.  */
name|COSTS_N_INSNS
argument_list|(
literal|19
argument_list|)
block|,
comment|/* cost of FDIV instruction.  */
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
block|,
comment|/* cost of FABS instruction.  */
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
block|,
comment|/* cost of FCHS instruction.  */
name|COSTS_N_INSNS
argument_list|(
literal|35
argument_list|)
block|,
comment|/* cost of FSQRT instruction.  */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|processor_costs
name|pentium4_cost
init|=
block|{
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* cost of an add instruction */
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
block|,
comment|/* cost of a lea instruction */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* variable shift costs */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/* constant shift costs */
block|{
name|COSTS_N_INSNS
argument_list|(
literal|15
argument_list|)
block|,
comment|/* cost of starting multiply for QI */
name|COSTS_N_INSNS
argument_list|(
literal|15
argument_list|)
block|,
comment|/*                               HI */
name|COSTS_N_INSNS
argument_list|(
literal|15
argument_list|)
block|,
comment|/*                               SI */
name|COSTS_N_INSNS
argument_list|(
literal|15
argument_list|)
block|,
comment|/*                               DI */
name|COSTS_N_INSNS
argument_list|(
literal|15
argument_list|)
block|}
block|,
comment|/*                               other */
literal|0
block|,
comment|/* cost of multiply per each bit set */
block|{
name|COSTS_N_INSNS
argument_list|(
literal|56
argument_list|)
block|,
comment|/* cost of a divide/mod for QI */
name|COSTS_N_INSNS
argument_list|(
literal|56
argument_list|)
block|,
comment|/*                          HI */
name|COSTS_N_INSNS
argument_list|(
literal|56
argument_list|)
block|,
comment|/*                          SI */
name|COSTS_N_INSNS
argument_list|(
literal|56
argument_list|)
block|,
comment|/*                          DI */
name|COSTS_N_INSNS
argument_list|(
literal|56
argument_list|)
block|}
block|,
comment|/*                          other */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* cost of movsx */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* cost of movzx */
literal|16
block|,
comment|/* "large" insn */
literal|6
block|,
comment|/* MOVE_RATIO */
literal|2
block|,
comment|/* cost for loading QImode using movzbl */
block|{
literal|4
block|,
literal|5
block|,
literal|4
block|}
block|,
comment|/* cost of loading integer registers 					   in QImode, HImode and SImode. 					   Relative to reg-reg move (2).  */
block|{
literal|2
block|,
literal|3
block|,
literal|2
block|}
block|,
comment|/* cost of storing integer registers */
literal|2
block|,
comment|/* cost of reg,reg fld/fst */
block|{
literal|2
block|,
literal|2
block|,
literal|6
block|}
block|,
comment|/* cost of loading fp registers 					   in SFmode, DFmode and XFmode */
block|{
literal|4
block|,
literal|4
block|,
literal|6
block|}
block|,
comment|/* cost of storing fp registers 					   in SFmode, DFmode and XFmode */
literal|2
block|,
comment|/* cost of moving MMX register */
block|{
literal|2
block|,
literal|2
block|}
block|,
comment|/* cost of loading MMX registers 					   in SImode and DImode */
block|{
literal|2
block|,
literal|2
block|}
block|,
comment|/* cost of storing MMX registers 					   in SImode and DImode */
literal|12
block|,
comment|/* cost of moving SSE register */
block|{
literal|12
block|,
literal|12
block|,
literal|12
block|}
block|,
comment|/* cost of loading SSE registers 					   in SImode, DImode and TImode */
block|{
literal|2
block|,
literal|2
block|,
literal|8
block|}
block|,
comment|/* cost of storing SSE registers 					   in SImode, DImode and TImode */
literal|10
block|,
comment|/* MMX or SSE register to integer */
literal|64
block|,
comment|/* size of prefetch block */
literal|6
block|,
comment|/* number of parallel prefetches */
literal|2
block|,
comment|/* Branch cost */
name|COSTS_N_INSNS
argument_list|(
literal|5
argument_list|)
block|,
comment|/* cost of FADD and FSUB insns.  */
name|COSTS_N_INSNS
argument_list|(
literal|7
argument_list|)
block|,
comment|/* cost of FMUL instruction.  */
name|COSTS_N_INSNS
argument_list|(
literal|43
argument_list|)
block|,
comment|/* cost of FDIV instruction.  */
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
block|,
comment|/* cost of FABS instruction.  */
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
block|,
comment|/* cost of FCHS instruction.  */
name|COSTS_N_INSNS
argument_list|(
literal|43
argument_list|)
block|,
comment|/* cost of FSQRT instruction.  */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|processor_costs
name|nocona_cost
init|=
block|{
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* cost of an add instruction */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* cost of a lea instruction */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* variable shift costs */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* constant shift costs */
block|{
name|COSTS_N_INSNS
argument_list|(
literal|10
argument_list|)
block|,
comment|/* cost of starting multiply for QI */
name|COSTS_N_INSNS
argument_list|(
literal|10
argument_list|)
block|,
comment|/*                               HI */
name|COSTS_N_INSNS
argument_list|(
literal|10
argument_list|)
block|,
comment|/*                               SI */
name|COSTS_N_INSNS
argument_list|(
literal|10
argument_list|)
block|,
comment|/*                               DI */
name|COSTS_N_INSNS
argument_list|(
literal|10
argument_list|)
block|}
block|,
comment|/*                               other */
literal|0
block|,
comment|/* cost of multiply per each bit set */
block|{
name|COSTS_N_INSNS
argument_list|(
literal|66
argument_list|)
block|,
comment|/* cost of a divide/mod for QI */
name|COSTS_N_INSNS
argument_list|(
literal|66
argument_list|)
block|,
comment|/*                          HI */
name|COSTS_N_INSNS
argument_list|(
literal|66
argument_list|)
block|,
comment|/*                          SI */
name|COSTS_N_INSNS
argument_list|(
literal|66
argument_list|)
block|,
comment|/*                          DI */
name|COSTS_N_INSNS
argument_list|(
literal|66
argument_list|)
block|}
block|,
comment|/*                          other */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* cost of movsx */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* cost of movzx */
literal|16
block|,
comment|/* "large" insn */
literal|17
block|,
comment|/* MOVE_RATIO */
literal|4
block|,
comment|/* cost for loading QImode using movzbl */
block|{
literal|4
block|,
literal|4
block|,
literal|4
block|}
block|,
comment|/* cost of loading integer registers 					   in QImode, HImode and SImode. 					   Relative to reg-reg move (2).  */
block|{
literal|4
block|,
literal|4
block|,
literal|4
block|}
block|,
comment|/* cost of storing integer registers */
literal|3
block|,
comment|/* cost of reg,reg fld/fst */
block|{
literal|12
block|,
literal|12
block|,
literal|12
block|}
block|,
comment|/* cost of loading fp registers 					   in SFmode, DFmode and XFmode */
block|{
literal|4
block|,
literal|4
block|,
literal|4
block|}
block|,
comment|/* cost of storing fp registers 					   in SFmode, DFmode and XFmode */
literal|6
block|,
comment|/* cost of moving MMX register */
block|{
literal|12
block|,
literal|12
block|}
block|,
comment|/* cost of loading MMX registers 					   in SImode and DImode */
block|{
literal|12
block|,
literal|12
block|}
block|,
comment|/* cost of storing MMX registers 					   in SImode and DImode */
literal|6
block|,
comment|/* cost of moving SSE register */
block|{
literal|12
block|,
literal|12
block|,
literal|12
block|}
block|,
comment|/* cost of loading SSE registers 					   in SImode, DImode and TImode */
block|{
literal|12
block|,
literal|12
block|,
literal|12
block|}
block|,
comment|/* cost of storing SSE registers 					   in SImode, DImode and TImode */
literal|8
block|,
comment|/* MMX or SSE register to integer */
literal|128
block|,
comment|/* size of prefetch block */
literal|8
block|,
comment|/* number of parallel prefetches */
literal|1
block|,
comment|/* Branch cost */
name|COSTS_N_INSNS
argument_list|(
literal|6
argument_list|)
block|,
comment|/* cost of FADD and FSUB insns.  */
name|COSTS_N_INSNS
argument_list|(
literal|8
argument_list|)
block|,
comment|/* cost of FMUL instruction.  */
name|COSTS_N_INSNS
argument_list|(
literal|40
argument_list|)
block|,
comment|/* cost of FDIV instruction.  */
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
block|,
comment|/* cost of FABS instruction.  */
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
block|,
comment|/* cost of FCHS instruction.  */
name|COSTS_N_INSNS
argument_list|(
literal|44
argument_list|)
block|,
comment|/* cost of FSQRT instruction.  */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Generic64 should produce code tuned for Nocona and K8.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|processor_costs
name|generic64_cost
init|=
block|{
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* cost of an add instruction */
comment|/* On all chips taken into consideration lea is 2 cycles and more.  With      this cost however our current implementation of synth_mult results in      use of unnecessary temporary registers causing regression on several      SPECfp benchmarks.  */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
operator|+
literal|1
block|,
comment|/* cost of a lea instruction */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* variable shift costs */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* constant shift costs */
block|{
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
block|,
comment|/* cost of starting multiply for QI */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/*                               HI */
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
block|,
comment|/*                               SI */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/*                               DI */
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
block|}
block|,
comment|/*                               other */
literal|0
block|,
comment|/* cost of multiply per each bit set */
block|{
name|COSTS_N_INSNS
argument_list|(
literal|18
argument_list|)
block|,
comment|/* cost of a divide/mod for QI */
name|COSTS_N_INSNS
argument_list|(
literal|26
argument_list|)
block|,
comment|/*                          HI */
name|COSTS_N_INSNS
argument_list|(
literal|42
argument_list|)
block|,
comment|/*                          SI */
name|COSTS_N_INSNS
argument_list|(
literal|74
argument_list|)
block|,
comment|/*                          DI */
name|COSTS_N_INSNS
argument_list|(
literal|74
argument_list|)
block|}
block|,
comment|/*                          other */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* cost of movsx */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* cost of movzx */
literal|8
block|,
comment|/* "large" insn */
literal|17
block|,
comment|/* MOVE_RATIO */
literal|4
block|,
comment|/* cost for loading QImode using movzbl */
block|{
literal|4
block|,
literal|4
block|,
literal|4
block|}
block|,
comment|/* cost of loading integer registers 					   in QImode, HImode and SImode. 					   Relative to reg-reg move (2).  */
block|{
literal|4
block|,
literal|4
block|,
literal|4
block|}
block|,
comment|/* cost of storing integer registers */
literal|4
block|,
comment|/* cost of reg,reg fld/fst */
block|{
literal|12
block|,
literal|12
block|,
literal|12
block|}
block|,
comment|/* cost of loading fp registers 					   in SFmode, DFmode and XFmode */
block|{
literal|6
block|,
literal|6
block|,
literal|8
block|}
block|,
comment|/* cost of storing fp registers 					   in SFmode, DFmode and XFmode */
literal|2
block|,
comment|/* cost of moving MMX register */
block|{
literal|8
block|,
literal|8
block|}
block|,
comment|/* cost of loading MMX registers 					   in SImode and DImode */
block|{
literal|8
block|,
literal|8
block|}
block|,
comment|/* cost of storing MMX registers 					   in SImode and DImode */
literal|2
block|,
comment|/* cost of moving SSE register */
block|{
literal|8
block|,
literal|8
block|,
literal|8
block|}
block|,
comment|/* cost of loading SSE registers 					   in SImode, DImode and TImode */
block|{
literal|8
block|,
literal|8
block|,
literal|8
block|}
block|,
comment|/* cost of storing SSE registers 					   in SImode, DImode and TImode */
literal|5
block|,
comment|/* MMX or SSE register to integer */
literal|64
block|,
comment|/* size of prefetch block */
literal|6
block|,
comment|/* number of parallel prefetches */
comment|/* Benchmarks shows large regressions on K8 sixtrack benchmark when this value      is increased to perhaps more appropriate value of 5.  */
literal|3
block|,
comment|/* Branch cost */
name|COSTS_N_INSNS
argument_list|(
literal|8
argument_list|)
block|,
comment|/* cost of FADD and FSUB insns.  */
name|COSTS_N_INSNS
argument_list|(
literal|8
argument_list|)
block|,
comment|/* cost of FMUL instruction.  */
name|COSTS_N_INSNS
argument_list|(
literal|20
argument_list|)
block|,
comment|/* cost of FDIV instruction.  */
name|COSTS_N_INSNS
argument_list|(
literal|8
argument_list|)
block|,
comment|/* cost of FABS instruction.  */
name|COSTS_N_INSNS
argument_list|(
literal|8
argument_list|)
block|,
comment|/* cost of FCHS instruction.  */
name|COSTS_N_INSNS
argument_list|(
literal|40
argument_list|)
block|,
comment|/* cost of FSQRT instruction.  */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Generic32 should produce code tuned for Athlon, PPro, Pentium4, Nocona and K8.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|processor_costs
name|generic32_cost
init|=
block|{
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* cost of an add instruction */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
operator|+
literal|1
block|,
comment|/* cost of a lea instruction */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* variable shift costs */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* constant shift costs */
block|{
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
block|,
comment|/* cost of starting multiply for QI */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/*                               HI */
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
block|,
comment|/*                               SI */
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
block|,
comment|/*                               DI */
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
block|}
block|,
comment|/*                               other */
literal|0
block|,
comment|/* cost of multiply per each bit set */
block|{
name|COSTS_N_INSNS
argument_list|(
literal|18
argument_list|)
block|,
comment|/* cost of a divide/mod for QI */
name|COSTS_N_INSNS
argument_list|(
literal|26
argument_list|)
block|,
comment|/*                          HI */
name|COSTS_N_INSNS
argument_list|(
literal|42
argument_list|)
block|,
comment|/*                          SI */
name|COSTS_N_INSNS
argument_list|(
literal|74
argument_list|)
block|,
comment|/*                          DI */
name|COSTS_N_INSNS
argument_list|(
literal|74
argument_list|)
block|}
block|,
comment|/*                          other */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* cost of movsx */
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
block|,
comment|/* cost of movzx */
literal|8
block|,
comment|/* "large" insn */
literal|17
block|,
comment|/* MOVE_RATIO */
literal|4
block|,
comment|/* cost for loading QImode using movzbl */
block|{
literal|4
block|,
literal|4
block|,
literal|4
block|}
block|,
comment|/* cost of loading integer registers 					   in QImode, HImode and SImode. 					   Relative to reg-reg move (2).  */
block|{
literal|4
block|,
literal|4
block|,
literal|4
block|}
block|,
comment|/* cost of storing integer registers */
literal|4
block|,
comment|/* cost of reg,reg fld/fst */
block|{
literal|12
block|,
literal|12
block|,
literal|12
block|}
block|,
comment|/* cost of loading fp registers 					   in SFmode, DFmode and XFmode */
block|{
literal|6
block|,
literal|6
block|,
literal|8
block|}
block|,
comment|/* cost of storing fp registers 					   in SFmode, DFmode and XFmode */
literal|2
block|,
comment|/* cost of moving MMX register */
block|{
literal|8
block|,
literal|8
block|}
block|,
comment|/* cost of loading MMX registers 					   in SImode and DImode */
block|{
literal|8
block|,
literal|8
block|}
block|,
comment|/* cost of storing MMX registers 					   in SImode and DImode */
literal|2
block|,
comment|/* cost of moving SSE register */
block|{
literal|8
block|,
literal|8
block|,
literal|8
block|}
block|,
comment|/* cost of loading SSE registers 					   in SImode, DImode and TImode */
block|{
literal|8
block|,
literal|8
block|,
literal|8
block|}
block|,
comment|/* cost of storing SSE registers 					   in SImode, DImode and TImode */
literal|5
block|,
comment|/* MMX or SSE register to integer */
literal|64
block|,
comment|/* size of prefetch block */
literal|6
block|,
comment|/* number of parallel prefetches */
literal|3
block|,
comment|/* Branch cost */
name|COSTS_N_INSNS
argument_list|(
literal|8
argument_list|)
block|,
comment|/* cost of FADD and FSUB insns.  */
name|COSTS_N_INSNS
argument_list|(
literal|8
argument_list|)
block|,
comment|/* cost of FMUL instruction.  */
name|COSTS_N_INSNS
argument_list|(
literal|20
argument_list|)
block|,
comment|/* cost of FDIV instruction.  */
name|COSTS_N_INSNS
argument_list|(
literal|8
argument_list|)
block|,
comment|/* cost of FABS instruction.  */
name|COSTS_N_INSNS
argument_list|(
literal|8
argument_list|)
block|,
comment|/* cost of FCHS instruction.  */
name|COSTS_N_INSNS
argument_list|(
literal|40
argument_list|)
block|,
comment|/* cost of FSQRT instruction.  */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|processor_costs
modifier|*
name|ix86_cost
init|=
operator|&
name|pentium_cost
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Processor feature/optimization bitmasks.  */
end_comment

begin_define
define|#
directive|define
name|m_386
value|(1<<PROCESSOR_I386)
end_define

begin_define
define|#
directive|define
name|m_486
value|(1<<PROCESSOR_I486)
end_define

begin_define
define|#
directive|define
name|m_PENT
value|(1<<PROCESSOR_PENTIUM)
end_define

begin_define
define|#
directive|define
name|m_PPRO
value|(1<<PROCESSOR_PENTIUMPRO)
end_define

begin_define
define|#
directive|define
name|m_K6
value|(1<<PROCESSOR_K6)
end_define

begin_define
define|#
directive|define
name|m_ATHLON
value|(1<<PROCESSOR_ATHLON)
end_define

begin_define
define|#
directive|define
name|m_PENT4
value|(1<<PROCESSOR_PENTIUM4)
end_define

begin_define
define|#
directive|define
name|m_K8
value|(1<<PROCESSOR_K8)
end_define

begin_define
define|#
directive|define
name|m_ATHLON_K8
value|(m_K8 | m_ATHLON)
end_define

begin_define
define|#
directive|define
name|m_NOCONA
value|(1<<PROCESSOR_NOCONA)
end_define

begin_define
define|#
directive|define
name|m_GENERIC32
value|(1<<PROCESSOR_GENERIC32)
end_define

begin_define
define|#
directive|define
name|m_GENERIC64
value|(1<<PROCESSOR_GENERIC64)
end_define

begin_define
define|#
directive|define
name|m_GENERIC
value|(m_GENERIC32 | m_GENERIC64)
end_define

begin_comment
comment|/* Generic instruction choice should be common subset of supported CPUs    (PPro/PENT4/NOCONA/Athlon/K8).  */
end_comment

begin_comment
comment|/* Leave is not affecting Nocona SPEC2000 results negatively, so enabling for    Generic64 seems like good code size tradeoff.  We can't enable it for 32bit    generic because it is not working well with PPro base chips.  */
end_comment

begin_decl_stmt
specifier|const
name|int
name|x86_use_leave
init|=
name|m_386
operator||
name|m_K6
operator||
name|m_ATHLON_K8
operator||
name|m_GENERIC64
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_push_memory
init|=
name|m_386
operator||
name|m_K6
operator||
name|m_ATHLON_K8
operator||
name|m_PENT4
operator||
name|m_NOCONA
operator||
name|m_GENERIC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_zero_extend_with_and
init|=
name|m_486
operator||
name|m_PENT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_movx
init|=
name|m_ATHLON_K8
operator||
name|m_PPRO
operator||
name|m_PENT4
operator||
name|m_NOCONA
operator||
name|m_GENERIC
comment|/* m_386 | m_K6 */
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_double_with_add
init|=
operator|~
name|m_386
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_use_bit_test
init|=
name|m_386
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_unroll_strlen
init|=
name|m_486
operator||
name|m_PENT
operator||
name|m_PPRO
operator||
name|m_ATHLON_K8
operator||
name|m_K6
operator||
name|m_GENERIC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_cmove
init|=
name|m_PPRO
operator||
name|m_ATHLON_K8
operator||
name|m_PENT4
operator||
name|m_NOCONA
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_3dnow_a
init|=
name|m_ATHLON_K8
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_deep_branch
init|=
name|m_PPRO
operator||
name|m_K6
operator||
name|m_ATHLON_K8
operator||
name|m_PENT4
operator||
name|m_NOCONA
operator||
name|m_GENERIC
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Branch hints were put in P4 based on simulation result. But    after P4 was made, no performance benefit was observed with    branch hints. It also increases the code size. As the result,    icc never generates branch hints.  */
end_comment

begin_decl_stmt
specifier|const
name|int
name|x86_branch_hints
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_use_sahf
init|=
name|m_PPRO
operator||
name|m_K6
operator||
name|m_PENT4
operator||
name|m_NOCONA
operator||
name|m_GENERIC32
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*m_GENERIC | m_ATHLON_K8 ? */
end_comment

begin_comment
comment|/* We probably ought to watch for partial register stalls on Generic32    compilation setting as well.  However in current implementation the    partial register stalls are not eliminated very well - they can    be introduced via subregs synthesized by combine and can happen    in caller/callee saving sequences.    Because this option pays back little on PPro based chips and is in conflict    with partial reg. dependencies used by Athlon/P4 based chips, it is better    to leave it off for generic32 for now.  */
end_comment

begin_decl_stmt
specifier|const
name|int
name|x86_partial_reg_stall
init|=
name|m_PPRO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_partial_flag_reg_stall
init|=
name|m_GENERIC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_use_himode_fiop
init|=
name|m_386
operator||
name|m_486
operator||
name|m_K6
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_use_simode_fiop
init|=
operator|~
operator|(
name|m_PPRO
operator||
name|m_ATHLON_K8
operator||
name|m_PENT
operator||
name|m_GENERIC
operator|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_use_mov0
init|=
name|m_K6
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_use_cltd
init|=
operator|~
operator|(
name|m_PENT
operator||
name|m_K6
operator||
name|m_GENERIC
operator|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_read_modify_write
init|=
operator|~
name|m_PENT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_read_modify
init|=
operator|~
operator|(
name|m_PENT
operator||
name|m_PPRO
operator|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_split_long_moves
init|=
name|m_PPRO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_promote_QImode
init|=
name|m_K6
operator||
name|m_PENT
operator||
name|m_386
operator||
name|m_486
operator||
name|m_ATHLON_K8
operator||
name|m_GENERIC
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* m_PENT4 ? */
end_comment

begin_decl_stmt
specifier|const
name|int
name|x86_fast_prefix
init|=
operator|~
operator|(
name|m_PENT
operator||
name|m_486
operator||
name|m_386
operator|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_single_stringop
init|=
name|m_386
operator||
name|m_PENT4
operator||
name|m_NOCONA
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_qimode_math
init|=
operator|~
operator|(
literal|0
operator|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_promote_qi_regs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* On PPro this flag is meant to avoid partial register stalls.  Just like    the x86_partial_reg_stall this option might be considered for Generic32    if our scheme for avoiding partial stalls was more effective.  */
end_comment

begin_decl_stmt
specifier|const
name|int
name|x86_himode_math
init|=
operator|~
operator|(
name|m_PPRO
operator|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_promote_hi_regs
init|=
name|m_PPRO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_sub_esp_4
init|=
name|m_ATHLON_K8
operator||
name|m_PPRO
operator||
name|m_PENT4
operator||
name|m_NOCONA
operator||
name|m_GENERIC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_sub_esp_8
init|=
name|m_ATHLON_K8
operator||
name|m_PPRO
operator||
name|m_386
operator||
name|m_486
operator||
name|m_PENT4
operator||
name|m_NOCONA
operator||
name|m_GENERIC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_add_esp_4
init|=
name|m_ATHLON_K8
operator||
name|m_K6
operator||
name|m_PENT4
operator||
name|m_NOCONA
operator||
name|m_GENERIC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_add_esp_8
init|=
name|m_ATHLON_K8
operator||
name|m_PPRO
operator||
name|m_K6
operator||
name|m_386
operator||
name|m_486
operator||
name|m_PENT4
operator||
name|m_NOCONA
operator||
name|m_GENERIC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_integer_DFmode_moves
init|=
operator|~
operator|(
name|m_ATHLON_K8
operator||
name|m_PENT4
operator||
name|m_NOCONA
operator||
name|m_PPRO
operator||
name|m_GENERIC
operator|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_partial_reg_dependency
init|=
name|m_ATHLON_K8
operator||
name|m_PENT4
operator||
name|m_NOCONA
operator||
name|m_GENERIC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_memory_mismatch_stall
init|=
name|m_ATHLON_K8
operator||
name|m_PENT4
operator||
name|m_NOCONA
operator||
name|m_GENERIC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_accumulate_outgoing_args
init|=
name|m_ATHLON_K8
operator||
name|m_PENT4
operator||
name|m_NOCONA
operator||
name|m_PPRO
operator||
name|m_GENERIC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_prologue_using_move
init|=
name|m_ATHLON_K8
operator||
name|m_PPRO
operator||
name|m_GENERIC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_epilogue_using_move
init|=
name|m_ATHLON_K8
operator||
name|m_PPRO
operator||
name|m_GENERIC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_shift1
init|=
operator|~
name|m_486
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_arch_always_fancy_math_387
init|=
name|m_PENT
operator||
name|m_PPRO
operator||
name|m_ATHLON_K8
operator||
name|m_PENT4
operator||
name|m_NOCONA
operator||
name|m_GENERIC
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* In Generic model we have an conflict here in between PPro/Pentium4 based chips    that thread 128bit SSE registers as single units versus K8 based chips that    divide SSE registers to two 64bit halves.    x86_sse_partial_reg_dependency promote all store destinations to be 128bit    to allow register renaming on 128bit SSE units, but usually results in one    extra microop on 64bit SSE units.  Experimental results shows that disabling    this option on P4 brings over 20% SPECfp regression, while enabling it on    K8 brings roughly 2.4% regression that can be partly masked by careful scheduling    of moves.  */
end_comment

begin_decl_stmt
specifier|const
name|int
name|x86_sse_partial_reg_dependency
init|=
name|m_PENT4
operator||
name|m_NOCONA
operator||
name|m_PPRO
operator||
name|m_GENERIC
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set for machines where the type and dependencies are resolved on SSE    register parts instead of whole registers, so we may maintain just    lower part of scalar values in proper format leaving the upper part    undefined.  */
end_comment

begin_decl_stmt
specifier|const
name|int
name|x86_sse_split_regs
init|=
name|m_ATHLON_K8
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_sse_typeless_stores
init|=
name|m_ATHLON_K8
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_sse_load0_by_pxor
init|=
name|m_PPRO
operator||
name|m_PENT4
operator||
name|m_NOCONA
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_use_ffreep
init|=
name|m_ATHLON_K8
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_rep_movl_optimal
init|=
name|m_386
operator||
name|m_PENT
operator||
name|m_PPRO
operator||
name|m_K6
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_use_incdec
init|=
operator|~
operator|(
name|m_PENT4
operator||
name|m_NOCONA
operator||
name|m_GENERIC
operator|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ??? Allowing interunit moves makes it all too easy for the compiler to put    integer data in xmm registers.  Which results in pretty abysmal code.  */
end_comment

begin_decl_stmt
specifier|const
name|int
name|x86_inter_unit_moves
init|=
literal|0
comment|/* ~(m_ATHLON_K8) */
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_ext_80387_constants
init|=
name|m_K6
operator||
name|m_ATHLON
operator||
name|m_PENT4
operator||
name|m_NOCONA
operator||
name|m_PPRO
operator||
name|m_GENERIC32
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Some CPU cores are not able to predict more than 4 branch instructions in    the 16 byte window.  */
end_comment

begin_decl_stmt
specifier|const
name|int
name|x86_four_jump_limit
init|=
name|m_PPRO
operator||
name|m_ATHLON_K8
operator||
name|m_PENT4
operator||
name|m_NOCONA
operator||
name|m_GENERIC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_schedule
init|=
name|m_PPRO
operator||
name|m_ATHLON_K8
operator||
name|m_K6
operator||
name|m_PENT
operator||
name|m_GENERIC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_use_bt
init|=
name|m_ATHLON_K8
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Compare and exchange was added for 80486.  */
end_comment

begin_decl_stmt
specifier|const
name|int
name|x86_cmpxchg
init|=
operator|~
name|m_386
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Compare and exchange 8 bytes was added for pentium.  */
end_comment

begin_decl_stmt
specifier|const
name|int
name|x86_cmpxchg8b
init|=
operator|~
operator|(
name|m_386
operator||
name|m_486
operator|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Compare and exchange 16 bytes was added for nocona.  */
end_comment

begin_decl_stmt
specifier|const
name|int
name|x86_cmpxchg16b
init|=
name|m_NOCONA
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Exchange and add was added for 80486.  */
end_comment

begin_decl_stmt
specifier|const
name|int
name|x86_xadd
init|=
operator|~
name|m_386
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_pad_returns
init|=
name|m_ATHLON_K8
operator||
name|m_GENERIC
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* In case the average insn count for single function invocation is    lower than this constant, emit fast (but longer) prologue and    epilogue code.  */
end_comment

begin_define
define|#
directive|define
name|FAST_PROLOGUE_INSN_COUNT
value|20
end_define

begin_comment
comment|/* Names for 8 (low), 8 (high), and 16-bit registers, respectively.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|qi_reg_name
index|[]
init|=
name|QI_REGISTER_NAMES
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|qi_high_reg_name
index|[]
init|=
name|QI_HIGH_REGISTER_NAMES
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|hi_reg_name
index|[]
init|=
name|HI_REGISTER_NAMES
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Array of the smallest class containing reg number REGNO, indexed by    REGNO.  Used by REGNO_REG_CLASS in i386.h.  */
end_comment

begin_decl_stmt
name|enum
name|reg_class
specifier|const
name|regclass_map
index|[
name|FIRST_PSEUDO_REGISTER
index|]
init|=
block|{
comment|/* ax, dx, cx, bx */
name|AREG
block|,
name|DREG
block|,
name|CREG
block|,
name|BREG
block|,
comment|/* si, di, bp, sp */
name|SIREG
block|,
name|DIREG
block|,
name|NON_Q_REGS
block|,
name|NON_Q_REGS
block|,
comment|/* FP registers */
name|FP_TOP_REG
block|,
name|FP_SECOND_REG
block|,
name|FLOAT_REGS
block|,
name|FLOAT_REGS
block|,
name|FLOAT_REGS
block|,
name|FLOAT_REGS
block|,
name|FLOAT_REGS
block|,
name|FLOAT_REGS
block|,
comment|/* arg pointer */
name|NON_Q_REGS
block|,
comment|/* flags, fpsr, dirflag, frame */
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NON_Q_REGS
block|,
name|SSE_REGS
block|,
name|SSE_REGS
block|,
name|SSE_REGS
block|,
name|SSE_REGS
block|,
name|SSE_REGS
block|,
name|SSE_REGS
block|,
name|SSE_REGS
block|,
name|SSE_REGS
block|,
name|MMX_REGS
block|,
name|MMX_REGS
block|,
name|MMX_REGS
block|,
name|MMX_REGS
block|,
name|MMX_REGS
block|,
name|MMX_REGS
block|,
name|MMX_REGS
block|,
name|MMX_REGS
block|,
name|NON_Q_REGS
block|,
name|NON_Q_REGS
block|,
name|NON_Q_REGS
block|,
name|NON_Q_REGS
block|,
name|NON_Q_REGS
block|,
name|NON_Q_REGS
block|,
name|NON_Q_REGS
block|,
name|NON_Q_REGS
block|,
name|SSE_REGS
block|,
name|SSE_REGS
block|,
name|SSE_REGS
block|,
name|SSE_REGS
block|,
name|SSE_REGS
block|,
name|SSE_REGS
block|,
name|SSE_REGS
block|,
name|SSE_REGS
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The "default" register map used in 32bit mode.  */
end_comment

begin_decl_stmt
name|int
specifier|const
name|dbx_register_map
index|[
name|FIRST_PSEUDO_REGISTER
index|]
init|=
block|{
literal|0
block|,
literal|2
block|,
literal|1
block|,
literal|3
block|,
literal|6
block|,
literal|7
block|,
literal|4
block|,
literal|5
block|,
comment|/* general regs */
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|16
block|,
literal|17
block|,
literal|18
block|,
literal|19
block|,
comment|/* fp regs */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* arg, flags, fpsr, dir, frame */
literal|21
block|,
literal|22
block|,
literal|23
block|,
literal|24
block|,
literal|25
block|,
literal|26
block|,
literal|27
block|,
literal|28
block|,
comment|/* SSE */
literal|29
block|,
literal|30
block|,
literal|31
block|,
literal|32
block|,
literal|33
block|,
literal|34
block|,
literal|35
block|,
literal|36
block|,
comment|/* MMX */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* extended integer registers */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* extended SSE registers */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
specifier|const
name|x86_64_int_parameter_registers
index|[
literal|6
index|]
init|=
block|{
literal|5
comment|/*RDI*/
block|,
literal|4
comment|/*RSI*/
block|,
literal|1
comment|/*RDX*/
block|,
literal|2
comment|/*RCX*/
block|,
name|FIRST_REX_INT_REG
comment|/*R8 */
block|,
name|FIRST_REX_INT_REG
operator|+
literal|1
comment|/*R9 */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
specifier|const
name|x86_64_int_return_registers
index|[
literal|4
index|]
init|=
block|{
literal|0
comment|/*RAX*/
block|,
literal|1
comment|/*RDI*/
block|,
literal|5
comment|/*RDI*/
block|,
literal|4
comment|/*RSI*/
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The "default" register map used in 64bit mode.  */
end_comment

begin_decl_stmt
name|int
specifier|const
name|dbx64_register_map
index|[
name|FIRST_PSEUDO_REGISTER
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
comment|/* general regs */
literal|33
block|,
literal|34
block|,
literal|35
block|,
literal|36
block|,
literal|37
block|,
literal|38
block|,
literal|39
block|,
literal|40
block|,
comment|/* fp regs */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* arg, flags, fpsr, dir, frame */
literal|17
block|,
literal|18
block|,
literal|19
block|,
literal|20
block|,
literal|21
block|,
literal|22
block|,
literal|23
block|,
literal|24
block|,
comment|/* SSE */
literal|41
block|,
literal|42
block|,
literal|43
block|,
literal|44
block|,
literal|45
block|,
literal|46
block|,
literal|47
block|,
literal|48
block|,
comment|/* MMX */
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
comment|/* extended integer registers */
literal|25
block|,
literal|26
block|,
literal|27
block|,
literal|28
block|,
literal|29
block|,
literal|30
block|,
literal|31
block|,
literal|32
block|,
comment|/* extended SSE registers */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Define the register numbers to be used in Dwarf debugging information.    The SVR4 reference port C compiler uses the following register numbers    in its Dwarf output code: 	0 for %eax (gcc regno = 0) 	1 for %ecx (gcc regno = 2) 	2 for %edx (gcc regno = 1) 	3 for %ebx (gcc regno = 3) 	4 for %esp (gcc regno = 7) 	5 for %ebp (gcc regno = 6) 	6 for %esi (gcc regno = 4) 	7 for %edi (gcc regno = 5)    The following three DWARF register numbers are never generated by    the SVR4 C compiler or by the GNU compilers, but SDB on x86/svr4    believes these numbers have these meanings. 	8  for %eip    (no gcc equivalent) 	9  for %eflags (gcc regno = 17) 	10 for %trapno (no gcc equivalent)    It is not at all clear how we should number the FP stack registers    for the x86 architecture.  If the version of SDB on x86/svr4 were    a bit less brain dead with respect to floating-point then we would    have a precedent to follow with respect to DWARF register numbers    for x86 FP registers, but the SDB on x86/svr4 is so completely    broken with respect to FP registers that it is hardly worth thinking    of it as something to strive for compatibility with.    The version of x86/svr4 SDB I have at the moment does (partially)    seem to believe that DWARF register number 11 is associated with    the x86 register %st(0), but that's about all.  Higher DWARF    register numbers don't seem to be associated with anything in    particular, and even for DWARF regno 11, SDB only seems to under-    stand that it should say that a variable lives in %st(0) (when    asked via an `=' command) if we said it was in DWARF regno 11,    but SDB still prints garbage when asked for the value of the    variable in question (via a `/' command).    (Also note that the labels SDB prints for various FP stack regs    when doing an `x' command are all wrong.)    Note that these problems generally don't affect the native SVR4    C compiler because it doesn't allow the use of -O with -g and    because when it is *not* optimizing, it allocates a memory    location for each floating-point variable, and the memory    location is what gets described in the DWARF AT_location    attribute for the variable in question.    Regardless of the severe mental illness of the x86/svr4 SDB, we    do something sensible here and we use the following DWARF    register numbers.  Note that these are all stack-top-relative    numbers. 	11 for %st(0) (gcc regno = 8) 	12 for %st(1) (gcc regno = 9) 	13 for %st(2) (gcc regno = 10) 	14 for %st(3) (gcc regno = 11) 	15 for %st(4) (gcc regno = 12) 	16 for %st(5) (gcc regno = 13) 	17 for %st(6) (gcc regno = 14) 	18 for %st(7) (gcc regno = 15) */
end_comment

begin_decl_stmt
name|int
specifier|const
name|svr4_dbx_register_map
index|[
name|FIRST_PSEUDO_REGISTER
index|]
init|=
block|{
literal|0
block|,
literal|2
block|,
literal|1
block|,
literal|3
block|,
literal|6
block|,
literal|7
block|,
literal|5
block|,
literal|4
block|,
comment|/* general regs */
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|16
block|,
literal|17
block|,
literal|18
block|,
comment|/* fp regs */
operator|-
literal|1
block|,
literal|9
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* arg, flags, fpsr, dir, frame */
literal|21
block|,
literal|22
block|,
literal|23
block|,
literal|24
block|,
literal|25
block|,
literal|26
block|,
literal|27
block|,
literal|28
block|,
comment|/* SSE registers */
literal|29
block|,
literal|30
block|,
literal|31
block|,
literal|32
block|,
literal|33
block|,
literal|34
block|,
literal|35
block|,
literal|36
block|,
comment|/* MMX registers */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* extended integer registers */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* extended SSE registers */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Test and compare insns in i386.md store the information needed to    generate branch and scc insns here.  */
end_comment

begin_decl_stmt
name|rtx
name|ix86_compare_op0
init|=
name|NULL_RTX
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|ix86_compare_op1
init|=
name|NULL_RTX
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|ix86_compare_emitted
init|=
name|NULL_RTX
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size of the register save area.  */
end_comment

begin_define
define|#
directive|define
name|X86_64_VARARGS_SIZE
value|(REGPARM_MAX * UNITS_PER_WORD + SSE_REGPARM_MAX * 16)
end_define

begin_comment
comment|/* Define the structure for the machine field in struct function.  */
end_comment

begin_decl_stmt
name|struct
name|stack_local_entry
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
name|unsigned
name|short
name|mode
decl_stmt|;
name|unsigned
name|short
name|n
decl_stmt|;
name|rtx
name|rtl
decl_stmt|;
name|struct
name|stack_local_entry
modifier|*
name|next
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* Structure describing stack frame layout.    Stack grows downward:     [arguments]<- ARG_POINTER    saved pc     saved frame pointer if frame_pointer_needed<- HARD_FRAME_POINTER    [saved regs]     [padding1]          \ 		        )    [va_arg registers]  (> to_allocate<- FRAME_POINTER    [frame]	       ( 		        )    [padding2]	       /   */
end_comment

begin_struct
struct|struct
name|ix86_frame
block|{
name|int
name|nregs
decl_stmt|;
name|int
name|padding1
decl_stmt|;
name|int
name|va_arg_size
decl_stmt|;
name|HOST_WIDE_INT
name|frame
decl_stmt|;
name|int
name|padding2
decl_stmt|;
name|int
name|outgoing_arguments_size
decl_stmt|;
name|int
name|red_zone_size
decl_stmt|;
name|HOST_WIDE_INT
name|to_allocate
decl_stmt|;
comment|/* The offsets relative to ARG_POINTER.  */
name|HOST_WIDE_INT
name|frame_pointer_offset
decl_stmt|;
name|HOST_WIDE_INT
name|hard_frame_pointer_offset
decl_stmt|;
name|HOST_WIDE_INT
name|stack_pointer_offset
decl_stmt|;
comment|/* When save_regs_using_mov is set, emit prologue using      move instead of push instructions.  */
name|bool
name|save_regs_using_mov
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Code model option.  */
end_comment

begin_decl_stmt
name|enum
name|cmodel
name|ix86_cmodel
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Asm dialect.  */
end_comment

begin_decl_stmt
name|enum
name|asm_dialect
name|ix86_asm_dialect
init|=
name|ASM_ATT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TLS dialects.  */
end_comment

begin_decl_stmt
name|enum
name|tls_dialect
name|ix86_tls_dialect
init|=
name|TLS_DIALECT_GNU
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Which unit we are generating floating point math for.  */
end_comment

begin_decl_stmt
name|enum
name|fpmath_unit
name|ix86_fpmath
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Which cpu are we scheduling for.  */
end_comment

begin_decl_stmt
name|enum
name|processor_type
name|ix86_tune
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Which instruction set architecture to use.  */
end_comment

begin_decl_stmt
name|enum
name|processor_type
name|ix86_arch
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if sse prefetch instruction is not NOOP.  */
end_comment

begin_decl_stmt
name|int
name|x86_prefetch_sse
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ix86_regparm_string as a number */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ix86_regparm
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -mstackrealign option */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|ix86_force_align_arg_pointer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|ix86_force_align_arg_pointer_string
index|[]
init|=
literal|"force_align_arg_pointer"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Preferred alignment for stack boundary in bits.  */
end_comment

begin_decl_stmt
name|unsigned
name|int
name|ix86_preferred_stack_boundary
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Values 1-5: see jump.c */
end_comment

begin_decl_stmt
name|int
name|ix86_branch_cost
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Variables which are this size or smaller are put in the data/bss    or ldata/lbss sections.  */
end_comment

begin_decl_stmt
name|int
name|ix86_section_threshold
init|=
literal|65536
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Prefix built by ASM_GENERATE_INTERNAL_LABEL.  */
end_comment

begin_decl_stmt
name|char
name|internal_label_prefix
index|[
literal|16
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|internal_label_prefix_len
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function_decl
specifier|static
name|bool
name|ix86_handle_option
parameter_list|(
name|size_t
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|output_pic_addr_const
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|put_condition_code
parameter_list|(
name|enum
name|rtx_code
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|get_some_local_dynamic_name
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_some_local_dynamic_name_1
parameter_list|(
name|rtx
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|ix86_expand_int_compare
parameter_list|(
name|enum
name|rtx_code
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|rtx_code
name|ix86_prepare_fp_compare_args
parameter_list|(
name|enum
name|rtx_code
parameter_list|,
name|rtx
modifier|*
parameter_list|,
name|rtx
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|ix86_fixed_condition_code_regs
parameter_list|(
name|unsigned
name|int
modifier|*
parameter_list|,
name|unsigned
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|machine_mode
name|ix86_cc_modes_compatible
parameter_list|(
name|enum
name|machine_mode
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|get_thread_pointer
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|legitimize_tls_address
parameter_list|(
name|rtx
parameter_list|,
name|enum
name|tls_model
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|get_pc_thunk_name
parameter_list|(
name|char
index|[
literal|32
index|]
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|gen_push
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ix86_flags_dependent
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|attr_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ix86_agi_dependent
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|attr_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|machine_function
modifier|*
name|ix86_init_machine_status
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ix86_split_to_parts
parameter_list|(
name|rtx
parameter_list|,
name|rtx
modifier|*
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ix86_nsaved_regs
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ix86_emit_save_regs
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ix86_emit_save_regs_using_mov
parameter_list|(
name|rtx
parameter_list|,
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ix86_emit_restore_regs_using_mov
parameter_list|(
name|rtx
parameter_list|,
name|HOST_WIDE_INT
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ix86_output_function_epilogue
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|HOST_WIDE_INT
name|ix86_GOT_alias_set
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ix86_adjust_counter
parameter_list|(
name|rtx
parameter_list|,
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|ix86_expand_aligntest
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ix86_expand_strlensi_unroll_1
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ix86_issue_rate
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ix86_adjust_cost
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ia32_multipass_dfa_lookahead
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ix86_init_mmx_sse_builtins
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|x86_this_parameter
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|x86_output_mi_thunk
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|HOST_WIDE_INT
parameter_list|,
name|HOST_WIDE_INT
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|x86_can_output_mi_thunk
parameter_list|(
name|tree
parameter_list|,
name|HOST_WIDE_INT
parameter_list|,
name|HOST_WIDE_INT
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|x86_file_start
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ix86_reorg
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|ix86_expand_carry_flag_compare
parameter_list|(
name|enum
name|rtx_code
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|ix86_build_builtin_va_list
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ix86_setup_incoming_varargs
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|tree
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|ix86_gimplify_va_arg
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
modifier|*
parameter_list|,
name|tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|ix86_scalar_mode_supported_p
parameter_list|(
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|ix86_vector_mode_supported_p
parameter_list|(
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ix86_address_cost
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|ix86_cannot_force_const_mem
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|ix86_delegitimize_address
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|i386_output_dwarf_dtprel
argument_list|(
name|FILE
operator|*
argument_list|,
name|int
argument_list|,
name|rtx
argument_list|)
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_struct_decl
struct_decl|struct
name|builtin_description
struct_decl|;
end_struct_decl

begin_function_decl
specifier|static
name|rtx
name|ix86_expand_sse_comi
parameter_list|(
specifier|const
name|struct
name|builtin_description
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|ix86_expand_sse_compare
parameter_list|(
specifier|const
name|struct
name|builtin_description
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|ix86_expand_unop1_builtin
parameter_list|(
name|enum
name|insn_code
parameter_list|,
name|tree
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|ix86_expand_unop_builtin
parameter_list|(
name|enum
name|insn_code
parameter_list|,
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|ix86_expand_binop_builtin
parameter_list|(
name|enum
name|insn_code
parameter_list|,
name|tree
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|ix86_expand_store_builtin
parameter_list|(
name|enum
name|insn_code
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|safe_vector_operand
parameter_list|(
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|ix86_expand_fp_compare
parameter_list|(
name|enum
name|rtx_code
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
modifier|*
parameter_list|,
name|rtx
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ix86_fp_comparison_arithmetics_cost
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ix86_fp_comparison_fcomi_cost
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ix86_fp_comparison_sahf_cost
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ix86_fp_comparison_cost
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|int
name|ix86_select_alt_pic_regnum
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ix86_save_reg
parameter_list|(
name|unsigned
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ix86_compute_frame_layout
parameter_list|(
name|struct
name|ix86_frame
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ix86_comp_type_attributes
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ix86_function_regparm
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|const
name|struct
name|attribute_spec
name|ix86_attribute_table
index|[]
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|bool
name|ix86_function_ok_for_sibcall
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|ix86_handle_cconv_attribute
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ix86_value_regno
parameter_list|(
name|enum
name|machine_mode
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|contains_128bit_aligned_vector_p
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|ix86_struct_value_rtx
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|ix86_ms_bitfield_layout_p
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|ix86_handle_struct_attribute
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|extended_reg_mentioned_1
parameter_list|(
name|rtx
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|ix86_rtx_costs
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|min_insn_size
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|ix86_md_asm_clobbers
parameter_list|(
name|tree
name|outputs
parameter_list|,
name|tree
name|inputs
parameter_list|,
name|tree
name|clobbers
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|ix86_must_pass_in_stack
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|ix86_pass_by_reference
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|tree
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ix86_init_builtins
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|ix86_expand_builtin
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|ix86_mangle_fundamental_type
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|ix86_stack_protect_fail
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|ix86_internal_arg_pointer
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ix86_dwarf_handle_frame_unspec
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* This function is only used on Solaris.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|i386_solaris_elf_named_section
argument_list|(
specifier|const
name|char
operator|*
argument_list|,
name|unsigned
name|int
argument_list|,
name|tree
argument_list|)
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Register class used for passing given 64bit part of the argument.    These represent classes as documented by the PS ABI, with the exception    of SSESF, SSEDF classes, that are basically SSE class, just gcc will    use SF or DFmode move instead of DImode to avoid reformatting penalties.     Similarly we play games with INTEGERSI_CLASS to use cheaper SImode moves    whenever possible (upper half does contain padding).  */
end_comment

begin_enum
enum|enum
name|x86_64_reg_class
block|{
name|X86_64_NO_CLASS
block|,
name|X86_64_INTEGER_CLASS
block|,
name|X86_64_INTEGERSI_CLASS
block|,
name|X86_64_SSE_CLASS
block|,
name|X86_64_SSESF_CLASS
block|,
name|X86_64_SSEDF_CLASS
block|,
name|X86_64_SSEUP_CLASS
block|,
name|X86_64_X87_CLASS
block|,
name|X86_64_X87UP_CLASS
block|,
name|X86_64_COMPLEX_X87_CLASS
block|,
name|X86_64_MEMORY_CLASS
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|x86_64_reg_class_name
index|[]
init|=
block|{
literal|"no"
block|,
literal|"integer"
block|,
literal|"integerSI"
block|,
literal|"sse"
block|,
literal|"sseSF"
block|,
literal|"sseDF"
block|,
literal|"sseup"
block|,
literal|"x87"
block|,
literal|"x87up"
block|,
literal|"cplx87"
block|,
literal|"no"
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MAX_CLASSES
value|4
end_define

begin_comment
comment|/* Table of constants used by fldpi, fldln2, etc....  */
end_comment

begin_decl_stmt
specifier|static
name|REAL_VALUE_TYPE
name|ext_80387_constants_table
index|[
literal|5
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|ext_80387_constants_init
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|init_ext_80387_constants
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|bool
name|ix86_in_large_data_p
argument_list|(
name|tree
argument_list|)
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ix86_encode_section_info
argument_list|(
name|tree
argument_list|,
name|rtx
argument_list|,
name|int
argument_list|)
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|x86_64_elf_unique_section
argument_list|(
name|tree
name|decl
argument_list|,
name|int
name|reloc
argument_list|)
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|section
modifier|*
name|x86_64_elf_select_section
argument_list|(
name|tree
name|decl
argument_list|,
name|int
name|reloc
argument_list|,
name|unsigned
name|HOST_WIDE_INT
name|align
argument_list|)
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Initialize the GCC target structure.  */
end_comment

begin_undef
undef|#
directive|undef
name|TARGET_ATTRIBUTE_TABLE
end_undef

begin_define
define|#
directive|define
name|TARGET_ATTRIBUTE_TABLE
value|ix86_attribute_table
end_define

begin_if
if|#
directive|if
name|TARGET_DLLIMPORT_DECL_ATTRIBUTES
end_if

begin_undef
undef|#
directive|undef
name|TARGET_MERGE_DECL_ATTRIBUTES
end_undef

begin_define
define|#
directive|define
name|TARGET_MERGE_DECL_ATTRIBUTES
value|merge_dllimport_decl_attributes
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|TARGET_COMP_TYPE_ATTRIBUTES
end_undef

begin_define
define|#
directive|define
name|TARGET_COMP_TYPE_ATTRIBUTES
value|ix86_comp_type_attributes
end_define

begin_undef
undef|#
directive|undef
name|TARGET_INIT_BUILTINS
end_undef

begin_define
define|#
directive|define
name|TARGET_INIT_BUILTINS
value|ix86_init_builtins
end_define

begin_undef
undef|#
directive|undef
name|TARGET_EXPAND_BUILTIN
end_undef

begin_define
define|#
directive|define
name|TARGET_EXPAND_BUILTIN
value|ix86_expand_builtin
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_FUNCTION_EPILOGUE
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_FUNCTION_EPILOGUE
value|ix86_output_function_epilogue
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ENCODE_SECTION_INFO
end_undef

begin_ifndef
ifndef|#
directive|ifndef
name|SUBTARGET_ENCODE_SECTION_INFO
end_ifndef

begin_define
define|#
directive|define
name|TARGET_ENCODE_SECTION_INFO
value|ix86_encode_section_info
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|TARGET_ENCODE_SECTION_INFO
value|SUBTARGET_ENCODE_SECTION_INFO
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|TARGET_ASM_OPEN_PAREN
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_OPEN_PAREN
value|""
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_CLOSE_PAREN
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_CLOSE_PAREN
value|""
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_ALIGNED_HI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_ALIGNED_HI_OP
value|ASM_SHORT
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_ALIGNED_SI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_ALIGNED_SI_OP
value|ASM_LONG
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|ASM_QUAD
end_ifdef

begin_undef
undef|#
directive|undef
name|TARGET_ASM_ALIGNED_DI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_ALIGNED_DI_OP
value|ASM_QUAD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|TARGET_ASM_UNALIGNED_HI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_UNALIGNED_HI_OP
value|TARGET_ASM_ALIGNED_HI_OP
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_UNALIGNED_SI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_UNALIGNED_SI_OP
value|TARGET_ASM_ALIGNED_SI_OP
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_UNALIGNED_DI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_UNALIGNED_DI_OP
value|TARGET_ASM_ALIGNED_DI_OP
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_ADJUST_COST
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_ADJUST_COST
value|ix86_adjust_cost
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_ISSUE_RATE
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_ISSUE_RATE
value|ix86_issue_rate
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD
define|\
value|ia32_multipass_dfa_lookahead
end_define

begin_undef
undef|#
directive|undef
name|TARGET_FUNCTION_OK_FOR_SIBCALL
end_undef

begin_define
define|#
directive|define
name|TARGET_FUNCTION_OK_FOR_SIBCALL
value|ix86_function_ok_for_sibcall
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_AS_TLS
end_ifdef

begin_undef
undef|#
directive|undef
name|TARGET_HAVE_TLS
end_undef

begin_define
define|#
directive|define
name|TARGET_HAVE_TLS
value|true
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|TARGET_CANNOT_FORCE_CONST_MEM
end_undef

begin_define
define|#
directive|define
name|TARGET_CANNOT_FORCE_CONST_MEM
value|ix86_cannot_force_const_mem
end_define

begin_undef
undef|#
directive|undef
name|TARGET_USE_BLOCKS_FOR_CONSTANT_P
end_undef

begin_define
define|#
directive|define
name|TARGET_USE_BLOCKS_FOR_CONSTANT_P
value|hook_bool_mode_rtx_true
end_define

begin_undef
undef|#
directive|undef
name|TARGET_DELEGITIMIZE_ADDRESS
end_undef

begin_define
define|#
directive|define
name|TARGET_DELEGITIMIZE_ADDRESS
value|ix86_delegitimize_address
end_define

begin_undef
undef|#
directive|undef
name|TARGET_MS_BITFIELD_LAYOUT_P
end_undef

begin_define
define|#
directive|define
name|TARGET_MS_BITFIELD_LAYOUT_P
value|ix86_ms_bitfield_layout_p
end_define

begin_if
if|#
directive|if
name|TARGET_MACHO
end_if

begin_undef
undef|#
directive|undef
name|TARGET_BINDS_LOCAL_P
end_undef

begin_define
define|#
directive|define
name|TARGET_BINDS_LOCAL_P
value|darwin_binds_local_p
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|TARGET_ASM_OUTPUT_MI_THUNK
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_OUTPUT_MI_THUNK
value|x86_output_mi_thunk
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_CAN_OUTPUT_MI_THUNK
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_CAN_OUTPUT_MI_THUNK
value|x86_can_output_mi_thunk
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_FILE_START
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_FILE_START
value|x86_file_start
end_define

begin_undef
undef|#
directive|undef
name|TARGET_DEFAULT_TARGET_FLAGS
end_undef

begin_define
define|#
directive|define
name|TARGET_DEFAULT_TARGET_FLAGS
define|\
value|(TARGET_DEFAULT			\    | TARGET_64BIT_DEFAULT		\    | TARGET_SUBTARGET_DEFAULT		\    | TARGET_TLS_DIRECT_SEG_REFS_DEFAULT)
end_define

begin_undef
undef|#
directive|undef
name|TARGET_HANDLE_OPTION
end_undef

begin_define
define|#
directive|define
name|TARGET_HANDLE_OPTION
value|ix86_handle_option
end_define

begin_undef
undef|#
directive|undef
name|TARGET_RTX_COSTS
end_undef

begin_define
define|#
directive|define
name|TARGET_RTX_COSTS
value|ix86_rtx_costs
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ADDRESS_COST
end_undef

begin_define
define|#
directive|define
name|TARGET_ADDRESS_COST
value|ix86_address_cost
end_define

begin_undef
undef|#
directive|undef
name|TARGET_FIXED_CONDITION_CODE_REGS
end_undef

begin_define
define|#
directive|define
name|TARGET_FIXED_CONDITION_CODE_REGS
value|ix86_fixed_condition_code_regs
end_define

begin_undef
undef|#
directive|undef
name|TARGET_CC_MODES_COMPATIBLE
end_undef

begin_define
define|#
directive|define
name|TARGET_CC_MODES_COMPATIBLE
value|ix86_cc_modes_compatible
end_define

begin_undef
undef|#
directive|undef
name|TARGET_MACHINE_DEPENDENT_REORG
end_undef

begin_define
define|#
directive|define
name|TARGET_MACHINE_DEPENDENT_REORG
value|ix86_reorg
end_define

begin_undef
undef|#
directive|undef
name|TARGET_BUILD_BUILTIN_VA_LIST
end_undef

begin_define
define|#
directive|define
name|TARGET_BUILD_BUILTIN_VA_LIST
value|ix86_build_builtin_va_list
end_define

begin_undef
undef|#
directive|undef
name|TARGET_MD_ASM_CLOBBERS
end_undef

begin_define
define|#
directive|define
name|TARGET_MD_ASM_CLOBBERS
value|ix86_md_asm_clobbers
end_define

begin_undef
undef|#
directive|undef
name|TARGET_PROMOTE_PROTOTYPES
end_undef

begin_define
define|#
directive|define
name|TARGET_PROMOTE_PROTOTYPES
value|hook_bool_tree_true
end_define

begin_undef
undef|#
directive|undef
name|TARGET_STRUCT_VALUE_RTX
end_undef

begin_define
define|#
directive|define
name|TARGET_STRUCT_VALUE_RTX
value|ix86_struct_value_rtx
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SETUP_INCOMING_VARARGS
end_undef

begin_define
define|#
directive|define
name|TARGET_SETUP_INCOMING_VARARGS
value|ix86_setup_incoming_varargs
end_define

begin_undef
undef|#
directive|undef
name|TARGET_MUST_PASS_IN_STACK
end_undef

begin_define
define|#
directive|define
name|TARGET_MUST_PASS_IN_STACK
value|ix86_must_pass_in_stack
end_define

begin_undef
undef|#
directive|undef
name|TARGET_PASS_BY_REFERENCE
end_undef

begin_define
define|#
directive|define
name|TARGET_PASS_BY_REFERENCE
value|ix86_pass_by_reference
end_define

begin_undef
undef|#
directive|undef
name|TARGET_INTERNAL_ARG_POINTER
end_undef

begin_define
define|#
directive|define
name|TARGET_INTERNAL_ARG_POINTER
value|ix86_internal_arg_pointer
end_define

begin_undef
undef|#
directive|undef
name|TARGET_DWARF_HANDLE_FRAME_UNSPEC
end_undef

begin_define
define|#
directive|define
name|TARGET_DWARF_HANDLE_FRAME_UNSPEC
value|ix86_dwarf_handle_frame_unspec
end_define

begin_undef
undef|#
directive|undef
name|TARGET_GIMPLIFY_VA_ARG_EXPR
end_undef

begin_define
define|#
directive|define
name|TARGET_GIMPLIFY_VA_ARG_EXPR
value|ix86_gimplify_va_arg
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCALAR_MODE_SUPPORTED_P
end_undef

begin_define
define|#
directive|define
name|TARGET_SCALAR_MODE_SUPPORTED_P
value|ix86_scalar_mode_supported_p
end_define

begin_undef
undef|#
directive|undef
name|TARGET_VECTOR_MODE_SUPPORTED_P
end_undef

begin_define
define|#
directive|define
name|TARGET_VECTOR_MODE_SUPPORTED_P
value|ix86_vector_mode_supported_p
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_AS_TLS
end_ifdef

begin_undef
undef|#
directive|undef
name|TARGET_ASM_OUTPUT_DWARF_DTPREL
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_OUTPUT_DWARF_DTPREL
value|i386_output_dwarf_dtprel
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SUBTARGET_INSERT_ATTRIBUTES
end_ifdef

begin_undef
undef|#
directive|undef
name|TARGET_INSERT_ATTRIBUTES
end_undef

begin_define
define|#
directive|define
name|TARGET_INSERT_ATTRIBUTES
value|SUBTARGET_INSERT_ATTRIBUTES
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|TARGET_MANGLE_FUNDAMENTAL_TYPE
end_undef

begin_define
define|#
directive|define
name|TARGET_MANGLE_FUNDAMENTAL_TYPE
value|ix86_mangle_fundamental_type
end_define

begin_undef
undef|#
directive|undef
name|TARGET_STACK_PROTECT_FAIL
end_undef

begin_define
define|#
directive|define
name|TARGET_STACK_PROTECT_FAIL
value|ix86_stack_protect_fail
end_define

begin_undef
undef|#
directive|undef
name|TARGET_FUNCTION_VALUE
end_undef

begin_define
define|#
directive|define
name|TARGET_FUNCTION_VALUE
value|ix86_function_value
end_define

begin_decl_stmt
name|struct
name|gcc_target
name|targetm
init|=
name|TARGET_INITIALIZER
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* The svr4 ABI for the i386 says that records and unions are returned    in memory.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DEFAULT_PCC_STRUCT_RETURN
end_ifndef

begin_define
define|#
directive|define
name|DEFAULT_PCC_STRUCT_RETURN
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Implement TARGET_HANDLE_OPTION.  */
end_comment

begin_function
specifier|static
name|bool
name|ix86_handle_option
parameter_list|(
name|size_t
name|code
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|value
parameter_list|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|OPT_m3dnow
case|:
if|if
condition|(
operator|!
name|value
condition|)
block|{
name|target_flags
operator|&=
operator|~
name|MASK_3DNOW_A
expr_stmt|;
name|target_flags_explicit
operator||=
name|MASK_3DNOW_A
expr_stmt|;
block|}
return|return
name|true
return|;
case|case
name|OPT_mmmx
case|:
if|if
condition|(
operator|!
name|value
condition|)
block|{
name|target_flags
operator|&=
operator|~
operator|(
name|MASK_3DNOW
operator||
name|MASK_3DNOW_A
operator|)
expr_stmt|;
name|target_flags_explicit
operator||=
name|MASK_3DNOW
operator||
name|MASK_3DNOW_A
expr_stmt|;
block|}
return|return
name|true
return|;
case|case
name|OPT_msse
case|:
if|if
condition|(
operator|!
name|value
condition|)
block|{
name|target_flags
operator|&=
operator|~
operator|(
name|MASK_SSE2
operator||
name|MASK_SSE3
operator|)
expr_stmt|;
name|target_flags_explicit
operator||=
name|MASK_SSE2
operator||
name|MASK_SSE3
expr_stmt|;
block|}
return|return
name|true
return|;
case|case
name|OPT_msse2
case|:
if|if
condition|(
operator|!
name|value
condition|)
block|{
name|target_flags
operator|&=
operator|~
name|MASK_SSE3
expr_stmt|;
name|target_flags_explicit
operator||=
name|MASK_SSE3
expr_stmt|;
block|}
return|return
name|true
return|;
default|default:
return|return
name|true
return|;
block|}
block|}
end_function

begin_comment
comment|/* Sometimes certain combinations of command options do not make    sense on a particular target machine.  You can define a macro    `OVERRIDE_OPTIONS' to take account of this.  This macro, if    defined, is executed once just after all the command options have    been parsed.     Don't use this macro to turn on various extra optimizations for    `-O'.  That is what `OPTIMIZATION_OPTIONS' is for.  */
end_comment

begin_function
name|void
name|override_options
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|ix86_tune_defaulted
init|=
literal|0
decl_stmt|;
comment|/* Comes from final.c -- no real reason to change it.  */
define|#
directive|define
name|MAX_CODE_ALIGN
value|16
specifier|static
struct|struct
name|ptt
block|{
specifier|const
name|struct
name|processor_costs
modifier|*
name|cost
decl_stmt|;
comment|/* Processor costs */
specifier|const
name|int
name|target_enable
decl_stmt|;
comment|/* Target flags to enable.  */
specifier|const
name|int
name|target_disable
decl_stmt|;
comment|/* Target flags to disable.  */
specifier|const
name|int
name|align_loop
decl_stmt|;
comment|/* Default alignments.  */
specifier|const
name|int
name|align_loop_max_skip
decl_stmt|;
specifier|const
name|int
name|align_jump
decl_stmt|;
specifier|const
name|int
name|align_jump_max_skip
decl_stmt|;
specifier|const
name|int
name|align_func
decl_stmt|;
block|}
decl|const
name|processor_target_table
index|[
name|PROCESSOR_max
index|]
init|=
block|{
block|{
operator|&
name|i386_cost
block|,
literal|0
block|,
literal|0
block|,
literal|4
block|,
literal|3
block|,
literal|4
block|,
literal|3
block|,
literal|4
block|}
block|,
block|{
operator|&
name|i486_cost
block|,
literal|0
block|,
literal|0
block|,
literal|16
block|,
literal|15
block|,
literal|16
block|,
literal|15
block|,
literal|16
block|}
block|,
block|{
operator|&
name|pentium_cost
block|,
literal|0
block|,
literal|0
block|,
literal|16
block|,
literal|7
block|,
literal|16
block|,
literal|7
block|,
literal|16
block|}
block|,
block|{
operator|&
name|pentiumpro_cost
block|,
literal|0
block|,
literal|0
block|,
literal|16
block|,
literal|15
block|,
literal|16
block|,
literal|7
block|,
literal|16
block|}
block|,
block|{
operator|&
name|k6_cost
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
literal|7
block|,
literal|32
block|,
literal|7
block|,
literal|32
block|}
block|,
block|{
operator|&
name|athlon_cost
block|,
literal|0
block|,
literal|0
block|,
literal|16
block|,
literal|7
block|,
literal|16
block|,
literal|7
block|,
literal|16
block|}
block|,
block|{
operator|&
name|pentium4_cost
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
operator|&
name|k8_cost
block|,
literal|0
block|,
literal|0
block|,
literal|16
block|,
literal|7
block|,
literal|16
block|,
literal|7
block|,
literal|16
block|}
block|,
block|{
operator|&
name|nocona_cost
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
operator|&
name|generic32_cost
block|,
literal|0
block|,
literal|0
block|,
literal|16
block|,
literal|7
block|,
literal|16
block|,
literal|7
block|,
literal|16
block|}
block|,
block|{
operator|&
name|generic64_cost
block|,
literal|0
block|,
literal|0
block|,
literal|16
block|,
literal|7
block|,
literal|16
block|,
literal|7
block|,
literal|16
block|}
block|}
struct|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|cpu_names
index|[]
init|=
name|TARGET_CPU_DEFAULT_NAMES
decl_stmt|;
specifier|static
struct|struct
name|pta
block|{
specifier|const
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
comment|/* processor name or nickname.  */
specifier|const
name|enum
name|processor_type
name|processor
decl_stmt|;
specifier|const
enum|enum
name|pta_flags
block|{
name|PTA_SSE
init|=
literal|1
block|,
name|PTA_SSE2
init|=
literal|2
block|,
name|PTA_SSE3
init|=
literal|4
block|,
name|PTA_MMX
init|=
literal|8
block|,
name|PTA_PREFETCH_SSE
init|=
literal|16
block|,
name|PTA_3DNOW
init|=
literal|32
block|,
name|PTA_3DNOW_A
init|=
literal|64
block|,
name|PTA_64BIT
init|=
literal|128
block|}
name|flags
enum|;
block|}
decl|const
name|processor_alias_table
index|[]
init|=
block|{
block|{
literal|"i386"
block|,
name|PROCESSOR_I386
block|,
literal|0
block|}
block|,
block|{
literal|"i486"
block|,
name|PROCESSOR_I486
block|,
literal|0
block|}
block|,
block|{
literal|"i586"
block|,
name|PROCESSOR_PENTIUM
block|,
literal|0
block|}
block|,
block|{
literal|"pentium"
block|,
name|PROCESSOR_PENTIUM
block|,
literal|0
block|}
block|,
block|{
literal|"pentium-mmx"
block|,
name|PROCESSOR_PENTIUM
block|,
name|PTA_MMX
block|}
block|,
block|{
literal|"winchip-c6"
block|,
name|PROCESSOR_I486
block|,
name|PTA_MMX
block|}
block|,
block|{
literal|"winchip2"
block|,
name|PROCESSOR_I486
block|,
name|PTA_MMX
operator||
name|PTA_3DNOW
block|}
block|,
block|{
literal|"c3"
block|,
name|PROCESSOR_I486
block|,
name|PTA_MMX
operator||
name|PTA_3DNOW
block|}
block|,
block|{
literal|"c3-2"
block|,
name|PROCESSOR_PENTIUMPRO
block|,
name|PTA_MMX
operator||
name|PTA_PREFETCH_SSE
operator||
name|PTA_SSE
block|}
block|,
block|{
literal|"i686"
block|,
name|PROCESSOR_PENTIUMPRO
block|,
literal|0
block|}
block|,
block|{
literal|"pentiumpro"
block|,
name|PROCESSOR_PENTIUMPRO
block|,
literal|0
block|}
block|,
block|{
literal|"pentium2"
block|,
name|PROCESSOR_PENTIUMPRO
block|,
name|PTA_MMX
block|}
block|,
block|{
literal|"pentium3"
block|,
name|PROCESSOR_PENTIUMPRO
block|,
name|PTA_MMX
operator||
name|PTA_SSE
operator||
name|PTA_PREFETCH_SSE
block|}
block|,
block|{
literal|"pentium3m"
block|,
name|PROCESSOR_PENTIUMPRO
block|,
name|PTA_MMX
operator||
name|PTA_SSE
operator||
name|PTA_PREFETCH_SSE
block|}
block|,
block|{
literal|"pentium-m"
block|,
name|PROCESSOR_PENTIUMPRO
block|,
name|PTA_MMX
operator||
name|PTA_SSE
operator||
name|PTA_PREFETCH_SSE
operator||
name|PTA_SSE2
block|}
block|,
block|{
literal|"pentium4"
block|,
name|PROCESSOR_PENTIUM4
block|,
name|PTA_SSE
operator||
name|PTA_SSE2
operator||
name|PTA_MMX
operator||
name|PTA_PREFETCH_SSE
block|}
block|,
block|{
literal|"pentium4m"
block|,
name|PROCESSOR_PENTIUM4
block|,
name|PTA_SSE
operator||
name|PTA_SSE2
operator||
name|PTA_MMX
operator||
name|PTA_PREFETCH_SSE
block|}
block|,
block|{
literal|"prescott"
block|,
name|PROCESSOR_NOCONA
block|,
name|PTA_SSE
operator||
name|PTA_SSE2
operator||
name|PTA_SSE3
operator||
name|PTA_MMX
operator||
name|PTA_PREFETCH_SSE
block|}
block|,
block|{
literal|"nocona"
block|,
name|PROCESSOR_NOCONA
block|,
name|PTA_SSE
operator||
name|PTA_SSE2
operator||
name|PTA_SSE3
operator||
name|PTA_64BIT
operator||
name|PTA_MMX
operator||
name|PTA_PREFETCH_SSE
block|}
block|,
block|{
literal|"k6"
block|,
name|PROCESSOR_K6
block|,
name|PTA_MMX
block|}
block|,
block|{
literal|"k6-2"
block|,
name|PROCESSOR_K6
block|,
name|PTA_MMX
operator||
name|PTA_3DNOW
block|}
block|,
block|{
literal|"k6-3"
block|,
name|PROCESSOR_K6
block|,
name|PTA_MMX
operator||
name|PTA_3DNOW
block|}
block|,
block|{
literal|"athlon"
block|,
name|PROCESSOR_ATHLON
block|,
name|PTA_MMX
operator||
name|PTA_PREFETCH_SSE
operator||
name|PTA_3DNOW
operator||
name|PTA_3DNOW_A
block|}
block|,
block|{
literal|"athlon-tbird"
block|,
name|PROCESSOR_ATHLON
block|,
name|PTA_MMX
operator||
name|PTA_PREFETCH_SSE
operator||
name|PTA_3DNOW
operator||
name|PTA_3DNOW_A
block|}
block|,
block|{
literal|"athlon-4"
block|,
name|PROCESSOR_ATHLON
block|,
name|PTA_MMX
operator||
name|PTA_PREFETCH_SSE
operator||
name|PTA_3DNOW
operator||
name|PTA_3DNOW_A
operator||
name|PTA_SSE
block|}
block|,
block|{
literal|"athlon-xp"
block|,
name|PROCESSOR_ATHLON
block|,
name|PTA_MMX
operator||
name|PTA_PREFETCH_SSE
operator||
name|PTA_3DNOW
operator||
name|PTA_3DNOW_A
operator||
name|PTA_SSE
block|}
block|,
block|{
literal|"athlon-mp"
block|,
name|PROCESSOR_ATHLON
block|,
name|PTA_MMX
operator||
name|PTA_PREFETCH_SSE
operator||
name|PTA_3DNOW
operator||
name|PTA_3DNOW_A
operator||
name|PTA_SSE
block|}
block|,
block|{
literal|"x86-64"
block|,
name|PROCESSOR_K8
block|,
name|PTA_MMX
operator||
name|PTA_PREFETCH_SSE
operator||
name|PTA_64BIT
operator||
name|PTA_SSE
operator||
name|PTA_SSE2
block|}
block|,
block|{
literal|"k8"
block|,
name|PROCESSOR_K8
block|,
name|PTA_MMX
operator||
name|PTA_PREFETCH_SSE
operator||
name|PTA_3DNOW
operator||
name|PTA_64BIT
operator||
name|PTA_3DNOW_A
operator||
name|PTA_SSE
operator||
name|PTA_SSE2
block|}
block|,
block|{
literal|"opteron"
block|,
name|PROCESSOR_K8
block|,
name|PTA_MMX
operator||
name|PTA_PREFETCH_SSE
operator||
name|PTA_3DNOW
operator||
name|PTA_64BIT
operator||
name|PTA_3DNOW_A
operator||
name|PTA_SSE
operator||
name|PTA_SSE2
block|}
block|,
block|{
literal|"athlon64"
block|,
name|PROCESSOR_K8
block|,
name|PTA_MMX
operator||
name|PTA_PREFETCH_SSE
operator||
name|PTA_3DNOW
operator||
name|PTA_64BIT
operator||
name|PTA_3DNOW_A
operator||
name|PTA_SSE
operator||
name|PTA_SSE2
block|}
block|,
block|{
literal|"athlon-fx"
block|,
name|PROCESSOR_K8
block|,
name|PTA_MMX
operator||
name|PTA_PREFETCH_SSE
operator||
name|PTA_3DNOW
operator||
name|PTA_64BIT
operator||
name|PTA_3DNOW_A
operator||
name|PTA_SSE
operator||
name|PTA_SSE2
block|}
block|,
block|{
literal|"generic32"
block|,
name|PROCESSOR_GENERIC32
block|,
literal|0
comment|/* flags are only used for -march switch.  */
block|}
block|,
block|{
literal|"generic64"
block|,
name|PROCESSOR_GENERIC64
block|,
name|PTA_64BIT
comment|/* flags are only used for -march switch.  */
block|}
block|,     }
struct|;
name|int
specifier|const
name|pta_size
init|=
name|ARRAY_SIZE
argument_list|(
name|processor_alias_table
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|SUBTARGET_OVERRIDE_OPTIONS
name|SUBTARGET_OVERRIDE_OPTIONS
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SUBSUBTARGET_OVERRIDE_OPTIONS
name|SUBSUBTARGET_OVERRIDE_OPTIONS
expr_stmt|;
endif|#
directive|endif
comment|/* -fPIC is the default for x86_64.  */
if|if
condition|(
name|TARGET_MACHO
operator|&&
name|TARGET_64BIT
condition|)
name|flag_pic
operator|=
literal|2
expr_stmt|;
comment|/* Set the default values for switches whose default depends on TARGET_64BIT      in case they weren't overwritten by command line options.  */
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
comment|/* Mach-O doesn't support omitting the frame pointer for now.  */
if|if
condition|(
name|flag_omit_frame_pointer
operator|==
literal|2
condition|)
name|flag_omit_frame_pointer
operator|=
operator|(
name|TARGET_MACHO
condition|?
literal|0
else|:
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|flag_asynchronous_unwind_tables
operator|==
literal|2
condition|)
name|flag_asynchronous_unwind_tables
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|flag_pcc_struct_return
operator|==
literal|2
condition|)
name|flag_pcc_struct_return
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|flag_omit_frame_pointer
operator|==
literal|2
condition|)
name|flag_omit_frame_pointer
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flag_asynchronous_unwind_tables
operator|==
literal|2
condition|)
name|flag_asynchronous_unwind_tables
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flag_pcc_struct_return
operator|==
literal|2
condition|)
name|flag_pcc_struct_return
operator|=
name|DEFAULT_PCC_STRUCT_RETURN
expr_stmt|;
block|}
comment|/* Need to check -mtune=generic first.  */
if|if
condition|(
name|ix86_tune_string
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ix86_tune_string
argument_list|,
literal|"generic"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|ix86_tune_string
argument_list|,
literal|"i686"
argument_list|)
comment|/* As special support for cross compilers we read -mtune=native 	     as -mtune=generic.  With native compilers we won't see the 	     -mtune=native, as it was changed by the driver.  */
operator|||
operator|!
name|strcmp
argument_list|(
name|ix86_tune_string
argument_list|,
literal|"native"
argument_list|)
condition|)
block|{
if|if
condition|(
name|TARGET_64BIT
condition|)
name|ix86_tune_string
operator|=
literal|"generic64"
expr_stmt|;
else|else
name|ix86_tune_string
operator|=
literal|"generic32"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|ix86_tune_string
argument_list|,
literal|"generic"
argument_list|,
literal|7
argument_list|)
condition|)
name|error
argument_list|(
literal|"bad value (%s) for -mtune= switch"
argument_list|,
name|ix86_tune_string
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ix86_arch_string
condition|)
name|ix86_tune_string
operator|=
name|ix86_arch_string
expr_stmt|;
if|if
condition|(
operator|!
name|ix86_tune_string
condition|)
block|{
name|ix86_tune_string
operator|=
name|cpu_names
index|[
name|TARGET_CPU_DEFAULT
index|]
expr_stmt|;
name|ix86_tune_defaulted
operator|=
literal|1
expr_stmt|;
block|}
comment|/* ix86_tune_string is set to ix86_arch_string or defaulted.  We 	 need to use a sensible tune option.  */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ix86_tune_string
argument_list|,
literal|"generic"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|ix86_tune_string
argument_list|,
literal|"x86-64"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|ix86_tune_string
argument_list|,
literal|"i686"
argument_list|)
condition|)
block|{
if|if
condition|(
name|TARGET_64BIT
condition|)
name|ix86_tune_string
operator|=
literal|"generic64"
expr_stmt|;
else|else
name|ix86_tune_string
operator|=
literal|"generic32"
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ix86_tune_string
argument_list|,
literal|"x86-64"
argument_list|)
condition|)
name|warning
argument_list|(
name|OPT_Wdeprecated
argument_list|,
literal|"-mtune=x86-64 is deprecated.  Use -mtune=k8 or "
literal|"-mtune=generic instead as appropriate."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ix86_arch_string
condition|)
name|ix86_arch_string
operator|=
name|TARGET_64BIT
condition|?
literal|"x86-64"
else|:
literal|"i486"
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ix86_arch_string
argument_list|,
literal|"generic"
argument_list|)
condition|)
name|error
argument_list|(
literal|"generic CPU can be used only for -mtune= switch"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|ix86_arch_string
argument_list|,
literal|"generic"
argument_list|,
literal|7
argument_list|)
condition|)
name|error
argument_list|(
literal|"bad value (%s) for -march= switch"
argument_list|,
name|ix86_arch_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|ix86_cmodel_string
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ix86_cmodel_string
argument_list|,
literal|"small"
argument_list|)
condition|)
name|ix86_cmodel
operator|=
name|flag_pic
condition|?
name|CM_SMALL_PIC
else|:
name|CM_SMALL
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ix86_cmodel_string
argument_list|,
literal|"medium"
argument_list|)
condition|)
name|ix86_cmodel
operator|=
name|flag_pic
condition|?
name|CM_MEDIUM_PIC
else|:
name|CM_MEDIUM
expr_stmt|;
elseif|else
if|if
condition|(
name|flag_pic
condition|)
name|sorry
argument_list|(
literal|"code model %s not supported in PIC mode"
argument_list|,
name|ix86_cmodel_string
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ix86_cmodel_string
argument_list|,
literal|"32"
argument_list|)
condition|)
name|ix86_cmodel
operator|=
name|CM_32
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ix86_cmodel_string
argument_list|,
literal|"kernel"
argument_list|)
operator|&&
operator|!
name|flag_pic
condition|)
name|ix86_cmodel
operator|=
name|CM_KERNEL
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ix86_cmodel_string
argument_list|,
literal|"large"
argument_list|)
operator|&&
operator|!
name|flag_pic
condition|)
name|ix86_cmodel
operator|=
name|CM_LARGE
expr_stmt|;
else|else
name|error
argument_list|(
literal|"bad value (%s) for -mcmodel= switch"
argument_list|,
name|ix86_cmodel_string
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ix86_cmodel
operator|=
name|CM_32
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
name|ix86_cmodel
operator|=
name|flag_pic
condition|?
name|CM_SMALL_PIC
else|:
name|CM_SMALL
expr_stmt|;
block|}
if|if
condition|(
name|ix86_asm_string
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|TARGET_MACHO
operator|&&
operator|!
name|strcmp
argument_list|(
name|ix86_asm_string
argument_list|,
literal|"intel"
argument_list|)
condition|)
name|ix86_asm_dialect
operator|=
name|ASM_INTEL
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ix86_asm_string
argument_list|,
literal|"att"
argument_list|)
condition|)
name|ix86_asm_dialect
operator|=
name|ASM_ATT
expr_stmt|;
else|else
name|error
argument_list|(
literal|"bad value (%s) for -masm= switch"
argument_list|,
name|ix86_asm_string
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|TARGET_64BIT
operator|==
literal|0
operator|)
operator|!=
operator|(
name|ix86_cmodel
operator|==
name|CM_32
operator|)
condition|)
name|error
argument_list|(
literal|"code model %qs not supported in the %s bit mode"
argument_list|,
name|ix86_cmodel_string
argument_list|,
name|TARGET_64BIT
condition|?
literal|"64"
else|:
literal|"32"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ix86_cmodel
operator|==
name|CM_LARGE
condition|)
name|sorry
argument_list|(
literal|"code model %<large%> not supported yet"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TARGET_64BIT
operator|!=
literal|0
operator|)
operator|!=
operator|(
operator|(
name|target_flags
operator|&
name|MASK_64BIT
operator|)
operator|!=
literal|0
operator|)
condition|)
name|sorry
argument_list|(
literal|"%i-bit mode not compiled in"
argument_list|,
operator|(
name|target_flags
operator|&
name|MASK_64BIT
operator|)
condition|?
literal|64
else|:
literal|32
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pta_size
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ix86_arch_string
argument_list|,
name|processor_alias_table
index|[
name|i
index|]
operator|.
name|name
argument_list|)
condition|)
block|{
name|ix86_arch
operator|=
name|processor_alias_table
index|[
name|i
index|]
operator|.
name|processor
expr_stmt|;
comment|/* Default cpu tuning to the architecture.  */
name|ix86_tune
operator|=
name|ix86_arch
expr_stmt|;
if|if
condition|(
name|processor_alias_table
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|PTA_MMX
operator|&&
operator|!
operator|(
name|target_flags_explicit
operator|&
name|MASK_MMX
operator|)
condition|)
name|target_flags
operator||=
name|MASK_MMX
expr_stmt|;
if|if
condition|(
name|processor_alias_table
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|PTA_3DNOW
operator|&&
operator|!
operator|(
name|target_flags_explicit
operator|&
name|MASK_3DNOW
operator|)
condition|)
name|target_flags
operator||=
name|MASK_3DNOW
expr_stmt|;
if|if
condition|(
name|processor_alias_table
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|PTA_3DNOW_A
operator|&&
operator|!
operator|(
name|target_flags_explicit
operator|&
name|MASK_3DNOW_A
operator|)
condition|)
name|target_flags
operator||=
name|MASK_3DNOW_A
expr_stmt|;
if|if
condition|(
name|processor_alias_table
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|PTA_SSE
operator|&&
operator|!
operator|(
name|target_flags_explicit
operator|&
name|MASK_SSE
operator|)
condition|)
name|target_flags
operator||=
name|MASK_SSE
expr_stmt|;
if|if
condition|(
name|processor_alias_table
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|PTA_SSE2
operator|&&
operator|!
operator|(
name|target_flags_explicit
operator|&
name|MASK_SSE2
operator|)
condition|)
name|target_flags
operator||=
name|MASK_SSE2
expr_stmt|;
if|if
condition|(
name|processor_alias_table
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|PTA_SSE3
operator|&&
operator|!
operator|(
name|target_flags_explicit
operator|&
name|MASK_SSE3
operator|)
condition|)
name|target_flags
operator||=
name|MASK_SSE3
expr_stmt|;
if|if
condition|(
name|processor_alias_table
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|PTA_PREFETCH_SSE
condition|)
name|x86_prefetch_sse
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
operator|&&
operator|!
operator|(
name|processor_alias_table
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|PTA_64BIT
operator|)
condition|)
name|error
argument_list|(
literal|"CPU you selected does not support x86-64 "
literal|"instruction set"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|pta_size
condition|)
name|error
argument_list|(
literal|"bad value (%s) for -march= switch"
argument_list|,
name|ix86_arch_string
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pta_size
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ix86_tune_string
argument_list|,
name|processor_alias_table
index|[
name|i
index|]
operator|.
name|name
argument_list|)
condition|)
block|{
name|ix86_tune
operator|=
name|processor_alias_table
index|[
name|i
index|]
operator|.
name|processor
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
operator|&&
operator|!
operator|(
name|processor_alias_table
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|PTA_64BIT
operator|)
condition|)
block|{
if|if
condition|(
name|ix86_tune_defaulted
condition|)
block|{
name|ix86_tune_string
operator|=
literal|"x86-64"
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pta_size
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ix86_tune_string
argument_list|,
name|processor_alias_table
index|[
name|i
index|]
operator|.
name|name
argument_list|)
condition|)
break|break;
name|ix86_tune
operator|=
name|processor_alias_table
index|[
name|i
index|]
operator|.
name|processor
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"CPU you selected does not support x86-64 "
literal|"instruction set"
argument_list|)
expr_stmt|;
block|}
comment|/* Intel CPUs have always interpreted SSE prefetch instructions as 	   NOPs; so, we can enable SSE prefetch instructions even when 	   -mtune (rather than -march) points us to a processor that has them. 	   However, the VIA C3 gives a SIGILL, so we only do that for i686 and 	   higher processors.  */
if|if
condition|(
name|TARGET_CMOVE
operator|&&
operator|(
name|processor_alias_table
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|PTA_PREFETCH_SSE
operator|)
condition|)
name|x86_prefetch_sse
operator|=
name|true
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|pta_size
condition|)
name|error
argument_list|(
literal|"bad value (%s) for -mtune= switch"
argument_list|,
name|ix86_tune_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|optimize_size
condition|)
name|ix86_cost
operator|=
operator|&
name|size_cost
expr_stmt|;
else|else
name|ix86_cost
operator|=
name|processor_target_table
index|[
name|ix86_tune
index|]
operator|.
name|cost
expr_stmt|;
name|target_flags
operator||=
name|processor_target_table
index|[
name|ix86_tune
index|]
operator|.
name|target_enable
expr_stmt|;
name|target_flags
operator|&=
operator|~
name|processor_target_table
index|[
name|ix86_tune
index|]
operator|.
name|target_disable
expr_stmt|;
comment|/* Arrange to set up i386_stack_locals for all functions.  */
name|init_machine_status
operator|=
name|ix86_init_machine_status
expr_stmt|;
comment|/* Validate -mregparm= value.  */
if|if
condition|(
name|ix86_regparm_string
condition|)
block|{
name|i
operator|=
name|atoi
argument_list|(
name|ix86_regparm_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|>
name|REGPARM_MAX
condition|)
name|error
argument_list|(
literal|"-mregparm=%d is not between 0 and %d"
argument_list|,
name|i
argument_list|,
name|REGPARM_MAX
argument_list|)
expr_stmt|;
else|else
name|ix86_regparm
operator|=
name|i
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TARGET_64BIT
condition|)
name|ix86_regparm
operator|=
name|REGPARM_MAX
expr_stmt|;
comment|/* If the user has provided any of the -malign-* options,      warn and use that value only if -falign-* is not set.      Remove this code in GCC 3.2 or later.  */
if|if
condition|(
name|ix86_align_loops_string
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"-malign-loops is obsolete, use -falign-loops"
argument_list|)
expr_stmt|;
if|if
condition|(
name|align_loops
operator|==
literal|0
condition|)
block|{
name|i
operator|=
name|atoi
argument_list|(
name|ix86_align_loops_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|>
name|MAX_CODE_ALIGN
condition|)
name|error
argument_list|(
literal|"-malign-loops=%d is not between 0 and %d"
argument_list|,
name|i
argument_list|,
name|MAX_CODE_ALIGN
argument_list|)
expr_stmt|;
else|else
name|align_loops
operator|=
literal|1
operator|<<
name|i
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ix86_align_jumps_string
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"-malign-jumps is obsolete, use -falign-jumps"
argument_list|)
expr_stmt|;
if|if
condition|(
name|align_jumps
operator|==
literal|0
condition|)
block|{
name|i
operator|=
name|atoi
argument_list|(
name|ix86_align_jumps_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|>
name|MAX_CODE_ALIGN
condition|)
name|error
argument_list|(
literal|"-malign-loops=%d is not between 0 and %d"
argument_list|,
name|i
argument_list|,
name|MAX_CODE_ALIGN
argument_list|)
expr_stmt|;
else|else
name|align_jumps
operator|=
literal|1
operator|<<
name|i
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ix86_align_funcs_string
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"-malign-functions is obsolete, use -falign-functions"
argument_list|)
expr_stmt|;
if|if
condition|(
name|align_functions
operator|==
literal|0
condition|)
block|{
name|i
operator|=
name|atoi
argument_list|(
name|ix86_align_funcs_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|>
name|MAX_CODE_ALIGN
condition|)
name|error
argument_list|(
literal|"-malign-loops=%d is not between 0 and %d"
argument_list|,
name|i
argument_list|,
name|MAX_CODE_ALIGN
argument_list|)
expr_stmt|;
else|else
name|align_functions
operator|=
literal|1
operator|<<
name|i
expr_stmt|;
block|}
block|}
comment|/* Default align_* from the processor table.  */
if|if
condition|(
name|align_loops
operator|==
literal|0
condition|)
block|{
name|align_loops
operator|=
name|processor_target_table
index|[
name|ix86_tune
index|]
operator|.
name|align_loop
expr_stmt|;
name|align_loops_max_skip
operator|=
name|processor_target_table
index|[
name|ix86_tune
index|]
operator|.
name|align_loop_max_skip
expr_stmt|;
block|}
if|if
condition|(
name|align_jumps
operator|==
literal|0
condition|)
block|{
name|align_jumps
operator|=
name|processor_target_table
index|[
name|ix86_tune
index|]
operator|.
name|align_jump
expr_stmt|;
name|align_jumps_max_skip
operator|=
name|processor_target_table
index|[
name|ix86_tune
index|]
operator|.
name|align_jump_max_skip
expr_stmt|;
block|}
if|if
condition|(
name|align_functions
operator|==
literal|0
condition|)
block|{
name|align_functions
operator|=
name|processor_target_table
index|[
name|ix86_tune
index|]
operator|.
name|align_func
expr_stmt|;
block|}
comment|/* Validate -mbranch-cost= value, or provide default.  */
name|ix86_branch_cost
operator|=
name|ix86_cost
operator|->
name|branch_cost
expr_stmt|;
if|if
condition|(
name|ix86_branch_cost_string
condition|)
block|{
name|i
operator|=
name|atoi
argument_list|(
name|ix86_branch_cost_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|>
literal|5
condition|)
name|error
argument_list|(
literal|"-mbranch-cost=%d is not between 0 and 5"
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
name|ix86_branch_cost
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|ix86_section_threshold_string
condition|)
block|{
name|i
operator|=
name|atoi
argument_list|(
name|ix86_section_threshold_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"-mlarge-data-threshold=%d is negative"
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
name|ix86_section_threshold
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|ix86_tls_dialect_string
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|ix86_tls_dialect_string
argument_list|,
literal|"gnu"
argument_list|)
operator|==
literal|0
condition|)
name|ix86_tls_dialect
operator|=
name|TLS_DIALECT_GNU
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|ix86_tls_dialect_string
argument_list|,
literal|"gnu2"
argument_list|)
operator|==
literal|0
condition|)
name|ix86_tls_dialect
operator|=
name|TLS_DIALECT_GNU2
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|ix86_tls_dialect_string
argument_list|,
literal|"sun"
argument_list|)
operator|==
literal|0
condition|)
name|ix86_tls_dialect
operator|=
name|TLS_DIALECT_SUN
expr_stmt|;
else|else
name|error
argument_list|(
literal|"bad value (%s) for -mtls-dialect= switch"
argument_list|,
name|ix86_tls_dialect_string
argument_list|)
expr_stmt|;
block|}
comment|/* Keep nonleaf frame pointers.  */
if|if
condition|(
name|flag_omit_frame_pointer
condition|)
name|target_flags
operator|&=
operator|~
name|MASK_OMIT_LEAF_FRAME_POINTER
expr_stmt|;
elseif|else
if|if
condition|(
name|TARGET_OMIT_LEAF_FRAME_POINTER
condition|)
name|flag_omit_frame_pointer
operator|=
literal|1
expr_stmt|;
comment|/* If we're doing fast math, we don't care about comparison order      wrt NaNs.  This lets us use a shorter comparison sequence.  */
if|if
condition|(
name|flag_finite_math_only
condition|)
name|target_flags
operator|&=
operator|~
name|MASK_IEEE_FP
expr_stmt|;
comment|/* If the architecture always has an FPU, turn off NO_FANCY_MATH_387,      since the insns won't need emulation.  */
if|if
condition|(
name|x86_arch_always_fancy_math_387
operator|&
operator|(
literal|1
operator|<<
name|ix86_arch
operator|)
condition|)
name|target_flags
operator|&=
operator|~
name|MASK_NO_FANCY_MATH_387
expr_stmt|;
comment|/* Likewise, if the target doesn't have a 387, or we've specified      software floating point, don't use 387 inline intrinsics.  */
if|if
condition|(
operator|!
name|TARGET_80387
condition|)
name|target_flags
operator||=
name|MASK_NO_FANCY_MATH_387
expr_stmt|;
comment|/* Turn on SSE2 builtins for -msse3.  */
if|if
condition|(
name|TARGET_SSE3
condition|)
name|target_flags
operator||=
name|MASK_SSE2
expr_stmt|;
comment|/* Turn on SSE builtins for -msse2.  */
if|if
condition|(
name|TARGET_SSE2
condition|)
name|target_flags
operator||=
name|MASK_SSE
expr_stmt|;
comment|/* Turn on MMX builtins for -msse.  */
if|if
condition|(
name|TARGET_SSE
condition|)
block|{
name|target_flags
operator||=
name|MASK_MMX
operator|&
operator|~
name|target_flags_explicit
expr_stmt|;
name|x86_prefetch_sse
operator|=
name|true
expr_stmt|;
block|}
comment|/* Turn on MMX builtins for 3Dnow.  */
if|if
condition|(
name|TARGET_3DNOW
condition|)
name|target_flags
operator||=
name|MASK_MMX
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
if|if
condition|(
name|TARGET_ALIGN_DOUBLE
condition|)
name|error
argument_list|(
literal|"-malign-double makes no sense in the 64bit mode"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_RTD
condition|)
name|error
argument_list|(
literal|"-mrtd calling convention not supported in the 64bit mode"
argument_list|)
expr_stmt|;
comment|/* Enable by default the SSE and MMX builtins.  Do allow the user to 	 explicitly disable any of these.  In particular, disabling SSE and 	 MMX for kernel code is extremely useful.  */
name|target_flags
operator||=
operator|(
operator|(
name|MASK_SSE2
operator||
name|MASK_SSE
operator||
name|MASK_MMX
operator||
name|MASK_128BIT_LONG_DOUBLE
operator|)
operator|&
operator|~
name|target_flags_explicit
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* i386 ABI does not specify red zone.  It still makes sense to use it          when programmer takes care to stack from being destroyed.  */
if|if
condition|(
operator|!
operator|(
name|target_flags_explicit
operator|&
name|MASK_NO_RED_ZONE
operator|)
condition|)
name|target_flags
operator||=
name|MASK_NO_RED_ZONE
expr_stmt|;
block|}
comment|/* Validate -mpreferred-stack-boundary= value, or provide default.      The default of 128 bits is for Pentium III's SSE __m128.  We can't      change it because of optimize_size.  Otherwise, we can't mix object      files compiled with -Os and -On.  */
name|ix86_preferred_stack_boundary
operator|=
literal|128
expr_stmt|;
if|if
condition|(
name|ix86_preferred_stack_boundary_string
condition|)
block|{
name|i
operator|=
name|atoi
argument_list|(
name|ix86_preferred_stack_boundary_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
operator|(
name|TARGET_64BIT
condition|?
literal|4
else|:
literal|2
operator|)
operator|||
name|i
operator|>
literal|12
condition|)
name|error
argument_list|(
literal|"-mpreferred-stack-boundary=%d is not between %d and 12"
argument_list|,
name|i
argument_list|,
name|TARGET_64BIT
condition|?
literal|4
else|:
literal|2
argument_list|)
expr_stmt|;
else|else
name|ix86_preferred_stack_boundary
operator|=
operator|(
literal|1
operator|<<
name|i
operator|)
operator|*
name|BITS_PER_UNIT
expr_stmt|;
block|}
comment|/* Accept -msseregparm only if at least SSE support is enabled.  */
if|if
condition|(
name|TARGET_SSEREGPARM
operator|&&
operator|!
name|TARGET_SSE
condition|)
name|error
argument_list|(
literal|"-msseregparm used without SSE enabled"
argument_list|)
expr_stmt|;
name|ix86_fpmath
operator|=
name|TARGET_FPMATH_DEFAULT
expr_stmt|;
if|if
condition|(
name|ix86_fpmath_string
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ix86_fpmath_string
argument_list|,
literal|"387"
argument_list|)
condition|)
name|ix86_fpmath
operator|=
name|FPMATH_387
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ix86_fpmath_string
argument_list|,
literal|"sse"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|TARGET_SSE
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"SSE instruction set disabled, using 387 arithmetics"
argument_list|)
expr_stmt|;
name|ix86_fpmath
operator|=
name|FPMATH_387
expr_stmt|;
block|}
else|else
name|ix86_fpmath
operator|=
name|FPMATH_SSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ix86_fpmath_string
argument_list|,
literal|"387,sse"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|ix86_fpmath_string
argument_list|,
literal|"sse,387"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|TARGET_SSE
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"SSE instruction set disabled, using 387 arithmetics"
argument_list|)
expr_stmt|;
name|ix86_fpmath
operator|=
name|FPMATH_387
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|TARGET_80387
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"387 instruction set disabled, using SSE arithmetics"
argument_list|)
expr_stmt|;
name|ix86_fpmath
operator|=
name|FPMATH_SSE
expr_stmt|;
block|}
else|else
name|ix86_fpmath
operator|=
name|FPMATH_SSE
operator||
name|FPMATH_387
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"bad value (%s) for -mfpmath= switch"
argument_list|,
name|ix86_fpmath_string
argument_list|)
expr_stmt|;
block|}
comment|/* If the i387 is disabled, then do not return values in it. */
if|if
condition|(
operator|!
name|TARGET_80387
condition|)
name|target_flags
operator|&=
operator|~
name|MASK_FLOAT_RETURNS
expr_stmt|;
if|if
condition|(
operator|(
name|x86_accumulate_outgoing_args
operator|&
name|TUNEMASK
operator|)
operator|&&
operator|!
operator|(
name|target_flags_explicit
operator|&
name|MASK_ACCUMULATE_OUTGOING_ARGS
operator|)
operator|&&
operator|!
name|optimize_size
condition|)
name|target_flags
operator||=
name|MASK_ACCUMULATE_OUTGOING_ARGS
expr_stmt|;
comment|/* ??? Unwind info is not correct around the CFG unless either a frame      pointer is present or M_A_O_A is set.  Fixing this requires rewriting      unwind info generation to be aware of the CFG and propagating states      around edges.  */
if|if
condition|(
operator|(
name|flag_unwind_tables
operator|||
name|flag_asynchronous_unwind_tables
operator|||
name|flag_exceptions
operator|||
name|flag_non_call_exceptions
operator|)
operator|&&
name|flag_omit_frame_pointer
operator|&&
operator|!
operator|(
name|target_flags
operator|&
name|MASK_ACCUMULATE_OUTGOING_ARGS
operator|)
condition|)
block|{
if|if
condition|(
name|target_flags_explicit
operator|&
name|MASK_ACCUMULATE_OUTGOING_ARGS
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"unwind tables currently require either a frame pointer "
literal|"or -maccumulate-outgoing-args for correctness"
argument_list|)
expr_stmt|;
name|target_flags
operator||=
name|MASK_ACCUMULATE_OUTGOING_ARGS
expr_stmt|;
block|}
comment|/* Figure out what ASM_GENERATE_INTERNAL_LABEL builds as a prefix.  */
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|internal_label_prefix
argument_list|,
literal|"LX"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|internal_label_prefix
argument_list|,
literal|'X'
argument_list|)
expr_stmt|;
name|internal_label_prefix_len
operator|=
name|p
operator|-
name|internal_label_prefix
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* When scheduling description is not available, disable scheduler pass      so it won't slow down the compilation and make x87 code slower.  */
if|if
condition|(
operator|!
name|TARGET_SCHEDULE
condition|)
name|flag_schedule_insns_after_reload
operator|=
name|flag_schedule_insns
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* switch to the appropriate section for output of DECL.    DECL is either a `VAR_DECL' node or a constant of some sort.    RELOC indicates whether forming the initial value of DECL requires    link-time relocations.  */
end_comment

begin_function
specifier|static
name|section
modifier|*
name|x86_64_elf_select_section
parameter_list|(
name|tree
name|decl
parameter_list|,
name|int
name|reloc
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|align
parameter_list|)
block|{
if|if
condition|(
operator|(
name|ix86_cmodel
operator|==
name|CM_MEDIUM
operator|||
name|ix86_cmodel
operator|==
name|CM_MEDIUM_PIC
operator|)
operator|&&
name|ix86_in_large_data_p
argument_list|(
name|decl
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|sname
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|flags
init|=
name|SECTION_WRITE
decl_stmt|;
switch|switch
condition|(
name|categorize_decl_for_section
argument_list|(
name|decl
argument_list|,
name|reloc
argument_list|)
condition|)
block|{
case|case
name|SECCAT_DATA
case|:
name|sname
operator|=
literal|".ldata"
expr_stmt|;
break|break;
case|case
name|SECCAT_DATA_REL
case|:
name|sname
operator|=
literal|".ldata.rel"
expr_stmt|;
break|break;
case|case
name|SECCAT_DATA_REL_LOCAL
case|:
name|sname
operator|=
literal|".ldata.rel.local"
expr_stmt|;
break|break;
case|case
name|SECCAT_DATA_REL_RO
case|:
name|sname
operator|=
literal|".ldata.rel.ro"
expr_stmt|;
break|break;
case|case
name|SECCAT_DATA_REL_RO_LOCAL
case|:
name|sname
operator|=
literal|".ldata.rel.ro.local"
expr_stmt|;
break|break;
case|case
name|SECCAT_BSS
case|:
name|sname
operator|=
literal|".lbss"
expr_stmt|;
name|flags
operator||=
name|SECTION_BSS
expr_stmt|;
break|break;
case|case
name|SECCAT_RODATA
case|:
case|case
name|SECCAT_RODATA_MERGE_STR
case|:
case|case
name|SECCAT_RODATA_MERGE_STR_INIT
case|:
case|case
name|SECCAT_RODATA_MERGE_CONST
case|:
name|sname
operator|=
literal|".lrodata"
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SECCAT_SRODATA
case|:
case|case
name|SECCAT_SDATA
case|:
case|case
name|SECCAT_SBSS
case|:
name|gcc_unreachable
argument_list|()
expr_stmt|;
case|case
name|SECCAT_TEXT
case|:
case|case
name|SECCAT_TDATA
case|:
case|case
name|SECCAT_TBSS
case|:
comment|/* We don't split these for medium model.  Place them into 	     default sections and hope for best.  */
break|break;
block|}
if|if
condition|(
name|sname
condition|)
block|{
comment|/* We might get called with string constants, but get_named_section 	     doesn't like them as they are not DECLs.  Also, we need to set 	     flags in that case.  */
if|if
condition|(
operator|!
name|DECL_P
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|get_section
argument_list|(
name|sname
argument_list|,
name|flags
argument_list|,
name|NULL
argument_list|)
return|;
return|return
name|get_named_section
argument_list|(
name|decl
argument_list|,
name|sname
argument_list|,
name|reloc
argument_list|)
return|;
block|}
block|}
return|return
name|default_elf_select_section
argument_list|(
name|decl
argument_list|,
name|reloc
argument_list|,
name|align
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Build up a unique section name, expressed as a    STRING_CST node, and assign it to DECL_SECTION_NAME (decl).    RELOC indicates whether the initial value of EXP requires    link-time relocations.  */
end_comment

begin_function
specifier|static
name|void
name|x86_64_elf_unique_section
parameter_list|(
name|tree
name|decl
parameter_list|,
name|int
name|reloc
parameter_list|)
block|{
if|if
condition|(
operator|(
name|ix86_cmodel
operator|==
name|CM_MEDIUM
operator|||
name|ix86_cmodel
operator|==
name|CM_MEDIUM_PIC
operator|)
operator|&&
name|ix86_in_large_data_p
argument_list|(
name|decl
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|prefix
init|=
name|NULL
decl_stmt|;
comment|/* We only need to use .gnu.linkonce if we don't have COMDAT groups.  */
name|bool
name|one_only
init|=
name|DECL_ONE_ONLY
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|HAVE_COMDAT_GROUP
decl_stmt|;
switch|switch
condition|(
name|categorize_decl_for_section
argument_list|(
name|decl
argument_list|,
name|reloc
argument_list|)
condition|)
block|{
case|case
name|SECCAT_DATA
case|:
case|case
name|SECCAT_DATA_REL
case|:
case|case
name|SECCAT_DATA_REL_LOCAL
case|:
case|case
name|SECCAT_DATA_REL_RO
case|:
case|case
name|SECCAT_DATA_REL_RO_LOCAL
case|:
name|prefix
operator|=
name|one_only
condition|?
literal|".gnu.linkonce.ld."
else|:
literal|".ldata."
expr_stmt|;
break|break;
case|case
name|SECCAT_BSS
case|:
name|prefix
operator|=
name|one_only
condition|?
literal|".gnu.linkonce.lb."
else|:
literal|".lbss."
expr_stmt|;
break|break;
case|case
name|SECCAT_RODATA
case|:
case|case
name|SECCAT_RODATA_MERGE_STR
case|:
case|case
name|SECCAT_RODATA_MERGE_STR_INIT
case|:
case|case
name|SECCAT_RODATA_MERGE_CONST
case|:
name|prefix
operator|=
name|one_only
condition|?
literal|".gnu.linkonce.lr."
else|:
literal|".lrodata."
expr_stmt|;
break|break;
case|case
name|SECCAT_SRODATA
case|:
case|case
name|SECCAT_SDATA
case|:
case|case
name|SECCAT_SBSS
case|:
name|gcc_unreachable
argument_list|()
expr_stmt|;
case|case
name|SECCAT_TEXT
case|:
case|case
name|SECCAT_TDATA
case|:
case|case
name|SECCAT_TBSS
case|:
comment|/* We don't split these for medium model.  Place them into 	     default sections and hope for best.  */
break|break;
block|}
if|if
condition|(
name|prefix
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|size_t
name|nlen
decl_stmt|,
name|plen
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|plen
operator|=
name|strlen
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|name
operator|=
name|targetm
operator|.
name|strip_name_encoding
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|nlen
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|string
operator|=
name|alloca
argument_list|(
name|nlen
operator|+
name|plen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|string
argument_list|,
name|prefix
argument_list|,
name|plen
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|string
operator|+
name|plen
argument_list|,
name|name
argument_list|,
name|nlen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|DECL_SECTION_NAME
argument_list|(
name|decl
argument_list|)
operator|=
name|build_string
argument_list|(
name|nlen
operator|+
name|plen
argument_list|,
name|string
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|default_unique_section
argument_list|(
name|decl
argument_list|,
name|reloc
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|COMMON_ASM_OP
end_ifdef

begin_comment
comment|/* This says how to output assembler code to declare an    uninitialized external linkage data object.     For medium model x86-64 we need to use .largecomm opcode for    large objects.  */
end_comment

begin_function
name|void
name|x86_elf_aligned_common
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|size
parameter_list|,
name|int
name|align
parameter_list|)
block|{
if|if
condition|(
operator|(
name|ix86_cmodel
operator|==
name|CM_MEDIUM
operator|||
name|ix86_cmodel
operator|==
name|CM_MEDIUM_PIC
operator|)
operator|&&
name|size
operator|>
operator|(
name|unsigned
name|int
operator|)
name|ix86_section_threshold
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|".largecomm\t"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|COMMON_ASM_OP
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|","
name|HOST_WIDE_INT_PRINT_UNSIGNED
literal|",%u\n"
argument_list|,
name|size
argument_list|,
name|align
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Utility function for targets to use in implementing    ASM_OUTPUT_ALIGNED_BSS.  */
end_comment

begin_function
name|void
name|x86_output_aligned_bss
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|tree
name|decl
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|size
parameter_list|,
name|int
name|align
parameter_list|)
block|{
if|if
condition|(
operator|(
name|ix86_cmodel
operator|==
name|CM_MEDIUM
operator|||
name|ix86_cmodel
operator|==
name|CM_MEDIUM_PIC
operator|)
operator|&&
name|size
operator|>
operator|(
name|unsigned
name|int
operator|)
name|ix86_section_threshold
condition|)
name|switch_to_section
argument_list|(
name|get_named_section
argument_list|(
name|decl
argument_list|,
literal|".lbss"
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|switch_to_section
argument_list|(
name|bss_section
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_ALIGN
argument_list|(
name|file
argument_list|,
name|floor_log2
argument_list|(
name|align
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ASM_DECLARE_OBJECT_NAME
name|last_assemble_variable_decl
operator|=
name|decl
expr_stmt|;
name|ASM_DECLARE_OBJECT_NAME
argument_list|(
name|file
argument_list|,
name|name
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Standard thing is just output label for the object.  */
name|ASM_OUTPUT_LABEL
argument_list|(
name|file
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ASM_DECLARE_OBJECT_NAME */
name|ASM_OUTPUT_SKIP
argument_list|(
name|file
argument_list|,
name|size
condition|?
name|size
else|:
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_function
name|void
name|optimization_options
parameter_list|(
name|int
name|level
parameter_list|,
name|int
name|size
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* For -O2 and beyond, turn off -fschedule-insns by default.  It tends to      make the problem with not enough registers even worse.  */
ifdef|#
directive|ifdef
name|INSN_SCHEDULING
if|if
condition|(
name|level
operator|>
literal|1
condition|)
name|flag_schedule_insns
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|TARGET_MACHO
condition|)
comment|/* The Darwin libraries never set errno, so we might as well        avoid calling them when that's the only reason we would.  */
name|flag_errno_math
operator|=
literal|0
expr_stmt|;
comment|/* The default values of these switches depend on the TARGET_64BIT      that is not known at this moment.  Mark these values with 2 and      let user the to override these.  In case there is no command line option      specifying them, we will set the defaults in override_options.  */
if|if
condition|(
name|optimize
operator|>=
literal|1
condition|)
name|flag_omit_frame_pointer
operator|=
literal|2
expr_stmt|;
name|flag_pcc_struct_return
operator|=
literal|2
expr_stmt|;
name|flag_asynchronous_unwind_tables
operator|=
literal|2
expr_stmt|;
ifdef|#
directive|ifdef
name|SUBTARGET_OPTIMIZATION_OPTIONS
name|SUBTARGET_OPTIMIZATION_OPTIONS
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Table of valid machine attributes.  */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|attribute_spec
name|ix86_attribute_table
index|[]
init|=
block|{
comment|/* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */
comment|/* Stdcall attribute says callee is responsible for popping arguments      if they are not variable.  */
block|{
literal|"stdcall"
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|true
block|,
name|true
block|,
name|ix86_handle_cconv_attribute
block|}
block|,
comment|/* Fastcall attribute says callee is responsible for popping arguments      if they are not variable.  */
block|{
literal|"fastcall"
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|true
block|,
name|true
block|,
name|ix86_handle_cconv_attribute
block|}
block|,
comment|/* Cdecl attribute says the callee is a normal C declaration */
block|{
literal|"cdecl"
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|true
block|,
name|true
block|,
name|ix86_handle_cconv_attribute
block|}
block|,
comment|/* Regparm attribute specifies how many integer arguments are to be      passed in registers.  */
block|{
literal|"regparm"
block|,
literal|1
block|,
literal|1
block|,
name|false
block|,
name|true
block|,
name|true
block|,
name|ix86_handle_cconv_attribute
block|}
block|,
comment|/* Sseregparm attribute says we are using x86_64 calling conventions      for FP arguments.  */
block|{
literal|"sseregparm"
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|true
block|,
name|true
block|,
name|ix86_handle_cconv_attribute
block|}
block|,
comment|/* force_align_arg_pointer says this function realigns the stack at entry.  */
block|{
operator|(
specifier|const
name|char
operator|*
operator|)
operator|&
name|ix86_force_align_arg_pointer_string
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|true
block|,
name|true
block|,
name|ix86_handle_cconv_attribute
block|}
block|,
if|#
directive|if
name|TARGET_DLLIMPORT_DECL_ATTRIBUTES
block|{
literal|"dllimport"
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|handle_dll_attribute
block|}
block|,
block|{
literal|"dllexport"
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|handle_dll_attribute
block|}
block|,
block|{
literal|"shared"
block|,
literal|0
block|,
literal|0
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|ix86_handle_shared_attribute
block|}
block|,
endif|#
directive|endif
block|{
literal|"ms_struct"
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|ix86_handle_struct_attribute
block|}
block|,
block|{
literal|"gcc_struct"
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|ix86_handle_struct_attribute
block|}
block|,
ifdef|#
directive|ifdef
name|SUBTARGET_ATTRIBUTE_TABLE
name|SUBTARGET_ATTRIBUTE_TABLE
block|,
endif|#
directive|endif
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Decide whether we can make a sibling call to a function.  DECL is the    declaration of the function being targeted by the call and EXP is the    CALL_EXPR representing the call.  */
end_comment

begin_function
specifier|static
name|bool
name|ix86_function_ok_for_sibcall
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|exp
parameter_list|)
block|{
name|tree
name|func
decl_stmt|;
name|rtx
name|a
decl_stmt|,
name|b
decl_stmt|;
comment|/* If we are generating position-independent code, we cannot sibcall      optimize any indirect call, or a direct call to a global function,      as the PLT requires %ebx be live.  */
if|if
condition|(
operator|!
name|TARGET_64BIT
operator|&&
name|flag_pic
operator|&&
operator|(
operator|!
name|decl
operator|||
operator|!
name|targetm
operator|.
name|binds_local_p
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|decl
condition|)
name|func
operator|=
name|decl
expr_stmt|;
else|else
block|{
name|func
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|func
argument_list|)
condition|)
name|func
operator|=
name|TREE_TYPE
argument_list|(
name|func
argument_list|)
expr_stmt|;
block|}
comment|/* Check that the return value locations are the same.  Like      if we are returning floats on the 80387 register stack, we cannot      make a sibcall from a function that doesn't return a float to a      function that does or, conversely, from a function that does return      a float to a function that doesn't; the necessary stack adjustment      would not be executed.  This is also the place we notice      differences in the return value ABI.  Note that it is ok for one      of the functions to have void return type as long as the return      value of the other is passed in a register.  */
name|a
operator|=
name|ix86_function_value
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|func
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|b
operator|=
name|ix86_function_value
argument_list|(
name|TREE_TYPE
argument_list|(
name|DECL_RESULT
argument_list|(
name|cfun
operator|->
name|decl
argument_list|)
argument_list|)
argument_list|,
name|cfun
operator|->
name|decl
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|STACK_REG_P
argument_list|(
name|a
argument_list|)
operator|||
name|STACK_REG_P
argument_list|(
name|b
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
condition|)
return|return
name|false
return|;
block|}
elseif|else
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|DECL_RESULT
argument_list|(
name|cfun
operator|->
name|decl
argument_list|)
argument_list|)
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* If this call is indirect, we'll need to be able to use a call-clobbered      register for the address of the target function.  Make sure that all      such registers are not used for passing parameters.  */
if|if
condition|(
operator|!
name|decl
operator|&&
operator|!
name|TARGET_64BIT
condition|)
block|{
name|tree
name|type
decl_stmt|;
comment|/* We're looking at the CALL_EXPR, we need the type of the function.  */
name|type
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* pointer expression */
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* pointer type */
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* function type */
if|if
condition|(
name|ix86_function_regparm
argument_list|(
name|type
argument_list|,
name|NULL
argument_list|)
operator|>=
literal|3
condition|)
block|{
comment|/* ??? Need to count the actual number of registers to be used, 	     not the possible number of registers.  Fix later.  */
return|return
name|false
return|;
block|}
block|}
if|#
directive|if
name|TARGET_DLLIMPORT_DECL_ATTRIBUTES
comment|/* Dllimport'd functions are also called indirectly.  */
if|if
condition|(
name|decl
operator|&&
name|DECL_DLLIMPORT_P
argument_list|(
name|decl
argument_list|)
operator|&&
name|ix86_function_regparm
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|NULL
argument_list|)
operator|>=
literal|3
condition|)
return|return
name|false
return|;
endif|#
directive|endif
comment|/* If we forced aligned the stack, then sibcalling would unalign the      stack, which may break the called function.  */
if|if
condition|(
name|cfun
operator|->
name|machine
operator|->
name|force_align_arg_pointer
condition|)
return|return
name|false
return|;
comment|/* Otherwise okay.  That also includes certain types of indirect calls.  */
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Handle "cdecl", "stdcall", "fastcall", "regparm" and "sseregparm"    calling convention attributes;    arguments as in struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|ix86_handle_cconv_attribute
parameter_list|(
name|tree
modifier|*
name|node
parameter_list|,
name|tree
name|name
parameter_list|,
name|tree
name|args
parameter_list|,
name|int
name|flags
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bool
modifier|*
name|no_add_attrs
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|!=
name|FUNCTION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|!=
name|METHOD_TYPE
operator|&&
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|!=
name|FIELD_DECL
operator|&&
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
block|{
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"%qs attribute only applies to functions"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
comment|/* Can combine regparm with all attributes but fastcall.  */
if|if
condition|(
name|is_attribute_p
argument_list|(
literal|"regparm"
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|tree
name|cst
decl_stmt|;
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"fastcall"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
operator|*
name|node
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"fastcall and regparm attributes are not compatible"
argument_list|)
expr_stmt|;
block|}
name|cst
operator|=
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cst
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"%qs attribute requires an integer constant argument"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|compare_tree_int
argument_list|(
name|cst
argument_list|,
name|REGPARM_MAX
argument_list|)
operator|>
literal|0
condition|)
block|{
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"argument to %qs attribute larger than %d"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|,
name|REGPARM_MAX
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TARGET_64BIT
operator|&&
name|lookup_attribute
argument_list|(
name|ix86_force_align_arg_pointer_string
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
operator|*
name|node
argument_list|)
argument_list|)
operator|&&
name|compare_tree_int
argument_list|(
name|cst
argument_list|,
name|REGPARM_MAX
operator|-
literal|1
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%s functions limited to %d register parameters"
argument_list|,
name|ix86_force_align_arg_pointer_string
argument_list|,
name|REGPARM_MAX
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"%qs attribute ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
comment|/* Can combine fastcall with stdcall (redundant) and sseregparm.  */
if|if
condition|(
name|is_attribute_p
argument_list|(
literal|"fastcall"
argument_list|,
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"cdecl"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
operator|*
name|node
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"fastcall and cdecl attributes are not compatible"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"stdcall"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
operator|*
name|node
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"fastcall and stdcall attributes are not compatible"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"regparm"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
operator|*
name|node
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"fastcall and regparm attributes are not compatible"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Can combine stdcall with fastcall (redundant), regparm and      sseregparm.  */
elseif|else
if|if
condition|(
name|is_attribute_p
argument_list|(
literal|"stdcall"
argument_list|,
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"cdecl"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
operator|*
name|node
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"stdcall and cdecl attributes are not compatible"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"fastcall"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
operator|*
name|node
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"stdcall and fastcall attributes are not compatible"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Can combine cdecl with regparm and sseregparm.  */
elseif|else
if|if
condition|(
name|is_attribute_p
argument_list|(
literal|"cdecl"
argument_list|,
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"stdcall"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
operator|*
name|node
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"stdcall and cdecl attributes are not compatible"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"fastcall"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
operator|*
name|node
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"fastcall and cdecl attributes are not compatible"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Can combine sseregparm with all attributes.  */
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Return 0 if the attributes for two types are incompatible, 1 if they    are compatible, and 2 if they are nearly compatible (which causes a    warning to be generated).  */
end_comment

begin_function
specifier|static
name|int
name|ix86_comp_type_attributes
parameter_list|(
name|tree
name|type1
parameter_list|,
name|tree
name|type2
parameter_list|)
block|{
comment|/* Check for mismatch of non-default calling convention.  */
specifier|const
name|char
modifier|*
specifier|const
name|rtdstr
init|=
name|TARGET_RTD
condition|?
literal|"cdecl"
else|:
literal|"stdcall"
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type1
argument_list|)
operator|!=
name|FUNCTION_TYPE
condition|)
return|return
literal|1
return|;
comment|/* Check for mismatched fastcall/regparm types.  */
if|if
condition|(
operator|(
operator|!
name|lookup_attribute
argument_list|(
literal|"fastcall"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|type1
argument_list|)
argument_list|)
operator|!=
operator|!
name|lookup_attribute
argument_list|(
literal|"fastcall"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|type2
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|ix86_function_regparm
argument_list|(
name|type1
argument_list|,
name|NULL
argument_list|)
operator|!=
name|ix86_function_regparm
argument_list|(
name|type2
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
comment|/* Check for mismatched sseregparm types.  */
if|if
condition|(
operator|!
name|lookup_attribute
argument_list|(
literal|"sseregparm"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|type1
argument_list|)
argument_list|)
operator|!=
operator|!
name|lookup_attribute
argument_list|(
literal|"sseregparm"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|type2
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Check for mismatched return types (cdecl vs stdcall).  */
if|if
condition|(
operator|!
name|lookup_attribute
argument_list|(
name|rtdstr
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|type1
argument_list|)
argument_list|)
operator|!=
operator|!
name|lookup_attribute
argument_list|(
name|rtdstr
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|type2
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the regparm value for a function with the indicated TYPE and DECL.    DECL may be NULL when calling function indirectly    or considering a libcall.  */
end_comment

begin_function
specifier|static
name|int
name|ix86_function_regparm
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|decl
parameter_list|)
block|{
name|tree
name|attr
decl_stmt|;
name|int
name|regparm
init|=
name|ix86_regparm
decl_stmt|;
name|bool
name|user_convention
init|=
name|false
decl_stmt|;
if|if
condition|(
operator|!
name|TARGET_64BIT
condition|)
block|{
name|attr
operator|=
name|lookup_attribute
argument_list|(
literal|"regparm"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
condition|)
block|{
name|regparm
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_VALUE
argument_list|(
name|attr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|user_convention
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"fastcall"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
name|regparm
operator|=
literal|2
expr_stmt|;
name|user_convention
operator|=
name|true
expr_stmt|;
block|}
comment|/* Use register calling convention for local functions when possible.  */
if|if
condition|(
operator|!
name|TARGET_64BIT
operator|&&
operator|!
name|user_convention
operator|&&
name|decl
operator|&&
name|flag_unit_at_a_time
operator|&&
operator|!
name|profile_flag
condition|)
block|{
name|struct
name|cgraph_local_info
modifier|*
name|i
init|=
name|cgraph_local_info
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|&&
name|i
operator|->
name|local
condition|)
block|{
name|int
name|local_regparm
decl_stmt|,
name|globals
init|=
literal|0
decl_stmt|,
name|regno
decl_stmt|;
comment|/* Make sure no regparm register is taken by a global register 		 variable.  */
for|for
control|(
name|local_regparm
operator|=
literal|0
init|;
name|local_regparm
operator|<
literal|3
condition|;
name|local_regparm
operator|++
control|)
if|if
condition|(
name|global_regs
index|[
name|local_regparm
index|]
condition|)
break|break;
comment|/* We can't use regparm(3) for nested functions as these use 		 static chain pointer in third argument.  */
if|if
condition|(
name|local_regparm
operator|==
literal|3
operator|&&
name|decl_function_context
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_NO_STATIC_CHAIN
argument_list|(
name|decl
argument_list|)
condition|)
name|local_regparm
operator|=
literal|2
expr_stmt|;
comment|/* If the function realigns its stackpointer, the 		 prologue will clobber %ecx.  If we've already 		 generated code for the callee, the callee 		 DECL_STRUCT_FUNCTION is gone, so we fall back to 		 scanning the attributes for the self-realigning 		 property.  */
if|if
condition|(
operator|(
name|DECL_STRUCT_FUNCTION
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_STRUCT_FUNCTION
argument_list|(
name|decl
argument_list|)
operator|->
name|machine
operator|->
name|force_align_arg_pointer
operator|)
operator|||
operator|(
operator|!
name|DECL_STRUCT_FUNCTION
argument_list|(
name|decl
argument_list|)
operator|&&
name|lookup_attribute
argument_list|(
name|ix86_force_align_arg_pointer_string
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
name|local_regparm
operator|=
literal|2
expr_stmt|;
comment|/* Each global register variable increases register preassure, 		 so the more global reg vars there are, the smaller regparm 		 optimization use, unless requested by the user explicitly.  */
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
literal|6
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|global_regs
index|[
name|regno
index|]
condition|)
name|globals
operator|++
expr_stmt|;
name|local_regparm
operator|=
name|globals
operator|<
name|local_regparm
condition|?
name|local_regparm
operator|-
name|globals
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|local_regparm
operator|>
name|regparm
condition|)
name|regparm
operator|=
name|local_regparm
expr_stmt|;
block|}
block|}
block|}
return|return
name|regparm
return|;
block|}
end_function

begin_comment
comment|/* Return 1 or 2, if we can pass up to SSE_REGPARM_MAX SFmode (1) and    DFmode (2) arguments in SSE registers for a function with the    indicated TYPE and DECL.  DECL may be NULL when calling function    indirectly or considering a libcall.  Otherwise return 0.  */
end_comment

begin_function
specifier|static
name|int
name|ix86_function_sseregparm
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|decl
parameter_list|)
block|{
comment|/* Use SSE registers to pass SFmode and DFmode arguments if requested      by the sseregparm attribute.  */
if|if
condition|(
name|TARGET_SSEREGPARM
operator|||
operator|(
name|type
operator|&&
name|lookup_attribute
argument_list|(
literal|"sseregparm"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|TARGET_SSE
condition|)
block|{
if|if
condition|(
name|decl
condition|)
name|error
argument_list|(
literal|"Calling %qD with attribute sseregparm without "
literal|"SSE/SSE2 enabled"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"Calling %qT with attribute sseregparm without "
literal|"SSE/SSE2 enabled"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|2
return|;
block|}
comment|/* For local functions, pass up to SSE_REGPARM_MAX SFmode      (and DFmode for SSE2) arguments in SSE registers,      even for 32-bit targets.  */
if|if
condition|(
operator|!
name|TARGET_64BIT
operator|&&
name|decl
operator|&&
name|TARGET_SSE_MATH
operator|&&
name|flag_unit_at_a_time
operator|&&
operator|!
name|profile_flag
condition|)
block|{
name|struct
name|cgraph_local_info
modifier|*
name|i
init|=
name|cgraph_local_info
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|&&
name|i
operator|->
name|local
condition|)
return|return
name|TARGET_SSE2
condition|?
literal|2
else|:
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return true if EAX is live at the start of the function.  Used by    ix86_expand_prologue to determine if we need special help before    calling allocate_stack_worker.  */
end_comment

begin_function
specifier|static
name|bool
name|ix86_eax_live_at_start_p
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Cheat.  Don't bother working forward from ix86_function_regparm      to the function type to whether an actual argument is located in      eax.  Instead just look at cfg info, which is still close enough      to correct at this point.  This gives false positives for broken      functions that might use uninitialized data that happens to be      allocated in eax, but who cares?  */
return|return
name|REGNO_REG_SET_P
argument_list|(
name|ENTRY_BLOCK_PTR
operator|->
name|il
operator|.
name|rtl
operator|->
name|global_live_at_end
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Value is the number of bytes of arguments automatically    popped when returning from a subroutine call.    FUNDECL is the declaration node of the function (as a tree),    FUNTYPE is the data type of the function (as a tree),    or for a library call it is an identifier node for the subroutine name.    SIZE is the number of bytes of arguments passed on the stack.     On the 80386, the RTD insn may be used to pop them if the number      of args is fixed, but if the number is variable then the caller      must pop them all.  RTD can't be used for library calls now      because the library is compiled with the Unix compiler.    Use of RTD is a selectable option, since it is incompatible with    standard Unix calling sequences.  If the option is not selected,    the caller must always pop the args.     The attribute stdcall is equivalent to RTD on a per module basis.  */
end_comment

begin_function
name|int
name|ix86_return_pops_args
parameter_list|(
name|tree
name|fundecl
parameter_list|,
name|tree
name|funtype
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|int
name|rtd
init|=
name|TARGET_RTD
operator|&&
operator|(
operator|!
name|fundecl
operator|||
name|TREE_CODE
argument_list|(
name|fundecl
argument_list|)
operator|!=
name|IDENTIFIER_NODE
operator|)
decl_stmt|;
comment|/* Cdecl functions override -mrtd, and never pop the stack.  */
if|if
condition|(
operator|!
name|lookup_attribute
argument_list|(
literal|"cdecl"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|funtype
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Stdcall and fastcall functions will pop the stack if not        variable args.  */
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"stdcall"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|funtype
argument_list|)
argument_list|)
operator|||
name|lookup_attribute
argument_list|(
literal|"fastcall"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|funtype
argument_list|)
argument_list|)
condition|)
name|rtd
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|rtd
operator|&&
operator|(
name|TYPE_ARG_TYPES
argument_list|(
name|funtype
argument_list|)
operator|==
name|NULL_TREE
operator|||
operator|(
name|TREE_VALUE
argument_list|(
name|tree_last
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|funtype
argument_list|)
argument_list|)
argument_list|)
operator|==
name|void_type_node
operator|)
operator|)
condition|)
return|return
name|size
return|;
block|}
comment|/* Lose any fake structure return argument if it is passed on the stack.  */
if|if
condition|(
name|aggregate_value_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|funtype
argument_list|)
argument_list|,
name|fundecl
argument_list|)
operator|&&
operator|!
name|TARGET_64BIT
operator|&&
operator|!
name|KEEP_AGGREGATE_RETURN_POINTER
condition|)
block|{
name|int
name|nregs
init|=
name|ix86_function_regparm
argument_list|(
name|funtype
argument_list|,
name|fundecl
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|nregs
condition|)
return|return
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Argument support functions.  */
end_comment

begin_comment
comment|/* Return true when register may be used to pass function parameters.  */
end_comment

begin_function
name|bool
name|ix86_function_arg_regno_p
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|TARGET_64BIT
condition|)
block|{
if|if
condition|(
name|TARGET_MACHO
condition|)
return|return
operator|(
name|regno
operator|<
name|REGPARM_MAX
operator|||
operator|(
name|TARGET_SSE
operator|&&
name|SSE_REGNO_P
argument_list|(
name|regno
argument_list|)
operator|&&
operator|!
name|fixed_regs
index|[
name|regno
index|]
operator|)
operator|)
return|;
else|else
return|return
operator|(
name|regno
operator|<
name|REGPARM_MAX
operator|||
operator|(
name|TARGET_MMX
operator|&&
name|MMX_REGNO_P
argument_list|(
name|regno
argument_list|)
operator|&&
operator|(
name|regno
operator|<
name|FIRST_MMX_REG
operator|+
name|MMX_REGPARM_MAX
operator|)
operator|)
operator|||
operator|(
name|TARGET_SSE
operator|&&
name|SSE_REGNO_P
argument_list|(
name|regno
argument_list|)
operator|&&
operator|(
name|regno
operator|<
name|FIRST_SSE_REG
operator|+
name|SSE_REGPARM_MAX
operator|)
operator|)
operator|)
return|;
block|}
if|if
condition|(
name|TARGET_MACHO
condition|)
block|{
if|if
condition|(
name|SSE_REGNO_P
argument_list|(
name|regno
argument_list|)
operator|&&
name|TARGET_SSE
condition|)
return|return
name|true
return|;
block|}
else|else
block|{
if|if
condition|(
name|TARGET_SSE
operator|&&
name|SSE_REGNO_P
argument_list|(
name|regno
argument_list|)
operator|&&
operator|(
name|regno
operator|<
name|FIRST_SSE_REG
operator|+
name|SSE_REGPARM_MAX
operator|)
condition|)
return|return
name|true
return|;
block|}
comment|/* RAX is used as hidden argument to va_arg functions.  */
if|if
condition|(
operator|!
name|regno
condition|)
return|return
name|true
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGPARM_MAX
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regno
operator|==
name|x86_64_int_parameter_registers
index|[
name|i
index|]
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Return if we do not know how to pass TYPE solely in registers.  */
end_comment

begin_function
specifier|static
name|bool
name|ix86_must_pass_in_stack
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
if|if
condition|(
name|must_pass_in_stack_var_size_or_pad
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* For 32-bit, we want TImode aggregates to go on the stack.  But watch out!      The layout_type routine is crafty and tries to trick us into passing      currently unsupported vector types on the stack by using TImode.  */
return|return
operator|(
operator|!
name|TARGET_64BIT
operator|&&
name|mode
operator|==
name|TImode
operator|&&
name|type
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|VECTOR_TYPE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Initialize a variable CUM of type CUMULATIVE_ARGS    for a call to a function whose data type is FNTYPE.    For a library call, FNTYPE is 0.  */
end_comment

begin_function
name|void
name|init_cumulative_args
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
name|cum
parameter_list|,
comment|/* Argument info to initialize */
name|tree
name|fntype
parameter_list|,
comment|/* tree ptr for function decl */
name|rtx
name|libname
parameter_list|,
comment|/* SYMBOL_REF of library name or 0 */
name|tree
name|fndecl
parameter_list|)
block|{
specifier|static
name|CUMULATIVE_ARGS
name|zero_cum
decl_stmt|;
name|tree
name|param
decl_stmt|,
name|next_param
decl_stmt|;
if|if
condition|(
name|TARGET_DEBUG_ARG
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ninit_cumulative_args ("
argument_list|)
expr_stmt|;
if|if
condition|(
name|fntype
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"fntype code = %s, ret code = %s"
argument_list|,
name|tree_code_name
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|fntype
argument_list|)
index|]
argument_list|,
name|tree_code_name
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|)
index|]
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"no fntype"
argument_list|)
expr_stmt|;
if|if
condition|(
name|libname
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|", libname = %s"
argument_list|,
name|XSTR
argument_list|(
name|libname
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|cum
operator|=
name|zero_cum
expr_stmt|;
comment|/* Set up the number of registers to use for passing arguments.  */
name|cum
operator|->
name|nregs
operator|=
name|ix86_regparm
expr_stmt|;
if|if
condition|(
name|TARGET_SSE
condition|)
name|cum
operator|->
name|sse_nregs
operator|=
name|SSE_REGPARM_MAX
expr_stmt|;
if|if
condition|(
name|TARGET_MMX
condition|)
name|cum
operator|->
name|mmx_nregs
operator|=
name|MMX_REGPARM_MAX
expr_stmt|;
name|cum
operator|->
name|warn_sse
operator|=
name|true
expr_stmt|;
name|cum
operator|->
name|warn_mmx
operator|=
name|true
expr_stmt|;
name|cum
operator|->
name|maybe_vaarg
operator|=
name|false
expr_stmt|;
comment|/* Use ecx and edx registers if function has fastcall attribute,      else look for regparm information.  */
if|if
condition|(
name|fntype
operator|&&
operator|!
name|TARGET_64BIT
condition|)
block|{
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"fastcall"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|fntype
argument_list|)
argument_list|)
condition|)
block|{
name|cum
operator|->
name|nregs
operator|=
literal|2
expr_stmt|;
name|cum
operator|->
name|fastcall
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|cum
operator|->
name|nregs
operator|=
name|ix86_function_regparm
argument_list|(
name|fntype
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
block|}
comment|/* Set up the number of SSE registers used for passing SFmode      and DFmode arguments.  Warn for mismatching ABI.  */
name|cum
operator|->
name|float_in_sse
operator|=
name|ix86_function_sseregparm
argument_list|(
name|fntype
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
comment|/* Determine if this function has variable arguments.  This is      indicated by the last argument being 'void_type_mode' if there      are no variable arguments.  If there are variable arguments, then      we won't pass anything in registers in 32-bit mode. */
if|if
condition|(
name|cum
operator|->
name|nregs
operator|||
name|cum
operator|->
name|mmx_nregs
operator|||
name|cum
operator|->
name|sse_nregs
condition|)
block|{
for|for
control|(
name|param
operator|=
operator|(
name|fntype
operator|)
condition|?
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
else|:
literal|0
init|;
name|param
operator|!=
literal|0
condition|;
name|param
operator|=
name|next_param
control|)
block|{
name|next_param
operator|=
name|TREE_CHAIN
argument_list|(
name|param
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_param
operator|==
literal|0
operator|&&
name|TREE_VALUE
argument_list|(
name|param
argument_list|)
operator|!=
name|void_type_node
condition|)
block|{
if|if
condition|(
operator|!
name|TARGET_64BIT
condition|)
block|{
name|cum
operator|->
name|nregs
operator|=
literal|0
expr_stmt|;
name|cum
operator|->
name|sse_nregs
operator|=
literal|0
expr_stmt|;
name|cum
operator|->
name|mmx_nregs
operator|=
literal|0
expr_stmt|;
name|cum
operator|->
name|warn_sse
operator|=
literal|0
expr_stmt|;
name|cum
operator|->
name|warn_mmx
operator|=
literal|0
expr_stmt|;
name|cum
operator|->
name|fastcall
operator|=
literal|0
expr_stmt|;
name|cum
operator|->
name|float_in_sse
operator|=
literal|0
expr_stmt|;
block|}
name|cum
operator|->
name|maybe_vaarg
operator|=
name|true
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
operator|!
name|fntype
operator|&&
operator|!
name|libname
operator|)
operator|||
operator|(
name|fntype
operator|&&
operator|!
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
operator|)
condition|)
name|cum
operator|->
name|maybe_vaarg
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|TARGET_DEBUG_ARG
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|", nregs=%d )\n"
argument_list|,
name|cum
operator|->
name|nregs
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Return the "natural" mode for TYPE.  In most cases, this is just TYPE_MODE.    But in the case of vector types, it is some vector mode.     When we have only some of our vector isa extensions enabled, then there    are some modes for which vector_mode_supported_p is false.  For these    modes, the generic vector support in gcc will choose some non-vector mode    in order to implement the type.  By computing the natural mode, we'll    select the proper ABI location for the operand and not depend on whatever    the middle-end decides to do with these vector types.  */
end_comment

begin_function
specifier|static
name|enum
name|machine_mode
name|type_natural_mode
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VECTOR_TYPE
operator|&&
operator|!
name|VECTOR_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|HOST_WIDE_INT
name|size
init|=
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|size
operator|==
literal|8
operator|||
name|size
operator|==
literal|16
operator|)
comment|/* ??? Generic code allows us to create width 1 vectors.  Ignore.  */
operator|&&
name|TYPE_VECTOR_SUBPARTS
argument_list|(
name|type
argument_list|)
operator|>
literal|1
condition|)
block|{
name|enum
name|machine_mode
name|innermode
init|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|REAL_TYPE
condition|)
name|mode
operator|=
name|MIN_MODE_VECTOR_FLOAT
expr_stmt|;
else|else
name|mode
operator|=
name|MIN_MODE_VECTOR_INT
expr_stmt|;
comment|/* Get the mode which has this inner mode and number of units.  */
for|for
control|(
init|;
name|mode
operator|!=
name|VOIDmode
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
if|if
condition|(
name|GET_MODE_NUNITS
argument_list|(
name|mode
argument_list|)
operator|==
name|TYPE_VECTOR_SUBPARTS
argument_list|(
name|type
argument_list|)
operator|&&
name|GET_MODE_INNER
argument_list|(
name|mode
argument_list|)
operator|==
name|innermode
condition|)
return|return
name|mode
return|;
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|mode
return|;
block|}
end_function

begin_comment
comment|/* We want to pass a value in REGNO whose "natural" mode is MODE.  However,    this may not agree with the mode that the type system has chosen for the    register, which is ORIG_MODE.  If ORIG_MODE is not BLKmode, then we can    go ahead and use it.  Otherwise we have to build a PARALLEL instead.  */
end_comment

begin_function
specifier|static
name|rtx
name|gen_reg_or_parallel
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|enum
name|machine_mode
name|orig_mode
parameter_list|,
name|unsigned
name|int
name|regno
parameter_list|)
block|{
name|rtx
name|tmp
decl_stmt|;
if|if
condition|(
name|orig_mode
operator|!=
name|BLKmode
condition|)
name|tmp
operator|=
name|gen_rtx_REG
argument_list|(
name|orig_mode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
else|else
block|{
name|tmp
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|tmp
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_PARALLEL
argument_list|(
name|orig_mode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|tmp
return|;
block|}
end_function

begin_comment
comment|/* x86-64 register passing implementation.  See x86-64 ABI for details.  Goal    of this code is to classify each 8bytes of incoming argument by the register    class and assign registers accordingly.  */
end_comment

begin_comment
comment|/* Return the union class of CLASS1 and CLASS2.    See the x86-64 PS ABI for details.  */
end_comment

begin_function
specifier|static
name|enum
name|x86_64_reg_class
name|merge_classes
parameter_list|(
name|enum
name|x86_64_reg_class
name|class1
parameter_list|,
name|enum
name|x86_64_reg_class
name|class2
parameter_list|)
block|{
comment|/* Rule #1: If both classes are equal, this is the resulting class.  */
if|if
condition|(
name|class1
operator|==
name|class2
condition|)
return|return
name|class1
return|;
comment|/* Rule #2: If one of the classes is NO_CLASS, the resulting class is      the other class.  */
if|if
condition|(
name|class1
operator|==
name|X86_64_NO_CLASS
condition|)
return|return
name|class2
return|;
if|if
condition|(
name|class2
operator|==
name|X86_64_NO_CLASS
condition|)
return|return
name|class1
return|;
comment|/* Rule #3: If one of the classes is MEMORY, the result is MEMORY.  */
if|if
condition|(
name|class1
operator|==
name|X86_64_MEMORY_CLASS
operator|||
name|class2
operator|==
name|X86_64_MEMORY_CLASS
condition|)
return|return
name|X86_64_MEMORY_CLASS
return|;
comment|/* Rule #4: If one of the classes is INTEGER, the result is INTEGER.  */
if|if
condition|(
operator|(
name|class1
operator|==
name|X86_64_INTEGERSI_CLASS
operator|&&
name|class2
operator|==
name|X86_64_SSESF_CLASS
operator|)
operator|||
operator|(
name|class2
operator|==
name|X86_64_INTEGERSI_CLASS
operator|&&
name|class1
operator|==
name|X86_64_SSESF_CLASS
operator|)
condition|)
return|return
name|X86_64_INTEGERSI_CLASS
return|;
if|if
condition|(
name|class1
operator|==
name|X86_64_INTEGER_CLASS
operator|||
name|class1
operator|==
name|X86_64_INTEGERSI_CLASS
operator|||
name|class2
operator|==
name|X86_64_INTEGER_CLASS
operator|||
name|class2
operator|==
name|X86_64_INTEGERSI_CLASS
condition|)
return|return
name|X86_64_INTEGER_CLASS
return|;
comment|/* Rule #5: If one of the classes is X87, X87UP, or COMPLEX_X87 class,      MEMORY is used.  */
if|if
condition|(
name|class1
operator|==
name|X86_64_X87_CLASS
operator|||
name|class1
operator|==
name|X86_64_X87UP_CLASS
operator|||
name|class1
operator|==
name|X86_64_COMPLEX_X87_CLASS
operator|||
name|class2
operator|==
name|X86_64_X87_CLASS
operator|||
name|class2
operator|==
name|X86_64_X87UP_CLASS
operator|||
name|class2
operator|==
name|X86_64_COMPLEX_X87_CLASS
condition|)
return|return
name|X86_64_MEMORY_CLASS
return|;
comment|/* Rule #6: Otherwise class SSE is used.  */
return|return
name|X86_64_SSE_CLASS
return|;
block|}
end_function

begin_comment
comment|/* Classify the argument of type TYPE and mode MODE.    CLASSES will be filled by the register class used to pass each word    of the operand.  The number of words is returned.  In case the parameter    should be passed in memory, 0 is returned. As a special case for zero    sized containers, classes[0] will be NO_CLASS and 1 is returned.     BIT_OFFSET is used internally for handling records and specifies offset    of the offset in bits modulo 256 to avoid overflow cases.     See the x86-64 PS ABI for details. */
end_comment

begin_function
specifier|static
name|int
name|classify_argument
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|type
parameter_list|,
name|enum
name|x86_64_reg_class
name|classes
index|[
name|MAX_CLASSES
index|]
parameter_list|,
name|int
name|bit_offset
parameter_list|)
block|{
name|HOST_WIDE_INT
name|bytes
init|=
operator|(
name|mode
operator|==
name|BLKmode
operator|)
condition|?
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
else|:
operator|(
name|int
operator|)
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|int
name|words
init|=
operator|(
name|bytes
operator|+
operator|(
name|bit_offset
operator|%
literal|64
operator|)
operator|/
literal|8
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
decl_stmt|;
comment|/* Variable sized entities are always passed/returned in memory.  */
if|if
condition|(
name|bytes
operator|<
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|targetm
operator|.
name|calls
operator|.
name|must_pass_in_stack
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|type
operator|&&
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
name|tree
name|field
decl_stmt|;
name|enum
name|x86_64_reg_class
name|subclasses
index|[
name|MAX_CLASSES
index|]
decl_stmt|;
comment|/* On x86-64 we pass structures larger than 16 bytes on the stack.  */
if|if
condition|(
name|bytes
operator|>
literal|16
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
name|i
operator|++
control|)
name|classes
index|[
name|i
index|]
operator|=
name|X86_64_NO_CLASS
expr_stmt|;
comment|/* Zero sized arrays or structures are NO_CLASS.  We return 0 to 	 signalize memory class, so handle it as special case.  */
if|if
condition|(
operator|!
name|words
condition|)
block|{
name|classes
index|[
literal|0
index|]
operator|=
name|X86_64_NO_CLASS
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Classify each field of record and merge classes.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|RECORD_TYPE
case|:
comment|/* For classes first merge in the field of the subclasses.  */
if|if
condition|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|tree
name|binfo
decl_stmt|,
name|base_binfo
decl_stmt|;
name|int
name|basenum
decl_stmt|;
for|for
control|(
name|binfo
operator|=
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
operator|,
name|basenum
operator|=
literal|0
init|;
name|BINFO_BASE_ITERATE
argument_list|(
name|binfo
argument_list|,
name|basenum
argument_list|,
name|base_binfo
argument_list|)
condition|;
name|basenum
operator|++
control|)
block|{
name|int
name|num
decl_stmt|;
name|int
name|offset
init|=
name|tree_low_cst
argument_list|(
name|BINFO_OFFSET
argument_list|(
name|base_binfo
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|*
literal|8
decl_stmt|;
name|tree
name|type
init|=
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
decl_stmt|;
name|num
operator|=
name|classify_argument
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|type
argument_list|,
name|subclasses
argument_list|,
operator|(
name|offset
operator|+
name|bit_offset
operator|)
operator|%
literal|256
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|num
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|int
name|pos
init|=
operator|(
name|offset
operator|+
operator|(
name|bit_offset
operator|%
literal|64
operator|)
operator|)
operator|/
literal|8
operator|/
literal|8
decl_stmt|;
name|classes
index|[
name|i
operator|+
name|pos
index|]
operator|=
name|merge_classes
argument_list|(
name|subclasses
index|[
name|i
index|]
argument_list|,
name|classes
index|[
name|i
operator|+
name|pos
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* And now merge the fields of structure.  */
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
name|int
name|num
decl_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
operator|==
name|error_mark_node
condition|)
continue|continue;
comment|/* Bitfields are always classified as integer.  Handle them 		     early, since later code would consider them to be 		     misaligned integers.  */
if|if
condition|(
name|DECL_BIT_FIELD
argument_list|(
name|field
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
operator|(
name|int_bit_position
argument_list|(
name|field
argument_list|)
operator|+
operator|(
name|bit_offset
operator|%
literal|64
operator|)
operator|)
operator|/
literal|8
operator|/
literal|8
init|;
name|i
operator|<
operator|(
operator|(
name|int_bit_position
argument_list|(
name|field
argument_list|)
operator|+
operator|(
name|bit_offset
operator|%
literal|64
operator|)
operator|)
operator|+
name|tree_low_cst
argument_list|(
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|+
literal|63
operator|)
operator|/
literal|8
operator|/
literal|8
condition|;
name|i
operator|++
control|)
name|classes
index|[
name|i
index|]
operator|=
name|merge_classes
argument_list|(
name|X86_64_INTEGER_CLASS
argument_list|,
name|classes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|num
operator|=
name|classify_argument
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
name|subclasses
argument_list|,
operator|(
name|int_bit_position
argument_list|(
name|field
argument_list|)
operator|+
name|bit_offset
operator|)
operator|%
literal|256
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|num
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|int
name|pos
init|=
operator|(
name|int_bit_position
argument_list|(
name|field
argument_list|)
operator|+
operator|(
name|bit_offset
operator|%
literal|64
operator|)
operator|)
operator|/
literal|8
operator|/
literal|8
decl_stmt|;
name|classes
index|[
name|i
operator|+
name|pos
index|]
operator|=
name|merge_classes
argument_list|(
name|subclasses
index|[
name|i
index|]
argument_list|,
name|classes
index|[
name|i
operator|+
name|pos
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
break|break;
case|case
name|ARRAY_TYPE
case|:
comment|/* Arrays are handled as small records.  */
block|{
name|int
name|num
decl_stmt|;
name|num
operator|=
name|classify_argument
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|subclasses
argument_list|,
name|bit_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|num
condition|)
return|return
literal|0
return|;
comment|/* The partial classes are now full classes.  */
if|if
condition|(
name|subclasses
index|[
literal|0
index|]
operator|==
name|X86_64_SSESF_CLASS
operator|&&
name|bytes
operator|!=
literal|4
condition|)
name|subclasses
index|[
literal|0
index|]
operator|=
name|X86_64_SSE_CLASS
expr_stmt|;
if|if
condition|(
name|subclasses
index|[
literal|0
index|]
operator|==
name|X86_64_INTEGERSI_CLASS
operator|&&
name|bytes
operator|!=
literal|4
condition|)
name|subclasses
index|[
literal|0
index|]
operator|=
name|X86_64_INTEGER_CLASS
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
name|i
operator|++
control|)
name|classes
index|[
name|i
index|]
operator|=
name|subclasses
index|[
name|i
operator|%
name|num
index|]
expr_stmt|;
break|break;
block|}
case|case
name|UNION_TYPE
case|:
case|case
name|QUAL_UNION_TYPE
case|:
comment|/* Unions are similar to RECORD_TYPE but offset is always 0. 	     */
comment|/* Unions are not derived.  */
name|gcc_assert
argument_list|(
operator|!
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
operator|||
operator|!
name|BINFO_N_BASE_BINFOS
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
name|int
name|num
decl_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
operator|==
name|error_mark_node
condition|)
continue|continue;
name|num
operator|=
name|classify_argument
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
name|subclasses
argument_list|,
name|bit_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|num
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
name|classes
index|[
name|i
index|]
operator|=
name|merge_classes
argument_list|(
name|subclasses
index|[
name|i
index|]
argument_list|,
name|classes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
comment|/* Final merger cleanup.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
name|i
operator|++
control|)
block|{
comment|/* If one class is MEMORY, everything should be passed in 	     memory.  */
if|if
condition|(
name|classes
index|[
name|i
index|]
operator|==
name|X86_64_MEMORY_CLASS
condition|)
return|return
literal|0
return|;
comment|/* The X86_64_SSEUP_CLASS should be always preceded by 	     X86_64_SSE_CLASS.  */
if|if
condition|(
name|classes
index|[
name|i
index|]
operator|==
name|X86_64_SSEUP_CLASS
operator|&&
operator|(
name|i
operator|==
literal|0
operator|||
name|classes
index|[
name|i
operator|-
literal|1
index|]
operator|!=
name|X86_64_SSE_CLASS
operator|)
condition|)
name|classes
index|[
name|i
index|]
operator|=
name|X86_64_SSE_CLASS
expr_stmt|;
comment|/*  X86_64_X87UP_CLASS should be preceded by X86_64_X87_CLASS.  */
if|if
condition|(
name|classes
index|[
name|i
index|]
operator|==
name|X86_64_X87UP_CLASS
operator|&&
operator|(
name|i
operator|==
literal|0
operator|||
name|classes
index|[
name|i
operator|-
literal|1
index|]
operator|!=
name|X86_64_X87_CLASS
operator|)
condition|)
name|classes
index|[
name|i
index|]
operator|=
name|X86_64_SSE_CLASS
expr_stmt|;
block|}
return|return
name|words
return|;
block|}
comment|/* Compute alignment needed.  We align all types to natural boundaries with      exception of XFmode that is aligned to 64bits.  */
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|mode
operator|!=
name|BLKmode
condition|)
block|{
name|int
name|mode_alignment
init|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|XFmode
condition|)
name|mode_alignment
operator|=
literal|128
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|XCmode
condition|)
name|mode_alignment
operator|=
literal|256
expr_stmt|;
if|if
condition|(
name|COMPLEX_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
name|mode_alignment
operator|/=
literal|2
expr_stmt|;
comment|/* Misaligned fields are always returned in memory.  */
if|if
condition|(
name|bit_offset
operator|%
name|mode_alignment
condition|)
return|return
literal|0
return|;
block|}
comment|/* for V1xx modes, just use the base mode */
if|if
condition|(
name|VECTOR_MODE_P
argument_list|(
name|mode
argument_list|)
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE_INNER
argument_list|(
name|mode
argument_list|)
argument_list|)
operator|==
name|bytes
condition|)
name|mode
operator|=
name|GET_MODE_INNER
argument_list|(
name|mode
argument_list|)
expr_stmt|;
comment|/* Classification of atomic types.  */
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|SDmode
case|:
case|case
name|DDmode
case|:
name|classes
index|[
literal|0
index|]
operator|=
name|X86_64_SSE_CLASS
expr_stmt|;
return|return
literal|1
return|;
case|case
name|TDmode
case|:
name|classes
index|[
literal|0
index|]
operator|=
name|X86_64_SSE_CLASS
expr_stmt|;
name|classes
index|[
literal|1
index|]
operator|=
name|X86_64_SSEUP_CLASS
expr_stmt|;
return|return
literal|2
return|;
case|case
name|DImode
case|:
case|case
name|SImode
case|:
case|case
name|HImode
case|:
case|case
name|QImode
case|:
case|case
name|CSImode
case|:
case|case
name|CHImode
case|:
case|case
name|CQImode
case|:
if|if
condition|(
name|bit_offset
operator|+
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<=
literal|32
condition|)
name|classes
index|[
literal|0
index|]
operator|=
name|X86_64_INTEGERSI_CLASS
expr_stmt|;
else|else
name|classes
index|[
literal|0
index|]
operator|=
name|X86_64_INTEGER_CLASS
expr_stmt|;
return|return
literal|1
return|;
case|case
name|CDImode
case|:
case|case
name|TImode
case|:
name|classes
index|[
literal|0
index|]
operator|=
name|classes
index|[
literal|1
index|]
operator|=
name|X86_64_INTEGER_CLASS
expr_stmt|;
return|return
literal|2
return|;
case|case
name|CTImode
case|:
return|return
literal|0
return|;
case|case
name|SFmode
case|:
if|if
condition|(
operator|!
operator|(
name|bit_offset
operator|%
literal|64
operator|)
condition|)
name|classes
index|[
literal|0
index|]
operator|=
name|X86_64_SSESF_CLASS
expr_stmt|;
else|else
name|classes
index|[
literal|0
index|]
operator|=
name|X86_64_SSE_CLASS
expr_stmt|;
return|return
literal|1
return|;
case|case
name|DFmode
case|:
name|classes
index|[
literal|0
index|]
operator|=
name|X86_64_SSEDF_CLASS
expr_stmt|;
return|return
literal|1
return|;
case|case
name|XFmode
case|:
name|classes
index|[
literal|0
index|]
operator|=
name|X86_64_X87_CLASS
expr_stmt|;
name|classes
index|[
literal|1
index|]
operator|=
name|X86_64_X87UP_CLASS
expr_stmt|;
return|return
literal|2
return|;
case|case
name|TFmode
case|:
name|classes
index|[
literal|0
index|]
operator|=
name|X86_64_SSE_CLASS
expr_stmt|;
name|classes
index|[
literal|1
index|]
operator|=
name|X86_64_SSEUP_CLASS
expr_stmt|;
return|return
literal|2
return|;
case|case
name|SCmode
case|:
name|classes
index|[
literal|0
index|]
operator|=
name|X86_64_SSE_CLASS
expr_stmt|;
return|return
literal|1
return|;
case|case
name|DCmode
case|:
name|classes
index|[
literal|0
index|]
operator|=
name|X86_64_SSEDF_CLASS
expr_stmt|;
name|classes
index|[
literal|1
index|]
operator|=
name|X86_64_SSEDF_CLASS
expr_stmt|;
return|return
literal|2
return|;
case|case
name|XCmode
case|:
name|classes
index|[
literal|0
index|]
operator|=
name|X86_64_COMPLEX_X87_CLASS
expr_stmt|;
return|return
literal|1
return|;
case|case
name|TCmode
case|:
comment|/* This modes is larger than 16 bytes.  */
return|return
literal|0
return|;
case|case
name|V4SFmode
case|:
case|case
name|V4SImode
case|:
case|case
name|V16QImode
case|:
case|case
name|V8HImode
case|:
case|case
name|V2DFmode
case|:
case|case
name|V2DImode
case|:
name|classes
index|[
literal|0
index|]
operator|=
name|X86_64_SSE_CLASS
expr_stmt|;
name|classes
index|[
literal|1
index|]
operator|=
name|X86_64_SSEUP_CLASS
expr_stmt|;
return|return
literal|2
return|;
case|case
name|V2SFmode
case|:
case|case
name|V2SImode
case|:
case|case
name|V4HImode
case|:
case|case
name|V8QImode
case|:
name|classes
index|[
literal|0
index|]
operator|=
name|X86_64_SSE_CLASS
expr_stmt|;
return|return
literal|1
return|;
case|case
name|BLKmode
case|:
case|case
name|VOIDmode
case|:
return|return
literal|0
return|;
default|default:
name|gcc_assert
argument_list|(
name|VECTOR_MODE_P
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes
operator|>
literal|16
condition|)
return|return
literal|0
return|;
name|gcc_assert
argument_list|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE_INNER
argument_list|(
name|mode
argument_list|)
argument_list|)
operator|==
name|MODE_INT
argument_list|)
expr_stmt|;
if|if
condition|(
name|bit_offset
operator|+
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<=
literal|32
condition|)
name|classes
index|[
literal|0
index|]
operator|=
name|X86_64_INTEGERSI_CLASS
expr_stmt|;
else|else
name|classes
index|[
literal|0
index|]
operator|=
name|X86_64_INTEGER_CLASS
expr_stmt|;
name|classes
index|[
literal|1
index|]
operator|=
name|X86_64_INTEGER_CLASS
expr_stmt|;
return|return
literal|1
operator|+
operator|(
name|bytes
operator|>
literal|8
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Examine the argument and return set number of register required in each    class.  Return 0 iff parameter should be passed in memory.  */
end_comment

begin_function
specifier|static
name|int
name|examine_argument
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|type
parameter_list|,
name|int
name|in_return
parameter_list|,
name|int
modifier|*
name|int_nregs
parameter_list|,
name|int
modifier|*
name|sse_nregs
parameter_list|)
block|{
name|enum
name|x86_64_reg_class
name|class
index|[
name|MAX_CLASSES
index|]
decl_stmt|;
name|int
name|n
init|=
name|classify_argument
argument_list|(
name|mode
argument_list|,
name|type
argument_list|,
name|class
argument_list|,
literal|0
argument_list|)
decl_stmt|;
operator|*
name|int_nregs
operator|=
literal|0
expr_stmt|;
operator|*
name|sse_nregs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
return|return
literal|0
return|;
for|for
control|(
name|n
operator|--
init|;
name|n
operator|>=
literal|0
condition|;
name|n
operator|--
control|)
switch|switch
condition|(
name|class
index|[
name|n
index|]
condition|)
block|{
case|case
name|X86_64_INTEGER_CLASS
case|:
case|case
name|X86_64_INTEGERSI_CLASS
case|:
operator|(
operator|*
name|int_nregs
operator|)
operator|++
expr_stmt|;
break|break;
case|case
name|X86_64_SSE_CLASS
case|:
case|case
name|X86_64_SSESF_CLASS
case|:
case|case
name|X86_64_SSEDF_CLASS
case|:
operator|(
operator|*
name|sse_nregs
operator|)
operator|++
expr_stmt|;
break|break;
case|case
name|X86_64_NO_CLASS
case|:
case|case
name|X86_64_SSEUP_CLASS
case|:
break|break;
case|case
name|X86_64_X87_CLASS
case|:
case|case
name|X86_64_X87UP_CLASS
case|:
if|if
condition|(
operator|!
name|in_return
condition|)
return|return
literal|0
return|;
break|break;
case|case
name|X86_64_COMPLEX_X87_CLASS
case|:
return|return
name|in_return
condition|?
literal|2
else|:
literal|0
return|;
case|case
name|X86_64_MEMORY_CLASS
case|:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Construct container for the argument used by GCC interface.  See    FUNCTION_ARG for the detailed description.  */
end_comment

begin_function
specifier|static
name|rtx
name|construct_container
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|enum
name|machine_mode
name|orig_mode
parameter_list|,
name|tree
name|type
parameter_list|,
name|int
name|in_return
parameter_list|,
name|int
name|nintregs
parameter_list|,
name|int
name|nsseregs
parameter_list|,
specifier|const
name|int
modifier|*
name|intreg
parameter_list|,
name|int
name|sse_regno
parameter_list|)
block|{
comment|/* The following variables hold the static issued_error state.  */
specifier|static
name|bool
name|issued_sse_arg_error
decl_stmt|;
specifier|static
name|bool
name|issued_sse_ret_error
decl_stmt|;
specifier|static
name|bool
name|issued_x87_ret_error
decl_stmt|;
name|enum
name|machine_mode
name|tmpmode
decl_stmt|;
name|int
name|bytes
init|=
operator|(
name|mode
operator|==
name|BLKmode
operator|)
condition|?
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
else|:
operator|(
name|int
operator|)
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|enum
name|x86_64_reg_class
name|class
index|[
name|MAX_CLASSES
index|]
decl_stmt|;
name|int
name|n
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|nexps
init|=
literal|0
decl_stmt|;
name|int
name|needed_sseregs
decl_stmt|,
name|needed_intregs
decl_stmt|;
name|rtx
name|exp
index|[
name|MAX_CLASSES
index|]
decl_stmt|;
name|rtx
name|ret
decl_stmt|;
name|n
operator|=
name|classify_argument
argument_list|(
name|mode
argument_list|,
name|type
argument_list|,
name|class
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_DEBUG_ARG
condition|)
block|{
if|if
condition|(
operator|!
name|n
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Memory class\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Classes:"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %s"
argument_list|,
name|x86_64_reg_class_name
index|[
name|class
index|[
name|i
index|]
index|]
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|n
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|examine_argument
argument_list|(
name|mode
argument_list|,
name|type
argument_list|,
name|in_return
argument_list|,
operator|&
name|needed_intregs
argument_list|,
operator|&
name|needed_sseregs
argument_list|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|needed_intregs
operator|>
name|nintregs
operator|||
name|needed_sseregs
operator|>
name|nsseregs
condition|)
return|return
name|NULL
return|;
comment|/* We allowed the user to turn off SSE for kernel mode.  Don't crash if      some less clueful developer tries to use floating-point anyway.  */
if|if
condition|(
name|needed_sseregs
operator|&&
operator|!
name|TARGET_SSE
condition|)
block|{
if|if
condition|(
name|in_return
condition|)
block|{
if|if
condition|(
operator|!
name|issued_sse_ret_error
condition|)
block|{
name|error
argument_list|(
literal|"SSE register return with SSE disabled"
argument_list|)
expr_stmt|;
name|issued_sse_ret_error
operator|=
name|true
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|issued_sse_arg_error
condition|)
block|{
name|error
argument_list|(
literal|"SSE register argument with SSE disabled"
argument_list|)
expr_stmt|;
name|issued_sse_arg_error
operator|=
name|true
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
comment|/* Likewise, error if the ABI requires us to return values in the      x87 registers and the user specified -mno-80387.  */
if|if
condition|(
operator|!
name|TARGET_80387
operator|&&
name|in_return
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|class
index|[
name|i
index|]
operator|==
name|X86_64_X87_CLASS
operator|||
name|class
index|[
name|i
index|]
operator|==
name|X86_64_X87UP_CLASS
operator|||
name|class
index|[
name|i
index|]
operator|==
name|X86_64_COMPLEX_X87_CLASS
condition|)
block|{
if|if
condition|(
operator|!
name|issued_x87_ret_error
condition|)
block|{
name|error
argument_list|(
literal|"x87 register return with x87 disabled"
argument_list|)
expr_stmt|;
name|issued_x87_ret_error
operator|=
name|true
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
comment|/* First construct simple cases.  Avoid SCmode, since we want to use      single register to pass this type.  */
if|if
condition|(
name|n
operator|==
literal|1
operator|&&
name|mode
operator|!=
name|SCmode
condition|)
switch|switch
condition|(
name|class
index|[
literal|0
index|]
condition|)
block|{
case|case
name|X86_64_INTEGER_CLASS
case|:
case|case
name|X86_64_INTEGERSI_CLASS
case|:
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|intreg
index|[
literal|0
index|]
argument_list|)
return|;
case|case
name|X86_64_SSE_CLASS
case|:
case|case
name|X86_64_SSESF_CLASS
case|:
case|case
name|X86_64_SSEDF_CLASS
case|:
return|return
name|gen_reg_or_parallel
argument_list|(
name|mode
argument_list|,
name|orig_mode
argument_list|,
name|SSE_REGNO
argument_list|(
name|sse_regno
argument_list|)
argument_list|)
return|;
case|case
name|X86_64_X87_CLASS
case|:
case|case
name|X86_64_COMPLEX_X87_CLASS
case|:
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|FIRST_STACK_REG
argument_list|)
return|;
case|case
name|X86_64_NO_CLASS
case|:
comment|/* Zero sized array, struct or class.  */
return|return
name|NULL
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|==
literal|2
operator|&&
name|class
index|[
literal|0
index|]
operator|==
name|X86_64_SSE_CLASS
operator|&&
name|class
index|[
literal|1
index|]
operator|==
name|X86_64_SSEUP_CLASS
operator|&&
name|mode
operator|!=
name|BLKmode
condition|)
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|SSE_REGNO
argument_list|(
name|sse_regno
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|n
operator|==
literal|2
operator|&&
name|class
index|[
literal|0
index|]
operator|==
name|X86_64_X87_CLASS
operator|&&
name|class
index|[
literal|1
index|]
operator|==
name|X86_64_X87UP_CLASS
condition|)
return|return
name|gen_rtx_REG
argument_list|(
name|XFmode
argument_list|,
name|FIRST_STACK_REG
argument_list|)
return|;
if|if
condition|(
name|n
operator|==
literal|2
operator|&&
name|class
index|[
literal|0
index|]
operator|==
name|X86_64_INTEGER_CLASS
operator|&&
name|class
index|[
literal|1
index|]
operator|==
name|X86_64_INTEGER_CLASS
operator|&&
operator|(
name|mode
operator|==
name|CDImode
operator|||
name|mode
operator|==
name|TImode
operator|||
name|mode
operator|==
name|TFmode
operator|)
operator|&&
name|intreg
index|[
literal|0
index|]
operator|+
literal|1
operator|==
name|intreg
index|[
literal|1
index|]
condition|)
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|intreg
index|[
literal|0
index|]
argument_list|)
return|;
comment|/* Otherwise figure out the entries of the PARALLEL.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|class
index|[
name|i
index|]
condition|)
block|{
case|case
name|X86_64_NO_CLASS
case|:
break|break;
case|case
name|X86_64_INTEGER_CLASS
case|:
case|case
name|X86_64_INTEGERSI_CLASS
case|:
comment|/* Merge TImodes on aligned occasions here too.  */
if|if
condition|(
name|i
operator|*
literal|8
operator|+
literal|8
operator|>
name|bytes
condition|)
name|tmpmode
operator|=
name|mode_for_size
argument_list|(
operator|(
name|bytes
operator|-
name|i
operator|*
literal|8
operator|)
operator|*
name|BITS_PER_UNIT
argument_list|,
name|MODE_INT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|class
index|[
name|i
index|]
operator|==
name|X86_64_INTEGERSI_CLASS
condition|)
name|tmpmode
operator|=
name|SImode
expr_stmt|;
else|else
name|tmpmode
operator|=
name|DImode
expr_stmt|;
comment|/* We've requested 24 bytes we don't have mode for.  Use DImode.  */
if|if
condition|(
name|tmpmode
operator|==
name|BLKmode
condition|)
name|tmpmode
operator|=
name|DImode
expr_stmt|;
name|exp
index|[
name|nexps
operator|++
index|]
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|tmpmode
argument_list|,
operator|*
name|intreg
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|i
operator|*
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|intreg
operator|++
expr_stmt|;
break|break;
case|case
name|X86_64_SSESF_CLASS
case|:
name|exp
index|[
name|nexps
operator|++
index|]
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|SFmode
argument_list|,
name|SSE_REGNO
argument_list|(
name|sse_regno
argument_list|)
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|i
operator|*
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|sse_regno
operator|++
expr_stmt|;
break|break;
case|case
name|X86_64_SSEDF_CLASS
case|:
name|exp
index|[
name|nexps
operator|++
index|]
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|DFmode
argument_list|,
name|SSE_REGNO
argument_list|(
name|sse_regno
argument_list|)
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|i
operator|*
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|sse_regno
operator|++
expr_stmt|;
break|break;
case|case
name|X86_64_SSE_CLASS
case|:
if|if
condition|(
name|i
operator|<
name|n
operator|-
literal|1
operator|&&
name|class
index|[
name|i
operator|+
literal|1
index|]
operator|==
name|X86_64_SSEUP_CLASS
condition|)
name|tmpmode
operator|=
name|TImode
expr_stmt|;
else|else
name|tmpmode
operator|=
name|DImode
expr_stmt|;
name|exp
index|[
name|nexps
operator|++
index|]
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|tmpmode
argument_list|,
name|SSE_REGNO
argument_list|(
name|sse_regno
argument_list|)
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|i
operator|*
literal|8
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpmode
operator|==
name|TImode
condition|)
name|i
operator|++
expr_stmt|;
name|sse_regno
operator|++
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Empty aligned struct, union or class.  */
if|if
condition|(
name|nexps
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
name|ret
operator|=
name|gen_rtx_PARALLEL
argument_list|(
name|mode
argument_list|,
name|rtvec_alloc
argument_list|(
name|nexps
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nexps
condition|;
name|i
operator|++
control|)
name|XVECEXP
argument_list|(
name|ret
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
operator|=
name|exp
index|[
name|i
index|]
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Update the data in CUM to advance over an argument    of mode MODE and data type TYPE.    (TYPE is null for libcalls where that information may not be available.)  */
end_comment

begin_function
name|void
name|function_arg_advance
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
name|cum
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|type
parameter_list|,
name|int
name|named
parameter_list|)
block|{
name|int
name|bytes
init|=
operator|(
name|mode
operator|==
name|BLKmode
operator|)
condition|?
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
else|:
operator|(
name|int
operator|)
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|int
name|words
init|=
operator|(
name|bytes
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
decl_stmt|;
if|if
condition|(
name|type
condition|)
name|mode
operator|=
name|type_natural_mode
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_DEBUG_ARG
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"function_adv (sz=%d, wds=%2d, nregs=%d, ssenregs=%d, "
literal|"mode=%s, named=%d)\n\n"
argument_list|,
name|words
argument_list|,
name|cum
operator|->
name|words
argument_list|,
name|cum
operator|->
name|nregs
argument_list|,
name|cum
operator|->
name|sse_nregs
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|mode
argument_list|)
argument_list|,
name|named
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
name|int
name|int_nregs
decl_stmt|,
name|sse_nregs
decl_stmt|;
if|if
condition|(
operator|!
name|examine_argument
argument_list|(
name|mode
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
operator|&
name|int_nregs
argument_list|,
operator|&
name|sse_nregs
argument_list|)
condition|)
name|cum
operator|->
name|words
operator|+=
name|words
expr_stmt|;
elseif|else
if|if
condition|(
name|sse_nregs
operator|<=
name|cum
operator|->
name|sse_nregs
operator|&&
name|int_nregs
operator|<=
name|cum
operator|->
name|nregs
condition|)
block|{
name|cum
operator|->
name|nregs
operator|-=
name|int_nregs
expr_stmt|;
name|cum
operator|->
name|sse_nregs
operator|-=
name|sse_nregs
expr_stmt|;
name|cum
operator|->
name|regno
operator|+=
name|int_nregs
expr_stmt|;
name|cum
operator|->
name|sse_regno
operator|+=
name|sse_nregs
expr_stmt|;
block|}
else|else
name|cum
operator|->
name|words
operator|+=
name|words
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|mode
condition|)
block|{
default|default:
break|break;
case|case
name|BLKmode
case|:
if|if
condition|(
name|bytes
operator|<
literal|0
condition|)
break|break;
comment|/* FALLTHRU */
case|case
name|DImode
case|:
case|case
name|SImode
case|:
case|case
name|HImode
case|:
case|case
name|QImode
case|:
name|cum
operator|->
name|words
operator|+=
name|words
expr_stmt|;
name|cum
operator|->
name|nregs
operator|-=
name|words
expr_stmt|;
name|cum
operator|->
name|regno
operator|+=
name|words
expr_stmt|;
if|if
condition|(
name|cum
operator|->
name|nregs
operator|<=
literal|0
condition|)
block|{
name|cum
operator|->
name|nregs
operator|=
literal|0
expr_stmt|;
name|cum
operator|->
name|regno
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|DFmode
case|:
if|if
condition|(
name|cum
operator|->
name|float_in_sse
operator|<
literal|2
condition|)
break|break;
case|case
name|SFmode
case|:
if|if
condition|(
name|cum
operator|->
name|float_in_sse
operator|<
literal|1
condition|)
break|break;
comment|/* FALLTHRU */
case|case
name|TImode
case|:
case|case
name|V16QImode
case|:
case|case
name|V8HImode
case|:
case|case
name|V4SImode
case|:
case|case
name|V2DImode
case|:
case|case
name|V4SFmode
case|:
case|case
name|V2DFmode
case|:
if|if
condition|(
operator|!
name|type
operator|||
operator|!
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|cum
operator|->
name|sse_words
operator|+=
name|words
expr_stmt|;
name|cum
operator|->
name|sse_nregs
operator|-=
literal|1
expr_stmt|;
name|cum
operator|->
name|sse_regno
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|cum
operator|->
name|sse_nregs
operator|<=
literal|0
condition|)
block|{
name|cum
operator|->
name|sse_nregs
operator|=
literal|0
expr_stmt|;
name|cum
operator|->
name|sse_regno
operator|=
literal|0
expr_stmt|;
block|}
block|}
break|break;
case|case
name|V8QImode
case|:
case|case
name|V4HImode
case|:
case|case
name|V2SImode
case|:
case|case
name|V2SFmode
case|:
if|if
condition|(
operator|!
name|type
operator|||
operator|!
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|cum
operator|->
name|mmx_words
operator|+=
name|words
expr_stmt|;
name|cum
operator|->
name|mmx_nregs
operator|-=
literal|1
expr_stmt|;
name|cum
operator|->
name|mmx_regno
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|cum
operator|->
name|mmx_nregs
operator|<=
literal|0
condition|)
block|{
name|cum
operator|->
name|mmx_nregs
operator|=
literal|0
expr_stmt|;
name|cum
operator|->
name|mmx_regno
operator|=
literal|0
expr_stmt|;
block|}
block|}
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Define where to put the arguments to a function.    Value is zero to push the argument on the stack,    or a hard register in which to store the argument.     MODE is the argument's machine mode.    TYPE is the data type of the argument (as a tree).     This is null for libcalls where that information may     not be available.    CUM is a variable of type CUMULATIVE_ARGS which gives info about     the preceding args and about the function being called.    NAMED is nonzero if this argument is a named parameter     (otherwise it is an extra parameter matching an ellipsis).  */
end_comment

begin_function
name|rtx
name|function_arg
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
name|cum
parameter_list|,
name|enum
name|machine_mode
name|orig_mode
parameter_list|,
name|tree
name|type
parameter_list|,
name|int
name|named
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|orig_mode
decl_stmt|;
name|rtx
name|ret
init|=
name|NULL_RTX
decl_stmt|;
name|int
name|bytes
init|=
operator|(
name|mode
operator|==
name|BLKmode
operator|)
condition|?
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
else|:
operator|(
name|int
operator|)
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|int
name|words
init|=
operator|(
name|bytes
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
decl_stmt|;
specifier|static
name|bool
name|warnedsse
decl_stmt|,
name|warnedmmx
decl_stmt|;
comment|/* To simplify the code below, represent vector types with a vector mode      even if MMX/SSE are not active.  */
if|if
condition|(
name|type
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VECTOR_TYPE
condition|)
name|mode
operator|=
name|type_natural_mode
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Handle a hidden AL argument containing number of registers for varargs      x86-64 functions.  For i386 ABI just return constm1_rtx to avoid      any AL settings.  */
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
block|{
if|if
condition|(
name|TARGET_64BIT
condition|)
return|return
name|GEN_INT
argument_list|(
name|cum
operator|->
name|maybe_vaarg
condition|?
operator|(
name|cum
operator|->
name|sse_nregs
operator|<
literal|0
condition|?
name|SSE_REGPARM_MAX
else|:
name|cum
operator|->
name|sse_regno
operator|)
else|:
operator|-
literal|1
argument_list|)
return|;
else|else
return|return
name|constm1_rtx
return|;
block|}
if|if
condition|(
name|TARGET_64BIT
condition|)
name|ret
operator|=
name|construct_container
argument_list|(
name|mode
argument_list|,
name|orig_mode
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
name|cum
operator|->
name|nregs
argument_list|,
name|cum
operator|->
name|sse_nregs
argument_list|,
operator|&
name|x86_64_int_parameter_registers
index|[
name|cum
operator|->
name|regno
index|]
argument_list|,
name|cum
operator|->
name|sse_regno
argument_list|)
expr_stmt|;
else|else
switch|switch
condition|(
name|mode
condition|)
block|{
comment|/* For now, pass fp/complex values on the stack.  */
default|default:
break|break;
case|case
name|BLKmode
case|:
if|if
condition|(
name|bytes
operator|<
literal|0
condition|)
break|break;
comment|/* FALLTHRU */
case|case
name|DImode
case|:
case|case
name|SImode
case|:
case|case
name|HImode
case|:
case|case
name|QImode
case|:
if|if
condition|(
name|words
operator|<=
name|cum
operator|->
name|nregs
condition|)
block|{
name|int
name|regno
init|=
name|cum
operator|->
name|regno
decl_stmt|;
comment|/* Fastcall allocates the first two DWORD (SImode) or 	       smaller arguments to ECX and EDX.  */
if|if
condition|(
name|cum
operator|->
name|fastcall
condition|)
block|{
if|if
condition|(
name|mode
operator|==
name|BLKmode
operator|||
name|mode
operator|==
name|DImode
condition|)
break|break;
comment|/* ECX not EAX is the first allocated register.  */
if|if
condition|(
name|regno
operator|==
literal|0
condition|)
name|regno
operator|=
literal|2
expr_stmt|;
block|}
name|ret
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DFmode
case|:
if|if
condition|(
name|cum
operator|->
name|float_in_sse
operator|<
literal|2
condition|)
break|break;
case|case
name|SFmode
case|:
if|if
condition|(
name|cum
operator|->
name|float_in_sse
operator|<
literal|1
condition|)
break|break;
comment|/* FALLTHRU */
case|case
name|TImode
case|:
case|case
name|V16QImode
case|:
case|case
name|V8HImode
case|:
case|case
name|V4SImode
case|:
case|case
name|V2DImode
case|:
case|case
name|V4SFmode
case|:
case|case
name|V2DFmode
case|:
if|if
condition|(
operator|!
name|type
operator|||
operator|!
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|TARGET_SSE
operator|&&
operator|!
name|warnedsse
operator|&&
name|cum
operator|->
name|warn_sse
condition|)
block|{
name|warnedsse
operator|=
name|true
expr_stmt|;
name|warning
argument_list|(
literal|0
argument_list|,
literal|"SSE vector argument without SSE enabled "
literal|"changes the ABI"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cum
operator|->
name|sse_nregs
condition|)
name|ret
operator|=
name|gen_reg_or_parallel
argument_list|(
name|mode
argument_list|,
name|orig_mode
argument_list|,
name|cum
operator|->
name|sse_regno
operator|+
name|FIRST_SSE_REG
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|V8QImode
case|:
case|case
name|V4HImode
case|:
case|case
name|V2SImode
case|:
case|case
name|V2SFmode
case|:
if|if
condition|(
operator|!
name|type
operator|||
operator|!
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|TARGET_MMX
operator|&&
operator|!
name|warnedmmx
operator|&&
name|cum
operator|->
name|warn_mmx
condition|)
block|{
name|warnedmmx
operator|=
name|true
expr_stmt|;
name|warning
argument_list|(
literal|0
argument_list|,
literal|"MMX vector argument without MMX enabled "
literal|"changes the ABI"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cum
operator|->
name|mmx_nregs
condition|)
name|ret
operator|=
name|gen_reg_or_parallel
argument_list|(
name|mode
argument_list|,
name|orig_mode
argument_list|,
name|cum
operator|->
name|mmx_regno
operator|+
name|FIRST_MMX_REG
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|TARGET_DEBUG_ARG
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"function_arg (size=%d, wds=%2d, nregs=%d, mode=%4s, named=%d, "
argument_list|,
name|words
argument_list|,
name|cum
operator|->
name|words
argument_list|,
name|cum
operator|->
name|nregs
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|mode
argument_list|)
argument_list|,
name|named
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|print_simple_rtl
argument_list|(
name|stderr
argument_list|,
name|ret
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|", stack"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" )\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* A C expression that indicates when an argument must be passed by    reference.  If nonzero for an argument, a copy of that argument is    made in memory and a pointer to the argument is passed instead of    the argument itself.  The pointer is passed in whatever way is    appropriate for passing a pointer to that type.  */
end_comment

begin_function
specifier|static
name|bool
name|ix86_pass_by_reference
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
name|cum
name|ATTRIBUTE_UNUSED
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|,
name|tree
name|type
parameter_list|,
name|bool
name|named
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
operator|!
name|TARGET_64BIT
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|type
operator|&&
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|TARGET_DEBUG_ARG
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"function_arg_pass_by_reference\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return true when TYPE should be 128bit aligned for 32bit argument passing    ABI.  Only called if TARGET_SSE.  */
end_comment

begin_function
specifier|static
name|bool
name|contains_128bit_aligned_vector_p
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|SSE_REG_MODE_P
argument_list|(
name|mode
argument_list|)
operator|&&
operator|(
operator|!
name|TYPE_USER_ALIGN
argument_list|(
name|type
argument_list|)
operator|||
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|>
literal|128
operator|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|<
literal|128
condition|)
return|return
name|false
return|;
if|if
condition|(
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* Walk the aggregates recursively.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|QUAL_UNION_TYPE
case|:
block|{
name|tree
name|field
decl_stmt|;
if|if
condition|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|tree
name|binfo
decl_stmt|,
name|base_binfo
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|binfo
operator|=
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
operator|,
name|i
operator|=
literal|0
init|;
name|BINFO_BASE_ITERATE
argument_list|(
name|binfo
argument_list|,
name|i
argument_list|,
name|base_binfo
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|contains_128bit_aligned_vector_p
argument_list|(
name|BINFO_TYPE
argument_list|(
name|base_binfo
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
block|}
comment|/* And now merge the fields of structure.  */
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
name|contains_128bit_aligned_vector_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
block|}
break|break;
block|}
case|case
name|ARRAY_TYPE
case|:
comment|/* Just for use if some languages passes arrays by value.  */
if|if
condition|(
name|contains_128bit_aligned_vector_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Gives the alignment boundary, in bits, of an argument with the    specified mode and type.  */
end_comment

begin_function
name|int
name|ix86_function_arg_boundary
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|int
name|align
decl_stmt|;
if|if
condition|(
name|type
condition|)
name|align
operator|=
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
expr_stmt|;
else|else
name|align
operator|=
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|align
operator|<
name|PARM_BOUNDARY
condition|)
name|align
operator|=
name|PARM_BOUNDARY
expr_stmt|;
if|if
condition|(
operator|!
name|TARGET_64BIT
condition|)
block|{
comment|/* i386 ABI defines all arguments to be 4 byte aligned.  We have to 	 make an exception for SSE modes since these require 128bit 	 alignment.  	 The handling here differs from field_alignment.  ICC aligns MMX 	 arguments to 4 byte boundaries, while structure fields are aligned 	 to 8 byte boundaries.  */
if|if
condition|(
operator|!
name|TARGET_SSE
condition|)
name|align
operator|=
name|PARM_BOUNDARY
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|type
condition|)
block|{
if|if
condition|(
operator|!
name|SSE_REG_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
name|align
operator|=
name|PARM_BOUNDARY
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|contains_128bit_aligned_vector_p
argument_list|(
name|type
argument_list|)
condition|)
name|align
operator|=
name|PARM_BOUNDARY
expr_stmt|;
block|}
block|}
if|if
condition|(
name|align
operator|>
literal|128
condition|)
name|align
operator|=
literal|128
expr_stmt|;
return|return
name|align
return|;
block|}
end_function

begin_comment
comment|/* Return true if N is a possible register number of function value.  */
end_comment

begin_function
name|bool
name|ix86_function_value_regno_p
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
if|if
condition|(
name|TARGET_MACHO
condition|)
block|{
if|if
condition|(
operator|!
name|TARGET_64BIT
condition|)
block|{
return|return
operator|(
operator|(
name|regno
operator|)
operator|==
literal|0
operator|||
operator|(
operator|(
name|regno
operator|)
operator|==
name|FIRST_FLOAT_REG
operator|&&
name|TARGET_FLOAT_RETURNS_IN_80387
operator|)
operator|||
operator|(
operator|(
name|regno
operator|)
operator|==
name|FIRST_SSE_REG
operator|&&
name|TARGET_SSE
operator|)
operator|)
return|;
block|}
return|return
operator|(
operator|(
name|regno
operator|)
operator|==
literal|0
operator|||
operator|(
name|regno
operator|)
operator|==
name|FIRST_FLOAT_REG
operator|||
operator|(
operator|(
name|regno
operator|)
operator|==
name|FIRST_SSE_REG
operator|&&
name|TARGET_SSE
operator|)
operator|||
operator|(
operator|(
name|regno
operator|)
operator|==
name|FIRST_FLOAT_REG
operator|&&
name|TARGET_FLOAT_RETURNS_IN_80387
operator|)
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|regno
operator|==
literal|0
operator|||
operator|(
name|regno
operator|==
name|FIRST_FLOAT_REG
operator|&&
name|TARGET_FLOAT_RETURNS_IN_80387
operator|)
operator|||
operator|(
name|regno
operator|==
name|FIRST_SSE_REG
operator|&&
name|TARGET_SSE
operator|)
condition|)
return|return
name|true
return|;
if|if
condition|(
operator|!
name|TARGET_64BIT
operator|&&
operator|(
name|regno
operator|==
name|FIRST_MMX_REG
operator|&&
name|TARGET_MMX
operator|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
block|}
end_function

begin_comment
comment|/* Define how to find the value returned by a function.    VALTYPE is the data type of the value (as a tree).    If the precise function being called is known, FUNC is its FUNCTION_DECL;    otherwise, FUNC is 0.  */
end_comment

begin_function
name|rtx
name|ix86_function_value
parameter_list|(
name|tree
name|valtype
parameter_list|,
name|tree
name|fntype_or_decl
parameter_list|,
name|bool
name|outgoing
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|enum
name|machine_mode
name|natmode
init|=
name|type_natural_mode
argument_list|(
name|valtype
argument_list|)
decl_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
name|rtx
name|ret
init|=
name|construct_container
argument_list|(
name|natmode
argument_list|,
name|TYPE_MODE
argument_list|(
name|valtype
argument_list|)
argument_list|,
name|valtype
argument_list|,
literal|1
argument_list|,
name|REGPARM_MAX
argument_list|,
name|SSE_REGPARM_MAX
argument_list|,
name|x86_64_int_return_registers
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* For zero sized structures, construct_container return NULL, but we 	 need to keep rest of compiler happy by returning meaningful value.  */
if|if
condition|(
operator|!
name|ret
condition|)
name|ret
operator|=
name|gen_rtx_REG
argument_list|(
name|TYPE_MODE
argument_list|(
name|valtype
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
else|else
block|{
name|tree
name|fn
init|=
name|NULL_TREE
decl_stmt|,
name|fntype
decl_stmt|;
if|if
condition|(
name|fntype_or_decl
operator|&&
name|DECL_P
argument_list|(
name|fntype_or_decl
argument_list|)
condition|)
name|fn
operator|=
name|fntype_or_decl
expr_stmt|;
name|fntype
operator|=
name|fn
condition|?
name|TREE_TYPE
argument_list|(
name|fn
argument_list|)
else|:
name|fntype_or_decl
expr_stmt|;
return|return
name|gen_rtx_REG
argument_list|(
name|TYPE_MODE
argument_list|(
name|valtype
argument_list|)
argument_list|,
name|ix86_value_regno
argument_list|(
name|natmode
argument_list|,
name|fn
argument_list|,
name|fntype
argument_list|)
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return true iff type is returned in memory.  */
end_comment

begin_function
name|int
name|ix86_return_in_memory
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|int
name|needed_intregs
decl_stmt|,
name|needed_sseregs
decl_stmt|,
name|size
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|type_natural_mode
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
return|return
operator|!
name|examine_argument
argument_list|(
name|mode
argument_list|,
name|type
argument_list|,
literal|1
argument_list|,
operator|&
name|needed_intregs
argument_list|,
operator|&
name|needed_sseregs
argument_list|)
return|;
if|if
condition|(
name|mode
operator|==
name|BLKmode
condition|)
return|return
literal|1
return|;
name|size
operator|=
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|MS_AGGREGATE_RETURN
operator|&&
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|size
operator|<=
literal|8
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|VECTOR_MODE_P
argument_list|(
name|mode
argument_list|)
operator|||
name|mode
operator|==
name|TImode
condition|)
block|{
comment|/* User-created vectors small enough to fit in EAX.  */
if|if
condition|(
name|size
operator|<
literal|8
condition|)
return|return
literal|0
return|;
comment|/* MMX/3dNow values are returned in MM0, 	 except when it doesn't exits.  */
if|if
condition|(
name|size
operator|==
literal|8
condition|)
return|return
operator|(
name|TARGET_MMX
condition|?
literal|0
else|:
literal|1
operator|)
return|;
comment|/* SSE values are returned in XMM0, except when it doesn't exist.  */
if|if
condition|(
name|size
operator|==
literal|16
condition|)
return|return
operator|(
name|TARGET_SSE
condition|?
literal|0
else|:
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|mode
operator|==
name|XFmode
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|mode
operator|==
name|TDmode
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|size
operator|>
literal|12
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* When returning SSE vector types, we have a choice of either      (1) being abi incompatible with a -march switch, or      (2) generating an error.    Given no good solution, I think the safest thing is one warning.    The user won't be able to use -Werror, but....     Choose the STRUCT_VALUE_RTX hook because that's (at present) only    called in response to actually generating a caller or callee that    uses such a type.  As opposed to RETURN_IN_MEMORY, which is called    via aggregate_value_p for general type probing from tree-ssa.  */
end_comment

begin_function
specifier|static
name|rtx
name|ix86_struct_value_rtx
parameter_list|(
name|tree
name|type
parameter_list|,
name|int
name|incoming
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
specifier|static
name|bool
name|warnedsse
decl_stmt|,
name|warnedmmx
decl_stmt|;
if|if
condition|(
name|type
condition|)
block|{
comment|/* Look at the return type of the function, not the function type.  */
name|enum
name|machine_mode
name|mode
init|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|TARGET_SSE
operator|&&
operator|!
name|warnedsse
condition|)
block|{
if|if
condition|(
name|mode
operator|==
name|TImode
operator|||
operator|(
name|VECTOR_MODE_P
argument_list|(
name|mode
argument_list|)
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|==
literal|16
operator|)
condition|)
block|{
name|warnedsse
operator|=
name|true
expr_stmt|;
name|warning
argument_list|(
literal|0
argument_list|,
literal|"SSE vector return without SSE enabled "
literal|"changes the ABI"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|TARGET_MMX
operator|&&
operator|!
name|warnedmmx
condition|)
block|{
if|if
condition|(
name|VECTOR_MODE_P
argument_list|(
name|mode
argument_list|)
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|==
literal|8
condition|)
block|{
name|warnedmmx
operator|=
name|true
expr_stmt|;
name|warning
argument_list|(
literal|0
argument_list|,
literal|"MMX vector return without MMX enabled "
literal|"changes the ABI"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Define how to find the value returned by a library function    assuming the value has mode MODE.  */
end_comment

begin_function
name|rtx
name|ix86_libcall_value
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|SFmode
case|:
case|case
name|SCmode
case|:
case|case
name|DFmode
case|:
case|case
name|DCmode
case|:
case|case
name|TFmode
case|:
case|case
name|SDmode
case|:
case|case
name|DDmode
case|:
case|case
name|TDmode
case|:
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|FIRST_SSE_REG
argument_list|)
return|;
case|case
name|XFmode
case|:
case|case
name|XCmode
case|:
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|FIRST_FLOAT_REG
argument_list|)
return|;
case|case
name|TCmode
case|:
return|return
name|NULL
return|;
default|default:
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
literal|0
argument_list|)
return|;
block|}
block|}
else|else
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|ix86_value_regno
argument_list|(
name|mode
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given a mode, return the register to use for a return value.  */
end_comment

begin_function
specifier|static
name|int
name|ix86_value_regno
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|func
parameter_list|,
name|tree
name|fntype
parameter_list|)
block|{
name|gcc_assert
argument_list|(
operator|!
name|TARGET_64BIT
argument_list|)
expr_stmt|;
comment|/* 8-byte vector modes in %mm0. See ix86_return_in_memory for where      we normally prevent this case when mmx is not available.  However      some ABIs may require the result to be returned like DImode.  */
if|if
condition|(
name|VECTOR_MODE_P
argument_list|(
name|mode
argument_list|)
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|==
literal|8
condition|)
return|return
name|TARGET_MMX
condition|?
name|FIRST_MMX_REG
else|:
literal|0
return|;
comment|/* 16-byte vector modes in %xmm0.  See ix86_return_in_memory for where      we prevent this case when sse is not available.  However some ABIs      may require the result to be returned like integer TImode.  */
if|if
condition|(
name|mode
operator|==
name|TImode
operator|||
operator|(
name|VECTOR_MODE_P
argument_list|(
name|mode
argument_list|)
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|==
literal|16
operator|)
condition|)
return|return
name|TARGET_SSE
condition|?
name|FIRST_SSE_REG
else|:
literal|0
return|;
comment|/* Decimal floating point values can go in %eax, unlike other float modes.  */
if|if
condition|(
name|DECIMAL_FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Most things go in %eax, except (unless -mno-fp-ret-in-387) fp values.  */
if|if
condition|(
operator|!
name|SCALAR_FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
operator|||
operator|!
name|TARGET_FLOAT_RETURNS_IN_80387
condition|)
return|return
literal|0
return|;
comment|/* Floating point return values in %st(0), except for local functions when      SSE math is enabled or for functions with sseregparm attribute.  */
if|if
condition|(
operator|(
name|func
operator|||
name|fntype
operator|)
operator|&&
operator|(
name|mode
operator|==
name|SFmode
operator|||
name|mode
operator|==
name|DFmode
operator|)
condition|)
block|{
name|int
name|sse_level
init|=
name|ix86_function_sseregparm
argument_list|(
name|fntype
argument_list|,
name|func
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|sse_level
operator|>=
literal|1
operator|&&
name|mode
operator|==
name|SFmode
operator|)
operator|||
operator|(
name|sse_level
operator|==
literal|2
operator|&&
name|mode
operator|==
name|DFmode
operator|)
condition|)
return|return
name|FIRST_SSE_REG
return|;
block|}
return|return
name|FIRST_FLOAT_REG
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create the va_list data type.  */
end_comment

begin_function
specifier|static
name|tree
name|ix86_build_builtin_va_list
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|f_gpr
decl_stmt|,
name|f_fpr
decl_stmt|,
name|f_ovf
decl_stmt|,
name|f_sav
decl_stmt|,
name|record
decl_stmt|,
name|type_decl
decl_stmt|;
comment|/* For i386 we use plain pointer to argument area.  */
if|if
condition|(
operator|!
name|TARGET_64BIT
condition|)
return|return
name|build_pointer_type
argument_list|(
name|char_type_node
argument_list|)
return|;
name|record
operator|=
call|(
modifier|*
name|lang_hooks
operator|.
name|types
operator|.
name|make_type
call|)
argument_list|(
name|RECORD_TYPE
argument_list|)
expr_stmt|;
name|type_decl
operator|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__va_list_tag"
argument_list|)
argument_list|,
name|record
argument_list|)
expr_stmt|;
name|f_gpr
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"gp_offset"
argument_list|)
argument_list|,
name|unsigned_type_node
argument_list|)
expr_stmt|;
name|f_fpr
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"fp_offset"
argument_list|)
argument_list|,
name|unsigned_type_node
argument_list|)
expr_stmt|;
name|f_ovf
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"overflow_arg_area"
argument_list|)
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
name|f_sav
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"reg_save_area"
argument_list|)
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
name|va_list_gpr_counter_field
operator|=
name|f_gpr
expr_stmt|;
name|va_list_fpr_counter_field
operator|=
name|f_fpr
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|f_gpr
argument_list|)
operator|=
name|record
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|f_fpr
argument_list|)
operator|=
name|record
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|f_ovf
argument_list|)
operator|=
name|record
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|f_sav
argument_list|)
operator|=
name|record
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|record
argument_list|)
operator|=
name|type_decl
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|record
argument_list|)
operator|=
name|type_decl
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|record
argument_list|)
operator|=
name|f_gpr
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|f_gpr
argument_list|)
operator|=
name|f_fpr
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|f_fpr
argument_list|)
operator|=
name|f_ovf
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|f_ovf
argument_list|)
operator|=
name|f_sav
expr_stmt|;
name|layout_type
argument_list|(
name|record
argument_list|)
expr_stmt|;
comment|/* The correct type is an array type of one element.  */
return|return
name|build_array_type
argument_list|(
name|record
argument_list|,
name|build_index_type
argument_list|(
name|size_zero_node
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Worker function for TARGET_SETUP_INCOMING_VARARGS.  */
end_comment

begin_function
specifier|static
name|void
name|ix86_setup_incoming_varargs
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
name|cum
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|type
parameter_list|,
name|int
modifier|*
name|pretend_size
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|no_rtl
parameter_list|)
block|{
name|CUMULATIVE_ARGS
name|next_cum
decl_stmt|;
name|rtx
name|save_area
init|=
name|NULL_RTX
decl_stmt|,
name|mem
decl_stmt|;
name|rtx
name|label
decl_stmt|;
name|rtx
name|label_ref
decl_stmt|;
name|rtx
name|tmp_reg
decl_stmt|;
name|rtx
name|nsse_reg
decl_stmt|;
name|int
name|set
decl_stmt|;
name|tree
name|fntype
decl_stmt|;
name|int
name|stdarg_p
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|TARGET_64BIT
condition|)
return|return;
if|if
condition|(
operator|!
name|cfun
operator|->
name|va_list_gpr_size
operator|&&
operator|!
name|cfun
operator|->
name|va_list_fpr_size
condition|)
return|return;
comment|/* Indicate to allocate space on the stack for varargs save area.  */
name|ix86_save_varrargs_registers
operator|=
literal|1
expr_stmt|;
name|cfun
operator|->
name|stack_alignment_needed
operator|=
literal|128
expr_stmt|;
name|fntype
operator|=
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
name|stdarg_p
operator|=
operator|(
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|TREE_VALUE
argument_list|(
name|tree_last
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|void_type_node
operator|)
operator|)
expr_stmt|;
comment|/* For varargs, we do not want to skip the dummy va_dcl argument.      For stdargs, we do want to skip the last named argument.  */
name|next_cum
operator|=
operator|*
name|cum
expr_stmt|;
if|if
condition|(
name|stdarg_p
condition|)
name|function_arg_advance
argument_list|(
operator|&
name|next_cum
argument_list|,
name|mode
argument_list|,
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|no_rtl
condition|)
name|save_area
operator|=
name|frame_pointer_rtx
expr_stmt|;
name|set
operator|=
name|get_varargs_alias_set
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
name|next_cum
operator|.
name|regno
init|;
name|i
operator|<
name|ix86_regparm
operator|&&
name|i
operator|<
name|next_cum
operator|.
name|regno
operator|+
name|cfun
operator|->
name|va_list_gpr_size
operator|/
name|UNITS_PER_WORD
condition|;
name|i
operator|++
control|)
block|{
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|plus_constant
argument_list|(
name|save_area
argument_list|,
name|i
operator|*
name|UNITS_PER_WORD
argument_list|)
argument_list|)
expr_stmt|;
name|MEM_NOTRAP_P
argument_list|(
name|mem
argument_list|)
operator|=
literal|1
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|set
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|x86_64_int_parameter_registers
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|next_cum
operator|.
name|sse_nregs
operator|&&
name|cfun
operator|->
name|va_list_fpr_size
condition|)
block|{
comment|/* Now emit code to save SSE registers.  The AX parameter contains number 	 of SSE parameter registers used to call this function.  We use 	 sse_prologue_save insn template that produces computed jump across 	 SSE saves.  We need some preparation work to get this working.  */
name|label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|label_ref
operator|=
name|gen_rtx_LABEL_REF
argument_list|(
name|Pmode
argument_list|,
name|label
argument_list|)
expr_stmt|;
comment|/* Compute address to jump to :          label - 5*eax + nnamed_sse_arguments*5  */
name|tmp_reg
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|nsse_reg
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_zero_extendqidi2
argument_list|(
name|nsse_reg
argument_list|,
name|gen_rtx_REG
argument_list|(
name|QImode
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|tmp_reg
argument_list|,
name|gen_rtx_MULT
argument_list|(
name|Pmode
argument_list|,
name|nsse_reg
argument_list|,
name|GEN_INT
argument_list|(
literal|4
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_cum
operator|.
name|sse_regno
condition|)
name|emit_move_insn
argument_list|(
name|nsse_reg
argument_list|,
name|gen_rtx_CONST
argument_list|(
name|DImode
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|DImode
argument_list|,
name|label_ref
argument_list|,
name|GEN_INT
argument_list|(
name|next_cum
operator|.
name|sse_regno
operator|*
literal|4
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_move_insn
argument_list|(
name|nsse_reg
argument_list|,
name|label_ref
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_subdi3
argument_list|(
name|nsse_reg
argument_list|,
name|nsse_reg
argument_list|,
name|tmp_reg
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Compute address of memory block we save into.  We always use pointer 	 pointing 127 bytes after first byte to store - this is needed to keep 	 instruction size limited by 4 bytes.  */
name|tmp_reg
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|tmp_reg
argument_list|,
name|plus_constant
argument_list|(
name|save_area
argument_list|,
literal|8
operator|*
name|REGPARM_MAX
operator|+
literal|127
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|plus_constant
argument_list|(
name|tmp_reg
argument_list|,
operator|-
literal|127
argument_list|)
argument_list|)
expr_stmt|;
name|MEM_NOTRAP_P
argument_list|(
name|mem
argument_list|)
operator|=
literal|1
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|set
argument_list|)
expr_stmt|;
name|set_mem_align
argument_list|(
name|mem
argument_list|,
name|BITS_PER_WORD
argument_list|)
expr_stmt|;
comment|/* And finally do the dirty job!  */
name|emit_insn
argument_list|(
name|gen_sse_prologue_save
argument_list|(
name|mem
argument_list|,
name|nsse_reg
argument_list|,
name|GEN_INT
argument_list|(
name|next_cum
operator|.
name|sse_regno
argument_list|)
argument_list|,
name|label
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Implement va_start.  */
end_comment

begin_function
name|void
name|ix86_va_start
parameter_list|(
name|tree
name|valist
parameter_list|,
name|rtx
name|nextarg
parameter_list|)
block|{
name|HOST_WIDE_INT
name|words
decl_stmt|,
name|n_gpr
decl_stmt|,
name|n_fpr
decl_stmt|;
name|tree
name|f_gpr
decl_stmt|,
name|f_fpr
decl_stmt|,
name|f_ovf
decl_stmt|,
name|f_sav
decl_stmt|;
name|tree
name|gpr
decl_stmt|,
name|fpr
decl_stmt|,
name|ovf
decl_stmt|,
name|sav
decl_stmt|,
name|t
decl_stmt|;
name|tree
name|type
decl_stmt|;
comment|/* Only 64bit target needs something special.  */
if|if
condition|(
operator|!
name|TARGET_64BIT
condition|)
block|{
name|std_expand_builtin_va_start
argument_list|(
name|valist
argument_list|,
name|nextarg
argument_list|)
expr_stmt|;
return|return;
block|}
name|f_gpr
operator|=
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|va_list_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|f_fpr
operator|=
name|TREE_CHAIN
argument_list|(
name|f_gpr
argument_list|)
expr_stmt|;
name|f_ovf
operator|=
name|TREE_CHAIN
argument_list|(
name|f_fpr
argument_list|)
expr_stmt|;
name|f_sav
operator|=
name|TREE_CHAIN
argument_list|(
name|f_ovf
argument_list|)
expr_stmt|;
name|valist
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|valist
argument_list|)
argument_list|)
argument_list|,
name|valist
argument_list|)
expr_stmt|;
name|gpr
operator|=
name|build3
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_gpr
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_gpr
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|fpr
operator|=
name|build3
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_fpr
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_fpr
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|ovf
operator|=
name|build3
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_ovf
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_ovf
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|sav
operator|=
name|build3
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_sav
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_sav
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* Count number of gp and fp argument registers used.  */
name|words
operator|=
name|current_function_args_info
operator|.
name|words
expr_stmt|;
name|n_gpr
operator|=
name|current_function_args_info
operator|.
name|regno
expr_stmt|;
name|n_fpr
operator|=
name|current_function_args_info
operator|.
name|sse_regno
expr_stmt|;
if|if
condition|(
name|TARGET_DEBUG_ARG
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"va_start: words = %d, n_gpr = %d, n_fpr = %d\n"
argument_list|,
operator|(
name|int
operator|)
name|words
argument_list|,
operator|(
name|int
operator|)
name|n_gpr
argument_list|,
operator|(
name|int
operator|)
name|n_fpr
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfun
operator|->
name|va_list_gpr_size
condition|)
block|{
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|gpr
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|type
argument_list|,
name|gpr
argument_list|,
name|build_int_cst
argument_list|(
name|type
argument_list|,
name|n_gpr
operator|*
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cfun
operator|->
name|va_list_fpr_size
condition|)
block|{
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|fpr
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|type
argument_list|,
name|fpr
argument_list|,
name|build_int_cst
argument_list|(
name|type
argument_list|,
name|n_fpr
operator|*
literal|16
operator|+
literal|8
operator|*
name|REGPARM_MAX
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
block|}
comment|/* Find the overflow area.  */
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|ovf
argument_list|)
expr_stmt|;
name|t
operator|=
name|make_tree
argument_list|(
name|type
argument_list|,
name|virtual_incoming_args_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|words
operator|!=
literal|0
condition|)
name|t
operator|=
name|build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|t
argument_list|,
name|build_int_cst
argument_list|(
name|type
argument_list|,
name|words
operator|*
name|UNITS_PER_WORD
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|type
argument_list|,
name|ovf
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfun
operator|->
name|va_list_gpr_size
operator|||
name|cfun
operator|->
name|va_list_fpr_size
condition|)
block|{
comment|/* Find the register save area. 	 Prologue of the function save it right above stack frame.  */
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|sav
argument_list|)
expr_stmt|;
name|t
operator|=
name|make_tree
argument_list|(
name|type
argument_list|,
name|frame_pointer_rtx
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|type
argument_list|,
name|sav
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Implement va_arg.  */
end_comment

begin_function
name|tree
name|ix86_gimplify_va_arg
parameter_list|(
name|tree
name|valist
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
modifier|*
name|pre_p
parameter_list|,
name|tree
modifier|*
name|post_p
parameter_list|)
block|{
specifier|static
specifier|const
name|int
name|intreg
index|[
literal|6
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|}
decl_stmt|;
name|tree
name|f_gpr
decl_stmt|,
name|f_fpr
decl_stmt|,
name|f_ovf
decl_stmt|,
name|f_sav
decl_stmt|;
name|tree
name|gpr
decl_stmt|,
name|fpr
decl_stmt|,
name|ovf
decl_stmt|,
name|sav
decl_stmt|,
name|t
decl_stmt|;
name|int
name|size
decl_stmt|,
name|rsize
decl_stmt|;
name|tree
name|lab_false
decl_stmt|,
name|lab_over
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|addr
decl_stmt|,
name|t2
decl_stmt|;
name|rtx
name|container
decl_stmt|;
name|int
name|indirect_p
init|=
literal|0
decl_stmt|;
name|tree
name|ptrtype
decl_stmt|;
name|enum
name|machine_mode
name|nat_mode
decl_stmt|;
comment|/* Only 64bit target needs something special.  */
if|if
condition|(
operator|!
name|TARGET_64BIT
condition|)
return|return
name|std_gimplify_va_arg_expr
argument_list|(
name|valist
argument_list|,
name|type
argument_list|,
name|pre_p
argument_list|,
name|post_p
argument_list|)
return|;
name|f_gpr
operator|=
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|va_list_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|f_fpr
operator|=
name|TREE_CHAIN
argument_list|(
name|f_gpr
argument_list|)
expr_stmt|;
name|f_ovf
operator|=
name|TREE_CHAIN
argument_list|(
name|f_fpr
argument_list|)
expr_stmt|;
name|f_sav
operator|=
name|TREE_CHAIN
argument_list|(
name|f_ovf
argument_list|)
expr_stmt|;
name|valist
operator|=
name|build_va_arg_indirect_ref
argument_list|(
name|valist
argument_list|)
expr_stmt|;
name|gpr
operator|=
name|build3
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_gpr
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_gpr
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|fpr
operator|=
name|build3
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_fpr
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_fpr
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|ovf
operator|=
name|build3
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_ovf
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_ovf
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|sav
operator|=
name|build3
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_sav
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_sav
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|indirect_p
operator|=
name|pass_by_reference
argument_list|(
name|NULL
argument_list|,
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|type
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|indirect_p
condition|)
name|type
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|size
operator|=
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|rsize
operator|=
operator|(
name|size
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
expr_stmt|;
name|nat_mode
operator|=
name|type_natural_mode
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|container
operator|=
name|construct_container
argument_list|(
name|nat_mode
argument_list|,
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
name|REGPARM_MAX
argument_list|,
name|SSE_REGPARM_MAX
argument_list|,
name|intreg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Pull the value out of the saved registers.  */
name|addr
operator|=
name|create_tmp_var
argument_list|(
name|ptr_type_node
argument_list|,
literal|"addr"
argument_list|)
expr_stmt|;
name|DECL_POINTER_ALIAS_SET
argument_list|(
name|addr
argument_list|)
operator|=
name|get_varargs_alias_set
argument_list|()
expr_stmt|;
if|if
condition|(
name|container
condition|)
block|{
name|int
name|needed_intregs
decl_stmt|,
name|needed_sseregs
decl_stmt|;
name|bool
name|need_temp
decl_stmt|;
name|tree
name|int_addr
decl_stmt|,
name|sse_addr
decl_stmt|;
name|lab_false
operator|=
name|create_artificial_label
argument_list|()
expr_stmt|;
name|lab_over
operator|=
name|create_artificial_label
argument_list|()
expr_stmt|;
name|examine_argument
argument_list|(
name|nat_mode
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
operator|&
name|needed_intregs
argument_list|,
operator|&
name|needed_sseregs
argument_list|)
expr_stmt|;
name|need_temp
operator|=
operator|(
operator|!
name|REG_P
argument_list|(
name|container
argument_list|)
operator|&&
operator|(
operator|(
name|needed_intregs
operator|&&
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|>
literal|64
operator|)
operator|||
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|>
literal|128
operator|)
operator|)
expr_stmt|;
comment|/* In case we are passing structure, verify that it is consecutive block          on the register save area.  If not we need to do moves.  */
if|if
condition|(
operator|!
name|need_temp
operator|&&
operator|!
name|REG_P
argument_list|(
name|container
argument_list|)
condition|)
block|{
comment|/* Verify that all registers are strictly consecutive  */
if|if
condition|(
name|SSE_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|container
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|container
argument_list|,
literal|0
argument_list|)
operator|&&
operator|!
name|need_temp
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|slot
init|=
name|XVECEXP
argument_list|(
name|container
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|slot
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|FIRST_SSE_REG
operator|+
operator|(
name|unsigned
name|int
operator|)
name|i
operator|||
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|slot
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|i
operator|*
literal|16
condition|)
name|need_temp
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|container
argument_list|,
literal|0
argument_list|)
operator|&&
operator|!
name|need_temp
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|slot
init|=
name|XVECEXP
argument_list|(
name|container
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|slot
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
operator|(
name|unsigned
name|int
operator|)
name|i
operator|||
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|slot
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|i
operator|*
literal|8
condition|)
name|need_temp
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|need_temp
condition|)
block|{
name|int_addr
operator|=
name|addr
expr_stmt|;
name|sse_addr
operator|=
name|addr
expr_stmt|;
block|}
else|else
block|{
name|int_addr
operator|=
name|create_tmp_var
argument_list|(
name|ptr_type_node
argument_list|,
literal|"int_addr"
argument_list|)
expr_stmt|;
name|DECL_POINTER_ALIAS_SET
argument_list|(
name|int_addr
argument_list|)
operator|=
name|get_varargs_alias_set
argument_list|()
expr_stmt|;
name|sse_addr
operator|=
name|create_tmp_var
argument_list|(
name|ptr_type_node
argument_list|,
literal|"sse_addr"
argument_list|)
expr_stmt|;
name|DECL_POINTER_ALIAS_SET
argument_list|(
name|sse_addr
argument_list|)
operator|=
name|get_varargs_alias_set
argument_list|()
expr_stmt|;
block|}
comment|/* First ensure that we fit completely in registers.  */
if|if
condition|(
name|needed_intregs
condition|)
block|{
name|t
operator|=
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|gpr
argument_list|)
argument_list|,
operator|(
name|REGPARM_MAX
operator|-
name|needed_intregs
operator|+
literal|1
operator|)
operator|*
literal|8
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|GE_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|gpr
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|t2
operator|=
name|build1
argument_list|(
name|GOTO_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|lab_false
argument_list|)
expr_stmt|;
name|t
operator|=
name|build3
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|t
argument_list|,
name|t2
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|t
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|needed_sseregs
condition|)
block|{
name|t
operator|=
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|fpr
argument_list|)
argument_list|,
operator|(
name|SSE_REGPARM_MAX
operator|-
name|needed_sseregs
operator|+
literal|1
operator|)
operator|*
literal|16
operator|+
name|REGPARM_MAX
operator|*
literal|8
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|GE_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|fpr
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|t2
operator|=
name|build1
argument_list|(
name|GOTO_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|lab_false
argument_list|)
expr_stmt|;
name|t
operator|=
name|build3
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|t
argument_list|,
name|t2
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|t
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
block|}
comment|/* Compute index to start of area used for integer regs.  */
if|if
condition|(
name|needed_intregs
condition|)
block|{
comment|/* int_addr = gpr + sav; */
name|t
operator|=
name|fold_convert
argument_list|(
name|ptr_type_node
argument_list|,
name|gpr
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|ptr_type_node
argument_list|,
name|sav
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|int_addr
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|t
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|needed_sseregs
condition|)
block|{
comment|/* sse_addr = fpr + sav; */
name|t
operator|=
name|fold_convert
argument_list|(
name|ptr_type_node
argument_list|,
name|fpr
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|ptr_type_node
argument_list|,
name|sav
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|sse_addr
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|t
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|need_temp
condition|)
block|{
name|int
name|i
decl_stmt|;
name|tree
name|temp
init|=
name|create_tmp_var
argument_list|(
name|type
argument_list|,
literal|"va_arg_tmp"
argument_list|)
decl_stmt|;
comment|/* addr =&temp; */
name|t
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|build_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|addr
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|t
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|container
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|slot
init|=
name|XVECEXP
argument_list|(
name|container
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|rtx
name|reg
init|=
name|XEXP
argument_list|(
name|slot
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|reg
argument_list|)
decl_stmt|;
name|tree
name|piece_type
init|=
name|lang_hooks
operator|.
name|types
operator|.
name|type_for_mode
argument_list|(
name|mode
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|addr_type
init|=
name|build_pointer_type
argument_list|(
name|piece_type
argument_list|)
decl_stmt|;
name|tree
name|src_addr
decl_stmt|,
name|src
decl_stmt|;
name|int
name|src_offset
decl_stmt|;
name|tree
name|dest_addr
decl_stmt|,
name|dest
decl_stmt|;
if|if
condition|(
name|SSE_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
condition|)
block|{
name|src_addr
operator|=
name|sse_addr
expr_stmt|;
name|src_offset
operator|=
operator|(
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|-
name|FIRST_SSE_REG
operator|)
operator|*
literal|16
expr_stmt|;
block|}
else|else
block|{
name|src_addr
operator|=
name|int_addr
expr_stmt|;
name|src_offset
operator|=
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|*
literal|8
expr_stmt|;
block|}
name|src_addr
operator|=
name|fold_convert
argument_list|(
name|addr_type
argument_list|,
name|src_addr
argument_list|)
expr_stmt|;
name|src_addr
operator|=
name|fold
argument_list|(
name|build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|addr_type
argument_list|,
name|src_addr
argument_list|,
name|size_int
argument_list|(
name|src_offset
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|src
operator|=
name|build_va_arg_indirect_ref
argument_list|(
name|src_addr
argument_list|)
expr_stmt|;
name|dest_addr
operator|=
name|fold_convert
argument_list|(
name|addr_type
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|dest_addr
operator|=
name|fold
argument_list|(
name|build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|addr_type
argument_list|,
name|dest_addr
argument_list|,
name|size_int
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|slot
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|dest
operator|=
name|build_va_arg_indirect_ref
argument_list|(
name|dest_addr
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|dest
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|t
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|needed_intregs
condition|)
block|{
name|t
operator|=
name|build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|gpr
argument_list|)
argument_list|,
name|gpr
argument_list|,
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|gpr
argument_list|)
argument_list|,
name|needed_intregs
operator|*
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|gpr
argument_list|)
argument_list|,
name|gpr
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|t
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|needed_sseregs
condition|)
block|{
name|t
operator|=
name|build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|fpr
argument_list|)
argument_list|,
name|fpr
argument_list|,
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|fpr
argument_list|)
argument_list|,
name|needed_sseregs
operator|*
literal|16
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|fpr
argument_list|)
argument_list|,
name|fpr
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|t
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|build1
argument_list|(
name|GOTO_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|lab_over
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|t
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
name|t
operator|=
name|build1
argument_list|(
name|LABEL_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|lab_false
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|t
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
block|}
comment|/* ... otherwise out of the overflow area.  */
comment|/* Care for on-stack alignment if needed.  */
if|if
condition|(
name|FUNCTION_ARG_BOUNDARY
argument_list|(
name|VOIDmode
argument_list|,
name|type
argument_list|)
operator|<=
literal|64
operator|||
name|integer_zerop
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
name|t
operator|=
name|ovf
expr_stmt|;
else|else
block|{
name|HOST_WIDE_INT
name|align
init|=
name|FUNCTION_ARG_BOUNDARY
argument_list|(
name|VOIDmode
argument_list|,
name|type
argument_list|)
operator|/
literal|8
decl_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|ovf
argument_list|)
argument_list|,
name|ovf
argument_list|,
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|ovf
argument_list|)
argument_list|,
name|align
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|t
argument_list|,
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
operator|-
name|align
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|gimplify_expr
argument_list|(
operator|&
name|t
argument_list|,
name|pre_p
argument_list|,
name|NULL
argument_list|,
name|is_gimple_val
argument_list|,
name|fb_rvalue
argument_list|)
expr_stmt|;
name|t2
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|addr
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|t2
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|t
argument_list|,
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|rsize
operator|*
name|UNITS_PER_WORD
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|ovf
argument_list|)
argument_list|,
name|ovf
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|t
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|container
condition|)
block|{
name|t
operator|=
name|build1
argument_list|(
name|LABEL_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|lab_over
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|t
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
block|}
name|ptrtype
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|addr
operator|=
name|fold_convert
argument_list|(
name|ptrtype
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|indirect_p
condition|)
name|addr
operator|=
name|build_va_arg_indirect_ref
argument_list|(
name|addr
argument_list|)
expr_stmt|;
return|return
name|build_va_arg_indirect_ref
argument_list|(
name|addr
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if OPNUM's MEM should be matched    in movabs* patterns.  */
end_comment

begin_function
name|int
name|ix86_check_movabs
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|int
name|opnum
parameter_list|)
block|{
name|rtx
name|set
decl_stmt|,
name|mem
decl_stmt|;
name|set
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|set
argument_list|)
operator|==
name|PARALLEL
condition|)
name|set
operator|=
name|XVECEXP
argument_list|(
name|set
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|set
argument_list|)
operator|==
name|SET
argument_list|)
expr_stmt|;
name|mem
operator|=
name|XEXP
argument_list|(
name|set
argument_list|,
name|opnum
argument_list|)
expr_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|mem
argument_list|)
operator|==
name|SUBREG
condition|)
name|mem
operator|=
name|SUBREG_REG
argument_list|(
name|mem
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|mem
argument_list|)
operator|==
name|MEM
argument_list|)
expr_stmt|;
return|return
operator|(
name|volatile_ok
operator|||
operator|!
name|MEM_VOLATILE_P
argument_list|(
name|mem
argument_list|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Initialize the table of extra 80387 mathematical constants.  */
end_comment

begin_function
specifier|static
name|void
name|init_ext_80387_constants
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|cst
index|[
literal|5
index|]
init|=
block|{
literal|"0.3010299956639811952256464283594894482"
block|,
comment|/* 0: fldlg2  */
literal|"0.6931471805599453094286904741849753009"
block|,
comment|/* 1: fldln2  */
literal|"1.4426950408889634073876517827983434472"
block|,
comment|/* 2: fldl2e  */
literal|"3.3219280948873623478083405569094566090"
block|,
comment|/* 3: fldl2t  */
literal|"3.1415926535897932385128089594061862044"
block|,
comment|/* 4: fldpi   */
block|}
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
name|real_from_string
argument_list|(
operator|&
name|ext_80387_constants_table
index|[
name|i
index|]
argument_list|,
name|cst
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Ensure each constant is rounded to XFmode precision.  */
name|real_convert
argument_list|(
operator|&
name|ext_80387_constants_table
index|[
name|i
index|]
argument_list|,
name|XFmode
argument_list|,
operator|&
name|ext_80387_constants_table
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|ext_80387_constants_init
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return true if the constant is something that can be loaded with    a special instruction.  */
end_comment

begin_function
name|int
name|standard_80387_constant_p
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_DOUBLE
operator|||
operator|!
name|FLOAT_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|x
operator|==
name|CONST0_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|x
operator|==
name|CONST1_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
return|return
literal|2
return|;
comment|/* For XFmode constants, try to find a special 80387 instruction when      optimizing for size or on those CPUs that benefit from them.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|XFmode
operator|&&
operator|(
name|optimize_size
operator|||
name|x86_ext_80387_constants
operator|&
name|TUNEMASK
operator|)
condition|)
block|{
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|ext_80387_constants_init
condition|)
name|init_ext_80387_constants
argument_list|()
expr_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|r
argument_list|,
name|x
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|real_identical
argument_list|(
operator|&
name|r
argument_list|,
operator|&
name|ext_80387_constants_table
index|[
name|i
index|]
argument_list|)
condition|)
return|return
name|i
operator|+
literal|3
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the opcode of the special instruction to be used to load    the constant X.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|standard_80387_constant_opcode
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
switch|switch
condition|(
name|standard_80387_constant_p
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
return|return
literal|"fldz"
return|;
case|case
literal|2
case|:
return|return
literal|"fld1"
return|;
case|case
literal|3
case|:
return|return
literal|"fldlg2"
return|;
case|case
literal|4
case|:
return|return
literal|"fldln2"
return|;
case|case
literal|5
case|:
return|return
literal|"fldl2e"
return|;
case|case
literal|6
case|:
return|return
literal|"fldl2t"
return|;
case|case
literal|7
case|:
return|return
literal|"fldpi"
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return the CONST_DOUBLE representing the 80387 constant that is    loaded by the specified special instruction.  The argument IDX    matches the return value from standard_80387_constant_p.  */
end_comment

begin_function
name|rtx
name|standard_80387_constant_rtx
parameter_list|(
name|int
name|idx
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|ext_80387_constants_init
condition|)
name|init_ext_80387_constants
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|idx
condition|)
block|{
case|case
literal|3
case|:
case|case
literal|4
case|:
case|case
literal|5
case|:
case|case
literal|6
case|:
case|case
literal|7
case|:
name|i
operator|=
name|idx
operator|-
literal|3
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
return|return
name|CONST_DOUBLE_FROM_REAL_VALUE
argument_list|(
name|ext_80387_constants_table
index|[
name|i
index|]
argument_list|,
name|XFmode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if mode is a valid mode for sse.  */
end_comment

begin_function
specifier|static
name|int
name|standard_sse_mode_p
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|V16QImode
case|:
case|case
name|V8HImode
case|:
case|case
name|V4SImode
case|:
case|case
name|V2DImode
case|:
case|case
name|V4SFmode
case|:
case|case
name|V2DFmode
case|:
return|return
literal|1
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return 1 if X is FP constant we can load to SSE register w/o using memory.  */
end_comment

begin_function
name|int
name|standard_sse_constant_p
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|x
operator|==
name|const0_rtx
operator|||
name|x
operator|==
name|CONST0_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|vector_all_ones_operand
argument_list|(
name|x
argument_list|,
name|mode
argument_list|)
operator|&&
name|standard_sse_mode_p
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|TARGET_SSE2
condition|?
literal|2
else|:
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the opcode of the special instruction to be used to load    the constant X.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|standard_sse_constant_opcode
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|x
parameter_list|)
block|{
switch|switch
condition|(
name|standard_sse_constant_p
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
if|if
condition|(
name|get_attr_mode
argument_list|(
name|insn
argument_list|)
operator|==
name|MODE_V4SF
condition|)
return|return
literal|"xorps\t%0, %0"
return|;
elseif|else
if|if
condition|(
name|get_attr_mode
argument_list|(
name|insn
argument_list|)
operator|==
name|MODE_V2DF
condition|)
return|return
literal|"xorpd\t%0, %0"
return|;
else|else
return|return
literal|"pxor\t%0, %0"
return|;
case|case
literal|2
case|:
return|return
literal|"pcmpeqd\t%0, %0"
return|;
block|}
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns 1 if OP contains a symbol reference */
end_comment

begin_function
name|int
name|symbolic_reference_mentioned_p
parameter_list|(
name|rtx
name|op
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|LABEL_REF
condition|)
return|return
literal|1
return|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|op
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|symbolic_reference_mentioned_p
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|&&
name|symbolic_reference_mentioned_p
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if it is appropriate to emit `ret' instructions in the    body of a function.  Do this only if the epilogue is simple, needing a    couple of insns.  Prior to reloading, we can't tell how many registers    must be saved, so return 0 then.  Return 0 if there is no frame    marker to de-allocate.  */
end_comment

begin_function
name|int
name|ix86_can_use_return_insn_p
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|ix86_frame
name|frame
decl_stmt|;
if|if
condition|(
operator|!
name|reload_completed
operator|||
name|frame_pointer_needed
condition|)
return|return
literal|0
return|;
comment|/* Don't allow more than 32 pop, since that's all we can do      with one instruction.  */
if|if
condition|(
name|current_function_pops_args
operator|&&
name|current_function_args_size
operator|>=
literal|32768
condition|)
return|return
literal|0
return|;
name|ix86_compute_frame_layout
argument_list|(
operator|&
name|frame
argument_list|)
expr_stmt|;
return|return
name|frame
operator|.
name|to_allocate
operator|==
literal|0
operator|&&
name|frame
operator|.
name|nregs
operator|==
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Value should be nonzero if functions must have frame pointers.    Zero means the frame pointer need not be set up (and parms may    be accessed via the stack pointer) in functions that seem suitable.  */
end_comment

begin_function
name|int
name|ix86_frame_pointer_required
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* If we accessed previous frames, then the generated code expects      to be able to access the saved ebp value in our frame.  */
if|if
condition|(
name|cfun
operator|->
name|machine
operator|->
name|accesses_prev_frame
condition|)
return|return
literal|1
return|;
comment|/* Several x86 os'es need a frame pointer for other reasons,      usually pertaining to setjmp.  */
if|if
condition|(
name|SUBTARGET_FRAME_POINTER_REQUIRED
condition|)
return|return
literal|1
return|;
comment|/* In override_options, TARGET_OMIT_LEAF_FRAME_POINTER turns off      the frame pointer by default.  Turn it back on now if we've not      got a leaf function.  */
if|if
condition|(
name|TARGET_OMIT_LEAF_FRAME_POINTER
operator|&&
operator|(
operator|!
name|current_function_is_leaf
operator|||
name|ix86_current_function_calls_tls_descriptor
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|current_function_profile
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Record that the current function accesses previous call frames.  */
end_comment

begin_function
name|void
name|ix86_setup_frame_addresses
parameter_list|(
name|void
parameter_list|)
block|{
name|cfun
operator|->
name|machine
operator|->
name|accesses_prev_frame
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|HAVE_GAS_HIDDEN
argument_list|)
operator|&&
operator|(
name|SUPPORTS_ONE_ONLY
operator|-
literal|0
operator|)
operator|)
operator|||
name|TARGET_MACHO
end_if

begin_define
define|#
directive|define
name|USE_HIDDEN_LINKONCE
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|USE_HIDDEN_LINKONCE
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|pic_labels_used
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Fills in the label name that should be used for a pc thunk for    the given register.  */
end_comment

begin_function
specifier|static
name|void
name|get_pc_thunk_name
parameter_list|(
name|char
name|name
index|[
literal|32
index|]
parameter_list|,
name|unsigned
name|int
name|regno
parameter_list|)
block|{
name|gcc_assert
argument_list|(
operator|!
name|TARGET_64BIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|USE_HIDDEN_LINKONCE
condition|)
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"__i686.get_pc_thunk.%s"
argument_list|,
name|reg_names
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
else|else
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|name
argument_list|,
literal|"LPR"
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function generates code for -fpic that loads %ebx with    the return address of the caller and then returns.  */
end_comment

begin_function
name|void
name|ix86_file_end
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|xops
index|[
literal|2
index|]
decl_stmt|;
name|int
name|regno
decl_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
literal|8
condition|;
operator|++
name|regno
control|)
block|{
name|char
name|name
index|[
literal|32
index|]
decl_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|pic_labels_used
operator|>>
name|regno
operator|)
operator|&
literal|1
operator|)
condition|)
continue|continue;
name|get_pc_thunk_name
argument_list|(
name|name
argument_list|,
name|regno
argument_list|)
expr_stmt|;
if|#
directive|if
name|TARGET_MACHO
if|if
condition|(
name|TARGET_MACHO
condition|)
block|{
name|switch_to_section
argument_list|(
name|darwin_sections
index|[
name|text_coal_section
index|]
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\t.weak_definition\t"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\n\t.private_extern\t"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
name|USE_HIDDEN_LINKONCE
condition|)
block|{
name|tree
name|decl
decl_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|get_identifier
argument_list|(
name|name
argument_list|)
argument_list|,
name|error_mark_node
argument_list|)
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ONE_ONLY
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
call|(
modifier|*
name|targetm
operator|.
name|asm_out
operator|.
name|unique_section
call|)
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|switch_to_section
argument_list|(
name|get_named_section
argument_list|(
name|decl
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|targetm
operator|.
name|asm_out
operator|.
name|globalize_label
call|)
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\t.hidden\t"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_DECLARE_FUNCTION_NAME
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|switch_to_section
argument_list|(
name|text_section
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|xops
index|[
literal|0
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|xops
index|[
literal|1
index|]
operator|=
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|stack_pointer_rtx
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"mov{l}\t{%1, %0|%0, %1}"
argument_list|,
name|xops
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ret"
argument_list|,
name|xops
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|NEED_INDICATE_EXEC_STACK
condition|)
name|file_end_indicate_exec_stack
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit code for the SET_GOT patterns.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|output_set_got
parameter_list|(
name|rtx
name|dest
parameter_list|,
name|rtx
name|label
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|rtx
name|xops
index|[
literal|3
index|]
decl_stmt|;
name|xops
index|[
literal|0
index|]
operator|=
name|dest
expr_stmt|;
name|xops
index|[
literal|1
index|]
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|GOT_SYMBOL_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TARGET_DEEP_BRANCH_PREDICTION
operator|||
operator|!
name|flag_pic
condition|)
block|{
name|xops
index|[
literal|2
index|]
operator|=
name|gen_rtx_LABEL_REF
argument_list|(
name|Pmode
argument_list|,
name|label
condition|?
name|label
else|:
name|gen_label_rtx
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flag_pic
condition|)
name|output_asm_insn
argument_list|(
literal|"mov{l}\t{%2, %0|%0, %2}"
argument_list|,
name|xops
argument_list|)
expr_stmt|;
else|else
name|output_asm_insn
argument_list|(
literal|"call\t%a2"
argument_list|,
name|xops
argument_list|)
expr_stmt|;
if|#
directive|if
name|TARGET_MACHO
comment|/* Output the Mach-O "canonical" label name ("Lxx$pb") here too.  This          is what will be referenced by the Mach-O PIC subsystem.  */
if|if
condition|(
operator|!
name|label
condition|)
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|machopic_function_base_name
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
call|(
modifier|*
name|targetm
operator|.
name|asm_out
operator|.
name|internal_label
call|)
argument_list|(
name|asm_out_file
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|xops
index|[
literal|2
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_pic
condition|)
name|output_asm_insn
argument_list|(
literal|"pop{l}\t%0"
argument_list|,
name|xops
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
name|name
index|[
literal|32
index|]
decl_stmt|;
name|get_pc_thunk_name
argument_list|(
name|name
argument_list|,
name|REGNO
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
name|pic_labels_used
operator||=
literal|1
operator|<<
name|REGNO
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|xops
index|[
literal|2
index|]
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|ggc_strdup
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|xops
index|[
literal|2
index|]
operator|=
name|gen_rtx_MEM
argument_list|(
name|QImode
argument_list|,
name|xops
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"call\t%X2"
argument_list|,
name|xops
argument_list|)
expr_stmt|;
comment|/* Output the Mach-O "canonical" label name ("Lxx$pb") here too.  This          is what will be referenced by the Mach-O PIC subsystem.  */
if|#
directive|if
name|TARGET_MACHO
if|if
condition|(
operator|!
name|label
condition|)
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|machopic_function_base_name
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|targetm
operator|.
name|asm_out
operator|.
name|internal_label
argument_list|(
name|asm_out_file
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|TARGET_MACHO
condition|)
return|return
literal|""
return|;
if|if
condition|(
operator|!
name|flag_pic
operator|||
name|TARGET_DEEP_BRANCH_PREDICTION
condition|)
name|output_asm_insn
argument_list|(
literal|"add{l}\t{%1, %0|%0, %1}"
argument_list|,
name|xops
argument_list|)
expr_stmt|;
else|else
name|output_asm_insn
argument_list|(
literal|"add{l}\t{%1+[.-%a2], %0|%0, %1+(.-%a2)}"
argument_list|,
name|xops
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
end_function

begin_comment
comment|/* Generate an "push" pattern for input ARG.  */
end_comment

begin_function
specifier|static
name|rtx
name|gen_push
parameter_list|(
name|rtx
name|arg
parameter_list|)
block|{
return|return
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_PRE_DEC
argument_list|(
name|Pmode
argument_list|,
name|stack_pointer_rtx
argument_list|)
argument_list|)
argument_list|,
name|arg
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return>= 0 if there is an unused call-clobbered register available    for the entire function.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|ix86_select_alt_pic_regnum
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|current_function_is_leaf
operator|&&
operator|!
name|current_function_profile
operator|&&
operator|!
name|ix86_current_function_calls_tls_descriptor
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
if|if
condition|(
operator|!
name|regs_ever_live
index|[
name|i
index|]
condition|)
return|return
name|i
return|;
block|}
return|return
name|INVALID_REGNUM
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if we need to save REGNO.  */
end_comment

begin_function
specifier|static
name|int
name|ix86_save_reg
parameter_list|(
name|unsigned
name|int
name|regno
parameter_list|,
name|int
name|maybe_eh_return
parameter_list|)
block|{
if|if
condition|(
name|pic_offset_table_rtx
operator|&&
name|regno
operator|==
name|REAL_PIC_OFFSET_TABLE_REGNUM
operator|&&
operator|(
name|regs_ever_live
index|[
name|REAL_PIC_OFFSET_TABLE_REGNUM
index|]
operator|||
name|current_function_profile
operator|||
name|current_function_calls_eh_return
operator|||
name|current_function_uses_const_pool
operator|)
condition|)
block|{
if|if
condition|(
name|ix86_select_alt_pic_regnum
argument_list|()
operator|!=
name|INVALID_REGNUM
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|current_function_calls_eh_return
operator|&&
name|maybe_eh_return
condition|)
block|{
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|test
init|=
name|EH_RETURN_DATA_REGNO
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|test
operator|==
name|INVALID_REGNUM
condition|)
break|break;
if|if
condition|(
name|test
operator|==
name|regno
condition|)
return|return
literal|1
return|;
block|}
block|}
if|if
condition|(
name|cfun
operator|->
name|machine
operator|->
name|force_align_arg_pointer
operator|&&
name|regno
operator|==
name|REGNO
argument_list|(
name|cfun
operator|->
name|machine
operator|->
name|force_align_arg_pointer
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
operator|(
name|regs_ever_live
index|[
name|regno
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|regno
index|]
operator|&&
operator|!
name|fixed_regs
index|[
name|regno
index|]
operator|&&
operator|(
name|regno
operator|!=
name|HARD_FRAME_POINTER_REGNUM
operator|||
operator|!
name|frame_pointer_needed
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return number of registers to be saved on the stack.  */
end_comment

begin_function
specifier|static
name|int
name|ix86_nsaved_regs
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|nregs
init|=
literal|0
decl_stmt|;
name|int
name|regno
decl_stmt|;
for|for
control|(
name|regno
operator|=
name|FIRST_PSEUDO_REGISTER
operator|-
literal|1
init|;
name|regno
operator|>=
literal|0
condition|;
name|regno
operator|--
control|)
if|if
condition|(
name|ix86_save_reg
argument_list|(
name|regno
argument_list|,
name|true
argument_list|)
condition|)
name|nregs
operator|++
expr_stmt|;
return|return
name|nregs
return|;
block|}
end_function

begin_comment
comment|/* Return the offset between two registers, one to be eliminated, and the other    its replacement, at the start of a routine.  */
end_comment

begin_function
name|HOST_WIDE_INT
name|ix86_initial_elimination_offset
parameter_list|(
name|int
name|from
parameter_list|,
name|int
name|to
parameter_list|)
block|{
name|struct
name|ix86_frame
name|frame
decl_stmt|;
name|ix86_compute_frame_layout
argument_list|(
operator|&
name|frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|from
operator|==
name|ARG_POINTER_REGNUM
operator|&&
name|to
operator|==
name|HARD_FRAME_POINTER_REGNUM
condition|)
return|return
name|frame
operator|.
name|hard_frame_pointer_offset
return|;
elseif|else
if|if
condition|(
name|from
operator|==
name|FRAME_POINTER_REGNUM
operator|&&
name|to
operator|==
name|HARD_FRAME_POINTER_REGNUM
condition|)
return|return
name|frame
operator|.
name|hard_frame_pointer_offset
operator|-
name|frame
operator|.
name|frame_pointer_offset
return|;
else|else
block|{
name|gcc_assert
argument_list|(
name|to
operator|==
name|STACK_POINTER_REGNUM
argument_list|)
expr_stmt|;
if|if
condition|(
name|from
operator|==
name|ARG_POINTER_REGNUM
condition|)
return|return
name|frame
operator|.
name|stack_pointer_offset
return|;
name|gcc_assert
argument_list|(
name|from
operator|==
name|FRAME_POINTER_REGNUM
argument_list|)
expr_stmt|;
return|return
name|frame
operator|.
name|stack_pointer_offset
operator|-
name|frame
operator|.
name|frame_pointer_offset
return|;
block|}
block|}
end_function

begin_comment
comment|/* Fill structure ix86_frame about frame of currently computed function.  */
end_comment

begin_function
specifier|static
name|void
name|ix86_compute_frame_layout
parameter_list|(
name|struct
name|ix86_frame
modifier|*
name|frame
parameter_list|)
block|{
name|HOST_WIDE_INT
name|total_size
decl_stmt|;
name|unsigned
name|int
name|stack_alignment_needed
decl_stmt|;
name|HOST_WIDE_INT
name|offset
decl_stmt|;
name|unsigned
name|int
name|preferred_alignment
decl_stmt|;
name|HOST_WIDE_INT
name|size
init|=
name|get_frame_size
argument_list|()
decl_stmt|;
name|frame
operator|->
name|nregs
operator|=
name|ix86_nsaved_regs
argument_list|()
expr_stmt|;
name|total_size
operator|=
name|size
expr_stmt|;
name|stack_alignment_needed
operator|=
name|cfun
operator|->
name|stack_alignment_needed
operator|/
name|BITS_PER_UNIT
expr_stmt|;
name|preferred_alignment
operator|=
name|cfun
operator|->
name|preferred_stack_boundary
operator|/
name|BITS_PER_UNIT
expr_stmt|;
comment|/* During reload iteration the amount of registers saved can change.      Recompute the value as needed.  Do not recompute when amount of registers      didn't change as reload does multiple calls to the function and does not      expect the decision to change within single iteration.  */
if|if
condition|(
operator|!
name|optimize_size
operator|&&
name|cfun
operator|->
name|machine
operator|->
name|use_fast_prologue_epilogue_nregs
operator|!=
name|frame
operator|->
name|nregs
condition|)
block|{
name|int
name|count
init|=
name|frame
operator|->
name|nregs
decl_stmt|;
name|cfun
operator|->
name|machine
operator|->
name|use_fast_prologue_epilogue_nregs
operator|=
name|count
expr_stmt|;
comment|/* The fast prologue uses move instead of push to save registers.  This          is significantly longer, but also executes faster as modern hardware          can execute the moves in parallel, but can't do that for push/pop.  	 Be careful about choosing what prologue to emit:  When function takes 	 many instructions to execute we may use slow version as well as in 	 case function is known to be outside hot spot (this is known with 	 feedback only).  Weight the size of function by number of registers 	 to save as it is cheap to use one or two push instructions but very 	 slow to use many of them.  */
if|if
condition|(
name|count
condition|)
name|count
operator|=
operator|(
name|count
operator|-
literal|1
operator|)
operator|*
name|FAST_PROLOGUE_INSN_COUNT
expr_stmt|;
if|if
condition|(
name|cfun
operator|->
name|function_frequency
operator|<
name|FUNCTION_FREQUENCY_NORMAL
operator|||
operator|(
name|flag_branch_probabilities
operator|&&
name|cfun
operator|->
name|function_frequency
operator|<
name|FUNCTION_FREQUENCY_HOT
operator|)
condition|)
name|cfun
operator|->
name|machine
operator|->
name|use_fast_prologue_epilogue
operator|=
name|false
expr_stmt|;
else|else
name|cfun
operator|->
name|machine
operator|->
name|use_fast_prologue_epilogue
operator|=
operator|!
name|expensive_function_p
argument_list|(
name|count
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_PROLOGUE_USING_MOVE
operator|&&
name|cfun
operator|->
name|machine
operator|->
name|use_fast_prologue_epilogue
condition|)
name|frame
operator|->
name|save_regs_using_mov
operator|=
name|true
expr_stmt|;
else|else
name|frame
operator|->
name|save_regs_using_mov
operator|=
name|false
expr_stmt|;
comment|/* Skip return address and saved base pointer.  */
name|offset
operator|=
name|frame_pointer_needed
condition|?
name|UNITS_PER_WORD
operator|*
literal|2
else|:
name|UNITS_PER_WORD
expr_stmt|;
name|frame
operator|->
name|hard_frame_pointer_offset
operator|=
name|offset
expr_stmt|;
comment|/* Do some sanity checking of stack_alignment_needed and      preferred_alignment, since i386 port is the only using those features      that may break easily.  */
name|gcc_assert
argument_list|(
operator|!
name|size
operator|||
name|stack_alignment_needed
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|preferred_alignment
operator|>=
name|STACK_BOUNDARY
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|preferred_alignment
operator|<=
name|PREFERRED_STACK_BOUNDARY
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|stack_alignment_needed
operator|<=
name|PREFERRED_STACK_BOUNDARY
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|stack_alignment_needed
operator|<
name|STACK_BOUNDARY
operator|/
name|BITS_PER_UNIT
condition|)
name|stack_alignment_needed
operator|=
name|STACK_BOUNDARY
operator|/
name|BITS_PER_UNIT
expr_stmt|;
comment|/* Register save area */
name|offset
operator|+=
name|frame
operator|->
name|nregs
operator|*
name|UNITS_PER_WORD
expr_stmt|;
comment|/* Va-arg area */
if|if
condition|(
name|ix86_save_varrargs_registers
condition|)
block|{
name|offset
operator|+=
name|X86_64_VARARGS_SIZE
expr_stmt|;
name|frame
operator|->
name|va_arg_size
operator|=
name|X86_64_VARARGS_SIZE
expr_stmt|;
block|}
else|else
name|frame
operator|->
name|va_arg_size
operator|=
literal|0
expr_stmt|;
comment|/* Align start of frame for local function.  */
name|frame
operator|->
name|padding1
operator|=
operator|(
operator|(
name|offset
operator|+
name|stack_alignment_needed
operator|-
literal|1
operator|)
operator|&
operator|-
name|stack_alignment_needed
operator|)
operator|-
name|offset
expr_stmt|;
name|offset
operator|+=
name|frame
operator|->
name|padding1
expr_stmt|;
comment|/* Frame pointer points here.  */
name|frame
operator|->
name|frame_pointer_offset
operator|=
name|offset
expr_stmt|;
name|offset
operator|+=
name|size
expr_stmt|;
comment|/* Add outgoing arguments area.  Can be skipped if we eliminated      all the function calls as dead code.      Skipping is however impossible when function calls alloca.  Alloca      expander assumes that last current_function_outgoing_args_size      of stack frame are unused.  */
if|if
condition|(
name|ACCUMULATE_OUTGOING_ARGS
operator|&&
operator|(
operator|!
name|current_function_is_leaf
operator|||
name|current_function_calls_alloca
operator|||
name|ix86_current_function_calls_tls_descriptor
operator|)
condition|)
block|{
name|offset
operator|+=
name|current_function_outgoing_args_size
expr_stmt|;
name|frame
operator|->
name|outgoing_arguments_size
operator|=
name|current_function_outgoing_args_size
expr_stmt|;
block|}
else|else
name|frame
operator|->
name|outgoing_arguments_size
operator|=
literal|0
expr_stmt|;
comment|/* Align stack boundary.  Only needed if we're calling another function      or using alloca.  */
if|if
condition|(
operator|!
name|current_function_is_leaf
operator|||
name|current_function_calls_alloca
operator|||
name|ix86_current_function_calls_tls_descriptor
condition|)
name|frame
operator|->
name|padding2
operator|=
operator|(
operator|(
name|offset
operator|+
name|preferred_alignment
operator|-
literal|1
operator|)
operator|&
operator|-
name|preferred_alignment
operator|)
operator|-
name|offset
expr_stmt|;
else|else
name|frame
operator|->
name|padding2
operator|=
literal|0
expr_stmt|;
name|offset
operator|+=
name|frame
operator|->
name|padding2
expr_stmt|;
comment|/* We've reached end of stack frame.  */
name|frame
operator|->
name|stack_pointer_offset
operator|=
name|offset
expr_stmt|;
comment|/* Size prologue needs to allocate.  */
name|frame
operator|->
name|to_allocate
operator|=
operator|(
name|size
operator|+
name|frame
operator|->
name|padding1
operator|+
name|frame
operator|->
name|padding2
operator|+
name|frame
operator|->
name|outgoing_arguments_size
operator|+
name|frame
operator|->
name|va_arg_size
operator|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|frame
operator|->
name|to_allocate
operator|&&
name|frame
operator|->
name|nregs
operator|<=
literal|1
operator|)
operator|||
operator|(
name|TARGET_64BIT
operator|&&
name|frame
operator|->
name|to_allocate
operator|>=
operator|(
name|HOST_WIDE_INT
operator|)
literal|0x80000000
operator|)
condition|)
name|frame
operator|->
name|save_regs_using_mov
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|TARGET_RED_ZONE
operator|&&
name|current_function_sp_is_unchanging
operator|&&
name|current_function_is_leaf
operator|&&
operator|!
name|ix86_current_function_calls_tls_descriptor
condition|)
block|{
name|frame
operator|->
name|red_zone_size
operator|=
name|frame
operator|->
name|to_allocate
expr_stmt|;
if|if
condition|(
name|frame
operator|->
name|save_regs_using_mov
condition|)
name|frame
operator|->
name|red_zone_size
operator|+=
name|frame
operator|->
name|nregs
operator|*
name|UNITS_PER_WORD
expr_stmt|;
if|if
condition|(
name|frame
operator|->
name|red_zone_size
operator|>
name|RED_ZONE_SIZE
operator|-
name|RED_ZONE_RESERVE
condition|)
name|frame
operator|->
name|red_zone_size
operator|=
name|RED_ZONE_SIZE
operator|-
name|RED_ZONE_RESERVE
expr_stmt|;
block|}
else|else
name|frame
operator|->
name|red_zone_size
operator|=
literal|0
expr_stmt|;
name|frame
operator|->
name|to_allocate
operator|-=
name|frame
operator|->
name|red_zone_size
expr_stmt|;
name|frame
operator|->
name|stack_pointer_offset
operator|-=
name|frame
operator|->
name|red_zone_size
expr_stmt|;
if|#
directive|if
literal|0
block|fprintf (stderr, "nregs: %i\n", frame->nregs);   fprintf (stderr, "size: %i\n", size);   fprintf (stderr, "alignment1: %i\n", stack_alignment_needed);   fprintf (stderr, "padding1: %i\n", frame->padding1);   fprintf (stderr, "va_arg: %i\n", frame->va_arg_size);   fprintf (stderr, "padding2: %i\n", frame->padding2);   fprintf (stderr, "to_allocate: %i\n", frame->to_allocate);   fprintf (stderr, "red_zone_size: %i\n", frame->red_zone_size);   fprintf (stderr, "frame_pointer_offset: %i\n", frame->frame_pointer_offset);   fprintf (stderr, "hard_frame_pointer_offset: %i\n", 	   frame->hard_frame_pointer_offset);   fprintf (stderr, "stack_pointer_offset: %i\n", frame->stack_pointer_offset);
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Emit code to save registers in the prologue.  */
end_comment

begin_function
specifier|static
name|void
name|ix86_emit_save_regs
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|int
name|regno
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|regno
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|regno
operator|--
operator|>
literal|0
condition|;
control|)
if|if
condition|(
name|ix86_save_reg
argument_list|(
name|regno
argument_list|,
name|true
argument_list|)
condition|)
block|{
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_push
argument_list|(
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|regno
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Emit code to save registers using MOV insns.  First register    is restored from POINTER + OFFSET.  */
end_comment

begin_function
specifier|static
name|void
name|ix86_emit_save_regs_using_mov
parameter_list|(
name|rtx
name|pointer
parameter_list|,
name|HOST_WIDE_INT
name|offset
parameter_list|)
block|{
name|unsigned
name|int
name|regno
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|ix86_save_reg
argument_list|(
name|regno
argument_list|,
name|true
argument_list|)
condition|)
block|{
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|adjust_address
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|pointer
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|offset
argument_list|)
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|regno
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|offset
operator|+=
name|UNITS_PER_WORD
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Expand prologue or epilogue stack adjustment.    The pattern exist to put a dependency on all ebp-based memory accesses.    STYLE should be negative if instructions should be marked as frame related,    zero if %r11 register is live and cannot be freely used and positive    otherwise.  */
end_comment

begin_function
specifier|static
name|void
name|pro_epilogue_adjust_stack
parameter_list|(
name|rtx
name|dest
parameter_list|,
name|rtx
name|src
parameter_list|,
name|rtx
name|offset
parameter_list|,
name|int
name|style
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
operator|!
name|TARGET_64BIT
condition|)
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_pro_epilogue_adjust_stack_1
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|x86_64_immediate_operand
argument_list|(
name|offset
argument_list|,
name|DImode
argument_list|)
condition|)
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_pro_epilogue_adjust_stack_rex64
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|rtx
name|r11
decl_stmt|;
comment|/* r11 is used by indirect sibcall return as well, set before the 	 epilogue and used after the epilogue.  ATM indirect sibcall 	 shouldn't be used together with huge frame sizes in one 	 function because of the frame_size check in sibcall.c.  */
name|gcc_assert
argument_list|(
name|style
argument_list|)
expr_stmt|;
name|r11
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|FIRST_REX_INT_REG
operator|+
literal|3
comment|/* R11 */
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|DImode
argument_list|,
name|r11
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|style
operator|<
literal|0
condition|)
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_pro_epilogue_adjust_stack_rex64_2
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|r11
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|style
operator|<
literal|0
condition|)
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the TARGET_INTERNAL_ARG_POINTER hook.  */
end_comment

begin_function
specifier|static
name|rtx
name|ix86_internal_arg_pointer
parameter_list|(
name|void
parameter_list|)
block|{
name|bool
name|has_force_align_arg_pointer
init|=
operator|(
literal|0
operator|!=
name|lookup_attribute
argument_list|(
name|ix86_force_align_arg_pointer_string
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
operator|(
name|FORCE_PREFERRED_STACK_BOUNDARY_IN_MAIN
operator|&&
name|DECL_NAME
argument_list|(
name|current_function_decl
argument_list|)
operator|&&
name|MAIN_NAME_P
argument_list|(
name|DECL_NAME
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
operator|&&
name|DECL_FILE_SCOPE_P
argument_list|(
name|current_function_decl
argument_list|)
operator|)
operator|||
name|ix86_force_align_arg_pointer
operator|||
name|has_force_align_arg_pointer
condition|)
block|{
comment|/* Nested functions can't realign the stack due to a register 	 conflict.  */
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|current_function_decl
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
if|if
condition|(
name|ix86_force_align_arg_pointer
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"-mstackrealign ignored for nested functions"
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_force_align_arg_pointer
condition|)
name|error
argument_list|(
literal|"%s not supported for nested functions"
argument_list|,
name|ix86_force_align_arg_pointer_string
argument_list|)
expr_stmt|;
return|return
name|virtual_incoming_args_rtx
return|;
block|}
name|cfun
operator|->
name|machine
operator|->
name|force_align_arg_pointer
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
name|copy_to_reg
argument_list|(
name|cfun
operator|->
name|machine
operator|->
name|force_align_arg_pointer
argument_list|)
return|;
block|}
else|else
return|return
name|virtual_incoming_args_rtx
return|;
block|}
end_function

begin_comment
comment|/* Handle the TARGET_DWARF_HANDLE_FRAME_UNSPEC hook.    This is called from dwarf2out.c to emit call frame instructions    for frame-related insns containing UNSPECs and UNSPEC_VOLATILEs. */
end_comment

begin_function
specifier|static
name|void
name|ix86_dwarf_handle_frame_unspec
parameter_list|(
specifier|const
name|char
modifier|*
name|label
parameter_list|,
name|rtx
name|pattern
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|rtx
name|unspec
init|=
name|SET_SRC
argument_list|(
name|pattern
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|unspec
argument_list|)
operator|==
name|UNSPEC
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|index
condition|)
block|{
case|case
name|UNSPEC_REG_SAVE
case|:
name|dwarf2out_reg_save_reg
argument_list|(
name|label
argument_list|,
name|XVECEXP
argument_list|(
name|unspec
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|SET_DEST
argument_list|(
name|pattern
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSPEC_DEF_CFA
case|:
name|dwarf2out_def_cfa
argument_list|(
name|label
argument_list|,
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|pattern
argument_list|)
argument_list|)
argument_list|,
name|INTVAL
argument_list|(
name|XVECEXP
argument_list|(
name|unspec
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Expand the prologue into a bunch of separate insns.  */
end_comment

begin_function
name|void
name|ix86_expand_prologue
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
name|bool
name|pic_reg_used
decl_stmt|;
name|struct
name|ix86_frame
name|frame
decl_stmt|;
name|HOST_WIDE_INT
name|allocate
decl_stmt|;
name|ix86_compute_frame_layout
argument_list|(
operator|&
name|frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfun
operator|->
name|machine
operator|->
name|force_align_arg_pointer
condition|)
block|{
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
comment|/* Grab the argument pointer.  */
name|x
operator|=
name|plus_constant
argument_list|(
name|stack_pointer_rtx
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|y
operator|=
name|cfun
operator|->
name|machine
operator|->
name|force_align_arg_pointer
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* The unwind info consists of two parts: install the fafp as the cfa, 	 and record the fafp as the "save register" of the stack pointer. 	 The later is there in order that the unwinder can see where it 	 should restore the stack pointer across the and insn.  */
name|x
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|const0_rtx
argument_list|)
argument_list|,
name|UNSPEC_DEF_CFA
argument_list|)
expr_stmt|;
name|x
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
name|y
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|stack_pointer_rtx
argument_list|)
argument_list|,
name|UNSPEC_REG_SAVE
argument_list|)
expr_stmt|;
name|y
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|cfun
operator|->
name|machine
operator|->
name|force_align_arg_pointer
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|y
argument_list|)
operator|=
literal|1
expr_stmt|;
name|x
operator|=
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_FRAME_RELATED_EXPR
argument_list|,
name|x
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|x
expr_stmt|;
comment|/* Align the stack.  */
name|emit_insn
argument_list|(
name|gen_andsi3
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
operator|-
literal|16
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* And here we cheat like madmen with the unwind info.  We force the 	 cfa register back to sp+4, which is exactly what it was at the 	 start of the function.  Re-pushing the return address results in 	 the return at the same spot relative to the cfa, and thus is 	 correct wrt the unwind info.  */
name|x
operator|=
name|cfun
operator|->
name|machine
operator|->
name|force_align_arg_pointer
expr_stmt|;
name|x
operator|=
name|gen_frame_mem
argument_list|(
name|Pmode
argument_list|,
name|plus_constant
argument_list|(
name|x
argument_list|,
operator|-
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_push
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|x
operator|=
name|GEN_INT
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|x
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|x
argument_list|)
argument_list|,
name|UNSPEC_DEF_CFA
argument_list|)
expr_stmt|;
name|x
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|x
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_FRAME_RELATED_EXPR
argument_list|,
name|x
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|x
expr_stmt|;
block|}
comment|/* Note: AT&T enter does NOT have reversed args.  Enter is probably      slower on all targets.  Also sdb doesn't like it.  */
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_push
argument_list|(
name|hard_frame_pointer_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|allocate
operator|=
name|frame
operator|.
name|to_allocate
expr_stmt|;
if|if
condition|(
operator|!
name|frame
operator|.
name|save_regs_using_mov
condition|)
name|ix86_emit_save_regs
argument_list|()
expr_stmt|;
else|else
name|allocate
operator|+=
name|frame
operator|.
name|nregs
operator|*
name|UNITS_PER_WORD
expr_stmt|;
comment|/* When using red zone we may start register saving before allocating      the stack frame saving one cycle of the prologue.  */
if|if
condition|(
name|TARGET_RED_ZONE
operator|&&
name|frame
operator|.
name|save_regs_using_mov
condition|)
name|ix86_emit_save_regs_using_mov
argument_list|(
name|frame_pointer_needed
condition|?
name|hard_frame_pointer_rtx
else|:
name|stack_pointer_rtx
argument_list|,
operator|-
name|frame
operator|.
name|nregs
operator|*
name|UNITS_PER_WORD
argument_list|)
expr_stmt|;
if|if
condition|(
name|allocate
operator|==
literal|0
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|TARGET_STACK_PROBE
operator|||
name|allocate
operator|<
name|CHECK_STACK_LIMIT
condition|)
name|pro_epilogue_adjust_stack
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
operator|-
name|allocate
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Only valid for Win32.  */
name|rtx
name|eax
init|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|bool
name|eax_live
init|=
name|ix86_eax_live_at_start_p
argument_list|()
decl_stmt|;
name|rtx
name|t
decl_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|TARGET_64BIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|eax_live
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_push
argument_list|(
name|eax
argument_list|)
argument_list|)
expr_stmt|;
name|allocate
operator|-=
literal|4
expr_stmt|;
block|}
name|emit_move_insn
argument_list|(
name|eax
argument_list|,
name|GEN_INT
argument_list|(
name|allocate
argument_list|)
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_allocate_stack_worker
argument_list|(
name|eax
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|t
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
operator|-
name|allocate
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_FRAME_RELATED_EXPR
argument_list|,
name|t
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|eax_live
condition|)
block|{
if|if
condition|(
name|frame_pointer_needed
condition|)
name|t
operator|=
name|plus_constant
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
name|allocate
operator|-
name|frame
operator|.
name|to_allocate
operator|-
name|frame
operator|.
name|nregs
operator|*
name|UNITS_PER_WORD
argument_list|)
expr_stmt|;
else|else
name|t
operator|=
name|plus_constant
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|allocate
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|eax
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|frame
operator|.
name|save_regs_using_mov
operator|&&
operator|!
name|TARGET_RED_ZONE
condition|)
block|{
if|if
condition|(
operator|!
name|frame_pointer_needed
operator|||
operator|!
name|frame
operator|.
name|to_allocate
condition|)
name|ix86_emit_save_regs_using_mov
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|frame
operator|.
name|to_allocate
argument_list|)
expr_stmt|;
else|else
name|ix86_emit_save_regs_using_mov
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
operator|-
name|frame
operator|.
name|nregs
operator|*
name|UNITS_PER_WORD
argument_list|)
expr_stmt|;
block|}
name|pic_reg_used
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|pic_offset_table_rtx
operator|&&
operator|(
name|regs_ever_live
index|[
name|REAL_PIC_OFFSET_TABLE_REGNUM
index|]
operator|||
name|current_function_profile
operator|)
condition|)
block|{
name|unsigned
name|int
name|alt_pic_reg_used
init|=
name|ix86_select_alt_pic_regnum
argument_list|()
decl_stmt|;
if|if
condition|(
name|alt_pic_reg_used
operator|!=
name|INVALID_REGNUM
condition|)
name|REGNO
argument_list|(
name|pic_offset_table_rtx
argument_list|)
operator|=
name|alt_pic_reg_used
expr_stmt|;
name|pic_reg_used
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|pic_reg_used
condition|)
block|{
if|if
condition|(
name|TARGET_64BIT
condition|)
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_set_got_rex64
argument_list|(
name|pic_offset_table_rtx
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_set_got
argument_list|(
name|pic_offset_table_rtx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Even with accurate pre-reload life analysis, we can wind up 	 deleting all references to the pic register after reload. 	 Consider if cross-jumping unifies two sides of a branch 	 controlled by a comparison vs the only read from a global. 	 In which case, allow the set_got to be deleted, though we're 	 too late to do anything about the ebx save in the prologue.  */
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_MAYBE_DEAD
argument_list|,
name|const0_rtx
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* Prevent function calls from be scheduled before the call to mcount.      In the pic_reg_used case, make sure that the got load isn't deleted.  */
if|if
condition|(
name|current_function_profile
condition|)
name|emit_insn
argument_list|(
name|gen_blockage
argument_list|(
name|pic_reg_used
condition|?
name|pic_offset_table_rtx
else|:
name|const0_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit code to restore saved registers using MOV insns.  First register    is restored from POINTER + OFFSET.  */
end_comment

begin_function
specifier|static
name|void
name|ix86_emit_restore_regs_using_mov
parameter_list|(
name|rtx
name|pointer
parameter_list|,
name|HOST_WIDE_INT
name|offset
parameter_list|,
name|int
name|maybe_eh_return
parameter_list|)
block|{
name|int
name|regno
decl_stmt|;
name|rtx
name|base_address
init|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|pointer
argument_list|)
decl_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|ix86_save_reg
argument_list|(
name|regno
argument_list|,
name|maybe_eh_return
argument_list|)
condition|)
block|{
comment|/* Ensure that adjust_address won't be forced to produce pointer 	   out of range allowed by x86-64 instruction set.  */
if|if
condition|(
name|TARGET_64BIT
operator|&&
name|offset
operator|!=
name|trunc_int_for_mode
argument_list|(
name|offset
argument_list|,
name|SImode
argument_list|)
condition|)
block|{
name|rtx
name|r11
decl_stmt|;
name|r11
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|FIRST_REX_INT_REG
operator|+
literal|3
comment|/* R11 */
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|r11
argument_list|,
name|GEN_INT
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|r11
argument_list|,
name|r11
argument_list|,
name|pointer
argument_list|)
argument_list|)
expr_stmt|;
name|base_address
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|r11
argument_list|)
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
block|}
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|regno
argument_list|)
argument_list|,
name|adjust_address
argument_list|(
name|base_address
argument_list|,
name|Pmode
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|UNITS_PER_WORD
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Restore function stack, frame, and registers.  */
end_comment

begin_function
name|void
name|ix86_expand_epilogue
parameter_list|(
name|int
name|style
parameter_list|)
block|{
name|int
name|regno
decl_stmt|;
name|int
name|sp_valid
init|=
operator|!
name|frame_pointer_needed
operator|||
name|current_function_sp_is_unchanging
decl_stmt|;
name|struct
name|ix86_frame
name|frame
decl_stmt|;
name|HOST_WIDE_INT
name|offset
decl_stmt|;
name|ix86_compute_frame_layout
argument_list|(
operator|&
name|frame
argument_list|)
expr_stmt|;
comment|/* Calculate start of saved registers relative to ebp.  Special care      must be taken for the normal return case of a function using      eh_return: the eax and edx registers are marked as saved, but not      restored along this path.  */
name|offset
operator|=
name|frame
operator|.
name|nregs
expr_stmt|;
if|if
condition|(
name|current_function_calls_eh_return
operator|&&
name|style
operator|!=
literal|2
condition|)
name|offset
operator|-=
literal|2
expr_stmt|;
name|offset
operator|*=
operator|-
name|UNITS_PER_WORD
expr_stmt|;
comment|/* If we're only restoring one register and sp is not valid then      using a move instruction to restore the register since it's      less work than reloading sp and popping the register.       The default code result in stack adjustment using add/lea instruction,      while this code results in LEAVE instruction (or discrete equivalent),      so it is profitable in some other cases as well.  Especially when there      are no registers to restore.  We also use this code when TARGET_USE_LEAVE      and there is exactly one register to pop. This heuristic may need some      tuning in future.  */
if|if
condition|(
operator|(
operator|!
name|sp_valid
operator|&&
name|frame
operator|.
name|nregs
operator|<=
literal|1
operator|)
operator|||
operator|(
name|TARGET_EPILOGUE_USING_MOVE
operator|&&
name|cfun
operator|->
name|machine
operator|->
name|use_fast_prologue_epilogue
operator|&&
operator|(
name|frame
operator|.
name|nregs
operator|>
literal|1
operator|||
name|frame
operator|.
name|to_allocate
operator|)
operator|)
operator|||
operator|(
name|frame_pointer_needed
operator|&&
operator|!
name|frame
operator|.
name|nregs
operator|&&
name|frame
operator|.
name|to_allocate
operator|)
operator|||
operator|(
name|frame_pointer_needed
operator|&&
name|TARGET_USE_LEAVE
operator|&&
name|cfun
operator|->
name|machine
operator|->
name|use_fast_prologue_epilogue
operator|&&
name|frame
operator|.
name|nregs
operator|==
literal|1
operator|)
operator|||
name|current_function_calls_eh_return
condition|)
block|{
comment|/* Restore registers.  We can use ebp or esp to address the memory 	 locations.  If both are available, default to ebp, since offsets 	 are known to be small.  Only exception is esp pointing directly to the 	 end of block of saved registers, where we may simplify addressing 	 mode.  */
if|if
condition|(
operator|!
name|frame_pointer_needed
operator|||
operator|(
name|sp_valid
operator|&&
operator|!
name|frame
operator|.
name|to_allocate
operator|)
condition|)
name|ix86_emit_restore_regs_using_mov
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|frame
operator|.
name|to_allocate
argument_list|,
name|style
operator|==
literal|2
argument_list|)
expr_stmt|;
else|else
name|ix86_emit_restore_regs_using_mov
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
name|offset
argument_list|,
name|style
operator|==
literal|2
argument_list|)
expr_stmt|;
comment|/* eh_return epilogues need %ecx added to the stack pointer.  */
if|if
condition|(
name|style
operator|==
literal|2
condition|)
block|{
name|rtx
name|tmp
decl_stmt|,
name|sa
init|=
name|EH_RETURN_STACKADJ_RTX
decl_stmt|;
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
name|tmp
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|hard_frame_pointer_rtx
argument_list|,
name|sa
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|plus_constant
argument_list|(
name|tmp
argument_list|,
name|UNITS_PER_WORD
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|sa
argument_list|,
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|hard_frame_pointer_rtx
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|pro_epilogue_adjust_stack
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|sa
argument_list|,
name|const0_rtx
argument_list|,
name|style
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tmp
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|sa
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|plus_constant
argument_list|(
name|tmp
argument_list|,
operator|(
name|frame
operator|.
name|to_allocate
operator|+
name|frame
operator|.
name|nregs
operator|*
name|UNITS_PER_WORD
operator|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|frame_pointer_needed
condition|)
name|pro_epilogue_adjust_stack
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|frame
operator|.
name|to_allocate
operator|+
name|frame
operator|.
name|nregs
operator|*
name|UNITS_PER_WORD
argument_list|)
argument_list|,
name|style
argument_list|)
expr_stmt|;
comment|/* If not an i386, mov& pop is faster than "leave".  */
elseif|else
if|if
condition|(
name|TARGET_USE_LEAVE
operator|||
name|optimize_size
operator|||
operator|!
name|cfun
operator|->
name|machine
operator|->
name|use_fast_prologue_epilogue
condition|)
name|emit_insn
argument_list|(
name|TARGET_64BIT
condition|?
name|gen_leave_rex64
argument_list|()
else|:
name|gen_leave
argument_list|()
argument_list|)
expr_stmt|;
else|else
block|{
name|pro_epilogue_adjust_stack
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|hard_frame_pointer_rtx
argument_list|,
name|const0_rtx
argument_list|,
name|style
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
name|emit_insn
argument_list|(
name|gen_popdi1
argument_list|(
name|hard_frame_pointer_rtx
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_popsi1
argument_list|(
name|hard_frame_pointer_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* First step is to deallocate the stack frame so that we can 	 pop the registers.  */
if|if
condition|(
operator|!
name|sp_valid
condition|)
block|{
name|gcc_assert
argument_list|(
name|frame_pointer_needed
argument_list|)
expr_stmt|;
name|pro_epilogue_adjust_stack
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|hard_frame_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|offset
argument_list|)
argument_list|,
name|style
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|frame
operator|.
name|to_allocate
condition|)
name|pro_epilogue_adjust_stack
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|frame
operator|.
name|to_allocate
argument_list|)
argument_list|,
name|style
argument_list|)
expr_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|ix86_save_reg
argument_list|(
name|regno
argument_list|,
name|false
argument_list|)
condition|)
block|{
if|if
condition|(
name|TARGET_64BIT
condition|)
name|emit_insn
argument_list|(
name|gen_popdi1
argument_list|(
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|regno
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_popsi1
argument_list|(
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|regno
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
comment|/* Leave results in shorter dependency chains on CPUs that are 	     able to grok it fast.  */
if|if
condition|(
name|TARGET_USE_LEAVE
condition|)
name|emit_insn
argument_list|(
name|TARGET_64BIT
condition|?
name|gen_leave_rex64
argument_list|()
else|:
name|gen_leave
argument_list|()
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TARGET_64BIT
condition|)
name|emit_insn
argument_list|(
name|gen_popdi1
argument_list|(
name|hard_frame_pointer_rtx
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_popsi1
argument_list|(
name|hard_frame_pointer_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cfun
operator|->
name|machine
operator|->
name|force_align_arg_pointer
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|cfun
operator|->
name|machine
operator|->
name|force_align_arg_pointer
argument_list|,
name|GEN_INT
argument_list|(
operator|-
literal|4
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Sibcall epilogues don't want a return instruction.  */
if|if
condition|(
name|style
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|current_function_pops_args
operator|&&
name|current_function_args_size
condition|)
block|{
name|rtx
name|popc
init|=
name|GEN_INT
argument_list|(
name|current_function_pops_args
argument_list|)
decl_stmt|;
comment|/* i386 can only pop 64K bytes.  If asked to pop more, pop 	 return address, do explicit add, and jump indirectly to the 	 caller.  */
if|if
condition|(
name|current_function_pops_args
operator|>=
literal|65536
condition|)
block|{
name|rtx
name|ecx
init|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
literal|2
argument_list|)
decl_stmt|;
comment|/* There is no "pascal" calling convention in 64bit ABI.  */
name|gcc_assert
argument_list|(
operator|!
name|TARGET_64BIT
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_popsi1
argument_list|(
name|ecx
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|popc
argument_list|)
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_return_indirect_internal
argument_list|(
name|ecx
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|emit_jump_insn
argument_list|(
name|gen_return_pop_internal
argument_list|(
name|popc
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|emit_jump_insn
argument_list|(
name|gen_return_internal
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Reset from the function's potential modifications.  */
end_comment

begin_function
specifier|static
name|void
name|ix86_output_function_epilogue
parameter_list|(
name|FILE
modifier|*
name|file
name|ATTRIBUTE_UNUSED
parameter_list|,
name|HOST_WIDE_INT
name|size
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|pic_offset_table_rtx
condition|)
name|REGNO
argument_list|(
name|pic_offset_table_rtx
argument_list|)
operator|=
name|REAL_PIC_OFFSET_TABLE_REGNUM
expr_stmt|;
if|#
directive|if
name|TARGET_MACHO
comment|/* Mach-O doesn't support labels at the end of objects, so if      it looks like we might want one, insert a NOP.  */
block|{
name|rtx
name|insn
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
while|while
condition|(
name|insn
operator|&&
name|NOTE_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE_INSN_DELETED_LABEL
condition|)
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|&&
operator|(
name|LABEL_P
argument_list|(
name|insn
argument_list|)
operator|||
operator|(
name|NOTE_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_DELETED_LABEL
operator|)
operator|)
condition|)
name|fputs
argument_list|(
literal|"\tnop\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Extract the parts of an RTL expression that is a valid memory address    for an instruction.  Return 0 if the structure of the address is    grossly off.  Return -1 if the address contains ASHIFT, so it is not    strictly valid, but still used for computing length of lea instruction.  */
end_comment

begin_function
name|int
name|ix86_decompose_address
parameter_list|(
name|rtx
name|addr
parameter_list|,
name|struct
name|ix86_address
modifier|*
name|out
parameter_list|)
block|{
name|rtx
name|base
init|=
name|NULL_RTX
decl_stmt|,
name|index
init|=
name|NULL_RTX
decl_stmt|,
name|disp
init|=
name|NULL_RTX
decl_stmt|;
name|rtx
name|base_reg
decl_stmt|,
name|index_reg
decl_stmt|;
name|HOST_WIDE_INT
name|scale
init|=
literal|1
decl_stmt|;
name|rtx
name|scale_rtx
init|=
name|NULL_RTX
decl_stmt|;
name|int
name|retval
init|=
literal|1
decl_stmt|;
name|enum
name|ix86_address_seg
name|seg
init|=
name|SEG_DEFAULT
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|SUBREG
condition|)
name|base
operator|=
name|addr
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|rtx
name|addends
index|[
literal|4
index|]
decl_stmt|,
name|op
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
name|op
operator|=
name|addr
expr_stmt|;
do|do
block|{
if|if
condition|(
name|n
operator|>=
literal|4
condition|)
return|return
literal|0
return|;
name|addends
index|[
name|n
operator|++
index|]
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|PLUS
condition|)
do|;
if|if
condition|(
name|n
operator|>=
literal|4
condition|)
return|return
literal|0
return|;
name|addends
index|[
name|n
index|]
operator|=
name|op
expr_stmt|;
for|for
control|(
name|i
operator|=
name|n
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|op
operator|=
name|addends
index|[
name|i
index|]
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|MULT
case|:
if|if
condition|(
name|index
condition|)
return|return
literal|0
return|;
name|index
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|scale_rtx
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSPEC
case|:
if|if
condition|(
name|XINT
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPEC_TP
operator|&&
name|TARGET_TLS_DIRECT_SEG_REFS
operator|&&
name|seg
operator|==
name|SEG_DEFAULT
condition|)
name|seg
operator|=
name|TARGET_64BIT
condition|?
name|SEG_FS
else|:
name|SEG_GS
expr_stmt|;
else|else
return|return
literal|0
return|;
break|break;
case|case
name|REG
case|:
case|case
name|SUBREG
case|:
if|if
condition|(
operator|!
name|base
condition|)
name|base
operator|=
name|op
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|index
condition|)
name|index
operator|=
name|op
expr_stmt|;
else|else
return|return
literal|0
return|;
break|break;
case|case
name|CONST
case|:
case|case
name|CONST_INT
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
if|if
condition|(
name|disp
condition|)
return|return
literal|0
return|;
name|disp
operator|=
name|op
expr_stmt|;
break|break;
default|default:
return|return
literal|0
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|MULT
condition|)
block|{
name|index
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* index*scale */
name|scale_rtx
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|ASHIFT
condition|)
block|{
name|rtx
name|tmp
decl_stmt|;
comment|/* We're called for lea too, which implements ashift on occasion.  */
name|index
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
literal|0
return|;
name|scale
operator|=
name|INTVAL
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|scale
operator|>
literal|3
condition|)
return|return
literal|0
return|;
name|scale
operator|=
literal|1
operator|<<
name|scale
expr_stmt|;
name|retval
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|disp
operator|=
name|addr
expr_stmt|;
comment|/* displacement */
comment|/* Extract the integral value of scale.  */
if|if
condition|(
name|scale_rtx
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|scale_rtx
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
literal|0
return|;
name|scale
operator|=
name|INTVAL
argument_list|(
name|scale_rtx
argument_list|)
expr_stmt|;
block|}
name|base_reg
operator|=
name|base
operator|&&
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|SUBREG
condition|?
name|SUBREG_REG
argument_list|(
name|base
argument_list|)
else|:
name|base
expr_stmt|;
name|index_reg
operator|=
name|index
operator|&&
name|GET_CODE
argument_list|(
name|index
argument_list|)
operator|==
name|SUBREG
condition|?
name|SUBREG_REG
argument_list|(
name|index
argument_list|)
else|:
name|index
expr_stmt|;
comment|/* Allow arg pointer and stack pointer as index if there is not scaling.  */
if|if
condition|(
name|base_reg
operator|&&
name|index_reg
operator|&&
name|scale
operator|==
literal|1
operator|&&
operator|(
name|index_reg
operator|==
name|arg_pointer_rtx
operator|||
name|index_reg
operator|==
name|frame_pointer_rtx
operator|||
operator|(
name|REG_P
argument_list|(
name|index_reg
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|index_reg
argument_list|)
operator|==
name|STACK_POINTER_REGNUM
operator|)
operator|)
condition|)
block|{
name|rtx
name|tmp
decl_stmt|;
name|tmp
operator|=
name|base
operator|,
name|base
operator|=
name|index
operator|,
name|index
operator|=
name|tmp
expr_stmt|;
name|tmp
operator|=
name|base_reg
operator|,
name|base_reg
operator|=
name|index_reg
operator|,
name|index_reg
operator|=
name|tmp
expr_stmt|;
block|}
comment|/* Special case: %ebp cannot be encoded as a base without a displacement.  */
if|if
condition|(
operator|(
name|base_reg
operator|==
name|hard_frame_pointer_rtx
operator|||
name|base_reg
operator|==
name|frame_pointer_rtx
operator|||
name|base_reg
operator|==
name|arg_pointer_rtx
operator|)
operator|&&
operator|!
name|disp
condition|)
name|disp
operator|=
name|const0_rtx
expr_stmt|;
comment|/* Special case: on K6, [%esi] makes the instruction vector decoded.      Avoid this by transforming to [%esi+0].  */
if|if
condition|(
name|ix86_tune
operator|==
name|PROCESSOR_K6
operator|&&
operator|!
name|optimize_size
operator|&&
name|base_reg
operator|&&
operator|!
name|index_reg
operator|&&
operator|!
name|disp
operator|&&
name|REG_P
argument_list|(
name|base_reg
argument_list|)
operator|&&
name|REGNO_REG_CLASS
argument_list|(
name|REGNO
argument_list|(
name|base_reg
argument_list|)
argument_list|)
operator|==
name|SIREG
condition|)
name|disp
operator|=
name|const0_rtx
expr_stmt|;
comment|/* Special case: encode reg+reg instead of reg*2.  */
if|if
condition|(
operator|!
name|base
operator|&&
name|index
operator|&&
name|scale
operator|&&
name|scale
operator|==
literal|2
condition|)
name|base
operator|=
name|index
operator|,
name|base_reg
operator|=
name|index_reg
operator|,
name|scale
operator|=
literal|1
expr_stmt|;
comment|/* Special case: scaling cannot be encoded without base or displacement.  */
if|if
condition|(
operator|!
name|base
operator|&&
operator|!
name|disp
operator|&&
name|index
operator|&&
name|scale
operator|!=
literal|1
condition|)
name|disp
operator|=
name|const0_rtx
expr_stmt|;
name|out
operator|->
name|base
operator|=
name|base
expr_stmt|;
name|out
operator|->
name|index
operator|=
name|index
expr_stmt|;
name|out
operator|->
name|disp
operator|=
name|disp
expr_stmt|;
name|out
operator|->
name|scale
operator|=
name|scale
expr_stmt|;
name|out
operator|->
name|seg
operator|=
name|seg
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return cost of the memory address x.    For i386, it is better to use a complex address than let gcc copy    the address into a reg and make a new pseudo.  But not if the address    requires to two regs - that would mean more pseudos with longer    lifetimes.  */
end_comment

begin_function
specifier|static
name|int
name|ix86_address_cost
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|struct
name|ix86_address
name|parts
decl_stmt|;
name|int
name|cost
init|=
literal|1
decl_stmt|;
name|int
name|ok
init|=
name|ix86_decompose_address
argument_list|(
name|x
argument_list|,
operator|&
name|parts
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|ok
argument_list|)
expr_stmt|;
if|if
condition|(
name|parts
operator|.
name|base
operator|&&
name|GET_CODE
argument_list|(
name|parts
operator|.
name|base
argument_list|)
operator|==
name|SUBREG
condition|)
name|parts
operator|.
name|base
operator|=
name|SUBREG_REG
argument_list|(
name|parts
operator|.
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|parts
operator|.
name|index
operator|&&
name|GET_CODE
argument_list|(
name|parts
operator|.
name|index
argument_list|)
operator|==
name|SUBREG
condition|)
name|parts
operator|.
name|index
operator|=
name|SUBREG_REG
argument_list|(
name|parts
operator|.
name|index
argument_list|)
expr_stmt|;
comment|/* More complex memory references are better.  */
if|if
condition|(
name|parts
operator|.
name|disp
operator|&&
name|parts
operator|.
name|disp
operator|!=
name|const0_rtx
condition|)
name|cost
operator|--
expr_stmt|;
if|if
condition|(
name|parts
operator|.
name|seg
operator|!=
name|SEG_DEFAULT
condition|)
name|cost
operator|--
expr_stmt|;
comment|/* Attempt to minimize number of registers in the address.  */
if|if
condition|(
operator|(
name|parts
operator|.
name|base
operator|&&
operator|(
operator|!
name|REG_P
argument_list|(
name|parts
operator|.
name|base
argument_list|)
operator|||
name|REGNO
argument_list|(
name|parts
operator|.
name|base
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|)
operator|||
operator|(
name|parts
operator|.
name|index
operator|&&
operator|(
operator|!
name|REG_P
argument_list|(
name|parts
operator|.
name|index
argument_list|)
operator|||
name|REGNO
argument_list|(
name|parts
operator|.
name|index
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|)
condition|)
name|cost
operator|++
expr_stmt|;
if|if
condition|(
name|parts
operator|.
name|base
operator|&&
operator|(
operator|!
name|REG_P
argument_list|(
name|parts
operator|.
name|base
argument_list|)
operator|||
name|REGNO
argument_list|(
name|parts
operator|.
name|base
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|&&
name|parts
operator|.
name|index
operator|&&
operator|(
operator|!
name|REG_P
argument_list|(
name|parts
operator|.
name|index
argument_list|)
operator|||
name|REGNO
argument_list|(
name|parts
operator|.
name|index
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|&&
name|parts
operator|.
name|base
operator|!=
name|parts
operator|.
name|index
condition|)
name|cost
operator|++
expr_stmt|;
comment|/* AMD-K6 don't like addresses with ModR/M set to 00_xxx_100b,      since it's predecode logic can't detect the length of instructions      and it degenerates to vector decoded.  Increase cost of such      addresses here.  The penalty is minimally 2 cycles.  It may be worthwhile      to split such addresses or even refuse such addresses at all.       Following addressing modes are affected:       [base+scale*index]       [scale*index+disp]       [base+index]       The first and last case  may be avoidable by explicitly coding the zero in      memory address, but I don't have AMD-K6 machine handy to check this      theory.  */
if|if
condition|(
name|TARGET_K6
operator|&&
operator|(
operator|(
operator|!
name|parts
operator|.
name|disp
operator|&&
name|parts
operator|.
name|base
operator|&&
name|parts
operator|.
name|index
operator|&&
name|parts
operator|.
name|scale
operator|!=
literal|1
operator|)
operator|||
operator|(
name|parts
operator|.
name|disp
operator|&&
operator|!
name|parts
operator|.
name|base
operator|&&
name|parts
operator|.
name|index
operator|&&
name|parts
operator|.
name|scale
operator|!=
literal|1
operator|)
operator|||
operator|(
operator|!
name|parts
operator|.
name|disp
operator|&&
name|parts
operator|.
name|base
operator|&&
name|parts
operator|.
name|index
operator|&&
name|parts
operator|.
name|scale
operator|==
literal|1
operator|)
operator|)
condition|)
name|cost
operator|+=
literal|10
expr_stmt|;
return|return
name|cost
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If X is a machine specific address (i.e. a symbol or label being    referenced as a displacement from the GOT implemented using an    UNSPEC), then return the base term.  Otherwise return X.  */
end_comment

begin_function
name|rtx
name|ix86_find_base_term
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|rtx
name|term
decl_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST
condition|)
return|return
name|x
return|;
name|term
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|term
argument_list|)
operator|==
name|PLUS
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|term
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|term
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_DOUBLE
operator|)
condition|)
name|term
operator|=
name|XEXP
argument_list|(
name|term
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|term
argument_list|)
operator|!=
name|UNSPEC
operator|||
name|XINT
argument_list|(
name|term
argument_list|,
literal|1
argument_list|)
operator|!=
name|UNSPEC_GOTPCREL
condition|)
return|return
name|x
return|;
name|term
operator|=
name|XVECEXP
argument_list|(
name|term
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|term
argument_list|)
operator|!=
name|SYMBOL_REF
operator|&&
name|GET_CODE
argument_list|(
name|term
argument_list|)
operator|!=
name|LABEL_REF
condition|)
return|return
name|x
return|;
return|return
name|term
return|;
block|}
name|term
operator|=
name|ix86_delegitimize_address
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|term
argument_list|)
operator|!=
name|SYMBOL_REF
operator|&&
name|GET_CODE
argument_list|(
name|term
argument_list|)
operator|!=
name|LABEL_REF
condition|)
return|return
name|x
return|;
return|return
name|term
return|;
block|}
end_function

begin_comment
comment|/* Allow {LABEL | SYMBOL}_REF - SYMBOL_REF-FOR-PICBASE for Mach-O as    this is used for to form addresses to local data when -fPIC is in    use.  */
end_comment

begin_function
specifier|static
name|bool
name|darwin_local_data_pic
parameter_list|(
name|rtx
name|disp
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|==
name|MINUS
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
block|{
specifier|const
name|char
modifier|*
name|sym_name
init|=
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|sym_name
argument_list|,
literal|"<pic base>"
argument_list|)
condition|)
return|return
name|true
return|;
block|}
block|}
return|return
name|false
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Determine if a given RTX is a valid constant.  We already know this    satisfies CONSTANT_P.  */
end_comment

begin_function
name|bool
name|legitimate_constant_p
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|CONST
case|:
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
name|false
return|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_MACHO
operator|&&
name|darwin_local_data_pic
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* Only some unspecs are valid as "constants".  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|UNSPEC
condition|)
switch|switch
condition|(
name|XINT
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|)
block|{
case|case
name|UNSPEC_GOTOFF
case|:
return|return
name|TARGET_64BIT
return|;
case|case
name|UNSPEC_TPOFF
case|:
case|case
name|UNSPEC_NTPOFF
case|:
name|x
operator|=
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|SYMBOL_REF_TLS_MODEL
argument_list|(
name|x
argument_list|)
operator|==
name|TLS_MODEL_LOCAL_EXEC
operator|)
return|;
case|case
name|UNSPEC_DTPOFF
case|:
name|x
operator|=
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|SYMBOL_REF_TLS_MODEL
argument_list|(
name|x
argument_list|)
operator|==
name|TLS_MODEL_LOCAL_DYNAMIC
operator|)
return|;
default|default:
return|return
name|false
return|;
block|}
comment|/* We must have drilled down to a symbol.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LABEL_REF
condition|)
return|return
name|true
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|SYMBOL_REF
condition|)
return|return
name|false
return|;
comment|/* FALLTHRU */
case|case
name|SYMBOL_REF
case|:
comment|/* TLS symbols are never valid.  */
if|if
condition|(
name|SYMBOL_REF_TLS_MODEL
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
case|case
name|CONST_DOUBLE
case|:
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|TImode
operator|&&
name|x
operator|!=
name|CONST0_RTX
argument_list|(
name|TImode
argument_list|)
operator|&&
operator|!
name|TARGET_64BIT
condition|)
return|return
name|false
return|;
break|break;
case|case
name|CONST_VECTOR
case|:
if|if
condition|(
name|x
operator|==
name|CONST0_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
default|default:
break|break;
block|}
comment|/* Otherwise we handle everything else in the move patterns.  */
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Determine if it's legal to put X into the constant pool.  This    is not possible for the address of thread-local symbols, which    is checked above.  */
end_comment

begin_function
specifier|static
name|bool
name|ix86_cannot_force_const_mem
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
comment|/* We can always put integral constants and vectors in memory.  */
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST_VECTOR
case|:
return|return
name|false
return|;
default|default:
break|break;
block|}
return|return
operator|!
name|legitimate_constant_p
argument_list|(
name|x
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Determine if a given RTX is a valid constant address.  */
end_comment

begin_function
name|bool
name|constant_address_p
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
return|return
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
operator|&&
name|legitimate_address_p
argument_list|(
name|Pmode
argument_list|,
name|x
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Nonzero if the constant value X is a legitimate general operand    when generating PIC code.  It is given that flag_pic is on and    that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */
end_comment

begin_function
name|bool
name|legitimate_pic_operand_p
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|rtx
name|inner
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|CONST
case|:
name|inner
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|inner
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
name|inner
operator|=
name|XEXP
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Only some unspecs are valid as "constants".  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|UNSPEC
condition|)
switch|switch
condition|(
name|XINT
argument_list|(
name|inner
argument_list|,
literal|1
argument_list|)
condition|)
block|{
case|case
name|UNSPEC_GOTOFF
case|:
return|return
name|TARGET_64BIT
return|;
case|case
name|UNSPEC_TPOFF
case|:
name|x
operator|=
name|XVECEXP
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|SYMBOL_REF_TLS_MODEL
argument_list|(
name|x
argument_list|)
operator|==
name|TLS_MODEL_LOCAL_EXEC
operator|)
return|;
default|default:
return|return
name|false
return|;
block|}
comment|/* FALLTHRU */
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
return|return
name|legitimate_pic_address_disp_p
argument_list|(
name|x
argument_list|)
return|;
default|default:
return|return
name|true
return|;
block|}
block|}
end_function

begin_comment
comment|/* Determine if a given CONST RTX is a valid memory displacement    in PIC mode.  */
end_comment

begin_function
name|int
name|legitimate_pic_address_disp_p
parameter_list|(
name|rtx
name|disp
parameter_list|)
block|{
name|bool
name|saw_plus
decl_stmt|;
comment|/* In 64bit mode we can allow direct addresses of symbols and labels      when they are not dynamic symbols.  */
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
name|rtx
name|op0
init|=
name|disp
decl_stmt|,
name|op1
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
condition|)
block|{
case|case
name|LABEL_REF
case|:
return|return
name|true
return|;
case|case
name|CONST
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|PLUS
condition|)
break|break;
name|op0
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|>=
literal|16
operator|*
literal|1024
operator|*
literal|1024
operator|||
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|<
operator|-
literal|16
operator|*
literal|1024
operator|*
literal|1024
condition|)
break|break;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|LABEL_REF
condition|)
return|return
name|true
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|SYMBOL_REF
condition|)
break|break;
comment|/* FALLTHRU */
case|case
name|SYMBOL_REF
case|:
comment|/* TLS references should always be enclosed in UNSPEC.  */
if|if
condition|(
name|SYMBOL_REF_TLS_MODEL
argument_list|(
name|op0
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|SYMBOL_REF_FAR_ADDR_P
argument_list|(
name|op0
argument_list|)
operator|&&
name|SYMBOL_REF_LOCAL_P
argument_list|(
name|op0
argument_list|)
condition|)
return|return
name|true
return|;
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|!=
name|CONST
condition|)
return|return
literal|0
return|;
name|disp
operator|=
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
comment|/* We are unsafe to allow PLUS expressions.  This limit allowed distance          of GOT tables.  We should not need these anyway.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|!=
name|UNSPEC
operator|||
operator|(
name|XINT
argument_list|(
name|disp
argument_list|,
literal|1
argument_list|)
operator|!=
name|UNSPEC_GOTPCREL
operator|&&
name|XINT
argument_list|(
name|disp
argument_list|,
literal|1
argument_list|)
operator|!=
name|UNSPEC_GOTOFF
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|SYMBOL_REF
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|LABEL_REF
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
name|saw_plus
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|==
name|PLUS
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
literal|0
return|;
name|disp
operator|=
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|saw_plus
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_MACHO
operator|&&
name|darwin_local_data_pic
argument_list|(
name|disp
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|!=
name|UNSPEC
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|XINT
argument_list|(
name|disp
argument_list|,
literal|1
argument_list|)
condition|)
block|{
case|case
name|UNSPEC_GOT
case|:
if|if
condition|(
name|saw_plus
condition|)
return|return
name|false
return|;
return|return
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
return|;
case|case
name|UNSPEC_GOTOFF
case|:
comment|/* Refuse GOTOFF in 64bit mode since it is always 64bit when used. 	 While ABI specify also 32bit relocation but we don't produce it in 	 small PIC model at all.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|)
operator|&&
operator|!
name|TARGET_64BIT
condition|)
return|return
name|local_symbolic_operand
argument_list|(
name|XVECEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|)
return|;
return|return
name|false
return|;
case|case
name|UNSPEC_GOTTPOFF
case|:
case|case
name|UNSPEC_GOTNTPOFF
case|:
case|case
name|UNSPEC_INDNTPOFF
case|:
if|if
condition|(
name|saw_plus
condition|)
return|return
name|false
return|;
name|disp
operator|=
name|XVECEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|SYMBOL_REF_TLS_MODEL
argument_list|(
name|disp
argument_list|)
operator|==
name|TLS_MODEL_INITIAL_EXEC
operator|)
return|;
case|case
name|UNSPEC_NTPOFF
case|:
name|disp
operator|=
name|XVECEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|SYMBOL_REF_TLS_MODEL
argument_list|(
name|disp
argument_list|)
operator|==
name|TLS_MODEL_LOCAL_EXEC
operator|)
return|;
case|case
name|UNSPEC_DTPOFF
case|:
name|disp
operator|=
name|XVECEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|SYMBOL_REF_TLS_MODEL
argument_list|(
name|disp
argument_list|)
operator|==
name|TLS_MODEL_LOCAL_DYNAMIC
operator|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression that is a valid    memory address for an instruction.  The MODE argument is the machine mode    for the MEM expression that wants to use this address.     It only recognizes address in canonical form.  LEGITIMIZE_ADDRESS should    convert common non-canonical forms to canonical form so that they will    be recognized.  */
end_comment

begin_function
name|int
name|legitimate_address_p
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|addr
parameter_list|,
name|int
name|strict
parameter_list|)
block|{
name|struct
name|ix86_address
name|parts
decl_stmt|;
name|rtx
name|base
decl_stmt|,
name|index
decl_stmt|,
name|disp
decl_stmt|;
name|HOST_WIDE_INT
name|scale
decl_stmt|;
specifier|const
name|char
modifier|*
name|reason
init|=
name|NULL
decl_stmt|;
name|rtx
name|reason_rtx
init|=
name|NULL_RTX
decl_stmt|;
if|if
condition|(
name|TARGET_DEBUG_ADDR
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n======\nGO_IF_LEGITIMATE_ADDRESS, mode = %s, strict = %d\n"
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|mode
argument_list|)
argument_list|,
name|strict
argument_list|)
expr_stmt|;
name|debug_rtx
argument_list|(
name|addr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ix86_decompose_address
argument_list|(
name|addr
argument_list|,
operator|&
name|parts
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|reason
operator|=
literal|"decomposition failed"
expr_stmt|;
goto|goto
name|report_error
goto|;
block|}
name|base
operator|=
name|parts
operator|.
name|base
expr_stmt|;
name|index
operator|=
name|parts
operator|.
name|index
expr_stmt|;
name|disp
operator|=
name|parts
operator|.
name|disp
expr_stmt|;
name|scale
operator|=
name|parts
operator|.
name|scale
expr_stmt|;
comment|/* Validate base register.       Don't allow SUBREG's that span more than a word here.  It can lead to spill      failures when the base is one word out of a two word structure, which is      represented internally as a DImode int.  */
if|if
condition|(
name|base
condition|)
block|{
name|rtx
name|reg
decl_stmt|;
name|reason_rtx
operator|=
name|base
expr_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|base
argument_list|)
condition|)
name|reg
operator|=
name|base
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|SUBREG
operator|&&
name|REG_P
argument_list|(
name|SUBREG_REG
argument_list|(
name|base
argument_list|)
argument_list|)
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|base
argument_list|)
argument_list|)
argument_list|)
operator|<=
name|UNITS_PER_WORD
condition|)
name|reg
operator|=
name|SUBREG_REG
argument_list|(
name|base
argument_list|)
expr_stmt|;
else|else
block|{
name|reason
operator|=
literal|"base is not a register"
expr_stmt|;
goto|goto
name|report_error
goto|;
block|}
if|if
condition|(
name|GET_MODE
argument_list|(
name|base
argument_list|)
operator|!=
name|Pmode
condition|)
block|{
name|reason
operator|=
literal|"base is not in Pmode"
expr_stmt|;
goto|goto
name|report_error
goto|;
block|}
if|if
condition|(
operator|(
name|strict
operator|&&
operator|!
name|REG_OK_FOR_BASE_STRICT_P
argument_list|(
name|reg
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|strict
operator|&&
operator|!
name|REG_OK_FOR_BASE_NONSTRICT_P
argument_list|(
name|reg
argument_list|)
operator|)
condition|)
block|{
name|reason
operator|=
literal|"base is not valid"
expr_stmt|;
goto|goto
name|report_error
goto|;
block|}
block|}
comment|/* Validate index register.       Don't allow SUBREG's that span more than a word here -- same as above.  */
if|if
condition|(
name|index
condition|)
block|{
name|rtx
name|reg
decl_stmt|;
name|reason_rtx
operator|=
name|index
expr_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|index
argument_list|)
condition|)
name|reg
operator|=
name|index
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|index
argument_list|)
operator|==
name|SUBREG
operator|&&
name|REG_P
argument_list|(
name|SUBREG_REG
argument_list|(
name|index
argument_list|)
argument_list|)
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|index
argument_list|)
argument_list|)
argument_list|)
operator|<=
name|UNITS_PER_WORD
condition|)
name|reg
operator|=
name|SUBREG_REG
argument_list|(
name|index
argument_list|)
expr_stmt|;
else|else
block|{
name|reason
operator|=
literal|"index is not a register"
expr_stmt|;
goto|goto
name|report_error
goto|;
block|}
if|if
condition|(
name|GET_MODE
argument_list|(
name|index
argument_list|)
operator|!=
name|Pmode
condition|)
block|{
name|reason
operator|=
literal|"index is not in Pmode"
expr_stmt|;
goto|goto
name|report_error
goto|;
block|}
if|if
condition|(
operator|(
name|strict
operator|&&
operator|!
name|REG_OK_FOR_INDEX_STRICT_P
argument_list|(
name|reg
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|strict
operator|&&
operator|!
name|REG_OK_FOR_INDEX_NONSTRICT_P
argument_list|(
name|reg
argument_list|)
operator|)
condition|)
block|{
name|reason
operator|=
literal|"index is not valid"
expr_stmt|;
goto|goto
name|report_error
goto|;
block|}
block|}
comment|/* Validate scale factor.  */
if|if
condition|(
name|scale
operator|!=
literal|1
condition|)
block|{
name|reason_rtx
operator|=
name|GEN_INT
argument_list|(
name|scale
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|index
condition|)
block|{
name|reason
operator|=
literal|"scale without index"
expr_stmt|;
goto|goto
name|report_error
goto|;
block|}
if|if
condition|(
name|scale
operator|!=
literal|2
operator|&&
name|scale
operator|!=
literal|4
operator|&&
name|scale
operator|!=
literal|8
condition|)
block|{
name|reason
operator|=
literal|"scale is not a valid multiplier"
expr_stmt|;
goto|goto
name|report_error
goto|;
block|}
block|}
comment|/* Validate displacement.  */
if|if
condition|(
name|disp
condition|)
block|{
name|reason_rtx
operator|=
name|disp
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|UNSPEC
condition|)
switch|switch
condition|(
name|XINT
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
block|{
comment|/* Refuse GOTOFF and GOT in 64bit mode since it is always 64bit when 	     used.  While ABI specify also 32bit relocations, we don't produce 	     them at all and use IP relative instead.  */
case|case
name|UNSPEC_GOT
case|:
case|case
name|UNSPEC_GOTOFF
case|:
name|gcc_assert
argument_list|(
name|flag_pic
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TARGET_64BIT
condition|)
goto|goto
name|is_legitimate_pic
goto|;
name|reason
operator|=
literal|"64bit address unspec"
expr_stmt|;
goto|goto
name|report_error
goto|;
case|case
name|UNSPEC_GOTPCREL
case|:
name|gcc_assert
argument_list|(
name|flag_pic
argument_list|)
expr_stmt|;
goto|goto
name|is_legitimate_pic
goto|;
case|case
name|UNSPEC_GOTTPOFF
case|:
case|case
name|UNSPEC_GOTNTPOFF
case|:
case|case
name|UNSPEC_INDNTPOFF
case|:
case|case
name|UNSPEC_NTPOFF
case|:
case|case
name|UNSPEC_DTPOFF
case|:
break|break;
default|default:
name|reason
operator|=
literal|"invalid address unspec"
expr_stmt|;
goto|goto
name|report_error
goto|;
block|}
elseif|else
if|if
condition|(
name|SYMBOLIC_CONST
argument_list|(
name|disp
argument_list|)
operator|&&
operator|(
name|flag_pic
operator|||
operator|(
name|TARGET_MACHO
if|#
directive|if
name|TARGET_MACHO
operator|&&
name|MACHOPIC_INDIRECT
operator|&&
operator|!
name|machopic_operand_p
argument_list|(
name|disp
argument_list|)
endif|#
directive|endif
operator|)
operator|)
condition|)
block|{
name|is_legitimate_pic
label|:
if|if
condition|(
name|TARGET_64BIT
operator|&&
operator|(
name|index
operator|||
name|base
operator|)
condition|)
block|{
comment|/* foo@dtpoff(%rX) is ok.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|!=
name|CONST
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|UNSPEC
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|||
operator|(
name|XINT
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|!=
name|UNSPEC_DTPOFF
operator|&&
name|XINT
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|!=
name|UNSPEC_NTPOFF
operator|)
condition|)
block|{
name|reason
operator|=
literal|"non-constant pic memory reference"
expr_stmt|;
goto|goto
name|report_error
goto|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|legitimate_pic_address_disp_p
argument_list|(
name|disp
argument_list|)
condition|)
block|{
name|reason
operator|=
literal|"displacement is an invalid pic construct"
expr_stmt|;
goto|goto
name|report_error
goto|;
block|}
comment|/* This code used to verify that a symbolic pic displacement 	     includes the pic_offset_table_rtx register.  	     While this is good idea, unfortunately these constructs may 	     be created by "adds using lea" optimization for incorrect 	     code like:  	     int a; 	     int foo(int i) 	       { 	         return *(&a+i); 	       }  	     This code is nonsensical, but results in addressing 	     GOT table with pic_offset_table_rtx base.  We can't 	     just refuse it easily, since it gets matched by 	     "addsi3" pattern, that later gets split to lea in the 	     case output register differs from input.  While this 	     can be handled by separate addsi pattern for this case 	     that never results in lea, this seems to be easier and 	     correct fix for crash to disable this test.  */
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|!=
name|LABEL_REF
operator|&&
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|!=
name|CONST_INT
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|!=
name|CONST
operator|||
operator|!
name|legitimate_constant_p
argument_list|(
name|disp
argument_list|)
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|!=
name|SYMBOL_REF
operator|||
operator|!
name|legitimate_constant_p
argument_list|(
name|disp
argument_list|)
operator|)
condition|)
block|{
name|reason
operator|=
literal|"displacement is not constant"
expr_stmt|;
goto|goto
name|report_error
goto|;
block|}
elseif|else
if|if
condition|(
name|TARGET_64BIT
operator|&&
operator|!
name|x86_64_immediate_operand
argument_list|(
name|disp
argument_list|,
name|VOIDmode
argument_list|)
condition|)
block|{
name|reason
operator|=
literal|"displacement is out of range"
expr_stmt|;
goto|goto
name|report_error
goto|;
block|}
block|}
comment|/* Everything looks valid.  */
if|if
condition|(
name|TARGET_DEBUG_ADDR
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Success.\n"
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
name|report_error
label|:
if|if
condition|(
name|TARGET_DEBUG_ADDR
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: %s\n"
argument_list|,
name|reason
argument_list|)
expr_stmt|;
name|debug_rtx
argument_list|(
name|reason_rtx
argument_list|)
expr_stmt|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a unique alias set for the GOT.  */
end_comment

begin_function
specifier|static
name|HOST_WIDE_INT
name|ix86_GOT_alias_set
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|HOST_WIDE_INT
name|set
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|set
operator|==
operator|-
literal|1
condition|)
name|set
operator|=
name|new_alias_set
argument_list|()
expr_stmt|;
return|return
name|set
return|;
block|}
end_function

begin_comment
comment|/* Return a legitimate reference for ORIG (an address) using the    register REG.  If REG is 0, a new pseudo is generated.     There are two types of references that must be handled:     1. Global data references must load the address from the GOT, via       the PIC reg.  An insn is emitted to do this load, and the reg is       returned.     2. Static data references, constant pool addresses, and code labels       compute the address as an offset from the GOT, whose base is in       the PIC reg.  Static data objects have SYMBOL_FLAG_LOCAL set to       differentiate them from global data objects.  The returned       address is the PIC reg + an unspec constant.     GO_IF_LEGITIMATE_ADDRESS rejects symbolic references unless the PIC    reg also appears in the address.  */
end_comment

begin_function
specifier|static
name|rtx
name|legitimize_pic_address
parameter_list|(
name|rtx
name|orig
parameter_list|,
name|rtx
name|reg
parameter_list|)
block|{
name|rtx
name|addr
init|=
name|orig
decl_stmt|;
name|rtx
name|new
init|=
name|orig
decl_stmt|;
name|rtx
name|base
decl_stmt|;
if|#
directive|if
name|TARGET_MACHO
if|if
condition|(
name|TARGET_MACHO
operator|&&
operator|!
name|TARGET_64BIT
condition|)
block|{
if|if
condition|(
name|reg
operator|==
literal|0
condition|)
name|reg
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
comment|/* Use the generic Mach-O PIC machinery.  */
return|return
name|machopic_legitimize_pic_address
argument_list|(
name|orig
argument_list|,
name|GET_MODE
argument_list|(
name|orig
argument_list|)
argument_list|,
name|reg
argument_list|)
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|TARGET_64BIT
operator|&&
name|legitimate_pic_address_disp_p
argument_list|(
name|addr
argument_list|)
condition|)
name|new
operator|=
name|addr
expr_stmt|;
elseif|else
if|if
condition|(
name|TARGET_64BIT
operator|&&
name|ix86_cmodel
operator|!=
name|CM_SMALL_PIC
operator|&&
name|local_symbolic_operand
argument_list|(
name|addr
argument_list|,
name|Pmode
argument_list|)
condition|)
block|{
name|rtx
name|tmpreg
decl_stmt|;
comment|/* This symbol may be referenced via a displacement from the PIC 	 base address (@GOTOFF).  */
if|if
condition|(
name|reload_in_progress
condition|)
name|regs_ever_live
index|[
name|PIC_OFFSET_TABLE_REGNUM
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|CONST
condition|)
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|new
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|UNSPEC_GOTOFF
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|,
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|new
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|addr
argument_list|)
argument_list|,
name|UNSPEC_GOTOFF
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reg
condition|)
name|tmpreg
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
else|else
name|tmpreg
operator|=
name|reg
expr_stmt|;
name|emit_move_insn
argument_list|(
name|tmpreg
argument_list|,
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
literal|0
condition|)
block|{
name|new
operator|=
name|expand_simple_binop
argument_list|(
name|Pmode
argument_list|,
name|PLUS
argument_list|,
name|reg
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|tmpreg
argument_list|,
literal|1
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
name|new
operator|=
name|reg
expr_stmt|;
block|}
else|else
name|new
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|tmpreg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|TARGET_64BIT
operator|&&
name|local_symbolic_operand
argument_list|(
name|addr
argument_list|,
name|Pmode
argument_list|)
condition|)
block|{
comment|/* This symbol may be referenced via a displacement from the PIC 	 base address (@GOTOFF).  */
if|if
condition|(
name|reload_in_progress
condition|)
name|regs_ever_live
index|[
name|PIC_OFFSET_TABLE_REGNUM
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|CONST
condition|)
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|new
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|UNSPEC_GOTOFF
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|,
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|new
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|addr
argument_list|)
argument_list|,
name|UNSPEC_GOTOFF
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
literal|0
condition|)
block|{
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|reg
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|SYMBOL_REF_TLS_MODEL
argument_list|(
name|addr
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
name|new
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|addr
argument_list|)
argument_list|,
name|UNSPEC_GOTPCREL
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_const_mem
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|new
argument_list|,
name|ix86_GOT_alias_set
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|==
literal|0
condition|)
name|reg
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
comment|/* Use directly gen_movsi, otherwise the address is loaded 	     into register for CSE.  We don't want to CSE this addresses, 	     instead we CSE addresses from the GOT table, so skip this.  */
name|emit_insn
argument_list|(
name|gen_movsi
argument_list|(
name|reg
argument_list|,
name|new
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|=
name|reg
expr_stmt|;
block|}
else|else
block|{
comment|/* This symbol must be referenced via a load from the 	     Global Offset Table (@GOT).  */
if|if
condition|(
name|reload_in_progress
condition|)
name|regs_ever_live
index|[
name|PIC_OFFSET_TABLE_REGNUM
index|]
operator|=
literal|1
expr_stmt|;
name|new
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|addr
argument_list|)
argument_list|,
name|UNSPEC_GOT
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_const_mem
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|new
argument_list|,
name|ix86_GOT_alias_set
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|==
literal|0
condition|)
name|reg
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|reg
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|!
name|x86_64_immediate_operand
argument_list|(
name|addr
argument_list|,
name|VOIDmode
argument_list|)
condition|)
block|{
if|if
condition|(
name|reg
condition|)
block|{
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|new
operator|=
name|reg
expr_stmt|;
block|}
else|else
name|new
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|CONST
condition|)
block|{
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* We must match stuff we generate before.  Assume the only 	     unspecs that can get here are ours.  Not that we could do 	     anything with them anyway....  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|UNSPEC
operator|||
operator|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|UNSPEC
operator|)
condition|)
return|return
name|orig
return|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|rtx
name|op0
init|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
decl_stmt|,
name|op1
init|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* Check first to see if this is a constant offset from a @GOTOFF 	     symbol reference.  */
if|if
condition|(
name|local_symbolic_operand
argument_list|(
name|op0
argument_list|,
name|Pmode
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
operator|!
name|TARGET_64BIT
condition|)
block|{
if|if
condition|(
name|reload_in_progress
condition|)
name|regs_ever_live
index|[
name|PIC_OFFSET_TABLE_REGNUM
index|]
operator|=
literal|1
expr_stmt|;
name|new
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|op0
argument_list|)
argument_list|,
name|UNSPEC_GOTOFF
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
literal|0
condition|)
block|{
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|reg
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|<
operator|-
literal|16
operator|*
literal|1024
operator|*
literal|1024
operator|||
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|>=
literal|16
operator|*
literal|1024
operator|*
literal|1024
condition|)
block|{
if|if
condition|(
operator|!
name|x86_64_immediate_operand
argument_list|(
name|op1
argument_list|,
name|Pmode
argument_list|)
condition|)
name|op1
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|op0
argument_list|)
argument_list|,
name|op1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|base
operator|=
name|legitimize_pic_address
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|new
operator|=
name|legitimize_pic_address
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|,
name|base
operator|==
name|reg
condition|?
name|NULL_RTX
else|:
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|new
argument_list|)
operator|==
name|CONST_INT
condition|)
name|new
operator|=
name|plus_constant
argument_list|(
name|base
argument_list|,
name|INTVAL
argument_list|(
name|new
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|new
argument_list|)
operator|==
name|PLUS
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|new
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|base
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|base
argument_list|,
name|XEXP
argument_list|(
name|new
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|=
name|XEXP
argument_list|(
name|new
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|new
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|base
argument_list|,
name|new
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|new
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Load the thread pointer.  If TO_REG is true, force it into a register.  */
end_comment

begin_function
specifier|static
name|rtx
name|get_thread_pointer
parameter_list|(
name|int
name|to_reg
parameter_list|)
block|{
name|rtx
name|tp
decl_stmt|,
name|reg
decl_stmt|,
name|insn
decl_stmt|;
name|tp
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|const0_rtx
argument_list|)
argument_list|,
name|UNSPEC_TP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|to_reg
condition|)
return|return
name|tp
return|;
name|reg
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|insn
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|tp
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
return|return
name|reg
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of legitimize_address and ix86_expand_move.  FOR_MOV is    false if we expect this to be used for a memory address and true if    we expect to load the address into a register.  */
end_comment

begin_function
specifier|static
name|rtx
name|legitimize_tls_address
parameter_list|(
name|rtx
name|x
parameter_list|,
name|enum
name|tls_model
name|model
parameter_list|,
name|int
name|for_mov
parameter_list|)
block|{
name|rtx
name|dest
decl_stmt|,
name|base
decl_stmt|,
name|off
decl_stmt|,
name|pic
decl_stmt|,
name|tp
decl_stmt|;
name|int
name|type
decl_stmt|;
switch|switch
condition|(
name|model
condition|)
block|{
case|case
name|TLS_MODEL_GLOBAL_DYNAMIC
case|:
name|dest
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|tp
operator|=
name|TARGET_GNU2_TLS
condition|?
name|get_thread_pointer
argument_list|(
literal|1
argument_list|)
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
operator|&&
operator|!
name|TARGET_GNU2_TLS
condition|)
block|{
name|rtx
name|rax
init|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|0
argument_list|)
decl_stmt|,
name|insns
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|emit_call_insn
argument_list|(
name|gen_tls_global_dynamic_64
argument_list|(
name|rax
argument_list|,
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_libcall_block
argument_list|(
name|insns
argument_list|,
name|dest
argument_list|,
name|rax
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TARGET_64BIT
operator|&&
name|TARGET_GNU2_TLS
condition|)
name|emit_insn
argument_list|(
name|gen_tls_global_dynamic_64
argument_list|(
name|dest
argument_list|,
name|x
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_tls_global_dynamic_32
argument_list|(
name|dest
argument_list|,
name|x
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_GNU2_TLS
condition|)
block|{
name|dest
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|tp
argument_list|,
name|dest
argument_list|)
argument_list|)
expr_stmt|;
name|set_unique_reg_note
argument_list|(
name|get_last_insn
argument_list|()
argument_list|,
name|REG_EQUIV
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TLS_MODEL_LOCAL_DYNAMIC
case|:
name|base
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|tp
operator|=
name|TARGET_GNU2_TLS
condition|?
name|get_thread_pointer
argument_list|(
literal|1
argument_list|)
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
operator|&&
operator|!
name|TARGET_GNU2_TLS
condition|)
block|{
name|rtx
name|rax
init|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|0
argument_list|)
decl_stmt|,
name|insns
decl_stmt|,
name|note
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|emit_call_insn
argument_list|(
name|gen_tls_local_dynamic_base_64
argument_list|(
name|rax
argument_list|)
argument_list|)
expr_stmt|;
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|note
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|const0_rtx
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|note
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|ix86_tls_get_addr
argument_list|()
argument_list|,
name|note
argument_list|)
expr_stmt|;
name|emit_libcall_block
argument_list|(
name|insns
argument_list|,
name|base
argument_list|,
name|rax
argument_list|,
name|note
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TARGET_64BIT
operator|&&
name|TARGET_GNU2_TLS
condition|)
name|emit_insn
argument_list|(
name|gen_tls_local_dynamic_base_64
argument_list|(
name|base
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_tls_local_dynamic_base_32
argument_list|(
name|base
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_GNU2_TLS
condition|)
block|{
name|rtx
name|x
init|=
name|ix86_tls_module_base
argument_list|()
decl_stmt|;
name|set_unique_reg_note
argument_list|(
name|get_last_insn
argument_list|()
argument_list|,
name|REG_EQUIV
argument_list|,
name|gen_rtx_MINUS
argument_list|(
name|Pmode
argument_list|,
name|x
argument_list|,
name|tp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|off
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|x
argument_list|)
argument_list|,
name|UNSPEC_DTPOFF
argument_list|)
expr_stmt|;
name|off
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|off
argument_list|)
expr_stmt|;
name|dest
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|base
argument_list|,
name|off
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_GNU2_TLS
condition|)
block|{
name|dest
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|dest
argument_list|,
name|tp
argument_list|)
argument_list|)
expr_stmt|;
name|set_unique_reg_note
argument_list|(
name|get_last_insn
argument_list|()
argument_list|,
name|REG_EQUIV
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TLS_MODEL_INITIAL_EXEC
case|:
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
name|pic
operator|=
name|NULL
expr_stmt|;
name|type
operator|=
name|UNSPEC_GOTNTPOFF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flag_pic
condition|)
block|{
if|if
condition|(
name|reload_in_progress
condition|)
name|regs_ever_live
index|[
name|PIC_OFFSET_TABLE_REGNUM
index|]
operator|=
literal|1
expr_stmt|;
name|pic
operator|=
name|pic_offset_table_rtx
expr_stmt|;
name|type
operator|=
name|TARGET_ANY_GNU_TLS
condition|?
name|UNSPEC_GOTNTPOFF
else|:
name|UNSPEC_GOTTPOFF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|TARGET_ANY_GNU_TLS
condition|)
block|{
name|pic
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_set_got
argument_list|(
name|pic
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|UNSPEC_GOTTPOFF
expr_stmt|;
block|}
else|else
block|{
name|pic
operator|=
name|NULL
expr_stmt|;
name|type
operator|=
name|UNSPEC_INDNTPOFF
expr_stmt|;
block|}
name|off
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|x
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|off
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|off
argument_list|)
expr_stmt|;
if|if
condition|(
name|pic
condition|)
name|off
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|pic
argument_list|,
name|off
argument_list|)
expr_stmt|;
name|off
operator|=
name|gen_const_mem
argument_list|(
name|Pmode
argument_list|,
name|off
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|off
argument_list|,
name|ix86_GOT_alias_set
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
operator|||
name|TARGET_ANY_GNU_TLS
condition|)
block|{
name|base
operator|=
name|get_thread_pointer
argument_list|(
name|for_mov
operator|||
operator|!
name|TARGET_TLS_DIRECT_SEG_REFS
argument_list|)
expr_stmt|;
name|off
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|off
argument_list|)
expr_stmt|;
return|return
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|base
argument_list|,
name|off
argument_list|)
return|;
block|}
else|else
block|{
name|base
operator|=
name|get_thread_pointer
argument_list|(
name|true
argument_list|)
expr_stmt|;
name|dest
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_subsi3
argument_list|(
name|dest
argument_list|,
name|base
argument_list|,
name|off
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TLS_MODEL_LOCAL_EXEC
case|:
name|off
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|x
argument_list|)
argument_list|,
operator|(
name|TARGET_64BIT
operator|||
name|TARGET_ANY_GNU_TLS
operator|)
condition|?
name|UNSPEC_NTPOFF
else|:
name|UNSPEC_TPOFF
argument_list|)
expr_stmt|;
name|off
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|off
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
operator|||
name|TARGET_ANY_GNU_TLS
condition|)
block|{
name|base
operator|=
name|get_thread_pointer
argument_list|(
name|for_mov
operator|||
operator|!
name|TARGET_TLS_DIRECT_SEG_REFS
argument_list|)
expr_stmt|;
return|return
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|base
argument_list|,
name|off
argument_list|)
return|;
block|}
else|else
block|{
name|base
operator|=
name|get_thread_pointer
argument_list|(
name|true
argument_list|)
expr_stmt|;
name|dest
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_subsi3
argument_list|(
name|dest
argument_list|,
name|base
argument_list|,
name|off
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
return|return
name|dest
return|;
block|}
end_function

begin_comment
comment|/* Try machine-dependent ways of modifying an illegitimate address    to be legitimate.  If we find one, return the new, valid address.    This macro is used in only one place: `memory_address' in explow.c.     OLDX is the address as it was before break_out_memory_refs was called.    In some cases it is useful to look at this to decide what needs to be done.     MODE and WIN are passed so that this macro can use    GO_IF_LEGITIMATE_ADDRESS.     It is always safe for this macro to do nothing.  It exists to recognize    opportunities to optimize the output.     For the 80386, we handle X+REG by loading X into a register R and    using R+REG.  R will go in a general reg and indexing will be used.    However, if REG is a broken-out memory address or multiplication,    nothing needs to be done because REG can certainly go in a general reg.     When -fpic is used, special handling is needed for symbolic references.    See comments by legitimize_pic_address in i386.c for details.  */
end_comment

begin_function
name|rtx
name|legitimize_address
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|oldx
name|ATTRIBUTE_UNUSED
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|int
name|changed
init|=
literal|0
decl_stmt|;
name|unsigned
name|log
decl_stmt|;
if|if
condition|(
name|TARGET_DEBUG_ADDR
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n==========\nLEGITIMIZE_ADDRESS, mode = %s\n"
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
name|debug_rtx
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
name|log
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
condition|?
name|SYMBOL_REF_TLS_MODEL
argument_list|(
name|x
argument_list|)
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|log
condition|)
return|return
name|legitimize_tls_address
argument_list|(
name|x
argument_list|,
name|log
argument_list|,
name|false
argument_list|)
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
operator|(
name|log
operator|=
name|SYMBOL_REF_TLS_MODEL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|rtx
name|t
init|=
name|legitimize_tls_address
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|log
argument_list|,
name|false
argument_list|)
decl_stmt|;
return|return
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|t
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|flag_pic
operator|&&
name|SYMBOLIC_CONST
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|legitimize_pic_address
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
return|;
comment|/* Canonicalize shifts by 0, 1, 2, 3 into multiply */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|ASHIFT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
literal|4
condition|)
block|{
name|changed
operator|=
literal|1
expr_stmt|;
name|log
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|gen_rtx_MULT
argument_list|(
name|Pmode
argument_list|,
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
literal|1
operator|<<
name|log
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
condition|)
block|{
comment|/* Canonicalize shifts by 0, 1, 2, 3 into multiply.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ASHIFT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
literal|4
condition|)
block|{
name|changed
operator|=
literal|1
expr_stmt|;
name|log
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|gen_rtx_MULT
argument_list|(
name|Pmode
argument_list|,
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
literal|1
operator|<<
name|log
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|ASHIFT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
literal|4
condition|)
block|{
name|changed
operator|=
literal|1
expr_stmt|;
name|log
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|=
name|gen_rtx_MULT
argument_list|(
name|Pmode
argument_list|,
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
literal|1
operator|<<
name|log
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Put multiply first if it isn't already.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|MULT
condition|)
block|{
name|rtx
name|tmp
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|=
name|tmp
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Canonicalize (plus (mult (reg) (const)) (plus (reg) (const))) 	 into (plus (plus (mult (reg) (const)) (reg)) (const)).  This can be 	 created by virtual register instantiation, register elimination, and 	 similar optimizations.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MULT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|changed
operator|=
literal|1
expr_stmt|;
name|x
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Canonicalize 	 (plus (plus (mult (reg) (const)) (plus (reg) (const))) const) 	 into (plus (plus (mult (reg) (const)) (reg)) (const)).  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MULT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|constant
decl_stmt|;
name|rtx
name|other
init|=
name|NULL_RTX
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|constant
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|other
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|constant
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|other
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|constant
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|constant
condition|)
block|{
name|changed
operator|=
literal|1
expr_stmt|;
name|x
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|plus_constant
argument_list|(
name|other
argument_list|,
name|INTVAL
argument_list|(
name|constant
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|changed
operator|&&
name|legitimate_address_p
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
name|FALSE
argument_list|)
condition|)
return|return
name|x
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MULT
condition|)
block|{
name|changed
operator|=
literal|1
expr_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|MULT
condition|)
block|{
name|changed
operator|=
literal|1
expr_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|=
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|changed
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
return|return
name|x
return|;
if|if
condition|(
name|flag_pic
operator|&&
name|SYMBOLIC_CONST
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|changed
operator|=
literal|1
expr_stmt|;
name|x
operator|=
name|legitimize_pic_address
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|changed
operator|&&
name|legitimate_address_p
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
name|FALSE
argument_list|)
condition|)
return|return
name|x
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|rtx
name|temp
init|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
name|rtx
name|val
init|=
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|temp
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|!=
name|temp
condition|)
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|=
name|temp
expr_stmt|;
return|return
name|x
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|rtx
name|temp
init|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
name|rtx
name|val
init|=
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|temp
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|!=
name|temp
condition|)
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|temp
expr_stmt|;
return|return
name|x
return|;
block|}
block|}
return|return
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print an integer constant expression in assembler syntax.  Addition    and subtraction are the only arithmetic that may appear in these    expressions.  FILE is the stdio stream to write to, X is the rtx, and    CODE is the operand print code from the output string.  */
end_comment

begin_function
specifier|static
name|void
name|output_pic_addr_const
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|rtx
name|x
parameter_list|,
name|int
name|code
parameter_list|)
block|{
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|PC
case|:
name|gcc_assert
argument_list|(
name|flag_pic
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'.'
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYMBOL_REF
case|:
if|if
condition|(
operator|!
name|TARGET_MACHO
operator|||
name|TARGET_64BIT
condition|)
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
else|else
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* Mark the decl as referenced so that cgraph will output the function.  */
if|if
condition|(
name|SYMBOL_REF_DECL
argument_list|(
name|x
argument_list|)
condition|)
name|mark_decl_referenced
argument_list|(
name|SYMBOL_REF_DECL
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|TARGET_MACHO
if|if
condition|(
name|MACHOPIC_INDIRECT
operator|&&
name|machopic_classify_symbol
argument_list|(
name|x
argument_list|)
operator|==
name|MACHOPIC_UNDEFINED_FUNCTION
condition|)
name|name
operator|=
name|machopic_indirection_name
argument_list|(
name|x
argument_list|,
comment|/*stub_p=*/
name|true
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|assemble_name
argument_list|(
name|file
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TARGET_MACHO
operator|&&
name|code
operator|==
literal|'P'
operator|&&
operator|!
name|SYMBOL_REF_LOCAL_P
argument_list|(
name|x
argument_list|)
condition|)
name|fputs
argument_list|(
literal|"@PLT"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|LABEL_REF
case|:
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* FALLTHRU */
case|case
name|CODE_LABEL
case|:
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|asm_out_file
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST_INT
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST
case|:
comment|/* This used to output parentheses around the expression, 	 but that does not work on the 386 (either ATT or BSD assembler).  */
name|output_pic_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|code
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST_DOUBLE
case|:
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|VOIDmode
condition|)
block|{
comment|/* We can use %d if the number is<32 bits and positive.  */
if|if
condition|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
operator|||
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0x%lx%08lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* We can't handle floating point constants; 	   PRINT_OPERAND must handle them.  */
name|output_operand_lossage
argument_list|(
literal|"floating constant misused"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PLUS
case|:
comment|/* Some assemblers need integer constants to appear first.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|output_pic_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'+'
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|output_pic_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|code
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
argument_list|)
expr_stmt|;
name|output_pic_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'+'
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|output_pic_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|code
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|MINUS
case|:
if|if
condition|(
operator|!
name|TARGET_MACHO
condition|)
name|putc
argument_list|(
name|ASSEMBLER_DIALECT
operator|==
name|ASM_INTEL
condition|?
literal|'('
else|:
literal|'['
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|output_pic_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'-'
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|output_pic_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TARGET_MACHO
condition|)
name|putc
argument_list|(
name|ASSEMBLER_DIALECT
operator|==
name|ASM_INTEL
condition|?
literal|')'
else|:
literal|']'
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSPEC
case|:
name|gcc_assert
argument_list|(
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
literal|1
argument_list|)
expr_stmt|;
name|output_pic_addr_const
argument_list|(
name|file
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|code
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|XINT
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|)
block|{
case|case
name|UNSPEC_GOT
case|:
name|fputs
argument_list|(
literal|"@GOT"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSPEC_GOTOFF
case|:
name|fputs
argument_list|(
literal|"@GOTOFF"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSPEC_GOTPCREL
case|:
name|fputs
argument_list|(
literal|"@GOTPCREL(%rip)"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSPEC_GOTTPOFF
case|:
comment|/* FIXME: This might be @TPOFF in Sun ld too.  */
name|fputs
argument_list|(
literal|"@GOTTPOFF"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSPEC_TPOFF
case|:
name|fputs
argument_list|(
literal|"@TPOFF"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSPEC_NTPOFF
case|:
if|if
condition|(
name|TARGET_64BIT
condition|)
name|fputs
argument_list|(
literal|"@TPOFF"
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
literal|"@NTPOFF"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSPEC_DTPOFF
case|:
name|fputs
argument_list|(
literal|"@DTPOFF"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSPEC_GOTNTPOFF
case|:
if|if
condition|(
name|TARGET_64BIT
condition|)
name|fputs
argument_list|(
literal|"@GOTTPOFF(%rip)"
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
literal|"@GOTNTPOFF"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSPEC_INDNTPOFF
case|:
name|fputs
argument_list|(
literal|"@INDNTPOFF"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
default|default:
name|output_operand_lossage
argument_list|(
literal|"invalid UNSPEC as operand"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|output_operand_lossage
argument_list|(
literal|"invalid expression as operand"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This is called from dwarf2out.c via TARGET_ASM_OUTPUT_DWARF_DTPREL.    We need to emit DTP-relative relocations.  */
end_comment

begin_function
specifier|static
name|void
name|i386_output_dwarf_dtprel
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|int
name|size
parameter_list|,
name|rtx
name|x
parameter_list|)
block|{
name|fputs
argument_list|(
name|ASM_LONG
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"@DTPOFF"
argument_list|,
name|file
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|4
case|:
break|break;
case|case
literal|8
case|:
name|fputs
argument_list|(
literal|", 0"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* In the name of slightly smaller debug output, and to cater to    general assembler lossage, recognize PIC+GOTOFF and turn it back    into a direct symbol reference.     On Darwin, this is necessary to avoid a crash, because Darwin    has a different PIC label for each routine but the DWARF debugging    information is not associated with any particular routine, so it's    necessary to remove references to the PIC label from RTL stored by    the DWARF output code.  */
end_comment

begin_function
specifier|static
name|rtx
name|ix86_delegitimize_address
parameter_list|(
name|rtx
name|orig_x
parameter_list|)
block|{
name|rtx
name|x
init|=
name|orig_x
decl_stmt|;
comment|/* reg_addend is NULL or a multiple of some register.  */
name|rtx
name|reg_addend
init|=
name|NULL_RTX
decl_stmt|;
comment|/* const_addend is NULL or a const_int.  */
name|rtx
name|const_addend
init|=
name|NULL_RTX
decl_stmt|;
comment|/* This is the result, or NULL.  */
name|rtx
name|result
init|=
name|NULL_RTX
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|UNSPEC
operator|||
name|XINT
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|!=
name|UNSPEC_GOTPCREL
operator|||
name|GET_CODE
argument_list|(
name|orig_x
argument_list|)
operator|!=
name|MEM
condition|)
return|return
name|orig_x
return|;
return|return
name|XVECEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST
condition|)
return|return
name|orig_x
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PIC_OFFSET_TABLE_REGNUM
condition|)
comment|/* %ebx + GOT/GOTOFF */
empty_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|)
block|{
comment|/* %ebx + %reg * scale + GOT/GOTOFF */
name|reg_addend
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|reg_addend
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|reg_addend
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PIC_OFFSET_TABLE_REGNUM
condition|)
name|reg_addend
operator|=
name|XEXP
argument_list|(
name|reg_addend
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|reg_addend
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|reg_addend
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|PIC_OFFSET_TABLE_REGNUM
condition|)
name|reg_addend
operator|=
name|XEXP
argument_list|(
name|reg_addend
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
return|return
name|orig_x
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg_addend
argument_list|)
operator|!=
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|reg_addend
argument_list|)
operator|!=
name|MULT
operator|&&
name|GET_CODE
argument_list|(
name|reg_addend
argument_list|)
operator|!=
name|ASHIFT
condition|)
return|return
name|orig_x
return|;
block|}
else|else
return|return
name|orig_x
return|;
name|x
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|const_addend
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|UNSPEC
operator|&&
operator|(
operator|(
name|XINT
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPEC_GOT
operator|&&
name|GET_CODE
argument_list|(
name|orig_x
argument_list|)
operator|==
name|MEM
operator|)
operator|||
operator|(
name|XINT
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPEC_GOTOFF
operator|&&
name|GET_CODE
argument_list|(
name|orig_x
argument_list|)
operator|!=
name|MEM
operator|)
operator|)
condition|)
name|result
operator|=
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_MACHO
operator|&&
name|darwin_local_data_pic
argument_list|(
name|x
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|orig_x
argument_list|)
operator|!=
name|MEM
condition|)
name|result
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
return|return
name|orig_x
return|;
if|if
condition|(
name|const_addend
condition|)
name|result
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|result
argument_list|,
name|const_addend
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_addend
condition|)
name|result
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|reg_addend
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|put_condition_code
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|int
name|reverse
parameter_list|,
name|int
name|fp
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|suffix
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|CCFPmode
operator|||
name|mode
operator|==
name|CCFPUmode
condition|)
block|{
name|enum
name|rtx_code
name|second_code
decl_stmt|,
name|bypass_code
decl_stmt|;
name|ix86_fp_comparison_codes
argument_list|(
name|code
argument_list|,
operator|&
name|bypass_code
argument_list|,
operator|&
name|code
argument_list|,
operator|&
name|second_code
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|bypass_code
operator|==
name|UNKNOWN
operator|&&
name|second_code
operator|==
name|UNKNOWN
argument_list|)
expr_stmt|;
name|code
operator|=
name|ix86_fp_compare_code_to_integer
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|mode
operator|=
name|CCmode
expr_stmt|;
block|}
if|if
condition|(
name|reverse
condition|)
name|code
operator|=
name|reverse_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EQ
case|:
name|suffix
operator|=
literal|"e"
expr_stmt|;
break|break;
case|case
name|NE
case|:
name|suffix
operator|=
literal|"ne"
expr_stmt|;
break|break;
case|case
name|GT
case|:
name|gcc_assert
argument_list|(
name|mode
operator|==
name|CCmode
operator|||
name|mode
operator|==
name|CCNOmode
operator|||
name|mode
operator|==
name|CCGCmode
argument_list|)
expr_stmt|;
name|suffix
operator|=
literal|"g"
expr_stmt|;
break|break;
case|case
name|GTU
case|:
comment|/* ??? Use "nbe" instead of "a" for fcmov lossage on some assemblers. 	 Those same assemblers have the same but opposite lossage on cmov.  */
name|gcc_assert
argument_list|(
name|mode
operator|==
name|CCmode
argument_list|)
expr_stmt|;
name|suffix
operator|=
name|fp
condition|?
literal|"nbe"
else|:
literal|"a"
expr_stmt|;
break|break;
case|case
name|LT
case|:
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|CCNOmode
case|:
case|case
name|CCGOCmode
case|:
name|suffix
operator|=
literal|"s"
expr_stmt|;
break|break;
case|case
name|CCmode
case|:
case|case
name|CCGCmode
case|:
name|suffix
operator|=
literal|"l"
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|LTU
case|:
name|gcc_assert
argument_list|(
name|mode
operator|==
name|CCmode
argument_list|)
expr_stmt|;
name|suffix
operator|=
literal|"b"
expr_stmt|;
break|break;
case|case
name|GE
case|:
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|CCNOmode
case|:
case|case
name|CCGOCmode
case|:
name|suffix
operator|=
literal|"ns"
expr_stmt|;
break|break;
case|case
name|CCmode
case|:
case|case
name|CCGCmode
case|:
name|suffix
operator|=
literal|"ge"
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|GEU
case|:
comment|/* ??? As above.  */
name|gcc_assert
argument_list|(
name|mode
operator|==
name|CCmode
argument_list|)
expr_stmt|;
name|suffix
operator|=
name|fp
condition|?
literal|"nb"
else|:
literal|"ae"
expr_stmt|;
break|break;
case|case
name|LE
case|:
name|gcc_assert
argument_list|(
name|mode
operator|==
name|CCmode
operator|||
name|mode
operator|==
name|CCGCmode
operator|||
name|mode
operator|==
name|CCNOmode
argument_list|)
expr_stmt|;
name|suffix
operator|=
literal|"le"
expr_stmt|;
break|break;
case|case
name|LEU
case|:
name|gcc_assert
argument_list|(
name|mode
operator|==
name|CCmode
argument_list|)
expr_stmt|;
name|suffix
operator|=
literal|"be"
expr_stmt|;
break|break;
case|case
name|UNORDERED
case|:
name|suffix
operator|=
name|fp
condition|?
literal|"u"
else|:
literal|"p"
expr_stmt|;
break|break;
case|case
name|ORDERED
case|:
name|suffix
operator|=
name|fp
condition|?
literal|"nu"
else|:
literal|"np"
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|fputs
argument_list|(
name|suffix
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print the name of register X to FILE based on its machine mode and number.    If CODE is 'w', pretend the mode is HImode.    If CODE is 'b', pretend the mode is QImode.    If CODE is 'k', pretend the mode is SImode.    If CODE is 'q', pretend the mode is DImode.    If CODE is 'h', pretend the reg is the 'high' byte register.    If CODE is 'y', print "st(0)" instead of "st", if the reg is stack op.  */
end_comment

begin_function
name|void
name|print_reg
parameter_list|(
name|rtx
name|x
parameter_list|,
name|int
name|code
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|!=
name|ARG_POINTER_REGNUM
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|!=
name|FRAME_POINTER_REGNUM
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|!=
name|FLAGS_REG
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|!=
name|FPSR_REG
argument_list|)
expr_stmt|;
if|if
condition|(
name|ASSEMBLER_DIALECT
operator|==
name|ASM_ATT
operator|||
name|USER_LABEL_PREFIX
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|putc
argument_list|(
literal|'%'
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
literal|'w'
operator|||
name|MMX_REG_P
argument_list|(
name|x
argument_list|)
condition|)
name|code
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
literal|'b'
condition|)
name|code
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
literal|'k'
condition|)
name|code
operator|=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
literal|'q'
condition|)
name|code
operator|=
literal|8
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
literal|'y'
condition|)
name|code
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
literal|'h'
condition|)
name|code
operator|=
literal|0
expr_stmt|;
else|else
name|code
operator|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Irritatingly, AMD extended registers use different naming convention      from the normal registers.  */
if|if
condition|(
name|REX_INT_REG_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|gcc_assert
argument_list|(
name|TARGET_64BIT
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
literal|0
case|:
name|error
argument_list|(
literal|"extended registers have no high halves"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"r%ib"
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
operator|-
name|FIRST_REX_INT_REG
operator|+
literal|8
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"r%iw"
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
operator|-
name|FIRST_REX_INT_REG
operator|+
literal|8
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"r%id"
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
operator|-
name|FIRST_REX_INT_REG
operator|+
literal|8
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"r%i"
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
operator|-
name|FIRST_REX_INT_REG
operator|+
literal|8
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"unsupported operand size for extended register"
argument_list|)
expr_stmt|;
break|break;
block|}
return|return;
block|}
switch|switch
condition|(
name|code
condition|)
block|{
case|case
literal|3
case|:
if|if
condition|(
name|STACK_TOP_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|fputs
argument_list|(
literal|"st(0)"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* FALLTHRU */
case|case
literal|8
case|:
case|case
literal|4
case|:
case|case
literal|12
case|:
if|if
condition|(
operator|!
name|ANY_FP_REG_P
argument_list|(
name|x
argument_list|)
condition|)
name|putc
argument_list|(
name|code
operator|==
literal|8
operator|&&
name|TARGET_64BIT
condition|?
literal|'r'
else|:
literal|'e'
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* FALLTHRU */
case|case
literal|16
case|:
case|case
literal|2
case|:
name|normal
label|:
name|fputs
argument_list|(
name|hi_reg_name
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|>=
name|ARRAY_SIZE
argument_list|(
name|qi_reg_name
argument_list|)
condition|)
goto|goto
name|normal
goto|;
name|fputs
argument_list|(
name|qi_reg_name
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|>=
name|ARRAY_SIZE
argument_list|(
name|qi_high_reg_name
argument_list|)
condition|)
goto|goto
name|normal
goto|;
name|fputs
argument_list|(
name|qi_high_reg_name
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Locate some local-dynamic symbol still in use by this function    so that we can print its name in some tls_local_dynamic_base    pattern.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_some_local_dynamic_name
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
name|cfun
operator|->
name|machine
operator|->
name|some_ld_name
condition|)
return|return
name|cfun
operator|->
name|machine
operator|->
name|some_ld_name
return|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|for_each_rtx
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|get_some_local_dynamic_name_1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|cfun
operator|->
name|machine
operator|->
name|some_ld_name
return|;
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_some_local_dynamic_name_1
parameter_list|(
name|rtx
modifier|*
name|px
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|rtx
name|x
init|=
operator|*
name|px
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|SYMBOL_REF_TLS_MODEL
argument_list|(
name|x
argument_list|)
operator|==
name|TLS_MODEL_LOCAL_DYNAMIC
condition|)
block|{
name|cfun
operator|->
name|machine
operator|->
name|some_ld_name
operator|=
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Meaning of CODE:    L,W,B,Q,S,T -- print the opcode suffix for specified size of operand.    C -- print opcode suffix for set/cmov insn.    c -- like C, but print reversed condition    F,f -- likewise, but for floating-point.    O -- if HAVE_AS_IX86_CMOV_SUN_SYNTAX, expand to "w.", "l." or "q.",         otherwise nothing    R -- print the prefix for register names.    z -- print the opcode suffix for the size of the current operand.    * -- print a star (in certain assembler syntax)    A -- print an absolute memory reference.    w -- print the operand as if it's a "word" (HImode) even if it isn't.    s -- print a shift double count, followed by the assemblers argument 	delimiter.    b -- print the QImode name of the register for the indicated operand. 	%b0 would print %al if operands[0] is reg 0.    w --  likewise, print the HImode name of the register.    k --  likewise, print the SImode name of the register.    q --  likewise, print the DImode name of the register.    h -- print the QImode name for a "high" register, either ah, bh, ch or dh.    y -- print "st(0)" instead of "st" as a register.    D -- print condition for SSE cmp instruction.    P -- if PIC, print an @PLT suffix.    X -- don't print any sort of PIC '@' suffix for a symbol.& -- print some in-use local-dynamic symbol name.    H -- print a memory address offset by 8; used for sse high-parts  */
end_comment

begin_function
name|void
name|print_operand
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|rtx
name|x
parameter_list|,
name|int
name|code
parameter_list|)
block|{
if|if
condition|(
name|code
condition|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
literal|'*'
case|:
if|if
condition|(
name|ASSEMBLER_DIALECT
operator|==
name|ASM_ATT
condition|)
name|putc
argument_list|(
literal|'*'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'&'
case|:
name|assemble_name
argument_list|(
name|file
argument_list|,
name|get_some_local_dynamic_name
argument_list|()
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'A'
case|:
switch|switch
condition|(
name|ASSEMBLER_DIALECT
condition|)
block|{
case|case
name|ASM_ATT
case|:
name|putc
argument_list|(
literal|'*'
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASM_INTEL
case|:
comment|/* Intel syntax. For absolute addresses, registers should not 		 be surrounded by braces.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
condition|)
block|{
name|putc
argument_list|(
literal|'['
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|PRINT_OPERAND
argument_list|(
name|file
argument_list|,
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|']'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|PRINT_OPERAND
argument_list|(
name|file
argument_list|,
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'L'
case|:
if|if
condition|(
name|ASSEMBLER_DIALECT
operator|==
name|ASM_ATT
condition|)
name|putc
argument_list|(
literal|'l'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'W'
case|:
if|if
condition|(
name|ASSEMBLER_DIALECT
operator|==
name|ASM_ATT
condition|)
name|putc
argument_list|(
literal|'w'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'B'
case|:
if|if
condition|(
name|ASSEMBLER_DIALECT
operator|==
name|ASM_ATT
condition|)
name|putc
argument_list|(
literal|'b'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'Q'
case|:
if|if
condition|(
name|ASSEMBLER_DIALECT
operator|==
name|ASM_ATT
condition|)
name|putc
argument_list|(
literal|'l'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'S'
case|:
if|if
condition|(
name|ASSEMBLER_DIALECT
operator|==
name|ASM_ATT
condition|)
name|putc
argument_list|(
literal|'s'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'T'
case|:
if|if
condition|(
name|ASSEMBLER_DIALECT
operator|==
name|ASM_ATT
condition|)
name|putc
argument_list|(
literal|'t'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'z'
case|:
comment|/* 387 opcodes don't get size suffixes if the operands are 	     registers.  */
if|if
condition|(
name|STACK_REG_P
argument_list|(
name|x
argument_list|)
condition|)
return|return;
comment|/* Likewise if using Intel opcodes.  */
if|if
condition|(
name|ASSEMBLER_DIALECT
operator|==
name|ASM_INTEL
condition|)
return|return;
comment|/* This is the size of op from size of operand.  */
switch|switch
condition|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
block|{
case|case
literal|2
case|:
ifdef|#
directive|ifdef
name|HAVE_GAS_FILDS_FISTS
name|putc
argument_list|(
literal|'s'
argument_list|,
name|file
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
case|case
literal|4
case|:
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|SFmode
condition|)
block|{
name|putc
argument_list|(
literal|'s'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|putc
argument_list|(
literal|'l'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|12
case|:
case|case
literal|16
case|:
name|putc
argument_list|(
literal|'t'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|8
case|:
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MODE_INT
condition|)
block|{
ifdef|#
directive|ifdef
name|GAS_MNEMONICS
name|putc
argument_list|(
literal|'q'
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|#
directive|else
name|putc
argument_list|(
literal|'l'
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'l'
argument_list|,
name|file
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|putc
argument_list|(
literal|'l'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
case|case
literal|'b'
case|:
case|case
literal|'w'
case|:
case|case
literal|'k'
case|:
case|case
literal|'q'
case|:
case|case
literal|'h'
case|:
case|case
literal|'y'
case|:
case|case
literal|'X'
case|:
case|case
literal|'P'
case|:
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
operator|||
operator|!
name|SHIFT_DOUBLE_OMITS_COUNT
condition|)
block|{
name|PRINT_OPERAND
argument_list|(
name|file
argument_list|,
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|','
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
literal|'D'
case|:
comment|/* Little bit of braindamage here.  The SSE compare instructions 	     does use completely different names for the comparisons that the 	     fp conditional moves.  */
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|EQ
case|:
case|case
name|UNEQ
case|:
name|fputs
argument_list|(
literal|"eq"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|LT
case|:
case|case
name|UNLT
case|:
name|fputs
argument_list|(
literal|"lt"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|LE
case|:
case|case
name|UNLE
case|:
name|fputs
argument_list|(
literal|"le"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNORDERED
case|:
name|fputs
argument_list|(
literal|"unord"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|NE
case|:
case|case
name|LTGT
case|:
name|fputs
argument_list|(
literal|"neq"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNGE
case|:
case|case
name|GE
case|:
name|fputs
argument_list|(
literal|"nlt"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNGT
case|:
case|case
name|GT
case|:
name|fputs
argument_list|(
literal|"nle"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|ORDERED
case|:
name|fputs
argument_list|(
literal|"ord"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
return|return;
case|case
literal|'O'
case|:
ifdef|#
directive|ifdef
name|HAVE_AS_IX86_CMOV_SUN_SYNTAX
if|if
condition|(
name|ASSEMBLER_DIALECT
operator|==
name|ASM_ATT
condition|)
block|{
switch|switch
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|HImode
case|:
name|putc
argument_list|(
literal|'w'
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|SImode
case|:
case|case
name|SFmode
case|:
name|putc
argument_list|(
literal|'l'
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|DImode
case|:
case|case
name|DFmode
case|:
name|putc
argument_list|(
literal|'q'
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'.'
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return;
case|case
literal|'C'
case|:
name|put_condition_code
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'F'
case|:
ifdef|#
directive|ifdef
name|HAVE_AS_IX86_CMOV_SUN_SYNTAX
if|if
condition|(
name|ASSEMBLER_DIALECT
operator|==
name|ASM_ATT
condition|)
name|putc
argument_list|(
literal|'.'
argument_list|,
name|file
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|put_condition_code
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
comment|/* Like above, but reverse condition */
case|case
literal|'c'
case|:
comment|/* Check to see if argument to %c is really a constant 	     and not a condition code which needs to be reversed.  */
if|if
condition|(
operator|!
name|COMPARISON_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|output_operand_lossage
argument_list|(
literal|"operand is neither a constant nor a condition code, invalid operand code 'c'"
argument_list|)
expr_stmt|;
return|return;
block|}
name|put_condition_code
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'f'
case|:
ifdef|#
directive|ifdef
name|HAVE_AS_IX86_CMOV_SUN_SYNTAX
if|if
condition|(
name|ASSEMBLER_DIALECT
operator|==
name|ASM_ATT
condition|)
name|putc
argument_list|(
literal|'.'
argument_list|,
name|file
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|put_condition_code
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'H'
case|:
comment|/* It doesn't actually matter what mode we use here, as we're 	     only going to use this for printing.  */
name|x
operator|=
name|adjust_address_nv
argument_list|(
name|x
argument_list|,
name|DImode
argument_list|,
literal|8
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
block|{
name|rtx
name|x
decl_stmt|;
if|if
condition|(
operator|!
name|optimize
operator|||
name|optimize_size
operator|||
operator|!
name|TARGET_BRANCH_PREDICTION_HINTS
condition|)
return|return;
name|x
operator|=
name|find_reg_note
argument_list|(
name|current_output_insn
argument_list|,
name|REG_BR_PROB
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
condition|)
block|{
name|int
name|pred_val
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|pred_val
operator|<
name|REG_BR_PROB_BASE
operator|*
literal|45
operator|/
literal|100
operator|||
name|pred_val
operator|>
name|REG_BR_PROB_BASE
operator|*
literal|55
operator|/
literal|100
condition|)
block|{
name|int
name|taken
init|=
name|pred_val
operator|>
name|REG_BR_PROB_BASE
operator|/
literal|2
decl_stmt|;
name|int
name|cputaken
init|=
name|final_forward_branch_p
argument_list|(
name|current_output_insn
argument_list|)
operator|==
literal|0
decl_stmt|;
comment|/* Emit hints only in the case default branch prediction 		       heuristics would fail.  */
if|if
condition|(
name|taken
operator|!=
name|cputaken
condition|)
block|{
comment|/* We use 3e (DS) prefix for taken branches and 			   2e (CS) prefix for not taken branches.  */
if|if
condition|(
name|taken
condition|)
name|fputs
argument_list|(
literal|"ds ; "
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
literal|"cs ; "
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return;
block|}
default|default:
name|output_operand_lossage
argument_list|(
literal|"invalid operand code '%c'"
argument_list|,
name|code
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
name|print_reg
argument_list|(
name|x
argument_list|,
name|code
argument_list|,
name|file
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
block|{
comment|/* No `byte ptr' prefix for call instructions.  */
if|if
condition|(
name|ASSEMBLER_DIALECT
operator|==
name|ASM_INTEL
operator|&&
name|code
operator|!=
literal|'X'
operator|&&
name|code
operator|!=
literal|'P'
condition|)
block|{
specifier|const
name|char
modifier|*
name|size
decl_stmt|;
switch|switch
condition|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
name|size
operator|=
literal|"BYTE"
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|size
operator|=
literal|"WORD"
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|size
operator|=
literal|"DWORD"
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|size
operator|=
literal|"QWORD"
expr_stmt|;
break|break;
case|case
literal|12
case|:
name|size
operator|=
literal|"XWORD"
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|size
operator|=
literal|"XMMWORD"
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
comment|/* Check for explicit size override (codes 'b', 'w' and 'k')  */
if|if
condition|(
name|code
operator|==
literal|'b'
condition|)
name|size
operator|=
literal|"BYTE"
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
literal|'w'
condition|)
name|size
operator|=
literal|"WORD"
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
literal|'k'
condition|)
name|size
operator|=
literal|"DWORD"
expr_stmt|;
name|fputs
argument_list|(
name|size
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|" PTR "
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Avoid (%rip) for call operands.  */
if|if
condition|(
name|CONSTANT_ADDRESS_P
argument_list|(
name|x
argument_list|)
operator|&&
name|code
operator|==
literal|'P'
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|this_is_asm_operands
operator|&&
operator|!
name|address_operand
argument_list|(
name|x
argument_list|,
name|VOIDmode
argument_list|)
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid constraints for operand"
argument_list|)
expr_stmt|;
else|else
name|output_address
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|SFmode
condition|)
block|{
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|long
name|l
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|r
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|REAL_VALUE_TO_TARGET_SINGLE
argument_list|(
name|r
argument_list|,
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|ASSEMBLER_DIALECT
operator|==
name|ASM_ATT
condition|)
name|putc
argument_list|(
literal|'$'
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0x%08lx"
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
comment|/* These float cases don't actually occur as immediate operands.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|DFmode
condition|)
block|{
name|char
name|dstr
index|[
literal|30
index|]
decl_stmt|;
name|real_to_decimal
argument_list|(
name|dstr
argument_list|,
name|CONST_DOUBLE_REAL_VALUE
argument_list|(
name|x
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|dstr
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|dstr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|XFmode
condition|)
block|{
name|char
name|dstr
index|[
literal|30
index|]
decl_stmt|;
name|real_to_decimal
argument_list|(
name|dstr
argument_list|,
name|CONST_DOUBLE_REAL_VALUE
argument_list|(
name|x
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|dstr
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|dstr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We have patterns that allow zero sets of memory, for instance. 	 In 64-bit mode, we should probably support all 8-byte vectors, 	 since we can in fact encode that into an immediate.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_VECTOR
condition|)
block|{
name|gcc_assert
argument_list|(
name|x
operator|==
name|CONST0_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|const0_rtx
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|!=
literal|'P'
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
if|if
condition|(
name|ASSEMBLER_DIALECT
operator|==
name|ASM_ATT
condition|)
name|putc
argument_list|(
literal|'$'
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LABEL_REF
condition|)
block|{
if|if
condition|(
name|ASSEMBLER_DIALECT
operator|==
name|ASM_ATT
condition|)
name|putc
argument_list|(
literal|'$'
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
literal|"OFFSET FLAT:"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|flag_pic
condition|)
name|output_pic_addr_const
argument_list|(
name|file
argument_list|,
name|x
argument_list|,
name|code
argument_list|)
expr_stmt|;
else|else
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print a memory operand whose address is ADDR.  */
end_comment

begin_function
name|void
name|print_operand_address
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|rtx
name|addr
parameter_list|)
block|{
name|struct
name|ix86_address
name|parts
decl_stmt|;
name|rtx
name|base
decl_stmt|,
name|index
decl_stmt|,
name|disp
decl_stmt|;
name|int
name|scale
decl_stmt|;
name|int
name|ok
init|=
name|ix86_decompose_address
argument_list|(
name|addr
argument_list|,
operator|&
name|parts
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|ok
argument_list|)
expr_stmt|;
name|base
operator|=
name|parts
operator|.
name|base
expr_stmt|;
name|index
operator|=
name|parts
operator|.
name|index
expr_stmt|;
name|disp
operator|=
name|parts
operator|.
name|disp
expr_stmt|;
name|scale
operator|=
name|parts
operator|.
name|scale
expr_stmt|;
switch|switch
condition|(
name|parts
operator|.
name|seg
condition|)
block|{
case|case
name|SEG_DEFAULT
case|:
break|break;
case|case
name|SEG_FS
case|:
case|case
name|SEG_GS
case|:
if|if
condition|(
name|USER_LABEL_PREFIX
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|putc
argument_list|(
literal|'%'
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
operator|(
name|parts
operator|.
name|seg
operator|==
name|SEG_FS
condition|?
literal|"fs:"
else|:
literal|"gs:"
operator|)
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|base
operator|&&
operator|!
name|index
condition|)
block|{
comment|/* Displacement only requires special attention.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|ASSEMBLER_DIALECT
operator|==
name|ASM_INTEL
operator|&&
name|parts
operator|.
name|seg
operator|==
name|SEG_DEFAULT
condition|)
block|{
if|if
condition|(
name|USER_LABEL_PREFIX
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|putc
argument_list|(
literal|'%'
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"ds:"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|INTVAL
argument_list|(
name|disp
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flag_pic
condition|)
name|output_pic_addr_const
argument_list|(
name|file
argument_list|,
name|disp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|disp
argument_list|)
expr_stmt|;
comment|/* Use one byte shorter RIP relative addressing for 64bit mode.  */
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
name|disp
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|==
name|LABEL_REF
operator|||
operator|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|SYMBOL_REF_TLS_MODEL
argument_list|(
name|disp
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|fputs
argument_list|(
literal|"(%rip)"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ASSEMBLER_DIALECT
operator|==
name|ASM_ATT
condition|)
block|{
if|if
condition|(
name|disp
condition|)
block|{
if|if
condition|(
name|flag_pic
condition|)
name|output_pic_addr_const
argument_list|(
name|file
argument_list|,
name|disp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|==
name|LABEL_REF
condition|)
name|output_asm_label
argument_list|(
name|disp
argument_list|)
expr_stmt|;
else|else
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|disp
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'('
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
condition|)
name|print_reg
argument_list|(
name|base
argument_list|,
literal|0
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
condition|)
block|{
name|putc
argument_list|(
literal|','
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|print_reg
argument_list|(
name|index
argument_list|,
literal|0
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|scale
operator|!=
literal|1
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|",%d"
argument_list|,
name|scale
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|')'
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|offset
init|=
name|NULL_RTX
decl_stmt|;
if|if
condition|(
name|disp
condition|)
block|{
comment|/* Pull out the offset of a symbol; print any symbol itself.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|offset
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|disp
operator|=
name|gen_rtx_CONST
argument_list|(
name|VOIDmode
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_pic
condition|)
name|output_pic_addr_const
argument_list|(
name|file
argument_list|,
name|disp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|==
name|LABEL_REF
condition|)
name|output_asm_label
argument_list|(
name|disp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|==
name|CONST_INT
condition|)
name|offset
operator|=
name|disp
expr_stmt|;
else|else
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|disp
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'['
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
condition|)
block|{
name|print_reg
argument_list|(
name|base
argument_list|,
literal|0
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
condition|)
block|{
if|if
condition|(
name|INTVAL
argument_list|(
name|offset
argument_list|)
operator|>=
literal|0
condition|)
name|putc
argument_list|(
literal|'+'
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|INTVAL
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|offset
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|INTVAL
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|putc
argument_list|(
literal|'0'
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
condition|)
block|{
name|putc
argument_list|(
literal|'+'
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|print_reg
argument_list|(
name|index
argument_list|,
literal|0
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|scale
operator|!=
literal|1
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"*%d"
argument_list|,
name|scale
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|']'
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|bool
name|output_addr_const_extra
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|rtx
name|x
parameter_list|)
block|{
name|rtx
name|op
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|UNSPEC
condition|)
return|return
name|false
return|;
name|op
operator|=
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|XINT
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|)
block|{
case|case
name|UNSPEC_GOTTPOFF
case|:
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|op
argument_list|)
expr_stmt|;
comment|/* FIXME: This might be @TPOFF in Sun ld.  */
name|fputs
argument_list|(
literal|"@GOTTPOFF"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSPEC_TPOFF
case|:
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"@TPOFF"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSPEC_NTPOFF
case|:
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
name|fputs
argument_list|(
literal|"@TPOFF"
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
literal|"@NTPOFF"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSPEC_DTPOFF
case|:
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"@DTPOFF"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSPEC_GOTNTPOFF
case|:
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
name|fputs
argument_list|(
literal|"@GOTTPOFF(%rip)"
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
literal|"@GOTNTPOFF"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSPEC_INDNTPOFF
case|:
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"@INDNTPOFF"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Split one or more DImode RTL references into pairs of SImode    references.  The RTL can be REG, offsettable MEM, integer constant, or    CONST_DOUBLE.  "operands" is a pointer to an array of DImode RTL to    split and "num" is its length.  lo_half and hi_half are output arrays    that parallel "operands".  */
end_comment

begin_function
name|void
name|split_di
parameter_list|(
name|rtx
name|operands
index|[]
parameter_list|,
name|int
name|num
parameter_list|,
name|rtx
name|lo_half
index|[]
parameter_list|,
name|rtx
name|hi_half
index|[]
parameter_list|)
block|{
while|while
condition|(
name|num
operator|--
condition|)
block|{
name|rtx
name|op
init|=
name|operands
index|[
name|num
index|]
decl_stmt|;
comment|/* simplify_subreg refuse to split volatile memory addresses,          but we still have to handle it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|lo_half
index|[
name|num
index|]
operator|=
name|adjust_address
argument_list|(
name|op
argument_list|,
name|SImode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|hi_half
index|[
name|num
index|]
operator|=
name|adjust_address
argument_list|(
name|op
argument_list|,
name|SImode
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lo_half
index|[
name|num
index|]
operator|=
name|simplify_gen_subreg
argument_list|(
name|SImode
argument_list|,
name|op
argument_list|,
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
condition|?
name|DImode
else|:
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|hi_half
index|[
name|num
index|]
operator|=
name|simplify_gen_subreg
argument_list|(
name|SImode
argument_list|,
name|op
argument_list|,
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
condition|?
name|DImode
else|:
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Split one or more TImode RTL references into pairs of DImode    references.  The RTL can be REG, offsettable MEM, integer constant, or    CONST_DOUBLE.  "operands" is a pointer to an array of DImode RTL to    split and "num" is its length.  lo_half and hi_half are output arrays    that parallel "operands".  */
end_comment

begin_function
name|void
name|split_ti
parameter_list|(
name|rtx
name|operands
index|[]
parameter_list|,
name|int
name|num
parameter_list|,
name|rtx
name|lo_half
index|[]
parameter_list|,
name|rtx
name|hi_half
index|[]
parameter_list|)
block|{
while|while
condition|(
name|num
operator|--
condition|)
block|{
name|rtx
name|op
init|=
name|operands
index|[
name|num
index|]
decl_stmt|;
comment|/* simplify_subreg refuse to split volatile memory addresses, but we          still have to handle it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|lo_half
index|[
name|num
index|]
operator|=
name|adjust_address
argument_list|(
name|op
argument_list|,
name|DImode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|hi_half
index|[
name|num
index|]
operator|=
name|adjust_address
argument_list|(
name|op
argument_list|,
name|DImode
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lo_half
index|[
name|num
index|]
operator|=
name|simplify_gen_subreg
argument_list|(
name|DImode
argument_list|,
name|op
argument_list|,
name|TImode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|hi_half
index|[
name|num
index|]
operator|=
name|simplify_gen_subreg
argument_list|(
name|DImode
argument_list|,
name|op
argument_list|,
name|TImode
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output code to perform a 387 binary operation in INSN, one of PLUS,    MINUS, MULT or DIV.  OPERANDS are the insn operands, where operands[3]    is the expression of the binary operation.  The output may either be    emitted here, or returned to the caller, like all output_* functions.     There is no guarantee that the operands are the same mode, as they    might be within FLOAT or FLOAT_EXTEND expressions.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SYSV386_COMPAT
end_ifndef

begin_comment
comment|/* Set to 1 for compatibility with brain-damaged assemblers.  No-one    wants to fix the assemblers because that causes incompatibility    with gcc.  No-one wants to fix gcc because that causes    incompatibility with assemblers...  You can use the option of    -DSYSV386_COMPAT=0 if you recompile both gcc and gas this way.  */
end_comment

begin_define
define|#
directive|define
name|SYSV386_COMPAT
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|const
name|char
modifier|*
name|output_387_binary_op
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
modifier|*
name|operands
parameter_list|)
block|{
specifier|static
name|char
name|buf
index|[
literal|30
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|ssep
decl_stmt|;
name|int
name|is_sse
init|=
name|SSE_REG_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|||
name|SSE_REG_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|||
name|SSE_REG_P
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
comment|/* Even if we do not want to check the inputs, this documents input      constraints.  Which helps in understanding the following code.  */
if|if
condition|(
name|STACK_REG_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|&&
operator|(
operator|(
name|REG_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|&&
operator|(
name|STACK_REG_P
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|==
name|MEM
operator|)
operator|)
operator|||
operator|(
name|REG_P
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|REGNO
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|&&
operator|(
name|STACK_REG_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|MEM
operator|)
operator|)
operator|)
operator|&&
operator|(
name|STACK_TOP_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|||
name|STACK_TOP_P
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|)
condition|)
empty_stmt|;
comment|/* ok */
else|else
name|gcc_assert
argument_list|(
name|is_sse
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
case|case
name|PLUS
case|:
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|||
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
argument_list|)
operator|==
name|MODE_INT
condition|)
name|p
operator|=
literal|"fiadd"
expr_stmt|;
else|else
name|p
operator|=
literal|"fadd"
expr_stmt|;
name|ssep
operator|=
literal|"add"
expr_stmt|;
break|break;
case|case
name|MINUS
case|:
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|||
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
argument_list|)
operator|==
name|MODE_INT
condition|)
name|p
operator|=
literal|"fisub"
expr_stmt|;
else|else
name|p
operator|=
literal|"fsub"
expr_stmt|;
name|ssep
operator|=
literal|"sub"
expr_stmt|;
break|break;
case|case
name|MULT
case|:
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|||
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
argument_list|)
operator|==
name|MODE_INT
condition|)
name|p
operator|=
literal|"fimul"
expr_stmt|;
else|else
name|p
operator|=
literal|"fmul"
expr_stmt|;
name|ssep
operator|=
literal|"mul"
expr_stmt|;
break|break;
case|case
name|DIV
case|:
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|||
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
argument_list|)
operator|==
name|MODE_INT
condition|)
name|p
operator|=
literal|"fidiv"
expr_stmt|;
else|else
name|p
operator|=
literal|"fdiv"
expr_stmt|;
name|ssep
operator|=
literal|"div"
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|is_sse
condition|)
block|{
name|strcpy
argument_list|(
name|buf
argument_list|,
name|ssep
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|SFmode
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"ss\t{%2, %0|%0, %2}"
argument_list|)
expr_stmt|;
else|else
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"sd\t{%2, %0|%0, %2}"
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
name|strcpy
argument_list|(
name|buf
argument_list|,
name|p
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
case|case
name|MULT
case|:
case|case
name|PLUS
case|:
if|if
condition|(
name|REG_P
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|REGNO
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
name|rtx
name|temp
init|=
name|operands
index|[
literal|2
index|]
decl_stmt|;
name|operands
index|[
literal|2
index|]
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|temp
expr_stmt|;
block|}
comment|/* know operands[0] == operands[1].  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|p
operator|=
literal|"%z2\t%2"
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|STACK_TOP_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
comment|/* How is it that we are storing to a dead operand[2]? 	       Well, presumably operands[1] is dead too.  We can't 	       store the result to st(0) as st(0) gets popped on this 	       instruction.  Instead store to operands[2] (which I 	       think has to be st(1)).  st(1) will be popped later. 	       gcc<= 2.8.1 didn't have this check and generated 	       assembly code that the Unixware assembler rejected.  */
name|p
operator|=
literal|"p\t{%0, %2|%2, %0}"
expr_stmt|;
comment|/* st(1) = st(0) op st(1); pop */
else|else
name|p
operator|=
literal|"p\t{%2, %0|%0, %2}"
expr_stmt|;
comment|/* st(r1) = st(r1) op st(0); pop */
break|break;
block|}
if|if
condition|(
name|STACK_TOP_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
name|p
operator|=
literal|"\t{%y2, %0|%0, %y2}"
expr_stmt|;
comment|/* st(0) = st(0) op st(r2) */
else|else
name|p
operator|=
literal|"\t{%2, %0|%0, %2}"
expr_stmt|;
comment|/* st(r1) = st(r1) op st(0) */
break|break;
case|case
name|MINUS
case|:
case|case
name|DIV
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|p
operator|=
literal|"r%z1\t%1"
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|p
operator|=
literal|"%z2\t%2"
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|SYSV386_COMPAT
comment|/* The SystemV/386 SVR3.2 assembler, and probably all AT&T 	     derived assemblers, confusingly reverse the direction of 	     the operation for fsub{r} and fdiv{r} when the 	     destination register is not st(0).  The Intel assembler 	     doesn't have this brain damage.  Read !SYSV386_COMPAT to 	     figure out what the hardware really does.  */
if|if
condition|(
name|STACK_TOP_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
name|p
operator|=
literal|"{p\t%0, %2|rp\t%2, %0}"
expr_stmt|;
else|else
name|p
operator|=
literal|"{rp\t%2, %0|p\t%0, %2}"
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|STACK_TOP_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
comment|/* As above for fmul/fadd, we can't store to st(0).  */
name|p
operator|=
literal|"rp\t{%0, %2|%2, %0}"
expr_stmt|;
comment|/* st(1) = st(0) op st(1); pop */
else|else
name|p
operator|=
literal|"p\t{%2, %0|%0, %2}"
expr_stmt|;
comment|/* st(r1) = st(r1) op st(0); pop */
endif|#
directive|endif
break|break;
block|}
if|if
condition|(
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|SYSV386_COMPAT
if|if
condition|(
name|STACK_TOP_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
name|p
operator|=
literal|"{rp\t%0, %1|p\t%1, %0}"
expr_stmt|;
else|else
name|p
operator|=
literal|"{p\t%1, %0|rp\t%0, %1}"
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|STACK_TOP_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
name|p
operator|=
literal|"p\t{%0, %1|%1, %0}"
expr_stmt|;
comment|/* st(1) = st(1) op st(0); pop */
else|else
name|p
operator|=
literal|"rp\t{%1, %0|%0, %1}"
expr_stmt|;
comment|/* st(r2) = st(0) op st(r2); pop */
endif|#
directive|endif
break|break;
block|}
if|if
condition|(
name|STACK_TOP_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|STACK_TOP_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
name|p
operator|=
literal|"\t{%y2, %0|%0, %y2}"
expr_stmt|;
comment|/* st(0) = st(0) op st(r2) */
else|else
name|p
operator|=
literal|"r\t{%y1, %0|%0, %y1}"
expr_stmt|;
comment|/* st(0) = st(r1) op st(0) */
break|break;
block|}
elseif|else
if|if
condition|(
name|STACK_TOP_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
if|#
directive|if
name|SYSV386_COMPAT
name|p
operator|=
literal|"{\t%1, %0|r\t%0, %1}"
expr_stmt|;
else|#
directive|else
name|p
operator|=
literal|"r\t{%1, %0|%0, %1}"
expr_stmt|;
comment|/* st(r2) = st(0) op st(r2) */
endif|#
directive|endif
block|}
else|else
block|{
if|#
directive|if
name|SYSV386_COMPAT
name|p
operator|=
literal|"{r\t%2, %0|\t%0, %2}"
expr_stmt|;
else|#
directive|else
name|p
operator|=
literal|"\t{%2, %0|%0, %2}"
expr_stmt|;
comment|/* st(r1) = st(r1) op st(0) */
endif|#
directive|endif
block|}
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|strcat
argument_list|(
name|buf
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/* Return needed mode for entity in optimize_mode_switching pass.  */
end_comment

begin_function
name|int
name|ix86_mode_needed
parameter_list|(
name|int
name|entity
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|enum
name|attr_i387_cw
name|mode
decl_stmt|;
comment|/* The mode UNINITIALIZED is used to store control word after a      function call or ASM pattern.  The mode ANY specify that function      has no requirements on the control word and make no changes in the      bits we are interested in.  */
if|if
condition|(
name|CALL_P
argument_list|(
name|insn
argument_list|)
operator|||
operator|(
name|NONJUMP_INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
operator|(
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|>=
literal|0
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ASM_INPUT
operator|)
operator|)
condition|)
return|return
name|I387_CW_UNINITIALIZED
return|;
if|if
condition|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|<
literal|0
condition|)
return|return
name|I387_CW_ANY
return|;
name|mode
operator|=
name|get_attr_i387_cw
argument_list|(
name|insn
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|entity
condition|)
block|{
case|case
name|I387_TRUNC
case|:
if|if
condition|(
name|mode
operator|==
name|I387_CW_TRUNC
condition|)
return|return
name|mode
return|;
break|break;
case|case
name|I387_FLOOR
case|:
if|if
condition|(
name|mode
operator|==
name|I387_CW_FLOOR
condition|)
return|return
name|mode
return|;
break|break;
case|case
name|I387_CEIL
case|:
if|if
condition|(
name|mode
operator|==
name|I387_CW_CEIL
condition|)
return|return
name|mode
return|;
break|break;
case|case
name|I387_MASK_PM
case|:
if|if
condition|(
name|mode
operator|==
name|I387_CW_MASK_PM
condition|)
return|return
name|mode
return|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
return|return
name|I387_CW_ANY
return|;
block|}
end_function

begin_comment
comment|/* Output code to initialize control word copies used by trunc?f?i and    rounding patterns.  CURRENT_MODE is set to current control word,    while NEW_MODE is set to new control word.  */
end_comment

begin_function
name|void
name|emit_i387_cw_initialization
parameter_list|(
name|int
name|mode
parameter_list|)
block|{
name|rtx
name|stored_mode
init|=
name|assign_386_stack_local
argument_list|(
name|HImode
argument_list|,
name|SLOT_CW_STORED
argument_list|)
decl_stmt|;
name|rtx
name|new_mode
decl_stmt|;
name|int
name|slot
decl_stmt|;
name|rtx
name|reg
init|=
name|gen_reg_rtx
argument_list|(
name|HImode
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_x86_fnstcw_1
argument_list|(
name|stored_mode
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|stored_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
operator|||
name|TARGET_PARTIAL_REG_STALL
operator|||
name|optimize_size
condition|)
block|{
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|I387_CW_TRUNC
case|:
comment|/* round toward zero (truncate) */
name|emit_insn
argument_list|(
name|gen_iorhi3
argument_list|(
name|reg
argument_list|,
name|reg
argument_list|,
name|GEN_INT
argument_list|(
literal|0x0c00
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|slot
operator|=
name|SLOT_CW_TRUNC
expr_stmt|;
break|break;
case|case
name|I387_CW_FLOOR
case|:
comment|/* round down toward -oo */
name|emit_insn
argument_list|(
name|gen_andhi3
argument_list|(
name|reg
argument_list|,
name|reg
argument_list|,
name|GEN_INT
argument_list|(
operator|~
literal|0x0c00
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_iorhi3
argument_list|(
name|reg
argument_list|,
name|reg
argument_list|,
name|GEN_INT
argument_list|(
literal|0x0400
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|slot
operator|=
name|SLOT_CW_FLOOR
expr_stmt|;
break|break;
case|case
name|I387_CW_CEIL
case|:
comment|/* round up toward +oo */
name|emit_insn
argument_list|(
name|gen_andhi3
argument_list|(
name|reg
argument_list|,
name|reg
argument_list|,
name|GEN_INT
argument_list|(
operator|~
literal|0x0c00
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_iorhi3
argument_list|(
name|reg
argument_list|,
name|reg
argument_list|,
name|GEN_INT
argument_list|(
literal|0x0800
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|slot
operator|=
name|SLOT_CW_CEIL
expr_stmt|;
break|break;
case|case
name|I387_CW_MASK_PM
case|:
comment|/* mask precision exception for nearbyint() */
name|emit_insn
argument_list|(
name|gen_iorhi3
argument_list|(
name|reg
argument_list|,
name|reg
argument_list|,
name|GEN_INT
argument_list|(
literal|0x0020
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|slot
operator|=
name|SLOT_CW_MASK_PM
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|I387_CW_TRUNC
case|:
comment|/* round toward zero (truncate) */
name|emit_insn
argument_list|(
name|gen_movsi_insv_1
argument_list|(
name|reg
argument_list|,
name|GEN_INT
argument_list|(
literal|0xc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|slot
operator|=
name|SLOT_CW_TRUNC
expr_stmt|;
break|break;
case|case
name|I387_CW_FLOOR
case|:
comment|/* round down toward -oo */
name|emit_insn
argument_list|(
name|gen_movsi_insv_1
argument_list|(
name|reg
argument_list|,
name|GEN_INT
argument_list|(
literal|0x4
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|slot
operator|=
name|SLOT_CW_FLOOR
expr_stmt|;
break|break;
case|case
name|I387_CW_CEIL
case|:
comment|/* round up toward +oo */
name|emit_insn
argument_list|(
name|gen_movsi_insv_1
argument_list|(
name|reg
argument_list|,
name|GEN_INT
argument_list|(
literal|0x8
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|slot
operator|=
name|SLOT_CW_CEIL
expr_stmt|;
break|break;
case|case
name|I387_CW_MASK_PM
case|:
comment|/* mask precision exception for nearbyint() */
name|emit_insn
argument_list|(
name|gen_iorhi3
argument_list|(
name|reg
argument_list|,
name|reg
argument_list|,
name|GEN_INT
argument_list|(
literal|0x0020
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|slot
operator|=
name|SLOT_CW_MASK_PM
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
name|gcc_assert
argument_list|(
name|slot
operator|<
name|MAX_386_STACK_LOCALS
argument_list|)
expr_stmt|;
name|new_mode
operator|=
name|assign_386_stack_local
argument_list|(
name|HImode
argument_list|,
name|slot
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|new_mode
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output code for INSN to convert a float to a signed int.  OPERANDS    are the insn operands.  The output may be [HSD]Imode and the input    operand may be [SDX]Fmode.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|output_fix_trunc
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
modifier|*
name|operands
parameter_list|,
name|int
name|fisttp
parameter_list|)
block|{
name|int
name|stack_top_dies
init|=
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|FIRST_STACK_REG
argument_list|)
operator|!=
literal|0
decl_stmt|;
name|int
name|dimode_p
init|=
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|DImode
decl_stmt|;
name|int
name|round_mode
init|=
name|get_attr_i387_cw
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* Jump through a hoop or two for DImode, since the hardware has no      non-popping instruction.  We used to do this a different way, but      that was somewhat fragile and broke with post-reload splitters.  */
if|if
condition|(
operator|(
name|dimode_p
operator|||
name|fisttp
operator|)
operator|&&
operator|!
name|stack_top_dies
condition|)
name|output_asm_insn
argument_list|(
literal|"fld\t%y1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|STACK_TOP_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|MEM
argument_list|)
expr_stmt|;
if|if
condition|(
name|fisttp
condition|)
name|output_asm_insn
argument_list|(
literal|"fisttp%z0\t%0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|round_mode
operator|!=
name|I387_CW_ANY
condition|)
name|output_asm_insn
argument_list|(
literal|"fldcw\t%3"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
if|if
condition|(
name|stack_top_dies
operator|||
name|dimode_p
condition|)
name|output_asm_insn
argument_list|(
literal|"fistp%z0\t%0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
else|else
name|output_asm_insn
argument_list|(
literal|"fist%z0\t%0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
if|if
condition|(
name|round_mode
operator|!=
name|I387_CW_ANY
condition|)
name|output_asm_insn
argument_list|(
literal|"fldcw\t%2"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
return|return
literal|""
return|;
block|}
end_function

begin_comment
comment|/* Output code for x87 ffreep insn.  The OPNO argument, which may only    have the values zero or one, indicates the ffreep insn's operand    from the OPERANDS array.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|output_387_ffreep
parameter_list|(
name|rtx
modifier|*
name|operands
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|opno
parameter_list|)
block|{
if|if
condition|(
name|TARGET_USE_FFREEP
condition|)
if|#
directive|if
name|HAVE_AS_IX86_FFREEP
return|return
name|opno
condition|?
literal|"ffreep\t%y1"
else|:
literal|"ffreep\t%y0"
return|;
else|#
directive|else
switch|switch
condition|(
name|REGNO
argument_list|(
name|operands
index|[
name|opno
index|]
argument_list|)
condition|)
block|{
case|case
name|FIRST_STACK_REG
operator|+
literal|0
case|:
return|return
literal|".word\t0xc0df"
return|;
case|case
name|FIRST_STACK_REG
operator|+
literal|1
case|:
return|return
literal|".word\t0xc1df"
return|;
case|case
name|FIRST_STACK_REG
operator|+
literal|2
case|:
return|return
literal|".word\t0xc2df"
return|;
case|case
name|FIRST_STACK_REG
operator|+
literal|3
case|:
return|return
literal|".word\t0xc3df"
return|;
case|case
name|FIRST_STACK_REG
operator|+
literal|4
case|:
return|return
literal|".word\t0xc4df"
return|;
case|case
name|FIRST_STACK_REG
operator|+
literal|5
case|:
return|return
literal|".word\t0xc5df"
return|;
case|case
name|FIRST_STACK_REG
operator|+
literal|6
case|:
return|return
literal|".word\t0xc6df"
return|;
case|case
name|FIRST_STACK_REG
operator|+
literal|7
case|:
return|return
literal|".word\t0xc7df"
return|;
block|}
endif|#
directive|endif
return|return
name|opno
condition|?
literal|"fstp\t%y1"
else|:
literal|"fstp\t%y0"
return|;
block|}
end_function

begin_comment
comment|/* Output code for INSN to compare OPERANDS.  EFLAGS_P is 1 when fcomi    should be used.  UNORDERED_P is true when fucom should be used.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|output_fp_compare
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
modifier|*
name|operands
parameter_list|,
name|int
name|eflags_p
parameter_list|,
name|int
name|unordered_p
parameter_list|)
block|{
name|int
name|stack_top_dies
decl_stmt|;
name|rtx
name|cmp_op0
decl_stmt|,
name|cmp_op1
decl_stmt|;
name|int
name|is_sse
init|=
name|SSE_REG_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|||
name|SSE_REG_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|eflags_p
condition|)
block|{
name|cmp_op0
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
name|cmp_op1
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
name|cmp_op0
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
name|cmp_op1
operator|=
name|operands
index|[
literal|2
index|]
expr_stmt|;
block|}
if|if
condition|(
name|is_sse
condition|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|SFmode
condition|)
if|if
condition|(
name|unordered_p
condition|)
return|return
literal|"ucomiss\t{%1, %0|%0, %1}"
return|;
else|else
return|return
literal|"comiss\t{%1, %0|%0, %1}"
return|;
elseif|else
if|if
condition|(
name|unordered_p
condition|)
return|return
literal|"ucomisd\t{%1, %0|%0, %1}"
return|;
else|else
return|return
literal|"comisd\t{%1, %0|%0, %1}"
return|;
block|}
name|gcc_assert
argument_list|(
name|STACK_TOP_P
argument_list|(
name|cmp_op0
argument_list|)
argument_list|)
expr_stmt|;
name|stack_top_dies
operator|=
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|FIRST_STACK_REG
argument_list|)
operator|!=
literal|0
expr_stmt|;
if|if
condition|(
name|cmp_op1
operator|==
name|CONST0_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|cmp_op1
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|stack_top_dies
condition|)
block|{
name|output_asm_insn
argument_list|(
literal|"ftst\n\tfnstsw\t%0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return
name|output_387_ffreep
argument_list|(
name|operands
argument_list|,
literal|1
argument_list|)
return|;
block|}
else|else
return|return
literal|"ftst\n\tfnstsw\t%0"
return|;
block|}
if|if
condition|(
name|STACK_REG_P
argument_list|(
name|cmp_op1
argument_list|)
operator|&&
name|stack_top_dies
operator|&&
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
name|cmp_op1
argument_list|)
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|cmp_op1
argument_list|)
operator|!=
name|FIRST_STACK_REG
condition|)
block|{
comment|/* If both the top of the 387 stack dies, and the other operand 	 is also a stack register that dies, then this must be a 	 `fcompp' float compare */
if|if
condition|(
name|eflags_p
condition|)
block|{
comment|/* There is no double popping fcomi variant.  Fortunately, 	     eflags is immune from the fstp's cc clobbering.  */
if|if
condition|(
name|unordered_p
condition|)
name|output_asm_insn
argument_list|(
literal|"fucomip\t{%y1, %0|%0, %y1}"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
else|else
name|output_asm_insn
argument_list|(
literal|"fcomip\t{%y1, %0|%0, %y1}"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return
name|output_387_ffreep
argument_list|(
name|operands
argument_list|,
literal|0
argument_list|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|unordered_p
condition|)
return|return
literal|"fucompp\n\tfnstsw\t%0"
return|;
else|else
return|return
literal|"fcompp\n\tfnstsw\t%0"
return|;
block|}
block|}
else|else
block|{
comment|/* Encoded here as eflags_p | intmode | unordered_p | stack_top_dies.  */
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|alt
index|[
literal|16
index|]
init|=
block|{
literal|"fcom%z2\t%y2\n\tfnstsw\t%0"
block|,
literal|"fcomp%z2\t%y2\n\tfnstsw\t%0"
block|,
literal|"fucom%z2\t%y2\n\tfnstsw\t%0"
block|,
literal|"fucomp%z2\t%y2\n\tfnstsw\t%0"
block|,
literal|"ficom%z2\t%y2\n\tfnstsw\t%0"
block|,
literal|"ficomp%z2\t%y2\n\tfnstsw\t%0"
block|,
name|NULL
block|,
name|NULL
block|,
literal|"fcomi\t{%y1, %0|%0, %y1}"
block|,
literal|"fcomip\t{%y1, %0|%0, %y1}"
block|,
literal|"fucomi\t{%y1, %0|%0, %y1}"
block|,
literal|"fucomip\t{%y1, %0|%0, %y1}"
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
name|int
name|mask
decl_stmt|;
specifier|const
name|char
modifier|*
name|ret
decl_stmt|;
name|mask
operator|=
name|eflags_p
operator|<<
literal|3
expr_stmt|;
name|mask
operator||=
operator|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|cmp_op1
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|)
operator|<<
literal|2
expr_stmt|;
name|mask
operator||=
name|unordered_p
operator|<<
literal|1
expr_stmt|;
name|mask
operator||=
name|stack_top_dies
expr_stmt|;
name|gcc_assert
argument_list|(
name|mask
operator|<
literal|16
argument_list|)
expr_stmt|;
name|ret
operator|=
name|alt
index|[
name|mask
index|]
expr_stmt|;
name|gcc_assert
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
block|}
end_function

begin_function
name|void
name|ix86_output_addr_vec_elt
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|int
name|value
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|directive
init|=
name|ASM_LONG
decl_stmt|;
ifdef|#
directive|ifdef
name|ASM_QUAD
if|if
condition|(
name|TARGET_64BIT
condition|)
name|directive
operator|=
name|ASM_QUAD
expr_stmt|;
else|#
directive|else
name|gcc_assert
argument_list|(
operator|!
name|TARGET_64BIT
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s%s%d\n"
argument_list|,
name|directive
argument_list|,
name|LPREFIX
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ix86_output_addr_diff_elt
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|int
name|value
parameter_list|,
name|int
name|rel
parameter_list|)
block|{
if|if
condition|(
name|TARGET_64BIT
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s%s%d-%s%d\n"
argument_list|,
name|ASM_LONG
argument_list|,
name|LPREFIX
argument_list|,
name|value
argument_list|,
name|LPREFIX
argument_list|,
name|rel
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|HAVE_AS_GOTOFF_IN_DATA
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s%s%d@GOTOFF\n"
argument_list|,
name|ASM_LONG
argument_list|,
name|LPREFIX
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|#
directive|if
name|TARGET_MACHO
elseif|else
if|if
condition|(
name|TARGET_MACHO
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s%s%d-"
argument_list|,
name|ASM_LONG
argument_list|,
name|LPREFIX
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|machopic_output_function_base_name
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
else|else
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"%s%U%s+[.-%s%d]\n"
argument_list|,
name|ASM_LONG
argument_list|,
name|GOT_SYMBOL_NAME
argument_list|,
name|LPREFIX
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate either "mov $0, reg" or "xor reg, reg", as appropriate    for the target.  */
end_comment

begin_function
name|void
name|ix86_expand_clear
parameter_list|(
name|rtx
name|dest
parameter_list|)
block|{
name|rtx
name|tmp
decl_stmt|;
comment|/* We play register width games, which are only valid after reload.  */
name|gcc_assert
argument_list|(
name|reload_completed
argument_list|)
expr_stmt|;
comment|/* Avoid HImode and its attendant prefix byte.  */
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|<
literal|4
condition|)
name|dest
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|dest
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
comment|/* This predicate should match that for movsi_xor and movdi_xor_rex64.  */
if|if
condition|(
name|reload_completed
operator|&&
operator|(
operator|!
name|TARGET_USE_MOV0
operator|||
name|optimize_size
operator|)
condition|)
block|{
name|rtx
name|clob
init|=
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|CCmode
argument_list|,
literal|17
argument_list|)
argument_list|)
decl_stmt|;
name|tmp
operator|=
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|tmp
argument_list|,
name|clob
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|emit_insn
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* X is an unchanging MEM.  If it is a constant pool reference, return    the constant pool rtx, else NULL.  */
end_comment

begin_function
name|rtx
name|maybe_get_pool_constant
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|x
operator|=
name|ix86_delegitimize_address
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|get_pool_constant
argument_list|(
name|x
argument_list|)
return|;
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_function
name|void
name|ix86_expand_move
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|operands
index|[]
parameter_list|)
block|{
name|int
name|strict
init|=
operator|(
name|reload_in_progress
operator|||
name|reload_completed
operator|)
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
name|enum
name|tls_model
name|model
decl_stmt|;
name|op0
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
name|op1
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
block|{
name|model
operator|=
name|SYMBOL_REF_TLS_MODEL
argument_list|(
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|model
condition|)
block|{
name|op1
operator|=
name|legitimize_tls_address
argument_list|(
name|op1
argument_list|,
name|model
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|op1
operator|=
name|force_operand
argument_list|(
name|op1
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
operator|==
name|op0
condition|)
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
block|{
name|model
operator|=
name|SYMBOL_REF_TLS_MODEL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|model
condition|)
block|{
name|rtx
name|addend
init|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|op1
operator|=
name|legitimize_tls_address
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|model
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|op1
operator|=
name|force_operand
argument_list|(
name|op1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_simple_binop
argument_list|(
name|Pmode
argument_list|,
name|PLUS
argument_list|,
name|op1
argument_list|,
name|addend
argument_list|,
name|op0
argument_list|,
literal|1
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
operator|==
name|op0
condition|)
return|return;
block|}
block|}
if|if
condition|(
name|flag_pic
operator|&&
name|mode
operator|==
name|Pmode
operator|&&
name|symbolic_operand
argument_list|(
name|op1
argument_list|,
name|Pmode
argument_list|)
condition|)
block|{
if|if
condition|(
name|TARGET_MACHO
operator|&&
operator|!
name|TARGET_64BIT
condition|)
block|{
if|#
directive|if
name|TARGET_MACHO
if|if
condition|(
name|MACHOPIC_PURE
condition|)
block|{
name|rtx
name|temp
init|=
operator|(
operator|(
name|reload_in_progress
operator|||
operator|(
operator|(
name|op0
operator|&&
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|REG
operator|)
operator|&&
name|mode
operator|==
name|Pmode
operator|)
operator|)
condition|?
name|op0
else|:
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
operator|)
decl_stmt|;
name|op1
operator|=
name|machopic_indirect_data_reference
argument_list|(
name|op1
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|op1
operator|=
name|machopic_legitimize_pic_address
argument_list|(
name|op1
argument_list|,
name|mode
argument_list|,
name|temp
operator|==
name|op1
condition|?
literal|0
else|:
name|temp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|MACHOPIC_INDIRECT
condition|)
name|op1
operator|=
name|machopic_indirect_data_reference
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
operator|==
name|op1
condition|)
return|return;
endif|#
directive|endif
block|}
else|else
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|MEM
condition|)
name|op1
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|op1
argument_list|)
expr_stmt|;
else|else
name|op1
operator|=
name|legitimize_address
argument_list|(
name|op1
argument_list|,
name|op1
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
name|PUSH_ROUNDING
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|)
operator|!=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|||
operator|!
name|push_operand
argument_list|(
name|op0
argument_list|,
name|mode
argument_list|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|MEM
condition|)
name|op1
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|push_operand
argument_list|(
name|op0
argument_list|,
name|mode
argument_list|)
operator|&&
operator|!
name|general_no_elim_operand
argument_list|(
name|op1
argument_list|,
name|mode
argument_list|)
condition|)
name|op1
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode
argument_list|,
name|op1
argument_list|)
expr_stmt|;
comment|/* Force large constants in 64bit compilation into register 	 to get them CSEed.  */
if|if
condition|(
name|TARGET_64BIT
operator|&&
name|mode
operator|==
name|DImode
operator|&&
name|immediate_operand
argument_list|(
name|op1
argument_list|,
name|mode
argument_list|)
operator|&&
operator|!
name|x86_64_zext_immediate_operand
argument_list|(
name|op1
argument_list|,
name|VOIDmode
argument_list|)
operator|&&
operator|!
name|register_operand
argument_list|(
name|op0
argument_list|,
name|mode
argument_list|)
operator|&&
name|optimize
operator|&&
operator|!
name|reload_completed
operator|&&
operator|!
name|reload_in_progress
condition|)
name|op1
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
block|{
comment|/* If we are loading a floating point constant to a register, 	     force the value to memory now, since we'll get better code 	     out the back end.  */
if|if
condition|(
name|strict
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
name|op1
operator|=
name|validize_mem
argument_list|(
name|force_const_mem
argument_list|(
name|mode
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|register_operand
argument_list|(
name|op0
argument_list|,
name|mode
argument_list|)
condition|)
block|{
name|rtx
name|temp
init|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|temp
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|op0
argument_list|,
name|temp
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
block|}
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ix86_expand_vector_move
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|operands
index|[]
parameter_list|)
block|{
name|rtx
name|op0
init|=
name|operands
index|[
literal|0
index|]
decl_stmt|,
name|op1
init|=
name|operands
index|[
literal|1
index|]
decl_stmt|;
comment|/* Force constants other than zero into memory.  We do not know how      the instructions used to build constants modify the upper 64 bits      of the register, once we have that information we may be able      to handle some of them more efficiently.  */
if|if
condition|(
operator|(
name|reload_in_progress
operator||
name|reload_completed
operator|)
operator|==
literal|0
operator|&&
name|register_operand
argument_list|(
name|op0
argument_list|,
name|mode
argument_list|)
operator|&&
name|CONSTANT_P
argument_list|(
name|op1
argument_list|)
operator|&&
name|standard_sse_constant_p
argument_list|(
name|op1
argument_list|)
operator|<=
literal|0
condition|)
name|op1
operator|=
name|validize_mem
argument_list|(
name|force_const_mem
argument_list|(
name|mode
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make operand1 a register if it isn't already.  */
if|if
condition|(
operator|!
name|no_new_pseudos
operator|&&
operator|!
name|register_operand
argument_list|(
name|op0
argument_list|,
name|mode
argument_list|)
operator|&&
operator|!
name|register_operand
argument_list|(
name|op1
argument_list|,
name|mode
argument_list|)
condition|)
block|{
name|emit_move_insn
argument_list|(
name|op0
argument_list|,
name|force_reg
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Implement the movmisalign patterns for SSE.  Non-SSE modes go    straight to ix86_expand_vector_move.  */
end_comment

begin_function
name|void
name|ix86_expand_vector_move_misalign
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|operands
index|[]
parameter_list|)
block|{
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|,
name|m
decl_stmt|;
name|op0
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
name|op1
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|MEM_P
argument_list|(
name|op1
argument_list|)
condition|)
block|{
comment|/* If we're optimizing for size, movups is the smallest.  */
if|if
condition|(
name|optimize_size
condition|)
block|{
name|op0
operator|=
name|gen_lowpart
argument_list|(
name|V4SFmode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|gen_lowpart
argument_list|(
name|V4SFmode
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_sse_movups
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* ??? If we have typed data, then it would appear that using 	 movdqu is the only way to get unaligned data loaded with 	 integer type.  */
if|if
condition|(
name|TARGET_SSE2
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_VECTOR_INT
condition|)
block|{
name|op0
operator|=
name|gen_lowpart
argument_list|(
name|V16QImode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|gen_lowpart
argument_list|(
name|V16QImode
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_sse2_movdqu
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|TARGET_SSE2
operator|&&
name|mode
operator|==
name|V2DFmode
condition|)
block|{
name|rtx
name|zero
decl_stmt|;
comment|/* When SSE registers are split into halves, we can avoid 	     writing to the top half twice.  */
if|if
condition|(
name|TARGET_SSE_SPLIT_REGS
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|op0
argument_list|)
argument_list|)
expr_stmt|;
name|zero
operator|=
name|op0
expr_stmt|;
block|}
else|else
block|{
comment|/* ??? Not sure about the best option for the Intel chips. 		 The following would seem to satisfy; the register is 		 entirely cleared, breaking the dependency chain.  We 		 then store to the upper half, with a dependency depth 		 of one.  A rumor has it that Intel recommends two movsd 		 followed by an unpacklpd, but this is unconfirmed.  And 		 given that the dependency depth of the unpacklpd would 		 still be one, I'm not sure why this would be better.  */
name|zero
operator|=
name|CONST0_RTX
argument_list|(
name|V2DFmode
argument_list|)
expr_stmt|;
block|}
name|m
operator|=
name|adjust_address
argument_list|(
name|op1
argument_list|,
name|DFmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_sse2_loadlpd
argument_list|(
name|op0
argument_list|,
name|zero
argument_list|,
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|=
name|adjust_address
argument_list|(
name|op1
argument_list|,
name|DFmode
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_sse2_loadhpd
argument_list|(
name|op0
argument_list|,
name|op0
argument_list|,
name|m
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|TARGET_SSE_PARTIAL_REG_DEPENDENCY
condition|)
name|emit_move_insn
argument_list|(
name|op0
argument_list|,
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|op0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|V4SFmode
condition|)
name|op0
operator|=
name|gen_lowpart
argument_list|(
name|V4SFmode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|m
operator|=
name|adjust_address
argument_list|(
name|op1
argument_list|,
name|V2SFmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_sse_loadlps
argument_list|(
name|op0
argument_list|,
name|op0
argument_list|,
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|=
name|adjust_address
argument_list|(
name|op1
argument_list|,
name|V2SFmode
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_sse_loadhps
argument_list|(
name|op0
argument_list|,
name|op0
argument_list|,
name|m
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|MEM_P
argument_list|(
name|op0
argument_list|)
condition|)
block|{
comment|/* If we're optimizing for size, movups is the smallest.  */
if|if
condition|(
name|optimize_size
condition|)
block|{
name|op0
operator|=
name|gen_lowpart
argument_list|(
name|V4SFmode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|gen_lowpart
argument_list|(
name|V4SFmode
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_sse_movups
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* ??? Similar to above, only less clear because of quote 	 typeless stores unquote.  */
if|if
condition|(
name|TARGET_SSE2
operator|&&
operator|!
name|TARGET_SSE_TYPELESS_STORES
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_VECTOR_INT
condition|)
block|{
name|op0
operator|=
name|gen_lowpart
argument_list|(
name|V16QImode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|gen_lowpart
argument_list|(
name|V16QImode
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_sse2_movdqu
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|TARGET_SSE2
operator|&&
name|mode
operator|==
name|V2DFmode
condition|)
block|{
name|m
operator|=
name|adjust_address
argument_list|(
name|op0
argument_list|,
name|DFmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_sse2_storelpd
argument_list|(
name|m
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|=
name|adjust_address
argument_list|(
name|op0
argument_list|,
name|DFmode
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_sse2_storehpd
argument_list|(
name|m
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|mode
operator|!=
name|V4SFmode
condition|)
name|op1
operator|=
name|gen_lowpart
argument_list|(
name|V4SFmode
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|m
operator|=
name|adjust_address
argument_list|(
name|op0
argument_list|,
name|V2SFmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_sse_storelps
argument_list|(
name|m
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|=
name|adjust_address
argument_list|(
name|op0
argument_list|,
name|V2SFmode
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_sse_storehps
argument_list|(
name|m
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Expand a push in MODE.  This is some mode for which we do not support    proper push instructions, at least from the registers that we expect    the value to live in.  */
end_comment

begin_function
name|void
name|ix86_expand_push
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|x
parameter_list|)
block|{
name|rtx
name|tmp
decl_stmt|;
name|tmp
operator|=
name|expand_simple_binop
argument_list|(
name|Pmode
argument_list|,
name|PLUS
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
operator|-
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|)
argument_list|,
name|stack_pointer_rtx
argument_list|,
literal|1
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|!=
name|stack_pointer_rtx
condition|)
name|emit_move_insn
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode
argument_list|,
name|stack_pointer_rtx
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|tmp
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fix up OPERANDS to satisfy ix86_binary_operator_ok.  Return the    destination to use for the operation.  If different from the true    destination in operands[0], a copy operation will be required.  */
end_comment

begin_function
name|rtx
name|ix86_fixup_binary_operands
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|operands
index|[]
parameter_list|)
block|{
name|int
name|matching_memory
decl_stmt|;
name|rtx
name|src1
decl_stmt|,
name|src2
decl_stmt|,
name|dst
decl_stmt|;
name|dst
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
name|src1
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
name|src2
operator|=
name|operands
index|[
literal|2
index|]
expr_stmt|;
comment|/* Recognize<var1> =<value><op><var1> for commutative operators */
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|RTX_COMM_ARITH
operator|&&
operator|(
name|rtx_equal_p
argument_list|(
name|dst
argument_list|,
name|src2
argument_list|)
operator|||
name|immediate_operand
argument_list|(
name|src1
argument_list|,
name|mode
argument_list|)
operator|)
condition|)
block|{
name|rtx
name|temp
init|=
name|src1
decl_stmt|;
name|src1
operator|=
name|src2
expr_stmt|;
name|src2
operator|=
name|temp
expr_stmt|;
block|}
comment|/* If the destination is memory, and we do not have matching source      operands, do things in registers.  */
name|matching_memory
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|dst
argument_list|,
name|src1
argument_list|)
condition|)
name|matching_memory
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|RTX_COMM_ARITH
operator|&&
name|rtx_equal_p
argument_list|(
name|dst
argument_list|,
name|src2
argument_list|)
condition|)
name|matching_memory
operator|=
literal|2
expr_stmt|;
else|else
name|dst
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
comment|/* Both source operands cannot be in memory.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|src1
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|src2
argument_list|)
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
name|matching_memory
operator|!=
literal|2
condition|)
name|src2
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|src2
argument_list|)
expr_stmt|;
else|else
name|src1
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|src1
argument_list|)
expr_stmt|;
block|}
comment|/* If the operation is not commutable, source 1 cannot be a constant      or non-matching memory.  */
if|if
condition|(
operator|(
name|CONSTANT_P
argument_list|(
name|src1
argument_list|)
operator|||
operator|(
operator|!
name|matching_memory
operator|&&
name|GET_CODE
argument_list|(
name|src1
argument_list|)
operator|==
name|MEM
operator|)
operator|)
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|!=
name|RTX_COMM_ARITH
condition|)
name|src1
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|src1
argument_list|)
expr_stmt|;
name|src1
operator|=
name|operands
index|[
literal|1
index|]
operator|=
name|src1
expr_stmt|;
name|src2
operator|=
name|operands
index|[
literal|2
index|]
operator|=
name|src2
expr_stmt|;
return|return
name|dst
return|;
block|}
end_function

begin_comment
comment|/* Similarly, but assume that the destination has already been    set up properly.  */
end_comment

begin_function
name|void
name|ix86_fixup_binary_operands_no_copy
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|operands
index|[]
parameter_list|)
block|{
name|rtx
name|dst
init|=
name|ix86_fixup_binary_operands
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|operands
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|dst
operator|==
name|operands
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Attempt to expand a binary operator.  Make the expansion closer to the    actual machine, then just general_operand, which will allow 3 separate    memory references (one output, two input) in a single insn.  */
end_comment

begin_function
name|void
name|ix86_expand_binary_operator
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|operands
index|[]
parameter_list|)
block|{
name|rtx
name|src1
decl_stmt|,
name|src2
decl_stmt|,
name|dst
decl_stmt|,
name|op
decl_stmt|,
name|clob
decl_stmt|;
name|dst
operator|=
name|ix86_fixup_binary_operands
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|src1
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
name|src2
operator|=
name|operands
index|[
literal|2
index|]
expr_stmt|;
comment|/* Emit the instruction.  */
name|op
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|dst
argument_list|,
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|src1
argument_list|,
name|src2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reload_in_progress
condition|)
block|{
comment|/* Reload doesn't know about the flags register, and doesn't know that          it doesn't want to clobber it.  We can only do this with PLUS.  */
name|gcc_assert
argument_list|(
name|code
operator|==
name|PLUS
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|clob
operator|=
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|CCmode
argument_list|,
name|FLAGS_REG
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|op
argument_list|,
name|clob
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Fix up the destination if needed.  */
if|if
condition|(
name|dst
operator|!=
name|operands
index|[
literal|0
index|]
condition|)
name|emit_move_insn
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|dst
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return TRUE or FALSE depending on whether the binary operator meets the    appropriate constraints.  */
end_comment

begin_function
name|int
name|ix86_binary_operator_ok
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|,
name|rtx
name|operands
index|[
literal|3
index|]
parameter_list|)
block|{
comment|/* Both source operands cannot be in memory.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|==
name|MEM
condition|)
return|return
literal|0
return|;
comment|/* If the operation is not commutable, source 1 cannot be a constant.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|!=
name|RTX_COMM_ARITH
condition|)
return|return
literal|0
return|;
comment|/* If the destination is memory, we must have a matching source operand.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
operator|(
name|rtx_equal_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
operator|||
operator|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|RTX_COMM_ARITH
operator|&&
name|rtx_equal_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|)
operator|)
operator|)
condition|)
return|return
literal|0
return|;
comment|/* If the operation is not commutable and the source 1 is memory, we must      have a matching destination.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|!=
name|RTX_COMM_ARITH
operator|&&
operator|!
name|rtx_equal_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Attempt to expand a unary operator.  Make the expansion closer to the    actual machine, then just general_operand, which will allow 2 separate    memory references (one output, one input) in a single insn.  */
end_comment

begin_function
name|void
name|ix86_expand_unary_operator
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|operands
index|[]
parameter_list|)
block|{
name|int
name|matching_memory
decl_stmt|;
name|rtx
name|src
decl_stmt|,
name|dst
decl_stmt|,
name|op
decl_stmt|,
name|clob
decl_stmt|;
name|dst
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
name|src
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
comment|/* If the destination is memory, and we do not have matching source      operands, do things in registers.  */
name|matching_memory
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|MEM_P
argument_list|(
name|dst
argument_list|)
condition|)
block|{
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|dst
argument_list|,
name|src
argument_list|)
condition|)
name|matching_memory
operator|=
literal|1
expr_stmt|;
else|else
name|dst
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
comment|/* When source operand is memory, destination must match.  */
if|if
condition|(
name|MEM_P
argument_list|(
name|src
argument_list|)
operator|&&
operator|!
name|matching_memory
condition|)
name|src
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|src
argument_list|)
expr_stmt|;
comment|/* Emit the instruction.  */
name|op
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|dst
argument_list|,
name|gen_rtx_fmt_e
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|src
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reload_in_progress
operator|||
name|code
operator|==
name|NOT
condition|)
block|{
comment|/* Reload doesn't know about the flags register, and doesn't know that          it doesn't want to clobber it.  */
name|gcc_assert
argument_list|(
name|code
operator|==
name|NOT
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|clob
operator|=
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|CCmode
argument_list|,
name|FLAGS_REG
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|op
argument_list|,
name|clob
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Fix up the destination if needed.  */
if|if
condition|(
name|dst
operator|!=
name|operands
index|[
literal|0
index|]
condition|)
name|emit_move_insn
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|dst
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return TRUE or FALSE depending on whether the unary operator meets the    appropriate constraints.  */
end_comment

begin_function
name|int
name|ix86_unary_operator_ok
parameter_list|(
name|enum
name|rtx_code
name|code
name|ATTRIBUTE_UNUSED
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|,
name|rtx
name|operands
index|[
literal|2
index|]
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* If one of operands is memory, source and destination must match.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|MEM
operator|||
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|MEM
operator|)
operator|&&
operator|!
name|rtx_equal_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of ix86_expand_fp_absneg_operator and copysign expanders.    Create a mask for the sign bit in MODE for an SSE register.  If VECT is    true, then replicate the mask for all elements of the vector register.    If INVERT is true, then create a mask excluding the sign bit.  */
end_comment

begin_function
name|rtx
name|ix86_build_signbit_mask
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|bool
name|vect
parameter_list|,
name|bool
name|invert
parameter_list|)
block|{
name|enum
name|machine_mode
name|vec_mode
decl_stmt|;
name|HOST_WIDE_INT
name|hi
decl_stmt|,
name|lo
decl_stmt|;
name|int
name|shift
init|=
literal|63
decl_stmt|;
name|rtvec
name|v
decl_stmt|;
name|rtx
name|mask
decl_stmt|;
comment|/* Find the sign bit, sign extended to 2*HWI.  */
if|if
condition|(
name|mode
operator|==
name|SFmode
condition|)
name|lo
operator|=
literal|0x80000000
operator|,
name|hi
operator|=
name|lo
operator|<
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|HOST_BITS_PER_WIDE_INT
operator|>=
literal|64
condition|)
name|lo
operator|=
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|shift
operator|,
name|hi
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|lo
operator|=
literal|0
operator|,
name|hi
operator|=
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|shift
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|)
expr_stmt|;
if|if
condition|(
name|invert
condition|)
name|lo
operator|=
operator|~
name|lo
operator|,
name|hi
operator|=
operator|~
name|hi
expr_stmt|;
comment|/* Force this value into the low part of a fp vector constant.  */
name|mask
operator|=
name|immed_double_const
argument_list|(
name|lo
argument_list|,
name|hi
argument_list|,
name|mode
operator|==
name|SFmode
condition|?
name|SImode
else|:
name|DImode
argument_list|)
expr_stmt|;
name|mask
operator|=
name|gen_lowpart
argument_list|(
name|mode
argument_list|,
name|mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|SFmode
condition|)
block|{
if|if
condition|(
name|vect
condition|)
name|v
operator|=
name|gen_rtvec
argument_list|(
literal|4
argument_list|,
name|mask
argument_list|,
name|mask
argument_list|,
name|mask
argument_list|,
name|mask
argument_list|)
expr_stmt|;
else|else
name|v
operator|=
name|gen_rtvec
argument_list|(
literal|4
argument_list|,
name|mask
argument_list|,
name|CONST0_RTX
argument_list|(
name|SFmode
argument_list|)
argument_list|,
name|CONST0_RTX
argument_list|(
name|SFmode
argument_list|)
argument_list|,
name|CONST0_RTX
argument_list|(
name|SFmode
argument_list|)
argument_list|)
expr_stmt|;
name|vec_mode
operator|=
name|V4SFmode
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|vect
condition|)
name|v
operator|=
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|mask
argument_list|,
name|mask
argument_list|)
expr_stmt|;
else|else
name|v
operator|=
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|mask
argument_list|,
name|CONST0_RTX
argument_list|(
name|DFmode
argument_list|)
argument_list|)
expr_stmt|;
name|vec_mode
operator|=
name|V2DFmode
expr_stmt|;
block|}
return|return
name|force_reg
argument_list|(
name|vec_mode
argument_list|,
name|gen_rtx_CONST_VECTOR
argument_list|(
name|vec_mode
argument_list|,
name|v
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Generate code for floating point ABS or NEG.  */
end_comment

begin_function
name|void
name|ix86_expand_fp_absneg_operator
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|operands
index|[]
parameter_list|)
block|{
name|rtx
name|mask
decl_stmt|,
name|set
decl_stmt|,
name|use
decl_stmt|,
name|clob
decl_stmt|,
name|dst
decl_stmt|,
name|src
decl_stmt|;
name|bool
name|matching_memory
decl_stmt|;
name|bool
name|use_sse
init|=
name|false
decl_stmt|;
name|bool
name|vector_mode
init|=
name|VECTOR_MODE_P
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|elt_mode
init|=
name|mode
decl_stmt|;
if|if
condition|(
name|vector_mode
condition|)
block|{
name|elt_mode
operator|=
name|GET_MODE_INNER
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|use_sse
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TARGET_SSE_MATH
condition|)
name|use_sse
operator|=
name|SSE_FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
expr_stmt|;
comment|/* NEG and ABS performed with SSE use bitwise mask operations.      Create the appropriate mask now.  */
if|if
condition|(
name|use_sse
condition|)
name|mask
operator|=
name|ix86_build_signbit_mask
argument_list|(
name|elt_mode
argument_list|,
name|vector_mode
argument_list|,
name|code
operator|==
name|ABS
argument_list|)
expr_stmt|;
else|else
name|mask
operator|=
name|NULL_RTX
expr_stmt|;
name|dst
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
name|src
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
comment|/* If the destination is memory, and we don't have matching source      operands or we're using the x87, do things in registers.  */
name|matching_memory
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|MEM_P
argument_list|(
name|dst
argument_list|)
condition|)
block|{
if|if
condition|(
name|use_sse
operator|&&
name|rtx_equal_p
argument_list|(
name|dst
argument_list|,
name|src
argument_list|)
condition|)
name|matching_memory
operator|=
name|true
expr_stmt|;
else|else
name|dst
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|MEM_P
argument_list|(
name|src
argument_list|)
operator|&&
operator|!
name|matching_memory
condition|)
name|src
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|vector_mode
condition|)
block|{
name|set
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|code
operator|==
name|NEG
condition|?
name|XOR
else|:
name|AND
argument_list|,
name|mode
argument_list|,
name|src
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|set
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|dst
argument_list|,
name|set
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|set
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|set
operator|=
name|gen_rtx_fmt_e
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|set
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|dst
argument_list|,
name|set
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
condition|)
block|{
name|use
operator|=
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|clob
operator|=
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|CCmode
argument_list|,
name|FLAGS_REG
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|3
argument_list|,
name|set
argument_list|,
name|use
argument_list|,
name|clob
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|emit_insn
argument_list|(
name|set
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dst
operator|!=
name|operands
index|[
literal|0
index|]
condition|)
name|emit_move_insn
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|dst
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Expand a copysign operation.  Special case operand 0 being a constant.  */
end_comment

begin_function
name|void
name|ix86_expand_copysign
parameter_list|(
name|rtx
name|operands
index|[]
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|,
name|vmode
decl_stmt|;
name|rtx
name|dest
decl_stmt|,
name|op0
decl_stmt|,
name|op1
decl_stmt|,
name|mask
decl_stmt|,
name|nmask
decl_stmt|;
name|dest
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
name|op0
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
name|op1
operator|=
name|operands
index|[
literal|2
index|]
expr_stmt|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|vmode
operator|=
name|mode
operator|==
name|SFmode
condition|?
name|V4SFmode
else|:
name|V2DFmode
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
name|rtvec
name|v
decl_stmt|;
if|if
condition|(
name|real_isneg
argument_list|(
name|CONST_DOUBLE_REAL_VALUE
argument_list|(
name|op0
argument_list|)
argument_list|)
condition|)
name|op0
operator|=
name|simplify_unary_operation
argument_list|(
name|ABS
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
condition|)
name|op0
operator|=
name|CONST0_RTX
argument_list|(
name|vmode
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|mode
operator|==
name|SFmode
condition|)
name|v
operator|=
name|gen_rtvec
argument_list|(
literal|4
argument_list|,
name|op0
argument_list|,
name|CONST0_RTX
argument_list|(
name|SFmode
argument_list|)
argument_list|,
name|CONST0_RTX
argument_list|(
name|SFmode
argument_list|)
argument_list|,
name|CONST0_RTX
argument_list|(
name|SFmode
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|v
operator|=
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|op0
argument_list|,
name|CONST0_RTX
argument_list|(
name|DFmode
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|force_reg
argument_list|(
name|vmode
argument_list|,
name|gen_rtx_CONST_VECTOR
argument_list|(
name|vmode
argument_list|,
name|v
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|mask
operator|=
name|ix86_build_signbit_mask
argument_list|(
name|mode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|SFmode
condition|)
name|emit_insn
argument_list|(
name|gen_copysignsf3_const
argument_list|(
name|dest
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|mask
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_copysigndf3_const
argument_list|(
name|dest
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|mask
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nmask
operator|=
name|ix86_build_signbit_mask
argument_list|(
name|mode
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mask
operator|=
name|ix86_build_signbit_mask
argument_list|(
name|mode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|SFmode
condition|)
name|emit_insn
argument_list|(
name|gen_copysignsf3_var
argument_list|(
name|dest
argument_list|,
name|NULL
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|nmask
argument_list|,
name|mask
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_copysigndf3_var
argument_list|(
name|dest
argument_list|,
name|NULL
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|nmask
argument_list|,
name|mask
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Deconstruct a copysign operation into bit masks.  Operand 0 is known to    be a constant, and so has already been expanded into a vector constant.  */
end_comment

begin_function
name|void
name|ix86_split_copysign_const
parameter_list|(
name|rtx
name|operands
index|[]
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|,
name|vmode
decl_stmt|;
name|rtx
name|dest
decl_stmt|,
name|op0
decl_stmt|,
name|op1
decl_stmt|,
name|mask
decl_stmt|,
name|x
decl_stmt|;
name|dest
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
name|op0
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
name|op1
operator|=
name|operands
index|[
literal|2
index|]
expr_stmt|;
name|mask
operator|=
name|operands
index|[
literal|3
index|]
expr_stmt|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|vmode
operator|=
name|GET_MODE
argument_list|(
name|mask
argument_list|)
expr_stmt|;
name|dest
operator|=
name|simplify_gen_subreg
argument_list|(
name|vmode
argument_list|,
name|dest
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|x
operator|=
name|gen_rtx_AND
argument_list|(
name|vmode
argument_list|,
name|dest
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|dest
argument_list|,
name|x
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
operator|!=
name|CONST0_RTX
argument_list|(
name|vmode
argument_list|)
condition|)
block|{
name|x
operator|=
name|gen_rtx_IOR
argument_list|(
name|vmode
argument_list|,
name|dest
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|dest
argument_list|,
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Deconstruct a copysign operation into bit masks.  Operand 0 is variable,    so we have to do two masks.  */
end_comment

begin_function
name|void
name|ix86_split_copysign_var
parameter_list|(
name|rtx
name|operands
index|[]
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|,
name|vmode
decl_stmt|;
name|rtx
name|dest
decl_stmt|,
name|scratch
decl_stmt|,
name|op0
decl_stmt|,
name|op1
decl_stmt|,
name|mask
decl_stmt|,
name|nmask
decl_stmt|,
name|x
decl_stmt|;
name|dest
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
name|scratch
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
name|op0
operator|=
name|operands
index|[
literal|2
index|]
expr_stmt|;
name|op1
operator|=
name|operands
index|[
literal|3
index|]
expr_stmt|;
name|nmask
operator|=
name|operands
index|[
literal|4
index|]
expr_stmt|;
name|mask
operator|=
name|operands
index|[
literal|5
index|]
expr_stmt|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|vmode
operator|=
name|GET_MODE
argument_list|(
name|mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
condition|)
block|{
comment|/* Shouldn't happen often (it's useless, obviously), but when it does 	 we'd generate incorrect code if we continue below.  */
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|op0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|REG_P
argument_list|(
name|mask
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|dest
argument_list|)
operator|==
name|REGNO
argument_list|(
name|mask
argument_list|)
condition|)
comment|/* alternative 0 */
block|{
name|gcc_assert
argument_list|(
name|REGNO
argument_list|(
name|op1
argument_list|)
operator|==
name|REGNO
argument_list|(
name|scratch
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|gen_rtx_AND
argument_list|(
name|vmode
argument_list|,
name|scratch
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|scratch
argument_list|,
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|dest
operator|=
name|mask
expr_stmt|;
name|op0
operator|=
name|simplify_gen_subreg
argument_list|(
name|vmode
argument_list|,
name|op0
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|x
operator|=
name|gen_rtx_NOT
argument_list|(
name|vmode
argument_list|,
name|dest
argument_list|)
expr_stmt|;
name|x
operator|=
name|gen_rtx_AND
argument_list|(
name|vmode
argument_list|,
name|x
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|dest
argument_list|,
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|REGNO
argument_list|(
name|op1
argument_list|)
operator|==
name|REGNO
argument_list|(
name|scratch
argument_list|)
condition|)
comment|/* alternative 1,3 */
block|{
name|x
operator|=
name|gen_rtx_AND
argument_list|(
name|vmode
argument_list|,
name|scratch
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* alternative 2,4 */
block|{
name|gcc_assert
argument_list|(
name|REGNO
argument_list|(
name|mask
argument_list|)
operator|==
name|REGNO
argument_list|(
name|scratch
argument_list|)
argument_list|)
expr_stmt|;
name|op1
operator|=
name|simplify_gen_subreg
argument_list|(
name|vmode
argument_list|,
name|op1
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|x
operator|=
name|gen_rtx_AND
argument_list|(
name|vmode
argument_list|,
name|scratch
argument_list|,
name|op1
argument_list|)
expr_stmt|;
block|}
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|scratch
argument_list|,
name|x
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|REGNO
argument_list|(
name|op0
argument_list|)
operator|==
name|REGNO
argument_list|(
name|dest
argument_list|)
condition|)
comment|/* alternative 1,2 */
block|{
name|dest
operator|=
name|simplify_gen_subreg
argument_list|(
name|vmode
argument_list|,
name|op0
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|x
operator|=
name|gen_rtx_AND
argument_list|(
name|vmode
argument_list|,
name|dest
argument_list|,
name|nmask
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* alternative 3,4 */
block|{
name|gcc_assert
argument_list|(
name|REGNO
argument_list|(
name|nmask
argument_list|)
operator|==
name|REGNO
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
name|dest
operator|=
name|nmask
expr_stmt|;
name|op0
operator|=
name|simplify_gen_subreg
argument_list|(
name|vmode
argument_list|,
name|op0
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|x
operator|=
name|gen_rtx_AND
argument_list|(
name|vmode
argument_list|,
name|dest
argument_list|,
name|op0
argument_list|)
expr_stmt|;
block|}
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|dest
argument_list|,
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|x
operator|=
name|gen_rtx_IOR
argument_list|(
name|vmode
argument_list|,
name|dest
argument_list|,
name|scratch
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|dest
argument_list|,
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return TRUE or FALSE depending on whether the first SET in INSN    has source and destination with matching CC modes, and that the    CC mode is at least as constrained as REQ_MODE.  */
end_comment

begin_function
name|int
name|ix86_match_ccmode
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|enum
name|machine_mode
name|req_mode
parameter_list|)
block|{
name|rtx
name|set
decl_stmt|;
name|enum
name|machine_mode
name|set_mode
decl_stmt|;
name|set
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|set
argument_list|)
operator|==
name|PARALLEL
condition|)
name|set
operator|=
name|XVECEXP
argument_list|(
name|set
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|set
argument_list|)
operator|==
name|SET
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|COMPARE
argument_list|)
expr_stmt|;
name|set_mode
operator|=
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|set_mode
condition|)
block|{
case|case
name|CCNOmode
case|:
if|if
condition|(
name|req_mode
operator|!=
name|CCNOmode
operator|&&
operator|(
name|req_mode
operator|!=
name|CCmode
operator|||
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|!=
name|const0_rtx
operator|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
name|CCmode
case|:
if|if
condition|(
name|req_mode
operator|==
name|CCGCmode
condition|)
return|return
literal|0
return|;
comment|/* FALLTHRU */
case|case
name|CCGCmode
case|:
if|if
condition|(
name|req_mode
operator|==
name|CCGOCmode
operator|||
name|req_mode
operator|==
name|CCNOmode
condition|)
return|return
literal|0
return|;
comment|/* FALLTHRU */
case|case
name|CCGOCmode
case|:
if|if
condition|(
name|req_mode
operator|==
name|CCZmode
condition|)
return|return
literal|0
return|;
comment|/* FALLTHRU */
case|case
name|CCZmode
case|:
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|set_mode
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Generate insn patterns to do an integer compare of OPERANDS.  */
end_comment

begin_function
specifier|static
name|rtx
name|ix86_expand_int_compare
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|rtx
name|op0
parameter_list|,
name|rtx
name|op1
parameter_list|)
block|{
name|enum
name|machine_mode
name|cmpmode
decl_stmt|;
name|rtx
name|tmp
decl_stmt|,
name|flags
decl_stmt|;
name|cmpmode
operator|=
name|SELECT_CC_MODE
argument_list|(
name|code
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|flags
operator|=
name|gen_rtx_REG
argument_list|(
name|cmpmode
argument_list|,
name|FLAGS_REG
argument_list|)
expr_stmt|;
comment|/* This is very simple, but making the interface the same as in the      FP case makes the rest of the code easier.  */
name|tmp
operator|=
name|gen_rtx_COMPARE
argument_list|(
name|cmpmode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|flags
argument_list|,
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Return the test that should be put into the flags user, i.e.      the bcc, scc, or cmov instruction.  */
return|return
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|VOIDmode
argument_list|,
name|flags
argument_list|,
name|const0_rtx
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Figure out whether to use ordered or unordered fp comparisons.    Return the appropriate mode to use.  */
end_comment

begin_function
name|enum
name|machine_mode
name|ix86_fp_compare_mode
parameter_list|(
name|enum
name|rtx_code
name|code
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* ??? In order to make all comparisons reversible, we do all comparisons      non-trapping when compiling for IEEE.  Once gcc is able to distinguish      all forms trapping and nontrapping comparisons, we can make inequality      comparisons trapping again, since it results in better code when using      FCOM based compares.  */
return|return
name|TARGET_IEEE_FP
condition|?
name|CCFPUmode
else|:
name|CCFPmode
return|;
block|}
end_function

begin_function
name|enum
name|machine_mode
name|ix86_cc_mode
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|rtx
name|op0
parameter_list|,
name|rtx
name|op1
parameter_list|)
block|{
if|if
condition|(
name|SCALAR_FLOAT_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
condition|)
return|return
name|ix86_fp_compare_mode
argument_list|(
name|code
argument_list|)
return|;
switch|switch
condition|(
name|code
condition|)
block|{
comment|/* Only zero flag is needed.  */
case|case
name|EQ
case|:
comment|/* ZF=0 */
case|case
name|NE
case|:
comment|/* ZF!=0 */
return|return
name|CCZmode
return|;
comment|/* Codes needing carry flag.  */
case|case
name|GEU
case|:
comment|/* CF=0 */
case|case
name|GTU
case|:
comment|/* CF=0& ZF=0 */
case|case
name|LTU
case|:
comment|/* CF=1 */
case|case
name|LEU
case|:
comment|/* CF=1 | ZF=1 */
return|return
name|CCmode
return|;
comment|/* Codes possibly doable only with sign flag when          comparing against zero.  */
case|case
name|GE
case|:
comment|/* SF=OF   or   SF=0 */
case|case
name|LT
case|:
comment|/* SF<>OF  or   SF=1 */
if|if
condition|(
name|op1
operator|==
name|const0_rtx
condition|)
return|return
name|CCGOCmode
return|;
else|else
comment|/* For other cases Carry flag is not required.  */
return|return
name|CCGCmode
return|;
comment|/* Codes doable only with sign flag when comparing          against zero, but we miss jump instruction for it          so we need to use relational tests against overflow          that thus needs to be zero.  */
case|case
name|GT
case|:
comment|/* ZF=0& SF=OF */
case|case
name|LE
case|:
comment|/* ZF=1 | SF<>OF */
if|if
condition|(
name|op1
operator|==
name|const0_rtx
condition|)
return|return
name|CCNOmode
return|;
else|else
return|return
name|CCGCmode
return|;
comment|/* strcmp pattern do (use flags) and combine may ask us for proper 	 mode.  */
case|case
name|USE
case|:
return|return
name|CCmode
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return the fixed registers used for condition codes.  */
end_comment

begin_function
specifier|static
name|bool
name|ix86_fixed_condition_code_regs
parameter_list|(
name|unsigned
name|int
modifier|*
name|p1
parameter_list|,
name|unsigned
name|int
modifier|*
name|p2
parameter_list|)
block|{
operator|*
name|p1
operator|=
name|FLAGS_REG
expr_stmt|;
operator|*
name|p2
operator|=
name|FPSR_REG
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* If two condition code modes are compatible, return a condition code    mode which is compatible with both.  Otherwise, return    VOIDmode.  */
end_comment

begin_function
specifier|static
name|enum
name|machine_mode
name|ix86_cc_modes_compatible
parameter_list|(
name|enum
name|machine_mode
name|m1
parameter_list|,
name|enum
name|machine_mode
name|m2
parameter_list|)
block|{
if|if
condition|(
name|m1
operator|==
name|m2
condition|)
return|return
name|m1
return|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|m1
argument_list|)
operator|!=
name|MODE_CC
operator|||
name|GET_MODE_CLASS
argument_list|(
name|m2
argument_list|)
operator|!=
name|MODE_CC
condition|)
return|return
name|VOIDmode
return|;
if|if
condition|(
operator|(
name|m1
operator|==
name|CCGCmode
operator|&&
name|m2
operator|==
name|CCGOCmode
operator|)
operator|||
operator|(
name|m1
operator|==
name|CCGOCmode
operator|&&
name|m2
operator|==
name|CCGCmode
operator|)
condition|)
return|return
name|CCGCmode
return|;
switch|switch
condition|(
name|m1
condition|)
block|{
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
case|case
name|CCmode
case|:
case|case
name|CCGCmode
case|:
case|case
name|CCGOCmode
case|:
case|case
name|CCNOmode
case|:
case|case
name|CCZmode
case|:
switch|switch
condition|(
name|m2
condition|)
block|{
default|default:
return|return
name|VOIDmode
return|;
case|case
name|CCmode
case|:
case|case
name|CCGCmode
case|:
case|case
name|CCGOCmode
case|:
case|case
name|CCNOmode
case|:
case|case
name|CCZmode
case|:
return|return
name|CCmode
return|;
block|}
case|case
name|CCFPmode
case|:
case|case
name|CCFPUmode
case|:
comment|/* These are only compatible with themselves, which we already 	 checked above.  */
return|return
name|VOIDmode
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return true if we should use an FCOMI instruction for this fp comparison.  */
end_comment

begin_function
name|int
name|ix86_use_fcomi_compare
parameter_list|(
name|enum
name|rtx_code
name|code
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|enum
name|rtx_code
name|swapped_code
init|=
name|swap_condition
argument_list|(
name|code
argument_list|)
decl_stmt|;
return|return
operator|(
operator|(
name|ix86_fp_comparison_cost
argument_list|(
name|code
argument_list|)
operator|==
name|ix86_fp_comparison_fcomi_cost
argument_list|(
name|code
argument_list|)
operator|)
operator|||
operator|(
name|ix86_fp_comparison_cost
argument_list|(
name|swapped_code
argument_list|)
operator|==
name|ix86_fp_comparison_fcomi_cost
argument_list|(
name|swapped_code
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Swap, force into registers, or otherwise massage the two operands    to a fp comparison.  The operands are updated in place; the new    comparison code is returned.  */
end_comment

begin_function
specifier|static
name|enum
name|rtx_code
name|ix86_prepare_fp_compare_args
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|rtx
modifier|*
name|pop0
parameter_list|,
name|rtx
modifier|*
name|pop1
parameter_list|)
block|{
name|enum
name|machine_mode
name|fpcmp_mode
init|=
name|ix86_fp_compare_mode
argument_list|(
name|code
argument_list|)
decl_stmt|;
name|rtx
name|op0
init|=
operator|*
name|pop0
decl_stmt|,
name|op1
init|=
operator|*
name|pop1
decl_stmt|;
name|enum
name|machine_mode
name|op_mode
init|=
name|GET_MODE
argument_list|(
name|op0
argument_list|)
decl_stmt|;
name|int
name|is_sse
init|=
name|TARGET_SSE_MATH
operator|&&
name|SSE_FLOAT_MODE_P
argument_list|(
name|op_mode
argument_list|)
decl_stmt|;
comment|/* All of the unordered compare instructions only work on registers.      The same is true of the fcomi compare instructions.  The XFmode      compare instructions require registers except when comparing      against zero or when converting operand 1 from fixed point to      floating point.  */
if|if
condition|(
operator|!
name|is_sse
operator|&&
operator|(
name|fpcmp_mode
operator|==
name|CCFPUmode
operator|||
operator|(
name|op_mode
operator|==
name|XFmode
operator|&&
operator|!
operator|(
name|standard_80387_constant_p
argument_list|(
name|op0
argument_list|)
operator|==
literal|1
operator|||
name|standard_80387_constant_p
argument_list|(
name|op1
argument_list|)
operator|==
literal|1
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|FLOAT
operator|)
operator|||
name|ix86_use_fcomi_compare
argument_list|(
name|code
argument_list|)
operator|)
condition|)
block|{
name|op0
operator|=
name|force_reg
argument_list|(
name|op_mode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|force_reg
argument_list|(
name|op_mode
argument_list|,
name|op1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* %%% We only allow op1 in memory; op0 must be st(0).  So swap 	 things around if they appear profitable, otherwise force op0 	 into a register.  */
if|if
condition|(
name|standard_80387_constant_p
argument_list|(
name|op0
argument_list|)
operator|==
literal|0
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
operator|(
name|standard_80387_constant_p
argument_list|(
name|op1
argument_list|)
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|MEM
operator|)
operator|)
condition|)
block|{
name|rtx
name|tmp
decl_stmt|;
name|tmp
operator|=
name|op0
operator|,
name|op0
operator|=
name|op1
operator|,
name|op1
operator|=
name|tmp
expr_stmt|;
name|code
operator|=
name|swap_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|REG
condition|)
name|op0
operator|=
name|force_reg
argument_list|(
name|op_mode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op1
argument_list|)
condition|)
block|{
name|int
name|tmp
init|=
name|standard_80387_constant_p
argument_list|(
name|op1
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmp
operator|==
literal|0
condition|)
name|op1
operator|=
name|validize_mem
argument_list|(
name|force_const_mem
argument_list|(
name|op_mode
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tmp
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|TARGET_CMOVE
condition|)
name|op1
operator|=
name|force_reg
argument_list|(
name|op_mode
argument_list|,
name|op1
argument_list|)
expr_stmt|;
block|}
else|else
name|op1
operator|=
name|force_reg
argument_list|(
name|op_mode
argument_list|,
name|op1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Try to rearrange the comparison to make it cheaper.  */
if|if
condition|(
name|ix86_fp_comparison_cost
argument_list|(
name|code
argument_list|)
operator|>
name|ix86_fp_comparison_cost
argument_list|(
name|swap_condition
argument_list|(
name|code
argument_list|)
argument_list|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|REG
operator|||
operator|!
name|no_new_pseudos
operator|)
condition|)
block|{
name|rtx
name|tmp
decl_stmt|;
name|tmp
operator|=
name|op0
operator|,
name|op0
operator|=
name|op1
operator|,
name|op1
operator|=
name|tmp
expr_stmt|;
name|code
operator|=
name|swap_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|REG
condition|)
name|op0
operator|=
name|force_reg
argument_list|(
name|op_mode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
block|}
operator|*
name|pop0
operator|=
name|op0
expr_stmt|;
operator|*
name|pop1
operator|=
name|op1
expr_stmt|;
return|return
name|code
return|;
block|}
end_function

begin_comment
comment|/* Convert comparison codes we use to represent FP comparison to integer    code that will result in proper branch.  Return UNKNOWN if no such code    is available.  */
end_comment

begin_function
name|enum
name|rtx_code
name|ix86_fp_compare_code_to_integer
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|GT
case|:
return|return
name|GTU
return|;
case|case
name|GE
case|:
return|return
name|GEU
return|;
case|case
name|ORDERED
case|:
case|case
name|UNORDERED
case|:
return|return
name|code
return|;
break|break;
case|case
name|UNEQ
case|:
return|return
name|EQ
return|;
break|break;
case|case
name|UNLT
case|:
return|return
name|LTU
return|;
break|break;
case|case
name|UNLE
case|:
return|return
name|LEU
return|;
break|break;
case|case
name|LTGT
case|:
return|return
name|NE
return|;
break|break;
default|default:
return|return
name|UNKNOWN
return|;
block|}
block|}
end_function

begin_comment
comment|/* Split comparison code CODE into comparisons we can do using branch    instructions.  BYPASS_CODE is comparison code for branch that will    branch around FIRST_CODE and SECOND_CODE.  If some of branches    is not required, set value to UNKNOWN.    We never require more than two branches.  */
end_comment

begin_function
name|void
name|ix86_fp_comparison_codes
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|enum
name|rtx_code
modifier|*
name|bypass_code
parameter_list|,
name|enum
name|rtx_code
modifier|*
name|first_code
parameter_list|,
name|enum
name|rtx_code
modifier|*
name|second_code
parameter_list|)
block|{
operator|*
name|first_code
operator|=
name|code
expr_stmt|;
operator|*
name|bypass_code
operator|=
name|UNKNOWN
expr_stmt|;
operator|*
name|second_code
operator|=
name|UNKNOWN
expr_stmt|;
comment|/* The fcomi comparison sets flags as follows:       cmp    ZF PF CF>      0  0  0<      0  0  1      =      1  0  0      un     1  1  1 */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|GT
case|:
comment|/* GTU - CF=0& ZF=0 */
case|case
name|GE
case|:
comment|/* GEU - CF=0 */
case|case
name|ORDERED
case|:
comment|/* PF=0 */
case|case
name|UNORDERED
case|:
comment|/* PF=1 */
case|case
name|UNEQ
case|:
comment|/* EQ - ZF=1 */
case|case
name|UNLT
case|:
comment|/* LTU - CF=1 */
case|case
name|UNLE
case|:
comment|/* LEU - CF=1 | ZF=1 */
case|case
name|LTGT
case|:
comment|/* EQ - ZF=0 */
break|break;
case|case
name|LT
case|:
comment|/* LTU - CF=1 - fails on unordered */
operator|*
name|first_code
operator|=
name|UNLT
expr_stmt|;
operator|*
name|bypass_code
operator|=
name|UNORDERED
expr_stmt|;
break|break;
case|case
name|LE
case|:
comment|/* LEU - CF=1 | ZF=1 - fails on unordered */
operator|*
name|first_code
operator|=
name|UNLE
expr_stmt|;
operator|*
name|bypass_code
operator|=
name|UNORDERED
expr_stmt|;
break|break;
case|case
name|EQ
case|:
comment|/* EQ - ZF=1 - fails on unordered */
operator|*
name|first_code
operator|=
name|UNEQ
expr_stmt|;
operator|*
name|bypass_code
operator|=
name|UNORDERED
expr_stmt|;
break|break;
case|case
name|NE
case|:
comment|/* NE - ZF=0 - fails on unordered */
operator|*
name|first_code
operator|=
name|LTGT
expr_stmt|;
operator|*
name|second_code
operator|=
name|UNORDERED
expr_stmt|;
break|break;
case|case
name|UNGE
case|:
comment|/* GEU - CF=0 - fails on unordered */
operator|*
name|first_code
operator|=
name|GE
expr_stmt|;
operator|*
name|second_code
operator|=
name|UNORDERED
expr_stmt|;
break|break;
case|case
name|UNGT
case|:
comment|/* GTU - CF=0& ZF=0 - fails on unordered */
operator|*
name|first_code
operator|=
name|GT
expr_stmt|;
operator|*
name|second_code
operator|=
name|UNORDERED
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TARGET_IEEE_FP
condition|)
block|{
operator|*
name|second_code
operator|=
name|UNKNOWN
expr_stmt|;
operator|*
name|bypass_code
operator|=
name|UNKNOWN
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return cost of comparison done fcom + arithmetics operations on AX.    All following functions do use number of instructions as a cost metrics.    In future this should be tweaked to compute bytes for optimize_size and    take into account performance of various instructions on various CPUs.  */
end_comment

begin_function
specifier|static
name|int
name|ix86_fp_comparison_arithmetics_cost
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|)
block|{
if|if
condition|(
operator|!
name|TARGET_IEEE_FP
condition|)
return|return
literal|4
return|;
comment|/* The cost of code output by ix86_expand_fp_compare.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|UNLE
case|:
case|case
name|UNLT
case|:
case|case
name|LTGT
case|:
case|case
name|GT
case|:
case|case
name|GE
case|:
case|case
name|UNORDERED
case|:
case|case
name|ORDERED
case|:
case|case
name|UNEQ
case|:
return|return
literal|4
return|;
break|break;
case|case
name|LT
case|:
case|case
name|NE
case|:
case|case
name|EQ
case|:
case|case
name|UNGE
case|:
return|return
literal|5
return|;
break|break;
case|case
name|LE
case|:
case|case
name|UNGT
case|:
return|return
literal|6
return|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return cost of comparison done using fcomi operation.    See ix86_fp_comparison_arithmetics_cost for the metrics.  */
end_comment

begin_function
specifier|static
name|int
name|ix86_fp_comparison_fcomi_cost
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|)
block|{
name|enum
name|rtx_code
name|bypass_code
decl_stmt|,
name|first_code
decl_stmt|,
name|second_code
decl_stmt|;
comment|/* Return arbitrarily high cost when instruction is not supported - this      prevents gcc from using it.  */
if|if
condition|(
operator|!
name|TARGET_CMOVE
condition|)
return|return
literal|1024
return|;
name|ix86_fp_comparison_codes
argument_list|(
name|code
argument_list|,
operator|&
name|bypass_code
argument_list|,
operator|&
name|first_code
argument_list|,
operator|&
name|second_code
argument_list|)
expr_stmt|;
return|return
operator|(
name|bypass_code
operator|!=
name|UNKNOWN
operator|||
name|second_code
operator|!=
name|UNKNOWN
operator|)
operator|+
literal|2
return|;
block|}
end_function

begin_comment
comment|/* Return cost of comparison done using sahf operation.    See ix86_fp_comparison_arithmetics_cost for the metrics.  */
end_comment

begin_function
specifier|static
name|int
name|ix86_fp_comparison_sahf_cost
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|)
block|{
name|enum
name|rtx_code
name|bypass_code
decl_stmt|,
name|first_code
decl_stmt|,
name|second_code
decl_stmt|;
comment|/* Return arbitrarily high cost when instruction is not preferred - this      avoids gcc from using it.  */
if|if
condition|(
operator|!
name|TARGET_USE_SAHF
operator|&&
operator|!
name|optimize_size
condition|)
return|return
literal|1024
return|;
name|ix86_fp_comparison_codes
argument_list|(
name|code
argument_list|,
operator|&
name|bypass_code
argument_list|,
operator|&
name|first_code
argument_list|,
operator|&
name|second_code
argument_list|)
expr_stmt|;
return|return
operator|(
name|bypass_code
operator|!=
name|UNKNOWN
operator|||
name|second_code
operator|!=
name|UNKNOWN
operator|)
operator|+
literal|3
return|;
block|}
end_function

begin_comment
comment|/* Compute cost of the comparison done using any method.    See ix86_fp_comparison_arithmetics_cost for the metrics.  */
end_comment

begin_function
specifier|static
name|int
name|ix86_fp_comparison_cost
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|)
block|{
name|int
name|fcomi_cost
decl_stmt|,
name|sahf_cost
decl_stmt|,
name|arithmetics_cost
init|=
literal|1024
decl_stmt|;
name|int
name|min
decl_stmt|;
name|fcomi_cost
operator|=
name|ix86_fp_comparison_fcomi_cost
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|sahf_cost
operator|=
name|ix86_fp_comparison_sahf_cost
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|min
operator|=
name|arithmetics_cost
operator|=
name|ix86_fp_comparison_arithmetics_cost
argument_list|(
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|min
operator|>
name|sahf_cost
condition|)
name|min
operator|=
name|sahf_cost
expr_stmt|;
if|if
condition|(
name|min
operator|>
name|fcomi_cost
condition|)
name|min
operator|=
name|fcomi_cost
expr_stmt|;
return|return
name|min
return|;
block|}
end_function

begin_comment
comment|/* Generate insn patterns to do a floating point compare of OPERANDS.  */
end_comment

begin_function
specifier|static
name|rtx
name|ix86_expand_fp_compare
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|rtx
name|op0
parameter_list|,
name|rtx
name|op1
parameter_list|,
name|rtx
name|scratch
parameter_list|,
name|rtx
modifier|*
name|second_test
parameter_list|,
name|rtx
modifier|*
name|bypass_test
parameter_list|)
block|{
name|enum
name|machine_mode
name|fpcmp_mode
decl_stmt|,
name|intcmp_mode
decl_stmt|;
name|rtx
name|tmp
decl_stmt|,
name|tmp2
decl_stmt|;
name|int
name|cost
init|=
name|ix86_fp_comparison_cost
argument_list|(
name|code
argument_list|)
decl_stmt|;
name|enum
name|rtx_code
name|bypass_code
decl_stmt|,
name|first_code
decl_stmt|,
name|second_code
decl_stmt|;
name|fpcmp_mode
operator|=
name|ix86_fp_compare_mode
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|code
operator|=
name|ix86_prepare_fp_compare_args
argument_list|(
name|code
argument_list|,
operator|&
name|op0
argument_list|,
operator|&
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|second_test
condition|)
operator|*
name|second_test
operator|=
name|NULL_RTX
expr_stmt|;
if|if
condition|(
name|bypass_test
condition|)
operator|*
name|bypass_test
operator|=
name|NULL_RTX
expr_stmt|;
name|ix86_fp_comparison_codes
argument_list|(
name|code
argument_list|,
operator|&
name|bypass_code
argument_list|,
operator|&
name|first_code
argument_list|,
operator|&
name|second_code
argument_list|)
expr_stmt|;
comment|/* Do fcomi/sahf based test when profitable.  */
if|if
condition|(
operator|(
name|bypass_code
operator|==
name|UNKNOWN
operator|||
name|bypass_test
operator|)
operator|&&
operator|(
name|second_code
operator|==
name|UNKNOWN
operator|||
name|second_test
operator|)
operator|&&
name|ix86_fp_comparison_arithmetics_cost
argument_list|(
name|code
argument_list|)
operator|>
name|cost
condition|)
block|{
if|if
condition|(
name|TARGET_CMOVE
condition|)
block|{
name|tmp
operator|=
name|gen_rtx_COMPARE
argument_list|(
name|fpcmp_mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|fpcmp_mode
argument_list|,
name|FLAGS_REG
argument_list|)
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tmp
operator|=
name|gen_rtx_COMPARE
argument_list|(
name|fpcmp_mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|tmp2
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|HImode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|tmp
argument_list|)
argument_list|,
name|UNSPEC_FNSTSW
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|scratch
condition|)
name|scratch
operator|=
name|gen_reg_rtx
argument_list|(
name|HImode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|scratch
argument_list|,
name|tmp2
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_x86_sahf_1
argument_list|(
name|scratch
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* The FP codes work out to act like unsigned.  */
name|intcmp_mode
operator|=
name|fpcmp_mode
expr_stmt|;
name|code
operator|=
name|first_code
expr_stmt|;
if|if
condition|(
name|bypass_code
operator|!=
name|UNKNOWN
condition|)
operator|*
name|bypass_test
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|bypass_code
argument_list|,
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|intcmp_mode
argument_list|,
name|FLAGS_REG
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|second_code
operator|!=
name|UNKNOWN
condition|)
operator|*
name|second_test
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|second_code
argument_list|,
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|intcmp_mode
argument_list|,
name|FLAGS_REG
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Sadness wrt reg-stack pops killing fpsr -- gotta get fnstsw first.  */
name|tmp
operator|=
name|gen_rtx_COMPARE
argument_list|(
name|fpcmp_mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|tmp2
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|HImode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|tmp
argument_list|)
argument_list|,
name|UNSPEC_FNSTSW
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|scratch
condition|)
name|scratch
operator|=
name|gen_reg_rtx
argument_list|(
name|HImode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|scratch
argument_list|,
name|tmp2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* In the unordered case, we have to check C2 for NaN's, which 	 doesn't happen to work out to anything nice combination-wise. 	 So do some bit twiddling on the value we've got in AH to come 	 up with an appropriate set of condition codes.  */
name|intcmp_mode
operator|=
name|CCNOmode
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|GT
case|:
case|case
name|UNGT
case|:
if|if
condition|(
name|code
operator|==
name|GT
operator|||
operator|!
name|TARGET_IEEE_FP
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_testqi_ext_ccno_0
argument_list|(
name|scratch
argument_list|,
name|GEN_INT
argument_list|(
literal|0x45
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|=
name|EQ
expr_stmt|;
block|}
else|else
block|{
name|emit_insn
argument_list|(
name|gen_andqi_ext_0
argument_list|(
name|scratch
argument_list|,
name|scratch
argument_list|,
name|GEN_INT
argument_list|(
literal|0x45
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_addqi_ext_1
argument_list|(
name|scratch
argument_list|,
name|scratch
argument_list|,
name|constm1_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_cmpqi_ext_3
argument_list|(
name|scratch
argument_list|,
name|GEN_INT
argument_list|(
literal|0x44
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|intcmp_mode
operator|=
name|CCmode
expr_stmt|;
name|code
operator|=
name|GEU
expr_stmt|;
block|}
break|break;
case|case
name|LT
case|:
case|case
name|UNLT
case|:
if|if
condition|(
name|code
operator|==
name|LT
operator|&&
name|TARGET_IEEE_FP
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_andqi_ext_0
argument_list|(
name|scratch
argument_list|,
name|scratch
argument_list|,
name|GEN_INT
argument_list|(
literal|0x45
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_cmpqi_ext_3
argument_list|(
name|scratch
argument_list|,
name|GEN_INT
argument_list|(
literal|0x01
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|intcmp_mode
operator|=
name|CCmode
expr_stmt|;
name|code
operator|=
name|EQ
expr_stmt|;
block|}
else|else
block|{
name|emit_insn
argument_list|(
name|gen_testqi_ext_ccno_0
argument_list|(
name|scratch
argument_list|,
name|GEN_INT
argument_list|(
literal|0x01
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|=
name|NE
expr_stmt|;
block|}
break|break;
case|case
name|GE
case|:
case|case
name|UNGE
case|:
if|if
condition|(
name|code
operator|==
name|GE
operator|||
operator|!
name|TARGET_IEEE_FP
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_testqi_ext_ccno_0
argument_list|(
name|scratch
argument_list|,
name|GEN_INT
argument_list|(
literal|0x05
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|=
name|EQ
expr_stmt|;
block|}
else|else
block|{
name|emit_insn
argument_list|(
name|gen_andqi_ext_0
argument_list|(
name|scratch
argument_list|,
name|scratch
argument_list|,
name|GEN_INT
argument_list|(
literal|0x45
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_xorqi_cc_ext_1
argument_list|(
name|scratch
argument_list|,
name|scratch
argument_list|,
name|GEN_INT
argument_list|(
literal|0x01
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|=
name|NE
expr_stmt|;
block|}
break|break;
case|case
name|LE
case|:
case|case
name|UNLE
case|:
if|if
condition|(
name|code
operator|==
name|LE
operator|&&
name|TARGET_IEEE_FP
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_andqi_ext_0
argument_list|(
name|scratch
argument_list|,
name|scratch
argument_list|,
name|GEN_INT
argument_list|(
literal|0x45
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_addqi_ext_1
argument_list|(
name|scratch
argument_list|,
name|scratch
argument_list|,
name|constm1_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_cmpqi_ext_3
argument_list|(
name|scratch
argument_list|,
name|GEN_INT
argument_list|(
literal|0x40
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|intcmp_mode
operator|=
name|CCmode
expr_stmt|;
name|code
operator|=
name|LTU
expr_stmt|;
block|}
else|else
block|{
name|emit_insn
argument_list|(
name|gen_testqi_ext_ccno_0
argument_list|(
name|scratch
argument_list|,
name|GEN_INT
argument_list|(
literal|0x45
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|=
name|NE
expr_stmt|;
block|}
break|break;
case|case
name|EQ
case|:
case|case
name|UNEQ
case|:
if|if
condition|(
name|code
operator|==
name|EQ
operator|&&
name|TARGET_IEEE_FP
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_andqi_ext_0
argument_list|(
name|scratch
argument_list|,
name|scratch
argument_list|,
name|GEN_INT
argument_list|(
literal|0x45
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_cmpqi_ext_3
argument_list|(
name|scratch
argument_list|,
name|GEN_INT
argument_list|(
literal|0x40
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|intcmp_mode
operator|=
name|CCmode
expr_stmt|;
name|code
operator|=
name|EQ
expr_stmt|;
block|}
else|else
block|{
name|emit_insn
argument_list|(
name|gen_testqi_ext_ccno_0
argument_list|(
name|scratch
argument_list|,
name|GEN_INT
argument_list|(
literal|0x40
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|=
name|NE
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|NE
case|:
case|case
name|LTGT
case|:
if|if
condition|(
name|code
operator|==
name|NE
operator|&&
name|TARGET_IEEE_FP
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_andqi_ext_0
argument_list|(
name|scratch
argument_list|,
name|scratch
argument_list|,
name|GEN_INT
argument_list|(
literal|0x45
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_xorqi_cc_ext_1
argument_list|(
name|scratch
argument_list|,
name|scratch
argument_list|,
name|GEN_INT
argument_list|(
literal|0x40
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|=
name|NE
expr_stmt|;
block|}
else|else
block|{
name|emit_insn
argument_list|(
name|gen_testqi_ext_ccno_0
argument_list|(
name|scratch
argument_list|,
name|GEN_INT
argument_list|(
literal|0x40
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|=
name|EQ
expr_stmt|;
block|}
break|break;
case|case
name|UNORDERED
case|:
name|emit_insn
argument_list|(
name|gen_testqi_ext_ccno_0
argument_list|(
name|scratch
argument_list|,
name|GEN_INT
argument_list|(
literal|0x04
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|=
name|NE
expr_stmt|;
break|break;
case|case
name|ORDERED
case|:
name|emit_insn
argument_list|(
name|gen_testqi_ext_ccno_0
argument_list|(
name|scratch
argument_list|,
name|GEN_INT
argument_list|(
literal|0x04
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|=
name|EQ
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Return the test that should be put into the flags user, i.e.      the bcc, scc, or cmov instruction.  */
return|return
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|intcmp_mode
argument_list|,
name|FLAGS_REG
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
return|;
block|}
end_function

begin_function
name|rtx
name|ix86_expand_compare
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|rtx
modifier|*
name|second_test
parameter_list|,
name|rtx
modifier|*
name|bypass_test
parameter_list|)
block|{
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|,
name|ret
decl_stmt|;
name|op0
operator|=
name|ix86_compare_op0
expr_stmt|;
name|op1
operator|=
name|ix86_compare_op1
expr_stmt|;
if|if
condition|(
name|second_test
condition|)
operator|*
name|second_test
operator|=
name|NULL_RTX
expr_stmt|;
if|if
condition|(
name|bypass_test
condition|)
operator|*
name|bypass_test
operator|=
name|NULL_RTX
expr_stmt|;
if|if
condition|(
name|ix86_compare_emitted
condition|)
block|{
name|ret
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|VOIDmode
argument_list|,
name|ix86_compare_emitted
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|ix86_compare_emitted
operator|=
name|NULL_RTX
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SCALAR_FLOAT_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
condition|)
name|ret
operator|=
name|ix86_expand_fp_compare
argument_list|(
name|code
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|NULL_RTX
argument_list|,
name|second_test
argument_list|,
name|bypass_test
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|ix86_expand_int_compare
argument_list|(
name|code
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Return true if the CODE will result in nontrivial jump sequence.  */
end_comment

begin_function
name|bool
name|ix86_fp_jump_nontrivial_p
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|)
block|{
name|enum
name|rtx_code
name|bypass_code
decl_stmt|,
name|first_code
decl_stmt|,
name|second_code
decl_stmt|;
if|if
condition|(
operator|!
name|TARGET_CMOVE
condition|)
return|return
name|true
return|;
name|ix86_fp_comparison_codes
argument_list|(
name|code
argument_list|,
operator|&
name|bypass_code
argument_list|,
operator|&
name|first_code
argument_list|,
operator|&
name|second_code
argument_list|)
expr_stmt|;
return|return
name|bypass_code
operator|!=
name|UNKNOWN
operator|||
name|second_code
operator|!=
name|UNKNOWN
return|;
block|}
end_function

begin_function
name|void
name|ix86_expand_branch
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|rtx
name|label
parameter_list|)
block|{
name|rtx
name|tmp
decl_stmt|;
comment|/* If we have emitted a compare insn, go straight to simple.      ix86_expand_compare won't emit anything if ix86_compare_emitted      is non NULL.  */
if|if
condition|(
name|ix86_compare_emitted
condition|)
goto|goto
name|simple
goto|;
switch|switch
condition|(
name|GET_MODE
argument_list|(
name|ix86_compare_op0
argument_list|)
condition|)
block|{
case|case
name|QImode
case|:
case|case
name|HImode
case|:
case|case
name|SImode
case|:
name|simple
label|:
name|tmp
operator|=
name|ix86_expand_compare
argument_list|(
name|code
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|VOIDmode
argument_list|,
name|tmp
argument_list|,
name|gen_rtx_LABEL_REF
argument_list|(
name|VOIDmode
argument_list|,
name|label
argument_list|)
argument_list|,
name|pc_rtx
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|pc_rtx
argument_list|,
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|SFmode
case|:
case|case
name|DFmode
case|:
case|case
name|XFmode
case|:
block|{
name|rtvec
name|vec
decl_stmt|;
name|int
name|use_fcomi
decl_stmt|;
name|enum
name|rtx_code
name|bypass_code
decl_stmt|,
name|first_code
decl_stmt|,
name|second_code
decl_stmt|;
name|code
operator|=
name|ix86_prepare_fp_compare_args
argument_list|(
name|code
argument_list|,
operator|&
name|ix86_compare_op0
argument_list|,
operator|&
name|ix86_compare_op1
argument_list|)
expr_stmt|;
name|ix86_fp_comparison_codes
argument_list|(
name|code
argument_list|,
operator|&
name|bypass_code
argument_list|,
operator|&
name|first_code
argument_list|,
operator|&
name|second_code
argument_list|)
expr_stmt|;
comment|/* Check whether we will use the natural sequence with one jump.  If 	   so, we can expand jump early.  Otherwise delay expansion by 	   creating compound insn to not confuse optimizers.  */
if|if
condition|(
name|bypass_code
operator|==
name|UNKNOWN
operator|&&
name|second_code
operator|==
name|UNKNOWN
operator|&&
name|TARGET_CMOVE
condition|)
block|{
name|ix86_split_fp_branch
argument_list|(
name|code
argument_list|,
name|ix86_compare_op0
argument_list|,
name|ix86_compare_op1
argument_list|,
name|gen_rtx_LABEL_REF
argument_list|(
name|VOIDmode
argument_list|,
name|label
argument_list|)
argument_list|,
name|pc_rtx
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tmp
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|VOIDmode
argument_list|,
name|ix86_compare_op0
argument_list|,
name|ix86_compare_op1
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|VOIDmode
argument_list|,
name|tmp
argument_list|,
name|gen_rtx_LABEL_REF
argument_list|(
name|VOIDmode
argument_list|,
name|label
argument_list|)
argument_list|,
name|pc_rtx
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|pc_rtx
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|use_fcomi
operator|=
name|ix86_use_fcomi_compare
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|vec
operator|=
name|rtvec_alloc
argument_list|(
literal|3
operator|+
operator|!
name|use_fcomi
argument_list|)
expr_stmt|;
name|RTVEC_ELT
argument_list|(
name|vec
argument_list|,
literal|0
argument_list|)
operator|=
name|tmp
expr_stmt|;
name|RTVEC_ELT
argument_list|(
name|vec
argument_list|,
literal|1
argument_list|)
operator|=
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|CCFPmode
argument_list|,
literal|18
argument_list|)
argument_list|)
expr_stmt|;
name|RTVEC_ELT
argument_list|(
name|vec
argument_list|,
literal|2
argument_list|)
operator|=
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|CCFPmode
argument_list|,
literal|17
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|use_fcomi
condition|)
name|RTVEC_ELT
argument_list|(
name|vec
argument_list|,
literal|3
argument_list|)
operator|=
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_SCRATCH
argument_list|(
name|HImode
argument_list|)
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|vec
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
case|case
name|DImode
case|:
if|if
condition|(
name|TARGET_64BIT
condition|)
goto|goto
name|simple
goto|;
case|case
name|TImode
case|:
comment|/* Expand DImode branch into multiple compare+branch.  */
block|{
name|rtx
name|lo
index|[
literal|2
index|]
decl_stmt|,
name|hi
index|[
literal|2
index|]
decl_stmt|,
name|label2
decl_stmt|;
name|enum
name|rtx_code
name|code1
decl_stmt|,
name|code2
decl_stmt|,
name|code3
decl_stmt|;
name|enum
name|machine_mode
name|submode
decl_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|ix86_compare_op0
argument_list|)
operator|&&
operator|!
name|CONSTANT_P
argument_list|(
name|ix86_compare_op1
argument_list|)
condition|)
block|{
name|tmp
operator|=
name|ix86_compare_op0
expr_stmt|;
name|ix86_compare_op0
operator|=
name|ix86_compare_op1
expr_stmt|;
name|ix86_compare_op1
operator|=
name|tmp
expr_stmt|;
name|code
operator|=
name|swap_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_MODE
argument_list|(
name|ix86_compare_op0
argument_list|)
operator|==
name|DImode
condition|)
block|{
name|split_di
argument_list|(
operator|&
name|ix86_compare_op0
argument_list|,
literal|1
argument_list|,
name|lo
operator|+
literal|0
argument_list|,
name|hi
operator|+
literal|0
argument_list|)
expr_stmt|;
name|split_di
argument_list|(
operator|&
name|ix86_compare_op1
argument_list|,
literal|1
argument_list|,
name|lo
operator|+
literal|1
argument_list|,
name|hi
operator|+
literal|1
argument_list|)
expr_stmt|;
name|submode
operator|=
name|SImode
expr_stmt|;
block|}
else|else
block|{
name|split_ti
argument_list|(
operator|&
name|ix86_compare_op0
argument_list|,
literal|1
argument_list|,
name|lo
operator|+
literal|0
argument_list|,
name|hi
operator|+
literal|0
argument_list|)
expr_stmt|;
name|split_ti
argument_list|(
operator|&
name|ix86_compare_op1
argument_list|,
literal|1
argument_list|,
name|lo
operator|+
literal|1
argument_list|,
name|hi
operator|+
literal|1
argument_list|)
expr_stmt|;
name|submode
operator|=
name|DImode
expr_stmt|;
block|}
comment|/* When comparing for equality, we can use (hi0^hi1)|(lo0^lo1) to 	   avoid two branches.  This costs one extra insn, so disable when 	   optimizing for size.  */
if|if
condition|(
operator|(
name|code
operator|==
name|EQ
operator|||
name|code
operator|==
name|NE
operator|)
operator|&&
operator|(
operator|!
name|optimize_size
operator|||
name|hi
index|[
literal|1
index|]
operator|==
name|const0_rtx
operator|||
name|lo
index|[
literal|1
index|]
operator|==
name|const0_rtx
operator|)
condition|)
block|{
name|rtx
name|xor0
decl_stmt|,
name|xor1
decl_stmt|;
name|xor1
operator|=
name|hi
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|hi
index|[
literal|1
index|]
operator|!=
name|const0_rtx
condition|)
name|xor1
operator|=
name|expand_binop
argument_list|(
name|submode
argument_list|,
name|xor_optab
argument_list|,
name|xor1
argument_list|,
name|hi
index|[
literal|1
index|]
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
name|xor0
operator|=
name|lo
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|lo
index|[
literal|1
index|]
operator|!=
name|const0_rtx
condition|)
name|xor0
operator|=
name|expand_binop
argument_list|(
name|submode
argument_list|,
name|xor_optab
argument_list|,
name|xor0
argument_list|,
name|lo
index|[
literal|1
index|]
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|expand_binop
argument_list|(
name|submode
argument_list|,
name|ior_optab
argument_list|,
name|xor1
argument_list|,
name|xor0
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
name|ix86_compare_op0
operator|=
name|tmp
expr_stmt|;
name|ix86_compare_op1
operator|=
name|const0_rtx
expr_stmt|;
name|ix86_expand_branch
argument_list|(
name|code
argument_list|,
name|label
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Otherwise, if we are doing less-than or greater-or-equal-than, 	   op1 is a constant and the low word is zero, then we can just 	   examine the high word.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|hi
index|[
literal|1
index|]
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|lo
index|[
literal|1
index|]
operator|==
name|const0_rtx
condition|)
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LT
case|:
case|case
name|LTU
case|:
case|case
name|GE
case|:
case|case
name|GEU
case|:
name|ix86_compare_op0
operator|=
name|hi
index|[
literal|0
index|]
expr_stmt|;
name|ix86_compare_op1
operator|=
name|hi
index|[
literal|1
index|]
expr_stmt|;
name|ix86_expand_branch
argument_list|(
name|code
argument_list|,
name|label
argument_list|)
expr_stmt|;
return|return;
default|default:
break|break;
block|}
comment|/* Otherwise, we need two or three jumps.  */
name|label2
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|code1
operator|=
name|code
expr_stmt|;
name|code2
operator|=
name|swap_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|code3
operator|=
name|unsigned_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LT
case|:
case|case
name|GT
case|:
case|case
name|LTU
case|:
case|case
name|GTU
case|:
break|break;
case|case
name|LE
case|:
name|code1
operator|=
name|LT
expr_stmt|;
name|code2
operator|=
name|GT
expr_stmt|;
break|break;
case|case
name|GE
case|:
name|code1
operator|=
name|GT
expr_stmt|;
name|code2
operator|=
name|LT
expr_stmt|;
break|break;
case|case
name|LEU
case|:
name|code1
operator|=
name|LTU
expr_stmt|;
name|code2
operator|=
name|GTU
expr_stmt|;
break|break;
case|case
name|GEU
case|:
name|code1
operator|=
name|GTU
expr_stmt|;
name|code2
operator|=
name|LTU
expr_stmt|;
break|break;
case|case
name|EQ
case|:
name|code1
operator|=
name|UNKNOWN
expr_stmt|;
name|code2
operator|=
name|NE
expr_stmt|;
break|break;
case|case
name|NE
case|:
name|code2
operator|=
name|UNKNOWN
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
comment|/* 	 * a< b => 	 *    if (hi(a)< hi(b)) goto true; 	 *    if (hi(a)> hi(b)) goto false; 	 *    if (lo(a)< lo(b)) goto true; 	 *  false: 	 */
name|ix86_compare_op0
operator|=
name|hi
index|[
literal|0
index|]
expr_stmt|;
name|ix86_compare_op1
operator|=
name|hi
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|code1
operator|!=
name|UNKNOWN
condition|)
name|ix86_expand_branch
argument_list|(
name|code1
argument_list|,
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
name|code2
operator|!=
name|UNKNOWN
condition|)
name|ix86_expand_branch
argument_list|(
name|code2
argument_list|,
name|label2
argument_list|)
expr_stmt|;
name|ix86_compare_op0
operator|=
name|lo
index|[
literal|0
index|]
expr_stmt|;
name|ix86_compare_op1
operator|=
name|lo
index|[
literal|1
index|]
expr_stmt|;
name|ix86_expand_branch
argument_list|(
name|code3
argument_list|,
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
name|code2
operator|!=
name|UNKNOWN
condition|)
name|emit_label
argument_list|(
name|label2
argument_list|)
expr_stmt|;
return|return;
block|}
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Split branch based on floating point condition.  */
end_comment

begin_function
name|void
name|ix86_split_fp_branch
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|rtx
name|op1
parameter_list|,
name|rtx
name|op2
parameter_list|,
name|rtx
name|target1
parameter_list|,
name|rtx
name|target2
parameter_list|,
name|rtx
name|tmp
parameter_list|,
name|rtx
name|pushed
parameter_list|)
block|{
name|rtx
name|second
decl_stmt|,
name|bypass
decl_stmt|;
name|rtx
name|label
init|=
name|NULL_RTX
decl_stmt|;
name|rtx
name|condition
decl_stmt|;
name|int
name|bypass_probability
init|=
operator|-
literal|1
decl_stmt|,
name|second_probability
init|=
operator|-
literal|1
decl_stmt|,
name|probability
init|=
operator|-
literal|1
decl_stmt|;
name|rtx
name|i
decl_stmt|;
if|if
condition|(
name|target2
operator|!=
name|pc_rtx
condition|)
block|{
name|rtx
name|tmp
init|=
name|target2
decl_stmt|;
name|code
operator|=
name|reverse_condition_maybe_unordered
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|target2
operator|=
name|target1
expr_stmt|;
name|target1
operator|=
name|tmp
expr_stmt|;
block|}
name|condition
operator|=
name|ix86_expand_fp_compare
argument_list|(
name|code
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|,
name|tmp
argument_list|,
operator|&
name|second
argument_list|,
operator|&
name|bypass
argument_list|)
expr_stmt|;
comment|/* Remove pushed operand from stack.  */
if|if
condition|(
name|pushed
condition|)
name|ix86_free_from_memory
argument_list|(
name|GET_MODE
argument_list|(
name|pushed
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|split_branch_probability
operator|>=
literal|0
condition|)
block|{
comment|/* Distribute the probabilities across the jumps. 	 Assume the BYPASS and SECOND to be always test 	 for UNORDERED.  */
name|probability
operator|=
name|split_branch_probability
expr_stmt|;
comment|/* Value of 1 is low enough to make no need for probability 	 to be updated.  Later we may run some experiments and see 	 if unordered values are more frequent in practice.  */
if|if
condition|(
name|bypass
condition|)
name|bypass_probability
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|second
condition|)
name|second_probability
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|bypass
operator|!=
name|NULL_RTX
condition|)
block|{
name|label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|i
operator|=
name|emit_jump_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|pc_rtx
argument_list|,
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|VOIDmode
argument_list|,
name|bypass
argument_list|,
name|gen_rtx_LABEL_REF
argument_list|(
name|VOIDmode
argument_list|,
name|label
argument_list|)
argument_list|,
name|pc_rtx
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bypass_probability
operator|>=
literal|0
condition|)
name|REG_NOTES
argument_list|(
name|i
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_BR_PROB
argument_list|,
name|GEN_INT
argument_list|(
name|bypass_probability
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
name|emit_jump_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|pc_rtx
argument_list|,
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|VOIDmode
argument_list|,
name|condition
argument_list|,
name|target1
argument_list|,
name|target2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|probability
operator|>=
literal|0
condition|)
name|REG_NOTES
argument_list|(
name|i
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_BR_PROB
argument_list|,
name|GEN_INT
argument_list|(
name|probability
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|second
operator|!=
name|NULL_RTX
condition|)
block|{
name|i
operator|=
name|emit_jump_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|pc_rtx
argument_list|,
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|VOIDmode
argument_list|,
name|second
argument_list|,
name|target1
argument_list|,
name|target2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|second_probability
operator|>=
literal|0
condition|)
name|REG_NOTES
argument_list|(
name|i
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_BR_PROB
argument_list|,
name|GEN_INT
argument_list|(
name|second_probability
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|label
operator|!=
name|NULL_RTX
condition|)
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ix86_expand_setcc
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|rtx
name|dest
parameter_list|)
block|{
name|rtx
name|ret
decl_stmt|,
name|tmp
decl_stmt|,
name|tmpreg
decl_stmt|,
name|equiv
decl_stmt|;
name|rtx
name|second_test
decl_stmt|,
name|bypass_test
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|ix86_compare_op0
argument_list|)
operator|==
operator|(
name|TARGET_64BIT
condition|?
name|TImode
else|:
name|DImode
operator|)
condition|)
return|return
literal|0
return|;
comment|/* FAIL */
name|gcc_assert
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
operator|==
name|QImode
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ix86_expand_compare
argument_list|(
name|code
argument_list|,
operator|&
name|second_test
argument_list|,
operator|&
name|bypass_test
argument_list|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|ret
argument_list|,
name|QImode
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|dest
expr_stmt|;
name|tmpreg
operator|=
name|dest
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|tmp
argument_list|,
name|ret
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bypass_test
operator|||
name|second_test
condition|)
block|{
name|rtx
name|test
init|=
name|second_test
decl_stmt|;
name|int
name|bypass
init|=
literal|0
decl_stmt|;
name|rtx
name|tmp2
init|=
name|gen_reg_rtx
argument_list|(
name|QImode
argument_list|)
decl_stmt|;
if|if
condition|(
name|bypass_test
condition|)
block|{
name|gcc_assert
argument_list|(
operator|!
name|second_test
argument_list|)
expr_stmt|;
name|test
operator|=
name|bypass_test
expr_stmt|;
name|bypass
operator|=
literal|1
expr_stmt|;
name|PUT_CODE
argument_list|(
name|test
argument_list|,
name|reverse_condition_maybe_unordered
argument_list|(
name|GET_CODE
argument_list|(
name|test
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|PUT_MODE
argument_list|(
name|test
argument_list|,
name|QImode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|tmp2
argument_list|,
name|test
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bypass
condition|)
name|emit_insn
argument_list|(
name|gen_andqi3
argument_list|(
name|tmp
argument_list|,
name|tmpreg
argument_list|,
name|tmp2
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_iorqi3
argument_list|(
name|tmp
argument_list|,
name|tmpreg
argument_list|,
name|tmp2
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Attach a REG_EQUAL note describing the comparison result.  */
if|if
condition|(
name|ix86_compare_op0
operator|&&
name|ix86_compare_op1
condition|)
block|{
name|equiv
operator|=
name|simplify_gen_relational
argument_list|(
name|code
argument_list|,
name|QImode
argument_list|,
name|GET_MODE
argument_list|(
name|ix86_compare_op0
argument_list|)
argument_list|,
name|ix86_compare_op0
argument_list|,
name|ix86_compare_op1
argument_list|)
expr_stmt|;
name|set_unique_reg_note
argument_list|(
name|get_last_insn
argument_list|()
argument_list|,
name|REG_EQUAL
argument_list|,
name|equiv
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
comment|/* DONE */
block|}
end_function

begin_comment
comment|/* Expand comparison setting or clearing carry flag.  Return true when    successful and set pop for the operation.  */
end_comment

begin_function
specifier|static
name|bool
name|ix86_expand_carry_flag_compare
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|rtx
name|op0
parameter_list|,
name|rtx
name|op1
parameter_list|,
name|rtx
modifier|*
name|pop
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|VOIDmode
condition|?
name|GET_MODE
argument_list|(
name|op0
argument_list|)
else|:
name|GET_MODE
argument_list|(
name|op1
argument_list|)
decl_stmt|;
comment|/* Do not handle DImode compares that go through special path.  Also we can't      deal with FP compares yet.  This is possible to add.  */
if|if
condition|(
name|mode
operator|==
operator|(
name|TARGET_64BIT
condition|?
name|TImode
else|:
name|DImode
operator|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|rtx
name|second_test
init|=
name|NULL
decl_stmt|,
name|bypass_test
init|=
name|NULL
decl_stmt|;
name|rtx
name|compare_op
decl_stmt|,
name|compare_seq
decl_stmt|;
comment|/* Shortcut:  following common codes never translate into carry flag compares.  */
if|if
condition|(
name|code
operator|==
name|EQ
operator|||
name|code
operator|==
name|NE
operator|||
name|code
operator|==
name|UNEQ
operator|||
name|code
operator|==
name|LTGT
operator|||
name|code
operator|==
name|ORDERED
operator|||
name|code
operator|==
name|UNORDERED
condition|)
return|return
name|false
return|;
comment|/* These comparisons require zero flag; swap operands so they won't.  */
if|if
condition|(
operator|(
name|code
operator|==
name|GT
operator|||
name|code
operator|==
name|UNLE
operator|||
name|code
operator|==
name|LE
operator|||
name|code
operator|==
name|UNGT
operator|)
operator|&&
operator|!
name|TARGET_IEEE_FP
condition|)
block|{
name|rtx
name|tmp
init|=
name|op0
decl_stmt|;
name|op0
operator|=
name|op1
expr_stmt|;
name|op1
operator|=
name|tmp
expr_stmt|;
name|code
operator|=
name|swap_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
comment|/* Try to expand the comparison and verify that we end up with carry flag 	 based comparison.  This is fails to be true only when we decide to expand 	 comparison using arithmetic that is not too common scenario.  */
name|start_sequence
argument_list|()
expr_stmt|;
name|compare_op
operator|=
name|ix86_expand_fp_compare
argument_list|(
name|code
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|NULL_RTX
argument_list|,
operator|&
name|second_test
argument_list|,
operator|&
name|bypass_test
argument_list|)
expr_stmt|;
name|compare_seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
name|second_test
operator|||
name|bypass_test
condition|)
return|return
name|false
return|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|compare_op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CCFPmode
operator|||
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|compare_op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CCFPUmode
condition|)
name|code
operator|=
name|ix86_fp_compare_code_to_integer
argument_list|(
name|GET_CODE
argument_list|(
name|compare_op
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|code
operator|=
name|GET_CODE
argument_list|(
name|compare_op
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|!=
name|LTU
operator|&&
name|code
operator|!=
name|GEU
condition|)
return|return
name|false
return|;
name|emit_insn
argument_list|(
name|compare_seq
argument_list|)
expr_stmt|;
operator|*
name|pop
operator|=
name|compare_op
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
operator|!
name|INTEGRAL_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|false
return|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LTU
case|:
case|case
name|GEU
case|:
break|break;
comment|/* Convert a==0 into (unsigned)a<1.  */
case|case
name|EQ
case|:
case|case
name|NE
case|:
if|if
condition|(
name|op1
operator|!=
name|const0_rtx
condition|)
return|return
name|false
return|;
name|op1
operator|=
name|const1_rtx
expr_stmt|;
name|code
operator|=
operator|(
name|code
operator|==
name|EQ
condition|?
name|LTU
else|:
name|GEU
operator|)
expr_stmt|;
break|break;
comment|/* Convert a>b into b<a or a>=b-1.  */
case|case
name|GTU
case|:
case|case
name|LEU
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|op1
operator|=
name|gen_int_mode
argument_list|(
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|+
literal|1
argument_list|,
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Bail out on overflow.  We still can swap operands but that 	     would force loading of the constant into register.  */
if|if
condition|(
name|op1
operator|==
name|const0_rtx
operator|||
operator|!
name|x86_64_immediate_operand
argument_list|(
name|op1
argument_list|,
name|GET_MODE
argument_list|(
name|op1
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
name|code
operator|=
operator|(
name|code
operator|==
name|GTU
condition|?
name|GEU
else|:
name|LTU
operator|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|tmp
init|=
name|op1
decl_stmt|;
name|op1
operator|=
name|op0
expr_stmt|;
name|op0
operator|=
name|tmp
expr_stmt|;
name|code
operator|=
operator|(
name|code
operator|==
name|GTU
condition|?
name|LTU
else|:
name|GEU
operator|)
expr_stmt|;
block|}
break|break;
comment|/* Convert a>=0 into (unsigned)a<0x80000000.  */
case|case
name|LT
case|:
case|case
name|GE
case|:
if|if
condition|(
name|mode
operator|==
name|DImode
operator|||
name|op1
operator|!=
name|const0_rtx
condition|)
return|return
name|false
return|;
name|op1
operator|=
name|gen_int_mode
argument_list|(
literal|1
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
literal|1
operator|)
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|code
operator|=
operator|(
name|code
operator|==
name|LT
condition|?
name|GEU
else|:
name|LTU
operator|)
expr_stmt|;
break|break;
case|case
name|LE
case|:
case|case
name|GT
case|:
if|if
condition|(
name|mode
operator|==
name|DImode
operator|||
name|op1
operator|!=
name|constm1_rtx
condition|)
return|return
name|false
return|;
name|op1
operator|=
name|gen_int_mode
argument_list|(
literal|1
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
literal|1
operator|)
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|code
operator|=
operator|(
name|code
operator|==
name|LE
condition|?
name|GEU
else|:
name|LTU
operator|)
expr_stmt|;
break|break;
default|default:
return|return
name|false
return|;
block|}
comment|/* Swapping operands may cause constant to appear as first operand.  */
if|if
condition|(
operator|!
name|nonimmediate_operand
argument_list|(
name|op0
argument_list|,
name|VOIDmode
argument_list|)
condition|)
block|{
if|if
condition|(
name|no_new_pseudos
condition|)
return|return
name|false
return|;
name|op0
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
block|}
name|ix86_compare_op0
operator|=
name|op0
expr_stmt|;
name|ix86_compare_op1
operator|=
name|op1
expr_stmt|;
operator|*
name|pop
operator|=
name|ix86_expand_compare
argument_list|(
name|code
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
operator|*
name|pop
argument_list|)
operator|==
name|LTU
operator|||
name|GET_CODE
argument_list|(
operator|*
name|pop
argument_list|)
operator|==
name|GEU
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
name|int
name|ix86_expand_int_movcc
parameter_list|(
name|rtx
name|operands
index|[]
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
decl_stmt|,
name|compare_code
decl_stmt|;
name|rtx
name|compare_seq
decl_stmt|,
name|compare_op
decl_stmt|;
name|rtx
name|second_test
decl_stmt|,
name|bypass_test
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|bool
name|sign_bit_compare_p
init|=
name|false
decl_stmt|;
empty_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|compare_op
operator|=
name|ix86_expand_compare
argument_list|(
name|code
argument_list|,
operator|&
name|second_test
argument_list|,
operator|&
name|bypass_test
argument_list|)
expr_stmt|;
name|compare_seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|compare_code
operator|=
name|GET_CODE
argument_list|(
name|compare_op
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ix86_compare_op1
operator|==
name|const0_rtx
operator|&&
operator|(
name|code
operator|==
name|GE
operator|||
name|code
operator|==
name|LT
operator|)
operator|)
operator|||
operator|(
name|ix86_compare_op1
operator|==
name|constm1_rtx
operator|&&
operator|(
name|code
operator|==
name|GT
operator|||
name|code
operator|==
name|LE
operator|)
operator|)
condition|)
name|sign_bit_compare_p
operator|=
name|true
expr_stmt|;
comment|/* Don't attempt mode expansion here -- if we had to expand 5 or 6      HImode insns, we'd be swallowed in word prefix ops.  */
if|if
condition|(
operator|(
name|mode
operator|!=
name|HImode
operator|||
name|TARGET_FAST_PREFIX
operator|)
operator|&&
operator|(
name|mode
operator|!=
operator|(
name|TARGET_64BIT
condition|?
name|TImode
else|:
name|DImode
operator|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|operands
index|[
literal|3
index|]
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|rtx
name|out
init|=
name|operands
index|[
literal|0
index|]
decl_stmt|;
name|HOST_WIDE_INT
name|ct
init|=
name|INTVAL
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|cf
init|=
name|INTVAL
argument_list|(
name|operands
index|[
literal|3
index|]
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|diff
decl_stmt|;
name|diff
operator|=
name|ct
operator|-
name|cf
expr_stmt|;
comment|/*  Sign bit compares are better done using shifts than we do by using 	  sbb.  */
if|if
condition|(
name|sign_bit_compare_p
operator|||
name|ix86_expand_carry_flag_compare
argument_list|(
name|code
argument_list|,
name|ix86_compare_op0
argument_list|,
name|ix86_compare_op1
argument_list|,
operator|&
name|compare_op
argument_list|)
condition|)
block|{
comment|/* Detect overlap between destination and compare sources.  */
name|rtx
name|tmp
init|=
name|out
decl_stmt|;
if|if
condition|(
operator|!
name|sign_bit_compare_p
condition|)
block|{
name|bool
name|fpcmp
init|=
name|false
decl_stmt|;
name|compare_code
operator|=
name|GET_CODE
argument_list|(
name|compare_op
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|compare_op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CCFPmode
operator|||
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|compare_op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CCFPUmode
condition|)
block|{
name|fpcmp
operator|=
name|true
expr_stmt|;
name|compare_code
operator|=
name|ix86_fp_compare_code_to_integer
argument_list|(
name|compare_code
argument_list|)
expr_stmt|;
block|}
comment|/* To simplify rest of code, restrict to the GEU case.  */
if|if
condition|(
name|compare_code
operator|==
name|LTU
condition|)
block|{
name|HOST_WIDE_INT
name|tmp
init|=
name|ct
decl_stmt|;
name|ct
operator|=
name|cf
expr_stmt|;
name|cf
operator|=
name|tmp
expr_stmt|;
name|compare_code
operator|=
name|reverse_condition
argument_list|(
name|compare_code
argument_list|)
expr_stmt|;
name|code
operator|=
name|reverse_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|fpcmp
condition|)
name|PUT_CODE
argument_list|(
name|compare_op
argument_list|,
name|reverse_condition_maybe_unordered
argument_list|(
name|GET_CODE
argument_list|(
name|compare_op
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|PUT_CODE
argument_list|(
name|compare_op
argument_list|,
name|reverse_condition
argument_list|(
name|GET_CODE
argument_list|(
name|compare_op
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|diff
operator|=
name|ct
operator|-
name|cf
expr_stmt|;
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|out
argument_list|,
name|ix86_compare_op0
argument_list|)
operator|||
name|reg_overlap_mentioned_p
argument_list|(
name|out
argument_list|,
name|ix86_compare_op1
argument_list|)
condition|)
name|tmp
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|DImode
condition|)
name|emit_insn
argument_list|(
name|gen_x86_movdicc_0_m1_rex64
argument_list|(
name|tmp
argument_list|,
name|compare_op
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_x86_movsicc_0_m1
argument_list|(
name|gen_lowpart
argument_list|(
name|SImode
argument_list|,
name|tmp
argument_list|)
argument_list|,
name|compare_op
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|code
operator|==
name|GT
operator|||
name|code
operator|==
name|GE
condition|)
name|code
operator|=
name|reverse_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
else|else
block|{
name|HOST_WIDE_INT
name|tmp
init|=
name|ct
decl_stmt|;
name|ct
operator|=
name|cf
expr_stmt|;
name|cf
operator|=
name|tmp
expr_stmt|;
name|diff
operator|=
name|ct
operator|-
name|cf
expr_stmt|;
block|}
name|tmp
operator|=
name|emit_store_flag
argument_list|(
name|tmp
argument_list|,
name|code
argument_list|,
name|ix86_compare_op0
argument_list|,
name|ix86_compare_op1
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|diff
operator|==
literal|1
condition|)
block|{
comment|/* 	       * cmpl op0,op1 	       * sbbl dest,dest 	       * [addl dest, ct] 	       * 	       * Size 5 - 8. 	       */
if|if
condition|(
name|ct
condition|)
name|tmp
operator|=
name|expand_simple_binop
argument_list|(
name|mode
argument_list|,
name|PLUS
argument_list|,
name|tmp
argument_list|,
name|GEN_INT
argument_list|(
name|ct
argument_list|)
argument_list|,
name|copy_rtx
argument_list|(
name|tmp
argument_list|)
argument_list|,
literal|1
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cf
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* 	       * cmpl op0,op1 	       * sbbl dest,dest 	       * orl $ct, dest 	       * 	       * Size 8. 	       */
name|tmp
operator|=
name|expand_simple_binop
argument_list|(
name|mode
argument_list|,
name|IOR
argument_list|,
name|tmp
argument_list|,
name|GEN_INT
argument_list|(
name|ct
argument_list|)
argument_list|,
name|copy_rtx
argument_list|(
name|tmp
argument_list|)
argument_list|,
literal|1
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|diff
operator|==
operator|-
literal|1
operator|&&
name|ct
condition|)
block|{
comment|/* 	       * cmpl op0,op1 	       * sbbl dest,dest 	       * notl dest 	       * [addl dest, cf] 	       * 	       * Size 8 - 11. 	       */
name|tmp
operator|=
name|expand_simple_unop
argument_list|(
name|mode
argument_list|,
name|NOT
argument_list|,
name|tmp
argument_list|,
name|copy_rtx
argument_list|(
name|tmp
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cf
condition|)
name|tmp
operator|=
name|expand_simple_binop
argument_list|(
name|mode
argument_list|,
name|PLUS
argument_list|,
name|copy_rtx
argument_list|(
name|tmp
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|cf
argument_list|)
argument_list|,
name|copy_rtx
argument_list|(
name|tmp
argument_list|)
argument_list|,
literal|1
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 	       * cmpl op0,op1 	       * sbbl dest,dest 	       * [notl dest] 	       * andl cf - ct, dest 	       * [addl dest, ct] 	       * 	       * Size 8 - 11. 	       */
if|if
condition|(
name|cf
operator|==
literal|0
condition|)
block|{
name|cf
operator|=
name|ct
expr_stmt|;
name|ct
operator|=
literal|0
expr_stmt|;
name|tmp
operator|=
name|expand_simple_unop
argument_list|(
name|mode
argument_list|,
name|NOT
argument_list|,
name|tmp
argument_list|,
name|copy_rtx
argument_list|(
name|tmp
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|tmp
operator|=
name|expand_simple_binop
argument_list|(
name|mode
argument_list|,
name|AND
argument_list|,
name|copy_rtx
argument_list|(
name|tmp
argument_list|)
argument_list|,
name|gen_int_mode
argument_list|(
name|cf
operator|-
name|ct
argument_list|,
name|mode
argument_list|)
argument_list|,
name|copy_rtx
argument_list|(
name|tmp
argument_list|)
argument_list|,
literal|1
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ct
condition|)
name|tmp
operator|=
name|expand_simple_binop
argument_list|(
name|mode
argument_list|,
name|PLUS
argument_list|,
name|copy_rtx
argument_list|(
name|tmp
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|ct
argument_list|)
argument_list|,
name|copy_rtx
argument_list|(
name|tmp
argument_list|)
argument_list|,
literal|1
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|tmp
argument_list|,
name|out
argument_list|)
condition|)
name|emit_move_insn
argument_list|(
name|copy_rtx
argument_list|(
name|out
argument_list|)
argument_list|,
name|copy_rtx
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
comment|/* DONE */
block|}
if|if
condition|(
name|diff
operator|<
literal|0
condition|)
block|{
name|HOST_WIDE_INT
name|tmp
decl_stmt|;
name|tmp
operator|=
name|ct
operator|,
name|ct
operator|=
name|cf
operator|,
name|cf
operator|=
name|tmp
expr_stmt|;
name|diff
operator|=
operator|-
name|diff
expr_stmt|;
if|if
condition|(
name|FLOAT_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|ix86_compare_op0
argument_list|)
argument_list|)
condition|)
block|{
comment|/* We may be reversing unordered compare to normal compare, that 		 is not valid in general (we may convert non-trapping condition 		 to trapping one), however on i386 we currently emit all 		 comparisons unordered.  */
name|compare_code
operator|=
name|reverse_condition_maybe_unordered
argument_list|(
name|compare_code
argument_list|)
expr_stmt|;
name|code
operator|=
name|reverse_condition_maybe_unordered
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|compare_code
operator|=
name|reverse_condition
argument_list|(
name|compare_code
argument_list|)
expr_stmt|;
name|code
operator|=
name|reverse_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
block|}
name|compare_code
operator|=
name|UNKNOWN
expr_stmt|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|ix86_compare_op0
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|GET_CODE
argument_list|(
name|ix86_compare_op1
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|ix86_compare_op1
operator|==
name|const0_rtx
operator|&&
operator|(
name|code
operator|==
name|LT
operator|||
name|code
operator|==
name|GE
operator|)
condition|)
name|compare_code
operator|=
name|code
expr_stmt|;
elseif|else
if|if
condition|(
name|ix86_compare_op1
operator|==
name|constm1_rtx
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|LE
condition|)
name|compare_code
operator|=
name|LT
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|GT
condition|)
name|compare_code
operator|=
name|GE
expr_stmt|;
block|}
block|}
comment|/* Optimize dest = (op0< 0) ? -1 : cf.  */
if|if
condition|(
name|compare_code
operator|!=
name|UNKNOWN
operator|&&
name|GET_MODE
argument_list|(
name|ix86_compare_op0
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|out
argument_list|)
operator|&&
operator|(
name|cf
operator|==
operator|-
literal|1
operator|||
name|ct
operator|==
operator|-
literal|1
operator|)
condition|)
block|{
comment|/* If lea code below could be used, only optimize 	     if it results in a 2 insn sequence.  */
if|if
condition|(
operator|!
operator|(
name|diff
operator|==
literal|1
operator|||
name|diff
operator|==
literal|2
operator|||
name|diff
operator|==
literal|4
operator|||
name|diff
operator|==
literal|8
operator|||
name|diff
operator|==
literal|3
operator|||
name|diff
operator|==
literal|5
operator|||
name|diff
operator|==
literal|9
operator|)
operator|||
operator|(
name|compare_code
operator|==
name|LT
operator|&&
name|ct
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|compare_code
operator|==
name|GE
operator|&&
name|cf
operator|==
operator|-
literal|1
operator|)
condition|)
block|{
comment|/* 	       * notl op1	(if necessary) 	       * sarl $31, op1 	       * orl cf, op1 	       */
if|if
condition|(
name|ct
operator|!=
operator|-
literal|1
condition|)
block|{
name|cf
operator|=
name|ct
expr_stmt|;
name|ct
operator|=
operator|-
literal|1
expr_stmt|;
name|code
operator|=
name|reverse_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
name|out
operator|=
name|emit_store_flag
argument_list|(
name|out
argument_list|,
name|code
argument_list|,
name|ix86_compare_op0
argument_list|,
name|ix86_compare_op1
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|out
operator|=
name|expand_simple_binop
argument_list|(
name|mode
argument_list|,
name|IOR
argument_list|,
name|out
argument_list|,
name|GEN_INT
argument_list|(
name|cf
argument_list|)
argument_list|,
name|out
argument_list|,
literal|1
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
operator|!=
name|operands
index|[
literal|0
index|]
condition|)
name|emit_move_insn
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|out
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
comment|/* DONE */
block|}
block|}
if|if
condition|(
operator|(
name|diff
operator|==
literal|1
operator|||
name|diff
operator|==
literal|2
operator|||
name|diff
operator|==
literal|4
operator|||
name|diff
operator|==
literal|8
operator|||
name|diff
operator|==
literal|3
operator|||
name|diff
operator|==
literal|5
operator|||
name|diff
operator|==
literal|9
operator|)
operator|&&
operator|(
operator|(
name|mode
operator|!=
name|QImode
operator|&&
name|mode
operator|!=
name|HImode
operator|)
operator|||
operator|!
name|TARGET_PARTIAL_REG_STALL
operator|)
operator|&&
operator|(
name|mode
operator|!=
name|DImode
operator|||
name|x86_64_immediate_operand
argument_list|(
name|GEN_INT
argument_list|(
name|cf
argument_list|)
argument_list|,
name|VOIDmode
argument_list|)
operator|)
condition|)
block|{
comment|/* 	   * xorl dest,dest 	   * cmpl op1,op2 	   * setcc dest 	   * lea cf(dest*(ct-cf)),dest 	   * 	   * Size 14. 	   * 	   * This also catches the degenerate setcc-only case. 	   */
name|rtx
name|tmp
decl_stmt|;
name|int
name|nops
decl_stmt|;
name|out
operator|=
name|emit_store_flag
argument_list|(
name|out
argument_list|,
name|code
argument_list|,
name|ix86_compare_op0
argument_list|,
name|ix86_compare_op1
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|nops
operator|=
literal|0
expr_stmt|;
comment|/* On x86_64 the lea instruction operates on Pmode, so we need 	     to get arithmetics done in proper mode to match.  */
if|if
condition|(
name|diff
operator|==
literal|1
condition|)
name|tmp
operator|=
name|copy_rtx
argument_list|(
name|out
argument_list|)
expr_stmt|;
else|else
block|{
name|rtx
name|out1
decl_stmt|;
name|out1
operator|=
name|copy_rtx
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_MULT
argument_list|(
name|mode
argument_list|,
name|out1
argument_list|,
name|GEN_INT
argument_list|(
name|diff
operator|&
operator|~
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|nops
operator|++
expr_stmt|;
if|if
condition|(
name|diff
operator|&
literal|1
condition|)
block|{
name|tmp
operator|=
name|gen_rtx_PLUS
argument_list|(
name|mode
argument_list|,
name|tmp
argument_list|,
name|out1
argument_list|)
expr_stmt|;
name|nops
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cf
operator|!=
literal|0
condition|)
block|{
name|tmp
operator|=
name|gen_rtx_PLUS
argument_list|(
name|mode
argument_list|,
name|tmp
argument_list|,
name|GEN_INT
argument_list|(
name|cf
argument_list|)
argument_list|)
expr_stmt|;
name|nops
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|tmp
argument_list|,
name|out
argument_list|)
condition|)
block|{
if|if
condition|(
name|nops
operator|==
literal|1
condition|)
name|out
operator|=
name|force_operand
argument_list|(
name|tmp
argument_list|,
name|copy_rtx
argument_list|(
name|out
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|copy_rtx
argument_list|(
name|out
argument_list|)
argument_list|,
name|copy_rtx
argument_list|(
name|tmp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|out
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
name|emit_move_insn
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|copy_rtx
argument_list|(
name|out
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
comment|/* DONE */
block|}
comment|/*        * General case:			Jumpful:        *   xorl dest,dest		cmpl op1, op2        *   cmpl op1, op2		movl ct, dest        *   setcc dest			jcc 1f        *   decl dest			movl cf, dest        *   andl (cf-ct),dest		1:        *   addl ct,dest        *        * Size 20.			Size 14.        *        * This is reasonably steep, but branch mispredict costs are        * high on modern cpus, so consider failing only if optimizing        * for space.        */
if|if
condition|(
operator|(
operator|!
name|TARGET_CMOVE
operator|||
operator|(
name|mode
operator|==
name|QImode
operator|&&
name|TARGET_PARTIAL_REG_STALL
operator|)
operator|)
operator|&&
name|BRANCH_COST
operator|>=
literal|2
condition|)
block|{
if|if
condition|(
name|cf
operator|==
literal|0
condition|)
block|{
name|cf
operator|=
name|ct
expr_stmt|;
name|ct
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|FLOAT_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|ix86_compare_op0
argument_list|)
argument_list|)
condition|)
comment|/* We may be reversing unordered compare to normal compare, 		   that is not valid in general (we may convert non-trapping 		   condition to trapping one), however on i386 we currently 		   emit all comparisons unordered.  */
name|code
operator|=
name|reverse_condition_maybe_unordered
argument_list|(
name|code
argument_list|)
expr_stmt|;
else|else
block|{
name|code
operator|=
name|reverse_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare_code
operator|!=
name|UNKNOWN
condition|)
name|compare_code
operator|=
name|reverse_condition
argument_list|(
name|compare_code
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|compare_code
operator|!=
name|UNKNOWN
condition|)
block|{
comment|/* notl op1	(if needed) 		 sarl $31, op1 		 andl (cf-ct), op1 		 addl ct, op1  		 For x< 0 (resp. x<= -1) there will be no notl, 		 so if possible swap the constants to get rid of the 		 complement. 		 True/false will be -1/0 while code below (store flag 		 followed by decrement) is 0/-1, so the constants need 		 to be exchanged once more.  */
if|if
condition|(
name|compare_code
operator|==
name|GE
operator|||
operator|!
name|cf
condition|)
block|{
name|code
operator|=
name|reverse_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|compare_code
operator|=
name|LT
expr_stmt|;
block|}
else|else
block|{
name|HOST_WIDE_INT
name|tmp
init|=
name|cf
decl_stmt|;
name|cf
operator|=
name|ct
expr_stmt|;
name|ct
operator|=
name|tmp
expr_stmt|;
block|}
name|out
operator|=
name|emit_store_flag
argument_list|(
name|out
argument_list|,
name|code
argument_list|,
name|ix86_compare_op0
argument_list|,
name|ix86_compare_op1
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|out
operator|=
name|emit_store_flag
argument_list|(
name|out
argument_list|,
name|code
argument_list|,
name|ix86_compare_op0
argument_list|,
name|ix86_compare_op1
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|out
operator|=
name|expand_simple_binop
argument_list|(
name|mode
argument_list|,
name|PLUS
argument_list|,
name|copy_rtx
argument_list|(
name|out
argument_list|)
argument_list|,
name|constm1_rtx
argument_list|,
name|copy_rtx
argument_list|(
name|out
argument_list|)
argument_list|,
literal|1
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
block|}
name|out
operator|=
name|expand_simple_binop
argument_list|(
name|mode
argument_list|,
name|AND
argument_list|,
name|copy_rtx
argument_list|(
name|out
argument_list|)
argument_list|,
name|gen_int_mode
argument_list|(
name|cf
operator|-
name|ct
argument_list|,
name|mode
argument_list|)
argument_list|,
name|copy_rtx
argument_list|(
name|out
argument_list|)
argument_list|,
literal|1
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ct
condition|)
name|out
operator|=
name|expand_simple_binop
argument_list|(
name|mode
argument_list|,
name|PLUS
argument_list|,
name|copy_rtx
argument_list|(
name|out
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|ct
argument_list|)
argument_list|,
name|copy_rtx
argument_list|(
name|out
argument_list|)
argument_list|,
literal|1
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|out
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
name|emit_move_insn
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|copy_rtx
argument_list|(
name|out
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
comment|/* DONE */
block|}
block|}
if|if
condition|(
operator|!
name|TARGET_CMOVE
operator|||
operator|(
name|mode
operator|==
name|QImode
operator|&&
name|TARGET_PARTIAL_REG_STALL
operator|)
condition|)
block|{
comment|/* Try a few things more with specific constants and a variable.  */
name|optab
name|op
decl_stmt|;
name|rtx
name|var
decl_stmt|,
name|orig_out
decl_stmt|,
name|out
decl_stmt|,
name|tmp
decl_stmt|;
if|if
condition|(
name|BRANCH_COST
operator|<=
literal|2
condition|)
return|return
literal|0
return|;
comment|/* FAIL */
comment|/* If one of the two operands is an interesting constant, load a 	 constant with the above and mask it in with a logical operation.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|var
operator|=
name|operands
index|[
literal|3
index|]
expr_stmt|;
if|if
condition|(
name|INTVAL
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|==
literal|0
operator|&&
name|operands
index|[
literal|3
index|]
operator|!=
name|constm1_rtx
condition|)
name|operands
index|[
literal|3
index|]
operator|=
name|constm1_rtx
operator|,
name|op
operator|=
name|and_optab
expr_stmt|;
elseif|else
if|if
condition|(
name|INTVAL
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|operands
index|[
literal|3
index|]
operator|!=
name|const0_rtx
condition|)
name|operands
index|[
literal|3
index|]
operator|=
name|const0_rtx
operator|,
name|op
operator|=
name|ior_optab
expr_stmt|;
else|else
return|return
literal|0
return|;
comment|/* FAIL */
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|3
index|]
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|var
operator|=
name|operands
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|INTVAL
argument_list|(
name|operands
index|[
literal|3
index|]
argument_list|)
operator|==
literal|0
operator|&&
name|operands
index|[
literal|2
index|]
operator|!=
name|constm1_rtx
condition|)
name|operands
index|[
literal|2
index|]
operator|=
name|constm1_rtx
operator|,
name|op
operator|=
name|and_optab
expr_stmt|;
elseif|else
if|if
condition|(
name|INTVAL
argument_list|(
name|operands
index|[
literal|3
index|]
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|operands
index|[
literal|3
index|]
operator|!=
name|const0_rtx
condition|)
name|operands
index|[
literal|2
index|]
operator|=
name|const0_rtx
operator|,
name|op
operator|=
name|ior_optab
expr_stmt|;
else|else
return|return
literal|0
return|;
comment|/* FAIL */
block|}
else|else
return|return
literal|0
return|;
comment|/* FAIL */
name|orig_out
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
name|tmp
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|operands
index|[
literal|0
index|]
operator|=
name|tmp
expr_stmt|;
comment|/* Recurse to get the constant loaded.  */
if|if
condition|(
name|ix86_expand_int_movcc
argument_list|(
name|operands
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* FAIL */
comment|/* Mask in the interesting variable.  */
name|out
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|op
argument_list|,
name|var
argument_list|,
name|tmp
argument_list|,
name|orig_out
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|out
argument_list|,
name|orig_out
argument_list|)
condition|)
name|emit_move_insn
argument_list|(
name|copy_rtx
argument_list|(
name|orig_out
argument_list|)
argument_list|,
name|copy_rtx
argument_list|(
name|out
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
comment|/* DONE */
block|}
comment|/*    * For comparison with above,    *    * movl cf,dest    * movl ct,tmp    * cmpl op1,op2    * cmovcc tmp,dest    *    * Size 15.    */
if|if
condition|(
operator|!
name|nonimmediate_operand
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|,
name|mode
argument_list|)
condition|)
name|operands
index|[
literal|2
index|]
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nonimmediate_operand
argument_list|(
name|operands
index|[
literal|3
index|]
argument_list|,
name|mode
argument_list|)
condition|)
name|operands
index|[
literal|3
index|]
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|operands
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|bypass_test
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
name|rtx
name|tmp
init|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|tmp
argument_list|,
name|operands
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|operands
index|[
literal|3
index|]
operator|=
name|tmp
expr_stmt|;
block|}
if|if
condition|(
name|second_test
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
name|rtx
name|tmp
init|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|tmp
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|operands
index|[
literal|2
index|]
operator|=
name|tmp
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|register_operand
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|,
name|VOIDmode
argument_list|)
operator|&&
operator|(
name|mode
operator|==
name|QImode
operator|||
operator|!
name|register_operand
argument_list|(
name|operands
index|[
literal|3
index|]
argument_list|,
name|VOIDmode
argument_list|)
operator|)
condition|)
name|operands
index|[
literal|2
index|]
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|QImode
operator|&&
operator|!
name|register_operand
argument_list|(
name|operands
index|[
literal|3
index|]
argument_list|,
name|VOIDmode
argument_list|)
condition|)
name|operands
index|[
literal|3
index|]
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|operands
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|compare_seq
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|mode
argument_list|,
name|compare_op
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|,
name|operands
index|[
literal|3
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bypass_test
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|copy_rtx
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|mode
argument_list|,
name|bypass_test
argument_list|,
name|copy_rtx
argument_list|(
name|operands
index|[
literal|3
index|]
argument_list|)
argument_list|,
name|copy_rtx
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|second_test
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|copy_rtx
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|mode
argument_list|,
name|second_test
argument_list|,
name|copy_rtx
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
argument_list|,
name|copy_rtx
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
comment|/* DONE */
block|}
end_function

begin_comment
comment|/* Swap, force into registers, or otherwise massage the two operands    to an sse comparison with a mask result.  Thus we differ a bit from    ix86_prepare_fp_compare_args which expects to produce a flags result.     The DEST operand exists to help determine whether to commute commutative    operators.  The POP0/POP1 operands are updated in place.  The new    comparison code is returned, or UNKNOWN if not implementable.  */
end_comment

begin_function
specifier|static
name|enum
name|rtx_code
name|ix86_prepare_sse_fp_compare_args
parameter_list|(
name|rtx
name|dest
parameter_list|,
name|enum
name|rtx_code
name|code
parameter_list|,
name|rtx
modifier|*
name|pop0
parameter_list|,
name|rtx
modifier|*
name|pop1
parameter_list|)
block|{
name|rtx
name|tmp
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LTGT
case|:
case|case
name|UNEQ
case|:
comment|/* We have no LTGT as an operator.  We could implement it with 	 NE& ORDERED, but this requires an extra temporary.  It's 	 not clear that it's worth it.  */
return|return
name|UNKNOWN
return|;
case|case
name|LT
case|:
case|case
name|LE
case|:
case|case
name|UNGT
case|:
case|case
name|UNGE
case|:
comment|/* These are supported directly.  */
break|break;
case|case
name|EQ
case|:
case|case
name|NE
case|:
case|case
name|UNORDERED
case|:
case|case
name|ORDERED
case|:
comment|/* For commutative operators, try to canonicalize the destination 	 operand to be first in the comparison - this helps reload to 	 avoid extra moves.  */
if|if
condition|(
operator|!
name|dest
operator|||
operator|!
name|rtx_equal_p
argument_list|(
name|dest
argument_list|,
operator|*
name|pop1
argument_list|)
condition|)
break|break;
comment|/* FALLTHRU */
case|case
name|GE
case|:
case|case
name|GT
case|:
case|case
name|UNLE
case|:
case|case
name|UNLT
case|:
comment|/* These are not supported directly.  Swap the comparison operands 	 to transform into something that is supported.  */
name|tmp
operator|=
operator|*
name|pop0
expr_stmt|;
operator|*
name|pop0
operator|=
operator|*
name|pop1
expr_stmt|;
operator|*
name|pop1
operator|=
name|tmp
expr_stmt|;
name|code
operator|=
name|swap_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
return|return
name|code
return|;
block|}
end_function

begin_comment
comment|/* Detect conditional moves that exactly match min/max operational    semantics.  Note that this is IEEE safe, as long as we don't    interchange the operands.     Returns FALSE if this conditional move doesn't match a MIN/MAX,    and TRUE if the operation is successful and instructions are emitted.  */
end_comment

begin_function
specifier|static
name|bool
name|ix86_expand_sse_fp_minmax
parameter_list|(
name|rtx
name|dest
parameter_list|,
name|enum
name|rtx_code
name|code
parameter_list|,
name|rtx
name|cmp_op0
parameter_list|,
name|rtx
name|cmp_op1
parameter_list|,
name|rtx
name|if_true
parameter_list|,
name|rtx
name|if_false
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|bool
name|is_min
decl_stmt|;
name|rtx
name|tmp
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|LT
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|UNGE
condition|)
block|{
name|tmp
operator|=
name|if_true
expr_stmt|;
name|if_true
operator|=
name|if_false
expr_stmt|;
name|if_false
operator|=
name|tmp
expr_stmt|;
block|}
else|else
return|return
name|false
return|;
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|cmp_op0
argument_list|,
name|if_true
argument_list|)
operator|&&
name|rtx_equal_p
argument_list|(
name|cmp_op1
argument_list|,
name|if_false
argument_list|)
condition|)
name|is_min
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|cmp_op1
argument_list|,
name|if_true
argument_list|)
operator|&&
name|rtx_equal_p
argument_list|(
name|cmp_op0
argument_list|,
name|if_false
argument_list|)
condition|)
name|is_min
operator|=
name|false
expr_stmt|;
else|else
return|return
name|false
return|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|dest
argument_list|)
expr_stmt|;
comment|/* We want to check HONOR_NANS and HONOR_SIGNED_ZEROS here,      but MODE may be a vector mode and thus not appropriate.  */
if|if
condition|(
operator|!
name|flag_finite_math_only
operator|||
operator|!
name|flag_unsafe_math_optimizations
condition|)
block|{
name|int
name|u
init|=
name|is_min
condition|?
name|UNSPEC_IEEE_MIN
else|:
name|UNSPEC_IEEE_MAX
decl_stmt|;
name|rtvec
name|v
decl_stmt|;
name|if_true
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|if_true
argument_list|)
expr_stmt|;
name|v
operator|=
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|if_true
argument_list|,
name|if_false
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|mode
argument_list|,
name|v
argument_list|,
name|u
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|code
operator|=
name|is_min
condition|?
name|SMIN
else|:
name|SMAX
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|if_true
argument_list|,
name|if_false
argument_list|)
expr_stmt|;
block|}
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|dest
argument_list|,
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Expand an sse vector comparison.  Return the register with the result.  */
end_comment

begin_function
specifier|static
name|rtx
name|ix86_expand_sse_cmp
parameter_list|(
name|rtx
name|dest
parameter_list|,
name|enum
name|rtx_code
name|code
parameter_list|,
name|rtx
name|cmp_op0
parameter_list|,
name|rtx
name|cmp_op1
parameter_list|,
name|rtx
name|op_true
parameter_list|,
name|rtx
name|op_false
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|cmp_op0
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|cmp_op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nonimmediate_operand
argument_list|(
name|cmp_op1
argument_list|,
name|mode
argument_list|)
condition|)
name|cmp_op1
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|cmp_op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|optimize
operator|||
name|reg_overlap_mentioned_p
argument_list|(
name|dest
argument_list|,
name|op_true
argument_list|)
operator|||
name|reg_overlap_mentioned_p
argument_list|(
name|dest
argument_list|,
name|op_false
argument_list|)
condition|)
name|dest
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|x
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|cmp_op0
argument_list|,
name|cmp_op1
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|dest
argument_list|,
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|dest
return|;
block|}
end_function

begin_comment
comment|/* Expand DEST = CMP ? OP_TRUE : OP_FALSE into a sequence of logical    operations.  This is used for both scalar and vector conditional moves.  */
end_comment

begin_function
specifier|static
name|void
name|ix86_expand_sse_movcc
parameter_list|(
name|rtx
name|dest
parameter_list|,
name|rtx
name|cmp
parameter_list|,
name|rtx
name|op_true
parameter_list|,
name|rtx
name|op_false
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|rtx
name|t2
decl_stmt|,
name|t3
decl_stmt|,
name|x
decl_stmt|;
if|if
condition|(
name|op_false
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|op_true
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|op_true
argument_list|)
expr_stmt|;
name|x
operator|=
name|gen_rtx_AND
argument_list|(
name|mode
argument_list|,
name|cmp
argument_list|,
name|op_true
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|dest
argument_list|,
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op_true
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|op_false
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|op_false
argument_list|)
expr_stmt|;
name|x
operator|=
name|gen_rtx_NOT
argument_list|(
name|mode
argument_list|,
name|cmp
argument_list|)
expr_stmt|;
name|x
operator|=
name|gen_rtx_AND
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
name|op_false
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|dest
argument_list|,
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|op_true
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|op_true
argument_list|)
expr_stmt|;
name|op_false
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|op_false
argument_list|)
expr_stmt|;
name|t2
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|optimize
condition|)
name|t3
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
else|else
name|t3
operator|=
name|dest
expr_stmt|;
name|x
operator|=
name|gen_rtx_AND
argument_list|(
name|mode
argument_list|,
name|op_true
argument_list|,
name|cmp
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|t2
argument_list|,
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|gen_rtx_NOT
argument_list|(
name|mode
argument_list|,
name|cmp
argument_list|)
expr_stmt|;
name|x
operator|=
name|gen_rtx_AND
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
name|op_false
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|t3
argument_list|,
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|gen_rtx_IOR
argument_list|(
name|mode
argument_list|,
name|t3
argument_list|,
name|t2
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|dest
argument_list|,
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Expand a floating-point conditional move.  Return true if successful.  */
end_comment

begin_function
name|int
name|ix86_expand_fp_movcc
parameter_list|(
name|rtx
name|operands
index|[]
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|rtx
name|tmp
decl_stmt|,
name|compare_op
decl_stmt|,
name|second_test
decl_stmt|,
name|bypass_test
decl_stmt|;
if|if
condition|(
name|TARGET_SSE_MATH
operator|&&
name|SSE_FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|enum
name|machine_mode
name|cmode
decl_stmt|;
comment|/* Since we've no cmove for sse registers, don't force bad register 	 allocation just to gain access to it.  Deny movcc when the 	 comparison mode doesn't match the move mode.  */
name|cmode
operator|=
name|GET_MODE
argument_list|(
name|ix86_compare_op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmode
operator|==
name|VOIDmode
condition|)
name|cmode
operator|=
name|GET_MODE
argument_list|(
name|ix86_compare_op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmode
operator|!=
name|mode
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|ix86_prepare_sse_fp_compare_args
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|code
argument_list|,
operator|&
name|ix86_compare_op0
argument_list|,
operator|&
name|ix86_compare_op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|UNKNOWN
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|ix86_expand_sse_fp_minmax
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|code
argument_list|,
name|ix86_compare_op0
argument_list|,
name|ix86_compare_op1
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|,
name|operands
index|[
literal|3
index|]
argument_list|)
condition|)
return|return
literal|1
return|;
name|tmp
operator|=
name|ix86_expand_sse_cmp
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|code
argument_list|,
name|ix86_compare_op0
argument_list|,
name|ix86_compare_op1
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|,
name|operands
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|ix86_expand_sse_movcc
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|tmp
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|,
name|operands
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* The floating point conditional move instructions don't directly      support conditions resulting from a signed integer comparison.  */
name|compare_op
operator|=
name|ix86_expand_compare
argument_list|(
name|code
argument_list|,
operator|&
name|second_test
argument_list|,
operator|&
name|bypass_test
argument_list|)
expr_stmt|;
comment|/* The floating point conditional move instructions don't directly      support signed integer comparisons.  */
if|if
condition|(
operator|!
name|fcmov_comparison_operator
argument_list|(
name|compare_op
argument_list|,
name|VOIDmode
argument_list|)
condition|)
block|{
name|gcc_assert
argument_list|(
operator|!
name|second_test
operator|&&
operator|!
name|bypass_test
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_reg_rtx
argument_list|(
name|QImode
argument_list|)
expr_stmt|;
name|ix86_expand_setcc
argument_list|(
name|code
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|code
operator|=
name|NE
expr_stmt|;
name|ix86_compare_op0
operator|=
name|tmp
expr_stmt|;
name|ix86_compare_op1
operator|=
name|const0_rtx
expr_stmt|;
name|compare_op
operator|=
name|ix86_expand_compare
argument_list|(
name|code
argument_list|,
operator|&
name|second_test
argument_list|,
operator|&
name|bypass_test
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bypass_test
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
name|tmp
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|tmp
argument_list|,
name|operands
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|operands
index|[
literal|3
index|]
operator|=
name|tmp
expr_stmt|;
block|}
if|if
condition|(
name|second_test
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
name|tmp
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|tmp
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|operands
index|[
literal|2
index|]
operator|=
name|tmp
expr_stmt|;
block|}
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|mode
argument_list|,
name|compare_op
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|,
name|operands
index|[
literal|3
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bypass_test
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|mode
argument_list|,
name|bypass_test
argument_list|,
name|operands
index|[
literal|3
index|]
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|second_test
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|mode
argument_list|,
name|second_test
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Expand a floating-point vector conditional move; a vcond operation    rather than a movcc operation.  */
end_comment

begin_function
name|bool
name|ix86_expand_fp_vcond
parameter_list|(
name|rtx
name|operands
index|[]
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|operands
index|[
literal|3
index|]
argument_list|)
decl_stmt|;
name|rtx
name|cmp
decl_stmt|;
name|code
operator|=
name|ix86_prepare_sse_fp_compare_args
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|code
argument_list|,
operator|&
name|operands
index|[
literal|4
index|]
argument_list|,
operator|&
name|operands
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|UNKNOWN
condition|)
return|return
name|false
return|;
if|if
condition|(
name|ix86_expand_sse_fp_minmax
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|code
argument_list|,
name|operands
index|[
literal|4
index|]
argument_list|,
name|operands
index|[
literal|5
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|)
condition|)
return|return
name|true
return|;
name|cmp
operator|=
name|ix86_expand_sse_cmp
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|code
argument_list|,
name|operands
index|[
literal|4
index|]
argument_list|,
name|operands
index|[
literal|5
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|ix86_expand_sse_movcc
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|cmp
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Expand a signed integral vector conditional move.  */
end_comment

begin_function
name|bool
name|ix86_expand_int_vcond
parameter_list|(
name|rtx
name|operands
index|[]
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|operands
index|[
literal|3
index|]
argument_list|)
decl_stmt|;
name|bool
name|negate
init|=
name|false
decl_stmt|;
name|rtx
name|x
decl_stmt|,
name|cop0
decl_stmt|,
name|cop1
decl_stmt|;
name|cop0
operator|=
name|operands
index|[
literal|4
index|]
expr_stmt|;
name|cop1
operator|=
name|operands
index|[
literal|5
index|]
expr_stmt|;
comment|/* Canonicalize the comparison to EQ, GT, GTU.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EQ
case|:
case|case
name|GT
case|:
case|case
name|GTU
case|:
break|break;
case|case
name|NE
case|:
case|case
name|LE
case|:
case|case
name|LEU
case|:
name|code
operator|=
name|reverse_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|negate
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|GE
case|:
case|case
name|GEU
case|:
name|code
operator|=
name|reverse_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|negate
operator|=
name|true
expr_stmt|;
comment|/* FALLTHRU */
case|case
name|LT
case|:
case|case
name|LTU
case|:
name|code
operator|=
name|swap_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|x
operator|=
name|cop0
operator|,
name|cop0
operator|=
name|cop1
operator|,
name|cop1
operator|=
name|x
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
comment|/* Unsigned parallel compare is not supported by the hardware.  Play some      tricks to turn this into a signed comparison against 0.  */
if|if
condition|(
name|code
operator|==
name|GTU
condition|)
block|{
name|cop0
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|cop0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|V4SImode
case|:
block|{
name|rtx
name|t1
decl_stmt|,
name|t2
decl_stmt|,
name|mask
decl_stmt|;
comment|/* Perform a parallel modulo subtraction.  */
name|t1
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_subv4si3
argument_list|(
name|t1
argument_list|,
name|cop0
argument_list|,
name|cop1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Extract the original sign bit of op0.  */
name|mask
operator|=
name|GEN_INT
argument_list|(
operator|-
literal|0x80000000
argument_list|)
expr_stmt|;
name|mask
operator|=
name|gen_rtx_CONST_VECTOR
argument_list|(
name|mode
argument_list|,
name|gen_rtvec
argument_list|(
literal|4
argument_list|,
name|mask
argument_list|,
name|mask
argument_list|,
name|mask
argument_list|,
name|mask
argument_list|)
argument_list|)
expr_stmt|;
name|mask
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|t2
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_andv4si3
argument_list|(
name|t2
argument_list|,
name|cop0
argument_list|,
name|mask
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XOR it back into the result of the subtraction.  This results 	       in the sign bit set iff we saw unsigned underflow.  */
name|x
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_xorv4si3
argument_list|(
name|x
argument_list|,
name|t1
argument_list|,
name|t2
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|=
name|GT
expr_stmt|;
block|}
break|break;
case|case
name|V16QImode
case|:
case|case
name|V8HImode
case|:
comment|/* Perform a parallel unsigned saturating subtraction.  */
name|x
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|x
argument_list|,
name|gen_rtx_US_MINUS
argument_list|(
name|mode
argument_list|,
name|cop0
argument_list|,
name|cop1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|=
name|EQ
expr_stmt|;
name|negate
operator|=
operator|!
name|negate
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|cop0
operator|=
name|x
expr_stmt|;
name|cop1
operator|=
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
name|x
operator|=
name|ix86_expand_sse_cmp
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|code
argument_list|,
name|cop0
argument_list|,
name|cop1
argument_list|,
name|operands
index|[
literal|1
operator|+
name|negate
index|]
argument_list|,
name|operands
index|[
literal|2
operator|-
name|negate
index|]
argument_list|)
expr_stmt|;
name|ix86_expand_sse_movcc
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|x
argument_list|,
name|operands
index|[
literal|1
operator|+
name|negate
index|]
argument_list|,
name|operands
index|[
literal|2
operator|-
name|negate
index|]
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Expand conditional increment or decrement using adb/sbb instructions.    The default case using setcc followed by the conditional move can be    done by generic code.  */
end_comment

begin_function
name|int
name|ix86_expand_int_addcc
parameter_list|(
name|rtx
name|operands
index|[]
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|rtx
name|compare_op
decl_stmt|;
name|rtx
name|val
init|=
name|const0_rtx
decl_stmt|;
name|bool
name|fpcmp
init|=
name|false
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|operands
index|[
literal|3
index|]
operator|!=
name|const1_rtx
operator|&&
name|operands
index|[
literal|3
index|]
operator|!=
name|constm1_rtx
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|ix86_expand_carry_flag_compare
argument_list|(
name|code
argument_list|,
name|ix86_compare_op0
argument_list|,
name|ix86_compare_op1
argument_list|,
operator|&
name|compare_op
argument_list|)
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|compare_op
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|compare_op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CCFPmode
operator|||
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|compare_op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CCFPUmode
condition|)
block|{
name|fpcmp
operator|=
name|true
expr_stmt|;
name|code
operator|=
name|ix86_fp_compare_code_to_integer
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|!=
name|LTU
condition|)
block|{
name|val
operator|=
name|constm1_rtx
expr_stmt|;
if|if
condition|(
name|fpcmp
condition|)
name|PUT_CODE
argument_list|(
name|compare_op
argument_list|,
name|reverse_condition_maybe_unordered
argument_list|(
name|GET_CODE
argument_list|(
name|compare_op
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|PUT_CODE
argument_list|(
name|compare_op
argument_list|,
name|reverse_condition
argument_list|(
name|GET_CODE
argument_list|(
name|compare_op
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|PUT_MODE
argument_list|(
name|compare_op
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/* Construct either adc or sbb insn.  */
if|if
condition|(
operator|(
name|code
operator|==
name|LTU
operator|)
operator|==
operator|(
name|operands
index|[
literal|3
index|]
operator|==
name|constm1_rtx
operator|)
condition|)
block|{
switch|switch
condition|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
case|case
name|QImode
case|:
name|emit_insn
argument_list|(
name|gen_subqi3_carry
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|,
name|val
argument_list|,
name|compare_op
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|HImode
case|:
name|emit_insn
argument_list|(
name|gen_subhi3_carry
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|,
name|val
argument_list|,
name|compare_op
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SImode
case|:
name|emit_insn
argument_list|(
name|gen_subsi3_carry
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|,
name|val
argument_list|,
name|compare_op
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DImode
case|:
name|emit_insn
argument_list|(
name|gen_subdi3_carry_rex64
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|,
name|val
argument_list|,
name|compare_op
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
case|case
name|QImode
case|:
name|emit_insn
argument_list|(
name|gen_addqi3_carry
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|,
name|val
argument_list|,
name|compare_op
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|HImode
case|:
name|emit_insn
argument_list|(
name|gen_addhi3_carry
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|,
name|val
argument_list|,
name|compare_op
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SImode
case|:
name|emit_insn
argument_list|(
name|gen_addsi3_carry
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|,
name|val
argument_list|,
name|compare_op
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DImode
case|:
name|emit_insn
argument_list|(
name|gen_adddi3_carry_rex64
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|,
name|val
argument_list|,
name|compare_op
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
comment|/* DONE */
block|}
end_function

begin_comment
comment|/* Split operands 0 and 1 into SImode parts.  Similar to split_di, but    works for floating pointer parameters and nonoffsetable memories.    For pushes, it returns just stack offsets; the values will be saved    in the right order.  Maximally three parts are generated.  */
end_comment

begin_function
specifier|static
name|int
name|ix86_split_to_parts
parameter_list|(
name|rtx
name|operand
parameter_list|,
name|rtx
modifier|*
name|parts
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|int
name|size
decl_stmt|;
if|if
condition|(
operator|!
name|TARGET_64BIT
condition|)
name|size
operator|=
name|mode
operator|==
name|XFmode
condition|?
literal|3
else|:
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|/
literal|4
expr_stmt|;
else|else
name|size
operator|=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|+
literal|4
operator|)
operator|/
literal|8
expr_stmt|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|!=
name|REG
operator|||
operator|!
name|MMX_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|operand
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|size
operator|>=
literal|2
operator|&&
name|size
operator|<=
literal|3
argument_list|)
expr_stmt|;
comment|/* Optimize constant pool reference to immediates.  This is used by fp      moves, that force all constants to memory to allow combining.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|MEM
operator|&&
name|MEM_READONLY_P
argument_list|(
name|operand
argument_list|)
condition|)
block|{
name|rtx
name|tmp
init|=
name|maybe_get_pool_constant
argument_list|(
name|operand
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmp
condition|)
name|operand
operator|=
name|tmp
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|offsettable_memref_p
argument_list|(
name|operand
argument_list|)
condition|)
block|{
comment|/* The only non-offsetable memories we handle are pushes.  */
name|int
name|ok
init|=
name|push_operand
argument_list|(
name|operand
argument_list|,
name|VOIDmode
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|ok
argument_list|)
expr_stmt|;
name|operand
operator|=
name|copy_rtx
argument_list|(
name|operand
argument_list|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|operand
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
name|parts
index|[
literal|0
index|]
operator|=
name|parts
index|[
literal|1
index|]
operator|=
name|parts
index|[
literal|2
index|]
operator|=
name|operand
expr_stmt|;
return|return
name|size
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|CONST_VECTOR
condition|)
block|{
name|enum
name|machine_mode
name|imode
init|=
name|int_mode_for_mode
argument_list|(
name|mode
argument_list|)
decl_stmt|;
comment|/* Caution: if we looked through a constant pool memory above, 	 the operand may actually have a different mode now.  That's 	 ok, since we want to pun this all the way back to an integer.  */
name|operand
operator|=
name|simplify_subreg
argument_list|(
name|imode
argument_list|,
name|operand
argument_list|,
name|GET_MODE
argument_list|(
name|operand
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|operand
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|mode
operator|=
name|imode
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TARGET_64BIT
condition|)
block|{
if|if
condition|(
name|mode
operator|==
name|DImode
condition|)
name|split_di
argument_list|(
operator|&
name|operand
argument_list|,
literal|1
argument_list|,
operator|&
name|parts
index|[
literal|0
index|]
argument_list|,
operator|&
name|parts
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|REG_P
argument_list|(
name|operand
argument_list|)
condition|)
block|{
name|gcc_assert
argument_list|(
name|reload_completed
argument_list|)
expr_stmt|;
name|parts
index|[
literal|0
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|operand
argument_list|)
operator|+
literal|0
argument_list|)
expr_stmt|;
name|parts
index|[
literal|1
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|operand
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|3
condition|)
name|parts
index|[
literal|2
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|operand
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|offsettable_memref_p
argument_list|(
name|operand
argument_list|)
condition|)
block|{
name|operand
operator|=
name|adjust_address
argument_list|(
name|operand
argument_list|,
name|SImode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|parts
index|[
literal|0
index|]
operator|=
name|operand
expr_stmt|;
name|parts
index|[
literal|1
index|]
operator|=
name|adjust_address
argument_list|(
name|operand
argument_list|,
name|SImode
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|3
condition|)
name|parts
index|[
literal|2
index|]
operator|=
name|adjust_address
argument_list|(
name|operand
argument_list|,
name|SImode
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|long
name|l
index|[
literal|4
index|]
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|r
argument_list|,
name|operand
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|XFmode
case|:
name|REAL_VALUE_TO_TARGET_LONG_DOUBLE
argument_list|(
name|r
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|parts
index|[
literal|2
index|]
operator|=
name|gen_int_mode
argument_list|(
name|l
index|[
literal|2
index|]
argument_list|,
name|SImode
argument_list|)
expr_stmt|;
break|break;
case|case
name|DFmode
case|:
name|REAL_VALUE_TO_TARGET_DOUBLE
argument_list|(
name|r
argument_list|,
name|l
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|parts
index|[
literal|1
index|]
operator|=
name|gen_int_mode
argument_list|(
name|l
index|[
literal|1
index|]
argument_list|,
name|SImode
argument_list|)
expr_stmt|;
name|parts
index|[
literal|0
index|]
operator|=
name|gen_int_mode
argument_list|(
name|l
index|[
literal|0
index|]
argument_list|,
name|SImode
argument_list|)
expr_stmt|;
block|}
else|else
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|mode
operator|==
name|TImode
condition|)
name|split_ti
argument_list|(
operator|&
name|operand
argument_list|,
literal|1
argument_list|,
operator|&
name|parts
index|[
literal|0
index|]
argument_list|,
operator|&
name|parts
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|XFmode
operator|||
name|mode
operator|==
name|TFmode
condition|)
block|{
name|enum
name|machine_mode
name|upper_mode
init|=
name|mode
operator|==
name|XFmode
condition|?
name|SImode
else|:
name|DImode
decl_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|operand
argument_list|)
condition|)
block|{
name|gcc_assert
argument_list|(
name|reload_completed
argument_list|)
expr_stmt|;
name|parts
index|[
literal|0
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|REGNO
argument_list|(
name|operand
argument_list|)
operator|+
literal|0
argument_list|)
expr_stmt|;
name|parts
index|[
literal|1
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|upper_mode
argument_list|,
name|REGNO
argument_list|(
name|operand
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|offsettable_memref_p
argument_list|(
name|operand
argument_list|)
condition|)
block|{
name|operand
operator|=
name|adjust_address
argument_list|(
name|operand
argument_list|,
name|DImode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|parts
index|[
literal|0
index|]
operator|=
name|operand
expr_stmt|;
name|parts
index|[
literal|1
index|]
operator|=
name|adjust_address
argument_list|(
name|operand
argument_list|,
name|upper_mode
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|long
name|l
index|[
literal|4
index|]
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|r
argument_list|,
name|operand
argument_list|)
expr_stmt|;
name|real_to_target
argument_list|(
name|l
argument_list|,
operator|&
name|r
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/* Do not use shift by 32 to avoid warning on 32bit systems.  */
if|if
condition|(
name|HOST_BITS_PER_WIDE_INT
operator|>=
literal|64
condition|)
name|parts
index|[
literal|0
index|]
operator|=
name|gen_int_mode
argument_list|(
operator|(
name|l
index|[
literal|0
index|]
operator|&
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|2
operator|<<
literal|31
operator|)
operator|-
literal|1
operator|)
operator|)
operator|+
operator|(
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
name|l
index|[
literal|1
index|]
operator|)
operator|<<
literal|31
operator|)
operator|<<
literal|1
operator|)
argument_list|,
name|DImode
argument_list|)
expr_stmt|;
else|else
name|parts
index|[
literal|0
index|]
operator|=
name|immed_double_const
argument_list|(
name|l
index|[
literal|0
index|]
argument_list|,
name|l
index|[
literal|1
index|]
argument_list|,
name|DImode
argument_list|)
expr_stmt|;
if|if
condition|(
name|upper_mode
operator|==
name|SImode
condition|)
name|parts
index|[
literal|1
index|]
operator|=
name|gen_int_mode
argument_list|(
name|l
index|[
literal|2
index|]
argument_list|,
name|SImode
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|HOST_BITS_PER_WIDE_INT
operator|>=
literal|64
condition|)
name|parts
index|[
literal|1
index|]
operator|=
name|gen_int_mode
argument_list|(
operator|(
name|l
index|[
literal|2
index|]
operator|&
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|2
operator|<<
literal|31
operator|)
operator|-
literal|1
operator|)
operator|)
operator|+
operator|(
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
name|l
index|[
literal|3
index|]
operator|)
operator|<<
literal|31
operator|)
operator|<<
literal|1
operator|)
argument_list|,
name|DImode
argument_list|)
expr_stmt|;
else|else
name|parts
index|[
literal|1
index|]
operator|=
name|immed_double_const
argument_list|(
name|l
index|[
literal|2
index|]
argument_list|,
name|l
index|[
literal|3
index|]
argument_list|,
name|DImode
argument_list|)
expr_stmt|;
block|}
else|else
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|size
return|;
block|}
end_function

begin_comment
comment|/* Emit insns to perform a move or push of DI, DF, and XF values.    Return false when normal moves are needed; true when all required    insns have been emitted.  Operands 2-4 contain the input values    int the correct order; operands 5-7 contain the output values.  */
end_comment

begin_function
name|void
name|ix86_split_long_move
parameter_list|(
name|rtx
name|operands
index|[]
parameter_list|)
block|{
name|rtx
name|part
index|[
literal|2
index|]
index|[
literal|3
index|]
decl_stmt|;
name|int
name|nparts
decl_stmt|;
name|int
name|push
init|=
literal|0
decl_stmt|;
name|int
name|collisions
init|=
literal|0
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
comment|/* The DFmode expanders may ask us to move double.      For 64bit target this is single move.  By hiding the fact      here we simplify i386.md splitters.  */
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator|==
literal|8
operator|&&
name|TARGET_64BIT
condition|)
block|{
comment|/* Optimize constant pool reference to immediates.  This is used by 	 fp moves, that force all constants to memory to allow combining.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|operands
index|[
literal|1
index|]
operator|=
name|get_pool_constant
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|push_operand
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|VOIDmode
argument_list|)
condition|)
block|{
name|operands
index|[
literal|0
index|]
operator|=
name|copy_rtx
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
block|}
else|else
name|operands
index|[
literal|0
index|]
operator|=
name|gen_lowpart
argument_list|(
name|DImode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|gen_lowpart
argument_list|(
name|DImode
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* The only non-offsettable memory we handle is push.  */
if|if
condition|(
name|push_operand
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|VOIDmode
argument_list|)
condition|)
name|push
operator|=
literal|1
expr_stmt|;
else|else
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|!=
name|MEM
operator|||
name|offsettable_memref_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|nparts
operator|=
name|ix86_split_to_parts
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|part
index|[
literal|1
index|]
argument_list|,
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ix86_split_to_parts
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|part
index|[
literal|0
index|]
argument_list|,
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* When emitting push, take care for source operands on the stack.  */
if|if
condition|(
name|push
operator|&&
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|MEM
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|nparts
operator|==
literal|3
condition|)
name|part
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|change_address
argument_list|(
name|part
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|,
name|GET_MODE
argument_list|(
name|part
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|part
index|[
literal|1
index|]
index|[
literal|2
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|part
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|change_address
argument_list|(
name|part
index|[
literal|1
index|]
index|[
literal|0
index|]
argument_list|,
name|GET_MODE
argument_list|(
name|part
index|[
literal|1
index|]
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|part
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* We need to do copy in the right order in case an address register      of the source overlaps the destination.  */
if|if
condition|(
name|REG_P
argument_list|(
name|part
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|part
index|[
literal|1
index|]
index|[
literal|0
index|]
argument_list|)
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|part
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|,
name|XEXP
argument_list|(
name|part
index|[
literal|1
index|]
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|collisions
operator|++
expr_stmt|;
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|part
index|[
literal|0
index|]
index|[
literal|1
index|]
argument_list|,
name|XEXP
argument_list|(
name|part
index|[
literal|1
index|]
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|collisions
operator|++
expr_stmt|;
if|if
condition|(
name|nparts
operator|==
literal|3
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|part
index|[
literal|0
index|]
index|[
literal|2
index|]
argument_list|,
name|XEXP
argument_list|(
name|part
index|[
literal|1
index|]
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|collisions
operator|++
expr_stmt|;
comment|/* Collision in the middle part can be handled by reordering.  */
if|if
condition|(
name|collisions
operator|==
literal|1
operator|&&
name|nparts
operator|==
literal|3
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|part
index|[
literal|0
index|]
index|[
literal|1
index|]
argument_list|,
name|XEXP
argument_list|(
name|part
index|[
literal|1
index|]
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|tmp
decl_stmt|;
name|tmp
operator|=
name|part
index|[
literal|0
index|]
index|[
literal|1
index|]
expr_stmt|;
name|part
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
name|part
index|[
literal|0
index|]
index|[
literal|2
index|]
expr_stmt|;
name|part
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|=
name|tmp
expr_stmt|;
name|tmp
operator|=
name|part
index|[
literal|1
index|]
index|[
literal|1
index|]
expr_stmt|;
name|part
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|part
index|[
literal|1
index|]
index|[
literal|2
index|]
expr_stmt|;
name|part
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|=
name|tmp
expr_stmt|;
block|}
comment|/* If there are more collisions, we can't handle it by reordering. 	 Do an lea to the last part and use only one colliding move.  */
elseif|else
if|if
condition|(
name|collisions
operator|>
literal|1
condition|)
block|{
name|rtx
name|base
decl_stmt|;
name|collisions
operator|=
literal|1
expr_stmt|;
name|base
operator|=
name|part
index|[
literal|0
index|]
index|[
name|nparts
operator|-
literal|1
index|]
expr_stmt|;
comment|/* Handle the case when the last part isn't valid for lea. 	     Happens in 64-bit mode storing the 12-byte XFmode.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|base
argument_list|)
operator|!=
name|Pmode
condition|)
name|base
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|REGNO
argument_list|(
name|base
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|base
argument_list|,
name|XEXP
argument_list|(
name|part
index|[
literal|1
index|]
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|part
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|replace_equiv_address
argument_list|(
name|part
index|[
literal|1
index|]
index|[
literal|0
index|]
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|part
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|replace_equiv_address
argument_list|(
name|part
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|,
name|plus_constant
argument_list|(
name|base
argument_list|,
name|UNITS_PER_WORD
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nparts
operator|==
literal|3
condition|)
name|part
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|=
name|replace_equiv_address
argument_list|(
name|part
index|[
literal|1
index|]
index|[
literal|2
index|]
argument_list|,
name|plus_constant
argument_list|(
name|base
argument_list|,
literal|8
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|push
condition|)
block|{
if|if
condition|(
operator|!
name|TARGET_64BIT
condition|)
block|{
if|if
condition|(
name|nparts
operator|==
literal|3
condition|)
block|{
if|if
condition|(
name|TARGET_128BIT_LONG_DOUBLE
operator|&&
name|mode
operator|==
name|XFmode
condition|)
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
operator|-
literal|4
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|part
index|[
literal|0
index|]
index|[
literal|2
index|]
argument_list|,
name|part
index|[
literal|1
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* In 64bit mode we don't have 32bit push available.  In case this is 	     register, it is OK - we will just use larger counterpart.  We also 	     retype memory - these comes from attempt to avoid REX prefix on 	     moving of second half of TFmode value.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|part
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|)
operator|==
name|SImode
condition|)
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|part
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
case|case
name|MEM
case|:
name|part
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|adjust_address
argument_list|(
name|part
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|,
name|DImode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG
case|:
name|part
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|REGNO
argument_list|(
name|part
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|GET_MODE
argument_list|(
name|part
index|[
literal|1
index|]
index|[
literal|0
index|]
argument_list|)
operator|==
name|SImode
condition|)
name|part
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|part
index|[
literal|1
index|]
index|[
literal|1
index|]
expr_stmt|;
block|}
block|}
name|emit_move_insn
argument_list|(
name|part
index|[
literal|0
index|]
index|[
literal|1
index|]
argument_list|,
name|part
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|part
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|,
name|part
index|[
literal|1
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Choose correct order to not overwrite the source before it is copied.  */
if|if
condition|(
operator|(
name|REG_P
argument_list|(
name|part
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|)
operator|&&
name|REG_P
argument_list|(
name|part
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|)
operator|&&
operator|(
name|REGNO
argument_list|(
name|part
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|)
operator|==
name|REGNO
argument_list|(
name|part
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|)
operator|||
operator|(
name|nparts
operator|==
literal|3
operator|&&
name|REGNO
argument_list|(
name|part
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|)
operator|==
name|REGNO
argument_list|(
name|part
index|[
literal|1
index|]
index|[
literal|2
index|]
argument_list|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|collisions
operator|>
literal|0
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|part
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|,
name|XEXP
argument_list|(
name|part
index|[
literal|1
index|]
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|nparts
operator|==
literal|3
condition|)
block|{
name|operands
index|[
literal|2
index|]
operator|=
name|part
index|[
literal|0
index|]
index|[
literal|2
index|]
expr_stmt|;
name|operands
index|[
literal|3
index|]
operator|=
name|part
index|[
literal|0
index|]
index|[
literal|1
index|]
expr_stmt|;
name|operands
index|[
literal|4
index|]
operator|=
name|part
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
name|operands
index|[
literal|5
index|]
operator|=
name|part
index|[
literal|1
index|]
index|[
literal|2
index|]
expr_stmt|;
name|operands
index|[
literal|6
index|]
operator|=
name|part
index|[
literal|1
index|]
index|[
literal|1
index|]
expr_stmt|;
name|operands
index|[
literal|7
index|]
operator|=
name|part
index|[
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
block|{
name|operands
index|[
literal|2
index|]
operator|=
name|part
index|[
literal|0
index|]
index|[
literal|1
index|]
expr_stmt|;
name|operands
index|[
literal|3
index|]
operator|=
name|part
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
name|operands
index|[
literal|5
index|]
operator|=
name|part
index|[
literal|1
index|]
index|[
literal|1
index|]
expr_stmt|;
name|operands
index|[
literal|6
index|]
operator|=
name|part
index|[
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|nparts
operator|==
literal|3
condition|)
block|{
name|operands
index|[
literal|2
index|]
operator|=
name|part
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
name|operands
index|[
literal|3
index|]
operator|=
name|part
index|[
literal|0
index|]
index|[
literal|1
index|]
expr_stmt|;
name|operands
index|[
literal|4
index|]
operator|=
name|part
index|[
literal|0
index|]
index|[
literal|2
index|]
expr_stmt|;
name|operands
index|[
literal|5
index|]
operator|=
name|part
index|[
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
name|operands
index|[
literal|6
index|]
operator|=
name|part
index|[
literal|1
index|]
index|[
literal|1
index|]
expr_stmt|;
name|operands
index|[
literal|7
index|]
operator|=
name|part
index|[
literal|1
index|]
index|[
literal|2
index|]
expr_stmt|;
block|}
else|else
block|{
name|operands
index|[
literal|2
index|]
operator|=
name|part
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
name|operands
index|[
literal|3
index|]
operator|=
name|part
index|[
literal|0
index|]
index|[
literal|1
index|]
expr_stmt|;
name|operands
index|[
literal|5
index|]
operator|=
name|part
index|[
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
name|operands
index|[
literal|6
index|]
operator|=
name|part
index|[
literal|1
index|]
index|[
literal|1
index|]
expr_stmt|;
block|}
block|}
comment|/* If optimizing for size, attempt to locally unCSE nonzero constants.  */
if|if
condition|(
name|optimize_size
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|5
index|]
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|operands
index|[
literal|5
index|]
operator|!=
name|const0_rtx
operator|&&
name|REG_P
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|6
index|]
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|operands
index|[
literal|6
index|]
argument_list|)
operator|==
name|INTVAL
argument_list|(
name|operands
index|[
literal|5
index|]
argument_list|)
condition|)
name|operands
index|[
literal|6
index|]
operator|=
name|operands
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|nparts
operator|==
literal|3
operator|&&
name|GET_CODE
argument_list|(
name|operands
index|[
literal|7
index|]
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|operands
index|[
literal|7
index|]
argument_list|)
operator|==
name|INTVAL
argument_list|(
name|operands
index|[
literal|5
index|]
argument_list|)
condition|)
name|operands
index|[
literal|7
index|]
operator|=
name|operands
index|[
literal|2
index|]
expr_stmt|;
block|}
if|if
condition|(
name|nparts
operator|==
literal|3
operator|&&
name|GET_CODE
argument_list|(
name|operands
index|[
literal|6
index|]
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|operands
index|[
literal|6
index|]
operator|!=
name|const0_rtx
operator|&&
name|REG_P
argument_list|(
name|operands
index|[
literal|3
index|]
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|operands
index|[
literal|7
index|]
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|operands
index|[
literal|7
index|]
argument_list|)
operator|==
name|INTVAL
argument_list|(
name|operands
index|[
literal|6
index|]
argument_list|)
condition|)
name|operands
index|[
literal|7
index|]
operator|=
name|operands
index|[
literal|3
index|]
expr_stmt|;
block|}
name|emit_move_insn
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|,
name|operands
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|operands
index|[
literal|3
index|]
argument_list|,
name|operands
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|nparts
operator|==
literal|3
condition|)
name|emit_move_insn
argument_list|(
name|operands
index|[
literal|4
index|]
argument_list|,
name|operands
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Helper function of ix86_split_ashl used to generate an SImode/DImode    left shift by a constant, either using a single shift or    a sequence of add instructions.  */
end_comment

begin_function
specifier|static
name|void
name|ix86_expand_ashl_const
parameter_list|(
name|rtx
name|operand
parameter_list|,
name|int
name|count
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|count
operator|==
literal|1
condition|)
block|{
name|emit_insn
argument_list|(
operator|(
name|mode
operator|==
name|DImode
condition|?
name|gen_addsi3
else|:
name|gen_adddi3
operator|)
operator|(
name|operand
operator|,
name|operand
operator|,
name|operand
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|optimize_size
operator|&&
name|count
operator|*
name|ix86_cost
operator|->
name|add
operator|<=
name|ix86_cost
operator|->
name|shift_const
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|emit_insn
argument_list|(
operator|(
name|mode
operator|==
name|DImode
condition|?
name|gen_addsi3
else|:
name|gen_adddi3
operator|)
operator|(
name|operand
operator|,
name|operand
operator|,
name|operand
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|emit_insn
argument_list|(
operator|(
name|mode
operator|==
name|DImode
condition|?
name|gen_ashlsi3
else|:
name|gen_ashldi3
operator|)
operator|(
name|operand
operator|,
name|operand
operator|,
name|GEN_INT
argument_list|(
name|count
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ix86_split_ashl
parameter_list|(
name|rtx
modifier|*
name|operands
parameter_list|,
name|rtx
name|scratch
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|rtx
name|low
index|[
literal|2
index|]
decl_stmt|,
name|high
index|[
literal|2
index|]
decl_stmt|;
name|int
name|count
decl_stmt|;
specifier|const
name|int
name|single_width
init|=
name|mode
operator|==
name|DImode
condition|?
literal|32
else|:
literal|64
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
operator|(
name|mode
operator|==
name|DImode
condition|?
name|split_di
else|:
name|split_ti
operator|)
operator|(
name|operands
operator|,
literal|2
operator|,
name|low
operator|,
name|high
operator|)
expr_stmt|;
name|count
operator|=
name|INTVAL
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|&
operator|(
name|single_width
operator|*
literal|2
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|count
operator|>=
name|single_width
condition|)
block|{
name|emit_move_insn
argument_list|(
name|high
index|[
literal|0
index|]
argument_list|,
name|low
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|low
index|[
literal|0
index|]
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
name|single_width
condition|)
name|ix86_expand_ashl_const
argument_list|(
name|high
index|[
literal|0
index|]
argument_list|,
name|count
operator|-
name|single_width
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
name|emit_move_insn
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
operator|(
name|mode
operator|==
name|DImode
condition|?
name|gen_x86_shld_1
else|:
name|gen_x86_64_shld
operator|)
operator|(
name|high
index|[
literal|0
index|]
operator|,
name|low
index|[
literal|0
index|]
operator|,
name|GEN_INT
argument_list|(
name|count
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|ix86_expand_ashl_const
argument_list|(
name|low
index|[
literal|0
index|]
argument_list|,
name|count
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
operator|(
name|mode
operator|==
name|DImode
condition|?
name|split_di
else|:
name|split_ti
operator|)
operator|(
name|operands
operator|,
literal|1
operator|,
name|low
operator|,
name|high
operator|)
expr_stmt|;
if|if
condition|(
name|operands
index|[
literal|1
index|]
operator|==
name|const1_rtx
condition|)
block|{
comment|/* Assuming we've chosen a QImode capable registers, then 1<< N 	 can be done with two 32/64-bit shifts, no branches, no cmoves.  */
if|if
condition|(
name|ANY_QI_REG_P
argument_list|(
name|low
index|[
literal|0
index|]
argument_list|)
operator|&&
name|ANY_QI_REG_P
argument_list|(
name|high
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|rtx
name|s
decl_stmt|,
name|d
decl_stmt|,
name|flags
init|=
name|gen_rtx_REG
argument_list|(
name|CCZmode
argument_list|,
name|FLAGS_REG
argument_list|)
decl_stmt|;
name|ix86_expand_clear
argument_list|(
name|low
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ix86_expand_clear
argument_list|(
name|high
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_testqi_ccz_1
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|,
name|GEN_INT
argument_list|(
name|single_width
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|=
name|gen_lowpart
argument_list|(
name|QImode
argument_list|,
name|low
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|d
operator|=
name|gen_rtx_STRICT_LOW_PART
argument_list|(
name|VOIDmode
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|s
operator|=
name|gen_rtx_EQ
argument_list|(
name|QImode
argument_list|,
name|flags
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|d
argument_list|,
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|=
name|gen_lowpart
argument_list|(
name|QImode
argument_list|,
name|high
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|d
operator|=
name|gen_rtx_STRICT_LOW_PART
argument_list|(
name|VOIDmode
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|s
operator|=
name|gen_rtx_NE
argument_list|(
name|QImode
argument_list|,
name|flags
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|d
argument_list|,
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Otherwise, we can get the same results by manually performing 	 a bit extract operation on bit 5/6, and then performing the two 	 shifts.  The two methods of getting 0/1 into low/high are exactly 	 the same size.  Avoiding the shift in the bit extract case helps 	 pentium4 a bit; no one else seems to care much either way.  */
else|else
block|{
name|rtx
name|x
decl_stmt|;
if|if
condition|(
name|TARGET_PARTIAL_REG_STALL
operator|&&
operator|!
name|optimize_size
condition|)
name|x
operator|=
name|gen_rtx_ZERO_EXTEND
argument_list|(
name|mode
operator|==
name|DImode
condition|?
name|SImode
else|:
name|DImode
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
else|else
name|x
operator|=
name|gen_lowpart
argument_list|(
name|mode
operator|==
name|DImode
condition|?
name|SImode
else|:
name|DImode
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|high
index|[
literal|0
index|]
argument_list|,
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
operator|(
name|mode
operator|==
name|DImode
condition|?
name|gen_lshrsi3
else|:
name|gen_lshrdi3
operator|)
operator|(
name|high
index|[
literal|0
index|]
operator|,
name|high
index|[
literal|0
index|]
operator|,
name|GEN_INT
argument_list|(
name|mode
operator|==
name|DImode
condition|?
literal|5
else|:
literal|6
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
operator|(
name|mode
operator|==
name|DImode
condition|?
name|gen_andsi3
else|:
name|gen_anddi3
operator|)
operator|(
name|high
index|[
literal|0
index|]
operator|,
name|high
index|[
literal|0
index|]
operator|,
name|GEN_INT
argument_list|(
literal|1
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|low
index|[
literal|0
index|]
argument_list|,
name|high
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
operator|(
name|mode
operator|==
name|DImode
condition|?
name|gen_xorsi3
else|:
name|gen_xordi3
operator|)
operator|(
name|low
index|[
literal|0
index|]
operator|,
name|low
index|[
literal|0
index|]
operator|,
name|GEN_INT
argument_list|(
literal|1
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
name|emit_insn
argument_list|(
operator|(
name|mode
operator|==
name|DImode
condition|?
name|gen_ashlsi3
else|:
name|gen_ashldi3
operator|)
operator|(
name|low
index|[
literal|0
index|]
operator|,
name|low
index|[
literal|0
index|]
operator|,
name|operands
index|[
literal|2
index|]
operator|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
operator|(
name|mode
operator|==
name|DImode
condition|?
name|gen_ashlsi3
else|:
name|gen_ashldi3
operator|)
operator|(
name|high
index|[
literal|0
index|]
operator|,
name|high
index|[
literal|0
index|]
operator|,
name|operands
index|[
literal|2
index|]
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|operands
index|[
literal|1
index|]
operator|==
name|constm1_rtx
condition|)
block|{
comment|/* For -1<< N, we can avoid the shld instruction, because we 	 know that we're shifting 0...31/63 ones into a -1.  */
name|emit_move_insn
argument_list|(
name|low
index|[
literal|0
index|]
argument_list|,
name|constm1_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|optimize_size
condition|)
name|emit_move_insn
argument_list|(
name|high
index|[
literal|0
index|]
argument_list|,
name|low
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
else|else
name|emit_move_insn
argument_list|(
name|high
index|[
literal|0
index|]
argument_list|,
name|constm1_rtx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
name|emit_move_insn
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
operator|(
name|mode
operator|==
name|DImode
condition|?
name|split_di
else|:
name|split_ti
operator|)
operator|(
name|operands
operator|,
literal|1
operator|,
name|low
operator|,
name|high
operator|)
expr_stmt|;
name|emit_insn
argument_list|(
operator|(
name|mode
operator|==
name|DImode
condition|?
name|gen_x86_shld_1
else|:
name|gen_x86_64_shld
operator|)
operator|(
name|high
index|[
literal|0
index|]
operator|,
name|low
index|[
literal|0
index|]
operator|,
name|operands
index|[
literal|2
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
name|emit_insn
argument_list|(
operator|(
name|mode
operator|==
name|DImode
condition|?
name|gen_ashlsi3
else|:
name|gen_ashldi3
operator|)
operator|(
name|low
index|[
literal|0
index|]
operator|,
name|low
index|[
literal|0
index|]
operator|,
name|operands
index|[
literal|2
index|]
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_CMOVE
operator|&&
name|scratch
condition|)
block|{
name|ix86_expand_clear
argument_list|(
name|scratch
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
operator|(
name|mode
operator|==
name|DImode
condition|?
name|gen_x86_shift_adj_1
else|:
name|gen_x86_64_shift_adj
operator|)
operator|(
name|high
index|[
literal|0
index|]
operator|,
name|low
index|[
literal|0
index|]
operator|,
name|operands
index|[
literal|2
index|]
operator|,
name|scratch
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
name|emit_insn
argument_list|(
name|gen_x86_shift_adj_2
argument_list|(
name|high
index|[
literal|0
index|]
argument_list|,
name|low
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ix86_split_ashr
parameter_list|(
name|rtx
modifier|*
name|operands
parameter_list|,
name|rtx
name|scratch
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|rtx
name|low
index|[
literal|2
index|]
decl_stmt|,
name|high
index|[
literal|2
index|]
decl_stmt|;
name|int
name|count
decl_stmt|;
specifier|const
name|int
name|single_width
init|=
name|mode
operator|==
name|DImode
condition|?
literal|32
else|:
literal|64
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
operator|(
name|mode
operator|==
name|DImode
condition|?
name|split_di
else|:
name|split_ti
operator|)
operator|(
name|operands
operator|,
literal|2
operator|,
name|low
operator|,
name|high
operator|)
expr_stmt|;
name|count
operator|=
name|INTVAL
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|&
operator|(
name|single_width
operator|*
literal|2
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
name|single_width
operator|*
literal|2
operator|-
literal|1
condition|)
block|{
name|emit_move_insn
argument_list|(
name|high
index|[
literal|0
index|]
argument_list|,
name|high
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
operator|(
name|mode
operator|==
name|DImode
condition|?
name|gen_ashrsi3
else|:
name|gen_ashrdi3
operator|)
operator|(
name|high
index|[
literal|0
index|]
operator|,
name|high
index|[
literal|0
index|]
operator|,
name|GEN_INT
argument_list|(
name|single_width
operator|-
literal|1
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|low
index|[
literal|0
index|]
argument_list|,
name|high
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|count
operator|>=
name|single_width
condition|)
block|{
name|emit_move_insn
argument_list|(
name|low
index|[
literal|0
index|]
argument_list|,
name|high
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|high
index|[
literal|0
index|]
argument_list|,
name|low
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
operator|(
name|mode
operator|==
name|DImode
condition|?
name|gen_ashrsi3
else|:
name|gen_ashrdi3
operator|)
operator|(
name|high
index|[
literal|0
index|]
operator|,
name|high
index|[
literal|0
index|]
operator|,
name|GEN_INT
argument_list|(
name|single_width
operator|-
literal|1
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
name|single_width
condition|)
name|emit_insn
argument_list|(
operator|(
name|mode
operator|==
name|DImode
condition|?
name|gen_ashrsi3
else|:
name|gen_ashrdi3
operator|)
operator|(
name|low
index|[
literal|0
index|]
operator|,
name|low
index|[
literal|0
index|]
operator|,
name|GEN_INT
argument_list|(
name|count
operator|-
name|single_width
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
name|emit_move_insn
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
operator|(
name|mode
operator|==
name|DImode
condition|?
name|gen_x86_shrd_1
else|:
name|gen_x86_64_shrd
operator|)
operator|(
name|low
index|[
literal|0
index|]
operator|,
name|high
index|[
literal|0
index|]
operator|,
name|GEN_INT
argument_list|(
name|count
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
operator|(
name|mode
operator|==
name|DImode
condition|?
name|gen_ashrsi3
else|:
name|gen_ashrdi3
operator|)
operator|(
name|high
index|[
literal|0
index|]
operator|,
name|high
index|[
literal|0
index|]
operator|,
name|GEN_INT
argument_list|(
name|count
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
name|emit_move_insn
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
operator|(
name|mode
operator|==
name|DImode
condition|?
name|split_di
else|:
name|split_ti
operator|)
operator|(
name|operands
operator|,
literal|1
operator|,
name|low
operator|,
name|high
operator|)
expr_stmt|;
name|emit_insn
argument_list|(
operator|(
name|mode
operator|==
name|DImode
condition|?
name|gen_x86_shrd_1
else|:
name|gen_x86_64_shrd
operator|)
operator|(
name|low
index|[
literal|0
index|]
operator|,
name|high
index|[
literal|0
index|]
operator|,
name|operands
index|[
literal|2
index|]
operator|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
operator|(
name|mode
operator|==
name|DImode
condition|?
name|gen_ashrsi3
else|:
name|gen_ashrdi3
operator|)
operator|(
name|high
index|[
literal|0
index|]
operator|,
name|high
index|[
literal|0
index|]
operator|,
name|operands
index|[
literal|2
index|]
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_CMOVE
operator|&&
name|scratch
condition|)
block|{
name|emit_move_insn
argument_list|(
name|scratch
argument_list|,
name|high
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
operator|(
name|mode
operator|==
name|DImode
condition|?
name|gen_ashrsi3
else|:
name|gen_ashrdi3
operator|)
operator|(
name|scratch
operator|,
name|scratch
operator|,
name|GEN_INT
argument_list|(
name|single_width
operator|-
literal|1
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
operator|(
name|mode
operator|==
name|DImode
condition|?
name|gen_x86_shift_adj_1
else|:
name|gen_x86_64_shift_adj
operator|)
operator|(
name|low
index|[
literal|0
index|]
operator|,
name|high
index|[
literal|0
index|]
operator|,
name|operands
index|[
literal|2
index|]
operator|,
name|scratch
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
name|emit_insn
argument_list|(
name|gen_x86_shift_adj_3
argument_list|(
name|low
index|[
literal|0
index|]
argument_list|,
name|high
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ix86_split_lshr
parameter_list|(
name|rtx
modifier|*
name|operands
parameter_list|,
name|rtx
name|scratch
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|rtx
name|low
index|[
literal|2
index|]
decl_stmt|,
name|high
index|[
literal|2
index|]
decl_stmt|;
name|int
name|count
decl_stmt|;
specifier|const
name|int
name|single_width
init|=
name|mode
operator|==
name|DImode
condition|?
literal|32
else|:
literal|64
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
operator|(
name|mode
operator|==
name|DImode
condition|?
name|split_di
else|:
name|split_ti
operator|)
operator|(
name|operands
operator|,
literal|2
operator|,
name|low
operator|,
name|high
operator|)
expr_stmt|;
name|count
operator|=
name|INTVAL
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|&
operator|(
name|single_width
operator|*
literal|2
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|count
operator|>=
name|single_width
condition|)
block|{
name|emit_move_insn
argument_list|(
name|low
index|[
literal|0
index|]
argument_list|,
name|high
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ix86_expand_clear
argument_list|(
name|high
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
name|single_width
condition|)
name|emit_insn
argument_list|(
operator|(
name|mode
operator|==
name|DImode
condition|?
name|gen_lshrsi3
else|:
name|gen_lshrdi3
operator|)
operator|(
name|low
index|[
literal|0
index|]
operator|,
name|low
index|[
literal|0
index|]
operator|,
name|GEN_INT
argument_list|(
name|count
operator|-
name|single_width
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
name|emit_move_insn
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
operator|(
name|mode
operator|==
name|DImode
condition|?
name|gen_x86_shrd_1
else|:
name|gen_x86_64_shrd
operator|)
operator|(
name|low
index|[
literal|0
index|]
operator|,
name|high
index|[
literal|0
index|]
operator|,
name|GEN_INT
argument_list|(
name|count
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
operator|(
name|mode
operator|==
name|DImode
condition|?
name|gen_lshrsi3
else|:
name|gen_lshrdi3
operator|)
operator|(
name|high
index|[
literal|0
index|]
operator|,
name|high
index|[
literal|0
index|]
operator|,
name|GEN_INT
argument_list|(
name|count
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
name|emit_move_insn
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
operator|(
name|mode
operator|==
name|DImode
condition|?
name|split_di
else|:
name|split_ti
operator|)
operator|(
name|operands
operator|,
literal|1
operator|,
name|low
operator|,
name|high
operator|)
expr_stmt|;
name|emit_insn
argument_list|(
operator|(
name|mode
operator|==
name|DImode
condition|?
name|gen_x86_shrd_1
else|:
name|gen_x86_64_shrd
operator|)
operator|(
name|low
index|[
literal|0
index|]
operator|,
name|high
index|[
literal|0
index|]
operator|,
name|operands
index|[
literal|2
index|]
operator|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
operator|(
name|mode
operator|==
name|DImode
condition|?
name|gen_lshrsi3
else|:
name|gen_lshrdi3
operator|)
operator|(
name|high
index|[
literal|0
index|]
operator|,
name|high
index|[
literal|0
index|]
operator|,
name|operands
index|[
literal|2
index|]
operator|)
argument_list|)
expr_stmt|;
comment|/* Heh.  By reversing the arguments, we can reuse this pattern.  */
if|if
condition|(
name|TARGET_CMOVE
operator|&&
name|scratch
condition|)
block|{
name|ix86_expand_clear
argument_list|(
name|scratch
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
operator|(
name|mode
operator|==
name|DImode
condition|?
name|gen_x86_shift_adj_1
else|:
name|gen_x86_64_shift_adj
operator|)
operator|(
name|low
index|[
literal|0
index|]
operator|,
name|high
index|[
literal|0
index|]
operator|,
name|operands
index|[
literal|2
index|]
operator|,
name|scratch
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
name|emit_insn
argument_list|(
name|gen_x86_shift_adj_2
argument_list|(
name|low
index|[
literal|0
index|]
argument_list|,
name|high
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Helper function for the string operations below.  Dest VARIABLE whether    it is aligned to VALUE bytes.  If true, jump to the label.  */
end_comment

begin_function
specifier|static
name|rtx
name|ix86_expand_aligntest
parameter_list|(
name|rtx
name|variable
parameter_list|,
name|int
name|value
parameter_list|)
block|{
name|rtx
name|label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|rtx
name|tmpcount
init|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|variable
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|variable
argument_list|)
operator|==
name|DImode
condition|)
name|emit_insn
argument_list|(
name|gen_anddi3
argument_list|(
name|tmpcount
argument_list|,
name|variable
argument_list|,
name|GEN_INT
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_andsi3
argument_list|(
name|tmpcount
argument_list|,
name|variable
argument_list|,
name|GEN_INT
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|tmpcount
argument_list|,
name|const0_rtx
argument_list|,
name|EQ
argument_list|,
literal|0
argument_list|,
name|GET_MODE
argument_list|(
name|variable
argument_list|)
argument_list|,
literal|1
argument_list|,
name|label
argument_list|)
expr_stmt|;
return|return
name|label
return|;
block|}
end_function

begin_comment
comment|/* Adjust COUNTER by the VALUE.  */
end_comment

begin_function
specifier|static
name|void
name|ix86_adjust_counter
parameter_list|(
name|rtx
name|countreg
parameter_list|,
name|HOST_WIDE_INT
name|value
parameter_list|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|countreg
argument_list|)
operator|==
name|DImode
condition|)
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|countreg
argument_list|,
name|countreg
argument_list|,
name|GEN_INT
argument_list|(
operator|-
name|value
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|countreg
argument_list|,
name|countreg
argument_list|,
name|GEN_INT
argument_list|(
operator|-
name|value
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Zero extend possibly SImode EXP to Pmode register.  */
end_comment

begin_function
name|rtx
name|ix86_zero_extend_to_Pmode
parameter_list|(
name|rtx
name|exp
parameter_list|)
block|{
name|rtx
name|r
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|exp
argument_list|)
operator|==
name|VOIDmode
condition|)
return|return
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|exp
argument_list|)
return|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|exp
argument_list|)
operator|==
name|Pmode
condition|)
return|return
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|exp
argument_list|)
return|;
name|r
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_zero_extendsidi2
argument_list|(
name|r
argument_list|,
name|exp
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Expand string move (memcpy) operation.  Use i386 string operations when    profitable.  expand_clrmem contains similar code.  */
end_comment

begin_function
name|int
name|ix86_expand_movmem
parameter_list|(
name|rtx
name|dst
parameter_list|,
name|rtx
name|src
parameter_list|,
name|rtx
name|count_exp
parameter_list|,
name|rtx
name|align_exp
parameter_list|)
block|{
name|rtx
name|srcreg
decl_stmt|,
name|destreg
decl_stmt|,
name|countreg
decl_stmt|,
name|srcexp
decl_stmt|,
name|destexp
decl_stmt|;
name|enum
name|machine_mode
name|counter_mode
decl_stmt|;
name|HOST_WIDE_INT
name|align
init|=
literal|0
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|count
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|align_exp
argument_list|)
operator|==
name|CONST_INT
condition|)
name|align
operator|=
name|INTVAL
argument_list|(
name|align_exp
argument_list|)
expr_stmt|;
comment|/* Can't use any of this if the user has appropriated esi or edi.  */
if|if
condition|(
name|global_regs
index|[
literal|4
index|]
operator|||
name|global_regs
index|[
literal|5
index|]
condition|)
return|return
literal|0
return|;
comment|/* This simple hack avoids all inlining code and simplifies code below.  */
if|if
condition|(
operator|!
name|TARGET_ALIGN_STRINGOPS
condition|)
name|align
operator|=
literal|64
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|count_exp
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|count
operator|=
name|INTVAL
argument_list|(
name|count_exp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TARGET_INLINE_ALL_STRINGOPS
operator|&&
name|count
operator|>
literal|64
condition|)
return|return
literal|0
return|;
block|}
comment|/* Figure out proper mode for counter.  For 32bits it is always SImode,      for 64bits use SImode when possible, otherwise DImode.      Set count to number of bytes copied when known at compile time.  */
if|if
condition|(
operator|!
name|TARGET_64BIT
operator|||
name|GET_MODE
argument_list|(
name|count_exp
argument_list|)
operator|==
name|SImode
operator|||
name|x86_64_zext_immediate_operand
argument_list|(
name|count_exp
argument_list|,
name|VOIDmode
argument_list|)
condition|)
name|counter_mode
operator|=
name|SImode
expr_stmt|;
else|else
name|counter_mode
operator|=
name|DImode
expr_stmt|;
name|gcc_assert
argument_list|(
name|counter_mode
operator|==
name|SImode
operator|||
name|counter_mode
operator|==
name|DImode
argument_list|)
expr_stmt|;
name|destreg
operator|=
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|destreg
operator|!=
name|XEXP
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
condition|)
name|dst
operator|=
name|replace_equiv_address_nv
argument_list|(
name|dst
argument_list|,
name|destreg
argument_list|)
expr_stmt|;
name|srcreg
operator|=
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|srcreg
operator|!=
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
condition|)
name|src
operator|=
name|replace_equiv_address_nv
argument_list|(
name|src
argument_list|,
name|srcreg
argument_list|)
expr_stmt|;
comment|/* When optimizing for size emit simple rep ; movsb instruction for      counts not divisible by 4, except when (movsl;)*(movsw;)?(movsb;)?      sequence is shorter than mov{b,l} $count, %{ecx,cl}; rep; movsb.      Sice of (movsl;)*(movsw;)?(movsb;)? sequence is      count / 4 + (count& 3), the other sequence is either 4 or 7 bytes,      but we don't know whether upper 24 (resp. 56) bits of %ecx will be      known to be zero or not.  The rep; movsb sequence causes higher      register pressure though, so take that into account.  */
if|if
condition|(
operator|(
operator|!
name|optimize
operator|||
name|optimize_size
operator|)
operator|&&
operator|(
name|count
operator|==
literal|0
operator|||
operator|(
operator|(
name|count
operator|&
literal|0x03
operator|)
operator|&&
operator|(
operator|!
name|optimize_size
operator|||
name|count
operator|>
literal|5
operator|*
literal|4
operator|||
operator|(
name|count
operator|&
literal|3
operator|)
operator|+
name|count
operator|/
literal|4
operator|>
literal|6
operator|)
operator|)
operator|)
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_cld
argument_list|()
argument_list|)
expr_stmt|;
name|countreg
operator|=
name|ix86_zero_extend_to_Pmode
argument_list|(
name|count_exp
argument_list|)
expr_stmt|;
name|destexp
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|destreg
argument_list|,
name|countreg
argument_list|)
expr_stmt|;
name|srcexp
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|srcreg
argument_list|,
name|countreg
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rep_mov
argument_list|(
name|destreg
argument_list|,
name|dst
argument_list|,
name|srcreg
argument_list|,
name|src
argument_list|,
name|countreg
argument_list|,
name|destexp
argument_list|,
name|srcexp
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* For constant aligned (or small unaligned) copies use rep movsl      followed by code copying the rest.  For PentiumPro ensure 8 byte      alignment to allow rep movsl acceleration.  */
elseif|else
if|if
condition|(
name|count
operator|!=
literal|0
operator|&&
operator|(
name|align
operator|>=
literal|8
operator|||
operator|(
operator|!
name|TARGET_PENTIUMPRO
operator|&&
operator|!
name|TARGET_64BIT
operator|&&
name|align
operator|>=
literal|4
operator|)
operator|||
name|optimize_size
operator|||
name|count
operator|<
operator|(
name|unsigned
name|int
operator|)
literal|64
operator|)
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|offset
init|=
literal|0
decl_stmt|;
name|int
name|size
init|=
name|TARGET_64BIT
operator|&&
operator|!
name|optimize_size
condition|?
literal|8
else|:
literal|4
decl_stmt|;
name|rtx
name|srcmem
decl_stmt|,
name|dstmem
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_cld
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|&
operator|~
operator|(
name|size
operator|-
literal|1
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|TARGET_SINGLE_STRINGOP
operator|||
name|optimize_size
operator|)
operator|&&
name|count
operator|<
literal|5
operator|*
literal|4
condition|)
block|{
name|enum
name|machine_mode
name|movs_mode
init|=
name|size
operator|==
literal|4
condition|?
name|SImode
else|:
name|DImode
decl_stmt|;
while|while
condition|(
name|offset
operator|<
operator|(
name|count
operator|&
operator|~
operator|(
name|size
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
name|srcmem
operator|=
name|adjust_automodify_address_nv
argument_list|(
name|src
argument_list|,
name|movs_mode
argument_list|,
name|srcreg
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|dstmem
operator|=
name|adjust_automodify_address_nv
argument_list|(
name|dst
argument_list|,
name|movs_mode
argument_list|,
name|destreg
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_strmov
argument_list|(
name|destreg
argument_list|,
name|dstmem
argument_list|,
name|srcreg
argument_list|,
name|srcmem
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|size
expr_stmt|;
block|}
block|}
else|else
block|{
name|countreg
operator|=
name|GEN_INT
argument_list|(
operator|(
name|count
operator|>>
operator|(
name|size
operator|==
literal|4
condition|?
literal|2
else|:
literal|3
operator|)
operator|)
operator|&
operator|(
name|TARGET_64BIT
condition|?
operator|-
literal|1
else|:
literal|0x3fffffff
operator|)
argument_list|)
expr_stmt|;
name|countreg
operator|=
name|copy_to_mode_reg
argument_list|(
name|counter_mode
argument_list|,
name|countreg
argument_list|)
expr_stmt|;
name|countreg
operator|=
name|ix86_zero_extend_to_Pmode
argument_list|(
name|countreg
argument_list|)
expr_stmt|;
name|destexp
operator|=
name|gen_rtx_ASHIFT
argument_list|(
name|Pmode
argument_list|,
name|countreg
argument_list|,
name|GEN_INT
argument_list|(
name|size
operator|==
literal|4
condition|?
literal|2
else|:
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|srcexp
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|destexp
argument_list|,
name|srcreg
argument_list|)
expr_stmt|;
name|destexp
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|destexp
argument_list|,
name|destreg
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rep_mov
argument_list|(
name|destreg
argument_list|,
name|dst
argument_list|,
name|srcreg
argument_list|,
name|src
argument_list|,
name|countreg
argument_list|,
name|destexp
argument_list|,
name|srcexp
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|=
name|count
operator|&
operator|~
operator|(
name|size
operator|-
literal|1
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|size
operator|==
literal|8
operator|&&
operator|(
name|count
operator|&
literal|0x04
operator|)
condition|)
block|{
name|srcmem
operator|=
name|adjust_automodify_address_nv
argument_list|(
name|src
argument_list|,
name|SImode
argument_list|,
name|srcreg
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|dstmem
operator|=
name|adjust_automodify_address_nv
argument_list|(
name|dst
argument_list|,
name|SImode
argument_list|,
name|destreg
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_strmov
argument_list|(
name|destreg
argument_list|,
name|dstmem
argument_list|,
name|srcreg
argument_list|,
name|srcmem
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|&
literal|0x02
condition|)
block|{
name|srcmem
operator|=
name|adjust_automodify_address_nv
argument_list|(
name|src
argument_list|,
name|HImode
argument_list|,
name|srcreg
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|dstmem
operator|=
name|adjust_automodify_address_nv
argument_list|(
name|dst
argument_list|,
name|HImode
argument_list|,
name|destreg
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_strmov
argument_list|(
name|destreg
argument_list|,
name|dstmem
argument_list|,
name|srcreg
argument_list|,
name|srcmem
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|&
literal|0x01
condition|)
block|{
name|srcmem
operator|=
name|adjust_automodify_address_nv
argument_list|(
name|src
argument_list|,
name|QImode
argument_list|,
name|srcreg
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|dstmem
operator|=
name|adjust_automodify_address_nv
argument_list|(
name|dst
argument_list|,
name|QImode
argument_list|,
name|destreg
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_strmov
argument_list|(
name|destreg
argument_list|,
name|dstmem
argument_list|,
name|srcreg
argument_list|,
name|srcmem
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* The generic code based on the glibc implementation:      - align destination to 4 bytes (8 byte alignment is used for PentiumPro      allowing accelerated copying there)      - copy the data using rep movsl      - copy the rest.  */
else|else
block|{
name|rtx
name|countreg2
decl_stmt|;
name|rtx
name|label
init|=
name|NULL
decl_stmt|;
name|rtx
name|srcmem
decl_stmt|,
name|dstmem
decl_stmt|;
name|int
name|desired_alignment
init|=
operator|(
name|TARGET_PENTIUMPRO
operator|&&
operator|(
name|count
operator|==
literal|0
operator|||
name|count
operator|>=
operator|(
name|unsigned
name|int
operator|)
literal|260
operator|)
condition|?
literal|8
else|:
name|UNITS_PER_WORD
operator|)
decl_stmt|;
comment|/* Get rid of MEM_OFFSETs, they won't be accurate.  */
name|dst
operator|=
name|change_address
argument_list|(
name|dst
argument_list|,
name|BLKmode
argument_list|,
name|destreg
argument_list|)
expr_stmt|;
name|src
operator|=
name|change_address
argument_list|(
name|src
argument_list|,
name|BLKmode
argument_list|,
name|srcreg
argument_list|)
expr_stmt|;
comment|/* In case we don't know anything about the alignment, default to          library version, since it is usually equally fast and result in          shorter code.  	 Also emit call when we know that the count is large and call overhead 	 will not be important.  */
if|if
condition|(
operator|!
name|TARGET_INLINE_ALL_STRINGOPS
operator|&&
operator|(
name|align
operator|<
name|UNITS_PER_WORD
operator|||
operator|!
name|TARGET_REP_MOVL_OPTIMAL
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TARGET_SINGLE_STRINGOP
condition|)
name|emit_insn
argument_list|(
name|gen_cld
argument_list|()
argument_list|)
expr_stmt|;
name|countreg2
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|countreg
operator|=
name|copy_to_mode_reg
argument_list|(
name|counter_mode
argument_list|,
name|count_exp
argument_list|)
expr_stmt|;
comment|/* We don't use loops to align destination and to copy parts smaller          than 4 bytes, because gcc is able to optimize such code better (in          the case the destination or the count really is aligned, gcc is often          able to predict the branches) and also it is friendlier to the          hardware branch prediction.           Using loops is beneficial for generic case, because we can          handle small counts using the loops.  Many CPUs (such as Athlon)          have large REP prefix setup costs.           This is quite costly.  Maybe we can revisit this decision later or          add some customizability to this code.  */
if|if
condition|(
name|count
operator|==
literal|0
operator|&&
name|align
operator|<
name|desired_alignment
condition|)
block|{
name|label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|countreg
argument_list|,
name|GEN_INT
argument_list|(
name|desired_alignment
operator|-
literal|1
argument_list|)
argument_list|,
name|LEU
argument_list|,
literal|0
argument_list|,
name|counter_mode
argument_list|,
literal|1
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|align
operator|<=
literal|1
condition|)
block|{
name|rtx
name|label
init|=
name|ix86_expand_aligntest
argument_list|(
name|destreg
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|srcmem
operator|=
name|change_address
argument_list|(
name|src
argument_list|,
name|QImode
argument_list|,
name|srcreg
argument_list|)
expr_stmt|;
name|dstmem
operator|=
name|change_address
argument_list|(
name|dst
argument_list|,
name|QImode
argument_list|,
name|destreg
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_strmov
argument_list|(
name|destreg
argument_list|,
name|dstmem
argument_list|,
name|srcreg
argument_list|,
name|srcmem
argument_list|)
argument_list|)
expr_stmt|;
name|ix86_adjust_counter
argument_list|(
name|countreg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|align
operator|<=
literal|2
condition|)
block|{
name|rtx
name|label
init|=
name|ix86_expand_aligntest
argument_list|(
name|destreg
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|srcmem
operator|=
name|change_address
argument_list|(
name|src
argument_list|,
name|HImode
argument_list|,
name|srcreg
argument_list|)
expr_stmt|;
name|dstmem
operator|=
name|change_address
argument_list|(
name|dst
argument_list|,
name|HImode
argument_list|,
name|destreg
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_strmov
argument_list|(
name|destreg
argument_list|,
name|dstmem
argument_list|,
name|srcreg
argument_list|,
name|srcmem
argument_list|)
argument_list|)
expr_stmt|;
name|ix86_adjust_counter
argument_list|(
name|countreg
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|align
operator|<=
literal|4
operator|&&
name|desired_alignment
operator|>
literal|4
condition|)
block|{
name|rtx
name|label
init|=
name|ix86_expand_aligntest
argument_list|(
name|destreg
argument_list|,
literal|4
argument_list|)
decl_stmt|;
name|srcmem
operator|=
name|change_address
argument_list|(
name|src
argument_list|,
name|SImode
argument_list|,
name|srcreg
argument_list|)
expr_stmt|;
name|dstmem
operator|=
name|change_address
argument_list|(
name|dst
argument_list|,
name|SImode
argument_list|,
name|destreg
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_strmov
argument_list|(
name|destreg
argument_list|,
name|dstmem
argument_list|,
name|srcreg
argument_list|,
name|srcmem
argument_list|)
argument_list|)
expr_stmt|;
name|ix86_adjust_counter
argument_list|(
name|countreg
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|label
operator|&&
name|desired_alignment
operator|>
literal|4
operator|&&
operator|!
name|TARGET_64BIT
condition|)
block|{
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|=
literal|1
expr_stmt|;
name|label
operator|=
name|NULL_RTX
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TARGET_SINGLE_STRINGOP
condition|)
name|emit_insn
argument_list|(
name|gen_cld
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_lshrdi3
argument_list|(
name|countreg2
argument_list|,
name|ix86_zero_extend_to_Pmode
argument_list|(
name|countreg
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
literal|3
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|destexp
operator|=
name|gen_rtx_ASHIFT
argument_list|(
name|Pmode
argument_list|,
name|countreg2
argument_list|,
name|GEN_INT
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|emit_insn
argument_list|(
name|gen_lshrsi3
argument_list|(
name|countreg2
argument_list|,
name|countreg
argument_list|,
name|const2_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|destexp
operator|=
name|gen_rtx_ASHIFT
argument_list|(
name|Pmode
argument_list|,
name|countreg2
argument_list|,
name|const2_rtx
argument_list|)
expr_stmt|;
block|}
name|srcexp
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|destexp
argument_list|,
name|srcreg
argument_list|)
expr_stmt|;
name|destexp
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|destexp
argument_list|,
name|destreg
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rep_mov
argument_list|(
name|destreg
argument_list|,
name|dst
argument_list|,
name|srcreg
argument_list|,
name|src
argument_list|,
name|countreg2
argument_list|,
name|destexp
argument_list|,
name|srcexp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|label
condition|)
block|{
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_64BIT
operator|&&
name|align
operator|>
literal|4
operator|&&
name|count
operator|!=
literal|0
operator|&&
operator|(
name|count
operator|&
literal|4
operator|)
condition|)
block|{
name|srcmem
operator|=
name|change_address
argument_list|(
name|src
argument_list|,
name|SImode
argument_list|,
name|srcreg
argument_list|)
expr_stmt|;
name|dstmem
operator|=
name|change_address
argument_list|(
name|dst
argument_list|,
name|SImode
argument_list|,
name|destreg
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_strmov
argument_list|(
name|destreg
argument_list|,
name|dstmem
argument_list|,
name|srcreg
argument_list|,
name|srcmem
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|align
operator|<=
literal|4
operator|||
name|count
operator|==
literal|0
operator|)
operator|&&
name|TARGET_64BIT
condition|)
block|{
name|rtx
name|label
init|=
name|ix86_expand_aligntest
argument_list|(
name|countreg
argument_list|,
literal|4
argument_list|)
decl_stmt|;
name|srcmem
operator|=
name|change_address
argument_list|(
name|src
argument_list|,
name|SImode
argument_list|,
name|srcreg
argument_list|)
expr_stmt|;
name|dstmem
operator|=
name|change_address
argument_list|(
name|dst
argument_list|,
name|SImode
argument_list|,
name|destreg
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_strmov
argument_list|(
name|destreg
argument_list|,
name|dstmem
argument_list|,
name|srcreg
argument_list|,
name|srcmem
argument_list|)
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|align
operator|>
literal|2
operator|&&
name|count
operator|!=
literal|0
operator|&&
operator|(
name|count
operator|&
literal|2
operator|)
condition|)
block|{
name|srcmem
operator|=
name|change_address
argument_list|(
name|src
argument_list|,
name|HImode
argument_list|,
name|srcreg
argument_list|)
expr_stmt|;
name|dstmem
operator|=
name|change_address
argument_list|(
name|dst
argument_list|,
name|HImode
argument_list|,
name|destreg
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_strmov
argument_list|(
name|destreg
argument_list|,
name|dstmem
argument_list|,
name|srcreg
argument_list|,
name|srcmem
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|align
operator|<=
literal|2
operator|||
name|count
operator|==
literal|0
condition|)
block|{
name|rtx
name|label
init|=
name|ix86_expand_aligntest
argument_list|(
name|countreg
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|srcmem
operator|=
name|change_address
argument_list|(
name|src
argument_list|,
name|HImode
argument_list|,
name|srcreg
argument_list|)
expr_stmt|;
name|dstmem
operator|=
name|change_address
argument_list|(
name|dst
argument_list|,
name|HImode
argument_list|,
name|destreg
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_strmov
argument_list|(
name|destreg
argument_list|,
name|dstmem
argument_list|,
name|srcreg
argument_list|,
name|srcmem
argument_list|)
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|align
operator|>
literal|1
operator|&&
name|count
operator|!=
literal|0
operator|&&
operator|(
name|count
operator|&
literal|1
operator|)
condition|)
block|{
name|srcmem
operator|=
name|change_address
argument_list|(
name|src
argument_list|,
name|QImode
argument_list|,
name|srcreg
argument_list|)
expr_stmt|;
name|dstmem
operator|=
name|change_address
argument_list|(
name|dst
argument_list|,
name|QImode
argument_list|,
name|destreg
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_strmov
argument_list|(
name|destreg
argument_list|,
name|dstmem
argument_list|,
name|srcreg
argument_list|,
name|srcmem
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|align
operator|<=
literal|1
operator|||
name|count
operator|==
literal|0
condition|)
block|{
name|rtx
name|label
init|=
name|ix86_expand_aligntest
argument_list|(
name|countreg
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|srcmem
operator|=
name|change_address
argument_list|(
name|src
argument_list|,
name|QImode
argument_list|,
name|srcreg
argument_list|)
expr_stmt|;
name|dstmem
operator|=
name|change_address
argument_list|(
name|dst
argument_list|,
name|QImode
argument_list|,
name|destreg
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_strmov
argument_list|(
name|destreg
argument_list|,
name|dstmem
argument_list|,
name|srcreg
argument_list|,
name|srcmem
argument_list|)
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Expand string clear operation (bzero).  Use i386 string operations when    profitable.  expand_movmem contains similar code.  */
end_comment

begin_function
name|int
name|ix86_expand_clrmem
parameter_list|(
name|rtx
name|dst
parameter_list|,
name|rtx
name|count_exp
parameter_list|,
name|rtx
name|align_exp
parameter_list|)
block|{
name|rtx
name|destreg
decl_stmt|,
name|zeroreg
decl_stmt|,
name|countreg
decl_stmt|,
name|destexp
decl_stmt|;
name|enum
name|machine_mode
name|counter_mode
decl_stmt|;
name|HOST_WIDE_INT
name|align
init|=
literal|0
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|count
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|align_exp
argument_list|)
operator|==
name|CONST_INT
condition|)
name|align
operator|=
name|INTVAL
argument_list|(
name|align_exp
argument_list|)
expr_stmt|;
comment|/* Can't use any of this if the user has appropriated esi.  */
if|if
condition|(
name|global_regs
index|[
literal|4
index|]
condition|)
return|return
literal|0
return|;
comment|/* This simple hack avoids all inlining code and simplifies code below.  */
if|if
condition|(
operator|!
name|TARGET_ALIGN_STRINGOPS
condition|)
name|align
operator|=
literal|32
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|count_exp
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|count
operator|=
name|INTVAL
argument_list|(
name|count_exp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TARGET_INLINE_ALL_STRINGOPS
operator|&&
name|count
operator|>
literal|64
condition|)
return|return
literal|0
return|;
block|}
comment|/* Figure out proper mode for counter.  For 32bits it is always SImode,      for 64bits use SImode when possible, otherwise DImode.      Set count to number of bytes copied when known at compile time.  */
if|if
condition|(
operator|!
name|TARGET_64BIT
operator|||
name|GET_MODE
argument_list|(
name|count_exp
argument_list|)
operator|==
name|SImode
operator|||
name|x86_64_zext_immediate_operand
argument_list|(
name|count_exp
argument_list|,
name|VOIDmode
argument_list|)
condition|)
name|counter_mode
operator|=
name|SImode
expr_stmt|;
else|else
name|counter_mode
operator|=
name|DImode
expr_stmt|;
name|destreg
operator|=
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|destreg
operator|!=
name|XEXP
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
condition|)
name|dst
operator|=
name|replace_equiv_address_nv
argument_list|(
name|dst
argument_list|,
name|destreg
argument_list|)
expr_stmt|;
comment|/* When optimizing for size emit simple rep ; movsb instruction for      counts not divisible by 4.  The movl $N, %ecx; rep; stosb      sequence is 7 bytes long, so if optimizing for size and count is      small enough that some stosl, stosw and stosb instructions without      rep are shorter, fall back into the next if.  */
if|if
condition|(
operator|(
operator|!
name|optimize
operator|||
name|optimize_size
operator|)
operator|&&
operator|(
name|count
operator|==
literal|0
operator|||
operator|(
operator|(
name|count
operator|&
literal|0x03
operator|)
operator|&&
operator|(
operator|!
name|optimize_size
operator|||
operator|(
name|count
operator|&
literal|0x03
operator|)
operator|+
operator|(
name|count
operator|>>
literal|2
operator|)
operator|>
literal|7
operator|)
operator|)
operator|)
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_cld
argument_list|()
argument_list|)
expr_stmt|;
name|countreg
operator|=
name|ix86_zero_extend_to_Pmode
argument_list|(
name|count_exp
argument_list|)
expr_stmt|;
name|zeroreg
operator|=
name|copy_to_mode_reg
argument_list|(
name|QImode
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|destexp
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|destreg
argument_list|,
name|countreg
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rep_stos
argument_list|(
name|destreg
argument_list|,
name|countreg
argument_list|,
name|dst
argument_list|,
name|zeroreg
argument_list|,
name|destexp
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|count
operator|!=
literal|0
operator|&&
operator|(
name|align
operator|>=
literal|8
operator|||
operator|(
operator|!
name|TARGET_PENTIUMPRO
operator|&&
operator|!
name|TARGET_64BIT
operator|&&
name|align
operator|>=
literal|4
operator|)
operator|||
name|optimize_size
operator|||
name|count
operator|<
operator|(
name|unsigned
name|int
operator|)
literal|64
operator|)
condition|)
block|{
name|int
name|size
init|=
name|TARGET_64BIT
operator|&&
operator|!
name|optimize_size
condition|?
literal|8
else|:
literal|4
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|offset
init|=
literal|0
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_cld
argument_list|()
argument_list|)
expr_stmt|;
name|zeroreg
operator|=
name|copy_to_mode_reg
argument_list|(
name|size
operator|==
literal|4
condition|?
name|SImode
else|:
name|DImode
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|&
operator|~
operator|(
name|size
operator|-
literal|1
operator|)
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|repcount
decl_stmt|;
name|unsigned
name|int
name|max_nonrep
decl_stmt|;
name|repcount
operator|=
name|count
operator|>>
operator|(
name|size
operator|==
literal|4
condition|?
literal|2
else|:
literal|3
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|TARGET_64BIT
condition|)
name|repcount
operator|&=
literal|0x3fffffff
expr_stmt|;
comment|/* movl $N, %ecx; rep; stosl is 7 bytes, while N x stosl is N bytes. 	     movl $N, %ecx; rep; stosq is 8 bytes, while N x stosq is 2xN 	     bytes.  In both cases the latter seems to be faster for small 	     values of N.  */
name|max_nonrep
operator|=
name|size
operator|==
literal|4
condition|?
literal|7
else|:
literal|4
expr_stmt|;
if|if
condition|(
operator|!
name|optimize_size
condition|)
switch|switch
condition|(
name|ix86_tune
condition|)
block|{
case|case
name|PROCESSOR_PENTIUM4
case|:
case|case
name|PROCESSOR_NOCONA
case|:
name|max_nonrep
operator|=
literal|3
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|repcount
operator|<=
name|max_nonrep
condition|)
while|while
condition|(
name|repcount
operator|--
operator|>
literal|0
condition|)
block|{
name|rtx
name|mem
init|=
name|adjust_automodify_address_nv
argument_list|(
name|dst
argument_list|,
name|GET_MODE
argument_list|(
name|zeroreg
argument_list|)
argument_list|,
name|destreg
argument_list|,
name|offset
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_strset
argument_list|(
name|destreg
argument_list|,
name|mem
argument_list|,
name|zeroreg
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|size
expr_stmt|;
block|}
else|else
block|{
name|countreg
operator|=
name|copy_to_mode_reg
argument_list|(
name|counter_mode
argument_list|,
name|GEN_INT
argument_list|(
name|repcount
argument_list|)
argument_list|)
expr_stmt|;
name|countreg
operator|=
name|ix86_zero_extend_to_Pmode
argument_list|(
name|countreg
argument_list|)
expr_stmt|;
name|destexp
operator|=
name|gen_rtx_ASHIFT
argument_list|(
name|Pmode
argument_list|,
name|countreg
argument_list|,
name|GEN_INT
argument_list|(
name|size
operator|==
literal|4
condition|?
literal|2
else|:
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|destexp
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|destexp
argument_list|,
name|destreg
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rep_stos
argument_list|(
name|destreg
argument_list|,
name|countreg
argument_list|,
name|dst
argument_list|,
name|zeroreg
argument_list|,
name|destexp
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|=
name|count
operator|&
operator|~
operator|(
name|size
operator|-
literal|1
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|size
operator|==
literal|8
operator|&&
operator|(
name|count
operator|&
literal|0x04
operator|)
condition|)
block|{
name|rtx
name|mem
init|=
name|adjust_automodify_address_nv
argument_list|(
name|dst
argument_list|,
name|SImode
argument_list|,
name|destreg
argument_list|,
name|offset
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_strset
argument_list|(
name|destreg
argument_list|,
name|mem
argument_list|,
name|gen_rtx_SUBREG
argument_list|(
name|SImode
argument_list|,
name|zeroreg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|&
literal|0x02
condition|)
block|{
name|rtx
name|mem
init|=
name|adjust_automodify_address_nv
argument_list|(
name|dst
argument_list|,
name|HImode
argument_list|,
name|destreg
argument_list|,
name|offset
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_strset
argument_list|(
name|destreg
argument_list|,
name|mem
argument_list|,
name|gen_rtx_SUBREG
argument_list|(
name|HImode
argument_list|,
name|zeroreg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|&
literal|0x01
condition|)
block|{
name|rtx
name|mem
init|=
name|adjust_automodify_address_nv
argument_list|(
name|dst
argument_list|,
name|QImode
argument_list|,
name|destreg
argument_list|,
name|offset
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_strset
argument_list|(
name|destreg
argument_list|,
name|mem
argument_list|,
name|gen_rtx_SUBREG
argument_list|(
name|QImode
argument_list|,
name|zeroreg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|rtx
name|countreg2
decl_stmt|;
name|rtx
name|label
init|=
name|NULL
decl_stmt|;
comment|/* Compute desired alignment of the string operation.  */
name|int
name|desired_alignment
init|=
operator|(
name|TARGET_PENTIUMPRO
operator|&&
operator|(
name|count
operator|==
literal|0
operator|||
name|count
operator|>=
operator|(
name|unsigned
name|int
operator|)
literal|260
operator|)
condition|?
literal|8
else|:
name|UNITS_PER_WORD
operator|)
decl_stmt|;
comment|/* In case we don't know anything about the alignment, default to          library version, since it is usually equally fast and result in          shorter code.  	 Also emit call when we know that the count is large and call overhead 	 will not be important.  */
if|if
condition|(
operator|!
name|TARGET_INLINE_ALL_STRINGOPS
operator|&&
operator|(
name|align
operator|<
name|UNITS_PER_WORD
operator|||
operator|!
name|TARGET_REP_MOVL_OPTIMAL
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TARGET_SINGLE_STRINGOP
condition|)
name|emit_insn
argument_list|(
name|gen_cld
argument_list|()
argument_list|)
expr_stmt|;
name|countreg2
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|countreg
operator|=
name|copy_to_mode_reg
argument_list|(
name|counter_mode
argument_list|,
name|count_exp
argument_list|)
expr_stmt|;
name|zeroreg
operator|=
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
comment|/* Get rid of MEM_OFFSET, it won't be accurate.  */
name|dst
operator|=
name|change_address
argument_list|(
name|dst
argument_list|,
name|BLKmode
argument_list|,
name|destreg
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
operator|&&
name|align
operator|<
name|desired_alignment
condition|)
block|{
name|label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|countreg
argument_list|,
name|GEN_INT
argument_list|(
name|desired_alignment
operator|-
literal|1
argument_list|)
argument_list|,
name|LEU
argument_list|,
literal|0
argument_list|,
name|counter_mode
argument_list|,
literal|1
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|align
operator|<=
literal|1
condition|)
block|{
name|rtx
name|label
init|=
name|ix86_expand_aligntest
argument_list|(
name|destreg
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_strset
argument_list|(
name|destreg
argument_list|,
name|dst
argument_list|,
name|gen_rtx_SUBREG
argument_list|(
name|QImode
argument_list|,
name|zeroreg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ix86_adjust_counter
argument_list|(
name|countreg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|align
operator|<=
literal|2
condition|)
block|{
name|rtx
name|label
init|=
name|ix86_expand_aligntest
argument_list|(
name|destreg
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_strset
argument_list|(
name|destreg
argument_list|,
name|dst
argument_list|,
name|gen_rtx_SUBREG
argument_list|(
name|HImode
argument_list|,
name|zeroreg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ix86_adjust_counter
argument_list|(
name|countreg
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|align
operator|<=
literal|4
operator|&&
name|desired_alignment
operator|>
literal|4
condition|)
block|{
name|rtx
name|label
init|=
name|ix86_expand_aligntest
argument_list|(
name|destreg
argument_list|,
literal|4
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_strset
argument_list|(
name|destreg
argument_list|,
name|dst
argument_list|,
operator|(
name|TARGET_64BIT
condition|?
name|gen_rtx_SUBREG
argument_list|(
name|SImode
argument_list|,
name|zeroreg
argument_list|,
literal|0
argument_list|)
else|:
name|zeroreg
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|ix86_adjust_counter
argument_list|(
name|countreg
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|label
operator|&&
name|desired_alignment
operator|>
literal|4
operator|&&
operator|!
name|TARGET_64BIT
condition|)
block|{
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|=
literal|1
expr_stmt|;
name|label
operator|=
name|NULL_RTX
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TARGET_SINGLE_STRINGOP
condition|)
name|emit_insn
argument_list|(
name|gen_cld
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_lshrdi3
argument_list|(
name|countreg2
argument_list|,
name|ix86_zero_extend_to_Pmode
argument_list|(
name|countreg
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
literal|3
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|destexp
operator|=
name|gen_rtx_ASHIFT
argument_list|(
name|Pmode
argument_list|,
name|countreg2
argument_list|,
name|GEN_INT
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|emit_insn
argument_list|(
name|gen_lshrsi3
argument_list|(
name|countreg2
argument_list|,
name|countreg
argument_list|,
name|const2_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|destexp
operator|=
name|gen_rtx_ASHIFT
argument_list|(
name|Pmode
argument_list|,
name|countreg2
argument_list|,
name|const2_rtx
argument_list|)
expr_stmt|;
block|}
name|destexp
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|destexp
argument_list|,
name|destreg
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rep_stos
argument_list|(
name|destreg
argument_list|,
name|countreg2
argument_list|,
name|dst
argument_list|,
name|zeroreg
argument_list|,
name|destexp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|label
condition|)
block|{
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_64BIT
operator|&&
name|align
operator|>
literal|4
operator|&&
name|count
operator|!=
literal|0
operator|&&
operator|(
name|count
operator|&
literal|4
operator|)
condition|)
name|emit_insn
argument_list|(
name|gen_strset
argument_list|(
name|destreg
argument_list|,
name|dst
argument_list|,
name|gen_rtx_SUBREG
argument_list|(
name|SImode
argument_list|,
name|zeroreg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
operator|&&
operator|(
name|align
operator|<=
literal|4
operator|||
name|count
operator|==
literal|0
operator|)
condition|)
block|{
name|rtx
name|label
init|=
name|ix86_expand_aligntest
argument_list|(
name|countreg
argument_list|,
literal|4
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_strset
argument_list|(
name|destreg
argument_list|,
name|dst
argument_list|,
name|gen_rtx_SUBREG
argument_list|(
name|SImode
argument_list|,
name|zeroreg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|align
operator|>
literal|2
operator|&&
name|count
operator|!=
literal|0
operator|&&
operator|(
name|count
operator|&
literal|2
operator|)
condition|)
name|emit_insn
argument_list|(
name|gen_strset
argument_list|(
name|destreg
argument_list|,
name|dst
argument_list|,
name|gen_rtx_SUBREG
argument_list|(
name|HImode
argument_list|,
name|zeroreg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|align
operator|<=
literal|2
operator|||
name|count
operator|==
literal|0
condition|)
block|{
name|rtx
name|label
init|=
name|ix86_expand_aligntest
argument_list|(
name|countreg
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_strset
argument_list|(
name|destreg
argument_list|,
name|dst
argument_list|,
name|gen_rtx_SUBREG
argument_list|(
name|HImode
argument_list|,
name|zeroreg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|align
operator|>
literal|1
operator|&&
name|count
operator|!=
literal|0
operator|&&
operator|(
name|count
operator|&
literal|1
operator|)
condition|)
name|emit_insn
argument_list|(
name|gen_strset
argument_list|(
name|destreg
argument_list|,
name|dst
argument_list|,
name|gen_rtx_SUBREG
argument_list|(
name|QImode
argument_list|,
name|zeroreg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|align
operator|<=
literal|1
operator|||
name|count
operator|==
literal|0
condition|)
block|{
name|rtx
name|label
init|=
name|ix86_expand_aligntest
argument_list|(
name|countreg
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_strset
argument_list|(
name|destreg
argument_list|,
name|dst
argument_list|,
name|gen_rtx_SUBREG
argument_list|(
name|QImode
argument_list|,
name|zeroreg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Expand strlen.  */
end_comment

begin_function
name|int
name|ix86_expand_strlen
parameter_list|(
name|rtx
name|out
parameter_list|,
name|rtx
name|src
parameter_list|,
name|rtx
name|eoschar
parameter_list|,
name|rtx
name|align
parameter_list|)
block|{
name|rtx
name|addr
decl_stmt|,
name|scratch1
decl_stmt|,
name|scratch2
decl_stmt|,
name|scratch3
decl_stmt|,
name|scratch4
decl_stmt|;
comment|/* The generic case of strlen expander is long.  Avoid it's      expanding unless TARGET_INLINE_ALL_STRINGOPS.  */
if|if
condition|(
name|TARGET_UNROLL_STRLEN
operator|&&
name|eoschar
operator|==
name|const0_rtx
operator|&&
name|optimize
operator|>
literal|1
operator|&&
operator|!
name|TARGET_INLINE_ALL_STRINGOPS
operator|&&
operator|!
name|optimize_size
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|align
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|INTVAL
argument_list|(
name|align
argument_list|)
operator|<
literal|4
operator|)
condition|)
return|return
literal|0
return|;
name|addr
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|scratch1
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_UNROLL_STRLEN
operator|&&
name|eoschar
operator|==
name|const0_rtx
operator|&&
name|optimize
operator|>
literal|1
operator|&&
operator|!
name|optimize_size
condition|)
block|{
comment|/* Well it seems that some optimizer does not combine a call like          foo(strlen(bar), strlen(bar));          when the move and the subtraction is done here.  It does calculate          the length just once when these instructions are done inside of          output_strlen_unroll().  But I think since&bar[strlen(bar)] is          often used and I use one fewer register for the lifetime of          output_strlen_unroll() this is better.  */
name|emit_move_insn
argument_list|(
name|out
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|ix86_expand_strlensi_unroll_1
argument_list|(
name|out
argument_list|,
name|src
argument_list|,
name|align
argument_list|)
expr_stmt|;
comment|/* strlensi_unroll_1 returns the address of the zero at the end of          the string, like memchr(), so compute the length by subtracting          the start address.  */
if|if
condition|(
name|TARGET_64BIT
condition|)
name|emit_insn
argument_list|(
name|gen_subdi3
argument_list|(
name|out
argument_list|,
name|out
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_subsi3
argument_list|(
name|out
argument_list|,
name|out
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|unspec
decl_stmt|;
name|scratch2
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|scratch3
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|scratch4
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|constm1_rtx
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|scratch3
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|eoschar
operator|=
name|force_reg
argument_list|(
name|QImode
argument_list|,
name|eoschar
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_cld
argument_list|()
argument_list|)
expr_stmt|;
name|src
operator|=
name|replace_equiv_address_nv
argument_list|(
name|src
argument_list|,
name|scratch3
argument_list|)
expr_stmt|;
comment|/* If .md starts supporting :P, this can be done in .md.  */
name|unspec
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|4
argument_list|,
name|src
argument_list|,
name|eoschar
argument_list|,
name|align
argument_list|,
name|scratch4
argument_list|)
argument_list|,
name|UNSPEC_SCAS
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_strlenqi_1
argument_list|(
name|scratch1
argument_list|,
name|scratch3
argument_list|,
name|unspec
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_one_cmpldi2
argument_list|(
name|scratch2
argument_list|,
name|scratch1
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|out
argument_list|,
name|scratch2
argument_list|,
name|constm1_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|emit_insn
argument_list|(
name|gen_one_cmplsi2
argument_list|(
name|scratch2
argument_list|,
name|scratch1
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|out
argument_list|,
name|scratch2
argument_list|,
name|constm1_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Expand the appropriate insns for doing strlen if not just doing    repnz; scasb     out = result, initialized with the start address    align_rtx = alignment of the address.    scratch = scratch register, initialized with the startaddress when 	not aligned, otherwise undefined     This is just the body. It needs the initializations mentioned above and    some address computing at the end.  These things are done in i386.md.  */
end_comment

begin_function
specifier|static
name|void
name|ix86_expand_strlensi_unroll_1
parameter_list|(
name|rtx
name|out
parameter_list|,
name|rtx
name|src
parameter_list|,
name|rtx
name|align_rtx
parameter_list|)
block|{
name|int
name|align
decl_stmt|;
name|rtx
name|tmp
decl_stmt|;
name|rtx
name|align_2_label
init|=
name|NULL_RTX
decl_stmt|;
name|rtx
name|align_3_label
init|=
name|NULL_RTX
decl_stmt|;
name|rtx
name|align_4_label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|rtx
name|end_0_label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|rtx
name|mem
decl_stmt|;
name|rtx
name|tmpreg
init|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
decl_stmt|;
name|rtx
name|scratch
init|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
decl_stmt|;
name|rtx
name|cmp
decl_stmt|;
name|align
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|align_rtx
argument_list|)
operator|==
name|CONST_INT
condition|)
name|align
operator|=
name|INTVAL
argument_list|(
name|align_rtx
argument_list|)
expr_stmt|;
comment|/* Loop to check 1..3 bytes for null to get an aligned pointer.  */
comment|/* Is there a known alignment and is it less than 4?  */
if|if
condition|(
name|align
operator|<
literal|4
condition|)
block|{
name|rtx
name|scratch1
init|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|scratch1
argument_list|,
name|out
argument_list|)
expr_stmt|;
comment|/* Is there a known alignment and is it not 2? */
if|if
condition|(
name|align
operator|!=
literal|2
condition|)
block|{
name|align_3_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
comment|/* Label when aligned to 3-byte */
name|align_2_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
comment|/* Label when aligned to 2-byte */
comment|/* Leave just the 3 lower bits.  */
name|align_rtx
operator|=
name|expand_binop
argument_list|(
name|Pmode
argument_list|,
name|and_optab
argument_list|,
name|scratch1
argument_list|,
name|GEN_INT
argument_list|(
literal|3
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|align_rtx
argument_list|,
name|const0_rtx
argument_list|,
name|EQ
argument_list|,
name|NULL
argument_list|,
name|Pmode
argument_list|,
literal|1
argument_list|,
name|align_4_label
argument_list|)
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|align_rtx
argument_list|,
name|const2_rtx
argument_list|,
name|EQ
argument_list|,
name|NULL
argument_list|,
name|Pmode
argument_list|,
literal|1
argument_list|,
name|align_2_label
argument_list|)
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|align_rtx
argument_list|,
name|const2_rtx
argument_list|,
name|GTU
argument_list|,
name|NULL
argument_list|,
name|Pmode
argument_list|,
literal|1
argument_list|,
name|align_3_label
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Since the alignment is 2, we have to check 2 or 0 bytes; 	     check if is aligned to 4 - byte.  */
name|align_rtx
operator|=
name|expand_binop
argument_list|(
name|Pmode
argument_list|,
name|and_optab
argument_list|,
name|scratch1
argument_list|,
name|const2_rtx
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|align_rtx
argument_list|,
name|const0_rtx
argument_list|,
name|EQ
argument_list|,
name|NULL
argument_list|,
name|Pmode
argument_list|,
literal|1
argument_list|,
name|align_4_label
argument_list|)
expr_stmt|;
block|}
name|mem
operator|=
name|change_address
argument_list|(
name|src
argument_list|,
name|QImode
argument_list|,
name|out
argument_list|)
expr_stmt|;
comment|/* Now compare the bytes.  */
comment|/* Compare the first n unaligned byte on a byte per byte basis.  */
name|emit_cmp_and_jump_insns
argument_list|(
name|mem
argument_list|,
name|const0_rtx
argument_list|,
name|EQ
argument_list|,
name|NULL
argument_list|,
name|QImode
argument_list|,
literal|1
argument_list|,
name|end_0_label
argument_list|)
expr_stmt|;
comment|/* Increment the address.  */
if|if
condition|(
name|TARGET_64BIT
condition|)
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|out
argument_list|,
name|out
argument_list|,
name|const1_rtx
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|out
argument_list|,
name|out
argument_list|,
name|const1_rtx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Not needed with an alignment of 2 */
if|if
condition|(
name|align
operator|!=
literal|2
condition|)
block|{
name|emit_label
argument_list|(
name|align_2_label
argument_list|)
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|mem
argument_list|,
name|const0_rtx
argument_list|,
name|EQ
argument_list|,
name|NULL
argument_list|,
name|QImode
argument_list|,
literal|1
argument_list|,
name|end_0_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|out
argument_list|,
name|out
argument_list|,
name|const1_rtx
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|out
argument_list|,
name|out
argument_list|,
name|const1_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|align_3_label
argument_list|)
expr_stmt|;
block|}
name|emit_cmp_and_jump_insns
argument_list|(
name|mem
argument_list|,
name|const0_rtx
argument_list|,
name|EQ
argument_list|,
name|NULL
argument_list|,
name|QImode
argument_list|,
literal|1
argument_list|,
name|end_0_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|out
argument_list|,
name|out
argument_list|,
name|const1_rtx
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|out
argument_list|,
name|out
argument_list|,
name|const1_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Generate loop to check 4 bytes at a time.  It is not a good idea to      align this loop.  It gives only huge programs, but does not help to      speed up.  */
name|emit_label
argument_list|(
name|align_4_label
argument_list|)
expr_stmt|;
name|mem
operator|=
name|change_address
argument_list|(
name|src
argument_list|,
name|SImode
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|scratch
argument_list|,
name|mem
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|out
argument_list|,
name|out
argument_list|,
name|GEN_INT
argument_list|(
literal|4
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|out
argument_list|,
name|out
argument_list|,
name|GEN_INT
argument_list|(
literal|4
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This formula yields a nonzero result iff one of the bytes is zero.      This saves three branches inside loop and many cycles.  */
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|tmpreg
argument_list|,
name|scratch
argument_list|,
name|GEN_INT
argument_list|(
operator|-
literal|0x01010101
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_one_cmplsi2
argument_list|(
name|scratch
argument_list|,
name|scratch
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_andsi3
argument_list|(
name|tmpreg
argument_list|,
name|tmpreg
argument_list|,
name|scratch
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_andsi3
argument_list|(
name|tmpreg
argument_list|,
name|tmpreg
argument_list|,
name|gen_int_mode
argument_list|(
literal|0x80808080
argument_list|,
name|SImode
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|tmpreg
argument_list|,
name|const0_rtx
argument_list|,
name|EQ
argument_list|,
literal|0
argument_list|,
name|SImode
argument_list|,
literal|1
argument_list|,
name|align_4_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_CMOVE
condition|)
block|{
name|rtx
name|reg
init|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
decl_stmt|;
name|rtx
name|reg2
init|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|tmpreg
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_lshrsi3
argument_list|(
name|reg
argument_list|,
name|reg
argument_list|,
name|GEN_INT
argument_list|(
literal|16
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If zero is not in the first two bytes, move two bytes forward.  */
name|emit_insn
argument_list|(
name|gen_testsi_ccno_1
argument_list|(
name|tmpreg
argument_list|,
name|GEN_INT
argument_list|(
literal|0x8080
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_REG
argument_list|(
name|CCNOmode
argument_list|,
name|FLAGS_REG
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_EQ
argument_list|(
name|VOIDmode
argument_list|,
name|tmp
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|tmpreg
argument_list|,
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|SImode
argument_list|,
name|tmp
argument_list|,
name|reg
argument_list|,
name|tmpreg
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Emit lea manually to avoid clobbering of flags.  */
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|SImode
argument_list|,
name|reg2
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|out
argument_list|,
name|const2_rtx
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_REG
argument_list|(
name|CCNOmode
argument_list|,
name|FLAGS_REG
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_EQ
argument_list|(
name|VOIDmode
argument_list|,
name|tmp
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|out
argument_list|,
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|Pmode
argument_list|,
name|tmp
argument_list|,
name|reg2
argument_list|,
name|out
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|end_2_label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
comment|/* Is zero in the first two bytes? */
name|emit_insn
argument_list|(
name|gen_testsi_ccno_1
argument_list|(
name|tmpreg
argument_list|,
name|GEN_INT
argument_list|(
literal|0x8080
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_REG
argument_list|(
name|CCNOmode
argument_list|,
name|FLAGS_REG
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_NE
argument_list|(
name|VOIDmode
argument_list|,
name|tmp
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|VOIDmode
argument_list|,
name|tmp
argument_list|,
name|gen_rtx_LABEL_REF
argument_list|(
name|VOIDmode
argument_list|,
name|end_2_label
argument_list|)
argument_list|,
name|pc_rtx
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|emit_jump_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|pc_rtx
argument_list|,
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|JUMP_LABEL
argument_list|(
name|tmp
argument_list|)
operator|=
name|end_2_label
expr_stmt|;
comment|/* Not in the first two.  Move two bytes forward.  */
name|emit_insn
argument_list|(
name|gen_lshrsi3
argument_list|(
name|tmpreg
argument_list|,
name|tmpreg
argument_list|,
name|GEN_INT
argument_list|(
literal|16
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|out
argument_list|,
name|out
argument_list|,
name|const2_rtx
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|out
argument_list|,
name|out
argument_list|,
name|const2_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|end_2_label
argument_list|)
expr_stmt|;
block|}
comment|/* Avoid branch in fixing the byte.  */
name|tmpreg
operator|=
name|gen_lowpart
argument_list|(
name|QImode
argument_list|,
name|tmpreg
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_addqi3_cc
argument_list|(
name|tmpreg
argument_list|,
name|tmpreg
argument_list|,
name|tmpreg
argument_list|)
argument_list|)
expr_stmt|;
name|cmp
operator|=
name|gen_rtx_LTU
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|CCmode
argument_list|,
literal|17
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
name|emit_insn
argument_list|(
name|gen_subdi3_carry_rex64
argument_list|(
name|out
argument_list|,
name|out
argument_list|,
name|GEN_INT
argument_list|(
literal|3
argument_list|)
argument_list|,
name|cmp
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_subsi3_carry
argument_list|(
name|out
argument_list|,
name|out
argument_list|,
name|GEN_INT
argument_list|(
literal|3
argument_list|)
argument_list|,
name|cmp
argument_list|)
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|end_0_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ix86_expand_call
parameter_list|(
name|rtx
name|retval
parameter_list|,
name|rtx
name|fnaddr
parameter_list|,
name|rtx
name|callarg1
parameter_list|,
name|rtx
name|callarg2
name|ATTRIBUTE_UNUSED
parameter_list|,
name|rtx
name|pop
parameter_list|,
name|int
name|sibcall
parameter_list|)
block|{
name|rtx
name|use
init|=
name|NULL
decl_stmt|,
name|call
decl_stmt|;
if|if
condition|(
name|pop
operator|==
name|const0_rtx
condition|)
name|pop
operator|=
name|NULL
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|TARGET_64BIT
operator|||
operator|!
name|pop
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_MACHO
operator|&&
operator|!
name|TARGET_64BIT
condition|)
block|{
if|#
directive|if
name|TARGET_MACHO
if|if
condition|(
name|flag_pic
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|fnaddr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
name|fnaddr
operator|=
name|machopic_indirect_call_target
argument_list|(
name|fnaddr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* Static functions and indirect calls don't need the pic register.  */
if|if
condition|(
operator|!
name|TARGET_64BIT
operator|&&
name|flag_pic
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|fnaddr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
operator|!
name|SYMBOL_REF_LOCAL_P
argument_list|(
name|XEXP
argument_list|(
name|fnaddr
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|use_reg
argument_list|(
operator|&
name|use
argument_list|,
name|pic_offset_table_rtx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_64BIT
operator|&&
name|INTVAL
argument_list|(
name|callarg2
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|rtx
name|al
init|=
name|gen_rtx_REG
argument_list|(
name|QImode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|al
argument_list|,
name|callarg2
argument_list|)
expr_stmt|;
name|use_reg
argument_list|(
operator|&
name|use
argument_list|,
name|al
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|call_insn_operand
argument_list|(
name|XEXP
argument_list|(
name|fnaddr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|)
condition|)
block|{
name|fnaddr
operator|=
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|fnaddr
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fnaddr
operator|=
name|gen_rtx_MEM
argument_list|(
name|QImode
argument_list|,
name|fnaddr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sibcall
operator|&&
name|TARGET_64BIT
operator|&&
operator|!
name|constant_call_address_operand
argument_list|(
name|XEXP
argument_list|(
name|fnaddr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|)
condition|)
block|{
name|rtx
name|addr
decl_stmt|;
name|addr
operator|=
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|fnaddr
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fnaddr
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|FIRST_REX_INT_REG
operator|+
literal|3
comment|/* R11 */
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|fnaddr
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|fnaddr
operator|=
name|gen_rtx_MEM
argument_list|(
name|QImode
argument_list|,
name|fnaddr
argument_list|)
expr_stmt|;
block|}
name|call
operator|=
name|gen_rtx_CALL
argument_list|(
name|VOIDmode
argument_list|,
name|fnaddr
argument_list|,
name|callarg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
condition|)
name|call
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|retval
argument_list|,
name|call
argument_list|)
expr_stmt|;
if|if
condition|(
name|pop
condition|)
block|{
name|pop
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|pop
argument_list|)
expr_stmt|;
name|pop
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|pop
argument_list|)
expr_stmt|;
name|call
operator|=
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|call
argument_list|,
name|pop
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|call
operator|=
name|emit_call_insn
argument_list|(
name|call
argument_list|)
expr_stmt|;
if|if
condition|(
name|use
condition|)
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|call
argument_list|)
operator|=
name|use
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Clear stack slot assignments remembered from previous functions.    This is called from INIT_EXPANDERS once before RTL is emitted for each    function.  */
end_comment

begin_function
specifier|static
name|struct
name|machine_function
modifier|*
name|ix86_init_machine_status
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|machine_function
modifier|*
name|f
decl_stmt|;
name|f
operator|=
name|ggc_alloc_cleared
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|machine_function
argument_list|)
argument_list|)
expr_stmt|;
name|f
operator|->
name|use_fast_prologue_epilogue_nregs
operator|=
operator|-
literal|1
expr_stmt|;
name|f
operator|->
name|tls_descriptor_call_expanded_p
operator|=
literal|0
expr_stmt|;
return|return
name|f
return|;
block|}
end_function

begin_comment
comment|/* Return a MEM corresponding to a stack slot with mode MODE.    Allocate a new slot if necessary.     The RTL for a function can have several slots available: N is    which slot to use.  */
end_comment

begin_function
name|rtx
name|assign_386_stack_local
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|enum
name|ix86_stack_slot
name|n
parameter_list|)
block|{
name|struct
name|stack_local_entry
modifier|*
name|s
decl_stmt|;
name|gcc_assert
argument_list|(
name|n
operator|<
name|MAX_386_STACK_LOCALS
argument_list|)
expr_stmt|;
comment|/* Virtual slot is valid only before vregs are instantiated.  */
name|gcc_assert
argument_list|(
operator|(
name|n
operator|==
name|SLOT_VIRTUAL
operator|)
operator|==
operator|!
name|virtuals_instantiated
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|ix86_stack_locals
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
if|if
condition|(
name|s
operator|->
name|mode
operator|==
name|mode
operator|&&
name|s
operator|->
name|n
operator|==
name|n
condition|)
return|return
name|s
operator|->
name|rtl
return|;
name|s
operator|=
operator|(
expr|struct
name|stack_local_entry
operator|*
operator|)
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|stack_local_entry
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|n
operator|=
name|n
expr_stmt|;
name|s
operator|->
name|mode
operator|=
name|mode
expr_stmt|;
name|s
operator|->
name|rtl
operator|=
name|assign_stack_local
argument_list|(
name|mode
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|s
operator|->
name|next
operator|=
name|ix86_stack_locals
expr_stmt|;
name|ix86_stack_locals
operator|=
name|s
expr_stmt|;
return|return
name|s
operator|->
name|rtl
return|;
block|}
end_function

begin_comment
comment|/* Construct the SYMBOL_REF for the tls_get_addr function.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|rtx
name|ix86_tls_symbol
expr_stmt|;
end_expr_stmt

begin_function
name|rtx
name|ix86_tls_get_addr
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ix86_tls_symbol
condition|)
block|{
name|ix86_tls_symbol
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
operator|(
name|TARGET_ANY_GNU_TLS
operator|&&
operator|!
name|TARGET_64BIT
operator|)
condition|?
literal|"___tls_get_addr"
else|:
literal|"__tls_get_addr"
argument_list|)
expr_stmt|;
block|}
return|return
name|ix86_tls_symbol
return|;
block|}
end_function

begin_comment
comment|/* Construct the SYMBOL_REF for the _TLS_MODULE_BASE_ symbol.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|rtx
name|ix86_tls_module_base_symbol
expr_stmt|;
end_expr_stmt

begin_function
name|rtx
name|ix86_tls_module_base
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ix86_tls_module_base_symbol
condition|)
block|{
name|ix86_tls_module_base_symbol
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
literal|"_TLS_MODULE_BASE_"
argument_list|)
expr_stmt|;
name|SYMBOL_REF_FLAGS
argument_list|(
name|ix86_tls_module_base_symbol
argument_list|)
operator||=
name|TLS_MODEL_GLOBAL_DYNAMIC
operator|<<
name|SYMBOL_FLAG_TLS_SHIFT
expr_stmt|;
block|}
return|return
name|ix86_tls_module_base_symbol
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Calculate the length of the memory address in the instruction    encoding.  Does not include the one-byte modrm, opcode, or prefix.  */
end_comment

begin_function
name|int
name|memory_address_length
parameter_list|(
name|rtx
name|addr
parameter_list|)
block|{
name|struct
name|ix86_address
name|parts
decl_stmt|;
name|rtx
name|base
decl_stmt|,
name|index
decl_stmt|,
name|disp
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|ok
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PRE_DEC
operator|||
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|POST_INC
operator|||
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PRE_MODIFY
operator|||
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|POST_MODIFY
condition|)
return|return
literal|0
return|;
name|ok
operator|=
name|ix86_decompose_address
argument_list|(
name|addr
argument_list|,
operator|&
name|parts
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|ok
argument_list|)
expr_stmt|;
if|if
condition|(
name|parts
operator|.
name|base
operator|&&
name|GET_CODE
argument_list|(
name|parts
operator|.
name|base
argument_list|)
operator|==
name|SUBREG
condition|)
name|parts
operator|.
name|base
operator|=
name|SUBREG_REG
argument_list|(
name|parts
operator|.
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|parts
operator|.
name|index
operator|&&
name|GET_CODE
argument_list|(
name|parts
operator|.
name|index
argument_list|)
operator|==
name|SUBREG
condition|)
name|parts
operator|.
name|index
operator|=
name|SUBREG_REG
argument_list|(
name|parts
operator|.
name|index
argument_list|)
expr_stmt|;
name|base
operator|=
name|parts
operator|.
name|base
expr_stmt|;
name|index
operator|=
name|parts
operator|.
name|index
expr_stmt|;
name|disp
operator|=
name|parts
operator|.
name|disp
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
comment|/* Rule of thumb:        - esp as the base always wants an index,        - ebp as the base always wants a displacement.  */
comment|/* Register Indirect.  */
if|if
condition|(
name|base
operator|&&
operator|!
name|index
operator|&&
operator|!
name|disp
condition|)
block|{
comment|/* esp (for its index) and ebp (for its displacement) need 	 the two-byte modrm form.  */
if|if
condition|(
name|addr
operator|==
name|stack_pointer_rtx
operator|||
name|addr
operator|==
name|arg_pointer_rtx
operator|||
name|addr
operator|==
name|frame_pointer_rtx
operator|||
name|addr
operator|==
name|hard_frame_pointer_rtx
condition|)
name|len
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Direct Addressing.  */
elseif|else
if|if
condition|(
name|disp
operator|&&
operator|!
name|base
operator|&&
operator|!
name|index
condition|)
name|len
operator|=
literal|4
expr_stmt|;
else|else
block|{
comment|/* Find the length of the displacement constant.  */
if|if
condition|(
name|disp
condition|)
block|{
if|if
condition|(
name|base
operator|&&
name|satisfies_constraint_K
argument_list|(
name|disp
argument_list|)
condition|)
name|len
operator|=
literal|1
expr_stmt|;
else|else
name|len
operator|=
literal|4
expr_stmt|;
block|}
comment|/* ebp always wants a displacement.  */
elseif|else
if|if
condition|(
name|base
operator|==
name|hard_frame_pointer_rtx
condition|)
name|len
operator|=
literal|1
expr_stmt|;
comment|/* An index requires the two-byte modrm form....  */
if|if
condition|(
name|index
comment|/* ...like esp, which always wants an index.  */
operator|||
name|base
operator|==
name|stack_pointer_rtx
operator|||
name|base
operator|==
name|arg_pointer_rtx
operator|||
name|base
operator|==
name|frame_pointer_rtx
condition|)
name|len
operator|+=
literal|1
expr_stmt|;
block|}
return|return
name|len
return|;
block|}
end_function

begin_comment
comment|/* Compute default value for "length_immediate" attribute.  When SHORTFORM    is set, expect that insn have 8bit immediate alternative.  */
end_comment

begin_function
name|int
name|ix86_attr_length_immediate_default
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|int
name|shortform
parameter_list|)
block|{
name|int
name|len
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|extract_insn_cached
argument_list|(
name|insn
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|recog_data
operator|.
name|n_operands
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|gcc_assert
argument_list|(
operator|!
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|shortform
operator|&&
name|satisfies_constraint_K
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
condition|)
name|len
operator|=
literal|1
expr_stmt|;
else|else
block|{
switch|switch
condition|(
name|get_attr_mode
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|MODE_QI
case|:
name|len
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|MODE_HI
case|:
name|len
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|MODE_SI
case|:
name|len
operator|+=
literal|4
expr_stmt|;
break|break;
comment|/* Immediates for DImode instructions are encoded as 32bit sign extended values.  */
case|case
name|MODE_DI
case|:
name|len
operator|+=
literal|4
expr_stmt|;
break|break;
default|default:
name|fatal_insn
argument_list|(
literal|"unknown insn mode"
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|len
return|;
block|}
end_function

begin_comment
comment|/* Compute default value for "length_address" attribute.  */
end_comment

begin_function
name|int
name|ix86_attr_length_address_default
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|get_attr_type
argument_list|(
name|insn
argument_list|)
operator|==
name|TYPE_LEA
condition|)
block|{
name|rtx
name|set
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|set
argument_list|)
operator|==
name|PARALLEL
condition|)
name|set
operator|=
name|XVECEXP
argument_list|(
name|set
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|set
argument_list|)
operator|==
name|SET
argument_list|)
expr_stmt|;
return|return
name|memory_address_length
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
return|;
block|}
name|extract_insn_cached
argument_list|(
name|insn
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|recog_data
operator|.
name|n_operands
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
operator|==
name|MEM
condition|)
block|{
return|return
name|memory_address_length
argument_list|(
name|XEXP
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the maximum number of instructions a cpu can issue.  */
end_comment

begin_function
specifier|static
name|int
name|ix86_issue_rate
parameter_list|(
name|void
parameter_list|)
block|{
switch|switch
condition|(
name|ix86_tune
condition|)
block|{
case|case
name|PROCESSOR_PENTIUM
case|:
case|case
name|PROCESSOR_K6
case|:
return|return
literal|2
return|;
case|case
name|PROCESSOR_PENTIUMPRO
case|:
case|case
name|PROCESSOR_PENTIUM4
case|:
case|case
name|PROCESSOR_ATHLON
case|:
case|case
name|PROCESSOR_K8
case|:
case|case
name|PROCESSOR_NOCONA
case|:
case|case
name|PROCESSOR_GENERIC32
case|:
case|case
name|PROCESSOR_GENERIC64
case|:
return|return
literal|3
return|;
default|default:
return|return
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/* A subroutine of ix86_adjust_cost -- return true iff INSN reads flags set    by DEP_INSN and nothing set by DEP_INSN.  */
end_comment

begin_function
specifier|static
name|int
name|ix86_flags_dependent
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|dep_insn
parameter_list|,
name|enum
name|attr_type
name|insn_type
parameter_list|)
block|{
name|rtx
name|set
decl_stmt|,
name|set2
decl_stmt|;
comment|/* Simplify the test for uninteresting insns.  */
if|if
condition|(
name|insn_type
operator|!=
name|TYPE_SETCC
operator|&&
name|insn_type
operator|!=
name|TYPE_ICMOV
operator|&&
name|insn_type
operator|!=
name|TYPE_FCMOV
operator|&&
name|insn_type
operator|!=
name|TYPE_IBR
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|dep_insn
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|set
operator|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|set2
operator|=
name|NULL_RTX
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|dep_insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|dep_insn
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
literal|2
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|dep_insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|dep_insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
block|{
name|set
operator|=
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|dep_insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|set2
operator|=
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|dep_insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|set
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|set
argument_list|)
operator|!=
name|FLAGS_REG
condition|)
return|return
literal|0
return|;
comment|/* This test is true if the dependent insn reads the flags but      not any other potentially set register.  */
if|if
condition|(
operator|!
name|reg_overlap_mentioned_p
argument_list|(
name|set
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|set2
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|set2
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of ix86_adjust_cost -- return true iff INSN has a memory    address with operands set by DEP_INSN.  */
end_comment

begin_function
specifier|static
name|int
name|ix86_agi_dependent
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|dep_insn
parameter_list|,
name|enum
name|attr_type
name|insn_type
parameter_list|)
block|{
name|rtx
name|addr
decl_stmt|;
if|if
condition|(
name|insn_type
operator|==
name|TYPE_LEA
operator|&&
name|TARGET_PENTIUM
condition|)
block|{
name|addr
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PARALLEL
condition|)
name|addr
operator|=
name|XVECEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|SET
argument_list|)
expr_stmt|;
name|addr
operator|=
name|SET_SRC
argument_list|(
name|addr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
name|extract_insn_cached
argument_list|(
name|insn
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|recog_data
operator|.
name|n_operands
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|addr
operator|=
name|XEXP
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|found
goto|;
block|}
return|return
literal|0
return|;
name|found
label|:
empty_stmt|;
block|}
return|return
name|modified_in_p
argument_list|(
name|addr
argument_list|,
name|dep_insn
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ix86_adjust_cost
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|link
parameter_list|,
name|rtx
name|dep_insn
parameter_list|,
name|int
name|cost
parameter_list|)
block|{
name|enum
name|attr_type
name|insn_type
decl_stmt|,
name|dep_insn_type
decl_stmt|;
name|enum
name|attr_memory
name|memory
decl_stmt|;
name|rtx
name|set
decl_stmt|,
name|set2
decl_stmt|;
name|int
name|dep_insn_code_number
decl_stmt|;
comment|/* Anti and output dependencies have zero cost on all CPUs.  */
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
name|dep_insn_code_number
operator|=
name|recog_memoized
argument_list|(
name|dep_insn
argument_list|)
expr_stmt|;
comment|/* If we can't recognize the insns, we can't really do anything.  */
if|if
condition|(
name|dep_insn_code_number
operator|<
literal|0
operator|||
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|<
literal|0
condition|)
return|return
name|cost
return|;
name|insn_type
operator|=
name|get_attr_type
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|dep_insn_type
operator|=
name|get_attr_type
argument_list|(
name|dep_insn
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ix86_tune
condition|)
block|{
case|case
name|PROCESSOR_PENTIUM
case|:
comment|/* Address Generation Interlock adds a cycle of latency.  */
if|if
condition|(
name|ix86_agi_dependent
argument_list|(
name|insn
argument_list|,
name|dep_insn
argument_list|,
name|insn_type
argument_list|)
condition|)
name|cost
operator|+=
literal|1
expr_stmt|;
comment|/* ??? Compares pair with jump/setcc.  */
if|if
condition|(
name|ix86_flags_dependent
argument_list|(
name|insn
argument_list|,
name|dep_insn
argument_list|,
name|insn_type
argument_list|)
condition|)
name|cost
operator|=
literal|0
expr_stmt|;
comment|/* Floating point stores require value to be ready one cycle earlier.  */
if|if
condition|(
name|insn_type
operator|==
name|TYPE_FMOV
operator|&&
name|get_attr_memory
argument_list|(
name|insn
argument_list|)
operator|==
name|MEMORY_STORE
operator|&&
operator|!
name|ix86_agi_dependent
argument_list|(
name|insn
argument_list|,
name|dep_insn
argument_list|,
name|insn_type
argument_list|)
condition|)
name|cost
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|PROCESSOR_PENTIUMPRO
case|:
name|memory
operator|=
name|get_attr_memory
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* INT->FP conversion is expensive.  */
if|if
condition|(
name|get_attr_fp_int_src
argument_list|(
name|dep_insn
argument_list|)
condition|)
name|cost
operator|+=
literal|5
expr_stmt|;
comment|/* There is one cycle extra latency between an FP op and a store.  */
if|if
condition|(
name|insn_type
operator|==
name|TYPE_FMOV
operator|&&
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|dep_insn
argument_list|)
operator|)
operator|!=
name|NULL_RTX
operator|&&
operator|(
name|set2
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
name|NULL_RTX
operator|&&
name|rtx_equal_p
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|set2
argument_list|)
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set2
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
name|cost
operator|+=
literal|1
expr_stmt|;
comment|/* Show ability of reorder buffer to hide latency of load by executing 	 in parallel with previous instruction in case 	 previous instruction is not needed to compute the address.  */
if|if
condition|(
operator|(
name|memory
operator|==
name|MEMORY_LOAD
operator|||
name|memory
operator|==
name|MEMORY_BOTH
operator|)
operator|&&
operator|!
name|ix86_agi_dependent
argument_list|(
name|insn
argument_list|,
name|dep_insn
argument_list|,
name|insn_type
argument_list|)
condition|)
block|{
comment|/* Claim moves to take one cycle, as core can issue one load 	     at time and the next load can start cycle later.  */
if|if
condition|(
name|dep_insn_type
operator|==
name|TYPE_IMOV
operator|||
name|dep_insn_type
operator|==
name|TYPE_FMOV
condition|)
name|cost
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|cost
operator|>
literal|1
condition|)
name|cost
operator|--
expr_stmt|;
block|}
break|break;
case|case
name|PROCESSOR_K6
case|:
name|memory
operator|=
name|get_attr_memory
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* The esp dependency is resolved before the instruction is really          finished.  */
if|if
condition|(
operator|(
name|insn_type
operator|==
name|TYPE_PUSH
operator|||
name|insn_type
operator|==
name|TYPE_POP
operator|)
operator|&&
operator|(
name|dep_insn_type
operator|==
name|TYPE_PUSH
operator|||
name|dep_insn_type
operator|==
name|TYPE_POP
operator|)
condition|)
return|return
literal|1
return|;
comment|/* INT->FP conversion is expensive.  */
if|if
condition|(
name|get_attr_fp_int_src
argument_list|(
name|dep_insn
argument_list|)
condition|)
name|cost
operator|+=
literal|5
expr_stmt|;
comment|/* Show ability of reorder buffer to hide latency of load by executing 	 in parallel with previous instruction in case 	 previous instruction is not needed to compute the address.  */
if|if
condition|(
operator|(
name|memory
operator|==
name|MEMORY_LOAD
operator|||
name|memory
operator|==
name|MEMORY_BOTH
operator|)
operator|&&
operator|!
name|ix86_agi_dependent
argument_list|(
name|insn
argument_list|,
name|dep_insn
argument_list|,
name|insn_type
argument_list|)
condition|)
block|{
comment|/* Claim moves to take one cycle, as core can issue one load 	     at time and the next load can start cycle later.  */
if|if
condition|(
name|dep_insn_type
operator|==
name|TYPE_IMOV
operator|||
name|dep_insn_type
operator|==
name|TYPE_FMOV
condition|)
name|cost
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|cost
operator|>
literal|2
condition|)
name|cost
operator|-=
literal|2
expr_stmt|;
else|else
name|cost
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|PROCESSOR_ATHLON
case|:
case|case
name|PROCESSOR_K8
case|:
case|case
name|PROCESSOR_GENERIC32
case|:
case|case
name|PROCESSOR_GENERIC64
case|:
name|memory
operator|=
name|get_attr_memory
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Show ability of reorder buffer to hide latency of load by executing 	 in parallel with previous instruction in case 	 previous instruction is not needed to compute the address.  */
if|if
condition|(
operator|(
name|memory
operator|==
name|MEMORY_LOAD
operator|||
name|memory
operator|==
name|MEMORY_BOTH
operator|)
operator|&&
operator|!
name|ix86_agi_dependent
argument_list|(
name|insn
argument_list|,
name|dep_insn
argument_list|,
name|insn_type
argument_list|)
condition|)
block|{
name|enum
name|attr_unit
name|unit
init|=
name|get_attr_unit
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|int
name|loadcost
init|=
literal|3
decl_stmt|;
comment|/* Because of the difference between the length of integer and 	     floating unit pipeline preparation stages, the memory operands 	     for floating point are cheaper.  	     ??? For Athlon it the difference is most probably 2.  */
if|if
condition|(
name|unit
operator|==
name|UNIT_INTEGER
operator|||
name|unit
operator|==
name|UNIT_UNKNOWN
condition|)
name|loadcost
operator|=
literal|3
expr_stmt|;
else|else
name|loadcost
operator|=
name|TARGET_ATHLON
condition|?
literal|2
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|cost
operator|>=
name|loadcost
condition|)
name|cost
operator|-=
name|loadcost
expr_stmt|;
else|else
name|cost
operator|=
literal|0
expr_stmt|;
block|}
default|default:
break|break;
block|}
return|return
name|cost
return|;
block|}
end_function

begin_comment
comment|/* How many alternative schedules to try.  This should be as wide as the    scheduling freedom in the DFA, but no wider.  Making this value too    large results extra work for the scheduler.  */
end_comment

begin_function
specifier|static
name|int
name|ia32_multipass_dfa_lookahead
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|ix86_tune
operator|==
name|PROCESSOR_PENTIUM
condition|)
return|return
literal|2
return|;
if|if
condition|(
name|ix86_tune
operator|==
name|PROCESSOR_PENTIUMPRO
operator|||
name|ix86_tune
operator|==
name|PROCESSOR_K6
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compute the alignment given to a constant that is being placed in memory.    EXP is the constant and ALIGN is the alignment that the object would    ordinarily have.    The value of this function is used instead of that alignment to align    the object.  */
end_comment

begin_function
name|int
name|ix86_constant_alignment
parameter_list|(
name|tree
name|exp
parameter_list|,
name|int
name|align
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|REAL_CST
condition|)
block|{
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|DFmode
operator|&&
name|align
operator|<
literal|64
condition|)
return|return
literal|64
return|;
elseif|else
if|if
condition|(
name|ALIGN_MODE_128
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|align
operator|<
literal|128
condition|)
return|return
literal|128
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|optimize_size
operator|&&
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|STRING_CST
operator|&&
operator|!
name|TARGET_NO_ALIGN_LONG_STRINGS
operator|&&
name|TREE_STRING_LENGTH
argument_list|(
name|exp
argument_list|)
operator|>=
literal|31
operator|&&
name|align
operator|<
name|BITS_PER_WORD
condition|)
return|return
name|BITS_PER_WORD
return|;
return|return
name|align
return|;
block|}
end_function

begin_comment
comment|/* Compute the alignment for a static variable.    TYPE is the data type, and ALIGN is the alignment that    the object would ordinarily have.  The value of this function is used    instead of that alignment to align the object.  */
end_comment

begin_function
name|int
name|ix86_data_alignment
parameter_list|(
name|tree
name|type
parameter_list|,
name|int
name|align
parameter_list|)
block|{
name|int
name|max_align
init|=
name|optimize_size
condition|?
name|BITS_PER_WORD
else|:
literal|256
decl_stmt|;
if|if
condition|(
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|>=
operator|(
name|unsigned
operator|)
name|max_align
operator|||
name|TREE_INT_CST_HIGH
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
operator|&&
name|align
operator|<
name|max_align
condition|)
name|align
operator|=
name|max_align
expr_stmt|;
comment|/* x86-64 ABI requires arrays greater than 16 bytes to be aligned      to 16byte boundary.  */
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
if|if
condition|(
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|>=
literal|128
operator|||
name|TREE_INT_CST_HIGH
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
operator|&&
name|align
operator|<
literal|128
condition|)
return|return
literal|128
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|DFmode
operator|&&
name|align
operator|<
literal|64
condition|)
return|return
literal|64
return|;
if|if
condition|(
name|ALIGN_MODE_128
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|align
operator|<
literal|128
condition|)
return|return
literal|128
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|COMPLEX_TYPE
condition|)
block|{
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|DCmode
operator|&&
name|align
operator|<
literal|64
condition|)
return|return
literal|64
return|;
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|XCmode
operator|&&
name|align
operator|<
literal|128
condition|)
return|return
literal|128
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|QUAL_UNION_TYPE
operator|)
operator|&&
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_MODE
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|DFmode
operator|&&
name|align
operator|<
literal|64
condition|)
return|return
literal|64
return|;
if|if
condition|(
name|ALIGN_MODE_128
argument_list|(
name|DECL_MODE
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|align
operator|<
literal|128
condition|)
return|return
literal|128
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REAL_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VECTOR_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
condition|)
block|{
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|DFmode
operator|&&
name|align
operator|<
literal|64
condition|)
return|return
literal|64
return|;
if|if
condition|(
name|ALIGN_MODE_128
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
name|align
operator|<
literal|128
condition|)
return|return
literal|128
return|;
block|}
return|return
name|align
return|;
block|}
end_function

begin_comment
comment|/* Compute the alignment for a local variable.    TYPE is the data type, and ALIGN is the alignment that    the object would ordinarily have.  The value of this macro is used    instead of that alignment to align the object.  */
end_comment

begin_function
name|int
name|ix86_local_alignment
parameter_list|(
name|tree
name|type
parameter_list|,
name|int
name|align
parameter_list|)
block|{
comment|/* x86-64 ABI requires arrays greater than 16 bytes to be aligned      to 16byte boundary.  */
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
if|if
condition|(
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|>=
literal|16
operator|||
name|TREE_INT_CST_HIGH
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
operator|&&
name|align
operator|<
literal|128
condition|)
return|return
literal|128
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|DFmode
operator|&&
name|align
operator|<
literal|64
condition|)
return|return
literal|64
return|;
if|if
condition|(
name|ALIGN_MODE_128
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|align
operator|<
literal|128
condition|)
return|return
literal|128
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|COMPLEX_TYPE
condition|)
block|{
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|DCmode
operator|&&
name|align
operator|<
literal|64
condition|)
return|return
literal|64
return|;
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|XCmode
operator|&&
name|align
operator|<
literal|128
condition|)
return|return
literal|128
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|QUAL_UNION_TYPE
operator|)
operator|&&
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_MODE
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|DFmode
operator|&&
name|align
operator|<
literal|64
condition|)
return|return
literal|64
return|;
if|if
condition|(
name|ALIGN_MODE_128
argument_list|(
name|DECL_MODE
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|align
operator|<
literal|128
condition|)
return|return
literal|128
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REAL_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VECTOR_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
condition|)
block|{
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|DFmode
operator|&&
name|align
operator|<
literal|64
condition|)
return|return
literal|64
return|;
if|if
condition|(
name|ALIGN_MODE_128
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
name|align
operator|<
literal|128
condition|)
return|return
literal|128
return|;
block|}
return|return
name|align
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit RTL insns to initialize the variable parts of a trampoline.    FNADDR is an RTX for the address of the function's pure code.    CXT is an RTX for the static chain value for the function.  */
end_comment

begin_function
name|void
name|x86_initialize_trampoline
parameter_list|(
name|rtx
name|tramp
parameter_list|,
name|rtx
name|fnaddr
parameter_list|,
name|rtx
name|cxt
parameter_list|)
block|{
if|if
condition|(
operator|!
name|TARGET_64BIT
condition|)
block|{
comment|/* Compute offset from the end of the jmp to the target function.  */
name|rtx
name|disp
init|=
name|expand_binop
argument_list|(
name|SImode
argument_list|,
name|sub_optab
argument_list|,
name|fnaddr
argument_list|,
name|plus_constant
argument_list|(
name|tramp
argument_list|,
literal|10
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_DIRECT
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|QImode
argument_list|,
name|tramp
argument_list|)
argument_list|,
name|gen_int_mode
argument_list|(
literal|0xb9
argument_list|,
name|QImode
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|tramp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|cxt
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|QImode
argument_list|,
name|plus_constant
argument_list|(
name|tramp
argument_list|,
literal|5
argument_list|)
argument_list|)
argument_list|,
name|gen_int_mode
argument_list|(
literal|0xe9
argument_list|,
name|QImode
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|tramp
argument_list|,
literal|6
argument_list|)
argument_list|)
argument_list|,
name|disp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|offset
init|=
literal|0
decl_stmt|;
comment|/* Try to load address using shorter movl instead of movabs.          We may want to support movq for kernel mode, but kernel does not use          trampolines at the moment.  */
if|if
condition|(
name|x86_64_zext_immediate_operand
argument_list|(
name|fnaddr
argument_list|,
name|VOIDmode
argument_list|)
condition|)
block|{
name|fnaddr
operator|=
name|copy_to_mode_reg
argument_list|(
name|DImode
argument_list|,
name|fnaddr
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|HImode
argument_list|,
name|plus_constant
argument_list|(
name|tramp
argument_list|,
name|offset
argument_list|)
argument_list|)
argument_list|,
name|gen_int_mode
argument_list|(
literal|0xbb41
argument_list|,
name|HImode
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|tramp
argument_list|,
name|offset
operator|+
literal|2
argument_list|)
argument_list|)
argument_list|,
name|gen_lowpart
argument_list|(
name|SImode
argument_list|,
name|fnaddr
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|6
expr_stmt|;
block|}
else|else
block|{
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|HImode
argument_list|,
name|plus_constant
argument_list|(
name|tramp
argument_list|,
name|offset
argument_list|)
argument_list|)
argument_list|,
name|gen_int_mode
argument_list|(
literal|0xbb49
argument_list|,
name|HImode
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|DImode
argument_list|,
name|plus_constant
argument_list|(
name|tramp
argument_list|,
name|offset
operator|+
literal|2
argument_list|)
argument_list|)
argument_list|,
name|fnaddr
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|10
expr_stmt|;
block|}
comment|/* Load static chain using movabs to r10.  */
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|HImode
argument_list|,
name|plus_constant
argument_list|(
name|tramp
argument_list|,
name|offset
argument_list|)
argument_list|)
argument_list|,
name|gen_int_mode
argument_list|(
literal|0xba49
argument_list|,
name|HImode
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|DImode
argument_list|,
name|plus_constant
argument_list|(
name|tramp
argument_list|,
name|offset
operator|+
literal|2
argument_list|)
argument_list|)
argument_list|,
name|cxt
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|10
expr_stmt|;
comment|/* Jump to the r11 */
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|HImode
argument_list|,
name|plus_constant
argument_list|(
name|tramp
argument_list|,
name|offset
argument_list|)
argument_list|)
argument_list|,
name|gen_int_mode
argument_list|(
literal|0xff49
argument_list|,
name|HImode
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|QImode
argument_list|,
name|plus_constant
argument_list|(
name|tramp
argument_list|,
name|offset
operator|+
literal|2
argument_list|)
argument_list|)
argument_list|,
name|gen_int_mode
argument_list|(
literal|0xe3
argument_list|,
name|QImode
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|3
expr_stmt|;
name|gcc_assert
argument_list|(
name|offset
operator|<=
name|TRAMPOLINE_SIZE
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ENABLE_EXECUTE_STACK
name|emit_library_call
argument_list|(
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
literal|"__enable_execute_stack"
argument_list|)
argument_list|,
name|LCT_NORMAL
argument_list|,
name|VOIDmode
argument_list|,
literal|1
argument_list|,
name|tramp
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Codes for all the SSE/MMX builtins.  */
end_comment

begin_enum
enum|enum
name|ix86_builtins
block|{
name|IX86_BUILTIN_ADDPS
block|,
name|IX86_BUILTIN_ADDSS
block|,
name|IX86_BUILTIN_DIVPS
block|,
name|IX86_BUILTIN_DIVSS
block|,
name|IX86_BUILTIN_MULPS
block|,
name|IX86_BUILTIN_MULSS
block|,
name|IX86_BUILTIN_SUBPS
block|,
name|IX86_BUILTIN_SUBSS
block|,
name|IX86_BUILTIN_CMPEQPS
block|,
name|IX86_BUILTIN_CMPLTPS
block|,
name|IX86_BUILTIN_CMPLEPS
block|,
name|IX86_BUILTIN_CMPGTPS
block|,
name|IX86_BUILTIN_CMPGEPS
block|,
name|IX86_BUILTIN_CMPNEQPS
block|,
name|IX86_BUILTIN_CMPNLTPS
block|,
name|IX86_BUILTIN_CMPNLEPS
block|,
name|IX86_BUILTIN_CMPNGTPS
block|,
name|IX86_BUILTIN_CMPNGEPS
block|,
name|IX86_BUILTIN_CMPORDPS
block|,
name|IX86_BUILTIN_CMPUNORDPS
block|,
name|IX86_BUILTIN_CMPEQSS
block|,
name|IX86_BUILTIN_CMPLTSS
block|,
name|IX86_BUILTIN_CMPLESS
block|,
name|IX86_BUILTIN_CMPNEQSS
block|,
name|IX86_BUILTIN_CMPNLTSS
block|,
name|IX86_BUILTIN_CMPNLESS
block|,
name|IX86_BUILTIN_CMPNGTSS
block|,
name|IX86_BUILTIN_CMPNGESS
block|,
name|IX86_BUILTIN_CMPORDSS
block|,
name|IX86_BUILTIN_CMPUNORDSS
block|,
name|IX86_BUILTIN_COMIEQSS
block|,
name|IX86_BUILTIN_COMILTSS
block|,
name|IX86_BUILTIN_COMILESS
block|,
name|IX86_BUILTIN_COMIGTSS
block|,
name|IX86_BUILTIN_COMIGESS
block|,
name|IX86_BUILTIN_COMINEQSS
block|,
name|IX86_BUILTIN_UCOMIEQSS
block|,
name|IX86_BUILTIN_UCOMILTSS
block|,
name|IX86_BUILTIN_UCOMILESS
block|,
name|IX86_BUILTIN_UCOMIGTSS
block|,
name|IX86_BUILTIN_UCOMIGESS
block|,
name|IX86_BUILTIN_UCOMINEQSS
block|,
name|IX86_BUILTIN_CVTPI2PS
block|,
name|IX86_BUILTIN_CVTPS2PI
block|,
name|IX86_BUILTIN_CVTSI2SS
block|,
name|IX86_BUILTIN_CVTSI642SS
block|,
name|IX86_BUILTIN_CVTSS2SI
block|,
name|IX86_BUILTIN_CVTSS2SI64
block|,
name|IX86_BUILTIN_CVTTPS2PI
block|,
name|IX86_BUILTIN_CVTTSS2SI
block|,
name|IX86_BUILTIN_CVTTSS2SI64
block|,
name|IX86_BUILTIN_MAXPS
block|,
name|IX86_BUILTIN_MAXSS
block|,
name|IX86_BUILTIN_MINPS
block|,
name|IX86_BUILTIN_MINSS
block|,
name|IX86_BUILTIN_LOADUPS
block|,
name|IX86_BUILTIN_STOREUPS
block|,
name|IX86_BUILTIN_MOVSS
block|,
name|IX86_BUILTIN_MOVHLPS
block|,
name|IX86_BUILTIN_MOVLHPS
block|,
name|IX86_BUILTIN_LOADHPS
block|,
name|IX86_BUILTIN_LOADLPS
block|,
name|IX86_BUILTIN_STOREHPS
block|,
name|IX86_BUILTIN_STORELPS
block|,
name|IX86_BUILTIN_MASKMOVQ
block|,
name|IX86_BUILTIN_MOVMSKPS
block|,
name|IX86_BUILTIN_PMOVMSKB
block|,
name|IX86_BUILTIN_MOVNTPS
block|,
name|IX86_BUILTIN_MOVNTQ
block|,
name|IX86_BUILTIN_LOADDQU
block|,
name|IX86_BUILTIN_STOREDQU
block|,
name|IX86_BUILTIN_PACKSSWB
block|,
name|IX86_BUILTIN_PACKSSDW
block|,
name|IX86_BUILTIN_PACKUSWB
block|,
name|IX86_BUILTIN_PADDB
block|,
name|IX86_BUILTIN_PADDW
block|,
name|IX86_BUILTIN_PADDD
block|,
name|IX86_BUILTIN_PADDQ
block|,
name|IX86_BUILTIN_PADDSB
block|,
name|IX86_BUILTIN_PADDSW
block|,
name|IX86_BUILTIN_PADDUSB
block|,
name|IX86_BUILTIN_PADDUSW
block|,
name|IX86_BUILTIN_PSUBB
block|,
name|IX86_BUILTIN_PSUBW
block|,
name|IX86_BUILTIN_PSUBD
block|,
name|IX86_BUILTIN_PSUBQ
block|,
name|IX86_BUILTIN_PSUBSB
block|,
name|IX86_BUILTIN_PSUBSW
block|,
name|IX86_BUILTIN_PSUBUSB
block|,
name|IX86_BUILTIN_PSUBUSW
block|,
name|IX86_BUILTIN_PAND
block|,
name|IX86_BUILTIN_PANDN
block|,
name|IX86_BUILTIN_POR
block|,
name|IX86_BUILTIN_PXOR
block|,
name|IX86_BUILTIN_PAVGB
block|,
name|IX86_BUILTIN_PAVGW
block|,
name|IX86_BUILTIN_PCMPEQB
block|,
name|IX86_BUILTIN_PCMPEQW
block|,
name|IX86_BUILTIN_PCMPEQD
block|,
name|IX86_BUILTIN_PCMPGTB
block|,
name|IX86_BUILTIN_PCMPGTW
block|,
name|IX86_BUILTIN_PCMPGTD
block|,
name|IX86_BUILTIN_PMADDWD
block|,
name|IX86_BUILTIN_PMAXSW
block|,
name|IX86_BUILTIN_PMAXUB
block|,
name|IX86_BUILTIN_PMINSW
block|,
name|IX86_BUILTIN_PMINUB
block|,
name|IX86_BUILTIN_PMULHUW
block|,
name|IX86_BUILTIN_PMULHW
block|,
name|IX86_BUILTIN_PMULLW
block|,
name|IX86_BUILTIN_PSADBW
block|,
name|IX86_BUILTIN_PSHUFW
block|,
name|IX86_BUILTIN_PSLLW
block|,
name|IX86_BUILTIN_PSLLD
block|,
name|IX86_BUILTIN_PSLLQ
block|,
name|IX86_BUILTIN_PSRAW
block|,
name|IX86_BUILTIN_PSRAD
block|,
name|IX86_BUILTIN_PSRLW
block|,
name|IX86_BUILTIN_PSRLD
block|,
name|IX86_BUILTIN_PSRLQ
block|,
name|IX86_BUILTIN_PSLLWI
block|,
name|IX86_BUILTIN_PSLLDI
block|,
name|IX86_BUILTIN_PSLLQI
block|,
name|IX86_BUILTIN_PSRAWI
block|,
name|IX86_BUILTIN_PSRADI
block|,
name|IX86_BUILTIN_PSRLWI
block|,
name|IX86_BUILTIN_PSRLDI
block|,
name|IX86_BUILTIN_PSRLQI
block|,
name|IX86_BUILTIN_PUNPCKHBW
block|,
name|IX86_BUILTIN_PUNPCKHWD
block|,
name|IX86_BUILTIN_PUNPCKHDQ
block|,
name|IX86_BUILTIN_PUNPCKLBW
block|,
name|IX86_BUILTIN_PUNPCKLWD
block|,
name|IX86_BUILTIN_PUNPCKLDQ
block|,
name|IX86_BUILTIN_SHUFPS
block|,
name|IX86_BUILTIN_RCPPS
block|,
name|IX86_BUILTIN_RCPSS
block|,
name|IX86_BUILTIN_RSQRTPS
block|,
name|IX86_BUILTIN_RSQRTSS
block|,
name|IX86_BUILTIN_SQRTPS
block|,
name|IX86_BUILTIN_SQRTSS
block|,
name|IX86_BUILTIN_UNPCKHPS
block|,
name|IX86_BUILTIN_UNPCKLPS
block|,
name|IX86_BUILTIN_ANDPS
block|,
name|IX86_BUILTIN_ANDNPS
block|,
name|IX86_BUILTIN_ORPS
block|,
name|IX86_BUILTIN_XORPS
block|,
name|IX86_BUILTIN_EMMS
block|,
name|IX86_BUILTIN_LDMXCSR
block|,
name|IX86_BUILTIN_STMXCSR
block|,
name|IX86_BUILTIN_SFENCE
block|,
comment|/* 3DNow! Original */
name|IX86_BUILTIN_FEMMS
block|,
name|IX86_BUILTIN_PAVGUSB
block|,
name|IX86_BUILTIN_PF2ID
block|,
name|IX86_BUILTIN_PFACC
block|,
name|IX86_BUILTIN_PFADD
block|,
name|IX86_BUILTIN_PFCMPEQ
block|,
name|IX86_BUILTIN_PFCMPGE
block|,
name|IX86_BUILTIN_PFCMPGT
block|,
name|IX86_BUILTIN_PFMAX
block|,
name|IX86_BUILTIN_PFMIN
block|,
name|IX86_BUILTIN_PFMUL
block|,
name|IX86_BUILTIN_PFRCP
block|,
name|IX86_BUILTIN_PFRCPIT1
block|,
name|IX86_BUILTIN_PFRCPIT2
block|,
name|IX86_BUILTIN_PFRSQIT1
block|,
name|IX86_BUILTIN_PFRSQRT
block|,
name|IX86_BUILTIN_PFSUB
block|,
name|IX86_BUILTIN_PFSUBR
block|,
name|IX86_BUILTIN_PI2FD
block|,
name|IX86_BUILTIN_PMULHRW
block|,
comment|/* 3DNow! Athlon Extensions */
name|IX86_BUILTIN_PF2IW
block|,
name|IX86_BUILTIN_PFNACC
block|,
name|IX86_BUILTIN_PFPNACC
block|,
name|IX86_BUILTIN_PI2FW
block|,
name|IX86_BUILTIN_PSWAPDSI
block|,
name|IX86_BUILTIN_PSWAPDSF
block|,
comment|/* SSE2 */
name|IX86_BUILTIN_ADDPD
block|,
name|IX86_BUILTIN_ADDSD
block|,
name|IX86_BUILTIN_DIVPD
block|,
name|IX86_BUILTIN_DIVSD
block|,
name|IX86_BUILTIN_MULPD
block|,
name|IX86_BUILTIN_MULSD
block|,
name|IX86_BUILTIN_SUBPD
block|,
name|IX86_BUILTIN_SUBSD
block|,
name|IX86_BUILTIN_CMPEQPD
block|,
name|IX86_BUILTIN_CMPLTPD
block|,
name|IX86_BUILTIN_CMPLEPD
block|,
name|IX86_BUILTIN_CMPGTPD
block|,
name|IX86_BUILTIN_CMPGEPD
block|,
name|IX86_BUILTIN_CMPNEQPD
block|,
name|IX86_BUILTIN_CMPNLTPD
block|,
name|IX86_BUILTIN_CMPNLEPD
block|,
name|IX86_BUILTIN_CMPNGTPD
block|,
name|IX86_BUILTIN_CMPNGEPD
block|,
name|IX86_BUILTIN_CMPORDPD
block|,
name|IX86_BUILTIN_CMPUNORDPD
block|,
name|IX86_BUILTIN_CMPNEPD
block|,
name|IX86_BUILTIN_CMPEQSD
block|,
name|IX86_BUILTIN_CMPLTSD
block|,
name|IX86_BUILTIN_CMPLESD
block|,
name|IX86_BUILTIN_CMPNEQSD
block|,
name|IX86_BUILTIN_CMPNLTSD
block|,
name|IX86_BUILTIN_CMPNLESD
block|,
name|IX86_BUILTIN_CMPORDSD
block|,
name|IX86_BUILTIN_CMPUNORDSD
block|,
name|IX86_BUILTIN_CMPNESD
block|,
name|IX86_BUILTIN_COMIEQSD
block|,
name|IX86_BUILTIN_COMILTSD
block|,
name|IX86_BUILTIN_COMILESD
block|,
name|IX86_BUILTIN_COMIGTSD
block|,
name|IX86_BUILTIN_COMIGESD
block|,
name|IX86_BUILTIN_COMINEQSD
block|,
name|IX86_BUILTIN_UCOMIEQSD
block|,
name|IX86_BUILTIN_UCOMILTSD
block|,
name|IX86_BUILTIN_UCOMILESD
block|,
name|IX86_BUILTIN_UCOMIGTSD
block|,
name|IX86_BUILTIN_UCOMIGESD
block|,
name|IX86_BUILTIN_UCOMINEQSD
block|,
name|IX86_BUILTIN_MAXPD
block|,
name|IX86_BUILTIN_MAXSD
block|,
name|IX86_BUILTIN_MINPD
block|,
name|IX86_BUILTIN_MINSD
block|,
name|IX86_BUILTIN_ANDPD
block|,
name|IX86_BUILTIN_ANDNPD
block|,
name|IX86_BUILTIN_ORPD
block|,
name|IX86_BUILTIN_XORPD
block|,
name|IX86_BUILTIN_SQRTPD
block|,
name|IX86_BUILTIN_SQRTSD
block|,
name|IX86_BUILTIN_UNPCKHPD
block|,
name|IX86_BUILTIN_UNPCKLPD
block|,
name|IX86_BUILTIN_SHUFPD
block|,
name|IX86_BUILTIN_LOADUPD
block|,
name|IX86_BUILTIN_STOREUPD
block|,
name|IX86_BUILTIN_MOVSD
block|,
name|IX86_BUILTIN_LOADHPD
block|,
name|IX86_BUILTIN_LOADLPD
block|,
name|IX86_BUILTIN_CVTDQ2PD
block|,
name|IX86_BUILTIN_CVTDQ2PS
block|,
name|IX86_BUILTIN_CVTPD2DQ
block|,
name|IX86_BUILTIN_CVTPD2PI
block|,
name|IX86_BUILTIN_CVTPD2PS
block|,
name|IX86_BUILTIN_CVTTPD2DQ
block|,
name|IX86_BUILTIN_CVTTPD2PI
block|,
name|IX86_BUILTIN_CVTPI2PD
block|,
name|IX86_BUILTIN_CVTSI2SD
block|,
name|IX86_BUILTIN_CVTSI642SD
block|,
name|IX86_BUILTIN_CVTSD2SI
block|,
name|IX86_BUILTIN_CVTSD2SI64
block|,
name|IX86_BUILTIN_CVTSD2SS
block|,
name|IX86_BUILTIN_CVTSS2SD
block|,
name|IX86_BUILTIN_CVTTSD2SI
block|,
name|IX86_BUILTIN_CVTTSD2SI64
block|,
name|IX86_BUILTIN_CVTPS2DQ
block|,
name|IX86_BUILTIN_CVTPS2PD
block|,
name|IX86_BUILTIN_CVTTPS2DQ
block|,
name|IX86_BUILTIN_MOVNTI
block|,
name|IX86_BUILTIN_MOVNTPD
block|,
name|IX86_BUILTIN_MOVNTDQ
block|,
comment|/* SSE2 MMX */
name|IX86_BUILTIN_MASKMOVDQU
block|,
name|IX86_BUILTIN_MOVMSKPD
block|,
name|IX86_BUILTIN_PMOVMSKB128
block|,
name|IX86_BUILTIN_PACKSSWB128
block|,
name|IX86_BUILTIN_PACKSSDW128
block|,
name|IX86_BUILTIN_PACKUSWB128
block|,
name|IX86_BUILTIN_PADDB128
block|,
name|IX86_BUILTIN_PADDW128
block|,
name|IX86_BUILTIN_PADDD128
block|,
name|IX86_BUILTIN_PADDQ128
block|,
name|IX86_BUILTIN_PADDSB128
block|,
name|IX86_BUILTIN_PADDSW128
block|,
name|IX86_BUILTIN_PADDUSB128
block|,
name|IX86_BUILTIN_PADDUSW128
block|,
name|IX86_BUILTIN_PSUBB128
block|,
name|IX86_BUILTIN_PSUBW128
block|,
name|IX86_BUILTIN_PSUBD128
block|,
name|IX86_BUILTIN_PSUBQ128
block|,
name|IX86_BUILTIN_PSUBSB128
block|,
name|IX86_BUILTIN_PSUBSW128
block|,
name|IX86_BUILTIN_PSUBUSB128
block|,
name|IX86_BUILTIN_PSUBUSW128
block|,
name|IX86_BUILTIN_PAND128
block|,
name|IX86_BUILTIN_PANDN128
block|,
name|IX86_BUILTIN_POR128
block|,
name|IX86_BUILTIN_PXOR128
block|,
name|IX86_BUILTIN_PAVGB128
block|,
name|IX86_BUILTIN_PAVGW128
block|,
name|IX86_BUILTIN_PCMPEQB128
block|,
name|IX86_BUILTIN_PCMPEQW128
block|,
name|IX86_BUILTIN_PCMPEQD128
block|,
name|IX86_BUILTIN_PCMPGTB128
block|,
name|IX86_BUILTIN_PCMPGTW128
block|,
name|IX86_BUILTIN_PCMPGTD128
block|,
name|IX86_BUILTIN_PMADDWD128
block|,
name|IX86_BUILTIN_PMAXSW128
block|,
name|IX86_BUILTIN_PMAXUB128
block|,
name|IX86_BUILTIN_PMINSW128
block|,
name|IX86_BUILTIN_PMINUB128
block|,
name|IX86_BUILTIN_PMULUDQ
block|,
name|IX86_BUILTIN_PMULUDQ128
block|,
name|IX86_BUILTIN_PMULHUW128
block|,
name|IX86_BUILTIN_PMULHW128
block|,
name|IX86_BUILTIN_PMULLW128
block|,
name|IX86_BUILTIN_PSADBW128
block|,
name|IX86_BUILTIN_PSHUFHW
block|,
name|IX86_BUILTIN_PSHUFLW
block|,
name|IX86_BUILTIN_PSHUFD
block|,
name|IX86_BUILTIN_PSLLW128
block|,
name|IX86_BUILTIN_PSLLD128
block|,
name|IX86_BUILTIN_PSLLQ128
block|,
name|IX86_BUILTIN_PSRAW128
block|,
name|IX86_BUILTIN_PSRAD128
block|,
name|IX86_BUILTIN_PSRLW128
block|,
name|IX86_BUILTIN_PSRLD128
block|,
name|IX86_BUILTIN_PSRLQ128
block|,
name|IX86_BUILTIN_PSLLDQI128
block|,
name|IX86_BUILTIN_PSLLWI128
block|,
name|IX86_BUILTIN_PSLLDI128
block|,
name|IX86_BUILTIN_PSLLQI128
block|,
name|IX86_BUILTIN_PSRAWI128
block|,
name|IX86_BUILTIN_PSRADI128
block|,
name|IX86_BUILTIN_PSRLDQI128
block|,
name|IX86_BUILTIN_PSRLWI128
block|,
name|IX86_BUILTIN_PSRLDI128
block|,
name|IX86_BUILTIN_PSRLQI128
block|,
name|IX86_BUILTIN_PUNPCKHBW128
block|,
name|IX86_BUILTIN_PUNPCKHWD128
block|,
name|IX86_BUILTIN_PUNPCKHDQ128
block|,
name|IX86_BUILTIN_PUNPCKHQDQ128
block|,
name|IX86_BUILTIN_PUNPCKLBW128
block|,
name|IX86_BUILTIN_PUNPCKLWD128
block|,
name|IX86_BUILTIN_PUNPCKLDQ128
block|,
name|IX86_BUILTIN_PUNPCKLQDQ128
block|,
name|IX86_BUILTIN_CLFLUSH
block|,
name|IX86_BUILTIN_MFENCE
block|,
name|IX86_BUILTIN_LFENCE
block|,
comment|/* Prescott New Instructions.  */
name|IX86_BUILTIN_ADDSUBPS
block|,
name|IX86_BUILTIN_HADDPS
block|,
name|IX86_BUILTIN_HSUBPS
block|,
name|IX86_BUILTIN_MOVSHDUP
block|,
name|IX86_BUILTIN_MOVSLDUP
block|,
name|IX86_BUILTIN_ADDSUBPD
block|,
name|IX86_BUILTIN_HADDPD
block|,
name|IX86_BUILTIN_HSUBPD
block|,
name|IX86_BUILTIN_LDDQU
block|,
name|IX86_BUILTIN_MONITOR
block|,
name|IX86_BUILTIN_MWAIT
block|,
name|IX86_BUILTIN_VEC_INIT_V2SI
block|,
name|IX86_BUILTIN_VEC_INIT_V4HI
block|,
name|IX86_BUILTIN_VEC_INIT_V8QI
block|,
name|IX86_BUILTIN_VEC_EXT_V2DF
block|,
name|IX86_BUILTIN_VEC_EXT_V2DI
block|,
name|IX86_BUILTIN_VEC_EXT_V4SF
block|,
name|IX86_BUILTIN_VEC_EXT_V4SI
block|,
name|IX86_BUILTIN_VEC_EXT_V8HI
block|,
name|IX86_BUILTIN_VEC_EXT_V16QI
block|,
name|IX86_BUILTIN_VEC_EXT_V2SI
block|,
name|IX86_BUILTIN_VEC_EXT_V4HI
block|,
name|IX86_BUILTIN_VEC_SET_V8HI
block|,
name|IX86_BUILTIN_VEC_SET_V4HI
block|,
name|IX86_BUILTIN_MAX
block|}
enum|;
end_enum

begin_define
define|#
directive|define
name|def_builtin
parameter_list|(
name|MASK
parameter_list|,
name|NAME
parameter_list|,
name|TYPE
parameter_list|,
name|CODE
parameter_list|)
define|\
value|do {									\   if ((MASK)& target_flags						\&& (!((MASK)& MASK_64BIT) || TARGET_64BIT))			\     lang_hooks.builtin_function ((NAME), (TYPE), (CODE), BUILT_IN_MD,	\ 				 NULL, NULL_TREE);			\ } while (0)
end_define

begin_comment
comment|/* Bits for builtin_description.flag.  */
end_comment

begin_comment
comment|/* Set when we don't support the comparison natively, and should    swap_comparison in order to support it.  */
end_comment

begin_define
define|#
directive|define
name|BUILTIN_DESC_SWAP_OPERANDS
value|1
end_define

begin_struct
struct|struct
name|builtin_description
block|{
specifier|const
name|unsigned
name|int
name|mask
decl_stmt|;
specifier|const
name|enum
name|insn_code
name|icode
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
specifier|const
name|enum
name|ix86_builtins
name|code
decl_stmt|;
specifier|const
name|enum
name|rtx_code
name|comparison
decl_stmt|;
specifier|const
name|unsigned
name|int
name|flag
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|builtin_description
name|bdesc_comi
index|[]
init|=
block|{
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_comi
block|,
literal|"__builtin_ia32_comieq"
block|,
name|IX86_BUILTIN_COMIEQSS
block|,
name|UNEQ
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_comi
block|,
literal|"__builtin_ia32_comilt"
block|,
name|IX86_BUILTIN_COMILTSS
block|,
name|UNLT
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_comi
block|,
literal|"__builtin_ia32_comile"
block|,
name|IX86_BUILTIN_COMILESS
block|,
name|UNLE
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_comi
block|,
literal|"__builtin_ia32_comigt"
block|,
name|IX86_BUILTIN_COMIGTSS
block|,
name|GT
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_comi
block|,
literal|"__builtin_ia32_comige"
block|,
name|IX86_BUILTIN_COMIGESS
block|,
name|GE
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_comi
block|,
literal|"__builtin_ia32_comineq"
block|,
name|IX86_BUILTIN_COMINEQSS
block|,
name|LTGT
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_ucomi
block|,
literal|"__builtin_ia32_ucomieq"
block|,
name|IX86_BUILTIN_UCOMIEQSS
block|,
name|UNEQ
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_ucomi
block|,
literal|"__builtin_ia32_ucomilt"
block|,
name|IX86_BUILTIN_UCOMILTSS
block|,
name|UNLT
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_ucomi
block|,
literal|"__builtin_ia32_ucomile"
block|,
name|IX86_BUILTIN_UCOMILESS
block|,
name|UNLE
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_ucomi
block|,
literal|"__builtin_ia32_ucomigt"
block|,
name|IX86_BUILTIN_UCOMIGTSS
block|,
name|GT
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_ucomi
block|,
literal|"__builtin_ia32_ucomige"
block|,
name|IX86_BUILTIN_UCOMIGESS
block|,
name|GE
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_ucomi
block|,
literal|"__builtin_ia32_ucomineq"
block|,
name|IX86_BUILTIN_UCOMINEQSS
block|,
name|LTGT
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_comi
block|,
literal|"__builtin_ia32_comisdeq"
block|,
name|IX86_BUILTIN_COMIEQSD
block|,
name|UNEQ
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_comi
block|,
literal|"__builtin_ia32_comisdlt"
block|,
name|IX86_BUILTIN_COMILTSD
block|,
name|UNLT
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_comi
block|,
literal|"__builtin_ia32_comisdle"
block|,
name|IX86_BUILTIN_COMILESD
block|,
name|UNLE
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_comi
block|,
literal|"__builtin_ia32_comisdgt"
block|,
name|IX86_BUILTIN_COMIGTSD
block|,
name|GT
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_comi
block|,
literal|"__builtin_ia32_comisdge"
block|,
name|IX86_BUILTIN_COMIGESD
block|,
name|GE
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_comi
block|,
literal|"__builtin_ia32_comisdneq"
block|,
name|IX86_BUILTIN_COMINEQSD
block|,
name|LTGT
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_ucomi
block|,
literal|"__builtin_ia32_ucomisdeq"
block|,
name|IX86_BUILTIN_UCOMIEQSD
block|,
name|UNEQ
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_ucomi
block|,
literal|"__builtin_ia32_ucomisdlt"
block|,
name|IX86_BUILTIN_UCOMILTSD
block|,
name|UNLT
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_ucomi
block|,
literal|"__builtin_ia32_ucomisdle"
block|,
name|IX86_BUILTIN_UCOMILESD
block|,
name|UNLE
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_ucomi
block|,
literal|"__builtin_ia32_ucomisdgt"
block|,
name|IX86_BUILTIN_UCOMIGTSD
block|,
name|GT
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_ucomi
block|,
literal|"__builtin_ia32_ucomisdge"
block|,
name|IX86_BUILTIN_UCOMIGESD
block|,
name|GE
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_ucomi
block|,
literal|"__builtin_ia32_ucomisdneq"
block|,
name|IX86_BUILTIN_UCOMINEQSD
block|,
name|LTGT
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|builtin_description
name|bdesc_2arg
index|[]
init|=
block|{
comment|/* SSE */
block|{
name|MASK_SSE
block|,
name|CODE_FOR_addv4sf3
block|,
literal|"__builtin_ia32_addps"
block|,
name|IX86_BUILTIN_ADDPS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_subv4sf3
block|,
literal|"__builtin_ia32_subps"
block|,
name|IX86_BUILTIN_SUBPS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_mulv4sf3
block|,
literal|"__builtin_ia32_mulps"
block|,
name|IX86_BUILTIN_MULPS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_divv4sf3
block|,
literal|"__builtin_ia32_divps"
block|,
name|IX86_BUILTIN_DIVPS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_vmaddv4sf3
block|,
literal|"__builtin_ia32_addss"
block|,
name|IX86_BUILTIN_ADDSS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_vmsubv4sf3
block|,
literal|"__builtin_ia32_subss"
block|,
name|IX86_BUILTIN_SUBSS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_vmmulv4sf3
block|,
literal|"__builtin_ia32_mulss"
block|,
name|IX86_BUILTIN_MULSS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_vmdivv4sf3
block|,
literal|"__builtin_ia32_divss"
block|,
name|IX86_BUILTIN_DIVSS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_maskcmpv4sf3
block|,
literal|"__builtin_ia32_cmpeqps"
block|,
name|IX86_BUILTIN_CMPEQPS
block|,
name|EQ
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_maskcmpv4sf3
block|,
literal|"__builtin_ia32_cmpltps"
block|,
name|IX86_BUILTIN_CMPLTPS
block|,
name|LT
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_maskcmpv4sf3
block|,
literal|"__builtin_ia32_cmpleps"
block|,
name|IX86_BUILTIN_CMPLEPS
block|,
name|LE
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_maskcmpv4sf3
block|,
literal|"__builtin_ia32_cmpgtps"
block|,
name|IX86_BUILTIN_CMPGTPS
block|,
name|LT
block|,
name|BUILTIN_DESC_SWAP_OPERANDS
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_maskcmpv4sf3
block|,
literal|"__builtin_ia32_cmpgeps"
block|,
name|IX86_BUILTIN_CMPGEPS
block|,
name|LE
block|,
name|BUILTIN_DESC_SWAP_OPERANDS
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_maskcmpv4sf3
block|,
literal|"__builtin_ia32_cmpunordps"
block|,
name|IX86_BUILTIN_CMPUNORDPS
block|,
name|UNORDERED
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_maskcmpv4sf3
block|,
literal|"__builtin_ia32_cmpneqps"
block|,
name|IX86_BUILTIN_CMPNEQPS
block|,
name|NE
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_maskcmpv4sf3
block|,
literal|"__builtin_ia32_cmpnltps"
block|,
name|IX86_BUILTIN_CMPNLTPS
block|,
name|UNGE
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_maskcmpv4sf3
block|,
literal|"__builtin_ia32_cmpnleps"
block|,
name|IX86_BUILTIN_CMPNLEPS
block|,
name|UNGT
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_maskcmpv4sf3
block|,
literal|"__builtin_ia32_cmpngtps"
block|,
name|IX86_BUILTIN_CMPNGTPS
block|,
name|UNGE
block|,
name|BUILTIN_DESC_SWAP_OPERANDS
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_maskcmpv4sf3
block|,
literal|"__builtin_ia32_cmpngeps"
block|,
name|IX86_BUILTIN_CMPNGEPS
block|,
name|UNGT
block|,
name|BUILTIN_DESC_SWAP_OPERANDS
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_maskcmpv4sf3
block|,
literal|"__builtin_ia32_cmpordps"
block|,
name|IX86_BUILTIN_CMPORDPS
block|,
name|ORDERED
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_vmmaskcmpv4sf3
block|,
literal|"__builtin_ia32_cmpeqss"
block|,
name|IX86_BUILTIN_CMPEQSS
block|,
name|EQ
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_vmmaskcmpv4sf3
block|,
literal|"__builtin_ia32_cmpltss"
block|,
name|IX86_BUILTIN_CMPLTSS
block|,
name|LT
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_vmmaskcmpv4sf3
block|,
literal|"__builtin_ia32_cmpless"
block|,
name|IX86_BUILTIN_CMPLESS
block|,
name|LE
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_vmmaskcmpv4sf3
block|,
literal|"__builtin_ia32_cmpunordss"
block|,
name|IX86_BUILTIN_CMPUNORDSS
block|,
name|UNORDERED
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_vmmaskcmpv4sf3
block|,
literal|"__builtin_ia32_cmpneqss"
block|,
name|IX86_BUILTIN_CMPNEQSS
block|,
name|NE
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_vmmaskcmpv4sf3
block|,
literal|"__builtin_ia32_cmpnltss"
block|,
name|IX86_BUILTIN_CMPNLTSS
block|,
name|UNGE
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_vmmaskcmpv4sf3
block|,
literal|"__builtin_ia32_cmpnless"
block|,
name|IX86_BUILTIN_CMPNLESS
block|,
name|UNGT
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_vmmaskcmpv4sf3
block|,
literal|"__builtin_ia32_cmpngtss"
block|,
name|IX86_BUILTIN_CMPNGTSS
block|,
name|UNGE
block|,
name|BUILTIN_DESC_SWAP_OPERANDS
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_vmmaskcmpv4sf3
block|,
literal|"__builtin_ia32_cmpngess"
block|,
name|IX86_BUILTIN_CMPNGESS
block|,
name|UNGT
block|,
name|BUILTIN_DESC_SWAP_OPERANDS
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_vmmaskcmpv4sf3
block|,
literal|"__builtin_ia32_cmpordss"
block|,
name|IX86_BUILTIN_CMPORDSS
block|,
name|ORDERED
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sminv4sf3
block|,
literal|"__builtin_ia32_minps"
block|,
name|IX86_BUILTIN_MINPS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_smaxv4sf3
block|,
literal|"__builtin_ia32_maxps"
block|,
name|IX86_BUILTIN_MAXPS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_vmsminv4sf3
block|,
literal|"__builtin_ia32_minss"
block|,
name|IX86_BUILTIN_MINSS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_vmsmaxv4sf3
block|,
literal|"__builtin_ia32_maxss"
block|,
name|IX86_BUILTIN_MAXSS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_andv4sf3
block|,
literal|"__builtin_ia32_andps"
block|,
name|IX86_BUILTIN_ANDPS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_nandv4sf3
block|,
literal|"__builtin_ia32_andnps"
block|,
name|IX86_BUILTIN_ANDNPS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_iorv4sf3
block|,
literal|"__builtin_ia32_orps"
block|,
name|IX86_BUILTIN_ORPS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_xorv4sf3
block|,
literal|"__builtin_ia32_xorps"
block|,
name|IX86_BUILTIN_XORPS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_movss
block|,
literal|"__builtin_ia32_movss"
block|,
name|IX86_BUILTIN_MOVSS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_movhlps
block|,
literal|"__builtin_ia32_movhlps"
block|,
name|IX86_BUILTIN_MOVHLPS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_movlhps
block|,
literal|"__builtin_ia32_movlhps"
block|,
name|IX86_BUILTIN_MOVLHPS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_unpckhps
block|,
literal|"__builtin_ia32_unpckhps"
block|,
name|IX86_BUILTIN_UNPCKHPS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_unpcklps
block|,
literal|"__builtin_ia32_unpcklps"
block|,
name|IX86_BUILTIN_UNPCKLPS
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* MMX */
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_addv8qi3
block|,
literal|"__builtin_ia32_paddb"
block|,
name|IX86_BUILTIN_PADDB
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_addv4hi3
block|,
literal|"__builtin_ia32_paddw"
block|,
name|IX86_BUILTIN_PADDW
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_addv2si3
block|,
literal|"__builtin_ia32_paddd"
block|,
name|IX86_BUILTIN_PADDD
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_mmx_adddi3
block|,
literal|"__builtin_ia32_paddq"
block|,
name|IX86_BUILTIN_PADDQ
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_subv8qi3
block|,
literal|"__builtin_ia32_psubb"
block|,
name|IX86_BUILTIN_PSUBB
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_subv4hi3
block|,
literal|"__builtin_ia32_psubw"
block|,
name|IX86_BUILTIN_PSUBW
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_subv2si3
block|,
literal|"__builtin_ia32_psubd"
block|,
name|IX86_BUILTIN_PSUBD
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_mmx_subdi3
block|,
literal|"__builtin_ia32_psubq"
block|,
name|IX86_BUILTIN_PSUBQ
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_ssaddv8qi3
block|,
literal|"__builtin_ia32_paddsb"
block|,
name|IX86_BUILTIN_PADDSB
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_ssaddv4hi3
block|,
literal|"__builtin_ia32_paddsw"
block|,
name|IX86_BUILTIN_PADDSW
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_sssubv8qi3
block|,
literal|"__builtin_ia32_psubsb"
block|,
name|IX86_BUILTIN_PSUBSB
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_sssubv4hi3
block|,
literal|"__builtin_ia32_psubsw"
block|,
name|IX86_BUILTIN_PSUBSW
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_usaddv8qi3
block|,
literal|"__builtin_ia32_paddusb"
block|,
name|IX86_BUILTIN_PADDUSB
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_usaddv4hi3
block|,
literal|"__builtin_ia32_paddusw"
block|,
name|IX86_BUILTIN_PADDUSW
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_ussubv8qi3
block|,
literal|"__builtin_ia32_psubusb"
block|,
name|IX86_BUILTIN_PSUBUSB
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_ussubv4hi3
block|,
literal|"__builtin_ia32_psubusw"
block|,
name|IX86_BUILTIN_PSUBUSW
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_mulv4hi3
block|,
literal|"__builtin_ia32_pmullw"
block|,
name|IX86_BUILTIN_PMULLW
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_smulv4hi3_highpart
block|,
literal|"__builtin_ia32_pmulhw"
block|,
name|IX86_BUILTIN_PMULHW
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
operator||
name|MASK_3DNOW_A
block|,
name|CODE_FOR_mmx_umulv4hi3_highpart
block|,
literal|"__builtin_ia32_pmulhuw"
block|,
name|IX86_BUILTIN_PMULHUW
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_andv2si3
block|,
literal|"__builtin_ia32_pand"
block|,
name|IX86_BUILTIN_PAND
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_nandv2si3
block|,
literal|"__builtin_ia32_pandn"
block|,
name|IX86_BUILTIN_PANDN
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_iorv2si3
block|,
literal|"__builtin_ia32_por"
block|,
name|IX86_BUILTIN_POR
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_xorv2si3
block|,
literal|"__builtin_ia32_pxor"
block|,
name|IX86_BUILTIN_PXOR
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
operator||
name|MASK_3DNOW_A
block|,
name|CODE_FOR_mmx_uavgv8qi3
block|,
literal|"__builtin_ia32_pavgb"
block|,
name|IX86_BUILTIN_PAVGB
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
operator||
name|MASK_3DNOW_A
block|,
name|CODE_FOR_mmx_uavgv4hi3
block|,
literal|"__builtin_ia32_pavgw"
block|,
name|IX86_BUILTIN_PAVGW
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_eqv8qi3
block|,
literal|"__builtin_ia32_pcmpeqb"
block|,
name|IX86_BUILTIN_PCMPEQB
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_eqv4hi3
block|,
literal|"__builtin_ia32_pcmpeqw"
block|,
name|IX86_BUILTIN_PCMPEQW
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_eqv2si3
block|,
literal|"__builtin_ia32_pcmpeqd"
block|,
name|IX86_BUILTIN_PCMPEQD
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_gtv8qi3
block|,
literal|"__builtin_ia32_pcmpgtb"
block|,
name|IX86_BUILTIN_PCMPGTB
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_gtv4hi3
block|,
literal|"__builtin_ia32_pcmpgtw"
block|,
name|IX86_BUILTIN_PCMPGTW
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_gtv2si3
block|,
literal|"__builtin_ia32_pcmpgtd"
block|,
name|IX86_BUILTIN_PCMPGTD
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
operator||
name|MASK_3DNOW_A
block|,
name|CODE_FOR_mmx_umaxv8qi3
block|,
literal|"__builtin_ia32_pmaxub"
block|,
name|IX86_BUILTIN_PMAXUB
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
operator||
name|MASK_3DNOW_A
block|,
name|CODE_FOR_mmx_smaxv4hi3
block|,
literal|"__builtin_ia32_pmaxsw"
block|,
name|IX86_BUILTIN_PMAXSW
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
operator||
name|MASK_3DNOW_A
block|,
name|CODE_FOR_mmx_uminv8qi3
block|,
literal|"__builtin_ia32_pminub"
block|,
name|IX86_BUILTIN_PMINUB
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
operator||
name|MASK_3DNOW_A
block|,
name|CODE_FOR_mmx_sminv4hi3
block|,
literal|"__builtin_ia32_pminsw"
block|,
name|IX86_BUILTIN_PMINSW
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_punpckhbw
block|,
literal|"__builtin_ia32_punpckhbw"
block|,
name|IX86_BUILTIN_PUNPCKHBW
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_punpckhwd
block|,
literal|"__builtin_ia32_punpckhwd"
block|,
name|IX86_BUILTIN_PUNPCKHWD
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_punpckhdq
block|,
literal|"__builtin_ia32_punpckhdq"
block|,
name|IX86_BUILTIN_PUNPCKHDQ
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_punpcklbw
block|,
literal|"__builtin_ia32_punpcklbw"
block|,
name|IX86_BUILTIN_PUNPCKLBW
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_punpcklwd
block|,
literal|"__builtin_ia32_punpcklwd"
block|,
name|IX86_BUILTIN_PUNPCKLWD
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_punpckldq
block|,
literal|"__builtin_ia32_punpckldq"
block|,
name|IX86_BUILTIN_PUNPCKLDQ
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Special.  */
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_packsswb
block|,
literal|0
block|,
name|IX86_BUILTIN_PACKSSWB
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_packssdw
block|,
literal|0
block|,
name|IX86_BUILTIN_PACKSSDW
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_packuswb
block|,
literal|0
block|,
name|IX86_BUILTIN_PACKUSWB
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_cvtpi2ps
block|,
literal|0
block|,
name|IX86_BUILTIN_CVTPI2PS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_cvtsi2ss
block|,
literal|0
block|,
name|IX86_BUILTIN_CVTSI2SS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
operator||
name|MASK_64BIT
block|,
name|CODE_FOR_sse_cvtsi2ssq
block|,
literal|0
block|,
name|IX86_BUILTIN_CVTSI642SS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_ashlv4hi3
block|,
literal|0
block|,
name|IX86_BUILTIN_PSLLW
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_ashlv4hi3
block|,
literal|0
block|,
name|IX86_BUILTIN_PSLLWI
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_ashlv2si3
block|,
literal|0
block|,
name|IX86_BUILTIN_PSLLD
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_ashlv2si3
block|,
literal|0
block|,
name|IX86_BUILTIN_PSLLDI
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_ashldi3
block|,
literal|0
block|,
name|IX86_BUILTIN_PSLLQ
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_ashldi3
block|,
literal|0
block|,
name|IX86_BUILTIN_PSLLQI
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_lshrv4hi3
block|,
literal|0
block|,
name|IX86_BUILTIN_PSRLW
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_lshrv4hi3
block|,
literal|0
block|,
name|IX86_BUILTIN_PSRLWI
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_lshrv2si3
block|,
literal|0
block|,
name|IX86_BUILTIN_PSRLD
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_lshrv2si3
block|,
literal|0
block|,
name|IX86_BUILTIN_PSRLDI
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_lshrdi3
block|,
literal|0
block|,
name|IX86_BUILTIN_PSRLQ
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_lshrdi3
block|,
literal|0
block|,
name|IX86_BUILTIN_PSRLQI
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_ashrv4hi3
block|,
literal|0
block|,
name|IX86_BUILTIN_PSRAW
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_ashrv4hi3
block|,
literal|0
block|,
name|IX86_BUILTIN_PSRAWI
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_ashrv2si3
block|,
literal|0
block|,
name|IX86_BUILTIN_PSRAD
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_ashrv2si3
block|,
literal|0
block|,
name|IX86_BUILTIN_PSRADI
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
operator||
name|MASK_3DNOW_A
block|,
name|CODE_FOR_mmx_psadbw
block|,
literal|0
block|,
name|IX86_BUILTIN_PSADBW
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_pmaddwd
block|,
literal|0
block|,
name|IX86_BUILTIN_PMADDWD
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* SSE2 */
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_addv2df3
block|,
literal|"__builtin_ia32_addpd"
block|,
name|IX86_BUILTIN_ADDPD
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_subv2df3
block|,
literal|"__builtin_ia32_subpd"
block|,
name|IX86_BUILTIN_SUBPD
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_mulv2df3
block|,
literal|"__builtin_ia32_mulpd"
block|,
name|IX86_BUILTIN_MULPD
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_divv2df3
block|,
literal|"__builtin_ia32_divpd"
block|,
name|IX86_BUILTIN_DIVPD
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_vmaddv2df3
block|,
literal|"__builtin_ia32_addsd"
block|,
name|IX86_BUILTIN_ADDSD
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_vmsubv2df3
block|,
literal|"__builtin_ia32_subsd"
block|,
name|IX86_BUILTIN_SUBSD
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_vmmulv2df3
block|,
literal|"__builtin_ia32_mulsd"
block|,
name|IX86_BUILTIN_MULSD
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_vmdivv2df3
block|,
literal|"__builtin_ia32_divsd"
block|,
name|IX86_BUILTIN_DIVSD
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_maskcmpv2df3
block|,
literal|"__builtin_ia32_cmpeqpd"
block|,
name|IX86_BUILTIN_CMPEQPD
block|,
name|EQ
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_maskcmpv2df3
block|,
literal|"__builtin_ia32_cmpltpd"
block|,
name|IX86_BUILTIN_CMPLTPD
block|,
name|LT
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_maskcmpv2df3
block|,
literal|"__builtin_ia32_cmplepd"
block|,
name|IX86_BUILTIN_CMPLEPD
block|,
name|LE
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_maskcmpv2df3
block|,
literal|"__builtin_ia32_cmpgtpd"
block|,
name|IX86_BUILTIN_CMPGTPD
block|,
name|LT
block|,
name|BUILTIN_DESC_SWAP_OPERANDS
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_maskcmpv2df3
block|,
literal|"__builtin_ia32_cmpgepd"
block|,
name|IX86_BUILTIN_CMPGEPD
block|,
name|LE
block|,
name|BUILTIN_DESC_SWAP_OPERANDS
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_maskcmpv2df3
block|,
literal|"__builtin_ia32_cmpunordpd"
block|,
name|IX86_BUILTIN_CMPUNORDPD
block|,
name|UNORDERED
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_maskcmpv2df3
block|,
literal|"__builtin_ia32_cmpneqpd"
block|,
name|IX86_BUILTIN_CMPNEQPD
block|,
name|NE
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_maskcmpv2df3
block|,
literal|"__builtin_ia32_cmpnltpd"
block|,
name|IX86_BUILTIN_CMPNLTPD
block|,
name|UNGE
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_maskcmpv2df3
block|,
literal|"__builtin_ia32_cmpnlepd"
block|,
name|IX86_BUILTIN_CMPNLEPD
block|,
name|UNGT
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_maskcmpv2df3
block|,
literal|"__builtin_ia32_cmpngtpd"
block|,
name|IX86_BUILTIN_CMPNGTPD
block|,
name|UNGE
block|,
name|BUILTIN_DESC_SWAP_OPERANDS
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_maskcmpv2df3
block|,
literal|"__builtin_ia32_cmpngepd"
block|,
name|IX86_BUILTIN_CMPNGEPD
block|,
name|UNGT
block|,
name|BUILTIN_DESC_SWAP_OPERANDS
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_maskcmpv2df3
block|,
literal|"__builtin_ia32_cmpordpd"
block|,
name|IX86_BUILTIN_CMPORDPD
block|,
name|ORDERED
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_vmmaskcmpv2df3
block|,
literal|"__builtin_ia32_cmpeqsd"
block|,
name|IX86_BUILTIN_CMPEQSD
block|,
name|EQ
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_vmmaskcmpv2df3
block|,
literal|"__builtin_ia32_cmpltsd"
block|,
name|IX86_BUILTIN_CMPLTSD
block|,
name|LT
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_vmmaskcmpv2df3
block|,
literal|"__builtin_ia32_cmplesd"
block|,
name|IX86_BUILTIN_CMPLESD
block|,
name|LE
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_vmmaskcmpv2df3
block|,
literal|"__builtin_ia32_cmpunordsd"
block|,
name|IX86_BUILTIN_CMPUNORDSD
block|,
name|UNORDERED
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_vmmaskcmpv2df3
block|,
literal|"__builtin_ia32_cmpneqsd"
block|,
name|IX86_BUILTIN_CMPNEQSD
block|,
name|NE
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_vmmaskcmpv2df3
block|,
literal|"__builtin_ia32_cmpnltsd"
block|,
name|IX86_BUILTIN_CMPNLTSD
block|,
name|UNGE
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_vmmaskcmpv2df3
block|,
literal|"__builtin_ia32_cmpnlesd"
block|,
name|IX86_BUILTIN_CMPNLESD
block|,
name|UNGT
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_vmmaskcmpv2df3
block|,
literal|"__builtin_ia32_cmpordsd"
block|,
name|IX86_BUILTIN_CMPORDSD
block|,
name|ORDERED
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sminv2df3
block|,
literal|"__builtin_ia32_minpd"
block|,
name|IX86_BUILTIN_MINPD
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_smaxv2df3
block|,
literal|"__builtin_ia32_maxpd"
block|,
name|IX86_BUILTIN_MAXPD
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_vmsminv2df3
block|,
literal|"__builtin_ia32_minsd"
block|,
name|IX86_BUILTIN_MINSD
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_vmsmaxv2df3
block|,
literal|"__builtin_ia32_maxsd"
block|,
name|IX86_BUILTIN_MAXSD
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_andv2df3
block|,
literal|"__builtin_ia32_andpd"
block|,
name|IX86_BUILTIN_ANDPD
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_nandv2df3
block|,
literal|"__builtin_ia32_andnpd"
block|,
name|IX86_BUILTIN_ANDNPD
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_iorv2df3
block|,
literal|"__builtin_ia32_orpd"
block|,
name|IX86_BUILTIN_ORPD
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_xorv2df3
block|,
literal|"__builtin_ia32_xorpd"
block|,
name|IX86_BUILTIN_XORPD
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_movsd
block|,
literal|"__builtin_ia32_movsd"
block|,
name|IX86_BUILTIN_MOVSD
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_unpckhpd
block|,
literal|"__builtin_ia32_unpckhpd"
block|,
name|IX86_BUILTIN_UNPCKHPD
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_unpcklpd
block|,
literal|"__builtin_ia32_unpcklpd"
block|,
name|IX86_BUILTIN_UNPCKLPD
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* SSE2 MMX */
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_addv16qi3
block|,
literal|"__builtin_ia32_paddb128"
block|,
name|IX86_BUILTIN_PADDB128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_addv8hi3
block|,
literal|"__builtin_ia32_paddw128"
block|,
name|IX86_BUILTIN_PADDW128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_addv4si3
block|,
literal|"__builtin_ia32_paddd128"
block|,
name|IX86_BUILTIN_PADDD128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_addv2di3
block|,
literal|"__builtin_ia32_paddq128"
block|,
name|IX86_BUILTIN_PADDQ128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_subv16qi3
block|,
literal|"__builtin_ia32_psubb128"
block|,
name|IX86_BUILTIN_PSUBB128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_subv8hi3
block|,
literal|"__builtin_ia32_psubw128"
block|,
name|IX86_BUILTIN_PSUBW128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_subv4si3
block|,
literal|"__builtin_ia32_psubd128"
block|,
name|IX86_BUILTIN_PSUBD128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_subv2di3
block|,
literal|"__builtin_ia32_psubq128"
block|,
name|IX86_BUILTIN_PSUBQ128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_sse2_ssaddv16qi3
block|,
literal|"__builtin_ia32_paddsb128"
block|,
name|IX86_BUILTIN_PADDSB128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_sse2_ssaddv8hi3
block|,
literal|"__builtin_ia32_paddsw128"
block|,
name|IX86_BUILTIN_PADDSW128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_sse2_sssubv16qi3
block|,
literal|"__builtin_ia32_psubsb128"
block|,
name|IX86_BUILTIN_PSUBSB128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_sse2_sssubv8hi3
block|,
literal|"__builtin_ia32_psubsw128"
block|,
name|IX86_BUILTIN_PSUBSW128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_sse2_usaddv16qi3
block|,
literal|"__builtin_ia32_paddusb128"
block|,
name|IX86_BUILTIN_PADDUSB128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_sse2_usaddv8hi3
block|,
literal|"__builtin_ia32_paddusw128"
block|,
name|IX86_BUILTIN_PADDUSW128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_sse2_ussubv16qi3
block|,
literal|"__builtin_ia32_psubusb128"
block|,
name|IX86_BUILTIN_PSUBUSB128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_sse2_ussubv8hi3
block|,
literal|"__builtin_ia32_psubusw128"
block|,
name|IX86_BUILTIN_PSUBUSW128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_mulv8hi3
block|,
literal|"__builtin_ia32_pmullw128"
block|,
name|IX86_BUILTIN_PMULLW128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_smulv8hi3_highpart
block|,
literal|"__builtin_ia32_pmulhw128"
block|,
name|IX86_BUILTIN_PMULHW128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_andv2di3
block|,
literal|"__builtin_ia32_pand128"
block|,
name|IX86_BUILTIN_PAND128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_nandv2di3
block|,
literal|"__builtin_ia32_pandn128"
block|,
name|IX86_BUILTIN_PANDN128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_iorv2di3
block|,
literal|"__builtin_ia32_por128"
block|,
name|IX86_BUILTIN_POR128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_xorv2di3
block|,
literal|"__builtin_ia32_pxor128"
block|,
name|IX86_BUILTIN_PXOR128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_uavgv16qi3
block|,
literal|"__builtin_ia32_pavgb128"
block|,
name|IX86_BUILTIN_PAVGB128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_uavgv8hi3
block|,
literal|"__builtin_ia32_pavgw128"
block|,
name|IX86_BUILTIN_PAVGW128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_eqv16qi3
block|,
literal|"__builtin_ia32_pcmpeqb128"
block|,
name|IX86_BUILTIN_PCMPEQB128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_eqv8hi3
block|,
literal|"__builtin_ia32_pcmpeqw128"
block|,
name|IX86_BUILTIN_PCMPEQW128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_eqv4si3
block|,
literal|"__builtin_ia32_pcmpeqd128"
block|,
name|IX86_BUILTIN_PCMPEQD128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_gtv16qi3
block|,
literal|"__builtin_ia32_pcmpgtb128"
block|,
name|IX86_BUILTIN_PCMPGTB128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_gtv8hi3
block|,
literal|"__builtin_ia32_pcmpgtw128"
block|,
name|IX86_BUILTIN_PCMPGTW128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_gtv4si3
block|,
literal|"__builtin_ia32_pcmpgtd128"
block|,
name|IX86_BUILTIN_PCMPGTD128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_umaxv16qi3
block|,
literal|"__builtin_ia32_pmaxub128"
block|,
name|IX86_BUILTIN_PMAXUB128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_smaxv8hi3
block|,
literal|"__builtin_ia32_pmaxsw128"
block|,
name|IX86_BUILTIN_PMAXSW128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_uminv16qi3
block|,
literal|"__builtin_ia32_pminub128"
block|,
name|IX86_BUILTIN_PMINUB128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sminv8hi3
block|,
literal|"__builtin_ia32_pminsw128"
block|,
name|IX86_BUILTIN_PMINSW128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_punpckhbw
block|,
literal|"__builtin_ia32_punpckhbw128"
block|,
name|IX86_BUILTIN_PUNPCKHBW128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_punpckhwd
block|,
literal|"__builtin_ia32_punpckhwd128"
block|,
name|IX86_BUILTIN_PUNPCKHWD128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_punpckhdq
block|,
literal|"__builtin_ia32_punpckhdq128"
block|,
name|IX86_BUILTIN_PUNPCKHDQ128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_punpckhqdq
block|,
literal|"__builtin_ia32_punpckhqdq128"
block|,
name|IX86_BUILTIN_PUNPCKHQDQ128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_punpcklbw
block|,
literal|"__builtin_ia32_punpcklbw128"
block|,
name|IX86_BUILTIN_PUNPCKLBW128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_punpcklwd
block|,
literal|"__builtin_ia32_punpcklwd128"
block|,
name|IX86_BUILTIN_PUNPCKLWD128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_punpckldq
block|,
literal|"__builtin_ia32_punpckldq128"
block|,
name|IX86_BUILTIN_PUNPCKLDQ128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_punpcklqdq
block|,
literal|"__builtin_ia32_punpcklqdq128"
block|,
name|IX86_BUILTIN_PUNPCKLQDQ128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_packsswb
block|,
literal|"__builtin_ia32_packsswb128"
block|,
name|IX86_BUILTIN_PACKSSWB128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_packssdw
block|,
literal|"__builtin_ia32_packssdw128"
block|,
name|IX86_BUILTIN_PACKSSDW128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_packuswb
block|,
literal|"__builtin_ia32_packuswb128"
block|,
name|IX86_BUILTIN_PACKUSWB128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_umulv8hi3_highpart
block|,
literal|"__builtin_ia32_pmulhuw128"
block|,
name|IX86_BUILTIN_PMULHUW128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_psadbw
block|,
literal|0
block|,
name|IX86_BUILTIN_PSADBW128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_umulsidi3
block|,
literal|0
block|,
name|IX86_BUILTIN_PMULUDQ
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_umulv2siv2di3
block|,
literal|0
block|,
name|IX86_BUILTIN_PMULUDQ128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_ashlv8hi3
block|,
literal|0
block|,
name|IX86_BUILTIN_PSLLWI128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_ashlv4si3
block|,
literal|0
block|,
name|IX86_BUILTIN_PSLLDI128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_ashlv2di3
block|,
literal|0
block|,
name|IX86_BUILTIN_PSLLQI128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_lshrv8hi3
block|,
literal|0
block|,
name|IX86_BUILTIN_PSRLWI128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_lshrv4si3
block|,
literal|0
block|,
name|IX86_BUILTIN_PSRLDI128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_lshrv2di3
block|,
literal|0
block|,
name|IX86_BUILTIN_PSRLQI128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_ashrv8hi3
block|,
literal|0
block|,
name|IX86_BUILTIN_PSRAWI128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_ashrv4si3
block|,
literal|0
block|,
name|IX86_BUILTIN_PSRADI128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_pmaddwd
block|,
literal|0
block|,
name|IX86_BUILTIN_PMADDWD128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_cvtsi2sd
block|,
literal|0
block|,
name|IX86_BUILTIN_CVTSI2SD
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
operator||
name|MASK_64BIT
block|,
name|CODE_FOR_sse2_cvtsi2sdq
block|,
literal|0
block|,
name|IX86_BUILTIN_CVTSI642SD
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_cvtsd2ss
block|,
literal|0
block|,
name|IX86_BUILTIN_CVTSD2SS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_cvtss2sd
block|,
literal|0
block|,
name|IX86_BUILTIN_CVTSS2SD
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* SSE3 MMX */
block|{
name|MASK_SSE3
block|,
name|CODE_FOR_sse3_addsubv4sf3
block|,
literal|"__builtin_ia32_addsubps"
block|,
name|IX86_BUILTIN_ADDSUBPS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE3
block|,
name|CODE_FOR_sse3_addsubv2df3
block|,
literal|"__builtin_ia32_addsubpd"
block|,
name|IX86_BUILTIN_ADDSUBPD
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE3
block|,
name|CODE_FOR_sse3_haddv4sf3
block|,
literal|"__builtin_ia32_haddps"
block|,
name|IX86_BUILTIN_HADDPS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE3
block|,
name|CODE_FOR_sse3_haddv2df3
block|,
literal|"__builtin_ia32_haddpd"
block|,
name|IX86_BUILTIN_HADDPD
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE3
block|,
name|CODE_FOR_sse3_hsubv4sf3
block|,
literal|"__builtin_ia32_hsubps"
block|,
name|IX86_BUILTIN_HSUBPS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE3
block|,
name|CODE_FOR_sse3_hsubv2df3
block|,
literal|"__builtin_ia32_hsubpd"
block|,
name|IX86_BUILTIN_HSUBPD
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|builtin_description
name|bdesc_1arg
index|[]
init|=
block|{
block|{
name|MASK_SSE
operator||
name|MASK_3DNOW_A
block|,
name|CODE_FOR_mmx_pmovmskb
block|,
literal|0
block|,
name|IX86_BUILTIN_PMOVMSKB
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_movmskps
block|,
literal|0
block|,
name|IX86_BUILTIN_MOVMSKPS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sqrtv4sf2
block|,
literal|0
block|,
name|IX86_BUILTIN_SQRTPS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_rsqrtv4sf2
block|,
literal|0
block|,
name|IX86_BUILTIN_RSQRTPS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_rcpv4sf2
block|,
literal|0
block|,
name|IX86_BUILTIN_RCPPS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_cvtps2pi
block|,
literal|0
block|,
name|IX86_BUILTIN_CVTPS2PI
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_cvtss2si
block|,
literal|0
block|,
name|IX86_BUILTIN_CVTSS2SI
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
operator||
name|MASK_64BIT
block|,
name|CODE_FOR_sse_cvtss2siq
block|,
literal|0
block|,
name|IX86_BUILTIN_CVTSS2SI64
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_cvttps2pi
block|,
literal|0
block|,
name|IX86_BUILTIN_CVTTPS2PI
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_cvttss2si
block|,
literal|0
block|,
name|IX86_BUILTIN_CVTTSS2SI
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
operator||
name|MASK_64BIT
block|,
name|CODE_FOR_sse_cvttss2siq
block|,
literal|0
block|,
name|IX86_BUILTIN_CVTTSS2SI64
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_pmovmskb
block|,
literal|0
block|,
name|IX86_BUILTIN_PMOVMSKB128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_movmskpd
block|,
literal|0
block|,
name|IX86_BUILTIN_MOVMSKPD
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sqrtv2df2
block|,
literal|0
block|,
name|IX86_BUILTIN_SQRTPD
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_cvtdq2pd
block|,
literal|0
block|,
name|IX86_BUILTIN_CVTDQ2PD
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_cvtdq2ps
block|,
literal|0
block|,
name|IX86_BUILTIN_CVTDQ2PS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_cvtpd2dq
block|,
literal|0
block|,
name|IX86_BUILTIN_CVTPD2DQ
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_cvtpd2pi
block|,
literal|0
block|,
name|IX86_BUILTIN_CVTPD2PI
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_cvtpd2ps
block|,
literal|0
block|,
name|IX86_BUILTIN_CVTPD2PS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_cvttpd2dq
block|,
literal|0
block|,
name|IX86_BUILTIN_CVTTPD2DQ
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_cvttpd2pi
block|,
literal|0
block|,
name|IX86_BUILTIN_CVTTPD2PI
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_cvtpi2pd
block|,
literal|0
block|,
name|IX86_BUILTIN_CVTPI2PD
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_cvtsd2si
block|,
literal|0
block|,
name|IX86_BUILTIN_CVTSD2SI
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_cvttsd2si
block|,
literal|0
block|,
name|IX86_BUILTIN_CVTTSD2SI
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
operator||
name|MASK_64BIT
block|,
name|CODE_FOR_sse2_cvtsd2siq
block|,
literal|0
block|,
name|IX86_BUILTIN_CVTSD2SI64
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
operator||
name|MASK_64BIT
block|,
name|CODE_FOR_sse2_cvttsd2siq
block|,
literal|0
block|,
name|IX86_BUILTIN_CVTTSD2SI64
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_cvtps2dq
block|,
literal|0
block|,
name|IX86_BUILTIN_CVTPS2DQ
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_cvtps2pd
block|,
literal|0
block|,
name|IX86_BUILTIN_CVTPS2PD
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_cvttps2dq
block|,
literal|0
block|,
name|IX86_BUILTIN_CVTTPS2DQ
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* SSE3 */
block|{
name|MASK_SSE3
block|,
name|CODE_FOR_sse3_movshdup
block|,
literal|0
block|,
name|IX86_BUILTIN_MOVSHDUP
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE3
block|,
name|CODE_FOR_sse3_movsldup
block|,
literal|0
block|,
name|IX86_BUILTIN_MOVSLDUP
block|,
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|ix86_init_builtins
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|TARGET_MMX
condition|)
name|ix86_init_mmx_sse_builtins
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set up all the MMX/SSE builtins.  This is not called if TARGET_MMX    is zero.  Otherwise, if TARGET_SSE is not set, only expand the MMX    builtins.  */
end_comment

begin_function
specifier|static
name|void
name|ix86_init_mmx_sse_builtins
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|struct
name|builtin_description
modifier|*
name|d
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|tree
name|V16QI_type_node
init|=
name|build_vector_type_for_mode
argument_list|(
name|intQI_type_node
argument_list|,
name|V16QImode
argument_list|)
decl_stmt|;
name|tree
name|V2SI_type_node
init|=
name|build_vector_type_for_mode
argument_list|(
name|intSI_type_node
argument_list|,
name|V2SImode
argument_list|)
decl_stmt|;
name|tree
name|V2SF_type_node
init|=
name|build_vector_type_for_mode
argument_list|(
name|float_type_node
argument_list|,
name|V2SFmode
argument_list|)
decl_stmt|;
name|tree
name|V2DI_type_node
init|=
name|build_vector_type_for_mode
argument_list|(
name|long_long_integer_type_node
argument_list|,
name|V2DImode
argument_list|)
decl_stmt|;
name|tree
name|V2DF_type_node
init|=
name|build_vector_type_for_mode
argument_list|(
name|double_type_node
argument_list|,
name|V2DFmode
argument_list|)
decl_stmt|;
name|tree
name|V4SF_type_node
init|=
name|build_vector_type_for_mode
argument_list|(
name|float_type_node
argument_list|,
name|V4SFmode
argument_list|)
decl_stmt|;
name|tree
name|V4SI_type_node
init|=
name|build_vector_type_for_mode
argument_list|(
name|intSI_type_node
argument_list|,
name|V4SImode
argument_list|)
decl_stmt|;
name|tree
name|V4HI_type_node
init|=
name|build_vector_type_for_mode
argument_list|(
name|intHI_type_node
argument_list|,
name|V4HImode
argument_list|)
decl_stmt|;
name|tree
name|V8QI_type_node
init|=
name|build_vector_type_for_mode
argument_list|(
name|intQI_type_node
argument_list|,
name|V8QImode
argument_list|)
decl_stmt|;
name|tree
name|V8HI_type_node
init|=
name|build_vector_type_for_mode
argument_list|(
name|intHI_type_node
argument_list|,
name|V8HImode
argument_list|)
decl_stmt|;
name|tree
name|pchar_type_node
init|=
name|build_pointer_type
argument_list|(
name|char_type_node
argument_list|)
decl_stmt|;
name|tree
name|pcchar_type_node
init|=
name|build_pointer_type
argument_list|(
name|build_type_variant
argument_list|(
name|char_type_node
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|pfloat_type_node
init|=
name|build_pointer_type
argument_list|(
name|float_type_node
argument_list|)
decl_stmt|;
name|tree
name|pcfloat_type_node
init|=
name|build_pointer_type
argument_list|(
name|build_type_variant
argument_list|(
name|float_type_node
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|pv2si_type_node
init|=
name|build_pointer_type
argument_list|(
name|V2SI_type_node
argument_list|)
decl_stmt|;
name|tree
name|pv2di_type_node
init|=
name|build_pointer_type
argument_list|(
name|V2DI_type_node
argument_list|)
decl_stmt|;
name|tree
name|pdi_type_node
init|=
name|build_pointer_type
argument_list|(
name|long_long_unsigned_type_node
argument_list|)
decl_stmt|;
comment|/* Comparisons.  */
name|tree
name|int_ftype_v4sf_v4sf
init|=
name|build_function_type_list
argument_list|(
name|integer_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4si_ftype_v4sf_v4sf
init|=
name|build_function_type_list
argument_list|(
name|V4SI_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
comment|/* MMX/SSE/integer conversions.  */
name|tree
name|int_ftype_v4sf
init|=
name|build_function_type_list
argument_list|(
name|integer_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|int64_ftype_v4sf
init|=
name|build_function_type_list
argument_list|(
name|long_long_integer_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|int_ftype_v8qi
init|=
name|build_function_type_list
argument_list|(
name|integer_type_node
argument_list|,
name|V8QI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4sf_ftype_v4sf_int
init|=
name|build_function_type_list
argument_list|(
name|V4SF_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4sf_ftype_v4sf_int64
init|=
name|build_function_type_list
argument_list|(
name|V4SF_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|long_long_integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4sf_ftype_v4sf_v2si
init|=
name|build_function_type_list
argument_list|(
name|V4SF_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|V2SI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
comment|/* Miscellaneous.  */
name|tree
name|v8qi_ftype_v4hi_v4hi
init|=
name|build_function_type_list
argument_list|(
name|V8QI_type_node
argument_list|,
name|V4HI_type_node
argument_list|,
name|V4HI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4hi_ftype_v2si_v2si
init|=
name|build_function_type_list
argument_list|(
name|V4HI_type_node
argument_list|,
name|V2SI_type_node
argument_list|,
name|V2SI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4sf_ftype_v4sf_v4sf_int
init|=
name|build_function_type_list
argument_list|(
name|V4SF_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v2si_ftype_v4hi_v4hi
init|=
name|build_function_type_list
argument_list|(
name|V2SI_type_node
argument_list|,
name|V4HI_type_node
argument_list|,
name|V4HI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4hi_ftype_v4hi_int
init|=
name|build_function_type_list
argument_list|(
name|V4HI_type_node
argument_list|,
name|V4HI_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4hi_ftype_v4hi_di
init|=
name|build_function_type_list
argument_list|(
name|V4HI_type_node
argument_list|,
name|V4HI_type_node
argument_list|,
name|long_long_unsigned_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v2si_ftype_v2si_di
init|=
name|build_function_type_list
argument_list|(
name|V2SI_type_node
argument_list|,
name|V2SI_type_node
argument_list|,
name|long_long_unsigned_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|void_ftype_void
init|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|void_list_node
argument_list|)
decl_stmt|;
name|tree
name|void_ftype_unsigned
init|=
name|build_function_type_list
argument_list|(
name|void_type_node
argument_list|,
name|unsigned_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|void_ftype_unsigned_unsigned
init|=
name|build_function_type_list
argument_list|(
name|void_type_node
argument_list|,
name|unsigned_type_node
argument_list|,
name|unsigned_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|void_ftype_pcvoid_unsigned_unsigned
init|=
name|build_function_type_list
argument_list|(
name|void_type_node
argument_list|,
name|const_ptr_type_node
argument_list|,
name|unsigned_type_node
argument_list|,
name|unsigned_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|unsigned_ftype_void
init|=
name|build_function_type
argument_list|(
name|unsigned_type_node
argument_list|,
name|void_list_node
argument_list|)
decl_stmt|;
name|tree
name|v2si_ftype_v4sf
init|=
name|build_function_type_list
argument_list|(
name|V2SI_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
comment|/* Loads/stores.  */
name|tree
name|void_ftype_v8qi_v8qi_pchar
init|=
name|build_function_type_list
argument_list|(
name|void_type_node
argument_list|,
name|V8QI_type_node
argument_list|,
name|V8QI_type_node
argument_list|,
name|pchar_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4sf_ftype_pcfloat
init|=
name|build_function_type_list
argument_list|(
name|V4SF_type_node
argument_list|,
name|pcfloat_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
comment|/* @@@ the type is bogus */
name|tree
name|v4sf_ftype_v4sf_pv2si
init|=
name|build_function_type_list
argument_list|(
name|V4SF_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|pv2si_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|void_ftype_pv2si_v4sf
init|=
name|build_function_type_list
argument_list|(
name|void_type_node
argument_list|,
name|pv2si_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|void_ftype_pfloat_v4sf
init|=
name|build_function_type_list
argument_list|(
name|void_type_node
argument_list|,
name|pfloat_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|void_ftype_pdi_di
init|=
name|build_function_type_list
argument_list|(
name|void_type_node
argument_list|,
name|pdi_type_node
argument_list|,
name|long_long_unsigned_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|void_ftype_pv2di_v2di
init|=
name|build_function_type_list
argument_list|(
name|void_type_node
argument_list|,
name|pv2di_type_node
argument_list|,
name|V2DI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
comment|/* Normal vector unops.  */
name|tree
name|v4sf_ftype_v4sf
init|=
name|build_function_type_list
argument_list|(
name|V4SF_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
comment|/* Normal vector binops.  */
name|tree
name|v4sf_ftype_v4sf_v4sf
init|=
name|build_function_type_list
argument_list|(
name|V4SF_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v8qi_ftype_v8qi_v8qi
init|=
name|build_function_type_list
argument_list|(
name|V8QI_type_node
argument_list|,
name|V8QI_type_node
argument_list|,
name|V8QI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4hi_ftype_v4hi_v4hi
init|=
name|build_function_type_list
argument_list|(
name|V4HI_type_node
argument_list|,
name|V4HI_type_node
argument_list|,
name|V4HI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v2si_ftype_v2si_v2si
init|=
name|build_function_type_list
argument_list|(
name|V2SI_type_node
argument_list|,
name|V2SI_type_node
argument_list|,
name|V2SI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|di_ftype_di_di
init|=
name|build_function_type_list
argument_list|(
name|long_long_unsigned_type_node
argument_list|,
name|long_long_unsigned_type_node
argument_list|,
name|long_long_unsigned_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v2si_ftype_v2sf
init|=
name|build_function_type_list
argument_list|(
name|V2SI_type_node
argument_list|,
name|V2SF_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v2sf_ftype_v2si
init|=
name|build_function_type_list
argument_list|(
name|V2SF_type_node
argument_list|,
name|V2SI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v2si_ftype_v2si
init|=
name|build_function_type_list
argument_list|(
name|V2SI_type_node
argument_list|,
name|V2SI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v2sf_ftype_v2sf
init|=
name|build_function_type_list
argument_list|(
name|V2SF_type_node
argument_list|,
name|V2SF_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v2sf_ftype_v2sf_v2sf
init|=
name|build_function_type_list
argument_list|(
name|V2SF_type_node
argument_list|,
name|V2SF_type_node
argument_list|,
name|V2SF_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v2si_ftype_v2sf_v2sf
init|=
name|build_function_type_list
argument_list|(
name|V2SI_type_node
argument_list|,
name|V2SF_type_node
argument_list|,
name|V2SF_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|pint_type_node
init|=
name|build_pointer_type
argument_list|(
name|integer_type_node
argument_list|)
decl_stmt|;
name|tree
name|pdouble_type_node
init|=
name|build_pointer_type
argument_list|(
name|double_type_node
argument_list|)
decl_stmt|;
name|tree
name|pcdouble_type_node
init|=
name|build_pointer_type
argument_list|(
name|build_type_variant
argument_list|(
name|double_type_node
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|int_ftype_v2df_v2df
init|=
name|build_function_type_list
argument_list|(
name|integer_type_node
argument_list|,
name|V2DF_type_node
argument_list|,
name|V2DF_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|void_ftype_pcvoid
init|=
name|build_function_type_list
argument_list|(
name|void_type_node
argument_list|,
name|const_ptr_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4sf_ftype_v4si
init|=
name|build_function_type_list
argument_list|(
name|V4SF_type_node
argument_list|,
name|V4SI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4si_ftype_v4sf
init|=
name|build_function_type_list
argument_list|(
name|V4SI_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v2df_ftype_v4si
init|=
name|build_function_type_list
argument_list|(
name|V2DF_type_node
argument_list|,
name|V4SI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4si_ftype_v2df
init|=
name|build_function_type_list
argument_list|(
name|V4SI_type_node
argument_list|,
name|V2DF_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v2si_ftype_v2df
init|=
name|build_function_type_list
argument_list|(
name|V2SI_type_node
argument_list|,
name|V2DF_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4sf_ftype_v2df
init|=
name|build_function_type_list
argument_list|(
name|V4SF_type_node
argument_list|,
name|V2DF_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v2df_ftype_v2si
init|=
name|build_function_type_list
argument_list|(
name|V2DF_type_node
argument_list|,
name|V2SI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v2df_ftype_v4sf
init|=
name|build_function_type_list
argument_list|(
name|V2DF_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|int_ftype_v2df
init|=
name|build_function_type_list
argument_list|(
name|integer_type_node
argument_list|,
name|V2DF_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|int64_ftype_v2df
init|=
name|build_function_type_list
argument_list|(
name|long_long_integer_type_node
argument_list|,
name|V2DF_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v2df_ftype_v2df_int
init|=
name|build_function_type_list
argument_list|(
name|V2DF_type_node
argument_list|,
name|V2DF_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v2df_ftype_v2df_int64
init|=
name|build_function_type_list
argument_list|(
name|V2DF_type_node
argument_list|,
name|V2DF_type_node
argument_list|,
name|long_long_integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4sf_ftype_v4sf_v2df
init|=
name|build_function_type_list
argument_list|(
name|V4SF_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|V2DF_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v2df_ftype_v2df_v4sf
init|=
name|build_function_type_list
argument_list|(
name|V2DF_type_node
argument_list|,
name|V2DF_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v2df_ftype_v2df_v2df_int
init|=
name|build_function_type_list
argument_list|(
name|V2DF_type_node
argument_list|,
name|V2DF_type_node
argument_list|,
name|V2DF_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v2df_ftype_v2df_pcdouble
init|=
name|build_function_type_list
argument_list|(
name|V2DF_type_node
argument_list|,
name|V2DF_type_node
argument_list|,
name|pcdouble_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|void_ftype_pdouble_v2df
init|=
name|build_function_type_list
argument_list|(
name|void_type_node
argument_list|,
name|pdouble_type_node
argument_list|,
name|V2DF_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|void_ftype_pint_int
init|=
name|build_function_type_list
argument_list|(
name|void_type_node
argument_list|,
name|pint_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|void_ftype_v16qi_v16qi_pchar
init|=
name|build_function_type_list
argument_list|(
name|void_type_node
argument_list|,
name|V16QI_type_node
argument_list|,
name|V16QI_type_node
argument_list|,
name|pchar_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v2df_ftype_pcdouble
init|=
name|build_function_type_list
argument_list|(
name|V2DF_type_node
argument_list|,
name|pcdouble_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v2df_ftype_v2df_v2df
init|=
name|build_function_type_list
argument_list|(
name|V2DF_type_node
argument_list|,
name|V2DF_type_node
argument_list|,
name|V2DF_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v16qi_ftype_v16qi_v16qi
init|=
name|build_function_type_list
argument_list|(
name|V16QI_type_node
argument_list|,
name|V16QI_type_node
argument_list|,
name|V16QI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v8hi_ftype_v8hi_v8hi
init|=
name|build_function_type_list
argument_list|(
name|V8HI_type_node
argument_list|,
name|V8HI_type_node
argument_list|,
name|V8HI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4si_ftype_v4si_v4si
init|=
name|build_function_type_list
argument_list|(
name|V4SI_type_node
argument_list|,
name|V4SI_type_node
argument_list|,
name|V4SI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v2di_ftype_v2di_v2di
init|=
name|build_function_type_list
argument_list|(
name|V2DI_type_node
argument_list|,
name|V2DI_type_node
argument_list|,
name|V2DI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v2di_ftype_v2df_v2df
init|=
name|build_function_type_list
argument_list|(
name|V2DI_type_node
argument_list|,
name|V2DF_type_node
argument_list|,
name|V2DF_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v2df_ftype_v2df
init|=
name|build_function_type_list
argument_list|(
name|V2DF_type_node
argument_list|,
name|V2DF_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v2di_ftype_v2di_int
init|=
name|build_function_type_list
argument_list|(
name|V2DI_type_node
argument_list|,
name|V2DI_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4si_ftype_v4si_int
init|=
name|build_function_type_list
argument_list|(
name|V4SI_type_node
argument_list|,
name|V4SI_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v8hi_ftype_v8hi_int
init|=
name|build_function_type_list
argument_list|(
name|V8HI_type_node
argument_list|,
name|V8HI_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4si_ftype_v8hi_v8hi
init|=
name|build_function_type_list
argument_list|(
name|V4SI_type_node
argument_list|,
name|V8HI_type_node
argument_list|,
name|V8HI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|di_ftype_v8qi_v8qi
init|=
name|build_function_type_list
argument_list|(
name|long_long_unsigned_type_node
argument_list|,
name|V8QI_type_node
argument_list|,
name|V8QI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|di_ftype_v2si_v2si
init|=
name|build_function_type_list
argument_list|(
name|long_long_unsigned_type_node
argument_list|,
name|V2SI_type_node
argument_list|,
name|V2SI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v2di_ftype_v16qi_v16qi
init|=
name|build_function_type_list
argument_list|(
name|V2DI_type_node
argument_list|,
name|V16QI_type_node
argument_list|,
name|V16QI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v2di_ftype_v4si_v4si
init|=
name|build_function_type_list
argument_list|(
name|V2DI_type_node
argument_list|,
name|V4SI_type_node
argument_list|,
name|V4SI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|int_ftype_v16qi
init|=
name|build_function_type_list
argument_list|(
name|integer_type_node
argument_list|,
name|V16QI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v16qi_ftype_pcchar
init|=
name|build_function_type_list
argument_list|(
name|V16QI_type_node
argument_list|,
name|pcchar_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|void_ftype_pchar_v16qi
init|=
name|build_function_type_list
argument_list|(
name|void_type_node
argument_list|,
name|pchar_type_node
argument_list|,
name|V16QI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|float80_type
decl_stmt|;
name|tree
name|float128_type
decl_stmt|;
name|tree
name|ftype
decl_stmt|;
comment|/* The __float80 type.  */
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|long_double_type_node
argument_list|)
operator|==
name|XFmode
condition|)
call|(
modifier|*
name|lang_hooks
operator|.
name|types
operator|.
name|register_builtin_type
call|)
argument_list|(
name|long_double_type_node
argument_list|,
literal|"__float80"
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* The __float80 type.  */
name|float80_type
operator|=
name|make_node
argument_list|(
name|REAL_TYPE
argument_list|)
expr_stmt|;
name|TYPE_PRECISION
argument_list|(
name|float80_type
argument_list|)
operator|=
literal|80
expr_stmt|;
name|layout_type
argument_list|(
name|float80_type
argument_list|)
expr_stmt|;
call|(
modifier|*
name|lang_hooks
operator|.
name|types
operator|.
name|register_builtin_type
call|)
argument_list|(
name|float80_type
argument_list|,
literal|"__float80"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
name|float128_type
operator|=
name|make_node
argument_list|(
name|REAL_TYPE
argument_list|)
expr_stmt|;
name|TYPE_PRECISION
argument_list|(
name|float128_type
argument_list|)
operator|=
literal|128
expr_stmt|;
name|layout_type
argument_list|(
name|float128_type
argument_list|)
expr_stmt|;
call|(
modifier|*
name|lang_hooks
operator|.
name|types
operator|.
name|register_builtin_type
call|)
argument_list|(
name|float128_type
argument_list|,
literal|"__float128"
argument_list|)
expr_stmt|;
block|}
comment|/* Add all builtins that are more or less simple operations on two      operands.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|d
operator|=
name|bdesc_2arg
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|bdesc_2arg
argument_list|)
condition|;
name|i
operator|++
operator|,
name|d
operator|++
control|)
block|{
comment|/* Use one of the operands; the target can have a different mode for 	 mask-generating compares.  */
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|name
operator|==
literal|0
condition|)
continue|continue;
name|mode
operator|=
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|V16QImode
case|:
name|type
operator|=
name|v16qi_ftype_v16qi_v16qi
expr_stmt|;
break|break;
case|case
name|V8HImode
case|:
name|type
operator|=
name|v8hi_ftype_v8hi_v8hi
expr_stmt|;
break|break;
case|case
name|V4SImode
case|:
name|type
operator|=
name|v4si_ftype_v4si_v4si
expr_stmt|;
break|break;
case|case
name|V2DImode
case|:
name|type
operator|=
name|v2di_ftype_v2di_v2di
expr_stmt|;
break|break;
case|case
name|V2DFmode
case|:
name|type
operator|=
name|v2df_ftype_v2df_v2df
expr_stmt|;
break|break;
case|case
name|V4SFmode
case|:
name|type
operator|=
name|v4sf_ftype_v4sf_v4sf
expr_stmt|;
break|break;
case|case
name|V8QImode
case|:
name|type
operator|=
name|v8qi_ftype_v8qi_v8qi
expr_stmt|;
break|break;
case|case
name|V4HImode
case|:
name|type
operator|=
name|v4hi_ftype_v4hi_v4hi
expr_stmt|;
break|break;
case|case
name|V2SImode
case|:
name|type
operator|=
name|v2si_ftype_v2si_v2si
expr_stmt|;
break|break;
case|case
name|DImode
case|:
name|type
operator|=
name|di_ftype_di_di
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
comment|/* Override for comparisons.  */
if|if
condition|(
name|d
operator|->
name|icode
operator|==
name|CODE_FOR_sse_maskcmpv4sf3
operator|||
name|d
operator|->
name|icode
operator|==
name|CODE_FOR_sse_vmmaskcmpv4sf3
condition|)
name|type
operator|=
name|v4si_ftype_v4sf_v4sf
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|icode
operator|==
name|CODE_FOR_sse2_maskcmpv2df3
operator|||
name|d
operator|->
name|icode
operator|==
name|CODE_FOR_sse2_vmmaskcmpv2df3
condition|)
name|type
operator|=
name|v2di_ftype_v2df_v2df
expr_stmt|;
name|def_builtin
argument_list|(
name|d
operator|->
name|mask
argument_list|,
name|d
operator|->
name|name
argument_list|,
name|type
argument_list|,
name|d
operator|->
name|code
argument_list|)
expr_stmt|;
block|}
comment|/* Add the remaining MMX insns with somewhat more complicated types.  */
name|def_builtin
argument_list|(
name|MASK_MMX
argument_list|,
literal|"__builtin_ia32_emms"
argument_list|,
name|void_ftype_void
argument_list|,
name|IX86_BUILTIN_EMMS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_MMX
argument_list|,
literal|"__builtin_ia32_psllw"
argument_list|,
name|v4hi_ftype_v4hi_di
argument_list|,
name|IX86_BUILTIN_PSLLW
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_MMX
argument_list|,
literal|"__builtin_ia32_pslld"
argument_list|,
name|v2si_ftype_v2si_di
argument_list|,
name|IX86_BUILTIN_PSLLD
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_MMX
argument_list|,
literal|"__builtin_ia32_psllq"
argument_list|,
name|di_ftype_di_di
argument_list|,
name|IX86_BUILTIN_PSLLQ
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_MMX
argument_list|,
literal|"__builtin_ia32_psrlw"
argument_list|,
name|v4hi_ftype_v4hi_di
argument_list|,
name|IX86_BUILTIN_PSRLW
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_MMX
argument_list|,
literal|"__builtin_ia32_psrld"
argument_list|,
name|v2si_ftype_v2si_di
argument_list|,
name|IX86_BUILTIN_PSRLD
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_MMX
argument_list|,
literal|"__builtin_ia32_psrlq"
argument_list|,
name|di_ftype_di_di
argument_list|,
name|IX86_BUILTIN_PSRLQ
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_MMX
argument_list|,
literal|"__builtin_ia32_psraw"
argument_list|,
name|v4hi_ftype_v4hi_di
argument_list|,
name|IX86_BUILTIN_PSRAW
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_MMX
argument_list|,
literal|"__builtin_ia32_psrad"
argument_list|,
name|v2si_ftype_v2si_di
argument_list|,
name|IX86_BUILTIN_PSRAD
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
operator||
name|MASK_3DNOW_A
argument_list|,
literal|"__builtin_ia32_pshufw"
argument_list|,
name|v4hi_ftype_v4hi_int
argument_list|,
name|IX86_BUILTIN_PSHUFW
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_MMX
argument_list|,
literal|"__builtin_ia32_pmaddwd"
argument_list|,
name|v2si_ftype_v4hi_v4hi
argument_list|,
name|IX86_BUILTIN_PMADDWD
argument_list|)
expr_stmt|;
comment|/* comi/ucomi insns.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|d
operator|=
name|bdesc_comi
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|bdesc_comi
argument_list|)
condition|;
name|i
operator|++
operator|,
name|d
operator|++
control|)
if|if
condition|(
name|d
operator|->
name|mask
operator|==
name|MASK_SSE2
condition|)
name|def_builtin
argument_list|(
name|d
operator|->
name|mask
argument_list|,
name|d
operator|->
name|name
argument_list|,
name|int_ftype_v2df_v2df
argument_list|,
name|d
operator|->
name|code
argument_list|)
expr_stmt|;
else|else
name|def_builtin
argument_list|(
name|d
operator|->
name|mask
argument_list|,
name|d
operator|->
name|name
argument_list|,
name|int_ftype_v4sf_v4sf
argument_list|,
name|d
operator|->
name|code
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_MMX
argument_list|,
literal|"__builtin_ia32_packsswb"
argument_list|,
name|v8qi_ftype_v4hi_v4hi
argument_list|,
name|IX86_BUILTIN_PACKSSWB
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_MMX
argument_list|,
literal|"__builtin_ia32_packssdw"
argument_list|,
name|v4hi_ftype_v2si_v2si
argument_list|,
name|IX86_BUILTIN_PACKSSDW
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_MMX
argument_list|,
literal|"__builtin_ia32_packuswb"
argument_list|,
name|v8qi_ftype_v4hi_v4hi
argument_list|,
name|IX86_BUILTIN_PACKUSWB
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
argument_list|,
literal|"__builtin_ia32_ldmxcsr"
argument_list|,
name|void_ftype_unsigned
argument_list|,
name|IX86_BUILTIN_LDMXCSR
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
argument_list|,
literal|"__builtin_ia32_stmxcsr"
argument_list|,
name|unsigned_ftype_void
argument_list|,
name|IX86_BUILTIN_STMXCSR
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
argument_list|,
literal|"__builtin_ia32_cvtpi2ps"
argument_list|,
name|v4sf_ftype_v4sf_v2si
argument_list|,
name|IX86_BUILTIN_CVTPI2PS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
argument_list|,
literal|"__builtin_ia32_cvtps2pi"
argument_list|,
name|v2si_ftype_v4sf
argument_list|,
name|IX86_BUILTIN_CVTPS2PI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
argument_list|,
literal|"__builtin_ia32_cvtsi2ss"
argument_list|,
name|v4sf_ftype_v4sf_int
argument_list|,
name|IX86_BUILTIN_CVTSI2SS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
operator||
name|MASK_64BIT
argument_list|,
literal|"__builtin_ia32_cvtsi642ss"
argument_list|,
name|v4sf_ftype_v4sf_int64
argument_list|,
name|IX86_BUILTIN_CVTSI642SS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
argument_list|,
literal|"__builtin_ia32_cvtss2si"
argument_list|,
name|int_ftype_v4sf
argument_list|,
name|IX86_BUILTIN_CVTSS2SI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
operator||
name|MASK_64BIT
argument_list|,
literal|"__builtin_ia32_cvtss2si64"
argument_list|,
name|int64_ftype_v4sf
argument_list|,
name|IX86_BUILTIN_CVTSS2SI64
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
argument_list|,
literal|"__builtin_ia32_cvttps2pi"
argument_list|,
name|v2si_ftype_v4sf
argument_list|,
name|IX86_BUILTIN_CVTTPS2PI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
argument_list|,
literal|"__builtin_ia32_cvttss2si"
argument_list|,
name|int_ftype_v4sf
argument_list|,
name|IX86_BUILTIN_CVTTSS2SI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
operator||
name|MASK_64BIT
argument_list|,
literal|"__builtin_ia32_cvttss2si64"
argument_list|,
name|int64_ftype_v4sf
argument_list|,
name|IX86_BUILTIN_CVTTSS2SI64
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
operator||
name|MASK_3DNOW_A
argument_list|,
literal|"__builtin_ia32_maskmovq"
argument_list|,
name|void_ftype_v8qi_v8qi_pchar
argument_list|,
name|IX86_BUILTIN_MASKMOVQ
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
argument_list|,
literal|"__builtin_ia32_loadups"
argument_list|,
name|v4sf_ftype_pcfloat
argument_list|,
name|IX86_BUILTIN_LOADUPS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
argument_list|,
literal|"__builtin_ia32_storeups"
argument_list|,
name|void_ftype_pfloat_v4sf
argument_list|,
name|IX86_BUILTIN_STOREUPS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
argument_list|,
literal|"__builtin_ia32_loadhps"
argument_list|,
name|v4sf_ftype_v4sf_pv2si
argument_list|,
name|IX86_BUILTIN_LOADHPS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
argument_list|,
literal|"__builtin_ia32_loadlps"
argument_list|,
name|v4sf_ftype_v4sf_pv2si
argument_list|,
name|IX86_BUILTIN_LOADLPS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
argument_list|,
literal|"__builtin_ia32_storehps"
argument_list|,
name|void_ftype_pv2si_v4sf
argument_list|,
name|IX86_BUILTIN_STOREHPS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
argument_list|,
literal|"__builtin_ia32_storelps"
argument_list|,
name|void_ftype_pv2si_v4sf
argument_list|,
name|IX86_BUILTIN_STORELPS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
argument_list|,
literal|"__builtin_ia32_movmskps"
argument_list|,
name|int_ftype_v4sf
argument_list|,
name|IX86_BUILTIN_MOVMSKPS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
operator||
name|MASK_3DNOW_A
argument_list|,
literal|"__builtin_ia32_pmovmskb"
argument_list|,
name|int_ftype_v8qi
argument_list|,
name|IX86_BUILTIN_PMOVMSKB
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
argument_list|,
literal|"__builtin_ia32_movntps"
argument_list|,
name|void_ftype_pfloat_v4sf
argument_list|,
name|IX86_BUILTIN_MOVNTPS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
operator||
name|MASK_3DNOW_A
argument_list|,
literal|"__builtin_ia32_movntq"
argument_list|,
name|void_ftype_pdi_di
argument_list|,
name|IX86_BUILTIN_MOVNTQ
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
operator||
name|MASK_3DNOW_A
argument_list|,
literal|"__builtin_ia32_sfence"
argument_list|,
name|void_ftype_void
argument_list|,
name|IX86_BUILTIN_SFENCE
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
operator||
name|MASK_3DNOW_A
argument_list|,
literal|"__builtin_ia32_psadbw"
argument_list|,
name|di_ftype_v8qi_v8qi
argument_list|,
name|IX86_BUILTIN_PSADBW
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
argument_list|,
literal|"__builtin_ia32_rcpps"
argument_list|,
name|v4sf_ftype_v4sf
argument_list|,
name|IX86_BUILTIN_RCPPS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
argument_list|,
literal|"__builtin_ia32_rcpss"
argument_list|,
name|v4sf_ftype_v4sf
argument_list|,
name|IX86_BUILTIN_RCPSS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
argument_list|,
literal|"__builtin_ia32_rsqrtps"
argument_list|,
name|v4sf_ftype_v4sf
argument_list|,
name|IX86_BUILTIN_RSQRTPS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
argument_list|,
literal|"__builtin_ia32_rsqrtss"
argument_list|,
name|v4sf_ftype_v4sf
argument_list|,
name|IX86_BUILTIN_RSQRTSS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
argument_list|,
literal|"__builtin_ia32_sqrtps"
argument_list|,
name|v4sf_ftype_v4sf
argument_list|,
name|IX86_BUILTIN_SQRTPS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
argument_list|,
literal|"__builtin_ia32_sqrtss"
argument_list|,
name|v4sf_ftype_v4sf
argument_list|,
name|IX86_BUILTIN_SQRTSS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
argument_list|,
literal|"__builtin_ia32_shufps"
argument_list|,
name|v4sf_ftype_v4sf_v4sf_int
argument_list|,
name|IX86_BUILTIN_SHUFPS
argument_list|)
expr_stmt|;
comment|/* Original 3DNow!  */
name|def_builtin
argument_list|(
name|MASK_3DNOW
argument_list|,
literal|"__builtin_ia32_femms"
argument_list|,
name|void_ftype_void
argument_list|,
name|IX86_BUILTIN_FEMMS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_3DNOW
argument_list|,
literal|"__builtin_ia32_pavgusb"
argument_list|,
name|v8qi_ftype_v8qi_v8qi
argument_list|,
name|IX86_BUILTIN_PAVGUSB
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_3DNOW
argument_list|,
literal|"__builtin_ia32_pf2id"
argument_list|,
name|v2si_ftype_v2sf
argument_list|,
name|IX86_BUILTIN_PF2ID
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_3DNOW
argument_list|,
literal|"__builtin_ia32_pfacc"
argument_list|,
name|v2sf_ftype_v2sf_v2sf
argument_list|,
name|IX86_BUILTIN_PFACC
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_3DNOW
argument_list|,
literal|"__builtin_ia32_pfadd"
argument_list|,
name|v2sf_ftype_v2sf_v2sf
argument_list|,
name|IX86_BUILTIN_PFADD
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_3DNOW
argument_list|,
literal|"__builtin_ia32_pfcmpeq"
argument_list|,
name|v2si_ftype_v2sf_v2sf
argument_list|,
name|IX86_BUILTIN_PFCMPEQ
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_3DNOW
argument_list|,
literal|"__builtin_ia32_pfcmpge"
argument_list|,
name|v2si_ftype_v2sf_v2sf
argument_list|,
name|IX86_BUILTIN_PFCMPGE
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_3DNOW
argument_list|,
literal|"__builtin_ia32_pfcmpgt"
argument_list|,
name|v2si_ftype_v2sf_v2sf
argument_list|,
name|IX86_BUILTIN_PFCMPGT
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_3DNOW
argument_list|,
literal|"__builtin_ia32_pfmax"
argument_list|,
name|v2sf_ftype_v2sf_v2sf
argument_list|,
name|IX86_BUILTIN_PFMAX
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_3DNOW
argument_list|,
literal|"__builtin_ia32_pfmin"
argument_list|,
name|v2sf_ftype_v2sf_v2sf
argument_list|,
name|IX86_BUILTIN_PFMIN
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_3DNOW
argument_list|,
literal|"__builtin_ia32_pfmul"
argument_list|,
name|v2sf_ftype_v2sf_v2sf
argument_list|,
name|IX86_BUILTIN_PFMUL
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_3DNOW
argument_list|,
literal|"__builtin_ia32_pfrcp"
argument_list|,
name|v2sf_ftype_v2sf
argument_list|,
name|IX86_BUILTIN_PFRCP
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_3DNOW
argument_list|,
literal|"__builtin_ia32_pfrcpit1"
argument_list|,
name|v2sf_ftype_v2sf_v2sf
argument_list|,
name|IX86_BUILTIN_PFRCPIT1
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_3DNOW
argument_list|,
literal|"__builtin_ia32_pfrcpit2"
argument_list|,
name|v2sf_ftype_v2sf_v2sf
argument_list|,
name|IX86_BUILTIN_PFRCPIT2
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_3DNOW
argument_list|,
literal|"__builtin_ia32_pfrsqrt"
argument_list|,
name|v2sf_ftype_v2sf
argument_list|,
name|IX86_BUILTIN_PFRSQRT
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_3DNOW
argument_list|,
literal|"__builtin_ia32_pfrsqit1"
argument_list|,
name|v2sf_ftype_v2sf_v2sf
argument_list|,
name|IX86_BUILTIN_PFRSQIT1
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_3DNOW
argument_list|,
literal|"__builtin_ia32_pfsub"
argument_list|,
name|v2sf_ftype_v2sf_v2sf
argument_list|,
name|IX86_BUILTIN_PFSUB
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_3DNOW
argument_list|,
literal|"__builtin_ia32_pfsubr"
argument_list|,
name|v2sf_ftype_v2sf_v2sf
argument_list|,
name|IX86_BUILTIN_PFSUBR
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_3DNOW
argument_list|,
literal|"__builtin_ia32_pi2fd"
argument_list|,
name|v2sf_ftype_v2si
argument_list|,
name|IX86_BUILTIN_PI2FD
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_3DNOW
argument_list|,
literal|"__builtin_ia32_pmulhrw"
argument_list|,
name|v4hi_ftype_v4hi_v4hi
argument_list|,
name|IX86_BUILTIN_PMULHRW
argument_list|)
expr_stmt|;
comment|/* 3DNow! extension as used in the Athlon CPU.  */
name|def_builtin
argument_list|(
name|MASK_3DNOW_A
argument_list|,
literal|"__builtin_ia32_pf2iw"
argument_list|,
name|v2si_ftype_v2sf
argument_list|,
name|IX86_BUILTIN_PF2IW
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_3DNOW_A
argument_list|,
literal|"__builtin_ia32_pfnacc"
argument_list|,
name|v2sf_ftype_v2sf_v2sf
argument_list|,
name|IX86_BUILTIN_PFNACC
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_3DNOW_A
argument_list|,
literal|"__builtin_ia32_pfpnacc"
argument_list|,
name|v2sf_ftype_v2sf_v2sf
argument_list|,
name|IX86_BUILTIN_PFPNACC
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_3DNOW_A
argument_list|,
literal|"__builtin_ia32_pi2fw"
argument_list|,
name|v2sf_ftype_v2si
argument_list|,
name|IX86_BUILTIN_PI2FW
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_3DNOW_A
argument_list|,
literal|"__builtin_ia32_pswapdsf"
argument_list|,
name|v2sf_ftype_v2sf
argument_list|,
name|IX86_BUILTIN_PSWAPDSF
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_3DNOW_A
argument_list|,
literal|"__builtin_ia32_pswapdsi"
argument_list|,
name|v2si_ftype_v2si
argument_list|,
name|IX86_BUILTIN_PSWAPDSI
argument_list|)
expr_stmt|;
comment|/* SSE2 */
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_maskmovdqu"
argument_list|,
name|void_ftype_v16qi_v16qi_pchar
argument_list|,
name|IX86_BUILTIN_MASKMOVDQU
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_loadupd"
argument_list|,
name|v2df_ftype_pcdouble
argument_list|,
name|IX86_BUILTIN_LOADUPD
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_storeupd"
argument_list|,
name|void_ftype_pdouble_v2df
argument_list|,
name|IX86_BUILTIN_STOREUPD
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_loadhpd"
argument_list|,
name|v2df_ftype_v2df_pcdouble
argument_list|,
name|IX86_BUILTIN_LOADHPD
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_loadlpd"
argument_list|,
name|v2df_ftype_v2df_pcdouble
argument_list|,
name|IX86_BUILTIN_LOADLPD
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_movmskpd"
argument_list|,
name|int_ftype_v2df
argument_list|,
name|IX86_BUILTIN_MOVMSKPD
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_pmovmskb128"
argument_list|,
name|int_ftype_v16qi
argument_list|,
name|IX86_BUILTIN_PMOVMSKB128
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_movnti"
argument_list|,
name|void_ftype_pint_int
argument_list|,
name|IX86_BUILTIN_MOVNTI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_movntpd"
argument_list|,
name|void_ftype_pdouble_v2df
argument_list|,
name|IX86_BUILTIN_MOVNTPD
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_movntdq"
argument_list|,
name|void_ftype_pv2di_v2di
argument_list|,
name|IX86_BUILTIN_MOVNTDQ
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_pshufd"
argument_list|,
name|v4si_ftype_v4si_int
argument_list|,
name|IX86_BUILTIN_PSHUFD
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_pshuflw"
argument_list|,
name|v8hi_ftype_v8hi_int
argument_list|,
name|IX86_BUILTIN_PSHUFLW
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_pshufhw"
argument_list|,
name|v8hi_ftype_v8hi_int
argument_list|,
name|IX86_BUILTIN_PSHUFHW
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_psadbw128"
argument_list|,
name|v2di_ftype_v16qi_v16qi
argument_list|,
name|IX86_BUILTIN_PSADBW128
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_sqrtpd"
argument_list|,
name|v2df_ftype_v2df
argument_list|,
name|IX86_BUILTIN_SQRTPD
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_sqrtsd"
argument_list|,
name|v2df_ftype_v2df
argument_list|,
name|IX86_BUILTIN_SQRTSD
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_shufpd"
argument_list|,
name|v2df_ftype_v2df_v2df_int
argument_list|,
name|IX86_BUILTIN_SHUFPD
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_cvtdq2pd"
argument_list|,
name|v2df_ftype_v4si
argument_list|,
name|IX86_BUILTIN_CVTDQ2PD
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_cvtdq2ps"
argument_list|,
name|v4sf_ftype_v4si
argument_list|,
name|IX86_BUILTIN_CVTDQ2PS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_cvtpd2dq"
argument_list|,
name|v4si_ftype_v2df
argument_list|,
name|IX86_BUILTIN_CVTPD2DQ
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_cvtpd2pi"
argument_list|,
name|v2si_ftype_v2df
argument_list|,
name|IX86_BUILTIN_CVTPD2PI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_cvtpd2ps"
argument_list|,
name|v4sf_ftype_v2df
argument_list|,
name|IX86_BUILTIN_CVTPD2PS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_cvttpd2dq"
argument_list|,
name|v4si_ftype_v2df
argument_list|,
name|IX86_BUILTIN_CVTTPD2DQ
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_cvttpd2pi"
argument_list|,
name|v2si_ftype_v2df
argument_list|,
name|IX86_BUILTIN_CVTTPD2PI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_cvtpi2pd"
argument_list|,
name|v2df_ftype_v2si
argument_list|,
name|IX86_BUILTIN_CVTPI2PD
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_cvtsd2si"
argument_list|,
name|int_ftype_v2df
argument_list|,
name|IX86_BUILTIN_CVTSD2SI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_cvttsd2si"
argument_list|,
name|int_ftype_v2df
argument_list|,
name|IX86_BUILTIN_CVTTSD2SI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
operator||
name|MASK_64BIT
argument_list|,
literal|"__builtin_ia32_cvtsd2si64"
argument_list|,
name|int64_ftype_v2df
argument_list|,
name|IX86_BUILTIN_CVTSD2SI64
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
operator||
name|MASK_64BIT
argument_list|,
literal|"__builtin_ia32_cvttsd2si64"
argument_list|,
name|int64_ftype_v2df
argument_list|,
name|IX86_BUILTIN_CVTTSD2SI64
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_cvtps2dq"
argument_list|,
name|v4si_ftype_v4sf
argument_list|,
name|IX86_BUILTIN_CVTPS2DQ
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_cvtps2pd"
argument_list|,
name|v2df_ftype_v4sf
argument_list|,
name|IX86_BUILTIN_CVTPS2PD
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_cvttps2dq"
argument_list|,
name|v4si_ftype_v4sf
argument_list|,
name|IX86_BUILTIN_CVTTPS2DQ
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_cvtsi2sd"
argument_list|,
name|v2df_ftype_v2df_int
argument_list|,
name|IX86_BUILTIN_CVTSI2SD
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
operator||
name|MASK_64BIT
argument_list|,
literal|"__builtin_ia32_cvtsi642sd"
argument_list|,
name|v2df_ftype_v2df_int64
argument_list|,
name|IX86_BUILTIN_CVTSI642SD
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_cvtsd2ss"
argument_list|,
name|v4sf_ftype_v4sf_v2df
argument_list|,
name|IX86_BUILTIN_CVTSD2SS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_cvtss2sd"
argument_list|,
name|v2df_ftype_v2df_v4sf
argument_list|,
name|IX86_BUILTIN_CVTSS2SD
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_clflush"
argument_list|,
name|void_ftype_pcvoid
argument_list|,
name|IX86_BUILTIN_CLFLUSH
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_lfence"
argument_list|,
name|void_ftype_void
argument_list|,
name|IX86_BUILTIN_LFENCE
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_mfence"
argument_list|,
name|void_ftype_void
argument_list|,
name|IX86_BUILTIN_MFENCE
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_loaddqu"
argument_list|,
name|v16qi_ftype_pcchar
argument_list|,
name|IX86_BUILTIN_LOADDQU
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_storedqu"
argument_list|,
name|void_ftype_pchar_v16qi
argument_list|,
name|IX86_BUILTIN_STOREDQU
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_pmuludq"
argument_list|,
name|di_ftype_v2si_v2si
argument_list|,
name|IX86_BUILTIN_PMULUDQ
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_pmuludq128"
argument_list|,
name|v2di_ftype_v4si_v4si
argument_list|,
name|IX86_BUILTIN_PMULUDQ128
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_psllw128"
argument_list|,
name|v8hi_ftype_v8hi_v8hi
argument_list|,
name|IX86_BUILTIN_PSLLW128
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_pslld128"
argument_list|,
name|v4si_ftype_v4si_v4si
argument_list|,
name|IX86_BUILTIN_PSLLD128
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_psllq128"
argument_list|,
name|v2di_ftype_v2di_v2di
argument_list|,
name|IX86_BUILTIN_PSLLQ128
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_psrlw128"
argument_list|,
name|v8hi_ftype_v8hi_v8hi
argument_list|,
name|IX86_BUILTIN_PSRLW128
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_psrld128"
argument_list|,
name|v4si_ftype_v4si_v4si
argument_list|,
name|IX86_BUILTIN_PSRLD128
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_psrlq128"
argument_list|,
name|v2di_ftype_v2di_v2di
argument_list|,
name|IX86_BUILTIN_PSRLQ128
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_psraw128"
argument_list|,
name|v8hi_ftype_v8hi_v8hi
argument_list|,
name|IX86_BUILTIN_PSRAW128
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_psrad128"
argument_list|,
name|v4si_ftype_v4si_v4si
argument_list|,
name|IX86_BUILTIN_PSRAD128
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_pslldqi128"
argument_list|,
name|v2di_ftype_v2di_int
argument_list|,
name|IX86_BUILTIN_PSLLDQI128
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_psllwi128"
argument_list|,
name|v8hi_ftype_v8hi_int
argument_list|,
name|IX86_BUILTIN_PSLLWI128
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_pslldi128"
argument_list|,
name|v4si_ftype_v4si_int
argument_list|,
name|IX86_BUILTIN_PSLLDI128
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_psllqi128"
argument_list|,
name|v2di_ftype_v2di_int
argument_list|,
name|IX86_BUILTIN_PSLLQI128
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_psrldqi128"
argument_list|,
name|v2di_ftype_v2di_int
argument_list|,
name|IX86_BUILTIN_PSRLDQI128
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_psrlwi128"
argument_list|,
name|v8hi_ftype_v8hi_int
argument_list|,
name|IX86_BUILTIN_PSRLWI128
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_psrldi128"
argument_list|,
name|v4si_ftype_v4si_int
argument_list|,
name|IX86_BUILTIN_PSRLDI128
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_psrlqi128"
argument_list|,
name|v2di_ftype_v2di_int
argument_list|,
name|IX86_BUILTIN_PSRLQI128
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_psrawi128"
argument_list|,
name|v8hi_ftype_v8hi_int
argument_list|,
name|IX86_BUILTIN_PSRAWI128
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_psradi128"
argument_list|,
name|v4si_ftype_v4si_int
argument_list|,
name|IX86_BUILTIN_PSRADI128
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_pmaddwd128"
argument_list|,
name|v4si_ftype_v8hi_v8hi
argument_list|,
name|IX86_BUILTIN_PMADDWD128
argument_list|)
expr_stmt|;
comment|/* Prescott New Instructions.  */
name|def_builtin
argument_list|(
name|MASK_SSE3
argument_list|,
literal|"__builtin_ia32_monitor"
argument_list|,
name|void_ftype_pcvoid_unsigned_unsigned
argument_list|,
name|IX86_BUILTIN_MONITOR
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE3
argument_list|,
literal|"__builtin_ia32_mwait"
argument_list|,
name|void_ftype_unsigned_unsigned
argument_list|,
name|IX86_BUILTIN_MWAIT
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE3
argument_list|,
literal|"__builtin_ia32_movshdup"
argument_list|,
name|v4sf_ftype_v4sf
argument_list|,
name|IX86_BUILTIN_MOVSHDUP
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE3
argument_list|,
literal|"__builtin_ia32_movsldup"
argument_list|,
name|v4sf_ftype_v4sf
argument_list|,
name|IX86_BUILTIN_MOVSLDUP
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE3
argument_list|,
literal|"__builtin_ia32_lddqu"
argument_list|,
name|v16qi_ftype_pcchar
argument_list|,
name|IX86_BUILTIN_LDDQU
argument_list|)
expr_stmt|;
comment|/* Access to the vec_init patterns.  */
name|ftype
operator|=
name|build_function_type_list
argument_list|(
name|V2SI_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_MMX
argument_list|,
literal|"__builtin_ia32_vec_init_v2si"
argument_list|,
name|ftype
argument_list|,
name|IX86_BUILTIN_VEC_INIT_V2SI
argument_list|)
expr_stmt|;
name|ftype
operator|=
name|build_function_type_list
argument_list|(
name|V4HI_type_node
argument_list|,
name|short_integer_type_node
argument_list|,
name|short_integer_type_node
argument_list|,
name|short_integer_type_node
argument_list|,
name|short_integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_MMX
argument_list|,
literal|"__builtin_ia32_vec_init_v4hi"
argument_list|,
name|ftype
argument_list|,
name|IX86_BUILTIN_VEC_INIT_V4HI
argument_list|)
expr_stmt|;
name|ftype
operator|=
name|build_function_type_list
argument_list|(
name|V8QI_type_node
argument_list|,
name|char_type_node
argument_list|,
name|char_type_node
argument_list|,
name|char_type_node
argument_list|,
name|char_type_node
argument_list|,
name|char_type_node
argument_list|,
name|char_type_node
argument_list|,
name|char_type_node
argument_list|,
name|char_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_MMX
argument_list|,
literal|"__builtin_ia32_vec_init_v8qi"
argument_list|,
name|ftype
argument_list|,
name|IX86_BUILTIN_VEC_INIT_V8QI
argument_list|)
expr_stmt|;
comment|/* Access to the vec_extract patterns.  */
name|ftype
operator|=
name|build_function_type_list
argument_list|(
name|double_type_node
argument_list|,
name|V2DF_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_vec_ext_v2df"
argument_list|,
name|ftype
argument_list|,
name|IX86_BUILTIN_VEC_EXT_V2DF
argument_list|)
expr_stmt|;
name|ftype
operator|=
name|build_function_type_list
argument_list|(
name|long_long_integer_type_node
argument_list|,
name|V2DI_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_vec_ext_v2di"
argument_list|,
name|ftype
argument_list|,
name|IX86_BUILTIN_VEC_EXT_V2DI
argument_list|)
expr_stmt|;
name|ftype
operator|=
name|build_function_type_list
argument_list|(
name|float_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
argument_list|,
literal|"__builtin_ia32_vec_ext_v4sf"
argument_list|,
name|ftype
argument_list|,
name|IX86_BUILTIN_VEC_EXT_V4SF
argument_list|)
expr_stmt|;
name|ftype
operator|=
name|build_function_type_list
argument_list|(
name|intSI_type_node
argument_list|,
name|V4SI_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_vec_ext_v4si"
argument_list|,
name|ftype
argument_list|,
name|IX86_BUILTIN_VEC_EXT_V4SI
argument_list|)
expr_stmt|;
name|ftype
operator|=
name|build_function_type_list
argument_list|(
name|intHI_type_node
argument_list|,
name|V8HI_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_vec_ext_v8hi"
argument_list|,
name|ftype
argument_list|,
name|IX86_BUILTIN_VEC_EXT_V8HI
argument_list|)
expr_stmt|;
name|ftype
operator|=
name|build_function_type_list
argument_list|(
name|intHI_type_node
argument_list|,
name|V4HI_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
operator||
name|MASK_3DNOW_A
argument_list|,
literal|"__builtin_ia32_vec_ext_v4hi"
argument_list|,
name|ftype
argument_list|,
name|IX86_BUILTIN_VEC_EXT_V4HI
argument_list|)
expr_stmt|;
name|ftype
operator|=
name|build_function_type_list
argument_list|(
name|intSI_type_node
argument_list|,
name|V2SI_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_MMX
argument_list|,
literal|"__builtin_ia32_vec_ext_v2si"
argument_list|,
name|ftype
argument_list|,
name|IX86_BUILTIN_VEC_EXT_V2SI
argument_list|)
expr_stmt|;
name|ftype
operator|=
name|build_function_type_list
argument_list|(
name|intQI_type_node
argument_list|,
name|V16QI_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_vec_ext_v16qi"
argument_list|,
name|ftype
argument_list|,
name|IX86_BUILTIN_VEC_EXT_V16QI
argument_list|)
expr_stmt|;
comment|/* Access to the vec_set patterns.  */
name|ftype
operator|=
name|build_function_type_list
argument_list|(
name|V8HI_type_node
argument_list|,
name|V8HI_type_node
argument_list|,
name|intHI_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_vec_set_v8hi"
argument_list|,
name|ftype
argument_list|,
name|IX86_BUILTIN_VEC_SET_V8HI
argument_list|)
expr_stmt|;
name|ftype
operator|=
name|build_function_type_list
argument_list|(
name|V4HI_type_node
argument_list|,
name|V4HI_type_node
argument_list|,
name|intHI_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
operator||
name|MASK_3DNOW_A
argument_list|,
literal|"__builtin_ia32_vec_set_v4hi"
argument_list|,
name|ftype
argument_list|,
name|IX86_BUILTIN_VEC_SET_V4HI
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Errors in the source file can cause expand_expr to return const0_rtx    where we expect a vector.  To avoid crashing, use one of the vector    clear instructions.  */
end_comment

begin_function
specifier|static
name|rtx
name|safe_vector_operand
parameter_list|(
name|rtx
name|x
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|x
operator|==
name|const0_rtx
condition|)
name|x
operator|=
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of ix86_expand_builtin to take care of binop insns.  */
end_comment

begin_function
specifier|static
name|rtx
name|ix86_expand_binop_builtin
parameter_list|(
name|enum
name|insn_code
name|icode
parameter_list|,
name|tree
name|arglist
parameter_list|,
name|rtx
name|target
parameter_list|)
block|{
name|rtx
name|pat
decl_stmt|,
name|xops
index|[
literal|3
index|]
decl_stmt|;
name|tree
name|arg0
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|tree
name|arg1
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|op0
init|=
name|expand_normal
argument_list|(
name|arg0
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|expand_normal
argument_list|(
name|arg1
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|tmode
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|mode0
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|mode1
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
decl_stmt|;
if|if
condition|(
name|VECTOR_MODE_P
argument_list|(
name|mode0
argument_list|)
condition|)
name|op0
operator|=
name|safe_vector_operand
argument_list|(
name|op0
argument_list|,
name|mode0
argument_list|)
expr_stmt|;
if|if
condition|(
name|VECTOR_MODE_P
argument_list|(
name|mode1
argument_list|)
condition|)
name|op1
operator|=
name|safe_vector_operand
argument_list|(
name|op1
argument_list|,
name|mode1
argument_list|)
expr_stmt|;
if|if
condition|(
name|optimize
operator|||
operator|!
name|target
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|tmode
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|target
operator|,
name|tmode
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op1
argument_list|)
operator|==
name|SImode
operator|&&
name|mode1
operator|==
name|TImode
condition|)
block|{
name|rtx
name|x
init|=
name|gen_reg_rtx
argument_list|(
name|V4SImode
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_sse2_loadd
argument_list|(
name|x
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
name|op1
operator|=
name|gen_lowpart
argument_list|(
name|TImode
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
comment|/* The insn must want input operands in the same modes as the      result.  */
name|gcc_assert
argument_list|(
operator|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
name|mode0
operator|||
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
name|VOIDmode
operator|)
operator|&&
operator|(
name|GET_MODE
argument_list|(
name|op1
argument_list|)
operator|==
name|mode1
operator|||
name|GET_MODE
argument_list|(
name|op1
argument_list|)
operator|==
name|VOIDmode
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode0
operator|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
operator|)
operator|(
name|op1
operator|,
name|mode1
operator|)
condition|)
name|op1
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode1
argument_list|,
name|op1
argument_list|)
expr_stmt|;
comment|/* ??? Using ix86_fixup_binary_operands is problematic when      we've got mismatched modes.  Fake it.  */
name|xops
index|[
literal|0
index|]
operator|=
name|target
expr_stmt|;
name|xops
index|[
literal|1
index|]
operator|=
name|op0
expr_stmt|;
name|xops
index|[
literal|2
index|]
operator|=
name|op1
expr_stmt|;
if|if
condition|(
name|tmode
operator|==
name|mode0
operator|&&
name|tmode
operator|==
name|mode1
condition|)
block|{
name|target
operator|=
name|ix86_fixup_binary_operands
argument_list|(
name|UNKNOWN
argument_list|,
name|tmode
argument_list|,
name|xops
argument_list|)
expr_stmt|;
name|op0
operator|=
name|xops
index|[
literal|1
index|]
expr_stmt|;
name|op1
operator|=
name|xops
index|[
literal|2
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|optimize
operator|||
operator|!
name|ix86_binary_operator_ok
argument_list|(
name|UNKNOWN
argument_list|,
name|tmode
argument_list|,
name|xops
argument_list|)
condition|)
block|{
name|op0
operator|=
name|force_reg
argument_list|(
name|mode0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|force_reg
argument_list|(
name|mode1
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
block|}
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of ix86_expand_builtin to take care of stores.  */
end_comment

begin_function
specifier|static
name|rtx
name|ix86_expand_store_builtin
parameter_list|(
name|enum
name|insn_code
name|icode
parameter_list|,
name|tree
name|arglist
parameter_list|)
block|{
name|rtx
name|pat
decl_stmt|;
name|tree
name|arg0
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|tree
name|arg1
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|op0
init|=
name|expand_normal
argument_list|(
name|arg0
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|expand_normal
argument_list|(
name|arg1
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode0
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|mode1
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
decl_stmt|;
if|if
condition|(
name|VECTOR_MODE_P
argument_list|(
name|mode1
argument_list|)
condition|)
name|op1
operator|=
name|safe_vector_operand
argument_list|(
name|op1
argument_list|,
name|mode1
argument_list|)
expr_stmt|;
name|op0
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode0
argument_list|,
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|op0
argument_list|)
argument_list|)
expr_stmt|;
name|op1
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode1
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
condition|)
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of ix86_expand_builtin to take care of unop insns.  */
end_comment

begin_function
specifier|static
name|rtx
name|ix86_expand_unop_builtin
parameter_list|(
name|enum
name|insn_code
name|icode
parameter_list|,
name|tree
name|arglist
parameter_list|,
name|rtx
name|target
parameter_list|,
name|int
name|do_load
parameter_list|)
block|{
name|rtx
name|pat
decl_stmt|;
name|tree
name|arg0
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|rtx
name|op0
init|=
name|expand_normal
argument_list|(
name|arg0
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|tmode
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|mode0
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
decl_stmt|;
if|if
condition|(
name|optimize
operator|||
operator|!
name|target
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|tmode
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|target
operator|,
name|tmode
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_load
condition|)
name|op0
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode0
argument_list|,
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|op0
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|VECTOR_MODE_P
argument_list|(
name|mode0
argument_list|)
condition|)
name|op0
operator|=
name|safe_vector_operand
argument_list|(
name|op0
argument_list|,
name|mode0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|optimize
operator|&&
operator|!
name|register_operand
argument_list|(
name|op0
argument_list|,
name|mode0
argument_list|)
operator|)
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode0
operator|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
block|}
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of ix86_expand_builtin to take care of three special unop insns:    sqrtss, rsqrtss, rcpss.  */
end_comment

begin_function
specifier|static
name|rtx
name|ix86_expand_unop1_builtin
parameter_list|(
name|enum
name|insn_code
name|icode
parameter_list|,
name|tree
name|arglist
parameter_list|,
name|rtx
name|target
parameter_list|)
block|{
name|rtx
name|pat
decl_stmt|;
name|tree
name|arg0
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|rtx
name|op1
decl_stmt|,
name|op0
init|=
name|expand_normal
argument_list|(
name|arg0
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|tmode
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|mode0
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
decl_stmt|;
if|if
condition|(
name|optimize
operator|||
operator|!
name|target
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|tmode
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|target
operator|,
name|tmode
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|VECTOR_MODE_P
argument_list|(
name|mode0
argument_list|)
condition|)
name|op0
operator|=
name|safe_vector_operand
argument_list|(
name|op0
argument_list|,
name|mode0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|optimize
operator|&&
operator|!
name|register_operand
argument_list|(
name|op0
argument_list|,
name|mode0
argument_list|)
operator|)
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode0
operator|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|op0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
operator|)
operator|(
name|op1
operator|,
name|mode0
operator|)
condition|)
name|op1
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of ix86_expand_builtin to take care of comparison insns.  */
end_comment

begin_function
specifier|static
name|rtx
name|ix86_expand_sse_compare
parameter_list|(
specifier|const
name|struct
name|builtin_description
modifier|*
name|d
parameter_list|,
name|tree
name|arglist
parameter_list|,
name|rtx
name|target
parameter_list|)
block|{
name|rtx
name|pat
decl_stmt|;
name|tree
name|arg0
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|tree
name|arg1
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|op0
init|=
name|expand_normal
argument_list|(
name|arg0
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|expand_normal
argument_list|(
name|arg1
argument_list|)
decl_stmt|;
name|rtx
name|op2
decl_stmt|;
name|enum
name|machine_mode
name|tmode
init|=
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|mode0
init|=
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|mode1
init|=
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
decl_stmt|;
name|enum
name|rtx_code
name|comparison
init|=
name|d
operator|->
name|comparison
decl_stmt|;
if|if
condition|(
name|VECTOR_MODE_P
argument_list|(
name|mode0
argument_list|)
condition|)
name|op0
operator|=
name|safe_vector_operand
argument_list|(
name|op0
argument_list|,
name|mode0
argument_list|)
expr_stmt|;
if|if
condition|(
name|VECTOR_MODE_P
argument_list|(
name|mode1
argument_list|)
condition|)
name|op1
operator|=
name|safe_vector_operand
argument_list|(
name|op1
argument_list|,
name|mode1
argument_list|)
expr_stmt|;
comment|/* Swap operands if we have a comparison that isn't available in      hardware.  */
if|if
condition|(
name|d
operator|->
name|flag
operator|&
name|BUILTIN_DESC_SWAP_OPERANDS
condition|)
block|{
name|rtx
name|tmp
init|=
name|gen_reg_rtx
argument_list|(
name|mode1
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|tmp
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|op1
operator|=
name|op0
expr_stmt|;
name|op0
operator|=
name|tmp
expr_stmt|;
block|}
if|if
condition|(
name|optimize
operator|||
operator|!
name|target
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|tmode
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|target
operator|,
name|tmode
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|optimize
operator|&&
operator|!
name|register_operand
argument_list|(
name|op0
argument_list|,
name|mode0
argument_list|)
operator|)
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode0
operator|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|optimize
operator|&&
operator|!
name|register_operand
argument_list|(
name|op1
argument_list|,
name|mode1
argument_list|)
operator|)
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
operator|)
operator|(
name|op1
operator|,
name|mode1
operator|)
condition|)
name|op1
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode1
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|op2
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|comparison
argument_list|,
name|mode0
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|d
operator|->
name|icode
argument_list|)
argument_list|(
name|target
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of ix86_expand_builtin to take care of comi insns.  */
end_comment

begin_function
specifier|static
name|rtx
name|ix86_expand_sse_comi
parameter_list|(
specifier|const
name|struct
name|builtin_description
modifier|*
name|d
parameter_list|,
name|tree
name|arglist
parameter_list|,
name|rtx
name|target
parameter_list|)
block|{
name|rtx
name|pat
decl_stmt|;
name|tree
name|arg0
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|tree
name|arg1
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|op0
init|=
name|expand_normal
argument_list|(
name|arg0
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|expand_normal
argument_list|(
name|arg1
argument_list|)
decl_stmt|;
name|rtx
name|op2
decl_stmt|;
name|enum
name|machine_mode
name|mode0
init|=
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|mode1
init|=
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
decl_stmt|;
name|enum
name|rtx_code
name|comparison
init|=
name|d
operator|->
name|comparison
decl_stmt|;
if|if
condition|(
name|VECTOR_MODE_P
argument_list|(
name|mode0
argument_list|)
condition|)
name|op0
operator|=
name|safe_vector_operand
argument_list|(
name|op0
argument_list|,
name|mode0
argument_list|)
expr_stmt|;
if|if
condition|(
name|VECTOR_MODE_P
argument_list|(
name|mode1
argument_list|)
condition|)
name|op1
operator|=
name|safe_vector_operand
argument_list|(
name|op1
argument_list|,
name|mode1
argument_list|)
expr_stmt|;
comment|/* Swap operands if we have a comparison that isn't available in      hardware.  */
if|if
condition|(
name|d
operator|->
name|flag
operator|&
name|BUILTIN_DESC_SWAP_OPERANDS
condition|)
block|{
name|rtx
name|tmp
init|=
name|op1
decl_stmt|;
name|op1
operator|=
name|op0
expr_stmt|;
name|op0
operator|=
name|tmp
expr_stmt|;
block|}
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|target
operator|=
name|gen_rtx_SUBREG
argument_list|(
name|QImode
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|optimize
operator|&&
operator|!
name|register_operand
argument_list|(
name|op0
argument_list|,
name|mode0
argument_list|)
operator|)
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode0
operator|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|optimize
operator|&&
operator|!
name|register_operand
argument_list|(
name|op1
argument_list|,
name|mode1
argument_list|)
operator|)
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op1
operator|,
name|mode1
operator|)
condition|)
name|op1
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode1
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|op2
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|comparison
argument_list|,
name|mode0
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|d
operator|->
name|icode
argument_list|)
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_STRICT_LOW_PART
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|)
argument_list|,
name|gen_rtx_fmt_ee
argument_list|(
name|comparison
argument_list|,
name|QImode
argument_list|,
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SUBREG_REG
argument_list|(
name|target
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the integer constant in ARG.  Constrain it to be in the range    of the subparts of VEC_TYPE; issue an error if not.  */
end_comment

begin_function
specifier|static
name|int
name|get_element_number
parameter_list|(
name|tree
name|vec_type
parameter_list|,
name|tree
name|arg
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|elt
decl_stmt|,
name|max
init|=
name|TYPE_VECTOR_SUBPARTS
argument_list|(
name|vec_type
argument_list|)
operator|-
literal|1
decl_stmt|;
if|if
condition|(
operator|!
name|host_integerp
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
operator|||
operator|(
name|elt
operator|=
name|tree_low_cst
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
operator|,
name|elt
operator|>
name|max
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"selector must be an integer constant in the range 0..%wi"
argument_list|,
name|max
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|elt
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of ix86_expand_builtin.  These builtins are a wrapper around    ix86_expand_vector_init.  We DO have language-level syntax for this, in    the form of  (type){ init-list }.  Except that since we can't place emms    instructions from inside the compiler, we can't allow the use of MMX    registers unless the user explicitly asks for it.  So we do *not* define    vec_set/vec_extract/vec_init patterns for MMX modes in mmx.md.  Instead    we have builtins invoked by mmintrin.h that gives us license to emit    these sorts of instructions.  */
end_comment

begin_function
specifier|static
name|rtx
name|ix86_expand_vec_init_builtin
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|arglist
parameter_list|,
name|rtx
name|target
parameter_list|)
block|{
name|enum
name|machine_mode
name|tmode
init|=
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|inner_mode
init|=
name|GET_MODE_INNER
argument_list|(
name|tmode
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_elt
init|=
name|GET_MODE_NUNITS
argument_list|(
name|tmode
argument_list|)
decl_stmt|;
name|rtvec
name|v
init|=
name|rtvec_alloc
argument_list|(
name|n_elt
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|VECTOR_MODE_P
argument_list|(
name|tmode
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_elt
condition|;
operator|++
name|i
operator|,
name|arglist
operator|=
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
control|)
block|{
name|rtx
name|x
init|=
name|expand_normal
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
name|RTVEC_ELT
argument_list|(
name|v
argument_list|,
name|i
argument_list|)
operator|=
name|gen_lowpart
argument_list|(
name|inner_mode
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
name|arglist
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target
operator|||
operator|!
name|register_operand
argument_list|(
name|target
argument_list|,
name|tmode
argument_list|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
name|ix86_expand_vector_init
argument_list|(
name|true
argument_list|,
name|target
argument_list|,
name|gen_rtx_PARALLEL
argument_list|(
name|tmode
argument_list|,
name|v
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of ix86_expand_builtin.  These builtins are a wrapper around    ix86_expand_vector_extract.  They would be redundant (for non-MMX) if we    had a language-level syntax for referencing vector elements.  */
end_comment

begin_function
specifier|static
name|rtx
name|ix86_expand_vec_ext_builtin
parameter_list|(
name|tree
name|arglist
parameter_list|,
name|rtx
name|target
parameter_list|)
block|{
name|enum
name|machine_mode
name|tmode
decl_stmt|,
name|mode0
decl_stmt|;
name|tree
name|arg0
decl_stmt|,
name|arg1
decl_stmt|;
name|int
name|elt
decl_stmt|;
name|rtx
name|op0
decl_stmt|;
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_normal
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
name|elt
operator|=
name|get_element_number
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
name|tmode
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|mode0
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|VECTOR_MODE_P
argument_list|(
name|mode0
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|force_reg
argument_list|(
name|mode0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|optimize
operator|||
operator|!
name|target
operator|||
operator|!
name|register_operand
argument_list|(
name|target
argument_list|,
name|tmode
argument_list|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
name|ix86_expand_vector_extract
argument_list|(
name|true
argument_list|,
name|target
argument_list|,
name|op0
argument_list|,
name|elt
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of ix86_expand_builtin.  These builtins are a wrapper around    ix86_expand_vector_set.  They would be redundant (for non-MMX) if we had    a language-level syntax for referencing vector elements.  */
end_comment

begin_function
specifier|static
name|rtx
name|ix86_expand_vec_set_builtin
parameter_list|(
name|tree
name|arglist
parameter_list|)
block|{
name|enum
name|machine_mode
name|tmode
decl_stmt|,
name|mode1
decl_stmt|;
name|tree
name|arg0
decl_stmt|,
name|arg1
decl_stmt|,
name|arg2
decl_stmt|;
name|int
name|elt
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|,
name|target
decl_stmt|;
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|tmode
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
expr_stmt|;
name|mode1
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|VECTOR_MODE_P
argument_list|(
name|tmode
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|tmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_expr
argument_list|(
name|arg1
argument_list|,
name|NULL_RTX
argument_list|,
name|mode1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|elt
operator|=
name|get_element_number
argument_list|(
name|TREE_TYPE
argument_list|(
name|arg0
argument_list|)
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|mode1
operator|&&
name|GET_MODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|VOIDmode
condition|)
name|op1
operator|=
name|convert_modes
argument_list|(
name|mode1
argument_list|,
name|GET_MODE
argument_list|(
name|op1
argument_list|)
argument_list|,
name|op1
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|op0
operator|=
name|force_reg
argument_list|(
name|tmode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|force_reg
argument_list|(
name|mode1
argument_list|,
name|op1
argument_list|)
expr_stmt|;
comment|/* OP0 is the source of these builtin functions and shouldn't be      modified.  Create a copy, use it and return it as target.  */
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|ix86_expand_vector_set
argument_list|(
name|true
argument_list|,
name|target
argument_list|,
name|op1
argument_list|,
name|elt
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_comment
comment|/* Expand an expression EXP that calls a built-in function,    with result going to TARGET if that's convenient    (and in mode MODE if that's convenient).    SUBTARGET may be used as the target for computing one of EXP's operands.    IGNORE is nonzero if the value is to be ignored.  */
end_comment

begin_function
specifier|static
name|rtx
name|ix86_expand_builtin
parameter_list|(
name|tree
name|exp
parameter_list|,
name|rtx
name|target
parameter_list|,
name|rtx
name|subtarget
name|ATTRIBUTE_UNUSED
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
specifier|const
name|struct
name|builtin_description
modifier|*
name|d
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|enum
name|insn_code
name|icode
decl_stmt|;
name|tree
name|fndecl
init|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|arg0
decl_stmt|,
name|arg1
decl_stmt|,
name|arg2
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|,
name|op2
decl_stmt|,
name|pat
decl_stmt|;
name|enum
name|machine_mode
name|tmode
decl_stmt|,
name|mode0
decl_stmt|,
name|mode1
decl_stmt|,
name|mode2
decl_stmt|;
name|unsigned
name|int
name|fcode
init|=
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|fcode
condition|)
block|{
case|case
name|IX86_BUILTIN_EMMS
case|:
name|emit_insn
argument_list|(
name|gen_mmx_emms
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|IX86_BUILTIN_SFENCE
case|:
name|emit_insn
argument_list|(
name|gen_sse_sfence
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|IX86_BUILTIN_MASKMOVQ
case|:
case|case
name|IX86_BUILTIN_MASKMOVDQU
case|:
name|icode
operator|=
operator|(
name|fcode
operator|==
name|IX86_BUILTIN_MASKMOVQ
condition|?
name|CODE_FOR_mmx_maskmovq
else|:
name|CODE_FOR_sse2_maskmovdqu
operator|)
expr_stmt|;
comment|/* Note the arg order is different from the operand order.  */
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_normal
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_normal
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|op2
operator|=
name|expand_normal
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
name|mode0
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
expr_stmt|;
name|mode1
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
expr_stmt|;
name|mode2
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
expr_stmt|;
name|op0
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|op0
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode1
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode0
operator|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op1
operator|,
name|mode1
operator|)
condition|)
name|op1
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode1
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
operator|)
operator|(
name|op2
operator|,
name|mode2
operator|)
condition|)
name|op2
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode2
argument_list|,
name|op2
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|IX86_BUILTIN_SQRTSS
case|:
return|return
name|ix86_expand_unop1_builtin
argument_list|(
name|CODE_FOR_sse_vmsqrtv4sf2
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IX86_BUILTIN_RSQRTSS
case|:
return|return
name|ix86_expand_unop1_builtin
argument_list|(
name|CODE_FOR_sse_vmrsqrtv4sf2
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IX86_BUILTIN_RCPSS
case|:
return|return
name|ix86_expand_unop1_builtin
argument_list|(
name|CODE_FOR_sse_vmrcpv4sf2
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IX86_BUILTIN_LOADUPS
case|:
return|return
name|ix86_expand_unop_builtin
argument_list|(
name|CODE_FOR_sse_movups
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|,
literal|1
argument_list|)
return|;
case|case
name|IX86_BUILTIN_STOREUPS
case|:
return|return
name|ix86_expand_store_builtin
argument_list|(
name|CODE_FOR_sse_movups
argument_list|,
name|arglist
argument_list|)
return|;
case|case
name|IX86_BUILTIN_LOADHPS
case|:
case|case
name|IX86_BUILTIN_LOADLPS
case|:
case|case
name|IX86_BUILTIN_LOADHPD
case|:
case|case
name|IX86_BUILTIN_LOADLPD
case|:
name|icode
operator|=
operator|(
name|fcode
operator|==
name|IX86_BUILTIN_LOADHPS
condition|?
name|CODE_FOR_sse_loadhps
else|:
name|fcode
operator|==
name|IX86_BUILTIN_LOADLPS
condition|?
name|CODE_FOR_sse_loadlps
else|:
name|fcode
operator|==
name|IX86_BUILTIN_LOADHPD
condition|?
name|CODE_FOR_sse2_loadhpd
else|:
name|CODE_FOR_sse2_loadlpd
operator|)
expr_stmt|;
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_normal
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_normal
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|tmode
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
expr_stmt|;
name|mode0
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
expr_stmt|;
name|mode1
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
expr_stmt|;
name|op0
operator|=
name|force_reg
argument_list|(
name|mode0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode1
argument_list|,
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|optimize
operator|||
name|target
operator|==
literal|0
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|tmode
operator|||
operator|!
name|register_operand
argument_list|(
name|target
argument_list|,
name|tmode
argument_list|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|target
return|;
case|case
name|IX86_BUILTIN_STOREHPS
case|:
case|case
name|IX86_BUILTIN_STORELPS
case|:
name|icode
operator|=
operator|(
name|fcode
operator|==
name|IX86_BUILTIN_STOREHPS
condition|?
name|CODE_FOR_sse_storehps
else|:
name|CODE_FOR_sse_storelps
operator|)
expr_stmt|;
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_normal
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_normal
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|mode0
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
expr_stmt|;
name|mode1
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
expr_stmt|;
name|op0
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode0
argument_list|,
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|op0
argument_list|)
argument_list|)
expr_stmt|;
name|op1
operator|=
name|force_reg
argument_list|(
name|mode1
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
case|case
name|IX86_BUILTIN_MOVNTPS
case|:
return|return
name|ix86_expand_store_builtin
argument_list|(
name|CODE_FOR_sse_movntv4sf
argument_list|,
name|arglist
argument_list|)
return|;
case|case
name|IX86_BUILTIN_MOVNTQ
case|:
return|return
name|ix86_expand_store_builtin
argument_list|(
name|CODE_FOR_sse_movntdi
argument_list|,
name|arglist
argument_list|)
return|;
case|case
name|IX86_BUILTIN_LDMXCSR
case|:
name|op0
operator|=
name|expand_normal
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|target
operator|=
name|assign_386_stack_local
argument_list|(
name|SImode
argument_list|,
name|SLOT_VIRTUAL
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_sse_ldmxcsr
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|IX86_BUILTIN_STMXCSR
case|:
name|target
operator|=
name|assign_386_stack_local
argument_list|(
name|SImode
argument_list|,
name|SLOT_VIRTUAL
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_sse_stmxcsr
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|copy_to_mode_reg
argument_list|(
name|SImode
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IX86_BUILTIN_SHUFPS
case|:
case|case
name|IX86_BUILTIN_SHUFPD
case|:
name|icode
operator|=
operator|(
name|fcode
operator|==
name|IX86_BUILTIN_SHUFPS
condition|?
name|CODE_FOR_sse_shufps
else|:
name|CODE_FOR_sse2_shufpd
operator|)
expr_stmt|;
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_normal
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_normal
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|op2
operator|=
name|expand_normal
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
name|tmode
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
expr_stmt|;
name|mode0
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
expr_stmt|;
name|mode1
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
expr_stmt|;
name|mode2
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|3
index|]
operator|.
name|mode
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode0
operator|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|optimize
operator|&&
operator|!
name|register_operand
argument_list|(
name|op1
argument_list|,
name|mode1
argument_list|)
operator|)
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
operator|)
operator|(
name|op1
operator|,
name|mode1
operator|)
condition|)
name|op1
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode1
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|3
index|]
operator|.
name|predicate
operator|)
operator|(
name|op2
operator|,
name|mode2
operator|)
condition|)
block|{
comment|/* @@@ better error message */
name|error
argument_list|(
literal|"mask must be an immediate"
argument_list|)
expr_stmt|;
return|return
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
return|;
block|}
if|if
condition|(
name|optimize
operator|||
name|target
operator|==
literal|0
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|tmode
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|target
operator|,
name|tmode
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|target
return|;
case|case
name|IX86_BUILTIN_PSHUFW
case|:
case|case
name|IX86_BUILTIN_PSHUFD
case|:
case|case
name|IX86_BUILTIN_PSHUFHW
case|:
case|case
name|IX86_BUILTIN_PSHUFLW
case|:
name|icode
operator|=
operator|(
name|fcode
operator|==
name|IX86_BUILTIN_PSHUFHW
condition|?
name|CODE_FOR_sse2_pshufhw
else|:
name|fcode
operator|==
name|IX86_BUILTIN_PSHUFLW
condition|?
name|CODE_FOR_sse2_pshuflw
else|:
name|fcode
operator|==
name|IX86_BUILTIN_PSHUFD
condition|?
name|CODE_FOR_sse2_pshufd
else|:
name|CODE_FOR_mmx_pshufw
operator|)
expr_stmt|;
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_normal
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_normal
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|tmode
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
expr_stmt|;
name|mode1
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
expr_stmt|;
name|mode2
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode1
operator|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode1
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
operator|)
operator|(
name|op1
operator|,
name|mode2
operator|)
condition|)
block|{
comment|/* @@@ better error message */
name|error
argument_list|(
literal|"mask must be an immediate"
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|tmode
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|target
operator|,
name|tmode
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|target
return|;
case|case
name|IX86_BUILTIN_PSLLWI128
case|:
name|icode
operator|=
name|CODE_FOR_ashlv8hi3
expr_stmt|;
goto|goto
name|do_pshifti
goto|;
case|case
name|IX86_BUILTIN_PSLLDI128
case|:
name|icode
operator|=
name|CODE_FOR_ashlv4si3
expr_stmt|;
goto|goto
name|do_pshifti
goto|;
case|case
name|IX86_BUILTIN_PSLLQI128
case|:
name|icode
operator|=
name|CODE_FOR_ashlv2di3
expr_stmt|;
goto|goto
name|do_pshifti
goto|;
case|case
name|IX86_BUILTIN_PSRAWI128
case|:
name|icode
operator|=
name|CODE_FOR_ashrv8hi3
expr_stmt|;
goto|goto
name|do_pshifti
goto|;
case|case
name|IX86_BUILTIN_PSRADI128
case|:
name|icode
operator|=
name|CODE_FOR_ashrv4si3
expr_stmt|;
goto|goto
name|do_pshifti
goto|;
case|case
name|IX86_BUILTIN_PSRLWI128
case|:
name|icode
operator|=
name|CODE_FOR_lshrv8hi3
expr_stmt|;
goto|goto
name|do_pshifti
goto|;
case|case
name|IX86_BUILTIN_PSRLDI128
case|:
name|icode
operator|=
name|CODE_FOR_lshrv4si3
expr_stmt|;
goto|goto
name|do_pshifti
goto|;
case|case
name|IX86_BUILTIN_PSRLQI128
case|:
name|icode
operator|=
name|CODE_FOR_lshrv2di3
expr_stmt|;
goto|goto
name|do_pshifti
goto|;
name|do_pshifti
label|:
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_expr
argument_list|(
name|arg1
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|CONST_INT
condition|)
block|{
name|error
argument_list|(
literal|"shift must be an immediate"
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
if|if
condition|(
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|<
literal|0
operator|||
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|>
literal|255
condition|)
name|op1
operator|=
name|GEN_INT
argument_list|(
literal|255
argument_list|)
expr_stmt|;
name|tmode
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
expr_stmt|;
name|mode1
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode1
operator|)
condition|)
name|op0
operator|=
name|copy_to_reg
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|target
return|;
case|case
name|IX86_BUILTIN_PSLLW128
case|:
name|icode
operator|=
name|CODE_FOR_ashlv8hi3
expr_stmt|;
goto|goto
name|do_pshift
goto|;
case|case
name|IX86_BUILTIN_PSLLD128
case|:
name|icode
operator|=
name|CODE_FOR_ashlv4si3
expr_stmt|;
goto|goto
name|do_pshift
goto|;
case|case
name|IX86_BUILTIN_PSLLQ128
case|:
name|icode
operator|=
name|CODE_FOR_ashlv2di3
expr_stmt|;
goto|goto
name|do_pshift
goto|;
case|case
name|IX86_BUILTIN_PSRAW128
case|:
name|icode
operator|=
name|CODE_FOR_ashrv8hi3
expr_stmt|;
goto|goto
name|do_pshift
goto|;
case|case
name|IX86_BUILTIN_PSRAD128
case|:
name|icode
operator|=
name|CODE_FOR_ashrv4si3
expr_stmt|;
goto|goto
name|do_pshift
goto|;
case|case
name|IX86_BUILTIN_PSRLW128
case|:
name|icode
operator|=
name|CODE_FOR_lshrv8hi3
expr_stmt|;
goto|goto
name|do_pshift
goto|;
case|case
name|IX86_BUILTIN_PSRLD128
case|:
name|icode
operator|=
name|CODE_FOR_lshrv4si3
expr_stmt|;
goto|goto
name|do_pshift
goto|;
case|case
name|IX86_BUILTIN_PSRLQ128
case|:
name|icode
operator|=
name|CODE_FOR_lshrv2di3
expr_stmt|;
goto|goto
name|do_pshift
goto|;
name|do_pshift
label|:
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_expr
argument_list|(
name|arg1
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tmode
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
expr_stmt|;
name|mode1
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode1
operator|)
condition|)
name|op0
operator|=
name|copy_to_reg
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|simplify_gen_subreg
argument_list|(
name|TImode
argument_list|,
name|op1
argument_list|,
name|GET_MODE
argument_list|(
name|op1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
operator|)
operator|(
name|op1
operator|,
name|TImode
operator|)
condition|)
name|op1
operator|=
name|copy_to_reg
argument_list|(
name|op1
argument_list|)
expr_stmt|;
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|target
return|;
case|case
name|IX86_BUILTIN_PSLLDQI128
case|:
case|case
name|IX86_BUILTIN_PSRLDQI128
case|:
name|icode
operator|=
operator|(
name|fcode
operator|==
name|IX86_BUILTIN_PSLLDQI128
condition|?
name|CODE_FOR_sse2_ashlti3
else|:
name|CODE_FOR_sse2_lshrti3
operator|)
expr_stmt|;
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_normal
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_normal
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|tmode
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
expr_stmt|;
name|mode1
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
expr_stmt|;
name|mode2
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode1
operator|)
condition|)
block|{
name|op0
operator|=
name|copy_to_reg
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|op0
operator|=
name|simplify_gen_subreg
argument_list|(
name|mode1
argument_list|,
name|op0
argument_list|,
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
operator|)
operator|(
name|op1
operator|,
name|mode2
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"shift must be an immediate"
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|V2DImode
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|simplify_gen_subreg
argument_list|(
name|tmode
argument_list|,
name|target
argument_list|,
name|V2DImode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|target
return|;
case|case
name|IX86_BUILTIN_FEMMS
case|:
name|emit_insn
argument_list|(
name|gen_mmx_femms
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|NULL_RTX
return|;
case|case
name|IX86_BUILTIN_PAVGUSB
case|:
return|return
name|ix86_expand_binop_builtin
argument_list|(
name|CODE_FOR_mmx_uavgv8qi3
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IX86_BUILTIN_PF2ID
case|:
return|return
name|ix86_expand_unop_builtin
argument_list|(
name|CODE_FOR_mmx_pf2id
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|IX86_BUILTIN_PFACC
case|:
return|return
name|ix86_expand_binop_builtin
argument_list|(
name|CODE_FOR_mmx_haddv2sf3
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IX86_BUILTIN_PFADD
case|:
return|return
name|ix86_expand_binop_builtin
argument_list|(
name|CODE_FOR_mmx_addv2sf3
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IX86_BUILTIN_PFCMPEQ
case|:
return|return
name|ix86_expand_binop_builtin
argument_list|(
name|CODE_FOR_mmx_eqv2sf3
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IX86_BUILTIN_PFCMPGE
case|:
return|return
name|ix86_expand_binop_builtin
argument_list|(
name|CODE_FOR_mmx_gev2sf3
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IX86_BUILTIN_PFCMPGT
case|:
return|return
name|ix86_expand_binop_builtin
argument_list|(
name|CODE_FOR_mmx_gtv2sf3
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IX86_BUILTIN_PFMAX
case|:
return|return
name|ix86_expand_binop_builtin
argument_list|(
name|CODE_FOR_mmx_smaxv2sf3
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IX86_BUILTIN_PFMIN
case|:
return|return
name|ix86_expand_binop_builtin
argument_list|(
name|CODE_FOR_mmx_sminv2sf3
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IX86_BUILTIN_PFMUL
case|:
return|return
name|ix86_expand_binop_builtin
argument_list|(
name|CODE_FOR_mmx_mulv2sf3
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IX86_BUILTIN_PFRCP
case|:
return|return
name|ix86_expand_unop_builtin
argument_list|(
name|CODE_FOR_mmx_rcpv2sf2
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|IX86_BUILTIN_PFRCPIT1
case|:
return|return
name|ix86_expand_binop_builtin
argument_list|(
name|CODE_FOR_mmx_rcpit1v2sf3
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IX86_BUILTIN_PFRCPIT2
case|:
return|return
name|ix86_expand_binop_builtin
argument_list|(
name|CODE_FOR_mmx_rcpit2v2sf3
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IX86_BUILTIN_PFRSQIT1
case|:
return|return
name|ix86_expand_binop_builtin
argument_list|(
name|CODE_FOR_mmx_rsqit1v2sf3
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IX86_BUILTIN_PFRSQRT
case|:
return|return
name|ix86_expand_unop_builtin
argument_list|(
name|CODE_FOR_mmx_rsqrtv2sf2
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|IX86_BUILTIN_PFSUB
case|:
return|return
name|ix86_expand_binop_builtin
argument_list|(
name|CODE_FOR_mmx_subv2sf3
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IX86_BUILTIN_PFSUBR
case|:
return|return
name|ix86_expand_binop_builtin
argument_list|(
name|CODE_FOR_mmx_subrv2sf3
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IX86_BUILTIN_PI2FD
case|:
return|return
name|ix86_expand_unop_builtin
argument_list|(
name|CODE_FOR_mmx_floatv2si2
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|IX86_BUILTIN_PMULHRW
case|:
return|return
name|ix86_expand_binop_builtin
argument_list|(
name|CODE_FOR_mmx_pmulhrwv4hi3
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IX86_BUILTIN_PF2IW
case|:
return|return
name|ix86_expand_unop_builtin
argument_list|(
name|CODE_FOR_mmx_pf2iw
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|IX86_BUILTIN_PFNACC
case|:
return|return
name|ix86_expand_binop_builtin
argument_list|(
name|CODE_FOR_mmx_hsubv2sf3
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IX86_BUILTIN_PFPNACC
case|:
return|return
name|ix86_expand_binop_builtin
argument_list|(
name|CODE_FOR_mmx_addsubv2sf3
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IX86_BUILTIN_PI2FW
case|:
return|return
name|ix86_expand_unop_builtin
argument_list|(
name|CODE_FOR_mmx_pi2fw
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|IX86_BUILTIN_PSWAPDSI
case|:
return|return
name|ix86_expand_unop_builtin
argument_list|(
name|CODE_FOR_mmx_pswapdv2si2
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|IX86_BUILTIN_PSWAPDSF
case|:
return|return
name|ix86_expand_unop_builtin
argument_list|(
name|CODE_FOR_mmx_pswapdv2sf2
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|IX86_BUILTIN_SQRTSD
case|:
return|return
name|ix86_expand_unop1_builtin
argument_list|(
name|CODE_FOR_sse2_vmsqrtv2df2
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IX86_BUILTIN_LOADUPD
case|:
return|return
name|ix86_expand_unop_builtin
argument_list|(
name|CODE_FOR_sse2_movupd
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|,
literal|1
argument_list|)
return|;
case|case
name|IX86_BUILTIN_STOREUPD
case|:
return|return
name|ix86_expand_store_builtin
argument_list|(
name|CODE_FOR_sse2_movupd
argument_list|,
name|arglist
argument_list|)
return|;
case|case
name|IX86_BUILTIN_MFENCE
case|:
name|emit_insn
argument_list|(
name|gen_sse2_mfence
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|IX86_BUILTIN_LFENCE
case|:
name|emit_insn
argument_list|(
name|gen_sse2_lfence
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|IX86_BUILTIN_CLFLUSH
case|:
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_normal
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
name|icode
operator|=
name|CODE_FOR_sse2_clflush
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|Pmode
operator|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_sse2_clflush
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|IX86_BUILTIN_MOVNTPD
case|:
return|return
name|ix86_expand_store_builtin
argument_list|(
name|CODE_FOR_sse2_movntv2df
argument_list|,
name|arglist
argument_list|)
return|;
case|case
name|IX86_BUILTIN_MOVNTDQ
case|:
return|return
name|ix86_expand_store_builtin
argument_list|(
name|CODE_FOR_sse2_movntv2di
argument_list|,
name|arglist
argument_list|)
return|;
case|case
name|IX86_BUILTIN_MOVNTI
case|:
return|return
name|ix86_expand_store_builtin
argument_list|(
name|CODE_FOR_sse2_movntsi
argument_list|,
name|arglist
argument_list|)
return|;
case|case
name|IX86_BUILTIN_LOADDQU
case|:
return|return
name|ix86_expand_unop_builtin
argument_list|(
name|CODE_FOR_sse2_movdqu
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|,
literal|1
argument_list|)
return|;
case|case
name|IX86_BUILTIN_STOREDQU
case|:
return|return
name|ix86_expand_store_builtin
argument_list|(
name|CODE_FOR_sse2_movdqu
argument_list|,
name|arglist
argument_list|)
return|;
case|case
name|IX86_BUILTIN_MONITOR
case|:
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_normal
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_normal
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|op2
operator|=
name|expand_normal
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|op0
argument_list|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|op1
argument_list|)
condition|)
name|op1
operator|=
name|copy_to_mode_reg
argument_list|(
name|SImode
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|op2
argument_list|)
condition|)
name|op2
operator|=
name|copy_to_mode_reg
argument_list|(
name|SImode
argument_list|,
name|op2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TARGET_64BIT
condition|)
name|emit_insn
argument_list|(
name|gen_sse3_monitor
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_sse3_monitor64
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|IX86_BUILTIN_MWAIT
case|:
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_normal
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_normal
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|op0
argument_list|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|SImode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|op1
argument_list|)
condition|)
name|op1
operator|=
name|copy_to_mode_reg
argument_list|(
name|SImode
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_sse3_mwait
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|IX86_BUILTIN_LDDQU
case|:
return|return
name|ix86_expand_unop_builtin
argument_list|(
name|CODE_FOR_sse3_lddqu
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|,
literal|1
argument_list|)
return|;
case|case
name|IX86_BUILTIN_VEC_INIT_V2SI
case|:
case|case
name|IX86_BUILTIN_VEC_INIT_V4HI
case|:
case|case
name|IX86_BUILTIN_VEC_INIT_V8QI
case|:
return|return
name|ix86_expand_vec_init_builtin
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IX86_BUILTIN_VEC_EXT_V2DF
case|:
case|case
name|IX86_BUILTIN_VEC_EXT_V2DI
case|:
case|case
name|IX86_BUILTIN_VEC_EXT_V4SF
case|:
case|case
name|IX86_BUILTIN_VEC_EXT_V4SI
case|:
case|case
name|IX86_BUILTIN_VEC_EXT_V8HI
case|:
case|case
name|IX86_BUILTIN_VEC_EXT_V16QI
case|:
case|case
name|IX86_BUILTIN_VEC_EXT_V2SI
case|:
case|case
name|IX86_BUILTIN_VEC_EXT_V4HI
case|:
return|return
name|ix86_expand_vec_ext_builtin
argument_list|(
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IX86_BUILTIN_VEC_SET_V8HI
case|:
case|case
name|IX86_BUILTIN_VEC_SET_V4HI
case|:
return|return
name|ix86_expand_vec_set_builtin
argument_list|(
name|arglist
argument_list|)
return|;
default|default:
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|d
operator|=
name|bdesc_2arg
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|bdesc_2arg
argument_list|)
condition|;
name|i
operator|++
operator|,
name|d
operator|++
control|)
if|if
condition|(
name|d
operator|->
name|code
operator|==
name|fcode
condition|)
block|{
comment|/* Compares are treated specially.  */
if|if
condition|(
name|d
operator|->
name|icode
operator|==
name|CODE_FOR_sse_maskcmpv4sf3
operator|||
name|d
operator|->
name|icode
operator|==
name|CODE_FOR_sse_vmmaskcmpv4sf3
operator|||
name|d
operator|->
name|icode
operator|==
name|CODE_FOR_sse2_maskcmpv2df3
operator|||
name|d
operator|->
name|icode
operator|==
name|CODE_FOR_sse2_vmmaskcmpv2df3
condition|)
return|return
name|ix86_expand_sse_compare
argument_list|(
name|d
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
return|return
name|ix86_expand_binop_builtin
argument_list|(
name|d
operator|->
name|icode
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|d
operator|=
name|bdesc_1arg
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|bdesc_1arg
argument_list|)
condition|;
name|i
operator|++
operator|,
name|d
operator|++
control|)
if|if
condition|(
name|d
operator|->
name|code
operator|==
name|fcode
condition|)
return|return
name|ix86_expand_unop_builtin
argument_list|(
name|d
operator|->
name|icode
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
return|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|d
operator|=
name|bdesc_comi
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|bdesc_comi
argument_list|)
condition|;
name|i
operator|++
operator|,
name|d
operator|++
control|)
if|if
condition|(
name|d
operator|->
name|code
operator|==
name|fcode
condition|)
return|return
name|ix86_expand_sse_comi
argument_list|(
name|d
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Store OPERAND to the memory after reload is completed.  This means    that we can't easily use assign_stack_local.  */
end_comment

begin_function
name|rtx
name|ix86_force_to_memory
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|operand
parameter_list|)
block|{
name|rtx
name|result
decl_stmt|;
name|gcc_assert
argument_list|(
name|reload_completed
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_RED_ZONE
condition|)
block|{
name|result
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
operator|-
name|RED_ZONE_SIZE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|result
argument_list|,
name|operand
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|TARGET_RED_ZONE
operator|&&
name|TARGET_64BIT
condition|)
block|{
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|HImode
case|:
case|case
name|SImode
case|:
name|operand
operator|=
name|gen_lowpart
argument_list|(
name|DImode
argument_list|,
name|operand
argument_list|)
expr_stmt|;
comment|/* FALLTHRU */
case|case
name|DImode
case|:
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|DImode
argument_list|,
name|gen_rtx_PRE_DEC
argument_list|(
name|DImode
argument_list|,
name|stack_pointer_rtx
argument_list|)
argument_list|)
argument_list|,
name|operand
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|result
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode
argument_list|,
name|stack_pointer_rtx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|DImode
case|:
block|{
name|rtx
name|operands
index|[
literal|2
index|]
decl_stmt|;
name|split_di
argument_list|(
operator|&
name|operand
argument_list|,
literal|1
argument_list|,
name|operands
argument_list|,
name|operands
operator|+
literal|1
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|gen_rtx_PRE_DEC
argument_list|(
name|Pmode
argument_list|,
name|stack_pointer_rtx
argument_list|)
argument_list|)
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|gen_rtx_PRE_DEC
argument_list|(
name|Pmode
argument_list|,
name|stack_pointer_rtx
argument_list|)
argument_list|)
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|HImode
case|:
comment|/* Store HImodes as SImodes.  */
name|operand
operator|=
name|gen_lowpart
argument_list|(
name|SImode
argument_list|,
name|operand
argument_list|)
expr_stmt|;
comment|/* FALLTHRU */
case|case
name|SImode
case|:
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|GET_MODE
argument_list|(
name|operand
argument_list|)
argument_list|,
name|gen_rtx_PRE_DEC
argument_list|(
name|SImode
argument_list|,
name|stack_pointer_rtx
argument_list|)
argument_list|)
argument_list|,
name|operand
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|result
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode
argument_list|,
name|stack_pointer_rtx
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Free operand from the memory.  */
end_comment

begin_function
name|void
name|ix86_free_from_memory
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|TARGET_RED_ZONE
condition|)
block|{
name|int
name|size
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|DImode
operator|||
name|TARGET_64BIT
condition|)
name|size
operator|=
literal|8
expr_stmt|;
else|else
name|size
operator|=
literal|4
expr_stmt|;
comment|/* Use LEA to deallocate stack space.  In peephole2 it will be converted          to pop or add instruction if registers are available.  */
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|size
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Put float CONST_DOUBLE in the constant pool instead of fp regs.    QImode must go into class Q_REGS.    Narrow ALL_REGS to GENERAL_REGS.  This supports allowing movsf and    movdf to do mem-to-mem moves through integer regs.  */
end_comment

begin_function
name|enum
name|reg_class
name|ix86_preferred_reload_class
parameter_list|(
name|rtx
name|x
parameter_list|,
name|enum
name|reg_class
name|class
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
comment|/* We're only allowed to return a subclass of CLASS.  Many of the      following checks fail for NO_REGS, so eliminate that early.  */
if|if
condition|(
name|class
operator|==
name|NO_REGS
condition|)
return|return
name|NO_REGS
return|;
comment|/* All classes can load zeros.  */
if|if
condition|(
name|x
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|class
return|;
comment|/* Force constants into memory if we are loading a (nonzero) constant into      an MMX or SSE register.  This is because there are no MMX/SSE instructions      to load from a constant.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
operator|&&
operator|(
name|MAYBE_MMX_CLASS_P
argument_list|(
name|class
argument_list|)
operator|||
name|MAYBE_SSE_CLASS_P
argument_list|(
name|class
argument_list|)
operator|)
condition|)
return|return
name|NO_REGS
return|;
comment|/* Prefer SSE regs only, if we can use them for math.  */
if|if
condition|(
name|TARGET_SSE_MATH
operator|&&
operator|!
name|TARGET_MIX_SSE_I387
operator|&&
name|SSE_FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|SSE_CLASS_P
argument_list|(
name|class
argument_list|)
condition|?
name|class
else|:
name|NO_REGS
return|;
comment|/* Floating-point constants need more complex checks.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|VOIDmode
condition|)
block|{
comment|/* General regs can load everything.  */
if|if
condition|(
name|reg_class_subset_p
argument_list|(
name|class
argument_list|,
name|GENERAL_REGS
argument_list|)
condition|)
return|return
name|class
return|;
comment|/* Floats can load 0 and 1 plus some others.  Note that we eliminated 	 zero above.  We only want to wind up preferring 80387 registers if 	 we plan on doing computation with them.  */
if|if
condition|(
name|TARGET_80387
operator|&&
name|standard_80387_constant_p
argument_list|(
name|x
argument_list|)
condition|)
block|{
comment|/* Limit class to non-sse.  */
if|if
condition|(
name|class
operator|==
name|FLOAT_SSE_REGS
condition|)
return|return
name|FLOAT_REGS
return|;
if|if
condition|(
name|class
operator|==
name|FP_TOP_SSE_REGS
condition|)
return|return
name|FP_TOP_REG
return|;
if|if
condition|(
name|class
operator|==
name|FP_SECOND_SSE_REGS
condition|)
return|return
name|FP_SECOND_REG
return|;
if|if
condition|(
name|class
operator|==
name|FLOAT_INT_REGS
operator|||
name|class
operator|==
name|FLOAT_REGS
condition|)
return|return
name|class
return|;
block|}
return|return
name|NO_REGS
return|;
block|}
comment|/* Generally when we see PLUS here, it's the function invariant      (plus soft-fp const_int).  Which can only be computed into general      regs.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
condition|)
return|return
name|reg_class_subset_p
argument_list|(
name|class
argument_list|,
name|GENERAL_REGS
argument_list|)
condition|?
name|class
else|:
name|NO_REGS
return|;
comment|/* QImode constants are easy to load, but non-constant QImode data      must go into Q_REGS.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|QImode
operator|&&
operator|!
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
if|if
condition|(
name|reg_class_subset_p
argument_list|(
name|class
argument_list|,
name|Q_REGS
argument_list|)
condition|)
return|return
name|class
return|;
if|if
condition|(
name|reg_class_subset_p
argument_list|(
name|Q_REGS
argument_list|,
name|class
argument_list|)
condition|)
return|return
name|Q_REGS
return|;
return|return
name|NO_REGS
return|;
block|}
return|return
name|class
return|;
block|}
end_function

begin_comment
comment|/* Discourage putting floating-point values in SSE registers unless    SSE math is being used, and likewise for the 387 registers.  */
end_comment

begin_function
name|enum
name|reg_class
name|ix86_preferred_output_reload_class
parameter_list|(
name|rtx
name|x
parameter_list|,
name|enum
name|reg_class
name|class
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
comment|/* Restrict the output reload class to the register bank that we are doing      math on.  If we would like not to return a subset of CLASS, reject this      alternative: if reload cannot do this, it will still use its choice.  */
name|mode
operator|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_SSE_MATH
operator|&&
name|SSE_FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|MAYBE_SSE_CLASS_P
argument_list|(
name|class
argument_list|)
condition|?
name|SSE_REGS
else|:
name|NO_REGS
return|;
if|if
condition|(
name|TARGET_80387
operator|&&
name|SCALAR_FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|class
operator|==
name|FP_TOP_SSE_REGS
condition|)
return|return
name|FP_TOP_REG
return|;
elseif|else
if|if
condition|(
name|class
operator|==
name|FP_SECOND_SSE_REGS
condition|)
return|return
name|FP_SECOND_REG
return|;
else|else
return|return
name|FLOAT_CLASS_P
argument_list|(
name|class
argument_list|)
condition|?
name|class
else|:
name|NO_REGS
return|;
block|}
return|return
name|class
return|;
block|}
end_function

begin_comment
comment|/* If we are copying between general and FP registers, we need a memory    location. The same is true for SSE and MMX registers.     The macro can't work reliably when one of the CLASSES is class containing    registers from multiple units (SSE, MMX, integer).  We avoid this by never    combining those units in single alternative in the machine description.    Ensure that this constraint holds to avoid unexpected surprises.     When STRICT is false, we are being called from REGISTER_MOVE_COST, so do not    enforce these sanity checks.  */
end_comment

begin_function
name|int
name|ix86_secondary_memory_needed
parameter_list|(
name|enum
name|reg_class
name|class1
parameter_list|,
name|enum
name|reg_class
name|class2
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|int
name|strict
parameter_list|)
block|{
if|if
condition|(
name|MAYBE_FLOAT_CLASS_P
argument_list|(
name|class1
argument_list|)
operator|!=
name|FLOAT_CLASS_P
argument_list|(
name|class1
argument_list|)
operator|||
name|MAYBE_FLOAT_CLASS_P
argument_list|(
name|class2
argument_list|)
operator|!=
name|FLOAT_CLASS_P
argument_list|(
name|class2
argument_list|)
operator|||
name|MAYBE_SSE_CLASS_P
argument_list|(
name|class1
argument_list|)
operator|!=
name|SSE_CLASS_P
argument_list|(
name|class1
argument_list|)
operator|||
name|MAYBE_SSE_CLASS_P
argument_list|(
name|class2
argument_list|)
operator|!=
name|SSE_CLASS_P
argument_list|(
name|class2
argument_list|)
operator|||
name|MAYBE_MMX_CLASS_P
argument_list|(
name|class1
argument_list|)
operator|!=
name|MMX_CLASS_P
argument_list|(
name|class1
argument_list|)
operator|||
name|MAYBE_MMX_CLASS_P
argument_list|(
name|class2
argument_list|)
operator|!=
name|MMX_CLASS_P
argument_list|(
name|class2
argument_list|)
condition|)
block|{
name|gcc_assert
argument_list|(
operator|!
name|strict
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|FLOAT_CLASS_P
argument_list|(
name|class1
argument_list|)
operator|!=
name|FLOAT_CLASS_P
argument_list|(
name|class2
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* ??? This is a lie.  We do have moves between mmx/general, and for      mmx/sse2.  But by saying we need secondary memory we discourage the      register allocator from using the mmx registers unless needed.  */
if|if
condition|(
name|MMX_CLASS_P
argument_list|(
name|class1
argument_list|)
operator|!=
name|MMX_CLASS_P
argument_list|(
name|class2
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|SSE_CLASS_P
argument_list|(
name|class1
argument_list|)
operator|!=
name|SSE_CLASS_P
argument_list|(
name|class2
argument_list|)
condition|)
block|{
comment|/* SSE1 doesn't have any direct moves from other classes.  */
if|if
condition|(
operator|!
name|TARGET_SSE2
condition|)
return|return
name|true
return|;
comment|/* If the target says that inter-unit moves are more expensive 	 than moving through memory, then don't generate them.  */
if|if
condition|(
operator|!
name|TARGET_INTER_UNIT_MOVES
operator|&&
operator|!
name|optimize_size
condition|)
return|return
name|true
return|;
comment|/* Between SSE and general, we have moves no larger than word size.  */
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|>
name|UNITS_PER_WORD
condition|)
return|return
name|true
return|;
comment|/* ??? For the cost of one register reformat penalty, we could use 	 the same instructions to move SFmode and DFmode data, but the 	 relevant move patterns don't support those alternatives.  */
if|if
condition|(
name|mode
operator|==
name|SFmode
operator|||
name|mode
operator|==
name|DFmode
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Return true if the registers in CLASS cannot represent the change from    modes FROM to TO.  */
end_comment

begin_function
name|bool
name|ix86_cannot_change_mode_class
parameter_list|(
name|enum
name|machine_mode
name|from
parameter_list|,
name|enum
name|machine_mode
name|to
parameter_list|,
name|enum
name|reg_class
name|class
parameter_list|)
block|{
if|if
condition|(
name|from
operator|==
name|to
condition|)
return|return
name|false
return|;
comment|/* x87 registers can't do subreg at all, as all values are reformatted      to extended precision.  */
if|if
condition|(
name|MAYBE_FLOAT_CLASS_P
argument_list|(
name|class
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|MAYBE_SSE_CLASS_P
argument_list|(
name|class
argument_list|)
operator|||
name|MAYBE_MMX_CLASS_P
argument_list|(
name|class
argument_list|)
condition|)
block|{
comment|/* Vector registers do not support QI or HImode loads.  If we don't 	 disallow a change to these modes, reload will assume it's ok to 	 drop the subreg from (subreg:SI (reg:HI 100) 0).  This affects 	 the vec_dupv4hi pattern.  */
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|from
argument_list|)
operator|<
literal|4
condition|)
return|return
name|true
return|;
comment|/* Vector registers do not support subreg with nonzero offsets, which 	 are otherwise valid for integer registers.  Since we can't see 	 whether we have a nonzero offset from here, prohibit all          nonparadoxical subregs changing size.  */
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|to
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|from
argument_list|)
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Return the cost of moving data from a register in class CLASS1 to    one in class CLASS2.     It is not required that the cost always equal 2 when FROM is the same as TO;    on some machines it is expensive to move between registers if they are not    general registers.  */
end_comment

begin_function
name|int
name|ix86_register_move_cost
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|enum
name|reg_class
name|class1
parameter_list|,
name|enum
name|reg_class
name|class2
parameter_list|)
block|{
comment|/* In case we require secondary memory, compute cost of the store followed      by load.  In order to avoid bad register allocation choices, we need      for this to be *at least* as high as the symmetric MEMORY_MOVE_COST.  */
if|if
condition|(
name|ix86_secondary_memory_needed
argument_list|(
name|class1
argument_list|,
name|class2
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|int
name|cost
init|=
literal|1
decl_stmt|;
name|cost
operator|+=
name|MAX
argument_list|(
name|MEMORY_MOVE_COST
argument_list|(
name|mode
argument_list|,
name|class1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|MEMORY_MOVE_COST
argument_list|(
name|mode
argument_list|,
name|class1
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|cost
operator|+=
name|MAX
argument_list|(
name|MEMORY_MOVE_COST
argument_list|(
name|mode
argument_list|,
name|class2
argument_list|,
literal|0
argument_list|)
argument_list|,
name|MEMORY_MOVE_COST
argument_list|(
name|mode
argument_list|,
name|class2
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* In case of copying from general_purpose_register we may emit multiple          stores followed by single load causing memory size mismatch stall.          Count this as arbitrarily high cost of 20.  */
if|if
condition|(
name|CLASS_MAX_NREGS
argument_list|(
name|class1
argument_list|,
name|mode
argument_list|)
operator|>
name|CLASS_MAX_NREGS
argument_list|(
name|class2
argument_list|,
name|mode
argument_list|)
condition|)
name|cost
operator|+=
literal|20
expr_stmt|;
comment|/* In the case of FP/MMX moves, the registers actually overlap, and we 	 have to switch modes in order to treat them differently.  */
if|if
condition|(
operator|(
name|MMX_CLASS_P
argument_list|(
name|class1
argument_list|)
operator|&&
name|MAYBE_FLOAT_CLASS_P
argument_list|(
name|class2
argument_list|)
operator|)
operator|||
operator|(
name|MMX_CLASS_P
argument_list|(
name|class2
argument_list|)
operator|&&
name|MAYBE_FLOAT_CLASS_P
argument_list|(
name|class1
argument_list|)
operator|)
condition|)
name|cost
operator|+=
literal|20
expr_stmt|;
return|return
name|cost
return|;
block|}
comment|/* Moves between SSE/MMX and integer unit are expensive.  */
if|if
condition|(
name|MMX_CLASS_P
argument_list|(
name|class1
argument_list|)
operator|!=
name|MMX_CLASS_P
argument_list|(
name|class2
argument_list|)
operator|||
name|SSE_CLASS_P
argument_list|(
name|class1
argument_list|)
operator|!=
name|SSE_CLASS_P
argument_list|(
name|class2
argument_list|)
condition|)
return|return
name|ix86_cost
operator|->
name|mmxsse_to_integer
return|;
if|if
condition|(
name|MAYBE_FLOAT_CLASS_P
argument_list|(
name|class1
argument_list|)
condition|)
return|return
name|ix86_cost
operator|->
name|fp_move
return|;
if|if
condition|(
name|MAYBE_SSE_CLASS_P
argument_list|(
name|class1
argument_list|)
condition|)
return|return
name|ix86_cost
operator|->
name|sse_move
return|;
if|if
condition|(
name|MAYBE_MMX_CLASS_P
argument_list|(
name|class1
argument_list|)
condition|)
return|return
name|ix86_cost
operator|->
name|mmx_move
return|;
return|return
literal|2
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if hard register REGNO can hold a value of machine-mode MODE.  */
end_comment

begin_function
name|bool
name|ix86_hard_regno_mode_ok
parameter_list|(
name|int
name|regno
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
comment|/* Flags and only flags can only hold CCmode values.  */
if|if
condition|(
name|CC_REGNO_P
argument_list|(
name|regno
argument_list|)
condition|)
return|return
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_CC
return|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_CC
operator|||
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_RANDOM
operator|||
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_PARTIAL_INT
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|FP_REGNO_P
argument_list|(
name|regno
argument_list|)
condition|)
return|return
name|VALID_FP_MODE_P
argument_list|(
name|mode
argument_list|)
return|;
if|if
condition|(
name|SSE_REGNO_P
argument_list|(
name|regno
argument_list|)
condition|)
block|{
comment|/* We implement the move patterns for all vector modes into and 	 out of SSE registers, even when no operation instructions 	 are available.  */
return|return
operator|(
name|VALID_SSE_REG_MODE
argument_list|(
name|mode
argument_list|)
operator|||
name|VALID_SSE2_REG_MODE
argument_list|(
name|mode
argument_list|)
operator|||
name|VALID_MMX_REG_MODE
argument_list|(
name|mode
argument_list|)
operator|||
name|VALID_MMX_REG_MODE_3DNOW
argument_list|(
name|mode
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|MMX_REGNO_P
argument_list|(
name|regno
argument_list|)
condition|)
block|{
comment|/* We implement the move patterns for 3DNOW modes even in MMX mode, 	 so if the register is available at all, then we can move data of 	 the given mode into or out of it.  */
return|return
operator|(
name|VALID_MMX_REG_MODE
argument_list|(
name|mode
argument_list|)
operator|||
name|VALID_MMX_REG_MODE_3DNOW
argument_list|(
name|mode
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|mode
operator|==
name|QImode
condition|)
block|{
comment|/* Take care for QImode values - they can be in non-QI regs, 	 but then they do cause partial register stalls.  */
if|if
condition|(
name|regno
operator|<
literal|4
operator|||
name|TARGET_64BIT
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|TARGET_PARTIAL_REG_STALL
condition|)
return|return
literal|1
return|;
return|return
name|reload_in_progress
operator|||
name|reload_completed
return|;
block|}
comment|/* We handle both integer and floats in the general purpose registers.  */
elseif|else
if|if
condition|(
name|VALID_INT_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|VALID_FP_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Lots of MMX code casts 8 byte vector modes to DImode.  If we then go      on to use that value in smaller contexts, this can easily force a      pseudo to be allocated to GENERAL_REGS.  Since this is no worse than      supporting DImode, allow it.  */
elseif|else
if|if
condition|(
name|VALID_MMX_REG_MODE_3DNOW
argument_list|(
name|mode
argument_list|)
operator|||
name|VALID_MMX_REG_MODE
argument_list|(
name|mode
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of ix86_modes_tieable_p.  Return true if MODE is a    tieable integer mode.  */
end_comment

begin_function
specifier|static
name|bool
name|ix86_tieable_integer_mode_p
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|HImode
case|:
case|case
name|SImode
case|:
return|return
name|true
return|;
case|case
name|QImode
case|:
return|return
name|TARGET_64BIT
operator|||
operator|!
name|TARGET_PARTIAL_REG_STALL
return|;
case|case
name|DImode
case|:
return|return
name|TARGET_64BIT
return|;
default|default:
return|return
name|false
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return true if MODE1 is accessible in a register that can hold MODE2    without copying.  That is, all register classes that can hold MODE2    can also hold MODE1.  */
end_comment

begin_function
name|bool
name|ix86_modes_tieable_p
parameter_list|(
name|enum
name|machine_mode
name|mode1
parameter_list|,
name|enum
name|machine_mode
name|mode2
parameter_list|)
block|{
if|if
condition|(
name|mode1
operator|==
name|mode2
condition|)
return|return
name|true
return|;
if|if
condition|(
name|ix86_tieable_integer_mode_p
argument_list|(
name|mode1
argument_list|)
operator|&&
name|ix86_tieable_integer_mode_p
argument_list|(
name|mode2
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* MODE2 being XFmode implies fp stack or general regs, which means we      can tie any smaller floating point modes to it.  Note that we do not      tie this with TFmode.  */
if|if
condition|(
name|mode2
operator|==
name|XFmode
condition|)
return|return
name|mode1
operator|==
name|SFmode
operator|||
name|mode1
operator|==
name|DFmode
return|;
comment|/* MODE2 being DFmode implies fp stack, general or sse regs, which means      that we can tie it with SFmode.  */
if|if
condition|(
name|mode2
operator|==
name|DFmode
condition|)
return|return
name|mode1
operator|==
name|SFmode
return|;
comment|/* If MODE2 is only appropriate for an SSE register, then tie with      any other mode acceptable to SSE registers.  */
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|mode2
argument_list|)
operator|>=
literal|8
operator|&&
name|ix86_hard_regno_mode_ok
argument_list|(
name|FIRST_SSE_REG
argument_list|,
name|mode2
argument_list|)
condition|)
return|return
name|ix86_hard_regno_mode_ok
argument_list|(
name|FIRST_SSE_REG
argument_list|,
name|mode1
argument_list|)
return|;
comment|/* If MODE2 is appropriate for an MMX (or SSE) register, then tie      with any other mode acceptable to MMX registers.  */
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|mode2
argument_list|)
operator|==
literal|8
operator|&&
name|ix86_hard_regno_mode_ok
argument_list|(
name|FIRST_MMX_REG
argument_list|,
name|mode2
argument_list|)
condition|)
return|return
name|ix86_hard_regno_mode_ok
argument_list|(
name|FIRST_MMX_REG
argument_list|,
name|mode1
argument_list|)
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Return the cost of moving data of mode M between a    register and memory.  A value of 2 is the default; this cost is    relative to those in `REGISTER_MOVE_COST'.     If moving between registers and memory is more expensive than    between two registers, you should define this macro to express the    relative cost.     Model also increased moving costs of QImode registers in non    Q_REGS classes.  */
end_comment

begin_function
name|int
name|ix86_memory_move_cost
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|enum
name|reg_class
name|class
parameter_list|,
name|int
name|in
parameter_list|)
block|{
if|if
condition|(
name|FLOAT_CLASS_P
argument_list|(
name|class
argument_list|)
condition|)
block|{
name|int
name|index
decl_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|SFmode
case|:
name|index
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|DFmode
case|:
name|index
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|XFmode
case|:
name|index
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
return|return
literal|100
return|;
block|}
return|return
name|in
condition|?
name|ix86_cost
operator|->
name|fp_load
index|[
name|index
index|]
else|:
name|ix86_cost
operator|->
name|fp_store
index|[
name|index
index|]
return|;
block|}
if|if
condition|(
name|SSE_CLASS_P
argument_list|(
name|class
argument_list|)
condition|)
block|{
name|int
name|index
decl_stmt|;
switch|switch
condition|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
condition|)
block|{
case|case
literal|4
case|:
name|index
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|index
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|index
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
return|return
literal|100
return|;
block|}
return|return
name|in
condition|?
name|ix86_cost
operator|->
name|sse_load
index|[
name|index
index|]
else|:
name|ix86_cost
operator|->
name|sse_store
index|[
name|index
index|]
return|;
block|}
if|if
condition|(
name|MMX_CLASS_P
argument_list|(
name|class
argument_list|)
condition|)
block|{
name|int
name|index
decl_stmt|;
switch|switch
condition|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
condition|)
block|{
case|case
literal|4
case|:
name|index
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|index
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
return|return
literal|100
return|;
block|}
return|return
name|in
condition|?
name|ix86_cost
operator|->
name|mmx_load
index|[
name|index
index|]
else|:
name|ix86_cost
operator|->
name|mmx_store
index|[
name|index
index|]
return|;
block|}
switch|switch
condition|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
if|if
condition|(
name|in
condition|)
return|return
operator|(
name|Q_CLASS_P
argument_list|(
name|class
argument_list|)
condition|?
name|ix86_cost
operator|->
name|int_load
index|[
literal|0
index|]
else|:
name|ix86_cost
operator|->
name|movzbl_load
operator|)
return|;
else|else
return|return
operator|(
name|Q_CLASS_P
argument_list|(
name|class
argument_list|)
condition|?
name|ix86_cost
operator|->
name|int_store
index|[
literal|0
index|]
else|:
name|ix86_cost
operator|->
name|int_store
index|[
literal|0
index|]
operator|+
literal|4
operator|)
return|;
break|break;
case|case
literal|2
case|:
return|return
name|in
condition|?
name|ix86_cost
operator|->
name|int_load
index|[
literal|1
index|]
else|:
name|ix86_cost
operator|->
name|int_store
index|[
literal|1
index|]
return|;
default|default:
comment|/* Compute number of 32bit moves needed.  TFmode is moved as XFmode.  */
if|if
condition|(
name|mode
operator|==
name|TFmode
condition|)
name|mode
operator|=
name|XFmode
expr_stmt|;
return|return
operator|(
operator|(
name|in
condition|?
name|ix86_cost
operator|->
name|int_load
index|[
literal|2
index|]
else|:
name|ix86_cost
operator|->
name|int_store
index|[
literal|2
index|]
operator|)
operator|*
operator|(
operator|(
operator|(
name|int
operator|)
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Compute a (partial) cost for rtx X.  Return true if the complete    cost has been computed, and false if subexpressions should be    scanned.  In either case, *TOTAL contains the cost result.  */
end_comment

begin_function
specifier|static
name|bool
name|ix86_rtx_costs
parameter_list|(
name|rtx
name|x
parameter_list|,
name|int
name|code
parameter_list|,
name|int
name|outer_code
parameter_list|,
name|int
modifier|*
name|total
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONST_INT
case|:
case|case
name|CONST
case|:
case|case
name|LABEL_REF
case|:
case|case
name|SYMBOL_REF
case|:
if|if
condition|(
name|TARGET_64BIT
operator|&&
operator|!
name|x86_64_immediate_operand
argument_list|(
name|x
argument_list|,
name|VOIDmode
argument_list|)
condition|)
operator|*
name|total
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|TARGET_64BIT
operator|&&
operator|!
name|x86_64_zext_immediate_operand
argument_list|(
name|x
argument_list|,
name|VOIDmode
argument_list|)
condition|)
operator|*
name|total
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|flag_pic
operator|&&
name|SYMBOLIC_CONST
argument_list|(
name|x
argument_list|)
operator|&&
operator|(
operator|!
name|TARGET_64BIT
operator|||
operator|(
operator|!
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|LABEL_REF
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|SYMBOL_REF
operator|||
operator|!
name|SYMBOL_REF_LOCAL_P
argument_list|(
name|x
argument_list|)
operator|)
operator|)
operator|)
condition|)
operator|*
name|total
operator|=
literal|1
expr_stmt|;
else|else
operator|*
name|total
operator|=
literal|0
expr_stmt|;
return|return
name|true
return|;
case|case
name|CONST_DOUBLE
case|:
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
operator|*
name|total
operator|=
literal|0
expr_stmt|;
else|else
switch|switch
condition|(
name|standard_80387_constant_p
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
comment|/* 0.0 */
operator|*
name|total
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
comment|/* Other constants */
operator|*
name|total
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|0
case|:
case|case
operator|-
literal|1
case|:
comment|/* Start with (MEM (SYMBOL_REF)), since that's where 	       it'll probably end up.  Add a penalty for size.  */
operator|*
name|total
operator|=
operator|(
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
operator|+
operator|(
name|flag_pic
operator|!=
literal|0
operator|&&
operator|!
name|TARGET_64BIT
operator|)
operator|+
operator|(
name|mode
operator|==
name|SFmode
condition|?
literal|0
else|:
name|mode
operator|==
name|DFmode
condition|?
literal|1
else|:
literal|2
operator|)
operator|)
expr_stmt|;
break|break;
block|}
return|return
name|true
return|;
case|case
name|ZERO_EXTEND
case|:
comment|/* The zero extensions is often completely free on x86_64, so make 	 it as cheap as possible.  */
if|if
condition|(
name|TARGET_64BIT
operator|&&
name|mode
operator|==
name|DImode
operator|&&
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SImode
condition|)
operator|*
name|total
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|TARGET_ZERO_EXTEND_WITH_AND
condition|)
operator|*
name|total
operator|=
name|ix86_cost
operator|->
name|add
expr_stmt|;
else|else
operator|*
name|total
operator|=
name|ix86_cost
operator|->
name|movzx
expr_stmt|;
return|return
name|false
return|;
case|case
name|SIGN_EXTEND
case|:
operator|*
name|total
operator|=
name|ix86_cost
operator|->
name|movsx
expr_stmt|;
return|return
name|false
return|;
case|case
name|ASHIFT
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|DImode
operator|||
name|TARGET_64BIT
operator|)
condition|)
block|{
name|HOST_WIDE_INT
name|value
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|1
condition|)
block|{
operator|*
name|total
operator|=
name|ix86_cost
operator|->
name|add
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
operator|(
name|value
operator|==
literal|2
operator|||
name|value
operator|==
literal|3
operator|)
operator|&&
name|ix86_cost
operator|->
name|lea
operator|<=
name|ix86_cost
operator|->
name|shift_const
condition|)
block|{
operator|*
name|total
operator|=
name|ix86_cost
operator|->
name|lea
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
comment|/* FALLTHRU */
case|case
name|ROTATE
case|:
case|case
name|ASHIFTRT
case|:
case|case
name|LSHIFTRT
case|:
case|case
name|ROTATERT
case|:
if|if
condition|(
operator|!
name|TARGET_64BIT
operator|&&
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|DImode
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>
literal|32
condition|)
operator|*
name|total
operator|=
name|ix86_cost
operator|->
name|shift_const
operator|+
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
expr_stmt|;
else|else
operator|*
name|total
operator|=
name|ix86_cost
operator|->
name|shift_const
operator|*
literal|2
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|AND
condition|)
operator|*
name|total
operator|=
name|ix86_cost
operator|->
name|shift_var
operator|*
literal|2
expr_stmt|;
else|else
operator|*
name|total
operator|=
name|ix86_cost
operator|->
name|shift_var
operator|*
literal|6
operator|+
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
operator|*
name|total
operator|=
name|ix86_cost
operator|->
name|shift_const
expr_stmt|;
else|else
operator|*
name|total
operator|=
name|ix86_cost
operator|->
name|shift_var
expr_stmt|;
block|}
return|return
name|false
return|;
case|case
name|MULT
case|:
if|if
condition|(
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
block|{
operator|*
name|total
operator|=
name|ix86_cost
operator|->
name|fmul
expr_stmt|;
return|return
name|false
return|;
block|}
else|else
block|{
name|rtx
name|op0
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|int
name|nbits
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|value
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|nbits
operator|=
literal|0
init|;
name|value
operator|!=
literal|0
condition|;
name|value
operator|&=
name|value
operator|-
literal|1
control|)
name|nbits
operator|++
expr_stmt|;
block|}
else|else
comment|/* This is arbitrary.  */
name|nbits
operator|=
literal|7
expr_stmt|;
comment|/* Compute costs correctly for widening multiplication.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SIGN_EXTEND
operator|||
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|ZERO_EXTEND
operator|)
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|*
literal|2
operator|==
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|int
name|is_mulwiden
init|=
literal|0
decl_stmt|;
name|enum
name|machine_mode
name|inner_mode
init|=
name|GET_MODE
argument_list|(
name|op0
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|GET_CODE
argument_list|(
name|op1
argument_list|)
condition|)
name|is_mulwiden
operator|=
literal|1
operator|,
name|op1
operator|=
name|XEXP
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SIGN_EXTEND
condition|)
name|is_mulwiden
operator|=
name|trunc_int_for_mode
argument_list|(
name|INTVAL
argument_list|(
name|op1
argument_list|)
argument_list|,
name|inner_mode
argument_list|)
operator|==
name|INTVAL
argument_list|(
name|op1
argument_list|)
expr_stmt|;
else|else
name|is_mulwiden
operator|=
operator|!
operator|(
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|&
operator|~
name|GET_MODE_MASK
argument_list|(
name|inner_mode
argument_list|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|is_mulwiden
condition|)
name|op0
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
operator|,
name|mode
operator|=
name|GET_MODE
argument_list|(
name|op0
argument_list|)
expr_stmt|;
block|}
operator|*
name|total
operator|=
operator|(
name|ix86_cost
operator|->
name|mult_init
index|[
name|MODE_INDEX
argument_list|(
name|mode
argument_list|)
index|]
operator|+
name|nbits
operator|*
name|ix86_cost
operator|->
name|mult_bit
operator|+
name|rtx_cost
argument_list|(
name|op0
argument_list|,
name|outer_code
argument_list|)
operator|+
name|rtx_cost
argument_list|(
name|op1
argument_list|,
name|outer_code
argument_list|)
operator|)
expr_stmt|;
return|return
name|true
return|;
block|}
case|case
name|DIV
case|:
case|case
name|UDIV
case|:
case|case
name|MOD
case|:
case|case
name|UMOD
case|:
if|if
condition|(
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
operator|*
name|total
operator|=
name|ix86_cost
operator|->
name|fdiv
expr_stmt|;
else|else
operator|*
name|total
operator|=
name|ix86_cost
operator|->
name|divide
index|[
name|MODE_INDEX
argument_list|(
name|mode
argument_list|)
index|]
expr_stmt|;
return|return
name|false
return|;
case|case
name|PLUS
case|:
if|if
condition|(
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
operator|*
name|total
operator|=
name|ix86_cost
operator|->
name|fadd
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|GET_MODE_BITSIZE
argument_list|(
name|Pmode
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MULT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|HOST_WIDE_INT
name|val
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|==
literal|2
operator|||
name|val
operator|==
literal|4
operator|||
name|val
operator|==
literal|8
condition|)
block|{
operator|*
name|total
operator|=
name|ix86_cost
operator|->
name|lea
expr_stmt|;
operator|*
name|total
operator|+=
name|rtx_cost
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|outer_code
argument_list|)
expr_stmt|;
operator|*
name|total
operator|+=
name|rtx_cost
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|outer_code
argument_list|)
expr_stmt|;
operator|*
name|total
operator|+=
name|rtx_cost
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|outer_code
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MULT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|HOST_WIDE_INT
name|val
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|==
literal|2
operator|||
name|val
operator|==
literal|4
operator|||
name|val
operator|==
literal|8
condition|)
block|{
operator|*
name|total
operator|=
name|ix86_cost
operator|->
name|lea
expr_stmt|;
operator|*
name|total
operator|+=
name|rtx_cost
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|outer_code
argument_list|)
expr_stmt|;
operator|*
name|total
operator|+=
name|rtx_cost
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|outer_code
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|)
block|{
operator|*
name|total
operator|=
name|ix86_cost
operator|->
name|lea
expr_stmt|;
operator|*
name|total
operator|+=
name|rtx_cost
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|outer_code
argument_list|)
expr_stmt|;
operator|*
name|total
operator|+=
name|rtx_cost
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|outer_code
argument_list|)
expr_stmt|;
operator|*
name|total
operator|+=
name|rtx_cost
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|outer_code
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
comment|/* FALLTHRU */
case|case
name|MINUS
case|:
if|if
condition|(
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
block|{
operator|*
name|total
operator|=
name|ix86_cost
operator|->
name|fadd
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* FALLTHRU */
case|case
name|AND
case|:
case|case
name|IOR
case|:
case|case
name|XOR
case|:
if|if
condition|(
operator|!
name|TARGET_64BIT
operator|&&
name|mode
operator|==
name|DImode
condition|)
block|{
operator|*
name|total
operator|=
operator|(
name|ix86_cost
operator|->
name|add
operator|*
literal|2
operator|+
operator|(
name|rtx_cost
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|outer_code
argument_list|)
operator|<<
operator|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|DImode
operator|)
operator|)
operator|+
operator|(
name|rtx_cost
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|outer_code
argument_list|)
operator|<<
operator|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|DImode
operator|)
operator|)
operator|)
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* FALLTHRU */
case|case
name|NEG
case|:
if|if
condition|(
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
block|{
operator|*
name|total
operator|=
name|ix86_cost
operator|->
name|fchs
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* FALLTHRU */
case|case
name|NOT
case|:
if|if
condition|(
operator|!
name|TARGET_64BIT
operator|&&
name|mode
operator|==
name|DImode
condition|)
operator|*
name|total
operator|=
name|ix86_cost
operator|->
name|add
operator|*
literal|2
expr_stmt|;
else|else
operator|*
name|total
operator|=
name|ix86_cost
operator|->
name|add
expr_stmt|;
return|return
name|false
return|;
case|case
name|COMPARE
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|const1_rtx
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|==
name|const0_rtx
condition|)
block|{
comment|/* This kind of construct is implemented using test[bwl]. 	     Treat it as if we had an AND.  */
operator|*
name|total
operator|=
operator|(
name|ix86_cost
operator|->
name|add
operator|+
name|rtx_cost
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|outer_code
argument_list|)
operator|+
name|rtx_cost
argument_list|(
name|const1_rtx
argument_list|,
name|outer_code
argument_list|)
operator|)
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
case|case
name|FLOAT_EXTEND
case|:
if|if
condition|(
operator|!
name|TARGET_SSE_MATH
operator|||
name|mode
operator|==
name|XFmode
operator|||
operator|(
name|mode
operator|==
name|DFmode
operator|&&
operator|!
name|TARGET_SSE2
operator|)
condition|)
comment|/* For standard 80387 constants, raise the cost to prevent 	   compress_float_constant() to generate load from memory.  */
switch|switch
condition|(
name|standard_80387_constant_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
case|case
operator|-
literal|1
case|:
case|case
literal|0
case|:
operator|*
name|total
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* 0.0 */
operator|*
name|total
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
operator|*
name|total
operator|=
operator|(
name|x86_ext_80387_constants
operator|&
name|TUNEMASK
operator|||
name|optimize_size
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
block|}
return|return
name|false
return|;
case|case
name|ABS
case|:
if|if
condition|(
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
operator|*
name|total
operator|=
name|ix86_cost
operator|->
name|fabs
expr_stmt|;
return|return
name|false
return|;
case|case
name|SQRT
case|:
if|if
condition|(
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
operator|*
name|total
operator|=
name|ix86_cost
operator|->
name|fsqrt
expr_stmt|;
return|return
name|false
return|;
case|case
name|UNSPEC
case|:
if|if
condition|(
name|XINT
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPEC_TP
condition|)
operator|*
name|total
operator|=
literal|0
expr_stmt|;
return|return
name|false
return|;
default|default:
return|return
name|false
return|;
block|}
block|}
end_function

begin_if
if|#
directive|if
name|TARGET_MACHO
end_if

begin_decl_stmt
specifier|static
name|int
name|current_machopic_label_num
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Given a symbol name and its associated stub, write out the    definition of the stub.  */
end_comment

begin_function
name|void
name|machopic_output_stub
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
specifier|const
name|char
modifier|*
name|symb
parameter_list|,
specifier|const
name|char
modifier|*
name|stub
parameter_list|)
block|{
name|unsigned
name|int
name|length
decl_stmt|;
name|char
modifier|*
name|binder_name
decl_stmt|,
modifier|*
name|symbol_name
decl_stmt|,
name|lazy_ptr_name
index|[
literal|32
index|]
decl_stmt|;
name|int
name|label
init|=
operator|++
name|current_machopic_label_num
decl_stmt|;
comment|/* For 64-bit we shouldn't get here.  */
name|gcc_assert
argument_list|(
operator|!
name|TARGET_64BIT
argument_list|)
expr_stmt|;
comment|/* Lose our funky encoding stuff so it doesn't contaminate the stub.  */
name|symb
operator|=
call|(
modifier|*
name|targetm
operator|.
name|strip_name_encoding
call|)
argument_list|(
name|symb
argument_list|)
expr_stmt|;
name|length
operator|=
name|strlen
argument_list|(
name|stub
argument_list|)
expr_stmt|;
name|binder_name
operator|=
name|alloca
argument_list|(
name|length
operator|+
literal|32
argument_list|)
expr_stmt|;
name|GEN_BINDER_NAME_FOR_STUB
argument_list|(
name|binder_name
argument_list|,
name|stub
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|length
operator|=
name|strlen
argument_list|(
name|symb
argument_list|)
expr_stmt|;
name|symbol_name
operator|=
name|alloca
argument_list|(
name|length
operator|+
literal|32
argument_list|)
expr_stmt|;
name|GEN_SYMBOL_NAME_FOR_SYMBOL
argument_list|(
name|symbol_name
argument_list|,
name|symb
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|lazy_ptr_name
argument_list|,
literal|"L%d$lz"
argument_list|,
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
name|MACHOPIC_PURE
condition|)
name|switch_to_section
argument_list|(
name|darwin_sections
index|[
name|machopic_picsymbol_stub_section
index|]
argument_list|)
expr_stmt|;
else|else
name|switch_to_section
argument_list|(
name|darwin_sections
index|[
name|machopic_symbol_stub_section
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s:\n"
argument_list|,
name|stub
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.indirect_symbol %s\n"
argument_list|,
name|symbol_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|MACHOPIC_PURE
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tcall\tLPC$%d\nLPC$%d:\tpopl\t%%eax\n"
argument_list|,
name|label
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tmovl\t%s-LPC$%d(%%eax),%%edx\n"
argument_list|,
name|lazy_ptr_name
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tjmp\t*%%edx\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tjmp\t*%s\n"
argument_list|,
name|lazy_ptr_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s:\n"
argument_list|,
name|binder_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|MACHOPIC_PURE
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tlea\t%s-LPC$%d(%%eax),%%eax\n"
argument_list|,
name|lazy_ptr_name
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tpushl\t%%eax\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tpushl\t$%s\n"
argument_list|,
name|lazy_ptr_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tjmp\tdyld_stub_binding_helper\n"
argument_list|)
expr_stmt|;
name|switch_to_section
argument_list|(
name|darwin_sections
index|[
name|machopic_lazy_symbol_ptr_section
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s:\n"
argument_list|,
name|lazy_ptr_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.indirect_symbol %s\n"
argument_list|,
name|symbol_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.long %s\n"
argument_list|,
name|binder_name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|darwin_x86_file_end
parameter_list|(
name|void
parameter_list|)
block|{
name|darwin_file_end
argument_list|()
expr_stmt|;
name|ix86_file_end
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TARGET_MACHO */
end_comment

begin_comment
comment|/* Order the registers for register allocator.  */
end_comment

begin_function
name|void
name|x86_order_regs_for_local_alloc
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|pos
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* First allocate the local general purpose registers.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|GENERAL_REGNO_P
argument_list|(
name|i
argument_list|)
operator|&&
name|call_used_regs
index|[
name|i
index|]
condition|)
name|reg_alloc_order
index|[
name|pos
operator|++
index|]
operator|=
name|i
expr_stmt|;
comment|/* Global general purpose registers.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|GENERAL_REGNO_P
argument_list|(
name|i
argument_list|)
operator|&&
operator|!
name|call_used_regs
index|[
name|i
index|]
condition|)
name|reg_alloc_order
index|[
name|pos
operator|++
index|]
operator|=
name|i
expr_stmt|;
comment|/* x87 registers come first in case we are doing FP math       using them.  */
if|if
condition|(
operator|!
name|TARGET_SSE_MATH
condition|)
for|for
control|(
name|i
operator|=
name|FIRST_STACK_REG
init|;
name|i
operator|<=
name|LAST_STACK_REG
condition|;
name|i
operator|++
control|)
name|reg_alloc_order
index|[
name|pos
operator|++
index|]
operator|=
name|i
expr_stmt|;
comment|/* SSE registers.  */
for|for
control|(
name|i
operator|=
name|FIRST_SSE_REG
init|;
name|i
operator|<=
name|LAST_SSE_REG
condition|;
name|i
operator|++
control|)
name|reg_alloc_order
index|[
name|pos
operator|++
index|]
operator|=
name|i
expr_stmt|;
for|for
control|(
name|i
operator|=
name|FIRST_REX_SSE_REG
init|;
name|i
operator|<=
name|LAST_REX_SSE_REG
condition|;
name|i
operator|++
control|)
name|reg_alloc_order
index|[
name|pos
operator|++
index|]
operator|=
name|i
expr_stmt|;
comment|/* x87 registers.  */
if|if
condition|(
name|TARGET_SSE_MATH
condition|)
for|for
control|(
name|i
operator|=
name|FIRST_STACK_REG
init|;
name|i
operator|<=
name|LAST_STACK_REG
condition|;
name|i
operator|++
control|)
name|reg_alloc_order
index|[
name|pos
operator|++
index|]
operator|=
name|i
expr_stmt|;
for|for
control|(
name|i
operator|=
name|FIRST_MMX_REG
init|;
name|i
operator|<=
name|LAST_MMX_REG
condition|;
name|i
operator|++
control|)
name|reg_alloc_order
index|[
name|pos
operator|++
index|]
operator|=
name|i
expr_stmt|;
comment|/* Initialize the rest of array as we do not allocate some registers       at all.  */
while|while
condition|(
name|pos
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|reg_alloc_order
index|[
name|pos
operator|++
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle a "ms_struct" or "gcc_struct" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|ix86_handle_struct_attribute
parameter_list|(
name|tree
modifier|*
name|node
parameter_list|,
name|tree
name|name
parameter_list|,
name|tree
name|args
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|flags
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bool
modifier|*
name|no_add_attrs
parameter_list|)
block|{
name|tree
modifier|*
name|type
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|DECL_P
argument_list|(
operator|*
name|node
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|type
operator|=
operator|&
name|TREE_TYPE
argument_list|(
operator|*
name|node
argument_list|)
expr_stmt|;
block|}
else|else
name|type
operator|=
name|node
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|type
operator|&&
operator|(
name|TREE_CODE
argument_list|(
operator|*
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
operator|*
name|type
argument_list|)
operator|==
name|UNION_TYPE
operator|)
operator|)
condition|)
block|{
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"%qs attribute ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|is_attribute_p
argument_list|(
literal|"ms_struct"
argument_list|,
name|name
argument_list|)
operator|&&
name|lookup_attribute
argument_list|(
literal|"gcc_struct"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
operator|*
name|type
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|is_attribute_p
argument_list|(
literal|"gcc_struct"
argument_list|,
name|name
argument_list|)
operator|&&
name|lookup_attribute
argument_list|(
literal|"ms_struct"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
operator|*
name|type
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
block|{
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"%qs incompatible attribute ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|ix86_ms_bitfield_layout_p
parameter_list|(
name|tree
name|record_type
parameter_list|)
block|{
return|return
operator|(
name|TARGET_MS_BITFIELD_LAYOUT
operator|&&
operator|!
name|lookup_attribute
argument_list|(
literal|"gcc_struct"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|record_type
argument_list|)
argument_list|)
operator|)
operator|||
name|lookup_attribute
argument_list|(
literal|"ms_struct"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|record_type
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns an expression indicating where the this parameter is    located on entry to the FUNCTION.  */
end_comment

begin_function
specifier|static
name|rtx
name|x86_this_parameter
parameter_list|(
name|tree
name|function
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
decl_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
name|int
name|n
init|=
name|aggregate_value_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|type
argument_list|)
operator|!=
literal|0
decl_stmt|;
return|return
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|x86_64_int_parameter_registers
index|[
name|n
index|]
argument_list|)
return|;
block|}
if|if
condition|(
name|ix86_function_regparm
argument_list|(
name|type
argument_list|,
name|function
argument_list|)
operator|>
literal|0
condition|)
block|{
name|tree
name|parm
decl_stmt|;
name|parm
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Figure out whether or not the function has a variable number of 	 arguments.  */
for|for
control|(
init|;
name|parm
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
control|)
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
operator|==
name|void_type_node
condition|)
break|break;
comment|/* If not, the this parameter is in the first argument.  */
if|if
condition|(
name|parm
condition|)
block|{
name|int
name|regno
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"fastcall"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
name|regno
operator|=
literal|2
expr_stmt|;
return|return
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|regno
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|aggregate_value_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|type
argument_list|)
condition|)
return|return
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|stack_pointer_rtx
argument_list|,
literal|8
argument_list|)
argument_list|)
return|;
else|else
return|return
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|stack_pointer_rtx
argument_list|,
literal|4
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Determine whether x86_output_mi_thunk can succeed.  */
end_comment

begin_function
specifier|static
name|bool
name|x86_can_output_mi_thunk
parameter_list|(
name|tree
name|thunk
name|ATTRIBUTE_UNUSED
parameter_list|,
name|HOST_WIDE_INT
name|delta
name|ATTRIBUTE_UNUSED
parameter_list|,
name|HOST_WIDE_INT
name|vcall_offset
parameter_list|,
name|tree
name|function
parameter_list|)
block|{
comment|/* 64-bit can handle anything.  */
if|if
condition|(
name|TARGET_64BIT
condition|)
return|return
name|true
return|;
comment|/* For 32-bit, everything's fine if we have one free register.  */
if|if
condition|(
name|ix86_function_regparm
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|,
name|function
argument_list|)
operator|<
literal|3
condition|)
return|return
name|true
return|;
comment|/* Need a free register for vcall_offset.  */
if|if
condition|(
name|vcall_offset
condition|)
return|return
name|false
return|;
comment|/* Need a free register for GOT references.  */
if|if
condition|(
name|flag_pic
operator|&&
operator|!
call|(
modifier|*
name|targetm
operator|.
name|binds_local_p
call|)
argument_list|(
name|function
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Otherwise ok.  */
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Output the assembler code for a thunk function.  THUNK_DECL is the    declaration for the thunk function itself, FUNCTION is the decl for    the target function.  DELTA is an immediate constant offset to be    added to THIS.  If VCALL_OFFSET is nonzero, the word at    *(*this + vcall_offset) should be added to THIS.  */
end_comment

begin_function
specifier|static
name|void
name|x86_output_mi_thunk
parameter_list|(
name|FILE
modifier|*
name|file
name|ATTRIBUTE_UNUSED
parameter_list|,
name|tree
name|thunk
name|ATTRIBUTE_UNUSED
parameter_list|,
name|HOST_WIDE_INT
name|delta
parameter_list|,
name|HOST_WIDE_INT
name|vcall_offset
parameter_list|,
name|tree
name|function
parameter_list|)
block|{
name|rtx
name|xops
index|[
literal|3
index|]
decl_stmt|;
name|rtx
name|this
init|=
name|x86_this_parameter
argument_list|(
name|function
argument_list|)
decl_stmt|;
name|rtx
name|this_reg
decl_stmt|,
name|tmp
decl_stmt|;
comment|/* If VCALL_OFFSET, we'll need THIS in a register.  Might as well      pull it in now and let DELTA benefit.  */
if|if
condition|(
name|REG_P
argument_list|(
name|this
argument_list|)
condition|)
name|this_reg
operator|=
name|this
expr_stmt|;
elseif|else
if|if
condition|(
name|vcall_offset
condition|)
block|{
comment|/* Put the this parameter into %eax.  */
name|xops
index|[
literal|0
index|]
operator|=
name|this
expr_stmt|;
name|xops
index|[
literal|1
index|]
operator|=
name|this_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"mov{l}\t{%0, %1|%1, %0}"
argument_list|,
name|xops
argument_list|)
expr_stmt|;
block|}
else|else
name|this_reg
operator|=
name|NULL_RTX
expr_stmt|;
comment|/* Adjust the this parameter by a fixed constant.  */
if|if
condition|(
name|delta
condition|)
block|{
name|xops
index|[
literal|0
index|]
operator|=
name|GEN_INT
argument_list|(
name|delta
argument_list|)
expr_stmt|;
name|xops
index|[
literal|1
index|]
operator|=
name|this_reg
condition|?
name|this_reg
else|:
name|this
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
if|if
condition|(
operator|!
name|x86_64_general_operand
argument_list|(
name|xops
index|[
literal|0
index|]
argument_list|,
name|DImode
argument_list|)
condition|)
block|{
name|tmp
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|FIRST_REX_INT_REG
operator|+
literal|2
comment|/* R10 */
argument_list|)
expr_stmt|;
name|xops
index|[
literal|1
index|]
operator|=
name|tmp
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"mov{q}\t{%1, %0|%0, %1}"
argument_list|,
name|xops
argument_list|)
expr_stmt|;
name|xops
index|[
literal|0
index|]
operator|=
name|tmp
expr_stmt|;
name|xops
index|[
literal|1
index|]
operator|=
name|this
expr_stmt|;
block|}
name|output_asm_insn
argument_list|(
literal|"add{q}\t{%0, %1|%1, %0}"
argument_list|,
name|xops
argument_list|)
expr_stmt|;
block|}
else|else
name|output_asm_insn
argument_list|(
literal|"add{l}\t{%0, %1|%1, %0}"
argument_list|,
name|xops
argument_list|)
expr_stmt|;
block|}
comment|/* Adjust the this parameter by a value stored in the vtable.  */
if|if
condition|(
name|vcall_offset
condition|)
block|{
if|if
condition|(
name|TARGET_64BIT
condition|)
name|tmp
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|FIRST_REX_INT_REG
operator|+
literal|2
comment|/* R10 */
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|tmp_regno
init|=
literal|2
comment|/* ECX */
decl_stmt|;
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"fastcall"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
argument_list|)
condition|)
name|tmp_regno
operator|=
literal|0
comment|/* EAX */
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|tmp_regno
argument_list|)
expr_stmt|;
block|}
name|xops
index|[
literal|0
index|]
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|this_reg
argument_list|)
expr_stmt|;
name|xops
index|[
literal|1
index|]
operator|=
name|tmp
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
name|output_asm_insn
argument_list|(
literal|"mov{q}\t{%0, %1|%1, %0}"
argument_list|,
name|xops
argument_list|)
expr_stmt|;
else|else
name|output_asm_insn
argument_list|(
literal|"mov{l}\t{%0, %1|%1, %0}"
argument_list|,
name|xops
argument_list|)
expr_stmt|;
comment|/* Adjust the this parameter.  */
name|xops
index|[
literal|0
index|]
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|plus_constant
argument_list|(
name|tmp
argument_list|,
name|vcall_offset
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
operator|&&
operator|!
name|memory_operand
argument_list|(
name|xops
index|[
literal|0
index|]
argument_list|,
name|Pmode
argument_list|)
condition|)
block|{
name|rtx
name|tmp2
init|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|FIRST_REX_INT_REG
operator|+
literal|3
comment|/* R11 */
argument_list|)
decl_stmt|;
name|xops
index|[
literal|0
index|]
operator|=
name|GEN_INT
argument_list|(
name|vcall_offset
argument_list|)
expr_stmt|;
name|xops
index|[
literal|1
index|]
operator|=
name|tmp2
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"mov{q}\t{%0, %1|%1, %0}"
argument_list|,
name|xops
argument_list|)
expr_stmt|;
name|xops
index|[
literal|0
index|]
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|tmp
argument_list|,
name|tmp2
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|xops
index|[
literal|1
index|]
operator|=
name|this_reg
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
name|output_asm_insn
argument_list|(
literal|"add{q}\t{%0, %1|%1, %0}"
argument_list|,
name|xops
argument_list|)
expr_stmt|;
else|else
name|output_asm_insn
argument_list|(
literal|"add{l}\t{%0, %1|%1, %0}"
argument_list|,
name|xops
argument_list|)
expr_stmt|;
block|}
comment|/* If necessary, drop THIS back to its stack slot.  */
if|if
condition|(
name|this_reg
operator|&&
name|this_reg
operator|!=
name|this
condition|)
block|{
name|xops
index|[
literal|0
index|]
operator|=
name|this_reg
expr_stmt|;
name|xops
index|[
literal|1
index|]
operator|=
name|this
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"mov{l}\t{%0, %1|%1, %0}"
argument_list|,
name|xops
argument_list|)
expr_stmt|;
block|}
name|xops
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|function
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
if|if
condition|(
operator|!
name|flag_pic
operator|||
call|(
modifier|*
name|targetm
operator|.
name|binds_local_p
call|)
argument_list|(
name|function
argument_list|)
condition|)
name|output_asm_insn
argument_list|(
literal|"jmp\t%P0"
argument_list|,
name|xops
argument_list|)
expr_stmt|;
else|else
block|{
name|tmp
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|xops
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|UNSPEC_GOTPCREL
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_MEM
argument_list|(
name|QImode
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|xops
index|[
literal|0
index|]
operator|=
name|tmp
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"jmp\t%A0"
argument_list|,
name|xops
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|flag_pic
operator|||
call|(
modifier|*
name|targetm
operator|.
name|binds_local_p
call|)
argument_list|(
name|function
argument_list|)
condition|)
name|output_asm_insn
argument_list|(
literal|"jmp\t%P0"
argument_list|,
name|xops
argument_list|)
expr_stmt|;
elseif|else
if|#
directive|if
name|TARGET_MACHO
if|if
condition|(
name|TARGET_MACHO
condition|)
block|{
name|rtx
name|sym_ref
init|=
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|function
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tmp
operator|=
operator|(
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|machopic_indirection_name
argument_list|(
name|sym_ref
argument_list|,
comment|/*stub_p=*/
name|true
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_MEM
argument_list|(
name|QImode
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|xops
index|[
literal|0
index|]
operator|=
name|tmp
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"jmp\t%0"
argument_list|,
name|xops
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* TARGET_MACHO */
block|{
name|tmp
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
literal|2
comment|/* ECX */
argument_list|)
expr_stmt|;
name|output_set_got
argument_list|(
name|tmp
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|xops
index|[
literal|1
index|]
operator|=
name|tmp
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"mov{l}\t{%0@GOT(%1), %1|%1, %0@GOT[%1]}"
argument_list|,
name|xops
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"jmp\t{*}%1"
argument_list|,
name|xops
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|x86_file_start
parameter_list|(
name|void
parameter_list|)
block|{
name|default_file_start
argument_list|()
expr_stmt|;
if|#
directive|if
name|TARGET_MACHO
name|darwin_file_start
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|X86_FILE_START_VERSION_DIRECTIVE
condition|)
name|fputs
argument_list|(
literal|"\t.version\t\"01.01\"\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|X86_FILE_START_FLTUSED
condition|)
name|fputs
argument_list|(
literal|"\t.global\t__fltused\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|ix86_asm_dialect
operator|==
name|ASM_INTEL
condition|)
name|fputs
argument_list|(
literal|"\t.intel_syntax\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|x86_field_alignment
parameter_list|(
name|tree
name|field
parameter_list|,
name|int
name|computed
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|TARGET_64BIT
operator|||
name|TARGET_ALIGN_DOUBLE
condition|)
return|return
name|computed
return|;
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|?
name|get_inner_array_type
argument_list|(
name|type
argument_list|)
else|:
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|DFmode
operator|||
name|mode
operator|==
name|DCmode
operator|||
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|||
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_COMPLEX_INT
condition|)
return|return
name|MIN
argument_list|(
literal|32
argument_list|,
name|computed
argument_list|)
return|;
return|return
name|computed
return|;
block|}
end_function

begin_comment
comment|/* Output assembler code to FILE to increment profiler label # LABELNO    for profiling a function entry.  */
end_comment

begin_function
name|void
name|x86_function_profiler
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|int
name|labelno
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|TARGET_64BIT
condition|)
if|if
condition|(
name|flag_pic
condition|)
block|{
ifndef|#
directive|ifndef
name|NO_PROFILE_COUNTERS
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tleaq\t%sP%d@(%%rip),%%r11\n"
argument_list|,
name|LPREFIX
argument_list|,
name|labelno
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tcall\t*%s@GOTPCREL(%%rip)\n"
argument_list|,
name|MCOUNT_NAME
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifndef|#
directive|ifndef
name|NO_PROFILE_COUNTERS
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tmovq\t$%sP%d,%%r11\n"
argument_list|,
name|LPREFIX
argument_list|,
name|labelno
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tcall\t%s\n"
argument_list|,
name|MCOUNT_NAME
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flag_pic
condition|)
block|{
ifndef|#
directive|ifndef
name|NO_PROFILE_COUNTERS
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tleal\t%sP%d@GOTOFF(%%ebx),%%%s\n"
argument_list|,
name|LPREFIX
argument_list|,
name|labelno
argument_list|,
name|PROFILE_COUNT_REGISTER
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tcall\t*%s@GOT(%%ebx)\n"
argument_list|,
name|MCOUNT_NAME
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifndef|#
directive|ifndef
name|NO_PROFILE_COUNTERS
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tmovl\t$%sP%d,%%%s\n"
argument_list|,
name|LPREFIX
argument_list|,
name|labelno
argument_list|,
name|PROFILE_COUNT_REGISTER
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tcall\t%s\n"
argument_list|,
name|MCOUNT_NAME
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* We don't have exact information about the insn sizes, but we may assume    quite safely that we are informed about all 1 byte insns and memory    address sizes.  This is enough to eliminate unnecessary padding in    99% of cases.  */
end_comment

begin_function
specifier|static
name|int
name|min_insn_size
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|int
name|l
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|||
operator|!
name|active_insn_p
argument_list|(
name|insn
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Discard alignments we've emit and jump instructions.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|UNSPEC_VOLATILE
operator|&&
name|XINT
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPECV_ALIGN
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ADDR_VEC
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
operator|)
condition|)
return|return
literal|0
return|;
comment|/* Important case - calls are always 5 bytes.      It is common to have many calls in the row.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|&&
name|symbolic_reference_mentioned_p
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|&&
operator|!
name|SIBLING_CALL_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return
literal|5
return|;
if|if
condition|(
name|get_attr_length
argument_list|(
name|insn
argument_list|)
operator|<=
literal|1
condition|)
return|return
literal|1
return|;
comment|/* For normal instructions we may rely on the sizes of addresses      and the presence of symbol to require 4 bytes of encoding.      This is not the case for jumps where references are PC relative.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|JUMP_INSN
condition|)
block|{
name|l
operator|=
name|get_attr_length_address
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|<
literal|4
operator|&&
name|symbolic_reference_mentioned_p
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
name|l
operator|=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|l
condition|)
return|return
literal|1
operator|+
name|l
return|;
else|else
return|return
literal|2
return|;
block|}
end_function

begin_comment
comment|/* AMD K8 core mispredicts jumps when there are more than 3 jumps in 16 byte    window.  */
end_comment

begin_function
specifier|static
name|void
name|ix86_avoid_jump_misspredicts
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|,
name|start
init|=
name|get_insns
argument_list|()
decl_stmt|;
name|int
name|nbytes
init|=
literal|0
decl_stmt|,
name|njumps
init|=
literal|0
decl_stmt|;
name|int
name|isjump
init|=
literal|0
decl_stmt|;
comment|/* Look for all minimal intervals of instructions containing 4 jumps.      The intervals are bounded by START and INSN.  NBYTES is the total      size of instructions in the interval including INSN and not including      START.  When the NBYTES is smaller than 16 bytes, it is possible      that the end of START and INSN ends up in the same 16byte page.       The smallest offset in the page INSN can start is the case where START      ends on the offset 0.  Offset of INSN is then NBYTES - sizeof (INSN).      We add p2align to 16byte window with maxskip 17 - NBYTES + sizeof (INSN).      */
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|nbytes
operator|+=
name|min_insn_size
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Insn %i estimated to %i bytes\n"
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|,
name|min_insn_size
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|ADDR_VEC
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|ADDR_DIFF_VEC
operator|)
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
name|njumps
operator|++
expr_stmt|;
else|else
continue|continue;
while|while
condition|(
name|njumps
operator|>
literal|3
condition|)
block|{
name|start
operator|=
name|NEXT_INSN
argument_list|(
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|start
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|start
argument_list|)
argument_list|)
operator|!=
name|ADDR_VEC
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|start
argument_list|)
argument_list|)
operator|!=
name|ADDR_DIFF_VEC
operator|)
operator|||
name|GET_CODE
argument_list|(
name|start
argument_list|)
operator|==
name|CALL_INSN
condition|)
name|njumps
operator|--
operator|,
name|isjump
operator|=
literal|1
expr_stmt|;
else|else
name|isjump
operator|=
literal|0
expr_stmt|;
name|nbytes
operator|-=
name|min_insn_size
argument_list|(
name|start
argument_list|)
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
name|njumps
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Interval %i to %i has %i bytes\n"
argument_list|,
name|INSN_UID
argument_list|(
name|start
argument_list|)
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|njumps
operator|==
literal|3
operator|&&
name|isjump
operator|&&
name|nbytes
operator|<
literal|16
condition|)
block|{
name|int
name|padsize
init|=
literal|15
operator|-
name|nbytes
operator|+
name|min_insn_size
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Padding insn %i by %i bytes!\n"
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|,
name|padsize
argument_list|)
expr_stmt|;
name|emit_insn_before
argument_list|(
name|gen_align
argument_list|(
name|GEN_INT
argument_list|(
name|padsize
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* AMD Athlon works faster    when RET is not destination of conditional jump or directly preceded    by other jump instruction.  We avoid the penalty by inserting NOP just    before the RET instructions in such cases.  */
end_comment

begin_function
specifier|static
name|void
name|ix86_pad_returns
parameter_list|(
name|void
parameter_list|)
block|{
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|EXIT_BLOCK_PTR->preds
argument_list|)
block|{
name|basic_block
name|bb
init|=
name|e
operator|->
name|src
decl_stmt|;
name|rtx
name|ret
init|=
name|BB_END
argument_list|(
name|bb
argument_list|)
decl_stmt|;
name|rtx
name|prev
decl_stmt|;
name|bool
name|replace
init|=
name|false
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|ret
argument_list|)
operator|!=
name|JUMP_INSN
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|ret
argument_list|)
argument_list|)
operator|!=
name|RETURN
operator|||
operator|!
name|maybe_hot_bb_p
argument_list|(
name|bb
argument_list|)
condition|)
continue|continue;
for|for
control|(
name|prev
operator|=
name|PREV_INSN
argument_list|(
name|ret
argument_list|)
init|;
name|prev
condition|;
name|prev
operator|=
name|PREV_INSN
argument_list|(
name|prev
argument_list|)
control|)
if|if
condition|(
name|active_insn_p
argument_list|(
name|prev
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|prev
argument_list|)
operator|==
name|CODE_LABEL
condition|)
break|break;
if|if
condition|(
name|prev
operator|&&
name|GET_CODE
argument_list|(
name|prev
argument_list|)
operator|==
name|CODE_LABEL
condition|)
block|{
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->preds
argument_list|)
if|if
condition|(
name|EDGE_FREQUENCY
argument_list|(
name|e
argument_list|)
operator|&&
name|e
operator|->
name|src
operator|->
name|index
operator|>=
literal|0
operator|&&
operator|!
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
operator|)
condition|)
name|replace
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|replace
condition|)
block|{
name|prev
operator|=
name|prev_active_insn
argument_list|(
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|prev
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|any_condjump_p
argument_list|(
name|prev
argument_list|)
operator|)
operator|||
name|GET_CODE
argument_list|(
name|prev
argument_list|)
operator|==
name|CALL_INSN
operator|)
condition|)
name|replace
operator|=
name|true
expr_stmt|;
comment|/* Empty functions get branch mispredict even when the jump destination 	     is not visible to us.  */
if|if
condition|(
operator|!
name|prev
operator|&&
name|cfun
operator|->
name|function_frequency
operator|>
name|FUNCTION_FREQUENCY_UNLIKELY_EXECUTED
condition|)
name|replace
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|replace
condition|)
block|{
name|emit_insn_before
argument_list|(
name|gen_return_internal_long
argument_list|()
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|ret
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Implement machine specific optimizations.  We implement padding of returns    for K8 CPUs and pass to avoid 4 jumps in the single 16 byte window.  */
end_comment

begin_function
specifier|static
name|void
name|ix86_reorg
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|TARGET_PAD_RETURNS
operator|&&
name|optimize
operator|&&
operator|!
name|optimize_size
condition|)
name|ix86_pad_returns
argument_list|()
expr_stmt|;
if|if
condition|(
name|TARGET_FOUR_JUMP_LIMIT
operator|&&
name|optimize
operator|&&
operator|!
name|optimize_size
condition|)
name|ix86_avoid_jump_misspredicts
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return nonzero when QImode register that must be represented via REX prefix    is used.  */
end_comment

begin_function
name|bool
name|x86_extended_QIreg_mentioned_p
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|extract_insn_cached
argument_list|(
name|insn
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|recog_data
operator|.
name|n_operands
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|REG_P
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
operator|>=
literal|4
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero when P points to register encoded via REX prefix.    Called via for_each_rtx.  */
end_comment

begin_function
specifier|static
name|int
name|extended_reg_mentioned_1
parameter_list|(
name|rtx
modifier|*
name|p
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|unsigned
name|int
name|regno
decl_stmt|;
if|if
condition|(
operator|!
name|REG_P
argument_list|(
operator|*
name|p
argument_list|)
condition|)
return|return
literal|0
return|;
name|regno
operator|=
name|REGNO
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
return|return
name|REX_INT_REGNO_P
argument_list|(
name|regno
argument_list|)
operator|||
name|REX_SSE_REGNO_P
argument_list|(
name|regno
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true when INSN mentions register that must be encoded using REX    prefix.  */
end_comment

begin_function
name|bool
name|x86_extended_reg_mentioned_p
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
return|return
name|for_each_rtx
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|extended_reg_mentioned_1
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Generate an unsigned DImode/SImode to FP conversion.  This is the same code    optabs would emit if we didn't have TFmode patterns.  */
end_comment

begin_function
name|void
name|x86_emit_floatuns
parameter_list|(
name|rtx
name|operands
index|[
literal|2
index|]
parameter_list|)
block|{
name|rtx
name|neglab
decl_stmt|,
name|donelab
decl_stmt|,
name|i0
decl_stmt|,
name|i1
decl_stmt|,
name|f0
decl_stmt|,
name|in
decl_stmt|,
name|out
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|,
name|inmode
decl_stmt|;
name|inmode
operator|=
name|GET_MODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|inmode
operator|==
name|SImode
operator|||
name|inmode
operator|==
name|DImode
argument_list|)
expr_stmt|;
name|out
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
name|in
operator|=
name|force_reg
argument_list|(
name|inmode
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|neglab
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|donelab
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|i1
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|f0
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|in
argument_list|,
name|const0_rtx
argument_list|,
name|LT
argument_list|,
name|const0_rtx
argument_list|,
name|Pmode
argument_list|,
literal|0
argument_list|,
name|neglab
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|out
argument_list|,
name|gen_rtx_FLOAT
argument_list|(
name|mode
argument_list|,
name|in
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_jump
argument_list|(
name|donelab
argument_list|)
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|neglab
argument_list|)
expr_stmt|;
name|i0
operator|=
name|expand_simple_binop
argument_list|(
name|Pmode
argument_list|,
name|LSHIFTRT
argument_list|,
name|in
argument_list|,
name|const1_rtx
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
name|i1
operator|=
name|expand_simple_binop
argument_list|(
name|Pmode
argument_list|,
name|AND
argument_list|,
name|in
argument_list|,
name|const1_rtx
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
name|i0
operator|=
name|expand_simple_binop
argument_list|(
name|Pmode
argument_list|,
name|IOR
argument_list|,
name|i0
argument_list|,
name|i1
argument_list|,
name|i0
argument_list|,
literal|1
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
name|expand_float
argument_list|(
name|f0
argument_list|,
name|i0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|out
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|mode
argument_list|,
name|f0
argument_list|,
name|f0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|donelab
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A subroutine of ix86_expand_vector_init.  Store into TARGET a vector    with all elements equal to VAR.  Return true if successful.  */
end_comment

begin_function
specifier|static
name|bool
name|ix86_expand_vector_init_duplicate
parameter_list|(
name|bool
name|mmx_ok
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|target
parameter_list|,
name|rtx
name|val
parameter_list|)
block|{
name|enum
name|machine_mode
name|smode
decl_stmt|,
name|wsmode
decl_stmt|,
name|wvmode
decl_stmt|;
name|rtx
name|x
decl_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|V2SImode
case|:
case|case
name|V2SFmode
case|:
if|if
condition|(
operator|!
name|mmx_ok
condition|)
return|return
name|false
return|;
comment|/* FALLTHRU */
case|case
name|V2DFmode
case|:
case|case
name|V2DImode
case|:
case|case
name|V4SFmode
case|:
case|case
name|V4SImode
case|:
name|val
operator|=
name|force_reg
argument_list|(
name|GET_MODE_INNER
argument_list|(
name|mode
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|x
operator|=
name|gen_rtx_VEC_DUPLICATE
argument_list|(
name|mode
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|,
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
case|case
name|V4HImode
case|:
if|if
condition|(
operator|!
name|mmx_ok
condition|)
return|return
name|false
return|;
if|if
condition|(
name|TARGET_SSE
operator|||
name|TARGET_3DNOW_A
condition|)
block|{
name|val
operator|=
name|gen_lowpart
argument_list|(
name|SImode
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|x
operator|=
name|gen_rtx_TRUNCATE
argument_list|(
name|HImode
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|x
operator|=
name|gen_rtx_VEC_DUPLICATE
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|,
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
else|else
block|{
name|smode
operator|=
name|HImode
expr_stmt|;
name|wsmode
operator|=
name|SImode
expr_stmt|;
name|wvmode
operator|=
name|V2SImode
expr_stmt|;
goto|goto
name|widen
goto|;
block|}
case|case
name|V8QImode
case|:
if|if
condition|(
operator|!
name|mmx_ok
condition|)
return|return
name|false
return|;
name|smode
operator|=
name|QImode
expr_stmt|;
name|wsmode
operator|=
name|HImode
expr_stmt|;
name|wvmode
operator|=
name|V4HImode
expr_stmt|;
goto|goto
name|widen
goto|;
case|case
name|V8HImode
case|:
if|if
condition|(
name|TARGET_SSE2
condition|)
block|{
name|rtx
name|tmp1
decl_stmt|,
name|tmp2
decl_stmt|;
comment|/* Extend HImode to SImode using a paradoxical SUBREG.  */
name|tmp1
operator|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|tmp1
argument_list|,
name|gen_lowpart
argument_list|(
name|SImode
argument_list|,
name|val
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Insert the SImode value as low element of V4SImode vector. */
name|tmp2
operator|=
name|gen_reg_rtx
argument_list|(
name|V4SImode
argument_list|)
expr_stmt|;
name|tmp1
operator|=
name|gen_rtx_VEC_MERGE
argument_list|(
name|V4SImode
argument_list|,
name|gen_rtx_VEC_DUPLICATE
argument_list|(
name|V4SImode
argument_list|,
name|tmp1
argument_list|)
argument_list|,
name|CONST0_RTX
argument_list|(
name|V4SImode
argument_list|)
argument_list|,
name|const1_rtx
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|tmp2
argument_list|,
name|tmp1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Cast the V4SImode vector back to a V8HImode vector.  */
name|tmp1
operator|=
name|gen_reg_rtx
argument_list|(
name|V8HImode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|tmp1
argument_list|,
name|gen_lowpart
argument_list|(
name|V8HImode
argument_list|,
name|tmp2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Duplicate the low short through the whole low SImode word.  */
name|emit_insn
argument_list|(
name|gen_sse2_punpcklwd
argument_list|(
name|tmp1
argument_list|,
name|tmp1
argument_list|,
name|tmp1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Cast the V8HImode vector back to a V4SImode vector.  */
name|tmp2
operator|=
name|gen_reg_rtx
argument_list|(
name|V4SImode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|tmp2
argument_list|,
name|gen_lowpart
argument_list|(
name|V4SImode
argument_list|,
name|tmp1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Replicate the low element of the V4SImode vector.  */
name|emit_insn
argument_list|(
name|gen_sse2_pshufd
argument_list|(
name|tmp2
argument_list|,
name|tmp2
argument_list|,
name|const0_rtx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Cast the V2SImode back to V8HImode, and store in target.  */
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|gen_lowpart
argument_list|(
name|V8HImode
argument_list|,
name|tmp2
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
name|smode
operator|=
name|HImode
expr_stmt|;
name|wsmode
operator|=
name|SImode
expr_stmt|;
name|wvmode
operator|=
name|V4SImode
expr_stmt|;
goto|goto
name|widen
goto|;
case|case
name|V16QImode
case|:
if|if
condition|(
name|TARGET_SSE2
condition|)
block|{
name|rtx
name|tmp1
decl_stmt|,
name|tmp2
decl_stmt|;
comment|/* Extend QImode to SImode using a paradoxical SUBREG.  */
name|tmp1
operator|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|tmp1
argument_list|,
name|gen_lowpart
argument_list|(
name|SImode
argument_list|,
name|val
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Insert the SImode value as low element of V4SImode vector. */
name|tmp2
operator|=
name|gen_reg_rtx
argument_list|(
name|V4SImode
argument_list|)
expr_stmt|;
name|tmp1
operator|=
name|gen_rtx_VEC_MERGE
argument_list|(
name|V4SImode
argument_list|,
name|gen_rtx_VEC_DUPLICATE
argument_list|(
name|V4SImode
argument_list|,
name|tmp1
argument_list|)
argument_list|,
name|CONST0_RTX
argument_list|(
name|V4SImode
argument_list|)
argument_list|,
name|const1_rtx
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|tmp2
argument_list|,
name|tmp1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Cast the V4SImode vector back to a V16QImode vector.  */
name|tmp1
operator|=
name|gen_reg_rtx
argument_list|(
name|V16QImode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|tmp1
argument_list|,
name|gen_lowpart
argument_list|(
name|V16QImode
argument_list|,
name|tmp2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Duplicate the low byte through the whole low SImode word.  */
name|emit_insn
argument_list|(
name|gen_sse2_punpcklbw
argument_list|(
name|tmp1
argument_list|,
name|tmp1
argument_list|,
name|tmp1
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_sse2_punpcklbw
argument_list|(
name|tmp1
argument_list|,
name|tmp1
argument_list|,
name|tmp1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Cast the V16QImode vector back to a V4SImode vector.  */
name|tmp2
operator|=
name|gen_reg_rtx
argument_list|(
name|V4SImode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|tmp2
argument_list|,
name|gen_lowpart
argument_list|(
name|V4SImode
argument_list|,
name|tmp1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Replicate the low element of the V4SImode vector.  */
name|emit_insn
argument_list|(
name|gen_sse2_pshufd
argument_list|(
name|tmp2
argument_list|,
name|tmp2
argument_list|,
name|const0_rtx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Cast the V2SImode back to V16QImode, and store in target.  */
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|gen_lowpart
argument_list|(
name|V16QImode
argument_list|,
name|tmp2
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
name|smode
operator|=
name|QImode
expr_stmt|;
name|wsmode
operator|=
name|HImode
expr_stmt|;
name|wvmode
operator|=
name|V8HImode
expr_stmt|;
goto|goto
name|widen
goto|;
name|widen
label|:
comment|/* Replicate the value once into the next wider mode and recurse.  */
name|val
operator|=
name|convert_modes
argument_list|(
name|wsmode
argument_list|,
name|smode
argument_list|,
name|val
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|x
operator|=
name|expand_simple_binop
argument_list|(
name|wsmode
argument_list|,
name|ASHIFT
argument_list|,
name|val
argument_list|,
name|GEN_INT
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|smode
argument_list|)
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
name|val
operator|=
name|expand_simple_binop
argument_list|(
name|wsmode
argument_list|,
name|IOR
argument_list|,
name|val
argument_list|,
name|x
argument_list|,
name|x
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
name|x
operator|=
name|gen_reg_rtx
argument_list|(
name|wvmode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ix86_expand_vector_init_duplicate
argument_list|(
name|mmx_ok
argument_list|,
name|wvmode
argument_list|,
name|x
argument_list|,
name|val
argument_list|)
condition|)
name|gcc_unreachable
argument_list|()
expr_stmt|;
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|gen_lowpart
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
default|default:
return|return
name|false
return|;
block|}
block|}
end_function

begin_comment
comment|/* A subroutine of ix86_expand_vector_init.  Store into TARGET a vector    whose ONE_VAR element is VAR, and other elements are zero.  Return true    if successful.  */
end_comment

begin_function
specifier|static
name|bool
name|ix86_expand_vector_init_one_nonzero
parameter_list|(
name|bool
name|mmx_ok
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|target
parameter_list|,
name|rtx
name|var
parameter_list|,
name|int
name|one_var
parameter_list|)
block|{
name|enum
name|machine_mode
name|vsimode
decl_stmt|;
name|rtx
name|new_target
decl_stmt|;
name|rtx
name|x
decl_stmt|,
name|tmp
decl_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|V2SFmode
case|:
case|case
name|V2SImode
case|:
if|if
condition|(
operator|!
name|mmx_ok
condition|)
return|return
name|false
return|;
comment|/* FALLTHRU */
case|case
name|V2DFmode
case|:
case|case
name|V2DImode
case|:
if|if
condition|(
name|one_var
operator|!=
literal|0
condition|)
return|return
name|false
return|;
name|var
operator|=
name|force_reg
argument_list|(
name|GET_MODE_INNER
argument_list|(
name|mode
argument_list|)
argument_list|,
name|var
argument_list|)
expr_stmt|;
name|x
operator|=
name|gen_rtx_VEC_CONCAT
argument_list|(
name|mode
argument_list|,
name|var
argument_list|,
name|CONST0_RTX
argument_list|(
name|GET_MODE_INNER
argument_list|(
name|mode
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|,
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
case|case
name|V4SFmode
case|:
case|case
name|V4SImode
case|:
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|target
argument_list|)
operator|||
name|REGNO
argument_list|(
name|target
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|new_target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
else|else
name|new_target
operator|=
name|target
expr_stmt|;
name|var
operator|=
name|force_reg
argument_list|(
name|GET_MODE_INNER
argument_list|(
name|mode
argument_list|)
argument_list|,
name|var
argument_list|)
expr_stmt|;
name|x
operator|=
name|gen_rtx_VEC_DUPLICATE
argument_list|(
name|mode
argument_list|,
name|var
argument_list|)
expr_stmt|;
name|x
operator|=
name|gen_rtx_VEC_MERGE
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
argument_list|,
name|const1_rtx
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|new_target
argument_list|,
name|x
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|one_var
operator|!=
literal|0
condition|)
block|{
comment|/* We need to shuffle the value to the correct position, so 	     create a new pseudo to store the intermediate result.  */
comment|/* With SSE2, we can use the integer shuffle insns.  */
if|if
condition|(
name|mode
operator|!=
name|V4SFmode
operator|&&
name|TARGET_SSE2
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_sse2_pshufd_1
argument_list|(
name|new_target
argument_list|,
name|new_target
argument_list|,
name|GEN_INT
argument_list|(
literal|1
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|one_var
operator|==
literal|1
condition|?
literal|0
else|:
literal|1
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|one_var
operator|==
literal|2
condition|?
literal|0
else|:
literal|1
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|one_var
operator|==
literal|3
condition|?
literal|0
else|:
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|!=
name|new_target
condition|)
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|new_target
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* Otherwise convert the intermediate result to V4SFmode and 	     use the SSE1 shuffle instructions.  */
if|if
condition|(
name|mode
operator|!=
name|V4SFmode
condition|)
block|{
name|tmp
operator|=
name|gen_reg_rtx
argument_list|(
name|V4SFmode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|tmp
argument_list|,
name|gen_lowpart
argument_list|(
name|V4SFmode
argument_list|,
name|new_target
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|tmp
operator|=
name|new_target
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_sse_shufps_1
argument_list|(
name|tmp
argument_list|,
name|tmp
argument_list|,
name|tmp
argument_list|,
name|GEN_INT
argument_list|(
literal|1
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|one_var
operator|==
literal|1
condition|?
literal|0
else|:
literal|1
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|one_var
operator|==
literal|2
condition|?
literal|0
operator|+
literal|4
else|:
literal|1
operator|+
literal|4
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|one_var
operator|==
literal|3
condition|?
literal|0
operator|+
literal|4
else|:
literal|1
operator|+
literal|4
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|V4SFmode
condition|)
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|gen_lowpart
argument_list|(
name|V4SImode
argument_list|,
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tmp
operator|!=
name|target
condition|)
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|target
operator|!=
name|new_target
condition|)
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|new_target
argument_list|)
expr_stmt|;
return|return
name|true
return|;
case|case
name|V8HImode
case|:
case|case
name|V16QImode
case|:
name|vsimode
operator|=
name|V4SImode
expr_stmt|;
goto|goto
name|widen
goto|;
case|case
name|V4HImode
case|:
case|case
name|V8QImode
case|:
if|if
condition|(
operator|!
name|mmx_ok
condition|)
return|return
name|false
return|;
name|vsimode
operator|=
name|V2SImode
expr_stmt|;
goto|goto
name|widen
goto|;
name|widen
label|:
if|if
condition|(
name|one_var
operator|!=
literal|0
condition|)
return|return
name|false
return|;
comment|/* Zero extend the variable element to SImode and recurse.  */
name|var
operator|=
name|convert_modes
argument_list|(
name|SImode
argument_list|,
name|GET_MODE_INNER
argument_list|(
name|mode
argument_list|)
argument_list|,
name|var
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|x
operator|=
name|gen_reg_rtx
argument_list|(
name|vsimode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ix86_expand_vector_init_one_nonzero
argument_list|(
name|mmx_ok
argument_list|,
name|vsimode
argument_list|,
name|x
argument_list|,
name|var
argument_list|,
name|one_var
argument_list|)
condition|)
name|gcc_unreachable
argument_list|()
expr_stmt|;
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|gen_lowpart
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
default|default:
return|return
name|false
return|;
block|}
block|}
end_function

begin_comment
comment|/* A subroutine of ix86_expand_vector_init.  Store into TARGET a vector    consisting of the values in VALS.  It is known that all elements    except ONE_VAR are constants.  Return true if successful.  */
end_comment

begin_function
specifier|static
name|bool
name|ix86_expand_vector_init_one_var
parameter_list|(
name|bool
name|mmx_ok
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|target
parameter_list|,
name|rtx
name|vals
parameter_list|,
name|int
name|one_var
parameter_list|)
block|{
name|rtx
name|var
init|=
name|XVECEXP
argument_list|(
name|vals
argument_list|,
literal|0
argument_list|,
name|one_var
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|wmode
decl_stmt|;
name|rtx
name|const_vec
decl_stmt|,
name|x
decl_stmt|;
name|const_vec
operator|=
name|copy_rtx
argument_list|(
name|vals
argument_list|)
expr_stmt|;
name|XVECEXP
argument_list|(
name|const_vec
argument_list|,
literal|0
argument_list|,
name|one_var
argument_list|)
operator|=
name|CONST0_RTX
argument_list|(
name|GET_MODE_INNER
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
name|const_vec
operator|=
name|gen_rtx_CONST_VECTOR
argument_list|(
name|mode
argument_list|,
name|XVEC
argument_list|(
name|const_vec
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|V2DFmode
case|:
case|case
name|V2DImode
case|:
case|case
name|V2SFmode
case|:
case|case
name|V2SImode
case|:
comment|/* For the two element vectors, it's just as easy to use 	 the general case.  */
return|return
name|false
return|;
case|case
name|V4SFmode
case|:
case|case
name|V4SImode
case|:
case|case
name|V8HImode
case|:
case|case
name|V4HImode
case|:
break|break;
case|case
name|V16QImode
case|:
name|wmode
operator|=
name|V8HImode
expr_stmt|;
goto|goto
name|widen
goto|;
case|case
name|V8QImode
case|:
name|wmode
operator|=
name|V4HImode
expr_stmt|;
goto|goto
name|widen
goto|;
name|widen
label|:
comment|/* There's no way to set one QImode entry easily.  Combine 	 the variable value with its adjacent constant value, and 	 promote to an HImode set.  */
name|x
operator|=
name|XVECEXP
argument_list|(
name|vals
argument_list|,
literal|0
argument_list|,
name|one_var
operator|^
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|one_var
operator|&
literal|1
condition|)
block|{
name|var
operator|=
name|convert_modes
argument_list|(
name|HImode
argument_list|,
name|QImode
argument_list|,
name|var
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|var
operator|=
name|expand_simple_binop
argument_list|(
name|HImode
argument_list|,
name|ASHIFT
argument_list|,
name|var
argument_list|,
name|GEN_INT
argument_list|(
literal|8
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
name|x
operator|=
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|var
operator|=
name|convert_modes
argument_list|(
name|HImode
argument_list|,
name|QImode
argument_list|,
name|var
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|x
operator|=
name|gen_int_mode
argument_list|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|<<
literal|8
argument_list|,
name|HImode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|x
operator|!=
name|const0_rtx
condition|)
name|var
operator|=
name|expand_simple_binop
argument_list|(
name|HImode
argument_list|,
name|IOR
argument_list|,
name|var
argument_list|,
name|x
argument_list|,
name|var
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
name|x
operator|=
name|gen_reg_rtx
argument_list|(
name|wmode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|x
argument_list|,
name|gen_lowpart
argument_list|(
name|wmode
argument_list|,
name|const_vec
argument_list|)
argument_list|)
expr_stmt|;
name|ix86_expand_vector_set
argument_list|(
name|mmx_ok
argument_list|,
name|x
argument_list|,
name|var
argument_list|,
name|one_var
operator|>>
literal|1
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|gen_lowpart
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
default|default:
return|return
name|false
return|;
block|}
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|const_vec
argument_list|)
expr_stmt|;
name|ix86_expand_vector_set
argument_list|(
name|mmx_ok
argument_list|,
name|target
argument_list|,
name|var
argument_list|,
name|one_var
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of ix86_expand_vector_init.  Handle the most general case:    all values variable, and none identical.  */
end_comment

begin_function
specifier|static
name|void
name|ix86_expand_vector_init_general
parameter_list|(
name|bool
name|mmx_ok
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|target
parameter_list|,
name|rtx
name|vals
parameter_list|)
block|{
name|enum
name|machine_mode
name|half_mode
init|=
name|GET_MODE_INNER
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|rtx
name|op0
init|=
name|NULL
decl_stmt|,
name|op1
init|=
name|NULL
decl_stmt|;
name|bool
name|use_vec_concat
init|=
name|false
decl_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|V2SFmode
case|:
case|case
name|V2SImode
case|:
if|if
condition|(
operator|!
name|mmx_ok
operator|&&
operator|!
name|TARGET_SSE
condition|)
break|break;
comment|/* FALLTHRU */
case|case
name|V2DFmode
case|:
case|case
name|V2DImode
case|:
comment|/* For the two element vectors, we always implement VEC_CONCAT.  */
name|op0
operator|=
name|XVECEXP
argument_list|(
name|vals
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|XVECEXP
argument_list|(
name|vals
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|use_vec_concat
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|V4SFmode
case|:
name|half_mode
operator|=
name|V2SFmode
expr_stmt|;
goto|goto
name|half
goto|;
case|case
name|V4SImode
case|:
name|half_mode
operator|=
name|V2SImode
expr_stmt|;
goto|goto
name|half
goto|;
name|half
label|:
block|{
name|rtvec
name|v
decl_stmt|;
comment|/* For V4SF and V4SI, we implement a concat of two V2 vectors. 	   Recurse to load the two halves.  */
name|op0
operator|=
name|gen_reg_rtx
argument_list|(
name|half_mode
argument_list|)
expr_stmt|;
name|v
operator|=
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|XVECEXP
argument_list|(
name|vals
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XVECEXP
argument_list|(
name|vals
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|ix86_expand_vector_init
argument_list|(
name|false
argument_list|,
name|op0
argument_list|,
name|gen_rtx_PARALLEL
argument_list|(
name|half_mode
argument_list|,
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|op1
operator|=
name|gen_reg_rtx
argument_list|(
name|half_mode
argument_list|)
expr_stmt|;
name|v
operator|=
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|XVECEXP
argument_list|(
name|vals
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
argument_list|,
name|XVECEXP
argument_list|(
name|vals
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|ix86_expand_vector_init
argument_list|(
name|false
argument_list|,
name|op1
argument_list|,
name|gen_rtx_PARALLEL
argument_list|(
name|half_mode
argument_list|,
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|use_vec_concat
operator|=
name|true
expr_stmt|;
block|}
break|break;
case|case
name|V8HImode
case|:
case|case
name|V16QImode
case|:
case|case
name|V4HImode
case|:
case|case
name|V8QImode
case|:
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|use_vec_concat
condition|)
block|{
if|if
condition|(
operator|!
name|register_operand
argument_list|(
name|op0
argument_list|,
name|half_mode
argument_list|)
condition|)
name|op0
operator|=
name|force_reg
argument_list|(
name|half_mode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|register_operand
argument_list|(
name|op1
argument_list|,
name|half_mode
argument_list|)
condition|)
name|op1
operator|=
name|force_reg
argument_list|(
name|half_mode
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|,
name|gen_rtx_VEC_CONCAT
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|n_elts
decl_stmt|,
name|n_words
decl_stmt|,
name|n_elt_per_word
decl_stmt|;
name|enum
name|machine_mode
name|inner_mode
decl_stmt|;
name|rtx
name|words
index|[
literal|4
index|]
decl_stmt|,
name|shift
decl_stmt|;
name|inner_mode
operator|=
name|GET_MODE_INNER
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|n_elts
operator|=
name|GET_MODE_NUNITS
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|n_words
operator|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|/
name|UNITS_PER_WORD
expr_stmt|;
name|n_elt_per_word
operator|=
name|n_elts
operator|/
name|n_words
expr_stmt|;
name|shift
operator|=
name|GEN_INT
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|inner_mode
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_words
condition|;
operator|++
name|i
control|)
block|{
name|rtx
name|word
init|=
name|NULL_RTX
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_elt_per_word
condition|;
operator|++
name|j
control|)
block|{
name|rtx
name|elt
init|=
name|XVECEXP
argument_list|(
name|vals
argument_list|,
literal|0
argument_list|,
operator|(
name|i
operator|+
literal|1
operator|)
operator|*
name|n_elt_per_word
operator|-
name|j
operator|-
literal|1
argument_list|)
decl_stmt|;
name|elt
operator|=
name|convert_modes
argument_list|(
name|word_mode
argument_list|,
name|inner_mode
argument_list|,
name|elt
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|==
literal|0
condition|)
name|word
operator|=
name|elt
expr_stmt|;
else|else
block|{
name|word
operator|=
name|expand_simple_binop
argument_list|(
name|word_mode
argument_list|,
name|ASHIFT
argument_list|,
name|word
argument_list|,
name|shift
argument_list|,
name|word
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
name|word
operator|=
name|expand_simple_binop
argument_list|(
name|word_mode
argument_list|,
name|IOR
argument_list|,
name|word
argument_list|,
name|elt
argument_list|,
name|word
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
block|}
block|}
name|words
index|[
name|i
index|]
operator|=
name|word
expr_stmt|;
block|}
if|if
condition|(
name|n_words
operator|==
literal|1
condition|)
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|gen_lowpart
argument_list|(
name|mode
argument_list|,
name|words
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|n_words
operator|==
literal|2
condition|)
block|{
name|rtx
name|tmp
init|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_lowpart
argument_list|(
name|word_mode
argument_list|,
name|tmp
argument_list|)
argument_list|,
name|words
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_highpart
argument_list|(
name|word_mode
argument_list|,
name|tmp
argument_list|)
argument_list|,
name|words
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n_words
operator|==
literal|4
condition|)
block|{
name|rtx
name|tmp
init|=
name|gen_reg_rtx
argument_list|(
name|V4SImode
argument_list|)
decl_stmt|;
name|vals
operator|=
name|gen_rtx_PARALLEL
argument_list|(
name|V4SImode
argument_list|,
name|gen_rtvec_v
argument_list|(
literal|4
argument_list|,
name|words
argument_list|)
argument_list|)
expr_stmt|;
name|ix86_expand_vector_init_general
argument_list|(
name|false
argument_list|,
name|V4SImode
argument_list|,
name|tmp
argument_list|,
name|vals
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|gen_lowpart
argument_list|(
name|mode
argument_list|,
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Initialize vector TARGET via VALS.  Suppress the use of MMX    instructions unless MMX_OK is true.  */
end_comment

begin_function
name|void
name|ix86_expand_vector_init
parameter_list|(
name|bool
name|mmx_ok
parameter_list|,
name|rtx
name|target
parameter_list|,
name|rtx
name|vals
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|target
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|inner_mode
init|=
name|GET_MODE_INNER
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|int
name|n_elts
init|=
name|GET_MODE_NUNITS
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|int
name|n_var
init|=
literal|0
decl_stmt|,
name|one_var
init|=
operator|-
literal|1
decl_stmt|;
name|bool
name|all_same
init|=
name|true
decl_stmt|,
name|all_const_zero
init|=
name|true
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rtx
name|x
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_elts
condition|;
operator|++
name|i
control|)
block|{
name|x
operator|=
name|XVECEXP
argument_list|(
name|vals
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
condition|)
name|n_var
operator|++
operator|,
name|one_var
operator|=
name|i
expr_stmt|;
elseif|else
if|if
condition|(
name|x
operator|!=
name|CONST0_RTX
argument_list|(
name|inner_mode
argument_list|)
condition|)
name|all_const_zero
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
operator|!
name|rtx_equal_p
argument_list|(
name|x
argument_list|,
name|XVECEXP
argument_list|(
name|vals
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|all_same
operator|=
name|false
expr_stmt|;
block|}
comment|/* Constants are best loaded from the constant pool.  */
if|if
condition|(
name|n_var
operator|==
literal|0
condition|)
block|{
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|gen_rtx_CONST_VECTOR
argument_list|(
name|mode
argument_list|,
name|XVEC
argument_list|(
name|vals
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If all values are identical, broadcast the value.  */
if|if
condition|(
name|all_same
operator|&&
name|ix86_expand_vector_init_duplicate
argument_list|(
name|mmx_ok
argument_list|,
name|mode
argument_list|,
name|target
argument_list|,
name|XVECEXP
argument_list|(
name|vals
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return;
comment|/* Values where only one field is non-constant are best loaded from      the pool and overwritten via move later.  */
if|if
condition|(
name|n_var
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|all_const_zero
operator|&&
name|ix86_expand_vector_init_one_nonzero
argument_list|(
name|mmx_ok
argument_list|,
name|mode
argument_list|,
name|target
argument_list|,
name|XVECEXP
argument_list|(
name|vals
argument_list|,
literal|0
argument_list|,
name|one_var
argument_list|)
argument_list|,
name|one_var
argument_list|)
condition|)
return|return;
if|if
condition|(
name|ix86_expand_vector_init_one_var
argument_list|(
name|mmx_ok
argument_list|,
name|mode
argument_list|,
name|target
argument_list|,
name|vals
argument_list|,
name|one_var
argument_list|)
condition|)
return|return;
block|}
name|ix86_expand_vector_init_general
argument_list|(
name|mmx_ok
argument_list|,
name|mode
argument_list|,
name|target
argument_list|,
name|vals
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ix86_expand_vector_set
parameter_list|(
name|bool
name|mmx_ok
parameter_list|,
name|rtx
name|target
parameter_list|,
name|rtx
name|val
parameter_list|,
name|int
name|elt
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|target
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|inner_mode
init|=
name|GET_MODE_INNER
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|bool
name|use_vec_merge
init|=
name|false
decl_stmt|;
name|rtx
name|tmp
decl_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|V2SFmode
case|:
case|case
name|V2SImode
case|:
if|if
condition|(
name|mmx_ok
condition|)
block|{
name|tmp
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE_INNER
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
name|ix86_expand_vector_extract
argument_list|(
name|true
argument_list|,
name|tmp
argument_list|,
name|target
argument_list|,
literal|1
operator|-
name|elt
argument_list|)
expr_stmt|;
if|if
condition|(
name|elt
operator|==
literal|0
condition|)
name|tmp
operator|=
name|gen_rtx_VEC_CONCAT
argument_list|(
name|mode
argument_list|,
name|tmp
argument_list|,
name|val
argument_list|)
expr_stmt|;
else|else
name|tmp
operator|=
name|gen_rtx_VEC_CONCAT
argument_list|(
name|mode
argument_list|,
name|val
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|,
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|V2DFmode
case|:
case|case
name|V2DImode
case|:
block|{
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
comment|/* For the two element vectors, we implement a VEC_CONCAT with 	   the extraction of the other element.  */
name|tmp
operator|=
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|GEN_INT
argument_list|(
literal|1
operator|-
name|elt
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_VEC_SELECT
argument_list|(
name|inner_mode
argument_list|,
name|target
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|elt
operator|==
literal|0
condition|)
name|op0
operator|=
name|val
operator|,
name|op1
operator|=
name|tmp
expr_stmt|;
else|else
name|op0
operator|=
name|tmp
operator|,
name|op1
operator|=
name|val
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_VEC_CONCAT
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|,
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|V4SFmode
case|:
switch|switch
condition|(
name|elt
condition|)
block|{
case|case
literal|0
case|:
name|use_vec_merge
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* tmp = target = A B C D */
name|tmp
operator|=
name|copy_to_reg
argument_list|(
name|target
argument_list|)
expr_stmt|;
comment|/* target = A A B B */
name|emit_insn
argument_list|(
name|gen_sse_unpcklps
argument_list|(
name|target
argument_list|,
name|target
argument_list|,
name|target
argument_list|)
argument_list|)
expr_stmt|;
comment|/* target = X A B B */
name|ix86_expand_vector_set
argument_list|(
name|false
argument_list|,
name|target
argument_list|,
name|val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* target = A X C D  */
name|emit_insn
argument_list|(
name|gen_sse_shufps_1
argument_list|(
name|target
argument_list|,
name|target
argument_list|,
name|tmp
argument_list|,
name|GEN_INT
argument_list|(
literal|1
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
literal|0
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
literal|2
operator|+
literal|4
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
literal|3
operator|+
literal|4
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
literal|2
case|:
comment|/* tmp = target = A B C D */
name|tmp
operator|=
name|copy_to_reg
argument_list|(
name|target
argument_list|)
expr_stmt|;
comment|/* tmp = X B C D */
name|ix86_expand_vector_set
argument_list|(
name|false
argument_list|,
name|tmp
argument_list|,
name|val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* target = A B X D */
name|emit_insn
argument_list|(
name|gen_sse_shufps_1
argument_list|(
name|target
argument_list|,
name|target
argument_list|,
name|tmp
argument_list|,
name|GEN_INT
argument_list|(
literal|0
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
literal|1
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
literal|0
operator|+
literal|4
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
literal|3
operator|+
literal|4
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
literal|3
case|:
comment|/* tmp = target = A B C D */
name|tmp
operator|=
name|copy_to_reg
argument_list|(
name|target
argument_list|)
expr_stmt|;
comment|/* tmp = X B C D */
name|ix86_expand_vector_set
argument_list|(
name|false
argument_list|,
name|tmp
argument_list|,
name|val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* target = A B X D */
name|emit_insn
argument_list|(
name|gen_sse_shufps_1
argument_list|(
name|target
argument_list|,
name|target
argument_list|,
name|tmp
argument_list|,
name|GEN_INT
argument_list|(
literal|0
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
literal|1
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
literal|2
operator|+
literal|4
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
literal|0
operator|+
literal|4
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|V4SImode
case|:
comment|/* Element 0 handled by vec_merge below.  */
if|if
condition|(
name|elt
operator|==
literal|0
condition|)
block|{
name|use_vec_merge
operator|=
name|true
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|TARGET_SSE2
condition|)
block|{
comment|/* With SSE2, use integer shuffles to swap element 0 and ELT, 	     store into element 0, then shuffle them back.  */
name|rtx
name|order
index|[
literal|4
index|]
decl_stmt|;
name|order
index|[
literal|0
index|]
operator|=
name|GEN_INT
argument_list|(
name|elt
argument_list|)
expr_stmt|;
name|order
index|[
literal|1
index|]
operator|=
name|const1_rtx
expr_stmt|;
name|order
index|[
literal|2
index|]
operator|=
name|const2_rtx
expr_stmt|;
name|order
index|[
literal|3
index|]
operator|=
name|GEN_INT
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|order
index|[
name|elt
index|]
operator|=
name|const0_rtx
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_sse2_pshufd_1
argument_list|(
name|target
argument_list|,
name|target
argument_list|,
name|order
index|[
literal|0
index|]
argument_list|,
name|order
index|[
literal|1
index|]
argument_list|,
name|order
index|[
literal|2
index|]
argument_list|,
name|order
index|[
literal|3
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ix86_expand_vector_set
argument_list|(
name|false
argument_list|,
name|target
argument_list|,
name|val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_sse2_pshufd_1
argument_list|(
name|target
argument_list|,
name|target
argument_list|,
name|order
index|[
literal|0
index|]
argument_list|,
name|order
index|[
literal|1
index|]
argument_list|,
name|order
index|[
literal|2
index|]
argument_list|,
name|order
index|[
literal|3
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* For SSE1, we have to reuse the V4SF code.  */
name|ix86_expand_vector_set
argument_list|(
name|false
argument_list|,
name|gen_lowpart
argument_list|(
name|V4SFmode
argument_list|,
name|target
argument_list|)
argument_list|,
name|gen_lowpart
argument_list|(
name|SFmode
argument_list|,
name|val
argument_list|)
argument_list|,
name|elt
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|V8HImode
case|:
name|use_vec_merge
operator|=
name|TARGET_SSE2
expr_stmt|;
break|break;
case|case
name|V4HImode
case|:
name|use_vec_merge
operator|=
name|mmx_ok
operator|&&
operator|(
name|TARGET_SSE
operator|||
name|TARGET_3DNOW_A
operator|)
expr_stmt|;
break|break;
case|case
name|V16QImode
case|:
case|case
name|V8QImode
case|:
default|default:
break|break;
block|}
if|if
condition|(
name|use_vec_merge
condition|)
block|{
name|tmp
operator|=
name|gen_rtx_VEC_DUPLICATE
argument_list|(
name|mode
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_VEC_MERGE
argument_list|(
name|mode
argument_list|,
name|tmp
argument_list|,
name|target
argument_list|,
name|GEN_INT
argument_list|(
literal|1
operator|<<
name|elt
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|,
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|mem
init|=
name|assign_stack_temp
argument_list|(
name|mode
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|,
name|false
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|adjust_address
argument_list|(
name|mem
argument_list|,
name|inner_mode
argument_list|,
name|elt
operator|*
name|GET_MODE_SIZE
argument_list|(
name|inner_mode
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|tmp
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|mem
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ix86_expand_vector_extract
parameter_list|(
name|bool
name|mmx_ok
parameter_list|,
name|rtx
name|target
parameter_list|,
name|rtx
name|vec
parameter_list|,
name|int
name|elt
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|vec
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|inner_mode
init|=
name|GET_MODE_INNER
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|bool
name|use_vec_extr
init|=
name|false
decl_stmt|;
name|rtx
name|tmp
decl_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|V2SImode
case|:
case|case
name|V2SFmode
case|:
if|if
condition|(
operator|!
name|mmx_ok
condition|)
break|break;
comment|/* FALLTHRU */
case|case
name|V2DFmode
case|:
case|case
name|V2DImode
case|:
name|use_vec_extr
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|V4SFmode
case|:
switch|switch
condition|(
name|elt
condition|)
block|{
case|case
literal|0
case|:
name|tmp
operator|=
name|vec
expr_stmt|;
break|break;
case|case
literal|1
case|:
case|case
literal|3
case|:
name|tmp
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_sse_shufps_1
argument_list|(
name|tmp
argument_list|,
name|vec
argument_list|,
name|vec
argument_list|,
name|GEN_INT
argument_list|(
name|elt
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|elt
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|elt
operator|+
literal|4
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|elt
operator|+
literal|4
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|tmp
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_sse_unpckhps
argument_list|(
name|tmp
argument_list|,
name|vec
argument_list|,
name|vec
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|vec
operator|=
name|tmp
expr_stmt|;
name|use_vec_extr
operator|=
name|true
expr_stmt|;
name|elt
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|V4SImode
case|:
if|if
condition|(
name|TARGET_SSE2
condition|)
block|{
switch|switch
condition|(
name|elt
condition|)
block|{
case|case
literal|0
case|:
name|tmp
operator|=
name|vec
expr_stmt|;
break|break;
case|case
literal|1
case|:
case|case
literal|3
case|:
name|tmp
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_sse2_pshufd_1
argument_list|(
name|tmp
argument_list|,
name|vec
argument_list|,
name|GEN_INT
argument_list|(
name|elt
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|elt
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|elt
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|elt
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|tmp
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_sse2_punpckhdq
argument_list|(
name|tmp
argument_list|,
name|vec
argument_list|,
name|vec
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|vec
operator|=
name|tmp
expr_stmt|;
name|use_vec_extr
operator|=
name|true
expr_stmt|;
name|elt
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* For SSE1, we have to reuse the V4SF code.  */
name|ix86_expand_vector_extract
argument_list|(
name|false
argument_list|,
name|gen_lowpart
argument_list|(
name|SFmode
argument_list|,
name|target
argument_list|)
argument_list|,
name|gen_lowpart
argument_list|(
name|V4SFmode
argument_list|,
name|vec
argument_list|)
argument_list|,
name|elt
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|V8HImode
case|:
name|use_vec_extr
operator|=
name|TARGET_SSE2
expr_stmt|;
break|break;
case|case
name|V4HImode
case|:
name|use_vec_extr
operator|=
name|mmx_ok
operator|&&
operator|(
name|TARGET_SSE
operator|||
name|TARGET_3DNOW_A
operator|)
expr_stmt|;
break|break;
case|case
name|V16QImode
case|:
case|case
name|V8QImode
case|:
comment|/* ??? Could extract the appropriate HImode element and shift.  */
default|default:
break|break;
block|}
if|if
condition|(
name|use_vec_extr
condition|)
block|{
name|tmp
operator|=
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|GEN_INT
argument_list|(
name|elt
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_VEC_SELECT
argument_list|(
name|inner_mode
argument_list|,
name|vec
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* Let the rtl optimizers know about the zero extension performed.  */
if|if
condition|(
name|inner_mode
operator|==
name|HImode
condition|)
block|{
name|tmp
operator|=
name|gen_rtx_ZERO_EXTEND
argument_list|(
name|SImode
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|target
operator|=
name|gen_lowpart
argument_list|(
name|SImode
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|,
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|mem
init|=
name|assign_stack_temp
argument_list|(
name|mode
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|,
name|false
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|vec
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|adjust_address
argument_list|(
name|mem
argument_list|,
name|inner_mode
argument_list|,
name|elt
operator|*
name|GET_MODE_SIZE
argument_list|(
name|inner_mode
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Expand a vector reduction on V4SFmode for SSE1.  FN is the binary    pattern to reduce; DEST is the destination; IN is the input vector.  */
end_comment

begin_function
name|void
name|ix86_expand_reduc_v4sf
parameter_list|(
name|rtx
function_decl|(
modifier|*
name|fn
function_decl|)
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
parameter_list|,
name|rtx
name|dest
parameter_list|,
name|rtx
name|in
parameter_list|)
block|{
name|rtx
name|tmp1
decl_stmt|,
name|tmp2
decl_stmt|,
name|tmp3
decl_stmt|;
name|tmp1
operator|=
name|gen_reg_rtx
argument_list|(
name|V4SFmode
argument_list|)
expr_stmt|;
name|tmp2
operator|=
name|gen_reg_rtx
argument_list|(
name|V4SFmode
argument_list|)
expr_stmt|;
name|tmp3
operator|=
name|gen_reg_rtx
argument_list|(
name|V4SFmode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_sse_movhlps
argument_list|(
name|tmp1
argument_list|,
name|in
argument_list|,
name|in
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|fn
argument_list|(
name|tmp2
argument_list|,
name|tmp1
argument_list|,
name|in
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_sse_shufps_1
argument_list|(
name|tmp3
argument_list|,
name|tmp2
argument_list|,
name|tmp2
argument_list|,
name|GEN_INT
argument_list|(
literal|1
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
literal|1
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
literal|1
operator|+
literal|4
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
literal|1
operator|+
literal|4
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|fn
argument_list|(
name|dest
argument_list|,
name|tmp2
argument_list|,
name|tmp3
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Target hook for scalar_mode_supported_p.  */
end_comment

begin_function
specifier|static
name|bool
name|ix86_scalar_mode_supported_p
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|DECIMAL_FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|true
return|;
else|else
return|return
name|default_scalar_mode_supported_p
argument_list|(
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Implements target hook vector_mode_supported_p.  */
end_comment

begin_function
specifier|static
name|bool
name|ix86_vector_mode_supported_p
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|TARGET_SSE
operator|&&
name|VALID_SSE_REG_MODE
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|TARGET_SSE2
operator|&&
name|VALID_SSE2_REG_MODE
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|TARGET_MMX
operator|&&
name|VALID_MMX_REG_MODE
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|TARGET_3DNOW
operator|&&
name|VALID_MMX_REG_MODE_3DNOW
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Worker function for TARGET_MD_ASM_CLOBBERS.     We do this in the new i386 backend to maintain source compatibility    with the old cc0-based compiler.  */
end_comment

begin_function
specifier|static
name|tree
name|ix86_md_asm_clobbers
parameter_list|(
name|tree
name|outputs
name|ATTRIBUTE_UNUSED
parameter_list|,
name|tree
name|inputs
name|ATTRIBUTE_UNUSED
parameter_list|,
name|tree
name|clobbers
parameter_list|)
block|{
name|clobbers
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_string
argument_list|(
literal|5
argument_list|,
literal|"flags"
argument_list|)
argument_list|,
name|clobbers
argument_list|)
expr_stmt|;
name|clobbers
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_string
argument_list|(
literal|4
argument_list|,
literal|"fpsr"
argument_list|)
argument_list|,
name|clobbers
argument_list|)
expr_stmt|;
name|clobbers
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_string
argument_list|(
literal|7
argument_list|,
literal|"dirflag"
argument_list|)
argument_list|,
name|clobbers
argument_list|)
expr_stmt|;
return|return
name|clobbers
return|;
block|}
end_function

begin_comment
comment|/* Return true if this goes in small data/bss.  */
end_comment

begin_function
specifier|static
name|bool
name|ix86_in_large_data_p
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
if|if
condition|(
name|ix86_cmodel
operator|!=
name|CM_MEDIUM
operator|&&
name|ix86_cmodel
operator|!=
name|CM_MEDIUM_PIC
condition|)
return|return
name|false
return|;
comment|/* Functions are never large data.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
return|return
name|false
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_SECTION_NAME
argument_list|(
name|exp
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|section
init|=
name|TREE_STRING_POINTER
argument_list|(
name|DECL_SECTION_NAME
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|section
argument_list|,
literal|".ldata"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|section
argument_list|,
literal|".lbss"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
else|else
block|{
name|HOST_WIDE_INT
name|size
init|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
comment|/* If this is an incomplete type with size 0, then we can't put it 	 in data because it might be too big when completed.  */
if|if
condition|(
operator|!
name|size
operator|||
name|size
operator|>
name|ix86_section_threshold
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ix86_encode_section_info
parameter_list|(
name|tree
name|decl
parameter_list|,
name|rtx
name|rtl
parameter_list|,
name|int
name|first
parameter_list|)
block|{
name|default_encode_section_info
argument_list|(
name|decl
argument_list|,
name|rtl
argument_list|,
name|first
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
operator|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|||
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|)
operator|&&
name|ix86_in_large_data_p
argument_list|(
name|decl
argument_list|)
condition|)
name|SYMBOL_REF_FLAGS
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator||=
name|SYMBOL_FLAG_FAR_ADDR
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Worker function for REVERSE_CONDITION.  */
end_comment

begin_function
name|enum
name|rtx_code
name|ix86_reverse_condition
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
return|return
operator|(
name|mode
operator|!=
name|CCFPmode
operator|&&
name|mode
operator|!=
name|CCFPUmode
condition|?
name|reverse_condition
argument_list|(
name|code
argument_list|)
else|:
name|reverse_condition_maybe_unordered
argument_list|(
name|code
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Output code to perform an x87 FP register move, from OPERANDS[1]    to OPERANDS[0].  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|output_387_reg_move
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
modifier|*
name|operands
parameter_list|)
block|{
if|if
condition|(
name|REG_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|&&
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|FIRST_STACK_REG
condition|)
return|return
name|output_387_ffreep
argument_list|(
name|operands
argument_list|,
literal|0
argument_list|)
return|;
return|return
literal|"fstp\t%y0"
return|;
block|}
if|if
condition|(
name|STACK_TOP_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
literal|"fld%z1\t%y1"
return|;
return|return
literal|"fst\t%y0"
return|;
block|}
end_function

begin_comment
comment|/* Output code to perform a conditional jump to LABEL, if C2 flag in    FP status register is set.  */
end_comment

begin_function
name|void
name|ix86_emit_fp_unordered_jump
parameter_list|(
name|rtx
name|label
parameter_list|)
block|{
name|rtx
name|reg
init|=
name|gen_reg_rtx
argument_list|(
name|HImode
argument_list|)
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_x86_fnstsw_1
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_USE_SAHF
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_x86_sahf_1
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|=
name|gen_rtx_REG
argument_list|(
name|CCmode
argument_list|,
name|FLAGS_REG
argument_list|)
expr_stmt|;
name|temp
operator|=
name|gen_rtx_UNORDERED
argument_list|(
name|VOIDmode
argument_list|,
name|temp
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|emit_insn
argument_list|(
name|gen_testqi_ext_ccno_0
argument_list|(
name|reg
argument_list|,
name|GEN_INT
argument_list|(
literal|0x04
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|=
name|gen_rtx_REG
argument_list|(
name|CCNOmode
argument_list|,
name|FLAGS_REG
argument_list|)
expr_stmt|;
name|temp
operator|=
name|gen_rtx_NE
argument_list|(
name|VOIDmode
argument_list|,
name|temp
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
block|}
name|temp
operator|=
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|VOIDmode
argument_list|,
name|temp
argument_list|,
name|gen_rtx_LABEL_REF
argument_list|(
name|VOIDmode
argument_list|,
name|label
argument_list|)
argument_list|,
name|pc_rtx
argument_list|)
expr_stmt|;
name|temp
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|pc_rtx
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output code to perform a log1p XFmode calculation.  */
end_comment

begin_function
name|void
name|ix86_emit_i387_log1p
parameter_list|(
name|rtx
name|op0
parameter_list|,
name|rtx
name|op1
parameter_list|)
block|{
name|rtx
name|label1
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|rtx
name|label2
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|rtx
name|tmp
init|=
name|gen_reg_rtx
argument_list|(
name|XFmode
argument_list|)
decl_stmt|;
name|rtx
name|tmp2
init|=
name|gen_reg_rtx
argument_list|(
name|XFmode
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_absxf2
argument_list|(
name|tmp
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_cmpxf
argument_list|(
name|tmp
argument_list|,
name|CONST_DOUBLE_FROM_REAL_VALUE
argument_list|(
name|REAL_VALUE_ATOF
argument_list|(
literal|"0.29289321881345247561810596348408353"
argument_list|,
name|XFmode
argument_list|)
argument_list|,
name|XFmode
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_bge
argument_list|(
name|label1
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|tmp2
argument_list|,
name|standard_80387_constant_rtx
argument_list|(
literal|4
argument_list|)
argument_list|)
expr_stmt|;
comment|/* fldln2 */
name|emit_insn
argument_list|(
name|gen_fyl2xp1_xf3
argument_list|(
name|op0
argument_list|,
name|tmp2
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
name|emit_jump
argument_list|(
name|label2
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|label1
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|tmp
argument_list|,
name|CONST1_RTX
argument_list|(
name|XFmode
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_addxf3
argument_list|(
name|tmp
argument_list|,
name|op1
argument_list|,
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|tmp2
argument_list|,
name|standard_80387_constant_rtx
argument_list|(
literal|4
argument_list|)
argument_list|)
expr_stmt|;
comment|/* fldln2 */
name|emit_insn
argument_list|(
name|gen_fyl2x_xf3
argument_list|(
name|op0
argument_list|,
name|tmp2
argument_list|,
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|label2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Solaris implementation of TARGET_ASM_NAMED_SECTION.  */
end_comment

begin_function
specifier|static
name|void
name|i386_solaris_elf_named_section
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|,
name|tree
name|decl
parameter_list|)
block|{
comment|/* With Binutils 2.15, the "@unwind" marker must be specified on      every occurrence of the ".eh_frame" section, not just the first      one.  */
if|if
condition|(
name|TARGET_64BIT
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".eh_frame"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.section\t%s,\"%s\",@unwind\n"
argument_list|,
name|name
argument_list|,
name|flags
operator|&
name|SECTION_WRITE
condition|?
literal|"aw"
else|:
literal|"a"
argument_list|)
expr_stmt|;
return|return;
block|}
name|default_elf_asm_named_section
argument_list|(
name|name
argument_list|,
name|flags
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the mangling of TYPE if it is an extended fundamental type.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|ix86_mangle_fundamental_type
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|TFmode
case|:
comment|/* __float128 is "g".  */
return|return
literal|"g"
return|;
case|case
name|XFmode
case|:
comment|/* "long double" or __float80 is "e".  */
return|return
literal|"e"
return|;
default|default:
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_comment
comment|/* For 32-bit code we can save PIC register setup by using    __stack_chk_fail_local hidden function instead of calling    __stack_chk_fail directly.  64-bit code doesn't need to setup any PIC    register, so it is better to call __stack_chk_fail directly.  */
end_comment

begin_function
specifier|static
name|tree
name|ix86_stack_protect_fail
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|TARGET_64BIT
condition|?
name|default_external_stack_protect_fail
argument_list|()
else|:
name|default_hidden_stack_protect_fail
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/* Select a format to encode pointers in exception handling data.  CODE    is 0 for data, 1 for code labels, 2 for function pointers.  GLOBAL is    true if the symbol may be affected by dynamic relocations.     ??? All x86 object file formats are capable of representing this.    After all, the relocation needed is the same as for the call insn.    Whether or not a particular assembler allows us to enter such, I    guess we'll have to see.  */
end_comment

begin_function
name|int
name|asm_preferred_eh_data_format
parameter_list|(
name|int
name|code
parameter_list|,
name|int
name|global
parameter_list|)
block|{
if|if
condition|(
name|flag_pic
condition|)
block|{
name|int
name|type
init|=
name|DW_EH_PE_sdata8
decl_stmt|;
if|if
condition|(
operator|!
name|TARGET_64BIT
operator|||
name|ix86_cmodel
operator|==
name|CM_SMALL_PIC
operator|||
operator|(
name|ix86_cmodel
operator|==
name|CM_MEDIUM_PIC
operator|&&
operator|(
name|global
operator|||
name|code
operator|)
operator|)
condition|)
name|type
operator|=
name|DW_EH_PE_sdata4
expr_stmt|;
return|return
operator|(
name|global
condition|?
name|DW_EH_PE_indirect
else|:
literal|0
operator|)
operator||
name|DW_EH_PE_pcrel
operator||
name|type
return|;
block|}
if|if
condition|(
name|ix86_cmodel
operator|==
name|CM_SMALL
operator|||
operator|(
name|ix86_cmodel
operator|==
name|CM_MEDIUM
operator|&&
name|code
operator|)
condition|)
return|return
name|DW_EH_PE_udata4
return|;
return|return
name|DW_EH_PE_absptr
return|;
block|}
end_function

begin_include
include|#
directive|include
file|"gt-i386.h"
end_include

end_unit

