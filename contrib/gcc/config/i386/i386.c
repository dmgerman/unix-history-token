begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Subroutines used for code generation on IA-32.    Copyright (C) 1988, 1992, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,    2002 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"conditions.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"optabs.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"target-def.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|CHECK_STACK_LIMIT
end_ifndef

begin_define
define|#
directive|define
name|CHECK_STACK_LIMIT
value|(-1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_warning
warning|#
directive|warning
warning|NEED TO REVISIT "PIC_REG_USED" AND -mprofiler-epilogue SUPPORT
end_warning

begin_if
if|#
directive|if
literal|0
end_if

begin_define
define|#
directive|define
name|PIC_REG_USED
define|\
value|(flag_pic&& (current_function_uses_pic_offset_table	\ 		|| current_function_uses_const_pool	\ 		|| profile_flag || profile_block_flag))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Processor costs (relative to an add) */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|processor_costs
name|size_cost
init|=
block|{
comment|/* costs for tunning for size */
literal|2
block|,
comment|/* cost of an add instruction */
literal|3
block|,
comment|/* cost of a lea instruction */
literal|2
block|,
comment|/* variable shift costs */
literal|3
block|,
comment|/* constant shift costs */
literal|3
block|,
comment|/* cost of starting a multiply */
literal|0
block|,
comment|/* cost of multiply per each bit set */
literal|3
block|,
comment|/* cost of a divide/mod */
literal|3
block|,
comment|/* cost of movsx */
literal|3
block|,
comment|/* cost of movzx */
literal|0
block|,
comment|/* "large" insn */
literal|2
block|,
comment|/* MOVE_RATIO */
literal|2
block|,
comment|/* cost for loading QImode using movzbl */
block|{
literal|2
block|,
literal|2
block|,
literal|2
block|}
block|,
comment|/* cost of loading integer registers 					   in QImode, HImode and SImode. 					   Relative to reg-reg move (2).  */
block|{
literal|2
block|,
literal|2
block|,
literal|2
block|}
block|,
comment|/* cost of storing integer registers */
literal|2
block|,
comment|/* cost of reg,reg fld/fst */
block|{
literal|2
block|,
literal|2
block|,
literal|2
block|}
block|,
comment|/* cost of loading fp registers 					   in SFmode, DFmode and XFmode */
block|{
literal|2
block|,
literal|2
block|,
literal|2
block|}
block|,
comment|/* cost of loading integer registers */
literal|3
block|,
comment|/* cost of moving MMX register */
block|{
literal|3
block|,
literal|3
block|}
block|,
comment|/* cost of loading MMX registers 					   in SImode and DImode */
block|{
literal|3
block|,
literal|3
block|}
block|,
comment|/* cost of storing MMX registers 					   in SImode and DImode */
literal|3
block|,
comment|/* cost of moving SSE register */
block|{
literal|3
block|,
literal|3
block|,
literal|3
block|}
block|,
comment|/* cost of loading SSE registers 					   in SImode, DImode and TImode */
block|{
literal|3
block|,
literal|3
block|,
literal|3
block|}
block|,
comment|/* cost of storing SSE registers 					   in SImode, DImode and TImode */
literal|3
block|,
comment|/* MMX or SSE register to integer */
literal|0
block|,
comment|/* size of prefetch block */
literal|0
block|,
comment|/* number of parallel prefetches */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Processor costs (relative to an add) */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|processor_costs
name|i386_cost
init|=
block|{
comment|/* 386 specific costs */
literal|1
block|,
comment|/* cost of an add instruction */
literal|1
block|,
comment|/* cost of a lea instruction */
literal|3
block|,
comment|/* variable shift costs */
literal|2
block|,
comment|/* constant shift costs */
literal|6
block|,
comment|/* cost of starting a multiply */
literal|1
block|,
comment|/* cost of multiply per each bit set */
literal|23
block|,
comment|/* cost of a divide/mod */
literal|3
block|,
comment|/* cost of movsx */
literal|2
block|,
comment|/* cost of movzx */
literal|15
block|,
comment|/* "large" insn */
literal|3
block|,
comment|/* MOVE_RATIO */
literal|4
block|,
comment|/* cost for loading QImode using movzbl */
block|{
literal|2
block|,
literal|4
block|,
literal|2
block|}
block|,
comment|/* cost of loading integer registers 					   in QImode, HImode and SImode. 					   Relative to reg-reg move (2).  */
block|{
literal|2
block|,
literal|4
block|,
literal|2
block|}
block|,
comment|/* cost of storing integer registers */
literal|2
block|,
comment|/* cost of reg,reg fld/fst */
block|{
literal|8
block|,
literal|8
block|,
literal|8
block|}
block|,
comment|/* cost of loading fp registers 					   in SFmode, DFmode and XFmode */
block|{
literal|8
block|,
literal|8
block|,
literal|8
block|}
block|,
comment|/* cost of loading integer registers */
literal|2
block|,
comment|/* cost of moving MMX register */
block|{
literal|4
block|,
literal|8
block|}
block|,
comment|/* cost of loading MMX registers 					   in SImode and DImode */
block|{
literal|4
block|,
literal|8
block|}
block|,
comment|/* cost of storing MMX registers 					   in SImode and DImode */
literal|2
block|,
comment|/* cost of moving SSE register */
block|{
literal|4
block|,
literal|8
block|,
literal|16
block|}
block|,
comment|/* cost of loading SSE registers 					   in SImode, DImode and TImode */
block|{
literal|4
block|,
literal|8
block|,
literal|16
block|}
block|,
comment|/* cost of storing SSE registers 					   in SImode, DImode and TImode */
literal|3
block|,
comment|/* MMX or SSE register to integer */
literal|0
block|,
comment|/* size of prefetch block */
literal|0
block|,
comment|/* number of parallel prefetches */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|processor_costs
name|i486_cost
init|=
block|{
comment|/* 486 specific costs */
literal|1
block|,
comment|/* cost of an add instruction */
literal|1
block|,
comment|/* cost of a lea instruction */
literal|3
block|,
comment|/* variable shift costs */
literal|2
block|,
comment|/* constant shift costs */
literal|12
block|,
comment|/* cost of starting a multiply */
literal|1
block|,
comment|/* cost of multiply per each bit set */
literal|40
block|,
comment|/* cost of a divide/mod */
literal|3
block|,
comment|/* cost of movsx */
literal|2
block|,
comment|/* cost of movzx */
literal|15
block|,
comment|/* "large" insn */
literal|3
block|,
comment|/* MOVE_RATIO */
literal|4
block|,
comment|/* cost for loading QImode using movzbl */
block|{
literal|2
block|,
literal|4
block|,
literal|2
block|}
block|,
comment|/* cost of loading integer registers 					   in QImode, HImode and SImode. 					   Relative to reg-reg move (2).  */
block|{
literal|2
block|,
literal|4
block|,
literal|2
block|}
block|,
comment|/* cost of storing integer registers */
literal|2
block|,
comment|/* cost of reg,reg fld/fst */
block|{
literal|8
block|,
literal|8
block|,
literal|8
block|}
block|,
comment|/* cost of loading fp registers 					   in SFmode, DFmode and XFmode */
block|{
literal|8
block|,
literal|8
block|,
literal|8
block|}
block|,
comment|/* cost of loading integer registers */
literal|2
block|,
comment|/* cost of moving MMX register */
block|{
literal|4
block|,
literal|8
block|}
block|,
comment|/* cost of loading MMX registers 					   in SImode and DImode */
block|{
literal|4
block|,
literal|8
block|}
block|,
comment|/* cost of storing MMX registers 					   in SImode and DImode */
literal|2
block|,
comment|/* cost of moving SSE register */
block|{
literal|4
block|,
literal|8
block|,
literal|16
block|}
block|,
comment|/* cost of loading SSE registers 					   in SImode, DImode and TImode */
block|{
literal|4
block|,
literal|8
block|,
literal|16
block|}
block|,
comment|/* cost of storing SSE registers 					   in SImode, DImode and TImode */
literal|3
block|,
comment|/* MMX or SSE register to integer */
literal|0
block|,
comment|/* size of prefetch block */
literal|0
block|,
comment|/* number of parallel prefetches */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|processor_costs
name|pentium_cost
init|=
block|{
literal|1
block|,
comment|/* cost of an add instruction */
literal|1
block|,
comment|/* cost of a lea instruction */
literal|4
block|,
comment|/* variable shift costs */
literal|1
block|,
comment|/* constant shift costs */
literal|11
block|,
comment|/* cost of starting a multiply */
literal|0
block|,
comment|/* cost of multiply per each bit set */
literal|25
block|,
comment|/* cost of a divide/mod */
literal|3
block|,
comment|/* cost of movsx */
literal|2
block|,
comment|/* cost of movzx */
literal|8
block|,
comment|/* "large" insn */
literal|6
block|,
comment|/* MOVE_RATIO */
literal|6
block|,
comment|/* cost for loading QImode using movzbl */
block|{
literal|2
block|,
literal|4
block|,
literal|2
block|}
block|,
comment|/* cost of loading integer registers 					   in QImode, HImode and SImode. 					   Relative to reg-reg move (2).  */
block|{
literal|2
block|,
literal|4
block|,
literal|2
block|}
block|,
comment|/* cost of storing integer registers */
literal|2
block|,
comment|/* cost of reg,reg fld/fst */
block|{
literal|2
block|,
literal|2
block|,
literal|6
block|}
block|,
comment|/* cost of loading fp registers 					   in SFmode, DFmode and XFmode */
block|{
literal|4
block|,
literal|4
block|,
literal|6
block|}
block|,
comment|/* cost of loading integer registers */
literal|8
block|,
comment|/* cost of moving MMX register */
block|{
literal|8
block|,
literal|8
block|}
block|,
comment|/* cost of loading MMX registers 					   in SImode and DImode */
block|{
literal|8
block|,
literal|8
block|}
block|,
comment|/* cost of storing MMX registers 					   in SImode and DImode */
literal|2
block|,
comment|/* cost of moving SSE register */
block|{
literal|4
block|,
literal|8
block|,
literal|16
block|}
block|,
comment|/* cost of loading SSE registers 					   in SImode, DImode and TImode */
block|{
literal|4
block|,
literal|8
block|,
literal|16
block|}
block|,
comment|/* cost of storing SSE registers 					   in SImode, DImode and TImode */
literal|3
block|,
comment|/* MMX or SSE register to integer */
literal|0
block|,
comment|/* size of prefetch block */
literal|0
block|,
comment|/* number of parallel prefetches */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|processor_costs
name|pentiumpro_cost
init|=
block|{
literal|1
block|,
comment|/* cost of an add instruction */
literal|1
block|,
comment|/* cost of a lea instruction */
literal|1
block|,
comment|/* variable shift costs */
literal|1
block|,
comment|/* constant shift costs */
literal|4
block|,
comment|/* cost of starting a multiply */
literal|0
block|,
comment|/* cost of multiply per each bit set */
literal|17
block|,
comment|/* cost of a divide/mod */
literal|1
block|,
comment|/* cost of movsx */
literal|1
block|,
comment|/* cost of movzx */
literal|8
block|,
comment|/* "large" insn */
literal|6
block|,
comment|/* MOVE_RATIO */
literal|2
block|,
comment|/* cost for loading QImode using movzbl */
block|{
literal|4
block|,
literal|4
block|,
literal|4
block|}
block|,
comment|/* cost of loading integer registers 					   in QImode, HImode and SImode. 					   Relative to reg-reg move (2).  */
block|{
literal|2
block|,
literal|2
block|,
literal|2
block|}
block|,
comment|/* cost of storing integer registers */
literal|2
block|,
comment|/* cost of reg,reg fld/fst */
block|{
literal|2
block|,
literal|2
block|,
literal|6
block|}
block|,
comment|/* cost of loading fp registers 					   in SFmode, DFmode and XFmode */
block|{
literal|4
block|,
literal|4
block|,
literal|6
block|}
block|,
comment|/* cost of loading integer registers */
literal|2
block|,
comment|/* cost of moving MMX register */
block|{
literal|2
block|,
literal|2
block|}
block|,
comment|/* cost of loading MMX registers 					   in SImode and DImode */
block|{
literal|2
block|,
literal|2
block|}
block|,
comment|/* cost of storing MMX registers 					   in SImode and DImode */
literal|2
block|,
comment|/* cost of moving SSE register */
block|{
literal|2
block|,
literal|2
block|,
literal|8
block|}
block|,
comment|/* cost of loading SSE registers 					   in SImode, DImode and TImode */
block|{
literal|2
block|,
literal|2
block|,
literal|8
block|}
block|,
comment|/* cost of storing SSE registers 					   in SImode, DImode and TImode */
literal|3
block|,
comment|/* MMX or SSE register to integer */
literal|32
block|,
comment|/* size of prefetch block */
literal|6
block|,
comment|/* number of parallel prefetches */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|processor_costs
name|k6_cost
init|=
block|{
literal|1
block|,
comment|/* cost of an add instruction */
literal|2
block|,
comment|/* cost of a lea instruction */
literal|1
block|,
comment|/* variable shift costs */
literal|1
block|,
comment|/* constant shift costs */
literal|3
block|,
comment|/* cost of starting a multiply */
literal|0
block|,
comment|/* cost of multiply per each bit set */
literal|18
block|,
comment|/* cost of a divide/mod */
literal|2
block|,
comment|/* cost of movsx */
literal|2
block|,
comment|/* cost of movzx */
literal|8
block|,
comment|/* "large" insn */
literal|4
block|,
comment|/* MOVE_RATIO */
literal|3
block|,
comment|/* cost for loading QImode using movzbl */
block|{
literal|4
block|,
literal|5
block|,
literal|4
block|}
block|,
comment|/* cost of loading integer registers 					   in QImode, HImode and SImode. 					   Relative to reg-reg move (2).  */
block|{
literal|2
block|,
literal|3
block|,
literal|2
block|}
block|,
comment|/* cost of storing integer registers */
literal|4
block|,
comment|/* cost of reg,reg fld/fst */
block|{
literal|6
block|,
literal|6
block|,
literal|6
block|}
block|,
comment|/* cost of loading fp registers 					   in SFmode, DFmode and XFmode */
block|{
literal|4
block|,
literal|4
block|,
literal|4
block|}
block|,
comment|/* cost of loading integer registers */
literal|2
block|,
comment|/* cost of moving MMX register */
block|{
literal|2
block|,
literal|2
block|}
block|,
comment|/* cost of loading MMX registers 					   in SImode and DImode */
block|{
literal|2
block|,
literal|2
block|}
block|,
comment|/* cost of storing MMX registers 					   in SImode and DImode */
literal|2
block|,
comment|/* cost of moving SSE register */
block|{
literal|2
block|,
literal|2
block|,
literal|8
block|}
block|,
comment|/* cost of loading SSE registers 					   in SImode, DImode and TImode */
block|{
literal|2
block|,
literal|2
block|,
literal|8
block|}
block|,
comment|/* cost of storing SSE registers 					   in SImode, DImode and TImode */
literal|6
block|,
comment|/* MMX or SSE register to integer */
literal|32
block|,
comment|/* size of prefetch block */
literal|1
block|,
comment|/* number of parallel prefetches */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|processor_costs
name|athlon_cost
init|=
block|{
literal|1
block|,
comment|/* cost of an add instruction */
literal|2
block|,
comment|/* cost of a lea instruction */
literal|1
block|,
comment|/* variable shift costs */
literal|1
block|,
comment|/* constant shift costs */
literal|5
block|,
comment|/* cost of starting a multiply */
literal|0
block|,
comment|/* cost of multiply per each bit set */
literal|42
block|,
comment|/* cost of a divide/mod */
literal|1
block|,
comment|/* cost of movsx */
literal|1
block|,
comment|/* cost of movzx */
literal|8
block|,
comment|/* "large" insn */
literal|9
block|,
comment|/* MOVE_RATIO */
literal|4
block|,
comment|/* cost for loading QImode using movzbl */
block|{
literal|4
block|,
literal|5
block|,
literal|4
block|}
block|,
comment|/* cost of loading integer registers 					   in QImode, HImode and SImode. 					   Relative to reg-reg move (2).  */
block|{
literal|2
block|,
literal|3
block|,
literal|2
block|}
block|,
comment|/* cost of storing integer registers */
literal|4
block|,
comment|/* cost of reg,reg fld/fst */
block|{
literal|6
block|,
literal|6
block|,
literal|20
block|}
block|,
comment|/* cost of loading fp registers 					   in SFmode, DFmode and XFmode */
block|{
literal|4
block|,
literal|4
block|,
literal|16
block|}
block|,
comment|/* cost of loading integer registers */
literal|2
block|,
comment|/* cost of moving MMX register */
block|{
literal|2
block|,
literal|2
block|}
block|,
comment|/* cost of loading MMX registers 					   in SImode and DImode */
block|{
literal|2
block|,
literal|2
block|}
block|,
comment|/* cost of storing MMX registers 					   in SImode and DImode */
literal|2
block|,
comment|/* cost of moving SSE register */
block|{
literal|2
block|,
literal|2
block|,
literal|8
block|}
block|,
comment|/* cost of loading SSE registers 					   in SImode, DImode and TImode */
block|{
literal|2
block|,
literal|2
block|,
literal|8
block|}
block|,
comment|/* cost of storing SSE registers 					   in SImode, DImode and TImode */
literal|6
block|,
comment|/* MMX or SSE register to integer */
literal|64
block|,
comment|/* size of prefetch block */
literal|6
block|,
comment|/* number of parallel prefetches */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|processor_costs
name|pentium4_cost
init|=
block|{
literal|1
block|,
comment|/* cost of an add instruction */
literal|1
block|,
comment|/* cost of a lea instruction */
literal|8
block|,
comment|/* variable shift costs */
literal|8
block|,
comment|/* constant shift costs */
literal|30
block|,
comment|/* cost of starting a multiply */
literal|0
block|,
comment|/* cost of multiply per each bit set */
literal|112
block|,
comment|/* cost of a divide/mod */
literal|1
block|,
comment|/* cost of movsx */
literal|1
block|,
comment|/* cost of movzx */
literal|16
block|,
comment|/* "large" insn */
literal|6
block|,
comment|/* MOVE_RATIO */
literal|2
block|,
comment|/* cost for loading QImode using movzbl */
block|{
literal|4
block|,
literal|5
block|,
literal|4
block|}
block|,
comment|/* cost of loading integer registers 					   in QImode, HImode and SImode. 					   Relative to reg-reg move (2).  */
block|{
literal|2
block|,
literal|3
block|,
literal|2
block|}
block|,
comment|/* cost of storing integer registers */
literal|2
block|,
comment|/* cost of reg,reg fld/fst */
block|{
literal|2
block|,
literal|2
block|,
literal|6
block|}
block|,
comment|/* cost of loading fp registers 					   in SFmode, DFmode and XFmode */
block|{
literal|4
block|,
literal|4
block|,
literal|6
block|}
block|,
comment|/* cost of loading integer registers */
literal|2
block|,
comment|/* cost of moving MMX register */
block|{
literal|2
block|,
literal|2
block|}
block|,
comment|/* cost of loading MMX registers 					   in SImode and DImode */
block|{
literal|2
block|,
literal|2
block|}
block|,
comment|/* cost of storing MMX registers 					   in SImode and DImode */
literal|12
block|,
comment|/* cost of moving SSE register */
block|{
literal|12
block|,
literal|12
block|,
literal|12
block|}
block|,
comment|/* cost of loading SSE registers 					   in SImode, DImode and TImode */
block|{
literal|2
block|,
literal|2
block|,
literal|8
block|}
block|,
comment|/* cost of storing SSE registers 					   in SImode, DImode and TImode */
literal|10
block|,
comment|/* MMX or SSE register to integer */
literal|64
block|,
comment|/* size of prefetch block */
literal|6
block|,
comment|/* number of parallel prefetches */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|processor_costs
modifier|*
name|ix86_cost
init|=
operator|&
name|pentium_cost
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Processor feature/optimization bitmasks.  */
end_comment

begin_define
define|#
directive|define
name|m_386
value|(1<<PROCESSOR_I386)
end_define

begin_define
define|#
directive|define
name|m_486
value|(1<<PROCESSOR_I486)
end_define

begin_define
define|#
directive|define
name|m_PENT
value|(1<<PROCESSOR_PENTIUM)
end_define

begin_define
define|#
directive|define
name|m_PPRO
value|(1<<PROCESSOR_PENTIUMPRO)
end_define

begin_define
define|#
directive|define
name|m_K6
value|(1<<PROCESSOR_K6)
end_define

begin_define
define|#
directive|define
name|m_ATHLON
value|(1<<PROCESSOR_ATHLON)
end_define

begin_define
define|#
directive|define
name|m_PENT4
value|(1<<PROCESSOR_PENTIUM4)
end_define

begin_decl_stmt
specifier|const
name|int
name|x86_use_leave
init|=
name|m_386
operator||
name|m_K6
operator||
name|m_ATHLON
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_push_memory
init|=
name|m_386
operator||
name|m_K6
operator||
name|m_ATHLON
operator||
name|m_PENT4
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_zero_extend_with_and
init|=
name|m_486
operator||
name|m_PENT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_movx
init|=
name|m_ATHLON
operator||
name|m_PPRO
operator||
name|m_PENT4
comment|/* m_386 | m_K6 */
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_double_with_add
init|=
operator|~
name|m_386
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_use_bit_test
init|=
name|m_386
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_unroll_strlen
init|=
name|m_486
operator||
name|m_PENT
operator||
name|m_PPRO
operator||
name|m_ATHLON
operator||
name|m_K6
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_cmove
init|=
name|m_PPRO
operator||
name|m_ATHLON
operator||
name|m_PENT4
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_3dnow_a
init|=
name|m_ATHLON
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_deep_branch
init|=
name|m_PPRO
operator||
name|m_K6
operator||
name|m_ATHLON
operator||
name|m_PENT4
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_branch_hints
init|=
name|m_PENT4
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_use_sahf
init|=
name|m_PPRO
operator||
name|m_K6
operator||
name|m_PENT4
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_partial_reg_stall
init|=
name|m_PPRO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_use_loop
init|=
name|m_K6
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_use_fiop
init|=
operator|~
operator|(
name|m_PPRO
operator||
name|m_ATHLON
operator||
name|m_PENT
operator|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_use_mov0
init|=
name|m_K6
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_use_cltd
init|=
operator|~
operator|(
name|m_PENT
operator||
name|m_K6
operator|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_read_modify_write
init|=
operator|~
name|m_PENT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_read_modify
init|=
operator|~
operator|(
name|m_PENT
operator||
name|m_PPRO
operator|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_split_long_moves
init|=
name|m_PPRO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_promote_QImode
init|=
name|m_K6
operator||
name|m_PENT
operator||
name|m_386
operator||
name|m_486
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_single_stringop
init|=
name|m_386
operator||
name|m_PENT4
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_qimode_math
init|=
operator|~
operator|(
literal|0
operator|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_promote_qi_regs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_himode_math
init|=
operator|~
operator|(
name|m_PPRO
operator|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_promote_hi_regs
init|=
name|m_PPRO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_sub_esp_4
init|=
name|m_ATHLON
operator||
name|m_PPRO
operator||
name|m_PENT4
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_sub_esp_8
init|=
name|m_ATHLON
operator||
name|m_PPRO
operator||
name|m_386
operator||
name|m_486
operator||
name|m_PENT4
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_add_esp_4
init|=
name|m_ATHLON
operator||
name|m_K6
operator||
name|m_PENT4
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_add_esp_8
init|=
name|m_ATHLON
operator||
name|m_PPRO
operator||
name|m_K6
operator||
name|m_386
operator||
name|m_486
operator||
name|m_PENT4
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_integer_DFmode_moves
init|=
operator|~
operator|(
name|m_ATHLON
operator||
name|m_PENT4
operator|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_partial_reg_dependency
init|=
name|m_ATHLON
operator||
name|m_PENT4
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_memory_mismatch_stall
init|=
name|m_ATHLON
operator||
name|m_PENT4
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_accumulate_outgoing_args
init|=
name|m_ATHLON
operator||
name|m_PENT4
operator||
name|m_PPRO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_prologue_using_move
init|=
name|m_ATHLON
operator||
name|m_PENT4
operator||
name|m_PPRO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_epilogue_using_move
init|=
name|m_ATHLON
operator||
name|m_PENT4
operator||
name|m_PPRO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_decompose_lea
init|=
name|m_PENT4
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* In case the avreage insn count for single function invocation is    lower than this constant, emit fast (but longer) prologue and    epilogue code.  */
end_comment

begin_define
define|#
directive|define
name|FAST_PROLOGUE_INSN_COUNT
value|30
end_define

begin_comment
comment|/* Set by prologue expander and used by epilogue expander to determine    the style used.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|use_fast_prologue_epilogue
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|AT_BP
parameter_list|(
name|MODE
parameter_list|)
value|(gen_rtx_MEM ((MODE), hard_frame_pointer_rtx))
end_define

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|hi_reg_name
index|[]
init|=
name|HI_REGISTER_NAMES
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* names for 16 bit regs */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|qi_reg_name
index|[]
init|=
name|QI_REGISTER_NAMES
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* names for 8 bit regs (low) */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|qi_high_reg_name
index|[]
init|=
name|QI_HIGH_REGISTER_NAMES
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* names for 8 bit regs (high) */
end_comment

begin_comment
comment|/* Array of the smallest class containing reg number REGNO, indexed by    REGNO.  Used by REGNO_REG_CLASS in i386.h.  */
end_comment

begin_decl_stmt
name|enum
name|reg_class
specifier|const
name|regclass_map
index|[
name|FIRST_PSEUDO_REGISTER
index|]
init|=
block|{
comment|/* ax, dx, cx, bx */
name|AREG
block|,
name|DREG
block|,
name|CREG
block|,
name|BREG
block|,
comment|/* si, di, bp, sp */
name|SIREG
block|,
name|DIREG
block|,
name|NON_Q_REGS
block|,
name|NON_Q_REGS
block|,
comment|/* FP registers */
name|FP_TOP_REG
block|,
name|FP_SECOND_REG
block|,
name|FLOAT_REGS
block|,
name|FLOAT_REGS
block|,
name|FLOAT_REGS
block|,
name|FLOAT_REGS
block|,
name|FLOAT_REGS
block|,
name|FLOAT_REGS
block|,
comment|/* arg pointer */
name|NON_Q_REGS
block|,
comment|/* flags, fpsr, dirflag, frame */
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NON_Q_REGS
block|,
name|SSE_REGS
block|,
name|SSE_REGS
block|,
name|SSE_REGS
block|,
name|SSE_REGS
block|,
name|SSE_REGS
block|,
name|SSE_REGS
block|,
name|SSE_REGS
block|,
name|SSE_REGS
block|,
name|MMX_REGS
block|,
name|MMX_REGS
block|,
name|MMX_REGS
block|,
name|MMX_REGS
block|,
name|MMX_REGS
block|,
name|MMX_REGS
block|,
name|MMX_REGS
block|,
name|MMX_REGS
block|,
name|NON_Q_REGS
block|,
name|NON_Q_REGS
block|,
name|NON_Q_REGS
block|,
name|NON_Q_REGS
block|,
name|NON_Q_REGS
block|,
name|NON_Q_REGS
block|,
name|NON_Q_REGS
block|,
name|NON_Q_REGS
block|,
name|SSE_REGS
block|,
name|SSE_REGS
block|,
name|SSE_REGS
block|,
name|SSE_REGS
block|,
name|SSE_REGS
block|,
name|SSE_REGS
block|,
name|SSE_REGS
block|,
name|SSE_REGS
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The "default" register map used in 32bit mode.  */
end_comment

begin_decl_stmt
name|int
specifier|const
name|dbx_register_map
index|[
name|FIRST_PSEUDO_REGISTER
index|]
init|=
block|{
literal|0
block|,
literal|2
block|,
literal|1
block|,
literal|3
block|,
literal|6
block|,
literal|7
block|,
literal|4
block|,
literal|5
block|,
comment|/* general regs */
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|16
block|,
literal|17
block|,
literal|18
block|,
literal|19
block|,
comment|/* fp regs */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* arg, flags, fpsr, dir, frame */
literal|21
block|,
literal|22
block|,
literal|23
block|,
literal|24
block|,
literal|25
block|,
literal|26
block|,
literal|27
block|,
literal|28
block|,
comment|/* SSE */
literal|29
block|,
literal|30
block|,
literal|31
block|,
literal|32
block|,
literal|33
block|,
literal|34
block|,
literal|35
block|,
literal|36
block|,
comment|/* MMX */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* extended integer registers */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* extended SSE registers */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
specifier|const
name|x86_64_int_parameter_registers
index|[
literal|6
index|]
init|=
block|{
literal|5
comment|/*RDI*/
block|,
literal|4
comment|/*RSI*/
block|,
literal|1
comment|/*RDX*/
block|,
literal|2
comment|/*RCX*/
block|,
name|FIRST_REX_INT_REG
comment|/*R8 */
block|,
name|FIRST_REX_INT_REG
operator|+
literal|1
comment|/*R9 */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
specifier|const
name|x86_64_int_return_registers
index|[
literal|4
index|]
init|=
block|{
literal|0
comment|/*RAX*/
block|,
literal|1
comment|/*RDI*/
block|,
literal|5
block|,
literal|4
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The "default" register map used in 64bit mode.  */
end_comment

begin_decl_stmt
name|int
specifier|const
name|dbx64_register_map
index|[
name|FIRST_PSEUDO_REGISTER
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
comment|/* general regs */
literal|33
block|,
literal|34
block|,
literal|35
block|,
literal|36
block|,
literal|37
block|,
literal|38
block|,
literal|39
block|,
literal|40
comment|/* fp regs */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* arg, flags, fpsr, dir, frame */
literal|17
block|,
literal|18
block|,
literal|19
block|,
literal|20
block|,
literal|21
block|,
literal|22
block|,
literal|23
block|,
literal|24
block|,
comment|/* SSE */
literal|41
block|,
literal|42
block|,
literal|43
block|,
literal|44
block|,
literal|45
block|,
literal|46
block|,
literal|47
block|,
literal|48
block|,
comment|/* MMX */
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
comment|/* extended integer registers */
literal|25
block|,
literal|26
block|,
literal|27
block|,
literal|28
block|,
literal|29
block|,
literal|30
block|,
literal|31
block|,
literal|32
block|,
comment|/* extended SSE registers */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Define the register numbers to be used in Dwarf debugging information.    The SVR4 reference port C compiler uses the following register numbers    in its Dwarf output code: 	0 for %eax (gcc regno = 0) 	1 for %ecx (gcc regno = 2) 	2 for %edx (gcc regno = 1) 	3 for %ebx (gcc regno = 3) 	4 for %esp (gcc regno = 7) 	5 for %ebp (gcc regno = 6) 	6 for %esi (gcc regno = 4) 	7 for %edi (gcc regno = 5)    The following three DWARF register numbers are never generated by    the SVR4 C compiler or by the GNU compilers, but SDB on x86/svr4    believes these numbers have these meanings. 	8  for %eip    (no gcc equivalent) 	9  for %eflags (gcc regno = 17) 	10 for %trapno (no gcc equivalent)    It is not at all clear how we should number the FP stack registers    for the x86 architecture.  If the version of SDB on x86/svr4 were    a bit less brain dead with respect to floating-point then we would    have a precedent to follow with respect to DWARF register numbers    for x86 FP registers, but the SDB on x86/svr4 is so completely    broken with respect to FP registers that it is hardly worth thinking    of it as something to strive for compatibility with.    The version of x86/svr4 SDB I have at the moment does (partially)    seem to believe that DWARF register number 11 is associated with    the x86 register %st(0), but that's about all.  Higher DWARF    register numbers don't seem to be associated with anything in    particular, and even for DWARF regno 11, SDB only seems to under-    stand that it should say that a variable lives in %st(0) (when    asked via an `=' command) if we said it was in DWARF regno 11,    but SDB still prints garbage when asked for the value of the    variable in question (via a `/' command).    (Also note that the labels SDB prints for various FP stack regs    when doing an `x' command are all wrong.)    Note that these problems generally don't affect the native SVR4    C compiler because it doesn't allow the use of -O with -g and    because when it is *not* optimizing, it allocates a memory    location for each floating-point variable, and the memory    location is what gets described in the DWARF AT_location    attribute for the variable in question.    Regardless of the severe mental illness of the x86/svr4 SDB, we    do something sensible here and we use the following DWARF    register numbers.  Note that these are all stack-top-relative    numbers. 	11 for %st(0) (gcc regno = 8) 	12 for %st(1) (gcc regno = 9) 	13 for %st(2) (gcc regno = 10) 	14 for %st(3) (gcc regno = 11) 	15 for %st(4) (gcc regno = 12) 	16 for %st(5) (gcc regno = 13) 	17 for %st(6) (gcc regno = 14) 	18 for %st(7) (gcc regno = 15) */
end_comment

begin_decl_stmt
name|int
specifier|const
name|svr4_dbx_register_map
index|[
name|FIRST_PSEUDO_REGISTER
index|]
init|=
block|{
literal|0
block|,
literal|2
block|,
literal|1
block|,
literal|3
block|,
literal|6
block|,
literal|7
block|,
literal|5
block|,
literal|4
block|,
comment|/* general regs */
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|16
block|,
literal|17
block|,
literal|18
block|,
comment|/* fp regs */
operator|-
literal|1
block|,
literal|9
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* arg, flags, fpsr, dir, frame */
literal|21
block|,
literal|22
block|,
literal|23
block|,
literal|24
block|,
literal|25
block|,
literal|26
block|,
literal|27
block|,
literal|28
block|,
comment|/* SSE registers */
literal|29
block|,
literal|30
block|,
literal|31
block|,
literal|32
block|,
literal|33
block|,
literal|34
block|,
literal|35
block|,
literal|36
block|,
comment|/* MMX registers */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* extemded integer registers */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* extemded SSE registers */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Test and compare insns in i386.md store the information needed to    generate branch and scc insns here.  */
end_comment

begin_decl_stmt
name|rtx
name|ix86_compare_op0
init|=
name|NULL_RTX
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|ix86_compare_op1
init|=
name|NULL_RTX
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MAX_386_STACK_LOCALS
value|3
end_define

begin_comment
comment|/* Size of the register save area.  */
end_comment

begin_define
define|#
directive|define
name|X86_64_VARARGS_SIZE
value|(REGPARM_MAX * UNITS_PER_WORD + SSE_REGPARM_MAX * 16)
end_define

begin_comment
comment|/* Define the structure for the machine field in struct function.  */
end_comment

begin_struct
struct|struct
name|machine_function
block|{
name|rtx
name|stack_locals
index|[
operator|(
name|int
operator|)
name|MAX_MACHINE_MODE
index|]
index|[
name|MAX_386_STACK_LOCALS
index|]
decl_stmt|;
name|int
name|save_varrargs_registers
decl_stmt|;
name|int
name|accesses_prev_frame
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|ix86_stack_locals
value|(cfun->machine->stack_locals)
end_define

begin_define
define|#
directive|define
name|ix86_save_varrargs_registers
value|(cfun->machine->save_varrargs_registers)
end_define

begin_comment
comment|/* Structure describing stack frame layout.    Stack grows downward:     [arguments]<- ARG_POINTER    saved pc     saved frame pointer if frame_pointer_needed<- HARD_FRAME_POINTER    [saved regs]     [padding1]          \ 		        )    [va_arg registers]  (> to_allocate<- FRAME_POINTER    [frame]	       ( 		        )    [padding2]	       /   */
end_comment

begin_struct
struct|struct
name|ix86_frame
block|{
name|int
name|nregs
decl_stmt|;
name|int
name|padding1
decl_stmt|;
name|int
name|va_arg_size
decl_stmt|;
name|HOST_WIDE_INT
name|frame
decl_stmt|;
name|int
name|padding2
decl_stmt|;
name|int
name|outgoing_arguments_size
decl_stmt|;
name|int
name|red_zone_size
decl_stmt|;
name|HOST_WIDE_INT
name|to_allocate
decl_stmt|;
comment|/* The offsets relative to ARG_POINTER.  */
name|HOST_WIDE_INT
name|frame_pointer_offset
decl_stmt|;
name|HOST_WIDE_INT
name|hard_frame_pointer_offset
decl_stmt|;
name|HOST_WIDE_INT
name|stack_pointer_offset
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Used to enable/disable debugging features.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|ix86_debug_arg_string
decl_stmt|,
modifier|*
name|ix86_debug_addr_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Code model option as passed by user.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|ix86_cmodel_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parsed value.  */
end_comment

begin_decl_stmt
name|enum
name|cmodel
name|ix86_cmodel
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Asm dialect.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|ix86_asm_string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|asm_dialect
name|ix86_asm_dialect
init|=
name|ASM_ATT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* which cpu are we scheduling for */
end_comment

begin_decl_stmt
name|enum
name|processor_type
name|ix86_cpu
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* which unit we are generating floating point math for */
end_comment

begin_decl_stmt
name|enum
name|fpmath_unit
name|ix86_fpmath
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* which instruction set architecture to use.  */
end_comment

begin_decl_stmt
name|int
name|ix86_arch
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Strings to hold which cpu and instruction set architecture  to use.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|ix86_cpu_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for -mcpu=<xxx> */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|ix86_arch_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for -march=<xxx> */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|ix86_fpmath_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for -mfpmath=<xxx> */
end_comment

begin_comment
comment|/* # of registers to use to pass arguments.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|ix86_regparm_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if sse prefetch instruction is not NOOP.  */
end_comment

begin_decl_stmt
name|int
name|x86_prefetch_sse
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ix86_regparm_string as a number */
end_comment

begin_decl_stmt
name|int
name|ix86_regparm
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Alignment to use for loops and jumps:  */
end_comment

begin_comment
comment|/* Power of two alignment for loops.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|ix86_align_loops_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Power of two alignment for non-loop jumps.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|ix86_align_jumps_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Power of two alignment for stack boundary in bytes.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|ix86_preferred_stack_boundary_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Preferred alignment for stack boundary in bits.  */
end_comment

begin_decl_stmt
name|int
name|ix86_preferred_stack_boundary
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Values 1-5: see jump.c */
end_comment

begin_decl_stmt
name|int
name|ix86_branch_cost
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|ix86_branch_cost_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Power of two alignment for functions.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|ix86_align_funcs_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Prefix built by ASM_GENERATE_INTERNAL_LABEL.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|internal_label_prefix
index|[
literal|16
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|internal_label_prefix_len
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|int
name|local_symbolic_operand
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
expr|enum
name|machine_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_pic_addr_const
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|put_condition_code
name|PARAMS
argument_list|(
operator|(
expr|enum
name|rtx_code
operator|,
expr|enum
name|machine_mode
operator|,
name|int
operator|,
name|int
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|ix86_expand_int_compare
name|PARAMS
argument_list|(
operator|(
expr|enum
name|rtx_code
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|rtx_code
name|ix86_prepare_fp_compare_args
name|PARAMS
argument_list|(
operator|(
expr|enum
name|rtx_code
operator|,
name|rtx
operator|*
operator|,
name|rtx
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|gen_push
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|memory_address_length
name|PARAMS
argument_list|(
operator|(
name|rtx
name|addr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ix86_flags_dependant
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
expr|enum
name|attr_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ix86_agi_dependant
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
expr|enum
name|attr_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ix86_safe_length
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|attr_memory
name|ix86_safe_memory
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|attr_pent_pair
name|ix86_safe_pent_pair
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|attr_ppro_uops
name|ix86_safe_ppro_uops
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ix86_dump_ppro_packet
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ix86_reorder_insn
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|*
operator|,
name|rtx
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|ix86_pent_find_pair
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|*
operator|,
name|rtx
operator|*
operator|,
expr|enum
name|attr_pent_pair
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ix86_init_machine_status
name|PARAMS
argument_list|(
operator|(
expr|struct
name|function
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ix86_mark_machine_status
name|PARAMS
argument_list|(
operator|(
expr|struct
name|function
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ix86_free_machine_status
name|PARAMS
argument_list|(
operator|(
expr|struct
name|function
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ix86_split_to_parts
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|*
operator|,
expr|enum
name|machine_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ix86_safe_length_prefix
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ix86_nsaved_regs
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ix86_emit_save_regs
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ix86_emit_save_regs_using_mov
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|HOST_WIDE_INT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ix86_emit_restore_regs_using_mov
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ix86_set_move_mem_attrs_1
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ix86_sched_reorder_pentium
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|*
operator|,
name|rtx
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ix86_sched_reorder_ppro
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|*
operator|,
name|rtx
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|HOST_WIDE_INT
name|ix86_GOT_alias_set
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ix86_adjust_counter
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|HOST_WIDE_INT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|ix86_expand_aligntest
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ix86_expand_strlensi_unroll_1
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ix86_issue_rate
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ix86_adjust_cost
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ix86_sched_init
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ix86_sched_reorder
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|int
operator|,
name|rtx
operator|*
operator|,
name|int
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ix86_variable_issue
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|int
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ix86_init_mmx_sse_builtins
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|ix86_address
block|{
name|rtx
name|base
decl_stmt|,
name|index
decl_stmt|,
name|disp
decl_stmt|;
name|HOST_WIDE_INT
name|scale
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|ix86_decompose_address
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
expr|struct
name|ix86_address
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_struct_decl
struct_decl|struct
name|builtin_description
struct_decl|;
end_struct_decl

begin_decl_stmt
specifier|static
name|rtx
name|ix86_expand_sse_comi
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|builtin_description
operator|*
operator|,
name|tree
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|ix86_expand_sse_compare
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|builtin_description
operator|*
operator|,
name|tree
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|ix86_expand_unop1_builtin
name|PARAMS
argument_list|(
operator|(
expr|enum
name|insn_code
operator|,
name|tree
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|ix86_expand_unop_builtin
name|PARAMS
argument_list|(
operator|(
expr|enum
name|insn_code
operator|,
name|tree
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|ix86_expand_binop_builtin
name|PARAMS
argument_list|(
operator|(
expr|enum
name|insn_code
operator|,
name|tree
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|ix86_expand_timode_binop_builtin
name|PARAMS
argument_list|(
operator|(
expr|enum
name|insn_code
operator|,
name|tree
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|ix86_expand_store_builtin
name|PARAMS
argument_list|(
operator|(
expr|enum
name|insn_code
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|safe_vector_operand
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
expr|enum
name|machine_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|rtx_code
name|ix86_fp_compare_code_to_integer
name|PARAMS
argument_list|(
operator|(
expr|enum
name|rtx_code
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ix86_fp_comparison_codes
name|PARAMS
argument_list|(
operator|(
expr|enum
name|rtx_code
name|code
operator|,
expr|enum
name|rtx_code
operator|*
operator|,
expr|enum
name|rtx_code
operator|*
operator|,
expr|enum
name|rtx_code
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|ix86_expand_fp_compare
name|PARAMS
argument_list|(
operator|(
expr|enum
name|rtx_code
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|*
operator|,
name|rtx
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ix86_fp_comparison_arithmetics_cost
name|PARAMS
argument_list|(
operator|(
expr|enum
name|rtx_code
name|code
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ix86_fp_comparison_fcomi_cost
name|PARAMS
argument_list|(
operator|(
expr|enum
name|rtx_code
name|code
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ix86_fp_comparison_sahf_cost
name|PARAMS
argument_list|(
operator|(
expr|enum
name|rtx_code
name|code
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ix86_fp_comparison_cost
name|PARAMS
argument_list|(
operator|(
expr|enum
name|rtx_code
name|code
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ix86_save_reg
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ix86_compute_frame_layout
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ix86_frame
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ix86_comp_type_attributes
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|attribute_spec
name|ix86_attribute_table
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|ix86_handle_cdecl_attribute
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|bool
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|ix86_handle_regparm_attribute
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|bool
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DO_GLOBAL_CTORS_BODY
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|ix86_svr3_asm_out_constructor
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Register class used for passing given 64bit part of the argument.    These represent classes as documented by the PS ABI, with the exception    of SSESF, SSEDF classes, that are basically SSE class, just gcc will    use SF or DFmode move instead of DImode to avoid reformating penalties.     Similary we play games with INTEGERSI_CLASS to use cheaper SImode moves    whenever possible (upper half does contain padding).  */
end_comment

begin_enum
enum|enum
name|x86_64_reg_class
block|{
name|X86_64_NO_CLASS
block|,
name|X86_64_INTEGER_CLASS
block|,
name|X86_64_INTEGERSI_CLASS
block|,
name|X86_64_SSE_CLASS
block|,
name|X86_64_SSESF_CLASS
block|,
name|X86_64_SSEDF_CLASS
block|,
name|X86_64_SSEUP_CLASS
block|,
name|X86_64_X87_CLASS
block|,
name|X86_64_X87UP_CLASS
block|,
name|X86_64_MEMORY_CLASS
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|x86_64_reg_class_name
index|[]
init|=
block|{
literal|"no"
block|,
literal|"integer"
block|,
literal|"integerSI"
block|,
literal|"sse"
block|,
literal|"sseSF"
block|,
literal|"sseDF"
block|,
literal|"sseup"
block|,
literal|"x87"
block|,
literal|"x87up"
block|,
literal|"no"
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MAX_CLASSES
value|4
end_define

begin_decl_stmt
specifier|static
name|int
name|classify_argument
name|PARAMS
argument_list|(
operator|(
expr|enum
name|machine_mode
operator|,
name|tree
operator|,
expr|enum
name|x86_64_reg_class
index|[
name|MAX_CLASSES
index|]
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|examine_argument
name|PARAMS
argument_list|(
operator|(
expr|enum
name|machine_mode
operator|,
name|tree
operator|,
name|int
operator|,
name|int
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|construct_container
name|PARAMS
argument_list|(
operator|(
expr|enum
name|machine_mode
operator|,
name|tree
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
specifier|const
name|int
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|x86_64_reg_class
name|merge_classes
name|PARAMS
argument_list|(
operator|(
expr|enum
name|x86_64_reg_class
operator|,
expr|enum
name|x86_64_reg_class
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Initialize the GCC target structure.  */
end_comment

begin_undef
undef|#
directive|undef
name|TARGET_ATTRIBUTE_TABLE
end_undef

begin_define
define|#
directive|define
name|TARGET_ATTRIBUTE_TABLE
value|ix86_attribute_table
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|TARGET_DLLIMPORT_DECL_ATTRIBUTES
end_ifdef

begin_undef
undef|#
directive|undef
name|TARGET_MERGE_DECL_ATTRIBUTES
end_undef

begin_define
define|#
directive|define
name|TARGET_MERGE_DECL_ATTRIBUTES
value|merge_dllimport_decl_attributes
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|TARGET_COMP_TYPE_ATTRIBUTES
end_undef

begin_define
define|#
directive|define
name|TARGET_COMP_TYPE_ATTRIBUTES
value|ix86_comp_type_attributes
end_define

begin_undef
undef|#
directive|undef
name|TARGET_INIT_BUILTINS
end_undef

begin_define
define|#
directive|define
name|TARGET_INIT_BUILTINS
value|ix86_init_builtins
end_define

begin_undef
undef|#
directive|undef
name|TARGET_EXPAND_BUILTIN
end_undef

begin_define
define|#
directive|define
name|TARGET_EXPAND_BUILTIN
value|ix86_expand_builtin
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|OSF_OS
argument_list|)
operator|||
name|defined
argument_list|(
name|TARGET_OSF1ELF
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|void
name|ix86_osf_output_function_prologue
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|HOST_WIDE_INT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|TARGET_ASM_FUNCTION_PROLOGUE
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_FUNCTION_PROLOGUE
value|ix86_osf_output_function_prologue
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|TARGET_ASM_OPEN_PAREN
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_OPEN_PAREN
value|""
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_CLOSE_PAREN
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_CLOSE_PAREN
value|""
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_ALIGNED_HI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_ALIGNED_HI_OP
value|ASM_SHORT
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_ALIGNED_SI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_ALIGNED_SI_OP
value|ASM_LONG
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|ASM_QUAD
end_ifdef

begin_undef
undef|#
directive|undef
name|TARGET_ASM_ALIGNED_DI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_ALIGNED_DI_OP
value|ASM_QUAD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|TARGET_ASM_UNALIGNED_HI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_UNALIGNED_HI_OP
value|TARGET_ASM_ALIGNED_HI_OP
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_UNALIGNED_SI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_UNALIGNED_SI_OP
value|TARGET_ASM_ALIGNED_SI_OP
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_UNALIGNED_DI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_UNALIGNED_DI_OP
value|TARGET_ASM_ALIGNED_DI_OP
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_ADJUST_COST
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_ADJUST_COST
value|ix86_adjust_cost
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_ISSUE_RATE
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_ISSUE_RATE
value|ix86_issue_rate
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_VARIABLE_ISSUE
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_VARIABLE_ISSUE
value|ix86_variable_issue
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_INIT
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_INIT
value|ix86_sched_init
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_REORDER
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_REORDER
value|ix86_sched_reorder
end_define

begin_decl_stmt
name|struct
name|gcc_target
name|targetm
init|=
name|TARGET_INITIALIZER
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Sometimes certain combinations of command options do not make    sense on a particular target machine.  You can define a macro    `OVERRIDE_OPTIONS' to take account of this.  This macro, if    defined, is executed once just after all the command options have    been parsed.     Don't use this macro to turn on various extra optimizations for    `-O'.  That is what `OPTIMIZATION_OPTIONS' is for.  */
end_comment

begin_function
name|void
name|override_options
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
comment|/* Comes from final.c -- no real reason to change it.  */
define|#
directive|define
name|MAX_CODE_ALIGN
value|16
specifier|static
struct|struct
name|ptt
block|{
specifier|const
name|struct
name|processor_costs
modifier|*
name|cost
decl_stmt|;
comment|/* Processor costs */
specifier|const
name|int
name|target_enable
decl_stmt|;
comment|/* Target flags to enable.  */
specifier|const
name|int
name|target_disable
decl_stmt|;
comment|/* Target flags to disable.  */
specifier|const
name|int
name|align_loop
decl_stmt|;
comment|/* Default alignments.  */
specifier|const
name|int
name|align_loop_max_skip
decl_stmt|;
specifier|const
name|int
name|align_jump
decl_stmt|;
specifier|const
name|int
name|align_jump_max_skip
decl_stmt|;
specifier|const
name|int
name|align_func
decl_stmt|;
specifier|const
name|int
name|branch_cost
decl_stmt|;
block|}
decl|const
name|processor_target_table
index|[
name|PROCESSOR_max
index|]
init|=
block|{
block|{
operator|&
name|i386_cost
block|,
literal|0
block|,
literal|0
block|,
literal|4
block|,
literal|3
block|,
literal|4
block|,
literal|3
block|,
literal|4
block|,
literal|1
block|}
block|,
block|{
operator|&
name|i486_cost
block|,
literal|0
block|,
literal|0
block|,
literal|16
block|,
literal|15
block|,
literal|16
block|,
literal|15
block|,
literal|16
block|,
literal|1
block|}
block|,
block|{
operator|&
name|pentium_cost
block|,
literal|0
block|,
literal|0
block|,
literal|16
block|,
literal|7
block|,
literal|16
block|,
literal|7
block|,
literal|16
block|,
literal|1
block|}
block|,
block|{
operator|&
name|pentiumpro_cost
block|,
literal|0
block|,
literal|0
block|,
literal|16
block|,
literal|15
block|,
literal|16
block|,
literal|7
block|,
literal|16
block|,
literal|1
block|}
block|,
block|{
operator|&
name|k6_cost
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
literal|7
block|,
literal|32
block|,
literal|7
block|,
literal|32
block|,
literal|1
block|}
block|,
block|{
operator|&
name|athlon_cost
block|,
literal|0
block|,
literal|0
block|,
literal|16
block|,
literal|7
block|,
literal|64
block|,
literal|7
block|,
literal|16
block|,
literal|1
block|}
block|,
block|{
operator|&
name|pentium4_cost
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|}
block|}
struct|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|cpu_names
index|[]
init|=
name|TARGET_CPU_DEFAULT_NAMES
decl_stmt|;
specifier|static
struct|struct
name|pta
block|{
specifier|const
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
comment|/* processor name or nickname.  */
specifier|const
name|enum
name|processor_type
name|processor
decl_stmt|;
specifier|const
enum|enum
name|pta_flags
block|{
name|PTA_SSE
init|=
literal|1
block|,
name|PTA_SSE2
init|=
literal|2
block|,
name|PTA_MMX
init|=
literal|4
block|,
name|PTA_PREFETCH_SSE
init|=
literal|8
block|,
name|PTA_3DNOW
init|=
literal|16
block|,
name|PTA_3DNOW_A
init|=
literal|64
block|}
name|flags
enum|;
block|}
decl|const
name|processor_alias_table
index|[]
init|=
block|{
block|{
literal|"i386"
block|,
name|PROCESSOR_I386
block|,
literal|0
block|}
block|,
block|{
literal|"i486"
block|,
name|PROCESSOR_I486
block|,
literal|0
block|}
block|,
block|{
literal|"i586"
block|,
name|PROCESSOR_PENTIUM
block|,
literal|0
block|}
block|,
block|{
literal|"pentium"
block|,
name|PROCESSOR_PENTIUM
block|,
literal|0
block|}
block|,
block|{
literal|"pentium-mmx"
block|,
name|PROCESSOR_PENTIUM
block|,
name|PTA_MMX
block|}
block|,
block|{
literal|"i686"
block|,
name|PROCESSOR_PENTIUMPRO
block|,
literal|0
block|}
block|,
block|{
literal|"pentiumpro"
block|,
name|PROCESSOR_PENTIUMPRO
block|,
literal|0
block|}
block|,
block|{
literal|"pentium2"
block|,
name|PROCESSOR_PENTIUMPRO
block|,
name|PTA_MMX
block|}
block|,
block|{
literal|"pentium3"
block|,
name|PROCESSOR_PENTIUMPRO
block|,
name|PTA_MMX
operator||
name|PTA_SSE
operator||
name|PTA_PREFETCH_SSE
block|}
block|,
block|{
literal|"pentium4"
block|,
name|PROCESSOR_PENTIUM4
block|,
name|PTA_SSE
operator||
name|PTA_SSE2
operator||
name|PTA_MMX
operator||
name|PTA_PREFETCH_SSE
block|}
block|,
block|{
literal|"k6"
block|,
name|PROCESSOR_K6
block|,
name|PTA_MMX
block|}
block|,
block|{
literal|"k6-2"
block|,
name|PROCESSOR_K6
block|,
name|PTA_MMX
operator||
name|PTA_3DNOW
block|}
block|,
block|{
literal|"k6-3"
block|,
name|PROCESSOR_K6
block|,
name|PTA_MMX
operator||
name|PTA_3DNOW
block|}
block|,
block|{
literal|"athlon"
block|,
name|PROCESSOR_ATHLON
block|,
name|PTA_MMX
operator||
name|PTA_PREFETCH_SSE
operator||
name|PTA_3DNOW
operator||
name|PTA_3DNOW_A
block|}
block|,
block|{
literal|"athlon-tbird"
block|,
name|PROCESSOR_ATHLON
block|,
name|PTA_MMX
operator||
name|PTA_PREFETCH_SSE
operator||
name|PTA_3DNOW
operator||
name|PTA_3DNOW_A
block|}
block|,
block|{
literal|"athlon-4"
block|,
name|PROCESSOR_ATHLON
block|,
name|PTA_MMX
operator||
name|PTA_PREFETCH_SSE
operator||
name|PTA_3DNOW
operator||
name|PTA_3DNOW_A
operator||
name|PTA_SSE
block|}
block|,
block|{
literal|"athlon-xp"
block|,
name|PROCESSOR_ATHLON
block|,
name|PTA_MMX
operator||
name|PTA_PREFETCH_SSE
operator||
name|PTA_3DNOW
operator||
name|PTA_3DNOW_A
operator||
name|PTA_SSE
block|}
block|,
block|{
literal|"athlon-mp"
block|,
name|PROCESSOR_ATHLON
block|,
name|PTA_MMX
operator||
name|PTA_PREFETCH_SSE
operator||
name|PTA_3DNOW
operator||
name|PTA_3DNOW_A
operator||
name|PTA_SSE
block|}
block|,     }
struct|;
name|int
specifier|const
name|pta_size
init|=
sizeof|sizeof
argument_list|(
name|processor_alias_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|pta
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|SUBTARGET_OVERRIDE_OPTIONS
name|SUBTARGET_OVERRIDE_OPTIONS
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|ix86_cpu_string
operator|&&
name|ix86_arch_string
condition|)
name|ix86_cpu_string
operator|=
name|ix86_arch_string
expr_stmt|;
if|if
condition|(
operator|!
name|ix86_cpu_string
condition|)
name|ix86_cpu_string
operator|=
name|cpu_names
index|[
name|TARGET_CPU_DEFAULT
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|ix86_arch_string
condition|)
name|ix86_arch_string
operator|=
name|TARGET_64BIT
condition|?
literal|"athlon-4"
else|:
literal|"i386"
expr_stmt|;
if|if
condition|(
name|ix86_cmodel_string
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ix86_cmodel_string
argument_list|,
literal|"small"
argument_list|)
condition|)
name|ix86_cmodel
operator|=
name|flag_pic
condition|?
name|CM_SMALL_PIC
else|:
name|CM_SMALL
expr_stmt|;
elseif|else
if|if
condition|(
name|flag_pic
condition|)
name|sorry
argument_list|(
literal|"code model %s not supported in PIC mode"
argument_list|,
name|ix86_cmodel_string
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ix86_cmodel_string
argument_list|,
literal|"32"
argument_list|)
condition|)
name|ix86_cmodel
operator|=
name|CM_32
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ix86_cmodel_string
argument_list|,
literal|"kernel"
argument_list|)
operator|&&
operator|!
name|flag_pic
condition|)
name|ix86_cmodel
operator|=
name|CM_KERNEL
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ix86_cmodel_string
argument_list|,
literal|"medium"
argument_list|)
operator|&&
operator|!
name|flag_pic
condition|)
name|ix86_cmodel
operator|=
name|CM_MEDIUM
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ix86_cmodel_string
argument_list|,
literal|"large"
argument_list|)
operator|&&
operator|!
name|flag_pic
condition|)
name|ix86_cmodel
operator|=
name|CM_LARGE
expr_stmt|;
else|else
name|error
argument_list|(
literal|"bad value (%s) for -mcmodel= switch"
argument_list|,
name|ix86_cmodel_string
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ix86_cmodel
operator|=
name|CM_32
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
name|ix86_cmodel
operator|=
name|flag_pic
condition|?
name|CM_SMALL_PIC
else|:
name|CM_SMALL
expr_stmt|;
block|}
if|if
condition|(
name|ix86_asm_string
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ix86_asm_string
argument_list|,
literal|"intel"
argument_list|)
condition|)
name|ix86_asm_dialect
operator|=
name|ASM_INTEL
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ix86_asm_string
argument_list|,
literal|"att"
argument_list|)
condition|)
name|ix86_asm_dialect
operator|=
name|ASM_ATT
expr_stmt|;
else|else
name|error
argument_list|(
literal|"bad value (%s) for -masm= switch"
argument_list|,
name|ix86_asm_string
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|TARGET_64BIT
operator|==
literal|0
operator|)
operator|!=
operator|(
name|ix86_cmodel
operator|==
name|CM_32
operator|)
condition|)
name|error
argument_list|(
literal|"code model `%s' not supported in the %s bit mode"
argument_list|,
name|ix86_cmodel_string
argument_list|,
name|TARGET_64BIT
condition|?
literal|"64"
else|:
literal|"32"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ix86_cmodel
operator|==
name|CM_LARGE
condition|)
name|sorry
argument_list|(
literal|"code model `large' not supported yet"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TARGET_64BIT
operator|!=
literal|0
operator|)
operator|!=
operator|(
operator|(
name|target_flags
operator|&
name|MASK_64BIT
operator|)
operator|!=
literal|0
operator|)
condition|)
name|sorry
argument_list|(
literal|"%i-bit mode not compiled in"
argument_list|,
operator|(
name|target_flags
operator|&
name|MASK_64BIT
operator|)
condition|?
literal|64
else|:
literal|32
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pta_size
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ix86_arch_string
argument_list|,
name|processor_alias_table
index|[
name|i
index|]
operator|.
name|name
argument_list|)
condition|)
block|{
name|ix86_arch
operator|=
name|processor_alias_table
index|[
name|i
index|]
operator|.
name|processor
expr_stmt|;
comment|/* Default cpu tuning to the architecture.  */
name|ix86_cpu
operator|=
name|ix86_arch
expr_stmt|;
if|if
condition|(
name|processor_alias_table
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|PTA_MMX
operator|&&
operator|!
operator|(
name|target_flags
operator|&
name|MASK_MMX_SET
operator|)
condition|)
name|target_flags
operator||=
name|MASK_MMX
expr_stmt|;
if|if
condition|(
name|processor_alias_table
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|PTA_3DNOW
operator|&&
operator|!
operator|(
name|target_flags
operator|&
name|MASK_3DNOW_SET
operator|)
condition|)
name|target_flags
operator||=
name|MASK_3DNOW
expr_stmt|;
if|if
condition|(
name|processor_alias_table
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|PTA_3DNOW_A
operator|&&
operator|!
operator|(
name|target_flags
operator|&
name|MASK_3DNOW_A_SET
operator|)
condition|)
name|target_flags
operator||=
name|MASK_3DNOW_A
expr_stmt|;
if|if
condition|(
name|processor_alias_table
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|PTA_SSE
operator|&&
operator|!
operator|(
name|target_flags
operator|&
name|MASK_SSE_SET
operator|)
condition|)
name|target_flags
operator||=
name|MASK_SSE
expr_stmt|;
if|if
condition|(
name|processor_alias_table
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|PTA_SSE2
operator|&&
operator|!
operator|(
name|target_flags
operator|&
name|MASK_SSE2_SET
operator|)
condition|)
name|target_flags
operator||=
name|MASK_SSE2
expr_stmt|;
if|if
condition|(
name|processor_alias_table
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|PTA_PREFETCH_SSE
condition|)
name|x86_prefetch_sse
operator|=
name|true
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|pta_size
condition|)
name|error
argument_list|(
literal|"bad value (%s) for -march= switch"
argument_list|,
name|ix86_arch_string
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pta_size
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ix86_cpu_string
argument_list|,
name|processor_alias_table
index|[
name|i
index|]
operator|.
name|name
argument_list|)
condition|)
block|{
name|ix86_cpu
operator|=
name|processor_alias_table
index|[
name|i
index|]
operator|.
name|processor
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|processor_alias_table
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|PTA_PREFETCH_SSE
condition|)
name|x86_prefetch_sse
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|pta_size
condition|)
name|error
argument_list|(
literal|"bad value (%s) for -mcpu= switch"
argument_list|,
name|ix86_cpu_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|optimize_size
condition|)
name|ix86_cost
operator|=
operator|&
name|size_cost
expr_stmt|;
else|else
name|ix86_cost
operator|=
name|processor_target_table
index|[
name|ix86_cpu
index|]
operator|.
name|cost
expr_stmt|;
name|target_flags
operator||=
name|processor_target_table
index|[
name|ix86_cpu
index|]
operator|.
name|target_enable
expr_stmt|;
name|target_flags
operator|&=
operator|~
name|processor_target_table
index|[
name|ix86_cpu
index|]
operator|.
name|target_disable
expr_stmt|;
comment|/* Arrange to set up i386_stack_locals for all functions.  */
name|init_machine_status
operator|=
name|ix86_init_machine_status
expr_stmt|;
name|mark_machine_status
operator|=
name|ix86_mark_machine_status
expr_stmt|;
name|free_machine_status
operator|=
name|ix86_free_machine_status
expr_stmt|;
comment|/* Validate -mregparm= value.  */
if|if
condition|(
name|ix86_regparm_string
condition|)
block|{
name|i
operator|=
name|atoi
argument_list|(
name|ix86_regparm_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|>
name|REGPARM_MAX
condition|)
name|error
argument_list|(
literal|"-mregparm=%d is not between 0 and %d"
argument_list|,
name|i
argument_list|,
name|REGPARM_MAX
argument_list|)
expr_stmt|;
else|else
name|ix86_regparm
operator|=
name|i
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TARGET_64BIT
condition|)
name|ix86_regparm
operator|=
name|REGPARM_MAX
expr_stmt|;
comment|/* If the user has provided any of the -malign-* options,      warn and use that value only if -falign-* is not set.      Remove this code in GCC 3.2 or later.  */
if|if
condition|(
name|ix86_align_loops_string
condition|)
block|{
name|warning
argument_list|(
literal|"-malign-loops is obsolete, use -falign-loops"
argument_list|)
expr_stmt|;
if|if
condition|(
name|align_loops
operator|==
literal|0
condition|)
block|{
name|i
operator|=
name|atoi
argument_list|(
name|ix86_align_loops_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|>
name|MAX_CODE_ALIGN
condition|)
name|error
argument_list|(
literal|"-malign-loops=%d is not between 0 and %d"
argument_list|,
name|i
argument_list|,
name|MAX_CODE_ALIGN
argument_list|)
expr_stmt|;
else|else
name|align_loops
operator|=
literal|1
operator|<<
name|i
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ix86_align_jumps_string
condition|)
block|{
name|warning
argument_list|(
literal|"-malign-jumps is obsolete, use -falign-jumps"
argument_list|)
expr_stmt|;
if|if
condition|(
name|align_jumps
operator|==
literal|0
condition|)
block|{
name|i
operator|=
name|atoi
argument_list|(
name|ix86_align_jumps_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|>
name|MAX_CODE_ALIGN
condition|)
name|error
argument_list|(
literal|"-malign-loops=%d is not between 0 and %d"
argument_list|,
name|i
argument_list|,
name|MAX_CODE_ALIGN
argument_list|)
expr_stmt|;
else|else
name|align_jumps
operator|=
literal|1
operator|<<
name|i
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ix86_align_funcs_string
condition|)
block|{
name|warning
argument_list|(
literal|"-malign-functions is obsolete, use -falign-functions"
argument_list|)
expr_stmt|;
if|if
condition|(
name|align_functions
operator|==
literal|0
condition|)
block|{
name|i
operator|=
name|atoi
argument_list|(
name|ix86_align_funcs_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|>
name|MAX_CODE_ALIGN
condition|)
name|error
argument_list|(
literal|"-malign-loops=%d is not between 0 and %d"
argument_list|,
name|i
argument_list|,
name|MAX_CODE_ALIGN
argument_list|)
expr_stmt|;
else|else
name|align_functions
operator|=
literal|1
operator|<<
name|i
expr_stmt|;
block|}
block|}
comment|/* Default align_* from the processor table.  */
if|if
condition|(
name|align_loops
operator|==
literal|0
condition|)
block|{
name|align_loops
operator|=
name|processor_target_table
index|[
name|ix86_cpu
index|]
operator|.
name|align_loop
expr_stmt|;
name|align_loops_max_skip
operator|=
name|processor_target_table
index|[
name|ix86_cpu
index|]
operator|.
name|align_loop_max_skip
expr_stmt|;
block|}
if|if
condition|(
name|align_jumps
operator|==
literal|0
condition|)
block|{
name|align_jumps
operator|=
name|processor_target_table
index|[
name|ix86_cpu
index|]
operator|.
name|align_jump
expr_stmt|;
name|align_jumps_max_skip
operator|=
name|processor_target_table
index|[
name|ix86_cpu
index|]
operator|.
name|align_jump_max_skip
expr_stmt|;
block|}
if|if
condition|(
name|align_functions
operator|==
literal|0
condition|)
block|{
name|align_functions
operator|=
name|processor_target_table
index|[
name|ix86_cpu
index|]
operator|.
name|align_func
expr_stmt|;
block|}
comment|/* Validate -mpreferred-stack-boundary= value, or provide default.      The default of 128 bits is for Pentium III's SSE __m128, but we      don't want additional code to keep the stack aligned when      optimizing for code size.  */
name|ix86_preferred_stack_boundary
operator|=
operator|(
name|optimize_size
condition|?
name|TARGET_64BIT
condition|?
literal|64
else|:
literal|32
else|:
literal|128
operator|)
expr_stmt|;
if|if
condition|(
name|ix86_preferred_stack_boundary_string
condition|)
block|{
name|i
operator|=
name|atoi
argument_list|(
name|ix86_preferred_stack_boundary_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
operator|(
name|TARGET_64BIT
condition|?
literal|3
else|:
literal|2
operator|)
operator|||
name|i
operator|>
literal|12
condition|)
name|error
argument_list|(
literal|"-mpreferred-stack-boundary=%d is not between %d and 12"
argument_list|,
name|i
argument_list|,
name|TARGET_64BIT
condition|?
literal|3
else|:
literal|2
argument_list|)
expr_stmt|;
else|else
name|ix86_preferred_stack_boundary
operator|=
operator|(
literal|1
operator|<<
name|i
operator|)
operator|*
name|BITS_PER_UNIT
expr_stmt|;
block|}
comment|/* Validate -mbranch-cost= value, or provide default.  */
name|ix86_branch_cost
operator|=
name|processor_target_table
index|[
name|ix86_cpu
index|]
operator|.
name|branch_cost
expr_stmt|;
if|if
condition|(
name|ix86_branch_cost_string
condition|)
block|{
name|i
operator|=
name|atoi
argument_list|(
name|ix86_branch_cost_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|>
literal|5
condition|)
name|error
argument_list|(
literal|"-mbranch-cost=%d is not between 0 and 5"
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
name|ix86_branch_cost
operator|=
name|i
expr_stmt|;
block|}
comment|/* Keep nonleaf frame pointers.  */
if|if
condition|(
name|TARGET_OMIT_LEAF_FRAME_POINTER
condition|)
name|flag_omit_frame_pointer
operator|=
literal|1
expr_stmt|;
comment|/* If we're doing fast math, we don't care about comparison order      wrt NaNs.  This lets us use a shorter comparison sequence.  */
if|if
condition|(
name|flag_unsafe_math_optimizations
condition|)
name|target_flags
operator|&=
operator|~
name|MASK_IEEE_FP
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
if|if
condition|(
name|TARGET_ALIGN_DOUBLE
condition|)
name|error
argument_list|(
literal|"-malign-double makes no sense in the 64bit mode"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_RTD
condition|)
name|error
argument_list|(
literal|"-mrtd calling convention not supported in the 64bit mode"
argument_list|)
expr_stmt|;
comment|/* Enable by default the SSE and MMX builtins.  */
name|target_flags
operator||=
operator|(
name|MASK_SSE2
operator||
name|MASK_SSE
operator||
name|MASK_MMX
operator||
name|MASK_128BIT_LONG_DOUBLE
operator|)
expr_stmt|;
name|ix86_fpmath
operator|=
name|FPMATH_SSE
expr_stmt|;
block|}
else|else
name|ix86_fpmath
operator|=
name|FPMATH_387
expr_stmt|;
if|if
condition|(
name|ix86_fpmath_string
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ix86_fpmath_string
argument_list|,
literal|"387"
argument_list|)
condition|)
name|ix86_fpmath
operator|=
name|FPMATH_387
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ix86_fpmath_string
argument_list|,
literal|"sse"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|TARGET_SSE
condition|)
block|{
name|warning
argument_list|(
literal|"SSE instruction set disabled, using 387 arithmetics"
argument_list|)
expr_stmt|;
name|ix86_fpmath
operator|=
name|FPMATH_387
expr_stmt|;
block|}
else|else
name|ix86_fpmath
operator|=
name|FPMATH_SSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ix86_fpmath_string
argument_list|,
literal|"387,sse"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|ix86_fpmath_string
argument_list|,
literal|"sse,387"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|TARGET_SSE
condition|)
block|{
name|warning
argument_list|(
literal|"SSE instruction set disabled, using 387 arithmetics"
argument_list|)
expr_stmt|;
name|ix86_fpmath
operator|=
name|FPMATH_387
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|TARGET_80387
condition|)
block|{
name|warning
argument_list|(
literal|"387 instruction set disabled, using SSE arithmetics"
argument_list|)
expr_stmt|;
name|ix86_fpmath
operator|=
name|FPMATH_SSE
expr_stmt|;
block|}
else|else
name|ix86_fpmath
operator|=
name|FPMATH_SSE
operator||
name|FPMATH_387
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"bad value (%s) for -mfpmath= switch"
argument_list|,
name|ix86_fpmath_string
argument_list|)
expr_stmt|;
block|}
comment|/* It makes no sense to ask for just SSE builtins, so MMX is also turned      on by -msse.  */
if|if
condition|(
name|TARGET_SSE
condition|)
block|{
name|target_flags
operator||=
name|MASK_MMX
expr_stmt|;
name|x86_prefetch_sse
operator|=
name|true
expr_stmt|;
block|}
comment|/* If it has 3DNow! it also has MMX so MMX is also turned on by -m3dnow */
if|if
condition|(
name|TARGET_3DNOW
condition|)
block|{
name|target_flags
operator||=
name|MASK_MMX
expr_stmt|;
comment|/* If we are targetting the Athlon architecture, enable the 3Dnow/MMX 	 extensions it adds.  */
if|if
condition|(
name|x86_3dnow_a
operator|&
operator|(
literal|1
operator|<<
name|ix86_arch
operator|)
condition|)
name|target_flags
operator||=
name|MASK_3DNOW_A
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|x86_accumulate_outgoing_args
operator|&
name|CPUMASK
operator|)
operator|&&
operator|!
operator|(
name|target_flags
operator|&
name|MASK_ACCUMULATE_OUTGOING_ARGS_SET
operator|)
operator|&&
operator|!
name|optimize_size
condition|)
name|target_flags
operator||=
name|MASK_ACCUMULATE_OUTGOING_ARGS
expr_stmt|;
comment|/* Figure out what ASM_GENERATE_INTERNAL_LABEL builds as a prefix.  */
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|internal_label_prefix
argument_list|,
literal|"LX"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|internal_label_prefix
argument_list|,
literal|'X'
argument_list|)
expr_stmt|;
name|internal_label_prefix_len
operator|=
name|p
operator|-
name|internal_label_prefix
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|optimization_options
parameter_list|(
name|level
parameter_list|,
name|size
parameter_list|)
name|int
name|level
decl_stmt|;
name|int
name|size
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
comment|/* For -O2 and beyond, turn off -fschedule-insns by default.  It tends to      make the problem with not enough registers even worse.  */
ifdef|#
directive|ifdef
name|INSN_SCHEDULING
if|if
condition|(
name|level
operator|>
literal|1
condition|)
name|flag_schedule_insns
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|TARGET_64BIT
operator|&&
name|optimize
operator|>=
literal|1
condition|)
name|flag_omit_frame_pointer
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
name|flag_pcc_struct_return
operator|=
literal|0
expr_stmt|;
name|flag_asynchronous_unwind_tables
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Table of valid machine attributes.  */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|attribute_spec
name|ix86_attribute_table
index|[]
init|=
block|{
comment|/* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */
comment|/* Stdcall attribute says callee is responsible for popping arguments      if they are not variable.  */
block|{
literal|"stdcall"
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|true
block|,
name|true
block|,
name|ix86_handle_cdecl_attribute
block|}
block|,
comment|/* Cdecl attribute says the callee is a normal C declaration */
block|{
literal|"cdecl"
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|true
block|,
name|true
block|,
name|ix86_handle_cdecl_attribute
block|}
block|,
comment|/* Regparm attribute specifies how many integer arguments are to be      passed in registers.  */
block|{
literal|"regparm"
block|,
literal|1
block|,
literal|1
block|,
name|false
block|,
name|true
block|,
name|true
block|,
name|ix86_handle_regparm_attribute
block|}
block|,
ifdef|#
directive|ifdef
name|TARGET_DLLIMPORT_DECL_ATTRIBUTES
block|{
literal|"dllimport"
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|ix86_handle_dll_attribute
block|}
block|,
block|{
literal|"dllexport"
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|ix86_handle_dll_attribute
block|}
block|,
block|{
literal|"shared"
block|,
literal|0
block|,
literal|0
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|ix86_handle_shared_attribute
block|}
block|,
endif|#
directive|endif
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Handle a "cdecl" or "stdcall" attribute;    arguments as in struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|ix86_handle_cdecl_attribute
parameter_list|(
name|node
parameter_list|,
name|name
parameter_list|,
name|args
parameter_list|,
name|flags
parameter_list|,
name|no_add_attrs
parameter_list|)
name|tree
modifier|*
name|node
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|tree
name|args
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|flags
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bool
modifier|*
name|no_add_attrs
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|!=
name|FUNCTION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|!=
name|METHOD_TYPE
operator|&&
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|!=
name|FIELD_DECL
operator|&&
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
block|{
name|warning
argument_list|(
literal|"`%s' attribute only applies to functions"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
name|warning
argument_list|(
literal|"`%s' attribute ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle a "regparm" attribute;    arguments as in struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|ix86_handle_regparm_attribute
parameter_list|(
name|node
parameter_list|,
name|name
parameter_list|,
name|args
parameter_list|,
name|flags
parameter_list|,
name|no_add_attrs
parameter_list|)
name|tree
modifier|*
name|node
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|tree
name|args
decl_stmt|;
name|int
name|flags
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bool
modifier|*
name|no_add_attrs
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|!=
name|FUNCTION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|!=
name|METHOD_TYPE
operator|&&
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|!=
name|FIELD_DECL
operator|&&
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
block|{
name|warning
argument_list|(
literal|"`%s' attribute only applies to functions"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
name|tree
name|cst
decl_stmt|;
name|cst
operator|=
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cst
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
name|warning
argument_list|(
literal|"`%s' attribute requires an integer constant argument"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|compare_tree_int
argument_list|(
name|cst
argument_list|,
name|REGPARM_MAX
argument_list|)
operator|>
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"argument to `%s' attribute larger than %d"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|,
name|REGPARM_MAX
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|OSF_OS
argument_list|)
operator|||
name|defined
argument_list|(
name|TARGET_OSF1ELF
argument_list|)
end_if

begin_comment
comment|/* Generate the assembly code for function entry.  FILE is a stdio    stream to output the code to.  SIZE is an int: how many units of    temporary storage to allocate.     Refer to the array `regs_ever_live' to determine which registers to    save; `regs_ever_live[I]' is nonzero if register number I is ever    used in the function.  This function is responsible for knowing    which registers should not be saved even if used.     We override it here to allow for the new profiling code to go before    the prologue and the old mcount code to go after the prologue (and    after %ebx has been set up for ELF shared library support).  */
end_comment

begin_function
specifier|static
name|void
name|ix86_osf_output_function_prologue
parameter_list|(
name|file
parameter_list|,
name|size
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|HOST_WIDE_INT
name|size
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|prefix
init|=
literal|""
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|lprefix
init|=
name|LPREFIX
decl_stmt|;
name|int
name|labelno
init|=
name|profile_label_no
decl_stmt|;
ifdef|#
directive|ifdef
name|OSF_OS
if|if
condition|(
name|TARGET_UNDERSCORES
condition|)
name|prefix
operator|=
literal|"_"
expr_stmt|;
if|if
condition|(
name|current_function_profile
operator|&&
name|OSF_PROFILE_BEFORE_PROLOGUE
condition|)
block|{
if|if
condition|(
operator|!
name|flag_pic
operator|&&
operator|!
name|HALF_PIC_P
argument_list|()
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tmovl $%sP%d,%%edx\n"
argument_list|,
name|lprefix
argument_list|,
name|labelno
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tcall *%s_mcount_ptr\n"
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|HALF_PIC_P
argument_list|()
condition|)
block|{
name|rtx
name|symref
decl_stmt|;
name|HALF_PIC_EXTERNAL
argument_list|(
literal|"_mcount_ptr"
argument_list|)
expr_stmt|;
name|symref
operator|=
name|HALF_PIC_PTR
argument_list|(
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
literal|"_mcount_ptr"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tmovl $%sP%d,%%edx\n"
argument_list|,
name|lprefix
argument_list|,
name|labelno
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tmovl %s%s,%%eax\n"
argument_list|,
name|prefix
argument_list|,
name|XSTR
argument_list|(
name|symref
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tcall *(%%eax)\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|static
name|int
name|call_no
init|=
literal|0
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tcall %sPc%d\n"
argument_list|,
name|lprefix
argument_list|,
name|call_no
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%sPc%d:\tpopl %%eax\n"
argument_list|,
name|lprefix
argument_list|,
name|call_no
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\taddl $_GLOBAL_OFFSET_TABLE_+[.-%sPc%d],%%eax\n"
argument_list|,
name|lprefix
argument_list|,
name|call_no
operator|++
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tleal %sP%d@GOTOFF(%%eax),%%edx\n"
argument_list|,
name|lprefix
argument_list|,
name|labelno
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tmovl %s_mcount_ptr@GOT(%%eax),%%eax\n"
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tcall *(%%eax)\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|#
directive|else
comment|/* !OSF_OS */
if|if
condition|(
name|current_function_profile
operator|&&
name|OSF_PROFILE_BEFORE_PROLOGUE
condition|)
block|{
if|if
condition|(
operator|!
name|flag_pic
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tmovl $%sP%d,%%edx\n"
argument_list|,
name|lprefix
argument_list|,
name|labelno
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tcall *%s_mcount_ptr\n"
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|static
name|int
name|call_no
init|=
literal|0
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tcall %sPc%d\n"
argument_list|,
name|lprefix
argument_list|,
name|call_no
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%sPc%d:\tpopl %%eax\n"
argument_list|,
name|lprefix
argument_list|,
name|call_no
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\taddl $_GLOBAL_OFFSET_TABLE_+[.-%sPc%d],%%eax\n"
argument_list|,
name|lprefix
argument_list|,
name|call_no
operator|++
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tleal %sP%d@GOTOFF(%%eax),%%edx\n"
argument_list|,
name|lprefix
argument_list|,
name|labelno
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tmovl %s_mcount_ptr@GOT(%%eax),%%eax\n"
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tcall *(%%eax)\n"
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* !OSF_OS */
name|function_prologue
argument_list|(
name|file
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OSF_OS || TARGET_OSF1ELF */
end_comment

begin_comment
comment|/* Return 0 if the attributes for two types are incompatible, 1 if they    are compatible, and 2 if they are nearly compatible (which causes a    warning to be generated).  */
end_comment

begin_function
specifier|static
name|int
name|ix86_comp_type_attributes
parameter_list|(
name|type1
parameter_list|,
name|type2
parameter_list|)
name|tree
name|type1
decl_stmt|;
name|tree
name|type2
decl_stmt|;
block|{
comment|/* Check for mismatch of non-default calling convention.  */
specifier|const
name|char
modifier|*
specifier|const
name|rtdstr
init|=
name|TARGET_RTD
condition|?
literal|"cdecl"
else|:
literal|"stdcall"
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type1
argument_list|)
operator|!=
name|FUNCTION_TYPE
condition|)
return|return
literal|1
return|;
comment|/* Check for mismatched return types (cdecl vs stdcall).  */
if|if
condition|(
operator|!
name|lookup_attribute
argument_list|(
name|rtdstr
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|type1
argument_list|)
argument_list|)
operator|!=
operator|!
name|lookup_attribute
argument_list|(
name|rtdstr
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|type2
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Value is the number of bytes of arguments automatically    popped when returning from a subroutine call.    FUNDECL is the declaration node of the function (as a tree),    FUNTYPE is the data type of the function (as a tree),    or for a library call it is an identifier node for the subroutine name.    SIZE is the number of bytes of arguments passed on the stack.     On the 80386, the RTD insn may be used to pop them if the number      of args is fixed, but if the number is variable then the caller      must pop them all.  RTD can't be used for library calls now      because the library is compiled with the Unix compiler.    Use of RTD is a selectable option, since it is incompatible with    standard Unix calling sequences.  If the option is not selected,    the caller must always pop the args.     The attribute stdcall is equivalent to RTD on a per module basis.  */
end_comment

begin_function
name|int
name|ix86_return_pops_args
parameter_list|(
name|fundecl
parameter_list|,
name|funtype
parameter_list|,
name|size
parameter_list|)
name|tree
name|fundecl
decl_stmt|;
name|tree
name|funtype
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|int
name|rtd
init|=
name|TARGET_RTD
operator|&&
operator|(
operator|!
name|fundecl
operator|||
name|TREE_CODE
argument_list|(
name|fundecl
argument_list|)
operator|!=
name|IDENTIFIER_NODE
operator|)
decl_stmt|;
comment|/* Cdecl functions override -mrtd, and never pop the stack.  */
if|if
condition|(
operator|!
name|lookup_attribute
argument_list|(
literal|"cdecl"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|funtype
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Stdcall functions will pop the stack if not variable args.  */
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"stdcall"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|funtype
argument_list|)
argument_list|)
condition|)
name|rtd
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|rtd
operator|&&
operator|(
name|TYPE_ARG_TYPES
argument_list|(
name|funtype
argument_list|)
operator|==
name|NULL_TREE
operator|||
operator|(
name|TREE_VALUE
argument_list|(
name|tree_last
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|funtype
argument_list|)
argument_list|)
argument_list|)
operator|==
name|void_type_node
operator|)
operator|)
condition|)
return|return
name|size
return|;
block|}
comment|/* Lose any fake structure return argument.  */
if|if
condition|(
name|aggregate_value_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|funtype
argument_list|)
argument_list|)
operator|&&
operator|!
name|TARGET_64BIT
condition|)
return|return
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Argument support functions.  */
end_comment

begin_comment
comment|/* Return true when register may be used to pass function parameters.  */
end_comment

begin_function
name|bool
name|ix86_function_arg_regno_p
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|TARGET_64BIT
condition|)
return|return
operator|(
name|regno
operator|<
name|REGPARM_MAX
operator|||
operator|(
name|TARGET_SSE
operator|&&
name|SSE_REGNO_P
argument_list|(
name|regno
argument_list|)
operator|&&
operator|!
name|fixed_regs
index|[
name|regno
index|]
operator|)
operator|)
return|;
if|if
condition|(
name|SSE_REGNO_P
argument_list|(
name|regno
argument_list|)
operator|&&
name|TARGET_SSE
condition|)
return|return
name|true
return|;
comment|/* RAX is used as hidden argument to va_arg functions.  */
if|if
condition|(
operator|!
name|regno
condition|)
return|return
name|true
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGPARM_MAX
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regno
operator|==
name|x86_64_int_parameter_registers
index|[
name|i
index|]
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Initialize a variable CUM of type CUMULATIVE_ARGS    for a call to a function whose data type is FNTYPE.    For a library call, FNTYPE is 0.  */
end_comment

begin_function
name|void
name|init_cumulative_args
parameter_list|(
name|cum
parameter_list|,
name|fntype
parameter_list|,
name|libname
parameter_list|)
name|CUMULATIVE_ARGS
modifier|*
name|cum
decl_stmt|;
comment|/* Argument info to initialize */
name|tree
name|fntype
decl_stmt|;
comment|/* tree ptr for function decl */
name|rtx
name|libname
decl_stmt|;
comment|/* SYMBOL_REF of library name or 0 */
block|{
specifier|static
name|CUMULATIVE_ARGS
name|zero_cum
decl_stmt|;
name|tree
name|param
decl_stmt|,
name|next_param
decl_stmt|;
if|if
condition|(
name|TARGET_DEBUG_ARG
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ninit_cumulative_args ("
argument_list|)
expr_stmt|;
if|if
condition|(
name|fntype
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"fntype code = %s, ret code = %s"
argument_list|,
name|tree_code_name
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|fntype
argument_list|)
index|]
argument_list|,
name|tree_code_name
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|)
index|]
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"no fntype"
argument_list|)
expr_stmt|;
if|if
condition|(
name|libname
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|", libname = %s"
argument_list|,
name|XSTR
argument_list|(
name|libname
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|cum
operator|=
name|zero_cum
expr_stmt|;
comment|/* Set up the number of registers to use for passing arguments.  */
name|cum
operator|->
name|nregs
operator|=
name|ix86_regparm
expr_stmt|;
name|cum
operator|->
name|sse_nregs
operator|=
name|SSE_REGPARM_MAX
expr_stmt|;
if|if
condition|(
name|fntype
operator|&&
operator|!
name|TARGET_64BIT
condition|)
block|{
name|tree
name|attr
init|=
name|lookup_attribute
argument_list|(
literal|"regparm"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|fntype
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|attr
condition|)
name|cum
operator|->
name|nregs
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_VALUE
argument_list|(
name|attr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|cum
operator|->
name|maybe_vaarg
operator|=
name|false
expr_stmt|;
comment|/* Determine if this function has variable arguments.  This is      indicated by the last argument being 'void_type_mode' if there      are no variable arguments.  If there are variable arguments, then      we won't pass anything in registers */
if|if
condition|(
name|cum
operator|->
name|nregs
condition|)
block|{
for|for
control|(
name|param
operator|=
operator|(
name|fntype
operator|)
condition|?
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
else|:
literal|0
init|;
name|param
operator|!=
literal|0
condition|;
name|param
operator|=
name|next_param
control|)
block|{
name|next_param
operator|=
name|TREE_CHAIN
argument_list|(
name|param
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_param
operator|==
literal|0
operator|&&
name|TREE_VALUE
argument_list|(
name|param
argument_list|)
operator|!=
name|void_type_node
condition|)
block|{
if|if
condition|(
operator|!
name|TARGET_64BIT
condition|)
name|cum
operator|->
name|nregs
operator|=
literal|0
expr_stmt|;
name|cum
operator|->
name|maybe_vaarg
operator|=
name|true
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
operator|!
name|fntype
operator|&&
operator|!
name|libname
operator|)
operator|||
operator|(
name|fntype
operator|&&
operator|!
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
operator|)
condition|)
name|cum
operator|->
name|maybe_vaarg
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TARGET_DEBUG_ARG
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|", nregs=%d )\n"
argument_list|,
name|cum
operator|->
name|nregs
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* x86-64 register passing impleemntation.  See x86-64 ABI for details.  Goal    of this code is to classify each 8bytes of incoming argument by the register    class and assign registers accordingly.  */
end_comment

begin_comment
comment|/* Return the union class of CLASS1 and CLASS2.    See the x86-64 PS ABI for details.  */
end_comment

begin_function
specifier|static
name|enum
name|x86_64_reg_class
name|merge_classes
parameter_list|(
name|class1
parameter_list|,
name|class2
parameter_list|)
name|enum
name|x86_64_reg_class
name|class1
decl_stmt|,
name|class2
decl_stmt|;
block|{
comment|/* Rule #1: If both classes are equal, this is the resulting class.  */
if|if
condition|(
name|class1
operator|==
name|class2
condition|)
return|return
name|class1
return|;
comment|/* Rule #2: If one of the classes is NO_CLASS, the resulting class is      the other class.  */
if|if
condition|(
name|class1
operator|==
name|X86_64_NO_CLASS
condition|)
return|return
name|class2
return|;
if|if
condition|(
name|class2
operator|==
name|X86_64_NO_CLASS
condition|)
return|return
name|class1
return|;
comment|/* Rule #3: If one of the classes is MEMORY, the result is MEMORY.  */
if|if
condition|(
name|class1
operator|==
name|X86_64_MEMORY_CLASS
operator|||
name|class2
operator|==
name|X86_64_MEMORY_CLASS
condition|)
return|return
name|X86_64_MEMORY_CLASS
return|;
comment|/* Rule #4: If one of the classes is INTEGER, the result is INTEGER.  */
if|if
condition|(
operator|(
name|class1
operator|==
name|X86_64_INTEGERSI_CLASS
operator|&&
name|class2
operator|==
name|X86_64_SSESF_CLASS
operator|)
operator|||
operator|(
name|class2
operator|==
name|X86_64_INTEGERSI_CLASS
operator|&&
name|class1
operator|==
name|X86_64_SSESF_CLASS
operator|)
condition|)
return|return
name|X86_64_INTEGERSI_CLASS
return|;
if|if
condition|(
name|class1
operator|==
name|X86_64_INTEGER_CLASS
operator|||
name|class1
operator|==
name|X86_64_INTEGERSI_CLASS
operator|||
name|class2
operator|==
name|X86_64_INTEGER_CLASS
operator|||
name|class2
operator|==
name|X86_64_INTEGERSI_CLASS
condition|)
return|return
name|X86_64_INTEGER_CLASS
return|;
comment|/* Rule #5: If one of the classes is X87 or X87UP class, MEMORY is used.  */
if|if
condition|(
name|class1
operator|==
name|X86_64_X87_CLASS
operator|||
name|class1
operator|==
name|X86_64_X87UP_CLASS
operator|||
name|class2
operator|==
name|X86_64_X87_CLASS
operator|||
name|class2
operator|==
name|X86_64_X87UP_CLASS
condition|)
return|return
name|X86_64_MEMORY_CLASS
return|;
comment|/* Rule #6: Otherwise class SSE is used.  */
return|return
name|X86_64_SSE_CLASS
return|;
block|}
end_function

begin_comment
comment|/* Classify the argument of type TYPE and mode MODE.    CLASSES will be filled by the register class used to pass each word    of the operand.  The number of words is returned.  In case the parameter    should be passed in memory, 0 is returned. As a special case for zero    sized containers, classes[0] will be NO_CLASS and 1 is returned.     BIT_OFFSET is used internally for handling records and specifies offset    of the offset in bits modulo 256 to avoid overflow cases.     See the x86-64 PS ABI for details. */
end_comment

begin_function
specifier|static
name|int
name|classify_argument
parameter_list|(
name|mode
parameter_list|,
name|type
parameter_list|,
name|classes
parameter_list|,
name|bit_offset
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|enum
name|x86_64_reg_class
name|classes
index|[
name|MAX_CLASSES
index|]
decl_stmt|;
name|int
name|bit_offset
decl_stmt|;
block|{
name|int
name|bytes
init|=
operator|(
name|mode
operator|==
name|BLKmode
operator|)
condition|?
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
else|:
operator|(
name|int
operator|)
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|int
name|words
init|=
operator|(
name|bytes
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
decl_stmt|;
if|if
condition|(
name|type
operator|&&
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
name|tree
name|field
decl_stmt|;
name|enum
name|x86_64_reg_class
name|subclasses
index|[
name|MAX_CLASSES
index|]
decl_stmt|;
comment|/* On x86-64 we pass structures larger than 16 bytes on the stack.  */
if|if
condition|(
name|bytes
operator|>
literal|16
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
name|i
operator|++
control|)
name|classes
index|[
name|i
index|]
operator|=
name|X86_64_NO_CLASS
expr_stmt|;
comment|/* Zero sized arrays or structures are NO_CLASS.  We return 0 to 	 signalize memory class, so handle it as special case.  */
if|if
condition|(
operator|!
name|words
condition|)
block|{
name|classes
index|[
literal|0
index|]
operator|=
name|X86_64_NO_CLASS
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Classify each field of record and merge classes.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
block|{
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
name|int
name|num
decl_stmt|;
comment|/* Bitfields are always classified as integer.  Handle them 		     early, since later code would consider them to be 		     misaligned integers.  */
if|if
condition|(
name|DECL_BIT_FIELD
argument_list|(
name|field
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
name|int_bit_position
argument_list|(
name|field
argument_list|)
operator|/
literal|8
operator|/
literal|8
init|;
name|i
operator|<
operator|(
name|int_bit_position
argument_list|(
name|field
argument_list|)
operator|+
name|tree_low_cst
argument_list|(
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|+
literal|63
operator|)
operator|/
literal|8
operator|/
literal|8
condition|;
name|i
operator|++
control|)
name|classes
index|[
name|i
index|]
operator|=
name|merge_classes
argument_list|(
name|X86_64_INTEGER_CLASS
argument_list|,
name|classes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|num
operator|=
name|classify_argument
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
name|subclasses
argument_list|,
operator|(
name|int_bit_position
argument_list|(
name|field
argument_list|)
operator|+
name|bit_offset
operator|)
operator|%
literal|256
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|num
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|int
name|pos
init|=
operator|(
name|int_bit_position
argument_list|(
name|field
argument_list|)
operator|+
name|bit_offset
operator|)
operator|/
literal|8
operator|/
literal|8
decl_stmt|;
name|classes
index|[
name|i
operator|+
name|pos
index|]
operator|=
name|merge_classes
argument_list|(
name|subclasses
index|[
name|i
index|]
argument_list|,
name|classes
index|[
name|i
operator|+
name|pos
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/* Arrays are handled as small records.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|int
name|num
decl_stmt|;
name|num
operator|=
name|classify_argument
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|subclasses
argument_list|,
name|bit_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|num
condition|)
return|return
literal|0
return|;
comment|/* The partial classes are now full classes.  */
if|if
condition|(
name|subclasses
index|[
literal|0
index|]
operator|==
name|X86_64_SSESF_CLASS
operator|&&
name|bytes
operator|!=
literal|4
condition|)
name|subclasses
index|[
literal|0
index|]
operator|=
name|X86_64_SSE_CLASS
expr_stmt|;
if|if
condition|(
name|subclasses
index|[
literal|0
index|]
operator|==
name|X86_64_INTEGERSI_CLASS
operator|&&
name|bytes
operator|!=
literal|4
condition|)
name|subclasses
index|[
literal|0
index|]
operator|=
name|X86_64_INTEGER_CLASS
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
name|i
operator|++
control|)
name|classes
index|[
name|i
index|]
operator|=
name|subclasses
index|[
name|i
operator|%
name|num
index|]
expr_stmt|;
block|}
comment|/* Unions are similar to RECORD_TYPE but offset is always 0.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
name|int
name|num
decl_stmt|;
name|num
operator|=
name|classify_argument
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
name|subclasses
argument_list|,
name|bit_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|num
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
name|classes
index|[
name|i
index|]
operator|=
name|merge_classes
argument_list|(
name|subclasses
index|[
name|i
index|]
argument_list|,
name|classes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* Final merger cleanup.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
name|i
operator|++
control|)
block|{
comment|/* If one class is MEMORY, everything should be passed in 	     memory.  */
if|if
condition|(
name|classes
index|[
name|i
index|]
operator|==
name|X86_64_MEMORY_CLASS
condition|)
return|return
literal|0
return|;
comment|/* The X86_64_SSEUP_CLASS should be always preceded by 	     X86_64_SSE_CLASS.  */
if|if
condition|(
name|classes
index|[
name|i
index|]
operator|==
name|X86_64_SSEUP_CLASS
operator|&&
operator|(
name|i
operator|==
literal|0
operator|||
name|classes
index|[
name|i
operator|-
literal|1
index|]
operator|!=
name|X86_64_SSE_CLASS
operator|)
condition|)
name|classes
index|[
name|i
index|]
operator|=
name|X86_64_SSE_CLASS
expr_stmt|;
comment|/*  X86_64_X87UP_CLASS should be preceded by X86_64_X87_CLASS.  */
if|if
condition|(
name|classes
index|[
name|i
index|]
operator|==
name|X86_64_X87UP_CLASS
operator|&&
operator|(
name|i
operator|==
literal|0
operator|||
name|classes
index|[
name|i
operator|-
literal|1
index|]
operator|!=
name|X86_64_X87_CLASS
operator|)
condition|)
name|classes
index|[
name|i
index|]
operator|=
name|X86_64_SSE_CLASS
expr_stmt|;
block|}
return|return
name|words
return|;
block|}
comment|/* Compute alignment needed.  We align all types to natural boundaries with      exception of XFmode that is aligned to 64bits.  */
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|mode
operator|!=
name|BLKmode
condition|)
block|{
name|int
name|mode_alignment
init|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|XFmode
condition|)
name|mode_alignment
operator|=
literal|128
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|XCmode
condition|)
name|mode_alignment
operator|=
literal|256
expr_stmt|;
comment|/* Misaligned fields are always returned in memory.  */
if|if
condition|(
name|bit_offset
operator|%
name|mode_alignment
condition|)
return|return
literal|0
return|;
block|}
comment|/* Classification of atomic types.  */
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|DImode
case|:
case|case
name|SImode
case|:
case|case
name|HImode
case|:
case|case
name|QImode
case|:
case|case
name|CSImode
case|:
case|case
name|CHImode
case|:
case|case
name|CQImode
case|:
if|if
condition|(
name|bit_offset
operator|+
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<=
literal|32
condition|)
name|classes
index|[
literal|0
index|]
operator|=
name|X86_64_INTEGERSI_CLASS
expr_stmt|;
else|else
name|classes
index|[
literal|0
index|]
operator|=
name|X86_64_INTEGER_CLASS
expr_stmt|;
return|return
literal|1
return|;
case|case
name|CDImode
case|:
case|case
name|TImode
case|:
name|classes
index|[
literal|0
index|]
operator|=
name|classes
index|[
literal|1
index|]
operator|=
name|X86_64_INTEGER_CLASS
expr_stmt|;
return|return
literal|2
return|;
case|case
name|CTImode
case|:
name|classes
index|[
literal|0
index|]
operator|=
name|classes
index|[
literal|1
index|]
operator|=
name|X86_64_INTEGER_CLASS
expr_stmt|;
name|classes
index|[
literal|2
index|]
operator|=
name|classes
index|[
literal|3
index|]
operator|=
name|X86_64_INTEGER_CLASS
expr_stmt|;
return|return
literal|4
return|;
case|case
name|SFmode
case|:
if|if
condition|(
operator|!
operator|(
name|bit_offset
operator|%
literal|64
operator|)
condition|)
name|classes
index|[
literal|0
index|]
operator|=
name|X86_64_SSESF_CLASS
expr_stmt|;
else|else
name|classes
index|[
literal|0
index|]
operator|=
name|X86_64_SSE_CLASS
expr_stmt|;
return|return
literal|1
return|;
case|case
name|DFmode
case|:
name|classes
index|[
literal|0
index|]
operator|=
name|X86_64_SSEDF_CLASS
expr_stmt|;
return|return
literal|1
return|;
case|case
name|TFmode
case|:
name|classes
index|[
literal|0
index|]
operator|=
name|X86_64_X87_CLASS
expr_stmt|;
name|classes
index|[
literal|1
index|]
operator|=
name|X86_64_X87UP_CLASS
expr_stmt|;
return|return
literal|2
return|;
case|case
name|TCmode
case|:
name|classes
index|[
literal|0
index|]
operator|=
name|X86_64_X87_CLASS
expr_stmt|;
name|classes
index|[
literal|1
index|]
operator|=
name|X86_64_X87UP_CLASS
expr_stmt|;
name|classes
index|[
literal|2
index|]
operator|=
name|X86_64_X87_CLASS
expr_stmt|;
name|classes
index|[
literal|3
index|]
operator|=
name|X86_64_X87UP_CLASS
expr_stmt|;
return|return
literal|4
return|;
case|case
name|DCmode
case|:
name|classes
index|[
literal|0
index|]
operator|=
name|X86_64_SSEDF_CLASS
expr_stmt|;
name|classes
index|[
literal|1
index|]
operator|=
name|X86_64_SSEDF_CLASS
expr_stmt|;
return|return
literal|2
return|;
case|case
name|SCmode
case|:
name|classes
index|[
literal|0
index|]
operator|=
name|X86_64_SSE_CLASS
expr_stmt|;
return|return
literal|1
return|;
case|case
name|BLKmode
case|:
return|return
literal|0
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Examine the argument and return set number of register required in each    class.  Return 0 iff parameter should be passed in memory.  */
end_comment

begin_function
specifier|static
name|int
name|examine_argument
parameter_list|(
name|mode
parameter_list|,
name|type
parameter_list|,
name|in_return
parameter_list|,
name|int_nregs
parameter_list|,
name|sse_nregs
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|int
modifier|*
name|int_nregs
decl_stmt|,
decl|*
name|sse_nregs
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|in_return
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|enum
name|x86_64_reg_class
name|class
index|[
name|MAX_CLASSES
index|]
decl_stmt|;
name|int
name|n
init|=
name|classify_argument
argument_list|(
name|mode
argument_list|,
name|type
argument_list|,
name|class
argument_list|,
literal|0
argument_list|)
decl_stmt|;
operator|*
name|int_nregs
operator|=
literal|0
expr_stmt|;
operator|*
name|sse_nregs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
return|return
literal|0
return|;
for|for
control|(
name|n
operator|--
init|;
name|n
operator|>=
literal|0
condition|;
name|n
operator|--
control|)
switch|switch
condition|(
name|class
index|[
name|n
index|]
condition|)
block|{
case|case
name|X86_64_INTEGER_CLASS
case|:
case|case
name|X86_64_INTEGERSI_CLASS
case|:
operator|(
operator|*
name|int_nregs
operator|)
operator|++
expr_stmt|;
break|break;
case|case
name|X86_64_SSE_CLASS
case|:
case|case
name|X86_64_SSESF_CLASS
case|:
case|case
name|X86_64_SSEDF_CLASS
case|:
operator|(
operator|*
name|sse_nregs
operator|)
operator|++
expr_stmt|;
break|break;
case|case
name|X86_64_NO_CLASS
case|:
case|case
name|X86_64_SSEUP_CLASS
case|:
break|break;
case|case
name|X86_64_X87_CLASS
case|:
case|case
name|X86_64_X87UP_CLASS
case|:
if|if
condition|(
operator|!
name|in_return
condition|)
return|return
literal|0
return|;
break|break;
case|case
name|X86_64_MEMORY_CLASS
case|:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_block

begin_comment
comment|/* Construct container for the argument used by GCC interface.  See    FUNCTION_ARG for the detailed description.  */
end_comment

begin_function
specifier|static
name|rtx
name|construct_container
parameter_list|(
name|mode
parameter_list|,
name|type
parameter_list|,
name|in_return
parameter_list|,
name|nintregs
parameter_list|,
name|nsseregs
parameter_list|,
name|intreg
parameter_list|,
name|sse_regno
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|int
name|in_return
decl_stmt|;
name|int
name|nintregs
decl_stmt|,
name|nsseregs
decl_stmt|;
specifier|const
name|int
modifier|*
name|intreg
decl_stmt|;
name|int
name|sse_regno
decl_stmt|;
block|{
name|enum
name|machine_mode
name|tmpmode
decl_stmt|;
name|int
name|bytes
init|=
operator|(
name|mode
operator|==
name|BLKmode
operator|)
condition|?
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
else|:
operator|(
name|int
operator|)
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|enum
name|x86_64_reg_class
name|class
index|[
name|MAX_CLASSES
index|]
decl_stmt|;
name|int
name|n
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|nexps
init|=
literal|0
decl_stmt|;
name|int
name|needed_sseregs
decl_stmt|,
name|needed_intregs
decl_stmt|;
name|rtx
name|exp
index|[
name|MAX_CLASSES
index|]
decl_stmt|;
name|rtx
name|ret
decl_stmt|;
name|n
operator|=
name|classify_argument
argument_list|(
name|mode
argument_list|,
name|type
argument_list|,
name|class
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_DEBUG_ARG
condition|)
block|{
if|if
condition|(
operator|!
name|n
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Memory class\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Classes:"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %s"
argument_list|,
name|x86_64_reg_class_name
index|[
name|class
index|[
name|i
index|]
index|]
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|n
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|examine_argument
argument_list|(
name|mode
argument_list|,
name|type
argument_list|,
name|in_return
argument_list|,
operator|&
name|needed_intregs
argument_list|,
operator|&
name|needed_sseregs
argument_list|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|needed_intregs
operator|>
name|nintregs
operator|||
name|needed_sseregs
operator|>
name|nsseregs
condition|)
return|return
name|NULL
return|;
comment|/* First construct simple cases.  Avoid SCmode, since we want to use      single register to pass this type.  */
if|if
condition|(
name|n
operator|==
literal|1
operator|&&
name|mode
operator|!=
name|SCmode
condition|)
switch|switch
condition|(
name|class
index|[
literal|0
index|]
condition|)
block|{
case|case
name|X86_64_INTEGER_CLASS
case|:
case|case
name|X86_64_INTEGERSI_CLASS
case|:
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|intreg
index|[
literal|0
index|]
argument_list|)
return|;
case|case
name|X86_64_SSE_CLASS
case|:
case|case
name|X86_64_SSESF_CLASS
case|:
case|case
name|X86_64_SSEDF_CLASS
case|:
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|SSE_REGNO
argument_list|(
name|sse_regno
argument_list|)
argument_list|)
return|;
case|case
name|X86_64_X87_CLASS
case|:
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|FIRST_STACK_REG
argument_list|)
return|;
case|case
name|X86_64_NO_CLASS
case|:
comment|/* Zero sized array, struct or class.  */
return|return
name|NULL
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|==
literal|2
operator|&&
name|class
index|[
literal|0
index|]
operator|==
name|X86_64_SSE_CLASS
operator|&&
name|class
index|[
literal|1
index|]
operator|==
name|X86_64_SSEUP_CLASS
condition|)
return|return
name|gen_rtx_REG
argument_list|(
name|TImode
argument_list|,
name|SSE_REGNO
argument_list|(
name|sse_regno
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|n
operator|==
literal|2
operator|&&
name|class
index|[
literal|0
index|]
operator|==
name|X86_64_X87_CLASS
operator|&&
name|class
index|[
literal|1
index|]
operator|==
name|X86_64_X87UP_CLASS
condition|)
return|return
name|gen_rtx_REG
argument_list|(
name|TFmode
argument_list|,
name|FIRST_STACK_REG
argument_list|)
return|;
if|if
condition|(
name|n
operator|==
literal|2
operator|&&
name|class
index|[
literal|0
index|]
operator|==
name|X86_64_INTEGER_CLASS
operator|&&
name|class
index|[
literal|1
index|]
operator|==
name|X86_64_INTEGER_CLASS
operator|&&
operator|(
name|mode
operator|==
name|CDImode
operator|||
name|mode
operator|==
name|TImode
operator|)
operator|&&
name|intreg
index|[
literal|0
index|]
operator|+
literal|1
operator|==
name|intreg
index|[
literal|1
index|]
condition|)
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|intreg
index|[
literal|0
index|]
argument_list|)
return|;
if|if
condition|(
name|n
operator|==
literal|4
operator|&&
name|class
index|[
literal|0
index|]
operator|==
name|X86_64_X87_CLASS
operator|&&
name|class
index|[
literal|1
index|]
operator|==
name|X86_64_X87UP_CLASS
operator|&&
name|class
index|[
literal|2
index|]
operator|==
name|X86_64_X87_CLASS
operator|&&
name|class
index|[
literal|3
index|]
operator|==
name|X86_64_X87UP_CLASS
condition|)
return|return
name|gen_rtx_REG
argument_list|(
name|TCmode
argument_list|,
name|FIRST_STACK_REG
argument_list|)
return|;
comment|/* Otherwise figure out the entries of the PARALLEL.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|class
index|[
name|i
index|]
condition|)
block|{
case|case
name|X86_64_NO_CLASS
case|:
break|break;
case|case
name|X86_64_INTEGER_CLASS
case|:
case|case
name|X86_64_INTEGERSI_CLASS
case|:
comment|/* Merge TImodes on aligned occassions here too.  */
if|if
condition|(
name|i
operator|*
literal|8
operator|+
literal|8
operator|>
name|bytes
condition|)
name|tmpmode
operator|=
name|mode_for_size
argument_list|(
operator|(
name|bytes
operator|-
name|i
operator|*
literal|8
operator|)
operator|*
name|BITS_PER_UNIT
argument_list|,
name|MODE_INT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|class
index|[
name|i
index|]
operator|==
name|X86_64_INTEGERSI_CLASS
condition|)
name|tmpmode
operator|=
name|SImode
expr_stmt|;
else|else
name|tmpmode
operator|=
name|DImode
expr_stmt|;
comment|/* We've requested 24 bytes we don't have mode for.  Use DImode.  */
if|if
condition|(
name|tmpmode
operator|==
name|BLKmode
condition|)
name|tmpmode
operator|=
name|DImode
expr_stmt|;
name|exp
index|[
name|nexps
operator|++
index|]
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|tmpmode
argument_list|,
operator|*
name|intreg
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|i
operator|*
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|intreg
operator|++
expr_stmt|;
break|break;
case|case
name|X86_64_SSESF_CLASS
case|:
name|exp
index|[
name|nexps
operator|++
index|]
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|SFmode
argument_list|,
name|SSE_REGNO
argument_list|(
name|sse_regno
argument_list|)
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|i
operator|*
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|sse_regno
operator|++
expr_stmt|;
break|break;
case|case
name|X86_64_SSEDF_CLASS
case|:
name|exp
index|[
name|nexps
operator|++
index|]
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|DFmode
argument_list|,
name|SSE_REGNO
argument_list|(
name|sse_regno
argument_list|)
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|i
operator|*
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|sse_regno
operator|++
expr_stmt|;
break|break;
case|case
name|X86_64_SSE_CLASS
case|:
if|if
condition|(
name|i
operator|<
name|n
operator|&&
name|class
index|[
name|i
operator|+
literal|1
index|]
operator|==
name|X86_64_SSEUP_CLASS
condition|)
name|tmpmode
operator|=
name|TImode
operator|,
name|i
operator|++
expr_stmt|;
else|else
name|tmpmode
operator|=
name|DImode
expr_stmt|;
name|exp
index|[
name|nexps
operator|++
index|]
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|tmpmode
argument_list|,
name|SSE_REGNO
argument_list|(
name|sse_regno
argument_list|)
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|i
operator|*
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|sse_regno
operator|++
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
name|ret
operator|=
name|gen_rtx_PARALLEL
argument_list|(
name|mode
argument_list|,
name|rtvec_alloc
argument_list|(
name|nexps
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nexps
condition|;
name|i
operator|++
control|)
name|XVECEXP
argument_list|(
name|ret
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
operator|=
name|exp
index|[
name|i
index|]
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Update the data in CUM to advance over an argument    of mode MODE and data type TYPE.    (TYPE is null for libcalls where that information may not be available.)  */
end_comment

begin_function
name|void
name|function_arg_advance
parameter_list|(
name|cum
parameter_list|,
name|mode
parameter_list|,
name|type
parameter_list|,
name|named
parameter_list|)
name|CUMULATIVE_ARGS
modifier|*
name|cum
decl_stmt|;
comment|/* current arg information */
name|enum
name|machine_mode
name|mode
decl_stmt|;
comment|/* current arg mode */
name|tree
name|type
decl_stmt|;
comment|/* type of the argument or 0 if lib support */
name|int
name|named
decl_stmt|;
comment|/* whether or not the argument was named */
block|{
name|int
name|bytes
init|=
operator|(
name|mode
operator|==
name|BLKmode
operator|)
condition|?
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
else|:
operator|(
name|int
operator|)
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|int
name|words
init|=
operator|(
name|bytes
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
decl_stmt|;
if|if
condition|(
name|TARGET_DEBUG_ARG
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"function_adv (sz=%d, wds=%2d, nregs=%d, mode=%s, named=%d)\n\n"
argument_list|,
name|words
argument_list|,
name|cum
operator|->
name|words
argument_list|,
name|cum
operator|->
name|nregs
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|mode
argument_list|)
argument_list|,
name|named
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
name|int
name|int_nregs
decl_stmt|,
name|sse_nregs
decl_stmt|;
if|if
condition|(
operator|!
name|examine_argument
argument_list|(
name|mode
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
operator|&
name|int_nregs
argument_list|,
operator|&
name|sse_nregs
argument_list|)
condition|)
name|cum
operator|->
name|words
operator|+=
name|words
expr_stmt|;
elseif|else
if|if
condition|(
name|sse_nregs
operator|<=
name|cum
operator|->
name|sse_nregs
operator|&&
name|int_nregs
operator|<=
name|cum
operator|->
name|nregs
condition|)
block|{
name|cum
operator|->
name|nregs
operator|-=
name|int_nregs
expr_stmt|;
name|cum
operator|->
name|sse_nregs
operator|-=
name|sse_nregs
expr_stmt|;
name|cum
operator|->
name|regno
operator|+=
name|int_nregs
expr_stmt|;
name|cum
operator|->
name|sse_regno
operator|+=
name|sse_nregs
expr_stmt|;
block|}
else|else
name|cum
operator|->
name|words
operator|+=
name|words
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|TARGET_SSE
operator|&&
name|mode
operator|==
name|TImode
condition|)
block|{
name|cum
operator|->
name|sse_words
operator|+=
name|words
expr_stmt|;
name|cum
operator|->
name|sse_nregs
operator|-=
literal|1
expr_stmt|;
name|cum
operator|->
name|sse_regno
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|cum
operator|->
name|sse_nregs
operator|<=
literal|0
condition|)
block|{
name|cum
operator|->
name|sse_nregs
operator|=
literal|0
expr_stmt|;
name|cum
operator|->
name|sse_regno
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|cum
operator|->
name|words
operator|+=
name|words
expr_stmt|;
name|cum
operator|->
name|nregs
operator|-=
name|words
expr_stmt|;
name|cum
operator|->
name|regno
operator|+=
name|words
expr_stmt|;
if|if
condition|(
name|cum
operator|->
name|nregs
operator|<=
literal|0
condition|)
block|{
name|cum
operator|->
name|nregs
operator|=
literal|0
expr_stmt|;
name|cum
operator|->
name|regno
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|/* Define where to put the arguments to a function.    Value is zero to push the argument on the stack,    or a hard register in which to store the argument.     MODE is the argument's machine mode.    TYPE is the data type of the argument (as a tree).     This is null for libcalls where that information may     not be available.    CUM is a variable of type CUMULATIVE_ARGS which gives info about     the preceding args and about the function being called.    NAMED is nonzero if this argument is a named parameter     (otherwise it is an extra parameter matching an ellipsis).  */
end_comment

begin_function
name|rtx
name|function_arg
parameter_list|(
name|cum
parameter_list|,
name|mode
parameter_list|,
name|type
parameter_list|,
name|named
parameter_list|)
name|CUMULATIVE_ARGS
modifier|*
name|cum
decl_stmt|;
comment|/* current arg information */
name|enum
name|machine_mode
name|mode
decl_stmt|;
comment|/* current arg mode */
name|tree
name|type
decl_stmt|;
comment|/* type of the argument or 0 if lib support */
name|int
name|named
decl_stmt|;
comment|/* != 0 for normal args, == 0 for ... args */
block|{
name|rtx
name|ret
init|=
name|NULL_RTX
decl_stmt|;
name|int
name|bytes
init|=
operator|(
name|mode
operator|==
name|BLKmode
operator|)
condition|?
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
else|:
operator|(
name|int
operator|)
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|int
name|words
init|=
operator|(
name|bytes
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
decl_stmt|;
comment|/* Handle an hidden AL argument containing number of registers for varargs      x86-64 functions.  For i386 ABI just return constm1_rtx to avoid      any AL settings.  */
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
block|{
if|if
condition|(
name|TARGET_64BIT
condition|)
return|return
name|GEN_INT
argument_list|(
name|cum
operator|->
name|maybe_vaarg
condition|?
operator|(
name|cum
operator|->
name|sse_nregs
operator|<
literal|0
condition|?
name|SSE_REGPARM_MAX
else|:
name|cum
operator|->
name|sse_regno
operator|)
else|:
operator|-
literal|1
argument_list|)
return|;
else|else
return|return
name|constm1_rtx
return|;
block|}
if|if
condition|(
name|TARGET_64BIT
condition|)
name|ret
operator|=
name|construct_container
argument_list|(
name|mode
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
name|cum
operator|->
name|nregs
argument_list|,
name|cum
operator|->
name|sse_nregs
argument_list|,
operator|&
name|x86_64_int_parameter_registers
index|[
name|cum
operator|->
name|regno
index|]
argument_list|,
name|cum
operator|->
name|sse_regno
argument_list|)
expr_stmt|;
else|else
switch|switch
condition|(
name|mode
condition|)
block|{
comment|/* For now, pass fp/complex values on the stack.  */
default|default:
break|break;
case|case
name|BLKmode
case|:
case|case
name|DImode
case|:
case|case
name|SImode
case|:
case|case
name|HImode
case|:
case|case
name|QImode
case|:
if|if
condition|(
name|words
operator|<=
name|cum
operator|->
name|nregs
condition|)
name|ret
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|cum
operator|->
name|regno
argument_list|)
expr_stmt|;
break|break;
case|case
name|TImode
case|:
if|if
condition|(
name|cum
operator|->
name|sse_nregs
condition|)
name|ret
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|cum
operator|->
name|sse_regno
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|TARGET_DEBUG_ARG
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"function_arg (size=%d, wds=%2d, nregs=%d, mode=%4s, named=%d"
argument_list|,
name|words
argument_list|,
name|cum
operator|->
name|words
argument_list|,
name|cum
operator|->
name|nregs
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|mode
argument_list|)
argument_list|,
name|named
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|", reg=%%e%s"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|ret
argument_list|)
index|]
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|", stack"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" )\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Gives the alignment boundary, in bits, of an argument with the specified mode    and type.   */
end_comment

begin_function
name|int
name|ix86_function_arg_boundary
parameter_list|(
name|mode
parameter_list|,
name|type
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
name|int
name|align
decl_stmt|;
if|if
condition|(
operator|!
name|TARGET_64BIT
condition|)
return|return
name|PARM_BOUNDARY
return|;
if|if
condition|(
name|type
condition|)
name|align
operator|=
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
expr_stmt|;
else|else
name|align
operator|=
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|align
operator|<
name|PARM_BOUNDARY
condition|)
name|align
operator|=
name|PARM_BOUNDARY
expr_stmt|;
if|if
condition|(
name|align
operator|>
literal|128
condition|)
name|align
operator|=
literal|128
expr_stmt|;
return|return
name|align
return|;
block|}
end_function

begin_comment
comment|/* Return true if N is a possible register number of function value.  */
end_comment

begin_function
name|bool
name|ix86_function_value_regno_p
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|TARGET_64BIT
condition|)
block|{
return|return
operator|(
operator|(
name|regno
operator|)
operator|==
literal|0
operator|||
operator|(
operator|(
name|regno
operator|)
operator|==
name|FIRST_FLOAT_REG
operator|&&
name|TARGET_FLOAT_RETURNS_IN_80387
operator|)
operator|||
operator|(
operator|(
name|regno
operator|)
operator|==
name|FIRST_SSE_REG
operator|&&
name|TARGET_SSE
operator|)
operator|)
return|;
block|}
return|return
operator|(
operator|(
name|regno
operator|)
operator|==
literal|0
operator|||
operator|(
name|regno
operator|)
operator|==
name|FIRST_FLOAT_REG
operator|||
operator|(
operator|(
name|regno
operator|)
operator|==
name|FIRST_SSE_REG
operator|&&
name|TARGET_SSE
operator|)
operator|||
operator|(
operator|(
name|regno
operator|)
operator|==
name|FIRST_FLOAT_REG
operator|&&
name|TARGET_FLOAT_RETURNS_IN_80387
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Define how to find the value returned by a function.    VALTYPE is the data type of the value (as a tree).    If the precise function being called is known, FUNC is its FUNCTION_DECL;    otherwise, FUNC is 0.  */
end_comment

begin_function
name|rtx
name|ix86_function_value
parameter_list|(
name|valtype
parameter_list|)
name|tree
name|valtype
decl_stmt|;
block|{
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
name|rtx
name|ret
init|=
name|construct_container
argument_list|(
name|TYPE_MODE
argument_list|(
name|valtype
argument_list|)
argument_list|,
name|valtype
argument_list|,
literal|1
argument_list|,
name|REGPARM_MAX
argument_list|,
name|SSE_REGPARM_MAX
argument_list|,
name|x86_64_int_return_registers
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* For zero sized structures, construct_continer return NULL, but we need          to keep rest of compiler happy by returning meaningfull value.  */
if|if
condition|(
operator|!
name|ret
condition|)
name|ret
operator|=
name|gen_rtx_REG
argument_list|(
name|TYPE_MODE
argument_list|(
name|valtype
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
else|else
return|return
name|gen_rtx_REG
argument_list|(
name|TYPE_MODE
argument_list|(
name|valtype
argument_list|)
argument_list|,
name|VALUE_REGNO
argument_list|(
name|TYPE_MODE
argument_list|(
name|valtype
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return false iff type is returned in memory.  */
end_comment

begin_function
name|int
name|ix86_return_in_memory
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|int
name|needed_intregs
decl_stmt|,
name|needed_sseregs
decl_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
return|return
operator|!
name|examine_argument
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|type
argument_list|,
literal|1
argument_list|,
operator|&
name|needed_intregs
argument_list|,
operator|&
name|needed_sseregs
argument_list|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|BLKmode
operator|||
operator|(
name|VECTOR_MODE_P
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
operator|==
literal|8
operator|)
operator|||
operator|(
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
operator|>
literal|12
operator|&&
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TImode
operator|&&
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TFmode
operator|&&
operator|!
name|VECTOR_MODE_P
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Define how to find the value returned by a library function    assuming the value has mode MODE.  */
end_comment

begin_function
name|rtx
name|ix86_libcall_value
parameter_list|(
name|mode
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|SFmode
case|:
case|case
name|SCmode
case|:
case|case
name|DFmode
case|:
case|case
name|DCmode
case|:
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|FIRST_SSE_REG
argument_list|)
return|;
case|case
name|TFmode
case|:
case|case
name|TCmode
case|:
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|FIRST_FLOAT_REG
argument_list|)
return|;
default|default:
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
literal|0
argument_list|)
return|;
block|}
block|}
else|else
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|VALUE_REGNO
argument_list|(
name|mode
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create the va_list data type.  */
end_comment

begin_function
name|tree
name|ix86_build_va_list
parameter_list|()
block|{
name|tree
name|f_gpr
decl_stmt|,
name|f_fpr
decl_stmt|,
name|f_ovf
decl_stmt|,
name|f_sav
decl_stmt|,
name|record
decl_stmt|,
name|type_decl
decl_stmt|;
comment|/* For i386 we use plain pointer to argument area.  */
if|if
condition|(
operator|!
name|TARGET_64BIT
condition|)
return|return
name|build_pointer_type
argument_list|(
name|char_type_node
argument_list|)
return|;
name|record
operator|=
name|make_lang_type
argument_list|(
name|RECORD_TYPE
argument_list|)
expr_stmt|;
name|type_decl
operator|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__va_list_tag"
argument_list|)
argument_list|,
name|record
argument_list|)
expr_stmt|;
name|f_gpr
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"gp_offset"
argument_list|)
argument_list|,
name|unsigned_type_node
argument_list|)
expr_stmt|;
name|f_fpr
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"fp_offset"
argument_list|)
argument_list|,
name|unsigned_type_node
argument_list|)
expr_stmt|;
name|f_ovf
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"overflow_arg_area"
argument_list|)
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
name|f_sav
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"reg_save_area"
argument_list|)
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|f_gpr
argument_list|)
operator|=
name|record
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|f_fpr
argument_list|)
operator|=
name|record
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|f_ovf
argument_list|)
operator|=
name|record
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|f_sav
argument_list|)
operator|=
name|record
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|record
argument_list|)
operator|=
name|type_decl
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|record
argument_list|)
operator|=
name|type_decl
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|record
argument_list|)
operator|=
name|f_gpr
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|f_gpr
argument_list|)
operator|=
name|f_fpr
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|f_fpr
argument_list|)
operator|=
name|f_ovf
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|f_ovf
argument_list|)
operator|=
name|f_sav
expr_stmt|;
name|layout_type
argument_list|(
name|record
argument_list|)
expr_stmt|;
comment|/* The correct type is an array type of one element.  */
return|return
name|build_array_type
argument_list|(
name|record
argument_list|,
name|build_index_type
argument_list|(
name|size_zero_node
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Perform any needed actions needed for a function that is receiving a    variable number of arguments.      CUM is as above.     MODE and TYPE are the mode and type of the current parameter.     PRETEND_SIZE is a variable that should be set to the amount of stack    that must be pushed by the prolog to pretend that our caller pushed    it.     Normally, this macro will push all remaining incoming registers on the    stack and set PRETEND_SIZE to the length of the registers pushed.  */
end_comment

begin_function
name|void
name|ix86_setup_incoming_varargs
parameter_list|(
name|cum
parameter_list|,
name|mode
parameter_list|,
name|type
parameter_list|,
name|pretend_size
parameter_list|,
name|no_rtl
parameter_list|)
name|CUMULATIVE_ARGS
modifier|*
name|cum
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|int
modifier|*
name|pretend_size
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|no_rtl
decl_stmt|;
block|{
name|CUMULATIVE_ARGS
name|next_cum
decl_stmt|;
name|rtx
name|save_area
init|=
name|NULL_RTX
decl_stmt|,
name|mem
decl_stmt|;
name|rtx
name|label
decl_stmt|;
name|rtx
name|label_ref
decl_stmt|;
name|rtx
name|tmp_reg
decl_stmt|;
name|rtx
name|nsse_reg
decl_stmt|;
name|int
name|set
decl_stmt|;
name|tree
name|fntype
decl_stmt|;
name|int
name|stdarg_p
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|TARGET_64BIT
condition|)
return|return;
comment|/* Indicate to allocate space on the stack for varargs save area.  */
name|ix86_save_varrargs_registers
operator|=
literal|1
expr_stmt|;
name|fntype
operator|=
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
name|stdarg_p
operator|=
operator|(
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|TREE_VALUE
argument_list|(
name|tree_last
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|void_type_node
operator|)
operator|)
expr_stmt|;
comment|/* For varargs, we do not want to skip the dummy va_dcl argument.      For stdargs, we do want to skip the last named argument.  */
name|next_cum
operator|=
operator|*
name|cum
expr_stmt|;
if|if
condition|(
name|stdarg_p
condition|)
name|function_arg_advance
argument_list|(
operator|&
name|next_cum
argument_list|,
name|mode
argument_list|,
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|no_rtl
condition|)
name|save_area
operator|=
name|frame_pointer_rtx
expr_stmt|;
name|set
operator|=
name|get_varargs_alias_set
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
name|next_cum
operator|.
name|regno
init|;
name|i
operator|<
name|ix86_regparm
condition|;
name|i
operator|++
control|)
block|{
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|plus_constant
argument_list|(
name|save_area
argument_list|,
name|i
operator|*
name|UNITS_PER_WORD
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|set
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|x86_64_int_parameter_registers
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|next_cum
operator|.
name|sse_nregs
condition|)
block|{
comment|/* Now emit code to save SSE registers.  The AX parameter contains number 	 of SSE parameter regsiters used to call this function.  We use 	 sse_prologue_save insn template that produces computed jump across 	 SSE saves.  We need some preparation work to get this working.  */
name|label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|label_ref
operator|=
name|gen_rtx_LABEL_REF
argument_list|(
name|Pmode
argument_list|,
name|label
argument_list|)
expr_stmt|;
comment|/* Compute address to jump to :          label - 5*eax + nnamed_sse_arguments*5  */
name|tmp_reg
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|nsse_reg
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_zero_extendqidi2
argument_list|(
name|nsse_reg
argument_list|,
name|gen_rtx_REG
argument_list|(
name|QImode
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|tmp_reg
argument_list|,
name|gen_rtx_MULT
argument_list|(
name|Pmode
argument_list|,
name|nsse_reg
argument_list|,
name|GEN_INT
argument_list|(
literal|4
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_cum
operator|.
name|sse_regno
condition|)
name|emit_move_insn
argument_list|(
name|nsse_reg
argument_list|,
name|gen_rtx_CONST
argument_list|(
name|DImode
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|DImode
argument_list|,
name|label_ref
argument_list|,
name|GEN_INT
argument_list|(
name|next_cum
operator|.
name|sse_regno
operator|*
literal|4
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_move_insn
argument_list|(
name|nsse_reg
argument_list|,
name|label_ref
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_subdi3
argument_list|(
name|nsse_reg
argument_list|,
name|nsse_reg
argument_list|,
name|tmp_reg
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Compute address of memory block we save into.  We always use pointer 	 pointing 127 bytes after first byte to store - this is needed to keep 	 instruction size limited by 4 bytes.  */
name|tmp_reg
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|tmp_reg
argument_list|,
name|plus_constant
argument_list|(
name|save_area
argument_list|,
literal|8
operator|*
name|REGPARM_MAX
operator|+
literal|127
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|plus_constant
argument_list|(
name|tmp_reg
argument_list|,
operator|-
literal|127
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|set
argument_list|)
expr_stmt|;
name|set_mem_align
argument_list|(
name|mem
argument_list|,
name|BITS_PER_WORD
argument_list|)
expr_stmt|;
comment|/* And finally do the dirty job!  */
name|emit_insn
argument_list|(
name|gen_sse_prologue_save
argument_list|(
name|mem
argument_list|,
name|nsse_reg
argument_list|,
name|GEN_INT
argument_list|(
name|next_cum
operator|.
name|sse_regno
argument_list|)
argument_list|,
name|label
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Implement va_start.  */
end_comment

begin_function
name|void
name|ix86_va_start
parameter_list|(
name|stdarg_p
parameter_list|,
name|valist
parameter_list|,
name|nextarg
parameter_list|)
name|int
name|stdarg_p
decl_stmt|;
name|tree
name|valist
decl_stmt|;
name|rtx
name|nextarg
decl_stmt|;
block|{
name|HOST_WIDE_INT
name|words
decl_stmt|,
name|n_gpr
decl_stmt|,
name|n_fpr
decl_stmt|;
name|tree
name|f_gpr
decl_stmt|,
name|f_fpr
decl_stmt|,
name|f_ovf
decl_stmt|,
name|f_sav
decl_stmt|;
name|tree
name|gpr
decl_stmt|,
name|fpr
decl_stmt|,
name|ovf
decl_stmt|,
name|sav
decl_stmt|,
name|t
decl_stmt|;
comment|/* Only 64bit target needs something special.  */
if|if
condition|(
operator|!
name|TARGET_64BIT
condition|)
block|{
name|std_expand_builtin_va_start
argument_list|(
name|stdarg_p
argument_list|,
name|valist
argument_list|,
name|nextarg
argument_list|)
expr_stmt|;
return|return;
block|}
name|f_gpr
operator|=
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|va_list_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|f_fpr
operator|=
name|TREE_CHAIN
argument_list|(
name|f_gpr
argument_list|)
expr_stmt|;
name|f_ovf
operator|=
name|TREE_CHAIN
argument_list|(
name|f_fpr
argument_list|)
expr_stmt|;
name|f_sav
operator|=
name|TREE_CHAIN
argument_list|(
name|f_ovf
argument_list|)
expr_stmt|;
name|valist
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|valist
argument_list|)
argument_list|)
argument_list|,
name|valist
argument_list|)
expr_stmt|;
name|gpr
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_gpr
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_gpr
argument_list|)
expr_stmt|;
name|fpr
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_fpr
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_fpr
argument_list|)
expr_stmt|;
name|ovf
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_ovf
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_ovf
argument_list|)
expr_stmt|;
name|sav
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_sav
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_sav
argument_list|)
expr_stmt|;
comment|/* Count number of gp and fp argument registers used.  */
name|words
operator|=
name|current_function_args_info
operator|.
name|words
expr_stmt|;
name|n_gpr
operator|=
name|current_function_args_info
operator|.
name|regno
expr_stmt|;
name|n_fpr
operator|=
name|current_function_args_info
operator|.
name|sse_regno
expr_stmt|;
if|if
condition|(
name|TARGET_DEBUG_ARG
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"va_start: words = %d, n_gpr = %d, n_fpr = %d\n"
argument_list|,
operator|(
name|int
operator|)
name|words
argument_list|,
operator|(
name|int
operator|)
name|n_gpr
argument_list|,
operator|(
name|int
operator|)
name|n_fpr
argument_list|)
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|gpr
argument_list|)
argument_list|,
name|gpr
argument_list|,
name|build_int_2
argument_list|(
name|n_gpr
operator|*
literal|8
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|fpr
argument_list|)
argument_list|,
name|fpr
argument_list|,
name|build_int_2
argument_list|(
name|n_fpr
operator|*
literal|16
operator|+
literal|8
operator|*
name|REGPARM_MAX
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
comment|/* Find the overflow area.  */
name|t
operator|=
name|make_tree
argument_list|(
name|TREE_TYPE
argument_list|(
name|ovf
argument_list|)
argument_list|,
name|virtual_incoming_args_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|words
operator|!=
literal|0
condition|)
name|t
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|ovf
argument_list|)
argument_list|,
name|t
argument_list|,
name|build_int_2
argument_list|(
name|words
operator|*
name|UNITS_PER_WORD
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|ovf
argument_list|)
argument_list|,
name|ovf
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
comment|/* Find the register save area.      Prologue of the function save it right above stack frame.  */
name|t
operator|=
name|make_tree
argument_list|(
name|TREE_TYPE
argument_list|(
name|sav
argument_list|)
argument_list|,
name|frame_pointer_rtx
argument_list|)
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|sav
argument_list|)
argument_list|,
name|sav
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Implement va_arg.  */
end_comment

begin_function
name|rtx
name|ix86_va_arg
parameter_list|(
name|valist
parameter_list|,
name|type
parameter_list|)
name|tree
name|valist
decl_stmt|,
name|type
decl_stmt|;
block|{
specifier|static
name|int
name|intreg
index|[
literal|6
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|}
decl_stmt|;
name|tree
name|f_gpr
decl_stmt|,
name|f_fpr
decl_stmt|,
name|f_ovf
decl_stmt|,
name|f_sav
decl_stmt|;
name|tree
name|gpr
decl_stmt|,
name|fpr
decl_stmt|,
name|ovf
decl_stmt|,
name|sav
decl_stmt|,
name|t
decl_stmt|;
name|int
name|size
decl_stmt|,
name|rsize
decl_stmt|;
name|rtx
name|lab_false
decl_stmt|,
name|lab_over
init|=
name|NULL_RTX
decl_stmt|;
name|rtx
name|addr_rtx
decl_stmt|,
name|r
decl_stmt|;
name|rtx
name|container
decl_stmt|;
comment|/* Only 64bit target needs something special.  */
if|if
condition|(
operator|!
name|TARGET_64BIT
condition|)
block|{
return|return
name|std_expand_builtin_va_arg
argument_list|(
name|valist
argument_list|,
name|type
argument_list|)
return|;
block|}
name|f_gpr
operator|=
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|va_list_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|f_fpr
operator|=
name|TREE_CHAIN
argument_list|(
name|f_gpr
argument_list|)
expr_stmt|;
name|f_ovf
operator|=
name|TREE_CHAIN
argument_list|(
name|f_fpr
argument_list|)
expr_stmt|;
name|f_sav
operator|=
name|TREE_CHAIN
argument_list|(
name|f_ovf
argument_list|)
expr_stmt|;
name|valist
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|valist
argument_list|)
argument_list|)
argument_list|,
name|valist
argument_list|)
expr_stmt|;
name|gpr
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_gpr
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_gpr
argument_list|)
expr_stmt|;
name|fpr
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_fpr
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_fpr
argument_list|)
expr_stmt|;
name|ovf
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_ovf
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_ovf
argument_list|)
expr_stmt|;
name|sav
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_sav
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_sav
argument_list|)
expr_stmt|;
name|size
operator|=
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|rsize
operator|=
operator|(
name|size
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
expr_stmt|;
name|container
operator|=
name|construct_container
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
name|REGPARM_MAX
argument_list|,
name|SSE_REGPARM_MAX
argument_list|,
name|intreg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*    * Pull the value out of the saved registers ...    */
name|addr_rtx
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|container
condition|)
block|{
name|rtx
name|int_addr_rtx
decl_stmt|,
name|sse_addr_rtx
decl_stmt|;
name|int
name|needed_intregs
decl_stmt|,
name|needed_sseregs
decl_stmt|;
name|int
name|need_temp
decl_stmt|;
name|lab_over
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|lab_false
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|examine_argument
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
operator|&
name|needed_intregs
argument_list|,
operator|&
name|needed_sseregs
argument_list|)
expr_stmt|;
name|need_temp
operator|=
operator|(
operator|(
name|needed_intregs
operator|&&
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|>
literal|64
operator|)
operator|||
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|>
literal|128
operator|)
expr_stmt|;
comment|/* In case we are passing structure, verify that it is consetuctive block          on the register save area.  If not we need to do moves.  */
if|if
condition|(
operator|!
name|need_temp
operator|&&
operator|!
name|REG_P
argument_list|(
name|container
argument_list|)
condition|)
block|{
comment|/* Verify that all registers are strictly consetuctive  */
if|if
condition|(
name|SSE_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|container
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|container
argument_list|,
literal|0
argument_list|)
operator|&&
operator|!
name|need_temp
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|slot
init|=
name|XVECEXP
argument_list|(
name|container
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|slot
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|FIRST_SSE_REG
operator|+
operator|(
name|unsigned
name|int
operator|)
name|i
operator|||
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|slot
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|i
operator|*
literal|16
condition|)
name|need_temp
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|container
argument_list|,
literal|0
argument_list|)
operator|&&
operator|!
name|need_temp
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|slot
init|=
name|XVECEXP
argument_list|(
name|container
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|slot
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
operator|(
name|unsigned
name|int
operator|)
name|i
operator|||
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|slot
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|i
operator|*
literal|8
condition|)
name|need_temp
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|need_temp
condition|)
block|{
name|int_addr_rtx
operator|=
name|addr_rtx
expr_stmt|;
name|sse_addr_rtx
operator|=
name|addr_rtx
expr_stmt|;
block|}
else|else
block|{
name|int_addr_rtx
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|sse_addr_rtx
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
block|}
comment|/* First ensure that we fit completely in registers.  */
if|if
condition|(
name|needed_intregs
condition|)
block|{
name|emit_cmp_and_jump_insns
argument_list|(
name|expand_expr
argument_list|(
name|gpr
argument_list|,
name|NULL_RTX
argument_list|,
name|SImode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
operator|(
name|REGPARM_MAX
operator|-
name|needed_intregs
operator|+
literal|1
operator|)
operator|*
literal|8
argument_list|)
argument_list|,
name|GE
argument_list|,
name|const1_rtx
argument_list|,
name|SImode
argument_list|,
literal|1
argument_list|,
name|lab_false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|needed_sseregs
condition|)
block|{
name|emit_cmp_and_jump_insns
argument_list|(
name|expand_expr
argument_list|(
name|fpr
argument_list|,
name|NULL_RTX
argument_list|,
name|SImode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
operator|(
name|SSE_REGPARM_MAX
operator|-
name|needed_sseregs
operator|+
literal|1
operator|)
operator|*
literal|16
operator|+
name|REGPARM_MAX
operator|*
literal|8
argument_list|)
argument_list|,
name|GE
argument_list|,
name|const1_rtx
argument_list|,
name|SImode
argument_list|,
literal|1
argument_list|,
name|lab_false
argument_list|)
expr_stmt|;
block|}
comment|/* Compute index to start of area used for integer regs.  */
if|if
condition|(
name|needed_intregs
condition|)
block|{
name|t
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|ptr_type_node
argument_list|,
name|sav
argument_list|,
name|gpr
argument_list|)
expr_stmt|;
name|r
operator|=
name|expand_expr
argument_list|(
name|t
argument_list|,
name|int_addr_rtx
argument_list|,
name|Pmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|int_addr_rtx
condition|)
name|emit_move_insn
argument_list|(
name|int_addr_rtx
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|needed_sseregs
condition|)
block|{
name|t
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|ptr_type_node
argument_list|,
name|sav
argument_list|,
name|fpr
argument_list|)
expr_stmt|;
name|r
operator|=
name|expand_expr
argument_list|(
name|t
argument_list|,
name|sse_addr_rtx
argument_list|,
name|Pmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|sse_addr_rtx
condition|)
name|emit_move_insn
argument_list|(
name|sse_addr_rtx
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|need_temp
condition|)
block|{
name|int
name|i
decl_stmt|;
name|rtx
name|mem
decl_stmt|;
comment|/* Never use the memory itself, as it has the alias set.  */
name|addr_rtx
operator|=
name|XEXP
argument_list|(
name|assign_temp
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|addr_rtx
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|get_varargs_alias_set
argument_list|()
argument_list|)
expr_stmt|;
name|set_mem_align
argument_list|(
name|mem
argument_list|,
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|container
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|slot
init|=
name|XVECEXP
argument_list|(
name|container
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|rtx
name|reg
init|=
name|XEXP
argument_list|(
name|slot
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|reg
argument_list|)
decl_stmt|;
name|rtx
name|src_addr
decl_stmt|;
name|rtx
name|src_mem
decl_stmt|;
name|int
name|src_offset
decl_stmt|;
name|rtx
name|dest_mem
decl_stmt|;
if|if
condition|(
name|SSE_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
condition|)
block|{
name|src_addr
operator|=
name|sse_addr_rtx
expr_stmt|;
name|src_offset
operator|=
operator|(
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|-
name|FIRST_SSE_REG
operator|)
operator|*
literal|16
expr_stmt|;
block|}
else|else
block|{
name|src_addr
operator|=
name|int_addr_rtx
expr_stmt|;
name|src_offset
operator|=
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|*
literal|8
expr_stmt|;
block|}
name|src_mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode
argument_list|,
name|src_addr
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|src_mem
argument_list|,
name|get_varargs_alias_set
argument_list|()
argument_list|)
expr_stmt|;
name|src_mem
operator|=
name|adjust_address
argument_list|(
name|src_mem
argument_list|,
name|mode
argument_list|,
name|src_offset
argument_list|)
expr_stmt|;
name|dest_mem
operator|=
name|adjust_address
argument_list|(
name|mem
argument_list|,
name|mode
argument_list|,
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|slot
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|dest_mem
argument_list|,
name|src_mem
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|needed_intregs
condition|)
block|{
name|t
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|gpr
argument_list|)
argument_list|,
name|gpr
argument_list|,
name|build_int_2
argument_list|(
name|needed_intregs
operator|*
literal|8
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|gpr
argument_list|)
argument_list|,
name|gpr
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|needed_sseregs
condition|)
block|{
name|t
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|fpr
argument_list|)
argument_list|,
name|fpr
argument_list|,
name|build_int_2
argument_list|(
name|needed_sseregs
operator|*
literal|16
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|fpr
argument_list|)
argument_list|,
name|fpr
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
block|}
name|emit_jump_insn
argument_list|(
name|gen_jump
argument_list|(
name|lab_over
argument_list|)
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|lab_false
argument_list|)
expr_stmt|;
block|}
comment|/* ... otherwise out of the overflow area.  */
comment|/* Care for on-stack alignment if needed.  */
if|if
condition|(
name|FUNCTION_ARG_BOUNDARY
argument_list|(
name|VOIDmode
argument_list|,
name|type
argument_list|)
operator|<=
literal|64
condition|)
name|t
operator|=
name|ovf
expr_stmt|;
else|else
block|{
name|HOST_WIDE_INT
name|align
init|=
name|FUNCTION_ARG_BOUNDARY
argument_list|(
name|VOIDmode
argument_list|,
name|type
argument_list|)
operator|/
literal|8
decl_stmt|;
name|t
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|ovf
argument_list|)
argument_list|,
name|ovf
argument_list|,
name|build_int_2
argument_list|(
name|align
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|t
argument_list|,
name|build_int_2
argument_list|(
operator|-
name|align
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|save_expr
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|r
operator|=
name|expand_expr
argument_list|(
name|t
argument_list|,
name|addr_rtx
argument_list|,
name|Pmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|addr_rtx
condition|)
name|emit_move_insn
argument_list|(
name|addr_rtx
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|t
argument_list|,
name|build_int_2
argument_list|(
name|rsize
operator|*
name|UNITS_PER_WORD
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|ovf
argument_list|)
argument_list|,
name|ovf
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|container
condition|)
name|emit_label
argument_list|(
name|lab_over
argument_list|)
expr_stmt|;
return|return
name|addr_rtx
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if OP is general operand representable on x86_64.  */
end_comment

begin_function
name|int
name|x86_64_general_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|TARGET_64BIT
condition|)
return|return
name|general_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
if|if
condition|(
name|nonimmediate_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
name|x86_64_sign_extended_value
argument_list|(
name|op
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if OP is general operand representable on x86_64    as either sign extended or zero extended constant.  */
end_comment

begin_function
name|int
name|x86_64_szext_general_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|TARGET_64BIT
condition|)
return|return
name|general_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
if|if
condition|(
name|nonimmediate_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
name|x86_64_sign_extended_value
argument_list|(
name|op
argument_list|)
operator|||
name|x86_64_zero_extended_value
argument_list|(
name|op
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if OP is nonmemory operand representable on x86_64.  */
end_comment

begin_function
name|int
name|x86_64_nonmemory_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|TARGET_64BIT
condition|)
return|return
name|nonmemory_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
if|if
condition|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
name|x86_64_sign_extended_value
argument_list|(
name|op
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if OP is nonmemory operand acceptable by movabs patterns.  */
end_comment

begin_function
name|int
name|x86_64_movabs_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|TARGET_64BIT
operator|||
operator|!
name|flag_pic
condition|)
return|return
name|nonmemory_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
if|if
condition|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
name|x86_64_sign_extended_value
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
operator|&&
operator|!
name|symbolic_reference_mentioned_p
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if OP is nonmemory operand representable on x86_64.  */
end_comment

begin_function
name|int
name|x86_64_szext_nonmemory_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|TARGET_64BIT
condition|)
return|return
name|nonmemory_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
if|if
condition|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
name|x86_64_sign_extended_value
argument_list|(
name|op
argument_list|)
operator|||
name|x86_64_zero_extended_value
argument_list|(
name|op
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if OP is immediate operand representable on x86_64.  */
end_comment

begin_function
name|int
name|x86_64_immediate_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|TARGET_64BIT
condition|)
return|return
name|immediate_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
return|return
name|x86_64_sign_extended_value
argument_list|(
name|op
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if OP is immediate operand representable on x86_64.  */
end_comment

begin_function
name|int
name|x86_64_zext_immediate_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
name|x86_64_zero_extended_value
argument_list|(
name|op
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if OP is (const_int 1), else return zero.  */
end_comment

begin_function
name|int
name|const_int_1_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|==
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if OP is either a symbol reference or a sum of a symbol    reference and a constant.  */
end_comment

begin_function
name|int
name|symbolic_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
return|return
literal|1
return|;
case|case
name|CONST
case|:
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|LABEL_REF
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|UNSPEC
operator|&&
operator|(
name|XINT
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
operator|==
literal|6
operator|||
name|XINT
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
operator|==
literal|7
operator|||
name|XINT
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
operator|==
literal|15
operator|)
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
literal|0
return|;
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|LABEL_REF
condition|)
return|return
literal|1
return|;
comment|/* Only @GOTOFF gets offsets.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|UNSPEC
operator|||
name|XINT
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
operator|!=
literal|7
condition|)
return|return
literal|0
return|;
name|op
operator|=
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|LABEL_REF
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return true if the operand contains a @GOT or @GOTOFF reference.  */
end_comment

begin_function
name|int
name|pic_symbolic_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|CONST
condition|)
return|return
literal|0
return|;
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|UNSPEC
condition|)
return|return
literal|1
return|;
block|}
else|else
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|UNSPEC
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
literal|0
return|;
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|UNSPEC
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP is a symbolic operand that resolves locally.  */
end_comment

begin_function
specifier|static
name|int
name|local_symbolic_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|LABEL_REF
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
name|op
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|SYMBOL_REF
condition|)
return|return
literal|0
return|;
comment|/* These we've been told are local by varasm and encode_section_info      respectively.  */
if|if
condition|(
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|op
argument_list|)
operator|||
name|SYMBOL_REF_FLAG
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* There is, however, a not insubstantial body of code in the rest of      the compiler that assumes it can just stick the results of       ASM_GENERATE_INTERNAL_LABEL in a symbol_ref and have done.  */
comment|/* ??? This is a hack.  Should update the body of the compiler to      always create a DECL an invoke ENCODE_SECTION_INFO.  */
if|if
condition|(
name|strncmp
argument_list|(
name|XSTR
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|internal_label_prefix
argument_list|,
name|internal_label_prefix_len
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Test for a valid operand for a call instruction.  Don't allow the    arg pointer register or virtual regs since they may decay into    reg + const, which the patterns can't handle.  */
end_comment

begin_function
name|int
name|call_insn_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
comment|/* Disallow indirect through a virtual register.  This leads to      compiler aborts when trying to eliminate them.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|op
operator|==
name|arg_pointer_rtx
operator|||
name|op
operator|==
name|frame_pointer_rtx
operator|||
operator|(
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|<=
name|LAST_VIRTUAL_REGISTER
operator|)
operator|)
condition|)
return|return
literal|0
return|;
comment|/* Disallow `call 1234'.  Due to varying assembler lameness this      gets either rejected or translated to `call .+1234'.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
literal|0
return|;
comment|/* Explicitly allow SYMBOL_REF even if pic.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
return|return
literal|1
return|;
comment|/* Half-pic doesn't allow anything but registers and constants.      We've just taken care of the later.  */
if|if
condition|(
name|HALF_PIC_P
argument_list|()
condition|)
return|return
name|register_operand
argument_list|(
name|op
argument_list|,
name|Pmode
argument_list|)
return|;
comment|/* Otherwise we can allow any general_operand in the address.  */
return|return
name|general_operand
argument_list|(
name|op
argument_list|,
name|Pmode
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|constant_call_address_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
name|op
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SYMBOL_REF
return|;
block|}
end_function

begin_comment
comment|/* Match exactly zero and one.  */
end_comment

begin_function
name|int
name|const0_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
name|op
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|const1_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
name|op
operator|==
name|const1_rtx
return|;
block|}
end_function

begin_comment
comment|/* Match 2, 4, or 8.  Used for leal multiplicands.  */
end_comment

begin_function
name|int
name|const248_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|==
literal|2
operator|||
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|==
literal|4
operator|||
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|==
literal|8
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* True if this is a constant appropriate for an increment or decremenmt.  */
end_comment

begin_function
name|int
name|incdec_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
comment|/* On Pentium4, the inc and dec operations causes extra dependency on flag      registers, since carry flag is not set.  */
if|if
condition|(
name|TARGET_PENTIUM4
operator|&&
operator|!
name|optimize_size
condition|)
return|return
literal|0
return|;
return|return
name|op
operator|==
name|const1_rtx
operator|||
name|op
operator|==
name|constm1_rtx
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if OP is acceptable as operand of DImode shift    expander.  */
end_comment

begin_function
name|int
name|shiftdi_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|TARGET_64BIT
condition|)
return|return
name|nonimmediate_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
else|else
return|return
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return false if this is the stack pointer, or any other fake    register eliminable to the stack pointer.  Otherwise, this is    a register operand.     This is used to prevent esp from being used as an index reg.    Which would only happen in pathological cases.  */
end_comment

begin_function
name|int
name|reg_no_sp_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|rtx
name|t
init|=
name|op
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|SUBREG
condition|)
name|t
operator|=
name|SUBREG_REG
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|stack_pointer_rtx
operator|||
name|t
operator|==
name|arg_pointer_rtx
operator|||
name|t
operator|==
name|frame_pointer_rtx
condition|)
return|return
literal|0
return|;
return|return
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|mmx_reg_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
name|MMX_REG_P
argument_list|(
name|op
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return false if this is any eliminable register.  Otherwise    general_operand.  */
end_comment

begin_function
name|int
name|general_no_elim_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|rtx
name|t
init|=
name|op
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|SUBREG
condition|)
name|t
operator|=
name|SUBREG_REG
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|arg_pointer_rtx
operator|||
name|t
operator|==
name|frame_pointer_rtx
operator|||
name|t
operator|==
name|virtual_incoming_args_rtx
operator|||
name|t
operator|==
name|virtual_stack_vars_rtx
operator|||
name|t
operator|==
name|virtual_stack_dynamic_rtx
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|REG_P
argument_list|(
name|t
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|t
argument_list|)
operator|>=
name|FIRST_VIRTUAL_REGISTER
operator|&&
name|REGNO
argument_list|(
name|t
argument_list|)
operator|<=
name|LAST_VIRTUAL_REGISTER
condition|)
return|return
literal|0
return|;
return|return
name|general_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return false if this is any eliminable register.  Otherwise    register_operand or const_int.  */
end_comment

begin_function
name|int
name|nonmemory_no_elim_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|rtx
name|t
init|=
name|op
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|SUBREG
condition|)
name|t
operator|=
name|SUBREG_REG
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|arg_pointer_rtx
operator|||
name|t
operator|==
name|frame_pointer_rtx
operator|||
name|t
operator|==
name|virtual_incoming_args_rtx
operator|||
name|t
operator|==
name|virtual_stack_vars_rtx
operator|||
name|t
operator|==
name|virtual_stack_dynamic_rtx
condition|)
return|return
literal|0
return|;
return|return
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|||
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if op is a Q_REGS class register.  */
end_comment

begin_function
name|int
name|q_regs_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
return|return
name|QI_REG_P
argument_list|(
name|op
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if op is a NON_Q_REGS class register.  */
end_comment

begin_function
name|int
name|non_q_regs_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
return|return
name|NON_QI_REG_P
argument_list|(
name|op
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a comparison that can be used in the CMPSS/CMPPS    insns.  */
end_comment

begin_function
name|int
name|sse_comparison_operator
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
comment|/* Operations supported directly.  */
case|case
name|EQ
case|:
case|case
name|LT
case|:
case|case
name|LE
case|:
case|case
name|UNORDERED
case|:
case|case
name|NE
case|:
case|case
name|UNGE
case|:
case|case
name|UNGT
case|:
case|case
name|ORDERED
case|:
return|return
literal|1
return|;
comment|/* These are equivalent to ones above in non-IEEE comparisons.  */
case|case
name|UNEQ
case|:
case|case
name|UNLT
case|:
case|case
name|UNLE
case|:
case|case
name|LTGT
case|:
case|case
name|GE
case|:
case|case
name|GT
case|:
return|return
operator|!
name|TARGET_IEEE_FP
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a valid comparison operator in valid mode.  */
end_comment

begin_function
name|int
name|ix86_comparison_operator
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|enum
name|machine_mode
name|inmode
decl_stmt|;
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|!=
literal|'<'
condition|)
return|return
literal|0
return|;
name|inmode
operator|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|inmode
operator|==
name|CCFPmode
operator|||
name|inmode
operator|==
name|CCFPUmode
condition|)
block|{
name|enum
name|rtx_code
name|second_code
decl_stmt|,
name|bypass_code
decl_stmt|;
name|ix86_fp_comparison_codes
argument_list|(
name|code
argument_list|,
operator|&
name|bypass_code
argument_list|,
operator|&
name|code
argument_list|,
operator|&
name|second_code
argument_list|)
expr_stmt|;
return|return
operator|(
name|bypass_code
operator|==
name|NIL
operator|&&
name|second_code
operator|==
name|NIL
operator|)
return|;
block|}
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EQ
case|:
case|case
name|NE
case|:
return|return
literal|1
return|;
case|case
name|LT
case|:
case|case
name|GE
case|:
if|if
condition|(
name|inmode
operator|==
name|CCmode
operator|||
name|inmode
operator|==
name|CCGCmode
operator|||
name|inmode
operator|==
name|CCGOCmode
operator|||
name|inmode
operator|==
name|CCNOmode
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
case|case
name|LTU
case|:
case|case
name|GTU
case|:
case|case
name|LEU
case|:
case|case
name|ORDERED
case|:
case|case
name|UNORDERED
case|:
case|case
name|GEU
case|:
if|if
condition|(
name|inmode
operator|==
name|CCmode
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
case|case
name|GT
case|:
case|case
name|LE
case|:
if|if
condition|(
name|inmode
operator|==
name|CCmode
operator|||
name|inmode
operator|==
name|CCGCmode
operator|||
name|inmode
operator|==
name|CCNOmode
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a comparison operator that can be issued by fcmov.  */
end_comment

begin_function
name|int
name|fcmov_comparison_operator
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|enum
name|machine_mode
name|inmode
decl_stmt|;
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|!=
literal|'<'
condition|)
return|return
literal|0
return|;
name|inmode
operator|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|inmode
operator|==
name|CCFPmode
operator|||
name|inmode
operator|==
name|CCFPUmode
condition|)
block|{
name|enum
name|rtx_code
name|second_code
decl_stmt|,
name|bypass_code
decl_stmt|;
name|ix86_fp_comparison_codes
argument_list|(
name|code
argument_list|,
operator|&
name|bypass_code
argument_list|,
operator|&
name|code
argument_list|,
operator|&
name|second_code
argument_list|)
expr_stmt|;
if|if
condition|(
name|bypass_code
operator|!=
name|NIL
operator|||
name|second_code
operator|!=
name|NIL
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|ix86_fp_compare_code_to_integer
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
comment|/* i387 supports just limited amount of conditional codes.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LTU
case|:
case|case
name|GTU
case|:
case|case
name|LEU
case|:
case|case
name|GEU
case|:
if|if
condition|(
name|inmode
operator|==
name|CCmode
operator|||
name|inmode
operator|==
name|CCFPmode
operator|||
name|inmode
operator|==
name|CCFPUmode
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
case|case
name|ORDERED
case|:
case|case
name|UNORDERED
case|:
case|case
name|EQ
case|:
case|case
name|NE
case|:
return|return
literal|1
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a binary operator that can be promoted to wider mode.  */
end_comment

begin_function
name|int
name|promotable_binary_operator
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|MULT
case|:
comment|/* Modern CPUs have same latency for HImode and SImode multiply,          but 386 and 486 do HImode multiply faster.  */
return|return
name|ix86_cpu
operator|>
name|PROCESSOR_I486
return|;
case|case
name|PLUS
case|:
case|case
name|AND
case|:
case|case
name|IOR
case|:
case|case
name|XOR
case|:
case|case
name|ASHIFT
case|:
return|return
literal|1
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Nearly general operand, but accept any const_double, since we wish    to be able to drop them into memory rather than have them get pulled    into registers.  */
end_comment

begin_function
name|int
name|cmp_fp_expander_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
return|return
literal|1
return|;
return|return
name|general_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Match an SI or HImode register for a zero_extract.  */
end_comment

begin_function
name|int
name|ext_register_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|int
name|regno
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|TARGET_64BIT
operator|||
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|DImode
operator|)
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|SImode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|HImode
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|register_operand
argument_list|(
name|op
argument_list|,
name|VOIDmode
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Be curefull to accept only registers having upper parts.  */
name|regno
operator|=
name|REG_P
argument_list|(
name|op
argument_list|)
condition|?
name|REGNO
argument_list|(
name|op
argument_list|)
else|:
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|regno
operator|>
name|LAST_VIRTUAL_REGISTER
operator|||
name|regno
operator|<
literal|4
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if this is a valid binary floating-point operation.    OP is the expression matched, and MODE is its mode.  */
end_comment

begin_function
name|int
name|binary_fp_operator
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
case|case
name|MULT
case|:
case|case
name|DIV
case|:
return|return
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_function
name|int
name|mult_operator
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MULT
return|;
block|}
end_function

begin_function
name|int
name|div_operator
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|DIV
return|;
block|}
end_function

begin_function
name|int
name|arith_or_logical_operator
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|mode
operator|==
name|VOIDmode
operator|||
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|mode
operator|)
operator|&&
operator|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
literal|'c'
operator|||
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
literal|'2'
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if OP is memory operand with a displacement.  */
end_comment

begin_function
name|int
name|memory_displacement_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|struct
name|ix86_address
name|parts
decl_stmt|;
if|if
condition|(
operator|!
name|memory_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|ix86_decompose_address
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|parts
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|parts
operator|.
name|disp
operator|!=
name|NULL_RTX
return|;
block|}
end_function

begin_comment
comment|/* To avoid problems when jump re-emits comparisons like testqi_ext_ccno_0,    re-recognize the operand to avoid a copy_to_mode_reg that will fail.     ??? It seems likely that this will only work because cmpsi is an    expander, and no actual insns use this.  */
end_comment

begin_function
name|int
name|cmpsi_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|nonimmediate_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|AND
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|SImode
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
literal|8
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
literal|8
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if OP is memory operand that can not be represented by the    modRM array.  */
end_comment

begin_function
name|int
name|long_memory_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|memory_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|memory_address_length
argument_list|(
name|op
argument_list|)
operator|!=
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if the rtx is known aligned.  */
end_comment

begin_function
name|int
name|aligned_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|struct
name|ix86_address
name|parts
decl_stmt|;
if|if
condition|(
operator|!
name|general_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Registers and immediate operands are always "aligned".  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|MEM
condition|)
return|return
literal|1
return|;
comment|/* Don't even try to do any aligned optimizations with volatiles.  */
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Pushes and pops are only valid on the stack pointer.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|PRE_DEC
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|POST_INC
condition|)
return|return
literal|1
return|;
comment|/* Decode the address.  */
if|if
condition|(
operator|!
name|ix86_decompose_address
argument_list|(
name|op
argument_list|,
operator|&
name|parts
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Look for some component that isn't known to be aligned.  */
if|if
condition|(
name|parts
operator|.
name|index
condition|)
block|{
if|if
condition|(
name|parts
operator|.
name|scale
operator|<
literal|4
operator|&&
name|REGNO_POINTER_ALIGN
argument_list|(
name|REGNO
argument_list|(
name|parts
operator|.
name|index
argument_list|)
argument_list|)
operator|<
literal|32
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|parts
operator|.
name|base
condition|)
block|{
if|if
condition|(
name|REGNO_POINTER_ALIGN
argument_list|(
name|REGNO
argument_list|(
name|parts
operator|.
name|base
argument_list|)
argument_list|)
operator|<
literal|32
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|parts
operator|.
name|disp
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|parts
operator|.
name|disp
argument_list|)
operator|!=
name|CONST_INT
operator|||
operator|(
name|INTVAL
argument_list|(
name|parts
operator|.
name|disp
argument_list|)
operator|&
literal|3
operator|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
block|}
comment|/* Didn't find one -- this must be an aligned address.  */
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return true if the constant is something that can be loaded with    a special instruction.  Only handle 0.0 and 1.0; others are less    worthwhile.  */
end_comment

begin_function
name|int
name|standard_80387_constant_p
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_DOUBLE
operator|||
operator|!
name|FLOAT_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Note that on the 80387, other constants, such as pi, that we should support      too.  On some machines, these are much slower to load as standard constant,      than to load from doubles in memory.  */
if|if
condition|(
name|x
operator|==
name|CONST0_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|x
operator|==
name|CONST1_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
return|return
literal|2
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if X is FP constant we can load to SSE register w/o using memory.  */
end_comment

begin_function
name|int
name|standard_sse_constant_p
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_DOUBLE
condition|)
return|return
operator|-
literal|1
return|;
return|return
operator|(
name|x
operator|==
name|CONST0_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if OP contains a symbol reference */
end_comment

begin_function
name|int
name|symbolic_reference_mentioned_p
parameter_list|(
name|op
parameter_list|)
name|rtx
name|op
decl_stmt|;
block|{
specifier|register
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|LABEL_REF
condition|)
return|return
literal|1
return|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|op
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|symbolic_reference_mentioned_p
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|&&
name|symbolic_reference_mentioned_p
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if it is appropriate to emit `ret' instructions in the    body of a function.  Do this only if the epilogue is simple, needing a    couple of insns.  Prior to reloading, we can't tell how many registers    must be saved, so return 0 then.  Return 0 if there is no frame    marker to de-allocate.     If NON_SAVING_SETJMP is defined and true, then it is not possible    for the epilogue to be simple, so return 0.  This is a special case    since NON_SAVING_SETJMP will not cause regs_ever_live to change    until final, but jump_optimize may need to know sooner if a    `return' is OK.  */
end_comment

begin_function
name|int
name|ix86_can_use_return_insn_p
parameter_list|()
block|{
name|struct
name|ix86_frame
name|frame
decl_stmt|;
ifdef|#
directive|ifdef
name|NON_SAVING_SETJMP
if|if
condition|(
name|NON_SAVING_SETJMP
operator|&&
name|current_function_calls_setjmp
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|reload_completed
operator|||
name|frame_pointer_needed
condition|)
return|return
literal|0
return|;
comment|/* Don't allow more than 32 pop, since that's all we can do      with one instruction.  */
if|if
condition|(
name|current_function_pops_args
operator|&&
name|current_function_args_size
operator|>=
literal|32768
condition|)
return|return
literal|0
return|;
name|ix86_compute_frame_layout
argument_list|(
operator|&
name|frame
argument_list|)
expr_stmt|;
return|return
name|frame
operator|.
name|to_allocate
operator|==
literal|0
operator|&&
name|frame
operator|.
name|nregs
operator|==
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if VALUE can be stored in the sign extended immediate field.  */
end_comment

begin_function
name|int
name|x86_64_sign_extended_value
parameter_list|(
name|value
parameter_list|)
name|rtx
name|value
decl_stmt|;
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
condition|)
block|{
comment|/* CONST_DOUBLES never match, since HOST_BITS_PER_WIDE_INT is known          to be at least 32 and this all acceptable constants are 	 represented as CONST_INT.  */
case|case
name|CONST_INT
case|:
if|if
condition|(
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|32
condition|)
return|return
literal|1
return|;
else|else
block|{
name|HOST_WIDE_INT
name|val
init|=
name|trunc_int_for_mode
argument_list|(
name|INTVAL
argument_list|(
name|value
argument_list|)
argument_list|,
name|DImode
argument_list|)
decl_stmt|;
return|return
name|trunc_int_for_mode
argument_list|(
name|val
argument_list|,
name|SImode
argument_list|)
operator|==
name|val
return|;
block|}
break|break;
comment|/* For certain code models, the symbolic references are known to fit.  */
case|case
name|SYMBOL_REF
case|:
return|return
name|ix86_cmodel
operator|==
name|CM_SMALL
operator|||
name|ix86_cmodel
operator|==
name|CM_KERNEL
return|;
comment|/* For certain code models, the code is near as well.  */
case|case
name|LABEL_REF
case|:
return|return
name|ix86_cmodel
operator|!=
name|CM_LARGE
operator|&&
name|ix86_cmodel
operator|!=
name|CM_SMALL_PIC
return|;
comment|/* We also may accept the offsetted memory references in certain special          cases.  */
case|case
name|CONST
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|UNSPEC
operator|&&
name|XVECLEN
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
literal|1
operator|&&
name|XINT
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
literal|15
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|rtx
name|op1
init|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|op2
init|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|offset
decl_stmt|;
if|if
condition|(
name|ix86_cmodel
operator|==
name|CM_LARGE
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op2
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
literal|0
return|;
name|offset
operator|=
name|trunc_int_for_mode
argument_list|(
name|INTVAL
argument_list|(
name|op2
argument_list|)
argument_list|,
name|DImode
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
condition|)
block|{
case|case
name|SYMBOL_REF
case|:
comment|/* For CM_SMALL assume that latest object is 1MB before 		     end of 31bits boundary.  We may also accept pretty 		     large negative constants knowing that all objects are 		     in the positive half of address space.  */
if|if
condition|(
name|ix86_cmodel
operator|==
name|CM_SMALL
operator|&&
name|offset
operator|<
literal|1024
operator|*
literal|1024
operator|*
literal|1024
operator|&&
name|trunc_int_for_mode
argument_list|(
name|offset
argument_list|,
name|SImode
argument_list|)
operator|==
name|offset
condition|)
return|return
literal|1
return|;
comment|/* For CM_KERNEL we know that all object resist in the 		     negative half of 32bits address space.  We may not 		     accept negative offsets, since they may be just off 		     and we may accept pretty large positive ones.  */
if|if
condition|(
name|ix86_cmodel
operator|==
name|CM_KERNEL
operator|&&
name|offset
operator|>
literal|0
operator|&&
name|trunc_int_for_mode
argument_list|(
name|offset
argument_list|,
name|SImode
argument_list|)
operator|==
name|offset
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|LABEL_REF
case|:
comment|/* These conditions are similar to SYMBOL_REF ones, just the 		     constraints for code models differ.  */
if|if
condition|(
operator|(
name|ix86_cmodel
operator|==
name|CM_SMALL
operator|||
name|ix86_cmodel
operator|==
name|CM_MEDIUM
operator|)
operator|&&
name|offset
operator|<
literal|1024
operator|*
literal|1024
operator|*
literal|1024
operator|&&
name|trunc_int_for_mode
argument_list|(
name|offset
argument_list|,
name|SImode
argument_list|)
operator|==
name|offset
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|ix86_cmodel
operator|==
name|CM_KERNEL
operator|&&
name|offset
operator|>
literal|0
operator|&&
name|trunc_int_for_mode
argument_list|(
name|offset
argument_list|,
name|SImode
argument_list|)
operator|==
name|offset
condition|)
return|return
literal|1
return|;
break|break;
default|default:
return|return
literal|0
return|;
block|}
block|}
return|return
literal|0
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return 1 if VALUE can be stored in the zero extended immediate field.  */
end_comment

begin_function
name|int
name|x86_64_zero_extended_value
parameter_list|(
name|value
parameter_list|)
name|rtx
name|value
decl_stmt|;
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
condition|)
block|{
case|case
name|CONST_DOUBLE
case|:
if|if
condition|(
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|32
condition|)
return|return
operator|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
operator|==
name|VOIDmode
operator|&&
operator|!
name|CONST_DOUBLE_HIGH
argument_list|(
name|value
argument_list|)
operator|)
return|;
else|else
return|return
literal|0
return|;
case|case
name|CONST_INT
case|:
if|if
condition|(
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|32
condition|)
return|return
name|INTVAL
argument_list|(
name|value
argument_list|)
operator|>=
literal|0
return|;
else|else
return|return
operator|!
operator|(
name|INTVAL
argument_list|(
name|value
argument_list|)
operator|&
operator|~
operator|(
name|HOST_WIDE_INT
operator|)
literal|0xffffffff
operator|)
return|;
break|break;
comment|/* For certain code models, the symbolic references are known to fit.  */
case|case
name|SYMBOL_REF
case|:
return|return
name|ix86_cmodel
operator|==
name|CM_SMALL
return|;
comment|/* For certain code models, the code is near as well.  */
case|case
name|LABEL_REF
case|:
return|return
name|ix86_cmodel
operator|==
name|CM_SMALL
operator|||
name|ix86_cmodel
operator|==
name|CM_MEDIUM
return|;
comment|/* We also may accept the offsetted memory references in certain special          cases.  */
case|case
name|CONST
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|rtx
name|op1
init|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|op2
init|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|ix86_cmodel
operator|==
name|CM_LARGE
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
condition|)
block|{
case|case
name|SYMBOL_REF
case|:
return|return
literal|0
return|;
comment|/* For small code model we may accept pretty large positive 		     offsets, since one bit is available for free.  Negative 		     offsets are limited by the size of NULL pointer area 		     specified by the ABI.  */
if|if
condition|(
name|ix86_cmodel
operator|==
name|CM_SMALL
operator|&&
name|GET_CODE
argument_list|(
name|op2
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|trunc_int_for_mode
argument_list|(
name|INTVAL
argument_list|(
name|op2
argument_list|)
argument_list|,
name|DImode
argument_list|)
operator|>
operator|-
literal|0x10000
operator|&&
operator|(
name|trunc_int_for_mode
argument_list|(
name|INTVAL
argument_list|(
name|op2
argument_list|)
argument_list|,
name|SImode
argument_list|)
operator|==
name|INTVAL
argument_list|(
name|op2
argument_list|)
operator|)
condition|)
return|return
literal|1
return|;
comment|/* ??? For the kernel, we may accept adjustment of 		     -0x10000000, since we know that it will just convert 		     negative address space to positive, but perhaps this 		     is not worthwhile.  */
break|break;
case|case
name|LABEL_REF
case|:
comment|/* These conditions are similar to SYMBOL_REF ones, just the 		     constraints for code models differ.  */
if|if
condition|(
operator|(
name|ix86_cmodel
operator|==
name|CM_SMALL
operator|||
name|ix86_cmodel
operator|==
name|CM_MEDIUM
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|op2
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|trunc_int_for_mode
argument_list|(
name|INTVAL
argument_list|(
name|op2
argument_list|)
argument_list|,
name|DImode
argument_list|)
operator|>
operator|-
literal|0x10000
operator|&&
operator|(
name|trunc_int_for_mode
argument_list|(
name|INTVAL
argument_list|(
name|op2
argument_list|)
argument_list|,
name|SImode
argument_list|)
operator|==
name|INTVAL
argument_list|(
name|op2
argument_list|)
operator|)
condition|)
return|return
literal|1
return|;
break|break;
default|default:
return|return
literal|0
return|;
block|}
block|}
return|return
literal|0
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Value should be nonzero if functions must have frame pointers.    Zero means the frame pointer need not be set up (and parms may    be accessed via the stack pointer) in functions that seem suitable.  */
end_comment

begin_function
name|int
name|ix86_frame_pointer_required
parameter_list|()
block|{
comment|/* If we accessed previous frames, then the generated code expects      to be able to access the saved ebp value in our frame.  */
if|if
condition|(
name|cfun
operator|->
name|machine
operator|->
name|accesses_prev_frame
condition|)
return|return
literal|1
return|;
comment|/* Several x86 os'es need a frame pointer for other reasons,      usually pertaining to setjmp.  */
if|if
condition|(
name|SUBTARGET_FRAME_POINTER_REQUIRED
condition|)
return|return
literal|1
return|;
comment|/* In override_options, TARGET_OMIT_LEAF_FRAME_POINTER turns off      the frame pointer by default.  Turn it back on now if we've not      got a leaf function.  */
if|if
condition|(
name|TARGET_OMIT_LEAF_FRAME_POINTER
operator|&&
operator|!
name|leaf_function_p
argument_list|()
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Record that the current function accesses previous call frames.  */
end_comment

begin_function
name|void
name|ix86_setup_frame_addresses
parameter_list|()
block|{
name|cfun
operator|->
name|machine
operator|->
name|accesses_prev_frame
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|char
name|pic_label_name
index|[
literal|32
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This function generates code for -fpic that loads %ebx with    the return address of the caller and then returns.  */
end_comment

begin_function
name|void
name|ix86_asm_file_end
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|rtx
name|xops
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|TARGET_DEEP_BRANCH_PREDICTION
operator|||
name|pic_label_name
index|[
literal|0
index|]
operator|==
literal|0
condition|)
return|return;
comment|/* ??? Binutils 2.10 and earlier has a linkonce elimination bug related      to updating relocations to a section being discarded such that this      doesn't work.  Ought to detect this at configure time.  */
if|#
directive|if
literal|0
comment|/* The trick here is to create a linkonce section containing the      pic label thunk, but to refer to it with an internal label.      Because the label is internal, we don't have inter-dso name      binding issues on hosts that don't support ".hidden".       In order to use these macros, however, we must create a fake      function decl.  */
block|if (targetm.have_named_sections)     {       tree decl = build_decl (FUNCTION_DECL, 			      get_identifier ("i686.get_pc_thunk"), 			      error_mark_node);       DECL_ONE_ONLY (decl) = 1;       UNIQUE_SECTION (decl, 0);       named_section (decl, NULL);     }   else
else|#
directive|else
name|text_section
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* This used to call ASM_DECLARE_FUNCTION_NAME() but since it's an      internal (non-global) label that's being emitted, it didn't make      sense to have .type information for local labels.   This caused      the SCO OpenServer 5.0.4 ELF assembler grief (why are you giving      me debug info for a label that you're declaring non-global?) this      was changed to call ASM_OUTPUT_LABEL() instead.  */
name|ASM_OUTPUT_LABEL
argument_list|(
name|file
argument_list|,
name|pic_label_name
argument_list|)
expr_stmt|;
name|xops
index|[
literal|0
index|]
operator|=
name|pic_offset_table_rtx
expr_stmt|;
name|xops
index|[
literal|1
index|]
operator|=
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|stack_pointer_rtx
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"mov{l}\t{%1, %0|%0, %1}"
argument_list|,
name|xops
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ret"
argument_list|,
name|xops
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|load_pic_register
parameter_list|()
block|{
name|rtx
name|gotsym
decl_stmt|,
name|pclab
decl_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
name|abort
argument_list|()
expr_stmt|;
name|gotsym
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
literal|"_GLOBAL_OFFSET_TABLE_"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_DEEP_BRANCH_PREDICTION
condition|)
block|{
if|if
condition|(
operator|!
name|pic_label_name
index|[
literal|0
index|]
condition|)
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|pic_label_name
argument_list|,
literal|"LPR"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pclab
operator|=
name|gen_rtx_MEM
argument_list|(
name|QImode
argument_list|,
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|pic_label_name
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pclab
operator|=
name|gen_rtx_LABEL_REF
argument_list|(
name|VOIDmode
argument_list|,
name|gen_label_rtx
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|emit_insn
argument_list|(
name|gen_prologue_get_pc
argument_list|(
name|pic_offset_table_rtx
argument_list|,
name|pclab
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TARGET_DEEP_BRANCH_PREDICTION
condition|)
name|emit_insn
argument_list|(
name|gen_popsi1
argument_list|(
name|pic_offset_table_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_prologue_set_got
argument_list|(
name|pic_offset_table_rtx
argument_list|,
name|gotsym
argument_list|,
name|pclab
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate an "push" pattern for input ARG.  */
end_comment

begin_function
specifier|static
name|rtx
name|gen_push
parameter_list|(
name|arg
parameter_list|)
name|rtx
name|arg
decl_stmt|;
block|{
return|return
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_PRE_DEC
argument_list|(
name|Pmode
argument_list|,
name|stack_pointer_rtx
argument_list|)
argument_list|)
argument_list|,
name|arg
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if we need to save REGNO.  */
end_comment

begin_function
specifier|static
name|int
name|ix86_save_reg
parameter_list|(
name|regno
parameter_list|,
name|maybe_eh_return
parameter_list|)
name|int
name|regno
decl_stmt|;
name|int
name|maybe_eh_return
decl_stmt|;
block|{
if|if
condition|(
name|flag_pic
operator|&&
operator|!
name|TARGET_64BIT
operator|&&
name|regno
operator|==
name|PIC_OFFSET_TABLE_REGNUM
operator|&&
operator|(
name|current_function_uses_pic_offset_table
operator|||
name|current_function_uses_const_pool
operator|||
name|current_function_calls_eh_return
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|current_function_calls_eh_return
operator|&&
name|maybe_eh_return
condition|)
block|{
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|test
init|=
name|EH_RETURN_DATA_REGNO
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|test
operator|==
name|INVALID_REGNUM
condition|)
break|break;
if|if
condition|(
name|test
operator|==
operator|(
name|unsigned
operator|)
name|regno
condition|)
return|return
literal|1
return|;
block|}
block|}
return|return
operator|(
name|regs_ever_live
index|[
name|regno
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|regno
index|]
operator|&&
operator|!
name|fixed_regs
index|[
name|regno
index|]
operator|&&
operator|(
name|regno
operator|!=
name|HARD_FRAME_POINTER_REGNUM
operator|||
operator|!
name|frame_pointer_needed
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return number of registers to be saved on the stack.  */
end_comment

begin_function
specifier|static
name|int
name|ix86_nsaved_regs
parameter_list|()
block|{
name|int
name|nregs
init|=
literal|0
decl_stmt|;
name|int
name|regno
decl_stmt|;
for|for
control|(
name|regno
operator|=
name|FIRST_PSEUDO_REGISTER
operator|-
literal|1
init|;
name|regno
operator|>=
literal|0
condition|;
name|regno
operator|--
control|)
if|if
condition|(
name|ix86_save_reg
argument_list|(
name|regno
argument_list|,
name|true
argument_list|)
condition|)
name|nregs
operator|++
expr_stmt|;
return|return
name|nregs
return|;
block|}
end_function

begin_comment
comment|/* Return the offset between two registers, one to be eliminated, and the other    its replacement, at the start of a routine.  */
end_comment

begin_function
name|HOST_WIDE_INT
name|ix86_initial_elimination_offset
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|)
name|int
name|from
decl_stmt|;
name|int
name|to
decl_stmt|;
block|{
name|struct
name|ix86_frame
name|frame
decl_stmt|;
name|ix86_compute_frame_layout
argument_list|(
operator|&
name|frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|from
operator|==
name|ARG_POINTER_REGNUM
operator|&&
name|to
operator|==
name|HARD_FRAME_POINTER_REGNUM
condition|)
return|return
name|frame
operator|.
name|hard_frame_pointer_offset
return|;
elseif|else
if|if
condition|(
name|from
operator|==
name|FRAME_POINTER_REGNUM
operator|&&
name|to
operator|==
name|HARD_FRAME_POINTER_REGNUM
condition|)
return|return
name|frame
operator|.
name|hard_frame_pointer_offset
operator|-
name|frame
operator|.
name|frame_pointer_offset
return|;
else|else
block|{
if|if
condition|(
name|to
operator|!=
name|STACK_POINTER_REGNUM
condition|)
name|abort
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|from
operator|==
name|ARG_POINTER_REGNUM
condition|)
return|return
name|frame
operator|.
name|stack_pointer_offset
return|;
elseif|else
if|if
condition|(
name|from
operator|!=
name|FRAME_POINTER_REGNUM
condition|)
name|abort
argument_list|()
expr_stmt|;
else|else
return|return
name|frame
operator|.
name|stack_pointer_offset
operator|-
name|frame
operator|.
name|frame_pointer_offset
return|;
block|}
block|}
end_function

begin_comment
comment|/* Fill structure ix86_frame about frame of currently computed function.  */
end_comment

begin_function
specifier|static
name|void
name|ix86_compute_frame_layout
parameter_list|(
name|frame
parameter_list|)
name|struct
name|ix86_frame
modifier|*
name|frame
decl_stmt|;
block|{
name|HOST_WIDE_INT
name|total_size
decl_stmt|;
name|int
name|stack_alignment_needed
init|=
name|cfun
operator|->
name|stack_alignment_needed
operator|/
name|BITS_PER_UNIT
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|int
name|preferred_alignment
init|=
name|cfun
operator|->
name|preferred_stack_boundary
operator|/
name|BITS_PER_UNIT
decl_stmt|;
name|HOST_WIDE_INT
name|size
init|=
name|get_frame_size
argument_list|()
decl_stmt|;
name|frame
operator|->
name|nregs
operator|=
name|ix86_nsaved_regs
argument_list|()
expr_stmt|;
name|total_size
operator|=
name|size
expr_stmt|;
comment|/* Skip return value and save base pointer.  */
name|offset
operator|=
name|frame_pointer_needed
condition|?
name|UNITS_PER_WORD
operator|*
literal|2
else|:
name|UNITS_PER_WORD
expr_stmt|;
name|frame
operator|->
name|hard_frame_pointer_offset
operator|=
name|offset
expr_stmt|;
comment|/* Do some sanity checking of stack_alignment_needed and      preferred_alignment, since i386 port is the only using those features      that may break easily.  */
if|if
condition|(
name|size
operator|&&
operator|!
name|stack_alignment_needed
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|preferred_alignment
operator|<
name|STACK_BOUNDARY
operator|/
name|BITS_PER_UNIT
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|preferred_alignment
operator|>
name|PREFERRED_STACK_BOUNDARY
operator|/
name|BITS_PER_UNIT
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|stack_alignment_needed
operator|>
name|PREFERRED_STACK_BOUNDARY
operator|/
name|BITS_PER_UNIT
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|stack_alignment_needed
operator|<
name|STACK_BOUNDARY
operator|/
name|BITS_PER_UNIT
condition|)
name|stack_alignment_needed
operator|=
name|STACK_BOUNDARY
operator|/
name|BITS_PER_UNIT
expr_stmt|;
comment|/* Register save area */
name|offset
operator|+=
name|frame
operator|->
name|nregs
operator|*
name|UNITS_PER_WORD
expr_stmt|;
comment|/* Va-arg area */
if|if
condition|(
name|ix86_save_varrargs_registers
condition|)
block|{
name|offset
operator|+=
name|X86_64_VARARGS_SIZE
expr_stmt|;
name|frame
operator|->
name|va_arg_size
operator|=
name|X86_64_VARARGS_SIZE
expr_stmt|;
block|}
else|else
name|frame
operator|->
name|va_arg_size
operator|=
literal|0
expr_stmt|;
comment|/* Align start of frame for local function.  */
name|frame
operator|->
name|padding1
operator|=
operator|(
operator|(
name|offset
operator|+
name|stack_alignment_needed
operator|-
literal|1
operator|)
operator|&
operator|-
name|stack_alignment_needed
operator|)
operator|-
name|offset
expr_stmt|;
name|offset
operator|+=
name|frame
operator|->
name|padding1
expr_stmt|;
comment|/* Frame pointer points here.  */
name|frame
operator|->
name|frame_pointer_offset
operator|=
name|offset
expr_stmt|;
name|offset
operator|+=
name|size
expr_stmt|;
comment|/* Add outgoing arguments area.  */
if|if
condition|(
name|ACCUMULATE_OUTGOING_ARGS
condition|)
block|{
name|offset
operator|+=
name|current_function_outgoing_args_size
expr_stmt|;
name|frame
operator|->
name|outgoing_arguments_size
operator|=
name|current_function_outgoing_args_size
expr_stmt|;
block|}
else|else
name|frame
operator|->
name|outgoing_arguments_size
operator|=
literal|0
expr_stmt|;
comment|/* Align stack boundary.  */
name|frame
operator|->
name|padding2
operator|=
operator|(
operator|(
name|offset
operator|+
name|preferred_alignment
operator|-
literal|1
operator|)
operator|&
operator|-
name|preferred_alignment
operator|)
operator|-
name|offset
expr_stmt|;
name|offset
operator|+=
name|frame
operator|->
name|padding2
expr_stmt|;
comment|/* We've reached end of stack frame.  */
name|frame
operator|->
name|stack_pointer_offset
operator|=
name|offset
expr_stmt|;
comment|/* Size prologue needs to allocate.  */
name|frame
operator|->
name|to_allocate
operator|=
operator|(
name|size
operator|+
name|frame
operator|->
name|padding1
operator|+
name|frame
operator|->
name|padding2
operator|+
name|frame
operator|->
name|outgoing_arguments_size
operator|+
name|frame
operator|->
name|va_arg_size
operator|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
operator|&&
name|TARGET_RED_ZONE
operator|&&
name|current_function_sp_is_unchanging
operator|&&
name|current_function_is_leaf
condition|)
block|{
name|frame
operator|->
name|red_zone_size
operator|=
name|frame
operator|->
name|to_allocate
expr_stmt|;
if|if
condition|(
name|frame
operator|->
name|red_zone_size
operator|>
name|RED_ZONE_SIZE
operator|-
name|RED_ZONE_RESERVE
condition|)
name|frame
operator|->
name|red_zone_size
operator|=
name|RED_ZONE_SIZE
operator|-
name|RED_ZONE_RESERVE
expr_stmt|;
block|}
else|else
name|frame
operator|->
name|red_zone_size
operator|=
literal|0
expr_stmt|;
name|frame
operator|->
name|to_allocate
operator|-=
name|frame
operator|->
name|red_zone_size
expr_stmt|;
name|frame
operator|->
name|stack_pointer_offset
operator|-=
name|frame
operator|->
name|red_zone_size
expr_stmt|;
if|#
directive|if
literal|0
block|fprintf (stderr, "nregs: %i\n", frame->nregs);   fprintf (stderr, "size: %i\n", size);   fprintf (stderr, "alignment1: %i\n", stack_alignment_needed);   fprintf (stderr, "padding1: %i\n", frame->padding1);   fprintf (stderr, "va_arg: %i\n", frame->va_arg_size);   fprintf (stderr, "padding2: %i\n", frame->padding2);   fprintf (stderr, "to_allocate: %i\n", frame->to_allocate);   fprintf (stderr, "red_zone_size: %i\n", frame->red_zone_size);   fprintf (stderr, "frame_pointer_offset: %i\n", frame->frame_pointer_offset);   fprintf (stderr, "hard_frame_pointer_offset: %i\n", 	   frame->hard_frame_pointer_offset);   fprintf (stderr, "stack_pointer_offset: %i\n", frame->stack_pointer_offset);
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Emit code to save registers in the prologue.  */
end_comment

begin_function
specifier|static
name|void
name|ix86_emit_save_regs
parameter_list|()
block|{
specifier|register
name|int
name|regno
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|regno
operator|=
name|FIRST_PSEUDO_REGISTER
operator|-
literal|1
init|;
name|regno
operator|>=
literal|0
condition|;
name|regno
operator|--
control|)
if|if
condition|(
name|ix86_save_reg
argument_list|(
name|regno
argument_list|,
name|true
argument_list|)
condition|)
block|{
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_push
argument_list|(
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|regno
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Emit code to save registers using MOV insns.  First register    is restored from POINTER + OFFSET.  */
end_comment

begin_function
specifier|static
name|void
name|ix86_emit_save_regs_using_mov
parameter_list|(
name|pointer
parameter_list|,
name|offset
parameter_list|)
name|rtx
name|pointer
decl_stmt|;
name|HOST_WIDE_INT
name|offset
decl_stmt|;
block|{
name|int
name|regno
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|ix86_save_reg
argument_list|(
name|regno
argument_list|,
name|true
argument_list|)
condition|)
block|{
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|adjust_address
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|pointer
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|offset
argument_list|)
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|regno
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|offset
operator|+=
name|UNITS_PER_WORD
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Expand the prologue into a bunch of separate insns.  */
end_comment

begin_function
name|void
name|ix86_expand_prologue
parameter_list|()
block|{
name|rtx
name|insn
decl_stmt|;
name|int
name|pic_reg_used
init|=
operator|(
name|flag_pic
operator|&&
operator|(
name|current_function_uses_pic_offset_table
operator|||
name|current_function_uses_const_pool
operator|)
operator|&&
operator|!
name|TARGET_64BIT
operator|)
decl_stmt|;
name|struct
name|ix86_frame
name|frame
decl_stmt|;
name|int
name|use_mov
init|=
literal|0
decl_stmt|;
name|HOST_WIDE_INT
name|allocate
decl_stmt|;
if|if
condition|(
operator|!
name|optimize_size
condition|)
block|{
name|use_fast_prologue_epilogue
operator|=
operator|!
name|expensive_function_p
argument_list|(
name|FAST_PROLOGUE_INSN_COUNT
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_PROLOGUE_USING_MOVE
condition|)
name|use_mov
operator|=
name|use_fast_prologue_epilogue
expr_stmt|;
block|}
name|ix86_compute_frame_layout
argument_list|(
operator|&
name|frame
argument_list|)
expr_stmt|;
comment|/* Note: AT&T enter does NOT have reversed args.  Enter is probably      slower on all targets.  Also sdb doesn't like it.  */
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_push
argument_list|(
name|hard_frame_pointer_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|allocate
operator|=
name|frame
operator|.
name|to_allocate
expr_stmt|;
comment|/* In case we are dealing only with single register and empty frame,      push is equivalent of the mov+add sequence.  */
if|if
condition|(
name|allocate
operator|==
literal|0
operator|&&
name|frame
operator|.
name|nregs
operator|<=
literal|1
condition|)
name|use_mov
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|use_mov
condition|)
name|ix86_emit_save_regs
argument_list|()
expr_stmt|;
else|else
name|allocate
operator|+=
name|frame
operator|.
name|nregs
operator|*
name|UNITS_PER_WORD
expr_stmt|;
if|if
condition|(
name|allocate
operator|==
literal|0
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|TARGET_STACK_PROBE
operator|||
name|allocate
operator|<
name|CHECK_STACK_LIMIT
condition|)
block|{
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_pro_epilogue_adjust_stack
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
operator|-
name|allocate
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* ??? Is this only valid for Win32?  */
name|rtx
name|arg0
decl_stmt|,
name|sym
decl_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
name|abort
argument_list|()
expr_stmt|;
name|arg0
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|arg0
argument_list|,
name|GEN_INT
argument_list|(
name|allocate
argument_list|)
argument_list|)
expr_stmt|;
name|sym
operator|=
name|gen_rtx_MEM
argument_list|(
name|FUNCTION_MODE
argument_list|,
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
literal|"_alloca"
argument_list|)
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_call_insn
argument_list|(
name|gen_call
argument_list|(
name|sym
argument_list|,
name|const0_rtx
argument_list|,
name|constm1_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|arg0
argument_list|)
argument_list|,
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|use_mov
condition|)
block|{
if|if
condition|(
operator|!
name|frame_pointer_needed
operator|||
operator|!
name|frame
operator|.
name|to_allocate
condition|)
name|ix86_emit_save_regs_using_mov
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|frame
operator|.
name|to_allocate
argument_list|)
expr_stmt|;
else|else
name|ix86_emit_save_regs_using_mov
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
operator|-
name|frame
operator|.
name|nregs
operator|*
name|UNITS_PER_WORD
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SUBTARGET_PROLOGUE
name|SUBTARGET_PROLOGUE
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pic_reg_used
condition|)
name|load_pic_register
argument_list|()
expr_stmt|;
comment|/* If we are profiling, make sure no instructions are scheduled before      the call to mcount.  However, if -fpic, the above call will have      done that.  */
if|if
condition|(
name|current_function_profile
operator|&&
operator|!
name|pic_reg_used
condition|)
name|emit_insn
argument_list|(
name|gen_blockage
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit code to restore saved registers using MOV insns.  First register    is restored from POINTER + OFFSET.  */
end_comment

begin_function
specifier|static
name|void
name|ix86_emit_restore_regs_using_mov
parameter_list|(
name|pointer
parameter_list|,
name|offset
parameter_list|,
name|maybe_eh_return
parameter_list|)
name|rtx
name|pointer
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|int
name|maybe_eh_return
decl_stmt|;
block|{
name|int
name|regno
decl_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|ix86_save_reg
argument_list|(
name|regno
argument_list|,
name|maybe_eh_return
argument_list|)
condition|)
block|{
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|regno
argument_list|)
argument_list|,
name|adjust_address
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|pointer
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|UNITS_PER_WORD
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Restore function stack, frame, and registers.  */
end_comment

begin_function
name|void
name|ix86_expand_epilogue
parameter_list|(
name|style
parameter_list|)
name|int
name|style
decl_stmt|;
block|{
name|int
name|regno
decl_stmt|;
name|int
name|sp_valid
init|=
operator|!
name|frame_pointer_needed
operator|||
name|current_function_sp_is_unchanging
decl_stmt|;
name|struct
name|ix86_frame
name|frame
decl_stmt|;
name|HOST_WIDE_INT
name|offset
decl_stmt|;
name|ix86_compute_frame_layout
argument_list|(
operator|&
name|frame
argument_list|)
expr_stmt|;
comment|/* Calculate start of saved registers relative to ebp.  Special care      must be taken for the normal return case of a function using      eh_return: the eax and edx registers are marked as saved, but not      restored along this path.  */
name|offset
operator|=
name|frame
operator|.
name|nregs
expr_stmt|;
if|if
condition|(
name|current_function_calls_eh_return
operator|&&
name|style
operator|!=
literal|2
condition|)
name|offset
operator|-=
literal|2
expr_stmt|;
name|offset
operator|*=
operator|-
name|UNITS_PER_WORD
expr_stmt|;
comment|/* If we're only restoring one register and sp is not valid then      using a move instruction to restore the register since it's      less work than reloading sp and popping the register.       The default code result in stack adjustment using add/lea instruction,      while this code results in LEAVE instruction (or discrete equivalent),      so it is profitable in some other cases as well.  Especially when there      are no registers to restore.  We also use this code when TARGET_USE_LEAVE      and there is exactly one register to pop. This heruistic may need some      tuning in future.  */
if|if
condition|(
operator|(
operator|!
name|sp_valid
operator|&&
name|frame
operator|.
name|nregs
operator|<=
literal|1
operator|)
operator|||
operator|(
name|TARGET_EPILOGUE_USING_MOVE
operator|&&
name|use_fast_prologue_epilogue
operator|&&
operator|(
name|frame
operator|.
name|nregs
operator|>
literal|1
operator|||
name|frame
operator|.
name|to_allocate
operator|)
operator|)
operator|||
operator|(
name|frame_pointer_needed
operator|&&
operator|!
name|frame
operator|.
name|nregs
operator|&&
name|frame
operator|.
name|to_allocate
operator|)
operator|||
operator|(
name|frame_pointer_needed
operator|&&
name|TARGET_USE_LEAVE
operator|&&
name|use_fast_prologue_epilogue
operator|&&
name|frame
operator|.
name|nregs
operator|==
literal|1
operator|)
operator|||
name|current_function_calls_eh_return
condition|)
block|{
comment|/* Restore registers.  We can use ebp or esp to address the memory 	 locations.  If both are available, default to ebp, since offsets 	 are known to be small.  Only exception is esp pointing directly to the 	 end of block of saved registers, where we may simplify addressing 	 mode.  */
if|if
condition|(
operator|!
name|frame_pointer_needed
operator|||
operator|(
name|sp_valid
operator|&&
operator|!
name|frame
operator|.
name|to_allocate
operator|)
condition|)
name|ix86_emit_restore_regs_using_mov
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|frame
operator|.
name|to_allocate
argument_list|,
name|style
operator|==
literal|2
argument_list|)
expr_stmt|;
else|else
name|ix86_emit_restore_regs_using_mov
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
name|offset
argument_list|,
name|style
operator|==
literal|2
argument_list|)
expr_stmt|;
comment|/* eh_return epilogues need %ecx added to the stack pointer.  */
if|if
condition|(
name|style
operator|==
literal|2
condition|)
block|{
name|rtx
name|tmp
decl_stmt|,
name|sa
init|=
name|EH_RETURN_STACKADJ_RTX
decl_stmt|;
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
name|tmp
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|hard_frame_pointer_rtx
argument_list|,
name|sa
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|plus_constant
argument_list|(
name|tmp
argument_list|,
name|UNITS_PER_WORD
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|sa
argument_list|,
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|hard_frame_pointer_rtx
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_pro_epilogue_adjust_stack
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|sa
argument_list|,
name|const0_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tmp
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|sa
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|plus_constant
argument_list|(
name|tmp
argument_list|,
operator|(
name|frame
operator|.
name|to_allocate
operator|+
name|frame
operator|.
name|nregs
operator|*
name|UNITS_PER_WORD
operator|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|frame_pointer_needed
condition|)
name|emit_insn
argument_list|(
name|gen_pro_epilogue_adjust_stack
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|frame
operator|.
name|to_allocate
operator|+
name|frame
operator|.
name|nregs
operator|*
name|UNITS_PER_WORD
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If not an i386, mov& pop is faster than "leave".  */
elseif|else
if|if
condition|(
name|TARGET_USE_LEAVE
operator|||
name|optimize_size
operator|||
operator|!
name|use_fast_prologue_epilogue
condition|)
name|emit_insn
argument_list|(
name|TARGET_64BIT
condition|?
name|gen_leave_rex64
argument_list|()
else|:
name|gen_leave
argument_list|()
argument_list|)
expr_stmt|;
else|else
block|{
name|emit_insn
argument_list|(
name|gen_pro_epilogue_adjust_stack
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|hard_frame_pointer_rtx
argument_list|,
name|const0_rtx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
name|emit_insn
argument_list|(
name|gen_popdi1
argument_list|(
name|hard_frame_pointer_rtx
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_popsi1
argument_list|(
name|hard_frame_pointer_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* First step is to deallocate the stack frame so that we can 	 pop the registers.  */
if|if
condition|(
operator|!
name|sp_valid
condition|)
block|{
if|if
condition|(
operator|!
name|frame_pointer_needed
condition|)
name|abort
argument_list|()
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_pro_epilogue_adjust_stack
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|hard_frame_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|offset
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|frame
operator|.
name|to_allocate
condition|)
name|emit_insn
argument_list|(
name|gen_pro_epilogue_adjust_stack
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|frame
operator|.
name|to_allocate
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|ix86_save_reg
argument_list|(
name|regno
argument_list|,
name|false
argument_list|)
condition|)
block|{
if|if
condition|(
name|TARGET_64BIT
condition|)
name|emit_insn
argument_list|(
name|gen_popdi1
argument_list|(
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|regno
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_popsi1
argument_list|(
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|regno
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
comment|/* Leave results in shorter dependency chains on CPUs that are 	     able to grok it fast.  */
if|if
condition|(
name|TARGET_USE_LEAVE
condition|)
name|emit_insn
argument_list|(
name|TARGET_64BIT
condition|?
name|gen_leave_rex64
argument_list|()
else|:
name|gen_leave
argument_list|()
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TARGET_64BIT
condition|)
name|emit_insn
argument_list|(
name|gen_popdi1
argument_list|(
name|hard_frame_pointer_rtx
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_popsi1
argument_list|(
name|hard_frame_pointer_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Sibcall epilogues don't want a return instruction.  */
if|if
condition|(
name|style
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|current_function_pops_args
operator|&&
name|current_function_args_size
condition|)
block|{
name|rtx
name|popc
init|=
name|GEN_INT
argument_list|(
name|current_function_pops_args
argument_list|)
decl_stmt|;
comment|/* i386 can only pop 64K bytes.  If asked to pop more, pop 	 return address, do explicit add, and jump indirectly to the 	 caller.  */
if|if
condition|(
name|current_function_pops_args
operator|>=
literal|65536
condition|)
block|{
name|rtx
name|ecx
init|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
literal|2
argument_list|)
decl_stmt|;
comment|/* There are is no "pascal" calling convention in 64bit ABI.  */
if|if
condition|(
name|TARGET_64BIT
condition|)
name|abort
argument_list|()
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_popsi1
argument_list|(
name|ecx
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|popc
argument_list|)
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_return_indirect_internal
argument_list|(
name|ecx
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|emit_jump_insn
argument_list|(
name|gen_return_pop_internal
argument_list|(
name|popc
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|emit_jump_insn
argument_list|(
name|gen_return_internal
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Extract the parts of an RTL expression that is a valid memory address    for an instruction.  Return 0 if the structure of the address is    grossly off.  Return -1 if the address contains ASHIFT, so it is not    strictly valid, but still used for computing length of lea instruction.    */
end_comment

begin_function
specifier|static
name|int
name|ix86_decompose_address
parameter_list|(
name|addr
parameter_list|,
name|out
parameter_list|)
specifier|register
name|rtx
name|addr
decl_stmt|;
name|struct
name|ix86_address
modifier|*
name|out
decl_stmt|;
block|{
name|rtx
name|base
init|=
name|NULL_RTX
decl_stmt|;
name|rtx
name|index
init|=
name|NULL_RTX
decl_stmt|;
name|rtx
name|disp
init|=
name|NULL_RTX
decl_stmt|;
name|HOST_WIDE_INT
name|scale
init|=
literal|1
decl_stmt|;
name|rtx
name|scale_rtx
init|=
name|NULL_RTX
decl_stmt|;
name|int
name|retval
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|SUBREG
condition|)
name|base
operator|=
name|addr
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|rtx
name|op0
init|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|enum
name|rtx_code
name|code0
init|=
name|GET_CODE
argument_list|(
name|op0
argument_list|)
decl_stmt|;
name|enum
name|rtx_code
name|code1
init|=
name|GET_CODE
argument_list|(
name|op1
argument_list|)
decl_stmt|;
if|if
condition|(
name|code0
operator|==
name|REG
operator|||
name|code0
operator|==
name|SUBREG
condition|)
block|{
if|if
condition|(
name|code1
operator|==
name|REG
operator|||
name|code1
operator|==
name|SUBREG
condition|)
name|index
operator|=
name|op0
operator|,
name|base
operator|=
name|op1
expr_stmt|;
comment|/* index + base */
else|else
name|base
operator|=
name|op0
operator|,
name|disp
operator|=
name|op1
expr_stmt|;
comment|/* base + displacement */
block|}
elseif|else
if|if
condition|(
name|code0
operator|==
name|MULT
condition|)
block|{
name|index
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|scale_rtx
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|code1
operator|==
name|REG
operator|||
name|code1
operator|==
name|SUBREG
condition|)
name|base
operator|=
name|op1
expr_stmt|;
comment|/* index*scale + base */
else|else
name|disp
operator|=
name|op1
expr_stmt|;
comment|/* index*scale + disp */
block|}
elseif|else
if|if
condition|(
name|code0
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MULT
condition|)
block|{
name|index
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* index*scale + base + disp */
name|scale_rtx
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|base
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|disp
operator|=
name|op1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code0
operator|==
name|PLUS
condition|)
block|{
name|index
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* index + base + disp */
name|base
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|disp
operator|=
name|op1
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|MULT
condition|)
block|{
name|index
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* index*scale */
name|scale_rtx
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|ASHIFT
condition|)
block|{
name|rtx
name|tmp
decl_stmt|;
comment|/* We're called for lea too, which implements ashift on occasion.  */
name|index
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
literal|0
return|;
name|scale
operator|=
name|INTVAL
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|scale
operator|>
literal|3
condition|)
return|return
literal|0
return|;
name|scale
operator|=
literal|1
operator|<<
name|scale
expr_stmt|;
name|retval
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|disp
operator|=
name|addr
expr_stmt|;
comment|/* displacement */
comment|/* Extract the integral value of scale.  */
if|if
condition|(
name|scale_rtx
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|scale_rtx
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
literal|0
return|;
name|scale
operator|=
name|INTVAL
argument_list|(
name|scale_rtx
argument_list|)
expr_stmt|;
block|}
comment|/* Allow arg pointer and stack pointer as index if there is not scaling */
if|if
condition|(
name|base
operator|&&
name|index
operator|&&
name|scale
operator|==
literal|1
operator|&&
operator|(
name|index
operator|==
name|arg_pointer_rtx
operator|||
name|index
operator|==
name|frame_pointer_rtx
operator|||
name|index
operator|==
name|stack_pointer_rtx
operator|)
condition|)
block|{
name|rtx
name|tmp
init|=
name|base
decl_stmt|;
name|base
operator|=
name|index
expr_stmt|;
name|index
operator|=
name|tmp
expr_stmt|;
block|}
comment|/* Special case: %ebp cannot be encoded as a base without a displacement.  */
if|if
condition|(
operator|(
name|base
operator|==
name|hard_frame_pointer_rtx
operator|||
name|base
operator|==
name|frame_pointer_rtx
operator|||
name|base
operator|==
name|arg_pointer_rtx
operator|)
operator|&&
operator|!
name|disp
condition|)
name|disp
operator|=
name|const0_rtx
expr_stmt|;
comment|/* Special case: on K6, [%esi] makes the instruction vector decoded.      Avoid this by transforming to [%esi+0].  */
if|if
condition|(
name|ix86_cpu
operator|==
name|PROCESSOR_K6
operator|&&
operator|!
name|optimize_size
operator|&&
name|base
operator|&&
operator|!
name|index
operator|&&
operator|!
name|disp
operator|&&
name|REG_P
argument_list|(
name|base
argument_list|)
operator|&&
name|REGNO_REG_CLASS
argument_list|(
name|REGNO
argument_list|(
name|base
argument_list|)
argument_list|)
operator|==
name|SIREG
condition|)
name|disp
operator|=
name|const0_rtx
expr_stmt|;
comment|/* Special case: encode reg+reg instead of reg*2.  */
if|if
condition|(
operator|!
name|base
operator|&&
name|index
operator|&&
name|scale
operator|&&
name|scale
operator|==
literal|2
condition|)
name|base
operator|=
name|index
operator|,
name|scale
operator|=
literal|1
expr_stmt|;
comment|/* Special case: scaling cannot be encoded without base or displacement.  */
if|if
condition|(
operator|!
name|base
operator|&&
operator|!
name|disp
operator|&&
name|index
operator|&&
name|scale
operator|!=
literal|1
condition|)
name|disp
operator|=
name|const0_rtx
expr_stmt|;
name|out
operator|->
name|base
operator|=
name|base
expr_stmt|;
name|out
operator|->
name|index
operator|=
name|index
expr_stmt|;
name|out
operator|->
name|disp
operator|=
name|disp
expr_stmt|;
name|out
operator|->
name|scale
operator|=
name|scale
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return cost of the memory address x.    For i386, it is better to use a complex address than let gcc copy    the address into a reg and make a new pseudo.  But not if the address    requires to two regs - that would mean more pseudos with longer    lifetimes.  */
end_comment

begin_function
name|int
name|ix86_address_cost
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|struct
name|ix86_address
name|parts
decl_stmt|;
name|int
name|cost
init|=
literal|1
decl_stmt|;
if|if
condition|(
operator|!
name|ix86_decompose_address
argument_list|(
name|x
argument_list|,
operator|&
name|parts
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* More complex memory references are better.  */
if|if
condition|(
name|parts
operator|.
name|disp
operator|&&
name|parts
operator|.
name|disp
operator|!=
name|const0_rtx
condition|)
name|cost
operator|--
expr_stmt|;
comment|/* Attempt to minimize number of registers in the address.  */
if|if
condition|(
operator|(
name|parts
operator|.
name|base
operator|&&
operator|(
operator|!
name|REG_P
argument_list|(
name|parts
operator|.
name|base
argument_list|)
operator|||
name|REGNO
argument_list|(
name|parts
operator|.
name|base
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|)
operator|||
operator|(
name|parts
operator|.
name|index
operator|&&
operator|(
operator|!
name|REG_P
argument_list|(
name|parts
operator|.
name|index
argument_list|)
operator|||
name|REGNO
argument_list|(
name|parts
operator|.
name|index
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|)
condition|)
name|cost
operator|++
expr_stmt|;
if|if
condition|(
name|parts
operator|.
name|base
operator|&&
operator|(
operator|!
name|REG_P
argument_list|(
name|parts
operator|.
name|base
argument_list|)
operator|||
name|REGNO
argument_list|(
name|parts
operator|.
name|base
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|&&
name|parts
operator|.
name|index
operator|&&
operator|(
operator|!
name|REG_P
argument_list|(
name|parts
operator|.
name|index
argument_list|)
operator|||
name|REGNO
argument_list|(
name|parts
operator|.
name|index
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|&&
name|parts
operator|.
name|base
operator|!=
name|parts
operator|.
name|index
condition|)
name|cost
operator|++
expr_stmt|;
comment|/* AMD-K6 don't like addresses with ModR/M set to 00_xxx_100b,      since it's predecode logic can't detect the length of instructions      and it degenerates to vector decoded.  Increase cost of such      addresses here.  The penalty is minimally 2 cycles.  It may be worthwhile      to split such addresses or even refuse such addresses at all.       Following addressing modes are affected:       [base+scale*index]       [scale*index+disp]       [base+index]       The first and last case  may be avoidable by explicitly coding the zero in      memory address, but I don't have AMD-K6 machine handy to check this      theory.  */
if|if
condition|(
name|TARGET_K6
operator|&&
operator|(
operator|(
operator|!
name|parts
operator|.
name|disp
operator|&&
name|parts
operator|.
name|base
operator|&&
name|parts
operator|.
name|index
operator|&&
name|parts
operator|.
name|scale
operator|!=
literal|1
operator|)
operator|||
operator|(
name|parts
operator|.
name|disp
operator|&&
operator|!
name|parts
operator|.
name|base
operator|&&
name|parts
operator|.
name|index
operator|&&
name|parts
operator|.
name|scale
operator|!=
literal|1
operator|)
operator|||
operator|(
operator|!
name|parts
operator|.
name|disp
operator|&&
name|parts
operator|.
name|base
operator|&&
name|parts
operator|.
name|index
operator|&&
name|parts
operator|.
name|scale
operator|==
literal|1
operator|)
operator|)
condition|)
name|cost
operator|+=
literal|10
expr_stmt|;
return|return
name|cost
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If X is a machine specific address (i.e. a symbol or label being    referenced as a displacement from the GOT implemented using an    UNSPEC), then return the base term.  Otherwise return X.  */
end_comment

begin_function
name|rtx
name|ix86_find_base_term
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|rtx
name|term
decl_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST
condition|)
return|return
name|x
return|;
name|term
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|term
argument_list|)
operator|==
name|PLUS
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|term
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|term
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_DOUBLE
operator|)
condition|)
name|term
operator|=
name|XEXP
argument_list|(
name|term
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|term
argument_list|)
operator|!=
name|UNSPEC
operator|||
name|XVECLEN
argument_list|(
name|term
argument_list|,
literal|0
argument_list|)
operator|!=
literal|1
operator|||
name|XINT
argument_list|(
name|term
argument_list|,
literal|1
argument_list|)
operator|!=
literal|15
condition|)
return|return
name|x
return|;
name|term
operator|=
name|XVECEXP
argument_list|(
name|term
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|term
argument_list|)
operator|!=
name|SYMBOL_REF
operator|&&
name|GET_CODE
argument_list|(
name|term
argument_list|)
operator|!=
name|LABEL_REF
condition|)
return|return
name|x
return|;
return|return
name|term
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|PLUS
operator|||
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|!=
name|pic_offset_table_rtx
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST
condition|)
return|return
name|x
return|;
name|term
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|term
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|term
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
name|term
operator|=
name|XEXP
argument_list|(
name|term
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|term
argument_list|)
operator|!=
name|UNSPEC
operator|||
name|XVECLEN
argument_list|(
name|term
argument_list|,
literal|0
argument_list|)
operator|!=
literal|1
operator|||
name|XINT
argument_list|(
name|term
argument_list|,
literal|1
argument_list|)
operator|!=
literal|7
condition|)
return|return
name|x
return|;
name|term
operator|=
name|XVECEXP
argument_list|(
name|term
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|term
argument_list|)
operator|!=
name|SYMBOL_REF
operator|&&
name|GET_CODE
argument_list|(
name|term
argument_list|)
operator|!=
name|LABEL_REF
condition|)
return|return
name|x
return|;
return|return
name|term
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Determine if a given CONST RTX is a valid memory displacement    in PIC mode.  */
end_comment

begin_function
name|int
name|legitimate_pic_address_disp_p
parameter_list|(
name|disp
parameter_list|)
specifier|register
name|rtx
name|disp
decl_stmt|;
block|{
comment|/* In 64bit mode we can allow direct addresses of symbols and labels      when they are not dynamic symbols.  */
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
name|rtx
name|x
init|=
name|disp
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|==
name|CONST
condition|)
name|x
operator|=
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* ??? Handle PIC code models */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|ix86_cmodel
operator|==
name|CM_SMALL_PIC
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
literal|1024
operator|*
literal|1024
operator|*
literal|1024
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>
operator|-
literal|1024
operator|*
literal|1024
operator|*
literal|1024
operator|)
condition|)
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_symbolic_operand
argument_list|(
name|x
argument_list|,
name|Pmode
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|!=
name|CONST
condition|)
return|return
literal|0
return|;
name|disp
operator|=
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
comment|/* We are unsafe to allow PLUS expressions.  This limit allowed distance          of GOT tables.  We should not need these anyway.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|!=
name|UNSPEC
operator|||
name|XVECLEN
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
operator|!=
literal|1
operator|||
name|XINT
argument_list|(
name|disp
argument_list|,
literal|1
argument_list|)
operator|!=
literal|15
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|SYMBOL_REF
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|LABEL_REF
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|==
name|PLUS
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
literal|0
return|;
name|disp
operator|=
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|!=
name|UNSPEC
operator|||
name|XVECLEN
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
operator|!=
literal|1
condition|)
return|return
literal|0
return|;
comment|/* Must be @GOT or @GOTOFF.  */
switch|switch
condition|(
name|XINT
argument_list|(
name|disp
argument_list|,
literal|1
argument_list|)
condition|)
block|{
case|case
literal|6
case|:
comment|/* @GOT */
return|return
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
return|;
case|case
literal|7
case|:
comment|/* @GOTOFF */
return|return
name|local_symbolic_operand
argument_list|(
name|XVECEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression that is a valid    memory address for an instruction.  The MODE argument is the machine mode    for the MEM expression that wants to use this address.     It only recognizes address in canonical form.  LEGITIMIZE_ADDRESS should    convert common non-canonical forms to canonical form so that they will    be recognized.  */
end_comment

begin_function
name|int
name|legitimate_address_p
parameter_list|(
name|mode
parameter_list|,
name|addr
parameter_list|,
name|strict
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
specifier|register
name|rtx
name|addr
decl_stmt|;
name|int
name|strict
decl_stmt|;
block|{
name|struct
name|ix86_address
name|parts
decl_stmt|;
name|rtx
name|base
decl_stmt|,
name|index
decl_stmt|,
name|disp
decl_stmt|;
name|HOST_WIDE_INT
name|scale
decl_stmt|;
specifier|const
name|char
modifier|*
name|reason
init|=
name|NULL
decl_stmt|;
name|rtx
name|reason_rtx
init|=
name|NULL_RTX
decl_stmt|;
if|if
condition|(
name|TARGET_DEBUG_ADDR
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n======\nGO_IF_LEGITIMATE_ADDRESS, mode = %s, strict = %d\n"
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|mode
argument_list|)
argument_list|,
name|strict
argument_list|)
expr_stmt|;
name|debug_rtx
argument_list|(
name|addr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ix86_decompose_address
argument_list|(
name|addr
argument_list|,
operator|&
name|parts
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|reason
operator|=
literal|"decomposition failed"
expr_stmt|;
goto|goto
name|report_error
goto|;
block|}
name|base
operator|=
name|parts
operator|.
name|base
expr_stmt|;
name|index
operator|=
name|parts
operator|.
name|index
expr_stmt|;
name|disp
operator|=
name|parts
operator|.
name|disp
expr_stmt|;
name|scale
operator|=
name|parts
operator|.
name|scale
expr_stmt|;
comment|/* Validate base register.       Don't allow SUBREG's here, it can lead to spill failures when the base      is one word out of a two word structure, which is represented internally      as a DImode int.  */
if|if
condition|(
name|base
condition|)
block|{
name|reason_rtx
operator|=
name|base
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|!=
name|REG
condition|)
block|{
name|reason
operator|=
literal|"base is not a register"
expr_stmt|;
goto|goto
name|report_error
goto|;
block|}
if|if
condition|(
name|GET_MODE
argument_list|(
name|base
argument_list|)
operator|!=
name|Pmode
condition|)
block|{
name|reason
operator|=
literal|"base is not in Pmode"
expr_stmt|;
goto|goto
name|report_error
goto|;
block|}
if|if
condition|(
operator|(
name|strict
operator|&&
operator|!
name|REG_OK_FOR_BASE_STRICT_P
argument_list|(
name|base
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|strict
operator|&&
operator|!
name|REG_OK_FOR_BASE_NONSTRICT_P
argument_list|(
name|base
argument_list|)
operator|)
condition|)
block|{
name|reason
operator|=
literal|"base is not valid"
expr_stmt|;
goto|goto
name|report_error
goto|;
block|}
block|}
comment|/* Validate index register.       Don't allow SUBREG's here, it can lead to spill failures when the index      is one word out of a two word structure, which is represented internally      as a DImode int.  */
if|if
condition|(
name|index
condition|)
block|{
name|reason_rtx
operator|=
name|index
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|index
argument_list|)
operator|!=
name|REG
condition|)
block|{
name|reason
operator|=
literal|"index is not a register"
expr_stmt|;
goto|goto
name|report_error
goto|;
block|}
if|if
condition|(
name|GET_MODE
argument_list|(
name|index
argument_list|)
operator|!=
name|Pmode
condition|)
block|{
name|reason
operator|=
literal|"index is not in Pmode"
expr_stmt|;
goto|goto
name|report_error
goto|;
block|}
if|if
condition|(
operator|(
name|strict
operator|&&
operator|!
name|REG_OK_FOR_INDEX_STRICT_P
argument_list|(
name|index
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|strict
operator|&&
operator|!
name|REG_OK_FOR_INDEX_NONSTRICT_P
argument_list|(
name|index
argument_list|)
operator|)
condition|)
block|{
name|reason
operator|=
literal|"index is not valid"
expr_stmt|;
goto|goto
name|report_error
goto|;
block|}
block|}
comment|/* Validate scale factor.  */
if|if
condition|(
name|scale
operator|!=
literal|1
condition|)
block|{
name|reason_rtx
operator|=
name|GEN_INT
argument_list|(
name|scale
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|index
condition|)
block|{
name|reason
operator|=
literal|"scale without index"
expr_stmt|;
goto|goto
name|report_error
goto|;
block|}
if|if
condition|(
name|scale
operator|!=
literal|2
operator|&&
name|scale
operator|!=
literal|4
operator|&&
name|scale
operator|!=
literal|8
condition|)
block|{
name|reason
operator|=
literal|"scale is not a valid multiplier"
expr_stmt|;
goto|goto
name|report_error
goto|;
block|}
block|}
comment|/* Validate displacement.  */
if|if
condition|(
name|disp
condition|)
block|{
name|reason_rtx
operator|=
name|disp
expr_stmt|;
if|if
condition|(
operator|!
name|CONSTANT_ADDRESS_P
argument_list|(
name|disp
argument_list|)
condition|)
block|{
name|reason
operator|=
literal|"displacement is not constant"
expr_stmt|;
goto|goto
name|report_error
goto|;
block|}
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
if|if
condition|(
operator|!
name|x86_64_sign_extended_value
argument_list|(
name|disp
argument_list|)
condition|)
block|{
name|reason
operator|=
literal|"displacement is out of range"
expr_stmt|;
goto|goto
name|report_error
goto|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
name|reason
operator|=
literal|"displacement is a const_double"
expr_stmt|;
goto|goto
name|report_error
goto|;
block|}
block|}
if|if
condition|(
name|flag_pic
operator|&&
name|SYMBOLIC_CONST
argument_list|(
name|disp
argument_list|)
condition|)
block|{
if|if
condition|(
name|TARGET_64BIT
operator|&&
operator|(
name|index
operator|||
name|base
operator|)
condition|)
block|{
name|reason
operator|=
literal|"non-constant pic memory reference"
expr_stmt|;
goto|goto
name|report_error
goto|;
block|}
if|if
condition|(
operator|!
name|legitimate_pic_address_disp_p
argument_list|(
name|disp
argument_list|)
condition|)
block|{
name|reason
operator|=
literal|"displacement is an invalid pic construct"
expr_stmt|;
goto|goto
name|report_error
goto|;
block|}
comment|/* This code used to verify that a symbolic pic displacement 	     includes the pic_offset_table_rtx register.  	     While this is good idea, unfortunately these constructs may 	     be created by "adds using lea" optimization for incorrect 	     code like:  	     int a; 	     int foo(int i) 	       { 	         return *(&a+i); 	       }  	     This code is nonsensical, but results in addressing 	     GOT table with pic_offset_table_rtx base.  We can't 	     just refuse it easily, since it gets matched by 	     "addsi3" pattern, that later gets split to lea in the 	     case output register differs from input.  While this 	     can be handled by separate addsi pattern for this case 	     that never results in lea, this seems to be easier and 	     correct fix for crash to disable this test.  */
block|}
elseif|else
if|if
condition|(
name|HALF_PIC_P
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|HALF_PIC_ADDRESS_P
argument_list|(
name|disp
argument_list|)
operator|||
operator|(
name|base
operator|!=
name|NULL_RTX
operator|||
name|index
operator|!=
name|NULL_RTX
operator|)
condition|)
block|{
name|reason
operator|=
literal|"displacement is an invalid half-pic reference"
expr_stmt|;
goto|goto
name|report_error
goto|;
block|}
block|}
block|}
comment|/* Everything looks valid.  */
if|if
condition|(
name|TARGET_DEBUG_ADDR
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Success.\n"
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
name|report_error
label|:
if|if
condition|(
name|TARGET_DEBUG_ADDR
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: %s\n"
argument_list|,
name|reason
argument_list|)
expr_stmt|;
name|debug_rtx
argument_list|(
name|reason_rtx
argument_list|)
expr_stmt|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return an unique alias set for the GOT.  */
end_comment

begin_function
specifier|static
name|HOST_WIDE_INT
name|ix86_GOT_alias_set
parameter_list|()
block|{
specifier|static
name|HOST_WIDE_INT
name|set
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|set
operator|==
operator|-
literal|1
condition|)
name|set
operator|=
name|new_alias_set
argument_list|()
expr_stmt|;
return|return
name|set
return|;
block|}
end_function

begin_comment
comment|/* Return a legitimate reference for ORIG (an address) using the    register REG.  If REG is 0, a new pseudo is generated.     There are two types of references that must be handled:     1. Global data references must load the address from the GOT, via       the PIC reg.  An insn is emitted to do this load, and the reg is       returned.     2. Static data references, constant pool addresses, and code labels       compute the address as an offset from the GOT, whose base is in       the PIC reg.  Static data objects have SYMBOL_REF_FLAG set to       differentiate them from global data objects.  The returned       address is the PIC reg + an unspec constant.     GO_IF_LEGITIMATE_ADDRESS rejects symbolic references unless the PIC    reg also appears in the address.  */
end_comment

begin_function
name|rtx
name|legitimize_pic_address
parameter_list|(
name|orig
parameter_list|,
name|reg
parameter_list|)
name|rtx
name|orig
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
block|{
name|rtx
name|addr
init|=
name|orig
decl_stmt|;
name|rtx
name|new
init|=
name|orig
decl_stmt|;
name|rtx
name|base
decl_stmt|;
if|if
condition|(
name|local_symbolic_operand
argument_list|(
name|addr
argument_list|,
name|Pmode
argument_list|)
condition|)
block|{
comment|/* In 64bit mode we can address such objects directly.  */
if|if
condition|(
name|TARGET_64BIT
condition|)
name|new
operator|=
name|addr
expr_stmt|;
else|else
block|{
comment|/* This symbol may be referenced via a displacement from the PIC 	     base address (@GOTOFF).  */
name|current_function_uses_pic_offset_table
operator|=
literal|1
expr_stmt|;
name|new
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|addr
argument_list|)
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
literal|0
condition|)
block|{
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|reg
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
block|{
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
name|current_function_uses_pic_offset_table
operator|=
literal|1
expr_stmt|;
name|new
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|addr
argument_list|)
argument_list|,
literal|15
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|new
argument_list|)
operator|=
literal|1
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|new
argument_list|,
name|ix86_GOT_alias_set
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|==
literal|0
condition|)
name|reg
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
comment|/* Use directly gen_movsi, otherwise the address is loaded 	     into register for CSE.  We don't want to CSE this addresses, 	     instead we CSE addresses from the GOT table, so skip this.  */
name|emit_insn
argument_list|(
name|gen_movsi
argument_list|(
name|reg
argument_list|,
name|new
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|=
name|reg
expr_stmt|;
block|}
else|else
block|{
comment|/* This symbol must be referenced via a load from the 	     Global Offset Table (@GOT).  */
name|current_function_uses_pic_offset_table
operator|=
literal|1
expr_stmt|;
name|new
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|addr
argument_list|)
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|new
argument_list|)
operator|=
literal|1
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|new
argument_list|,
name|ix86_GOT_alias_set
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|==
literal|0
condition|)
name|reg
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|reg
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|CONST
condition|)
block|{
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|UNSPEC
condition|)
block|{
comment|/* Check that the unspec is one of the ones we generate?  */
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|!=
name|PLUS
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|rtx
name|op0
init|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
decl_stmt|,
name|op1
init|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* Check first to see if this is a constant offset from a @GOTOFF 	     symbol reference.  */
if|if
condition|(
name|local_symbolic_operand
argument_list|(
name|op0
argument_list|,
name|Pmode
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
operator|!
name|TARGET_64BIT
condition|)
block|{
name|current_function_uses_pic_offset_table
operator|=
literal|1
expr_stmt|;
name|new
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|op0
argument_list|)
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
literal|0
condition|)
block|{
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|reg
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* ??? We need to limit offsets here.  */
block|}
block|}
else|else
block|{
name|base
operator|=
name|legitimize_pic_address
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|new
operator|=
name|legitimize_pic_address
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|,
name|base
operator|==
name|reg
condition|?
name|NULL_RTX
else|:
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|new
argument_list|)
operator|==
name|CONST_INT
condition|)
name|new
operator|=
name|plus_constant
argument_list|(
name|base
argument_list|,
name|INTVAL
argument_list|(
name|new
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|new
argument_list|)
operator|==
name|PLUS
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|new
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|base
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|base
argument_list|,
name|XEXP
argument_list|(
name|new
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|=
name|XEXP
argument_list|(
name|new
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|new
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|base
argument_list|,
name|new
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|new
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Try machine-dependent ways of modifying an illegitimate address    to be legitimate.  If we find one, return the new, valid address.    This macro is used in only one place: `memory_address' in explow.c.     OLDX is the address as it was before break_out_memory_refs was called.    In some cases it is useful to look at this to decide what needs to be done.     MODE and WIN are passed so that this macro can use    GO_IF_LEGITIMATE_ADDRESS.     It is always safe for this macro to do nothing.  It exists to recognize    opportunities to optimize the output.     For the 80386, we handle X+REG by loading X into a register R and    using R+REG.  R will go in a general reg and indexing will be used.    However, if REG is a broken-out memory address or multiplication,    nothing needs to be done because REG can certainly go in a general reg.     When -fpic is used, special handling is needed for symbolic references.    See comments by legitimize_pic_address in i386.c for details.  */
end_comment

begin_function
name|rtx
name|legitimize_address
parameter_list|(
name|x
parameter_list|,
name|oldx
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|x
decl_stmt|;
specifier|register
name|rtx
name|oldx
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|int
name|changed
init|=
literal|0
decl_stmt|;
name|unsigned
name|log
decl_stmt|;
if|if
condition|(
name|TARGET_DEBUG_ADDR
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n==========\nLEGITIMIZE_ADDRESS, mode = %s\n"
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
name|debug_rtx
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_pic
operator|&&
name|SYMBOLIC_CONST
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|legitimize_pic_address
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
return|;
comment|/* Canonicalize shifts by 0, 1, 2, 3 into multiply */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|ASHIFT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|log
operator|=
operator|(
name|unsigned
operator|)
name|exact_log2
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|<
literal|4
condition|)
block|{
name|changed
operator|=
literal|1
expr_stmt|;
name|x
operator|=
name|gen_rtx_MULT
argument_list|(
name|Pmode
argument_list|,
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
literal|1
operator|<<
name|log
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
condition|)
block|{
comment|/* Canonicalize shifts by 0, 1, 2, 3 into multiply.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ASHIFT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|log
operator|=
operator|(
name|unsigned
operator|)
name|exact_log2
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|<
literal|4
condition|)
block|{
name|changed
operator|=
literal|1
expr_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|gen_rtx_MULT
argument_list|(
name|Pmode
argument_list|,
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
literal|1
operator|<<
name|log
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|ASHIFT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|log
operator|=
operator|(
name|unsigned
operator|)
name|exact_log2
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|<
literal|4
condition|)
block|{
name|changed
operator|=
literal|1
expr_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|=
name|gen_rtx_MULT
argument_list|(
name|Pmode
argument_list|,
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
literal|1
operator|<<
name|log
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Put multiply first if it isn't already.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|MULT
condition|)
block|{
name|rtx
name|tmp
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|=
name|tmp
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Canonicalize (plus (mult (reg) (const)) (plus (reg) (const))) 	 into (plus (plus (mult (reg) (const)) (reg)) (const)).  This can be 	 created by virtual register instantiation, register elimination, and 	 similar optimizations.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MULT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|changed
operator|=
literal|1
expr_stmt|;
name|x
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Canonicalize 	 (plus (plus (mult (reg) (const)) (plus (reg) (const))) const) 	 into (plus (plus (mult (reg) (const)) (reg)) (const)).  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MULT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|constant
decl_stmt|;
name|rtx
name|other
init|=
name|NULL_RTX
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|constant
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|other
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|constant
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|other
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|constant
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|constant
condition|)
block|{
name|changed
operator|=
literal|1
expr_stmt|;
name|x
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|plus_constant
argument_list|(
name|other
argument_list|,
name|INTVAL
argument_list|(
name|constant
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|changed
operator|&&
name|legitimate_address_p
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
name|FALSE
argument_list|)
condition|)
return|return
name|x
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MULT
condition|)
block|{
name|changed
operator|=
literal|1
expr_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|MULT
condition|)
block|{
name|changed
operator|=
literal|1
expr_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|=
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|changed
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
return|return
name|x
return|;
if|if
condition|(
name|flag_pic
operator|&&
name|SYMBOLIC_CONST
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|changed
operator|=
literal|1
expr_stmt|;
name|x
operator|=
name|legitimize_pic_address
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|changed
operator|&&
name|legitimate_address_p
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
name|FALSE
argument_list|)
condition|)
return|return
name|x
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
specifier|register
name|rtx
name|temp
init|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
specifier|register
name|rtx
name|val
init|=
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|temp
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|!=
name|temp
condition|)
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|=
name|temp
expr_stmt|;
return|return
name|x
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
specifier|register
name|rtx
name|temp
init|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
specifier|register
name|rtx
name|val
init|=
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|temp
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|!=
name|temp
condition|)
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|temp
expr_stmt|;
return|return
name|x
return|;
block|}
block|}
return|return
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print an integer constant expression in assembler syntax.  Addition    and subtraction are the only arithmetic that may appear in these    expressions.  FILE is the stdio stream to write to, X is the rtx, and    CODE is the operand print code from the output string.  */
end_comment

begin_function
specifier|static
name|void
name|output_pic_addr_const
parameter_list|(
name|file
parameter_list|,
name|x
parameter_list|,
name|code
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|int
name|code
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|PC
case|:
if|if
condition|(
name|flag_pic
condition|)
name|putc
argument_list|(
literal|'.'
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
break|break;
case|case
name|SYMBOL_REF
case|:
name|assemble_name
argument_list|(
name|file
argument_list|,
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
literal|'P'
operator|&&
operator|!
name|SYMBOL_REF_FLAG
argument_list|(
name|x
argument_list|)
condition|)
name|fputs
argument_list|(
literal|"@PLT"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|LABEL_REF
case|:
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* FALLTHRU */
case|case
name|CODE_LABEL
case|:
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|asm_out_file
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST_INT
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST
case|:
comment|/* This used to output parentheses around the expression, 	 but that does not work on the 386 (either ATT or BSD assembler).  */
name|output_pic_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|code
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST_DOUBLE
case|:
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|VOIDmode
condition|)
block|{
comment|/* We can use %d if the number is<32 bits and positive.  */
if|if
condition|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
operator|||
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0x%lx%08lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* We can't handle floating point constants; 	   PRINT_OPERAND must handle them.  */
name|output_operand_lossage
argument_list|(
literal|"floating constant misused"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PLUS
case|:
comment|/* Some assemblers need integer constants to appear first.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|output_pic_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'+'
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|output_pic_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|code
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|output_pic_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'+'
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|output_pic_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|code
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
break|break;
case|case
name|MINUS
case|:
name|putc
argument_list|(
name|ASSEMBLER_DIALECT
operator|==
name|ASM_INTEL
condition|?
literal|'('
else|:
literal|'['
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|output_pic_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'-'
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|output_pic_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|ASSEMBLER_DIALECT
operator|==
name|ASM_INTEL
condition|?
literal|')'
else|:
literal|']'
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSPEC
case|:
if|if
condition|(
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|!=
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
name|output_pic_addr_const
argument_list|(
name|file
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|code
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|XINT
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|)
block|{
case|case
literal|6
case|:
name|fputs
argument_list|(
literal|"@GOT"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
literal|7
case|:
name|fputs
argument_list|(
literal|"@GOTOFF"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|fputs
argument_list|(
literal|"@PLT"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
literal|15
case|:
name|fputs
argument_list|(
literal|"@GOTPCREL(%RIP)"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
default|default:
name|output_operand_lossage
argument_list|(
literal|"invalid UNSPEC as operand"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|output_operand_lossage
argument_list|(
literal|"invalid expression as operand"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This is called from dwarfout.c via ASM_OUTPUT_DWARF_ADDR_CONST.    We need to handle our special PIC relocations.  */
end_comment

begin_function
name|void
name|i386_dwarf_output_addr_const
parameter_list|(
name|file
parameter_list|,
name|x
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|ASM_QUAD
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|TARGET_64BIT
condition|?
name|ASM_QUAD
else|:
name|ASM_LONG
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|TARGET_64BIT
condition|)
name|abort
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|ASM_LONG
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|flag_pic
condition|)
name|output_pic_addr_const
argument_list|(
name|file
argument_list|,
name|x
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
else|else
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* In the name of slightly smaller debug output, and to cater to    general assembler losage, recognize PIC+GOTOFF and turn it back    into a direct symbol reference.  */
end_comment

begin_function
name|rtx
name|i386_simplify_dwarf_addr
parameter_list|(
name|orig_x
parameter_list|)
name|rtx
name|orig_x
decl_stmt|;
block|{
name|rtx
name|x
init|=
name|orig_x
decl_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|UNSPEC
operator|||
name|XINT
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|!=
literal|15
condition|)
return|return
name|orig_x
return|;
return|return
name|XVECEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST
condition|)
return|return
name|orig_x
return|;
name|x
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|UNSPEC
operator|&&
operator|(
name|XINT
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|==
literal|6
operator|||
name|XINT
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|==
literal|7
operator|)
condition|)
return|return
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|UNSPEC
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|XINT
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
literal|6
operator|||
name|XINT
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
literal|7
operator|)
condition|)
return|return
name|gen_rtx_PLUS
argument_list|(
name|VOIDmode
argument_list|,
name|XVECEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
return|return
name|orig_x
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|put_condition_code
parameter_list|(
name|code
parameter_list|,
name|mode
parameter_list|,
name|reverse
parameter_list|,
name|fp
parameter_list|,
name|file
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|reverse
decl_stmt|,
name|fp
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|suffix
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|CCFPmode
operator|||
name|mode
operator|==
name|CCFPUmode
condition|)
block|{
name|enum
name|rtx_code
name|second_code
decl_stmt|,
name|bypass_code
decl_stmt|;
name|ix86_fp_comparison_codes
argument_list|(
name|code
argument_list|,
operator|&
name|bypass_code
argument_list|,
operator|&
name|code
argument_list|,
operator|&
name|second_code
argument_list|)
expr_stmt|;
if|if
condition|(
name|bypass_code
operator|!=
name|NIL
operator|||
name|second_code
operator|!=
name|NIL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|code
operator|=
name|ix86_fp_compare_code_to_integer
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|mode
operator|=
name|CCmode
expr_stmt|;
block|}
if|if
condition|(
name|reverse
condition|)
name|code
operator|=
name|reverse_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EQ
case|:
name|suffix
operator|=
literal|"e"
expr_stmt|;
break|break;
case|case
name|NE
case|:
name|suffix
operator|=
literal|"ne"
expr_stmt|;
break|break;
case|case
name|GT
case|:
if|if
condition|(
name|mode
operator|!=
name|CCmode
operator|&&
name|mode
operator|!=
name|CCNOmode
operator|&&
name|mode
operator|!=
name|CCGCmode
condition|)
name|abort
argument_list|()
expr_stmt|;
name|suffix
operator|=
literal|"g"
expr_stmt|;
break|break;
case|case
name|GTU
case|:
comment|/* ??? Use "nbe" instead of "a" for fcmov losage on some assemblers. 	 Those same assemblers have the same but opposite losage on cmov.  */
if|if
condition|(
name|mode
operator|!=
name|CCmode
condition|)
name|abort
argument_list|()
expr_stmt|;
name|suffix
operator|=
name|fp
condition|?
literal|"nbe"
else|:
literal|"a"
expr_stmt|;
break|break;
case|case
name|LT
case|:
if|if
condition|(
name|mode
operator|==
name|CCNOmode
operator|||
name|mode
operator|==
name|CCGOCmode
condition|)
name|suffix
operator|=
literal|"s"
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|CCmode
operator|||
name|mode
operator|==
name|CCGCmode
condition|)
name|suffix
operator|=
literal|"l"
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
break|break;
case|case
name|LTU
case|:
if|if
condition|(
name|mode
operator|!=
name|CCmode
condition|)
name|abort
argument_list|()
expr_stmt|;
name|suffix
operator|=
literal|"b"
expr_stmt|;
break|break;
case|case
name|GE
case|:
if|if
condition|(
name|mode
operator|==
name|CCNOmode
operator|||
name|mode
operator|==
name|CCGOCmode
condition|)
name|suffix
operator|=
literal|"ns"
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|CCmode
operator|||
name|mode
operator|==
name|CCGCmode
condition|)
name|suffix
operator|=
literal|"ge"
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
break|break;
case|case
name|GEU
case|:
comment|/* ??? As above.  */
if|if
condition|(
name|mode
operator|!=
name|CCmode
condition|)
name|abort
argument_list|()
expr_stmt|;
name|suffix
operator|=
name|fp
condition|?
literal|"nb"
else|:
literal|"ae"
expr_stmt|;
break|break;
case|case
name|LE
case|:
if|if
condition|(
name|mode
operator|!=
name|CCmode
operator|&&
name|mode
operator|!=
name|CCGCmode
operator|&&
name|mode
operator|!=
name|CCNOmode
condition|)
name|abort
argument_list|()
expr_stmt|;
name|suffix
operator|=
literal|"le"
expr_stmt|;
break|break;
case|case
name|LEU
case|:
if|if
condition|(
name|mode
operator|!=
name|CCmode
condition|)
name|abort
argument_list|()
expr_stmt|;
name|suffix
operator|=
literal|"be"
expr_stmt|;
break|break;
case|case
name|UNORDERED
case|:
name|suffix
operator|=
name|fp
condition|?
literal|"u"
else|:
literal|"p"
expr_stmt|;
break|break;
case|case
name|ORDERED
case|:
name|suffix
operator|=
name|fp
condition|?
literal|"nu"
else|:
literal|"np"
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|fputs
argument_list|(
name|suffix
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|print_reg
parameter_list|(
name|x
parameter_list|,
name|code
parameter_list|,
name|file
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|int
name|code
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|==
name|ARG_POINTER_REGNUM
operator|||
name|REGNO
argument_list|(
name|x
argument_list|)
operator|==
name|FRAME_POINTER_REGNUM
operator|||
name|REGNO
argument_list|(
name|x
argument_list|)
operator|==
name|FLAGS_REG
operator|||
name|REGNO
argument_list|(
name|x
argument_list|)
operator|==
name|FPSR_REG
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|ASSEMBLER_DIALECT
operator|==
name|ASM_ATT
operator|||
name|USER_LABEL_PREFIX
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|putc
argument_list|(
literal|'%'
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
literal|'w'
operator|||
name|MMX_REG_P
argument_list|(
name|x
argument_list|)
condition|)
name|code
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
literal|'b'
condition|)
name|code
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
literal|'k'
condition|)
name|code
operator|=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
literal|'q'
condition|)
name|code
operator|=
literal|8
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
literal|'y'
condition|)
name|code
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
literal|'h'
condition|)
name|code
operator|=
literal|0
expr_stmt|;
else|else
name|code
operator|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Irritatingly, AMD extended registers use different naming convention      from the normal registers.  */
if|if
condition|(
name|REX_INT_REG_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|TARGET_64BIT
condition|)
name|abort
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
literal|0
case|:
name|error
argument_list|(
literal|"extended registers have no high halves"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"r%ib"
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
operator|-
name|FIRST_REX_INT_REG
operator|+
literal|8
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"r%iw"
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
operator|-
name|FIRST_REX_INT_REG
operator|+
literal|8
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"r%id"
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
operator|-
name|FIRST_REX_INT_REG
operator|+
literal|8
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"r%i"
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
operator|-
name|FIRST_REX_INT_REG
operator|+
literal|8
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"unsupported operand size for extended register"
argument_list|)
expr_stmt|;
break|break;
block|}
return|return;
block|}
switch|switch
condition|(
name|code
condition|)
block|{
case|case
literal|3
case|:
if|if
condition|(
name|STACK_TOP_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|fputs
argument_list|(
literal|"st(0)"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* FALLTHRU */
case|case
literal|8
case|:
case|case
literal|4
case|:
case|case
literal|12
case|:
if|if
condition|(
operator|!
name|ANY_FP_REG_P
argument_list|(
name|x
argument_list|)
condition|)
name|putc
argument_list|(
name|code
operator|==
literal|8
operator|&&
name|TARGET_64BIT
condition|?
literal|'r'
else|:
literal|'e'
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* FALLTHRU */
case|case
literal|16
case|:
case|case
literal|2
case|:
name|fputs
argument_list|(
name|hi_reg_name
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|fputs
argument_list|(
name|qi_reg_name
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|fputs
argument_list|(
name|qi_high_reg_name
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Meaning of CODE:    L,W,B,Q,S,T -- print the opcode suffix for specified size of operand.    C -- print opcode suffix for set/cmov insn.    c -- like C, but print reversed condition    F,f -- likewise, but for floating-point.    R -- print the prefix for register names.    z -- print the opcode suffix for the size of the current operand.    * -- print a star (in certain assembler syntax)    A -- print an absolute memory reference.    w -- print the operand as if it's a "word" (HImode) even if it isn't.    s -- print a shift double count, followed by the assemblers argument 	delimiter.    b -- print the QImode name of the register for the indicated operand. 	%b0 would print %al if operands[0] is reg 0.    w --  likewise, print the HImode name of the register.    k --  likewise, print the SImode name of the register.    q --  likewise, print the DImode name of the register.    h -- print the QImode name for a "high" register, either ah, bh, ch or dh.    y -- print "st(0)" instead of "st" as a register.    D -- print condition for SSE cmp instruction.    P -- if PIC, print an @PLT suffix.    X -- don't print any sort of PIC '@' suffix for a symbol.  */
end_comment

begin_function
name|void
name|print_operand
parameter_list|(
name|file
parameter_list|,
name|x
parameter_list|,
name|code
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|int
name|code
decl_stmt|;
block|{
if|if
condition|(
name|code
condition|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
literal|'*'
case|:
if|if
condition|(
name|ASSEMBLER_DIALECT
operator|==
name|ASM_ATT
condition|)
name|putc
argument_list|(
literal|'*'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'A'
case|:
if|if
condition|(
name|ASSEMBLER_DIALECT
operator|==
name|ASM_ATT
condition|)
name|putc
argument_list|(
literal|'*'
argument_list|,
name|file
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ASSEMBLER_DIALECT
operator|==
name|ASM_INTEL
condition|)
block|{
comment|/* Intel syntax. For absolute addresses, registers should not 		 be surrounded by braces.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
condition|)
block|{
name|putc
argument_list|(
literal|'['
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|PRINT_OPERAND
argument_list|(
name|file
argument_list|,
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|']'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
name|PRINT_OPERAND
argument_list|(
name|file
argument_list|,
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'L'
case|:
if|if
condition|(
name|ASSEMBLER_DIALECT
operator|==
name|ASM_ATT
condition|)
name|putc
argument_list|(
literal|'l'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'W'
case|:
if|if
condition|(
name|ASSEMBLER_DIALECT
operator|==
name|ASM_ATT
condition|)
name|putc
argument_list|(
literal|'w'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'B'
case|:
if|if
condition|(
name|ASSEMBLER_DIALECT
operator|==
name|ASM_ATT
condition|)
name|putc
argument_list|(
literal|'b'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'Q'
case|:
if|if
condition|(
name|ASSEMBLER_DIALECT
operator|==
name|ASM_ATT
condition|)
name|putc
argument_list|(
literal|'l'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'S'
case|:
if|if
condition|(
name|ASSEMBLER_DIALECT
operator|==
name|ASM_ATT
condition|)
name|putc
argument_list|(
literal|'s'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'T'
case|:
if|if
condition|(
name|ASSEMBLER_DIALECT
operator|==
name|ASM_ATT
condition|)
name|putc
argument_list|(
literal|'t'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'z'
case|:
comment|/* 387 opcodes don't get size suffixes if the operands are 	     registers.  */
if|if
condition|(
name|STACK_REG_P
argument_list|(
name|x
argument_list|)
condition|)
return|return;
comment|/* this is the size of op from size of operand */
switch|switch
condition|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
block|{
case|case
literal|2
case|:
ifdef|#
directive|ifdef
name|HAVE_GAS_FILDS_FISTS
name|putc
argument_list|(
literal|'s'
argument_list|,
name|file
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
case|case
literal|4
case|:
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|SFmode
condition|)
block|{
name|putc
argument_list|(
literal|'s'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|putc
argument_list|(
literal|'l'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|12
case|:
case|case
literal|16
case|:
name|putc
argument_list|(
literal|'t'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|8
case|:
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MODE_INT
condition|)
block|{
ifdef|#
directive|ifdef
name|GAS_MNEMONICS
name|putc
argument_list|(
literal|'q'
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|#
directive|else
name|putc
argument_list|(
literal|'l'
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'l'
argument_list|,
name|file
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|putc
argument_list|(
literal|'l'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
case|case
literal|'b'
case|:
case|case
literal|'w'
case|:
case|case
literal|'k'
case|:
case|case
literal|'q'
case|:
case|case
literal|'h'
case|:
case|case
literal|'y'
case|:
case|case
literal|'X'
case|:
case|case
literal|'P'
case|:
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
operator|||
operator|!
name|SHIFT_DOUBLE_OMITS_COUNT
condition|)
block|{
name|PRINT_OPERAND
argument_list|(
name|file
argument_list|,
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|','
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
literal|'D'
case|:
comment|/* Little bit of braindamage here.  The SSE compare instructions 	     does use completely different names for the comparisons that the 	     fp conditional moves.  */
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|EQ
case|:
case|case
name|UNEQ
case|:
name|fputs
argument_list|(
literal|"eq"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|LT
case|:
case|case
name|UNLT
case|:
name|fputs
argument_list|(
literal|"lt"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|LE
case|:
case|case
name|UNLE
case|:
name|fputs
argument_list|(
literal|"le"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNORDERED
case|:
name|fputs
argument_list|(
literal|"unord"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|NE
case|:
case|case
name|LTGT
case|:
name|fputs
argument_list|(
literal|"neq"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNGE
case|:
case|case
name|GE
case|:
name|fputs
argument_list|(
literal|"nlt"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNGT
case|:
case|case
name|GT
case|:
name|fputs
argument_list|(
literal|"nle"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|ORDERED
case|:
name|fputs
argument_list|(
literal|"ord"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
break|break;
block|}
return|return;
case|case
literal|'C'
case|:
name|put_condition_code
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'F'
case|:
name|put_condition_code
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
comment|/* Like above, but reverse condition */
case|case
literal|'c'
case|:
comment|/* Check to see if argument to %c is really a constant  	     and not a condition code which needs to be reversed.  */
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
literal|'<'
condition|)
block|{
name|output_operand_lossage
argument_list|(
literal|"operand is neither a constant nor a condition code, invalid operand code 'c'"
argument_list|)
expr_stmt|;
return|return;
block|}
name|put_condition_code
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'f'
case|:
name|put_condition_code
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'+'
case|:
block|{
name|rtx
name|x
decl_stmt|;
if|if
condition|(
operator|!
name|optimize
operator|||
name|optimize_size
operator|||
operator|!
name|TARGET_BRANCH_PREDICTION_HINTS
condition|)
return|return;
name|x
operator|=
name|find_reg_note
argument_list|(
name|current_output_insn
argument_list|,
name|REG_BR_PROB
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
condition|)
block|{
name|int
name|pred_val
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|pred_val
operator|<
name|REG_BR_PROB_BASE
operator|*
literal|45
operator|/
literal|100
operator|||
name|pred_val
operator|>
name|REG_BR_PROB_BASE
operator|*
literal|55
operator|/
literal|100
condition|)
block|{
name|int
name|taken
init|=
name|pred_val
operator|>
name|REG_BR_PROB_BASE
operator|/
literal|2
decl_stmt|;
name|int
name|cputaken
init|=
name|final_forward_branch_p
argument_list|(
name|current_output_insn
argument_list|)
operator|==
literal|0
decl_stmt|;
comment|/* Emit hints only in the case default branch prediction 		       heruistics would fail.  */
if|if
condition|(
name|taken
operator|!=
name|cputaken
condition|)
block|{
comment|/* We use 3e (DS) prefix for taken branches and 			   2e (CS) prefix for not taken branches.  */
if|if
condition|(
name|taken
condition|)
name|fputs
argument_list|(
literal|"ds ; "
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
literal|"cs ; "
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return;
block|}
default|default:
block|{
name|char
name|str
index|[
literal|50
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|str
argument_list|,
literal|"invalid operand code `%c'"
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|output_operand_lossage
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
block|{
name|PRINT_REG
argument_list|(
name|x
argument_list|,
name|code
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
block|{
comment|/* No `byte ptr' prefix for call instructions.  */
if|if
condition|(
name|ASSEMBLER_DIALECT
operator|==
name|ASM_INTEL
operator|&&
name|code
operator|!=
literal|'X'
operator|&&
name|code
operator|!=
literal|'P'
condition|)
block|{
specifier|const
name|char
modifier|*
name|size
decl_stmt|;
switch|switch
condition|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
name|size
operator|=
literal|"BYTE"
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|size
operator|=
literal|"WORD"
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|size
operator|=
literal|"DWORD"
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|size
operator|=
literal|"QWORD"
expr_stmt|;
break|break;
case|case
literal|12
case|:
name|size
operator|=
literal|"XWORD"
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|size
operator|=
literal|"XMMWORD"
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Check for explicit size override (codes 'b', 'w' and 'k')  */
if|if
condition|(
name|code
operator|==
literal|'b'
condition|)
name|size
operator|=
literal|"BYTE"
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
literal|'w'
condition|)
name|size
operator|=
literal|"WORD"
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
literal|'k'
condition|)
name|size
operator|=
literal|"DWORD"
expr_stmt|;
name|fputs
argument_list|(
name|size
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|" PTR "
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_pic
operator|&&
name|CONSTANT_ADDRESS_P
argument_list|(
name|x
argument_list|)
condition|)
name|output_pic_addr_const
argument_list|(
name|file
argument_list|,
name|x
argument_list|,
name|code
argument_list|)
expr_stmt|;
comment|/* Avoid (%rip) for call operands.  */
elseif|else
if|if
condition|(
name|CONSTANT_ADDRESS_P
argument_list|(
name|x
argument_list|)
operator|&&
name|code
operator|==
literal|'P'
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
else|else
name|output_address
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|SFmode
condition|)
block|{
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|long
name|l
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|r
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|REAL_VALUE_TO_TARGET_SINGLE
argument_list|(
name|r
argument_list|,
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|ASSEMBLER_DIALECT
operator|==
name|ASM_ATT
condition|)
name|putc
argument_list|(
literal|'$'
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0x%lx"
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
comment|/* These float cases don't actually occur as immediate operands.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|DFmode
condition|)
block|{
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|char
name|dstr
index|[
literal|30
index|]
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|r
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|REAL_VALUE_TO_DECIMAL
argument_list|(
name|r
argument_list|,
literal|"%.22e"
argument_list|,
name|dstr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|dstr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
operator|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|XFmode
operator|||
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|TFmode
operator|)
condition|)
block|{
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|char
name|dstr
index|[
literal|30
index|]
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|r
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|REAL_VALUE_TO_DECIMAL
argument_list|(
name|r
argument_list|,
literal|"%.22e"
argument_list|,
name|dstr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|dstr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|code
operator|!=
literal|'P'
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
if|if
condition|(
name|ASSEMBLER_DIALECT
operator|==
name|ASM_ATT
condition|)
name|putc
argument_list|(
literal|'$'
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LABEL_REF
condition|)
block|{
if|if
condition|(
name|ASSEMBLER_DIALECT
operator|==
name|ASM_ATT
condition|)
name|putc
argument_list|(
literal|'$'
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
literal|"OFFSET FLAT:"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|flag_pic
condition|)
name|output_pic_addr_const
argument_list|(
name|file
argument_list|,
name|x
argument_list|,
name|code
argument_list|)
expr_stmt|;
else|else
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print a memory operand whose address is ADDR.  */
end_comment

begin_function
name|void
name|print_operand_address
parameter_list|(
name|file
parameter_list|,
name|addr
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
specifier|register
name|rtx
name|addr
decl_stmt|;
block|{
name|struct
name|ix86_address
name|parts
decl_stmt|;
name|rtx
name|base
decl_stmt|,
name|index
decl_stmt|,
name|disp
decl_stmt|;
name|int
name|scale
decl_stmt|;
if|if
condition|(
operator|!
name|ix86_decompose_address
argument_list|(
name|addr
argument_list|,
operator|&
name|parts
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|base
operator|=
name|parts
operator|.
name|base
expr_stmt|;
name|index
operator|=
name|parts
operator|.
name|index
expr_stmt|;
name|disp
operator|=
name|parts
operator|.
name|disp
expr_stmt|;
name|scale
operator|=
name|parts
operator|.
name|scale
expr_stmt|;
if|if
condition|(
operator|!
name|base
operator|&&
operator|!
name|index
condition|)
block|{
comment|/* Displacement only requires special attention.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|ASSEMBLER_DIALECT
operator|==
name|ASM_INTEL
condition|)
block|{
if|if
condition|(
name|USER_LABEL_PREFIX
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|putc
argument_list|(
literal|'%'
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"ds:"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|INTVAL
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flag_pic
condition|)
name|output_pic_addr_const
argument_list|(
name|file
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|addr
argument_list|)
expr_stmt|;
comment|/* Use one byte shorter RIP relative addressing for 64bit mode.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|!=
name|CONST_INT
operator|&&
name|TARGET_64BIT
condition|)
name|fputs
argument_list|(
literal|"(%rip)"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ASSEMBLER_DIALECT
operator|==
name|ASM_ATT
condition|)
block|{
if|if
condition|(
name|disp
condition|)
block|{
if|if
condition|(
name|flag_pic
condition|)
name|output_pic_addr_const
argument_list|(
name|file
argument_list|,
name|disp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|==
name|LABEL_REF
condition|)
name|output_asm_label
argument_list|(
name|disp
argument_list|)
expr_stmt|;
else|else
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|disp
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'('
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
condition|)
name|PRINT_REG
argument_list|(
name|base
argument_list|,
literal|0
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
condition|)
block|{
name|putc
argument_list|(
literal|','
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|PRINT_REG
argument_list|(
name|index
argument_list|,
literal|0
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|scale
operator|!=
literal|1
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|",%d"
argument_list|,
name|scale
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|')'
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|offset
init|=
name|NULL_RTX
decl_stmt|;
if|if
condition|(
name|disp
condition|)
block|{
comment|/* Pull out the offset of a symbol; print any symbol itself.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|offset
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|disp
operator|=
name|gen_rtx_CONST
argument_list|(
name|VOIDmode
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_pic
condition|)
name|output_pic_addr_const
argument_list|(
name|file
argument_list|,
name|disp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|==
name|LABEL_REF
condition|)
name|output_asm_label
argument_list|(
name|disp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|==
name|CONST_INT
condition|)
name|offset
operator|=
name|disp
expr_stmt|;
else|else
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|disp
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'['
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
condition|)
block|{
name|PRINT_REG
argument_list|(
name|base
argument_list|,
literal|0
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
condition|)
block|{
if|if
condition|(
name|INTVAL
argument_list|(
name|offset
argument_list|)
operator|>=
literal|0
condition|)
name|putc
argument_list|(
literal|'+'
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|INTVAL
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|offset
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|INTVAL
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|putc
argument_list|(
literal|'0'
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
condition|)
block|{
name|putc
argument_list|(
literal|'+'
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|PRINT_REG
argument_list|(
name|index
argument_list|,
literal|0
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|scale
operator|!=
literal|1
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"*%d"
argument_list|,
name|scale
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|']'
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Split one or more DImode RTL references into pairs of SImode    references.  The RTL can be REG, offsettable MEM, integer constant, or    CONST_DOUBLE.  "operands" is a pointer to an array of DImode RTL to    split and "num" is its length.  lo_half and hi_half are output arrays    that parallel "operands".  */
end_comment

begin_decl_stmt
name|void
name|split_di
argument_list|(
name|operands
argument_list|,
name|num
argument_list|,
name|lo_half
argument_list|,
name|hi_half
argument_list|)
name|rtx
name|operands
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|num
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|lo_half
index|[]
decl_stmt|,
name|hi_half
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
name|num
operator|--
condition|)
block|{
name|rtx
name|op
init|=
name|operands
index|[
name|num
index|]
decl_stmt|;
comment|/* simplify_subreg refuse to split volatile memory addresses,          but we still have to handle it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|lo_half
index|[
name|num
index|]
operator|=
name|adjust_address
argument_list|(
name|op
argument_list|,
name|SImode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|hi_half
index|[
name|num
index|]
operator|=
name|adjust_address
argument_list|(
name|op
argument_list|,
name|SImode
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lo_half
index|[
name|num
index|]
operator|=
name|simplify_gen_subreg
argument_list|(
name|SImode
argument_list|,
name|op
argument_list|,
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
condition|?
name|DImode
else|:
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|hi_half
index|[
name|num
index|]
operator|=
name|simplify_gen_subreg
argument_list|(
name|SImode
argument_list|,
name|op
argument_list|,
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
condition|?
name|DImode
else|:
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/* Split one or more TImode RTL references into pairs of SImode    references.  The RTL can be REG, offsettable MEM, integer constant, or    CONST_DOUBLE.  "operands" is a pointer to an array of DImode RTL to    split and "num" is its length.  lo_half and hi_half are output arrays    that parallel "operands".  */
end_comment

begin_decl_stmt
name|void
name|split_ti
argument_list|(
name|operands
argument_list|,
name|num
argument_list|,
name|lo_half
argument_list|,
name|hi_half
argument_list|)
name|rtx
name|operands
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|num
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|lo_half
index|[]
decl_stmt|,
name|hi_half
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
name|num
operator|--
condition|)
block|{
name|rtx
name|op
init|=
name|operands
index|[
name|num
index|]
decl_stmt|;
comment|/* simplify_subreg refuse to split volatile memory addresses, but we          still have to handle it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|lo_half
index|[
name|num
index|]
operator|=
name|adjust_address
argument_list|(
name|op
argument_list|,
name|DImode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|hi_half
index|[
name|num
index|]
operator|=
name|adjust_address
argument_list|(
name|op
argument_list|,
name|DImode
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lo_half
index|[
name|num
index|]
operator|=
name|simplify_gen_subreg
argument_list|(
name|DImode
argument_list|,
name|op
argument_list|,
name|TImode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|hi_half
index|[
name|num
index|]
operator|=
name|simplify_gen_subreg
argument_list|(
name|DImode
argument_list|,
name|op
argument_list|,
name|TImode
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Output code to perform a 387 binary operation in INSN, one of PLUS,    MINUS, MULT or DIV.  OPERANDS are the insn operands, where operands[3]    is the expression of the binary operation.  The output may either be    emitted here, or returned to the caller, like all output_* functions.     There is no guarantee that the operands are the same mode, as they    might be within FLOAT or FLOAT_EXTEND expressions.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SYSV386_COMPAT
end_ifndef

begin_comment
comment|/* Set to 1 for compatibility with brain-damaged assemblers.  No-one    wants to fix the assemblers because that causes incompatibility    with gcc.  No-one wants to fix gcc because that causes    incompatibility with assemblers...  You can use the option of    -DSYSV386_COMPAT=0 if you recompile both gcc and gas this way.  */
end_comment

begin_define
define|#
directive|define
name|SYSV386_COMPAT
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|const
name|char
modifier|*
name|output_387_binary_op
parameter_list|(
name|insn
parameter_list|,
name|operands
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
literal|30
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|ssep
decl_stmt|;
name|int
name|is_sse
init|=
name|SSE_REG_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator||
name|SSE_REG_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator||
name|SSE_REG_P
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
comment|/* Even if we do not want to check the inputs, this documents input      constraints.  Which helps in understanding the following code.  */
if|if
condition|(
name|STACK_REG_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|&&
operator|(
operator|(
name|REG_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|&&
operator|(
name|STACK_REG_P
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|==
name|MEM
operator|)
operator|)
operator|||
operator|(
name|REG_P
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|REGNO
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|&&
operator|(
name|STACK_REG_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|MEM
operator|)
operator|)
operator|)
operator|&&
operator|(
name|STACK_TOP_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|||
name|STACK_TOP_P
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|)
condition|)
empty_stmt|;
comment|/* ok */
elseif|else
if|if
condition|(
operator|!
name|is_sse
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
case|case
name|PLUS
case|:
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|||
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
argument_list|)
operator|==
name|MODE_INT
condition|)
name|p
operator|=
literal|"fiadd"
expr_stmt|;
else|else
name|p
operator|=
literal|"fadd"
expr_stmt|;
name|ssep
operator|=
literal|"add"
expr_stmt|;
break|break;
case|case
name|MINUS
case|:
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|||
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
argument_list|)
operator|==
name|MODE_INT
condition|)
name|p
operator|=
literal|"fisub"
expr_stmt|;
else|else
name|p
operator|=
literal|"fsub"
expr_stmt|;
name|ssep
operator|=
literal|"sub"
expr_stmt|;
break|break;
case|case
name|MULT
case|:
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|||
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
argument_list|)
operator|==
name|MODE_INT
condition|)
name|p
operator|=
literal|"fimul"
expr_stmt|;
else|else
name|p
operator|=
literal|"fmul"
expr_stmt|;
name|ssep
operator|=
literal|"mul"
expr_stmt|;
break|break;
case|case
name|DIV
case|:
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|||
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
argument_list|)
operator|==
name|MODE_INT
condition|)
name|p
operator|=
literal|"fidiv"
expr_stmt|;
else|else
name|p
operator|=
literal|"fdiv"
expr_stmt|;
name|ssep
operator|=
literal|"div"
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|is_sse
condition|)
block|{
name|strcpy
argument_list|(
name|buf
argument_list|,
name|ssep
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|SFmode
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"ss\t{%2, %0|%0, %2}"
argument_list|)
expr_stmt|;
else|else
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"sd\t{%2, %0|%0, %2}"
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
name|strcpy
argument_list|(
name|buf
argument_list|,
name|p
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
case|case
name|MULT
case|:
case|case
name|PLUS
case|:
if|if
condition|(
name|REG_P
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|REGNO
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
name|rtx
name|temp
init|=
name|operands
index|[
literal|2
index|]
decl_stmt|;
name|operands
index|[
literal|2
index|]
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|temp
expr_stmt|;
block|}
comment|/* know operands[0] == operands[1].  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|p
operator|=
literal|"%z2\t%2"
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|STACK_TOP_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
comment|/* How is it that we are storing to a dead operand[2]? 	       Well, presumably operands[1] is dead too.  We can't 	       store the result to st(0) as st(0) gets popped on this 	       instruction.  Instead store to operands[2] (which I 	       think has to be st(1)).  st(1) will be popped later. 	       gcc<= 2.8.1 didn't have this check and generated 	       assembly code that the Unixware assembler rejected.  */
name|p
operator|=
literal|"p\t{%0, %2|%2, %0}"
expr_stmt|;
comment|/* st(1) = st(0) op st(1); pop */
else|else
name|p
operator|=
literal|"p\t{%2, %0|%0, %2}"
expr_stmt|;
comment|/* st(r1) = st(r1) op st(0); pop */
break|break;
block|}
if|if
condition|(
name|STACK_TOP_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
name|p
operator|=
literal|"\t{%y2, %0|%0, %y2}"
expr_stmt|;
comment|/* st(0) = st(0) op st(r2) */
else|else
name|p
operator|=
literal|"\t{%2, %0|%0, %2}"
expr_stmt|;
comment|/* st(r1) = st(r1) op st(0) */
break|break;
case|case
name|MINUS
case|:
case|case
name|DIV
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|p
operator|=
literal|"r%z1\t%1"
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|p
operator|=
literal|"%z2\t%2"
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|SYSV386_COMPAT
comment|/* The SystemV/386 SVR3.2 assembler, and probably all AT&T 	     derived assemblers, confusingly reverse the direction of 	     the operation for fsub{r} and fdiv{r} when the 	     destination register is not st(0).  The Intel assembler 	     doesn't have this brain damage.  Read !SYSV386_COMPAT to 	     figure out what the hardware really does.  */
if|if
condition|(
name|STACK_TOP_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
name|p
operator|=
literal|"{p\t%0, %2|rp\t%2, %0}"
expr_stmt|;
else|else
name|p
operator|=
literal|"{rp\t%2, %0|p\t%0, %2}"
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|STACK_TOP_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
comment|/* As above for fmul/fadd, we can't store to st(0).  */
name|p
operator|=
literal|"rp\t{%0, %2|%2, %0}"
expr_stmt|;
comment|/* st(1) = st(0) op st(1); pop */
else|else
name|p
operator|=
literal|"p\t{%2, %0|%0, %2}"
expr_stmt|;
comment|/* st(r1) = st(r1) op st(0); pop */
endif|#
directive|endif
break|break;
block|}
if|if
condition|(
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|SYSV386_COMPAT
if|if
condition|(
name|STACK_TOP_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
name|p
operator|=
literal|"{rp\t%0, %1|p\t%1, %0}"
expr_stmt|;
else|else
name|p
operator|=
literal|"{p\t%1, %0|rp\t%0, %1}"
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|STACK_TOP_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
name|p
operator|=
literal|"p\t{%0, %1|%1, %0}"
expr_stmt|;
comment|/* st(1) = st(1) op st(0); pop */
else|else
name|p
operator|=
literal|"rp\t{%1, %0|%0, %1}"
expr_stmt|;
comment|/* st(r2) = st(0) op st(r2); pop */
endif|#
directive|endif
break|break;
block|}
if|if
condition|(
name|STACK_TOP_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|STACK_TOP_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
name|p
operator|=
literal|"\t{%y2, %0|%0, %y2}"
expr_stmt|;
comment|/* st(0) = st(0) op st(r2) */
else|else
name|p
operator|=
literal|"r\t{%y1, %0|%0, %y1}"
expr_stmt|;
comment|/* st(0) = st(r1) op st(0) */
break|break;
block|}
elseif|else
if|if
condition|(
name|STACK_TOP_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
if|#
directive|if
name|SYSV386_COMPAT
name|p
operator|=
literal|"{\t%1, %0|r\t%0, %1}"
expr_stmt|;
else|#
directive|else
name|p
operator|=
literal|"r\t{%1, %0|%0, %1}"
expr_stmt|;
comment|/* st(r2) = st(0) op st(r2) */
endif|#
directive|endif
block|}
else|else
block|{
if|#
directive|if
name|SYSV386_COMPAT
name|p
operator|=
literal|"{r\t%2, %0|\t%0, %2}"
expr_stmt|;
else|#
directive|else
name|p
operator|=
literal|"\t{%2, %0|%0, %2}"
expr_stmt|;
comment|/* st(r1) = st(r1) op st(0) */
endif|#
directive|endif
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|strcat
argument_list|(
name|buf
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/* Output code to initialize control word copies used by    trunc?f?i patterns.  NORMAL is set to current control word, while ROUND_DOWN    is set to control word rounding downwards.  */
end_comment

begin_function
name|void
name|emit_i387_cw_initialization
parameter_list|(
name|normal
parameter_list|,
name|round_down
parameter_list|)
name|rtx
name|normal
decl_stmt|,
name|round_down
decl_stmt|;
block|{
name|rtx
name|reg
init|=
name|gen_reg_rtx
argument_list|(
name|HImode
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_x86_fnstcw_1
argument_list|(
name|normal
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|normal
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TARGET_PARTIAL_REG_STALL
operator|&&
operator|!
name|optimize_size
operator|&&
operator|!
name|TARGET_64BIT
condition|)
name|emit_insn
argument_list|(
name|gen_movsi_insv_1
argument_list|(
name|reg
argument_list|,
name|GEN_INT
argument_list|(
literal|0xc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_iorhi3
argument_list|(
name|reg
argument_list|,
name|reg
argument_list|,
name|GEN_INT
argument_list|(
literal|0xc00
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|round_down
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output code for INSN to convert a float to a signed int.  OPERANDS    are the insn operands.  The output may be [HSD]Imode and the input    operand may be [SDX]Fmode.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|output_fix_trunc
parameter_list|(
name|insn
parameter_list|,
name|operands
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
name|int
name|stack_top_dies
init|=
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|FIRST_STACK_REG
argument_list|)
operator|!=
literal|0
decl_stmt|;
name|int
name|dimode_p
init|=
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|DImode
decl_stmt|;
comment|/* Jump through a hoop or two for DImode, since the hardware has no      non-popping instruction.  We used to do this a different way, but      that was somewhat fragile and broke with post-reload splitters.  */
if|if
condition|(
name|dimode_p
operator|&&
operator|!
name|stack_top_dies
condition|)
name|output_asm_insn
argument_list|(
literal|"fld\t%y1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|STACK_TOP_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|!=
name|MEM
condition|)
name|abort
argument_list|()
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"fldcw\t%3"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
if|if
condition|(
name|stack_top_dies
operator|||
name|dimode_p
condition|)
name|output_asm_insn
argument_list|(
literal|"fistp%z0\t%0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
else|else
name|output_asm_insn
argument_list|(
literal|"fist%z0\t%0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"fldcw\t%2"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
end_function

begin_comment
comment|/* Output code for INSN to compare OPERANDS.  EFLAGS_P is 1 when fcomi    should be used and 2 when fnstsw should be used.  UNORDERED_P is true    when fucom should be used.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|output_fp_compare
parameter_list|(
name|insn
parameter_list|,
name|operands
parameter_list|,
name|eflags_p
parameter_list|,
name|unordered_p
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
modifier|*
name|operands
decl_stmt|;
name|int
name|eflags_p
decl_stmt|,
name|unordered_p
decl_stmt|;
block|{
name|int
name|stack_top_dies
decl_stmt|;
name|rtx
name|cmp_op0
init|=
name|operands
index|[
literal|0
index|]
decl_stmt|;
name|rtx
name|cmp_op1
init|=
name|operands
index|[
literal|1
index|]
decl_stmt|;
name|int
name|is_sse
init|=
name|SSE_REG_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator||
name|SSE_REG_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|eflags_p
operator|==
literal|2
condition|)
block|{
name|cmp_op0
operator|=
name|cmp_op1
expr_stmt|;
name|cmp_op1
operator|=
name|operands
index|[
literal|2
index|]
expr_stmt|;
block|}
if|if
condition|(
name|is_sse
condition|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|SFmode
condition|)
if|if
condition|(
name|unordered_p
condition|)
return|return
literal|"ucomiss\t{%1, %0|%0, %1}"
return|;
else|else
return|return
literal|"comiss\t{%1, %0|%0, %y}"
return|;
elseif|else
if|if
condition|(
name|unordered_p
condition|)
return|return
literal|"ucomisd\t{%1, %0|%0, %1}"
return|;
else|else
return|return
literal|"comisd\t{%1, %0|%0, %y}"
return|;
block|}
if|if
condition|(
operator|!
name|STACK_TOP_P
argument_list|(
name|cmp_op0
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|stack_top_dies
operator|=
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|FIRST_STACK_REG
argument_list|)
operator|!=
literal|0
expr_stmt|;
if|if
condition|(
name|STACK_REG_P
argument_list|(
name|cmp_op1
argument_list|)
operator|&&
name|stack_top_dies
operator|&&
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
name|cmp_op1
argument_list|)
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|cmp_op1
argument_list|)
operator|!=
name|FIRST_STACK_REG
condition|)
block|{
comment|/* If both the top of the 387 stack dies, and the other operand 	 is also a stack register that dies, then this must be a 	 `fcompp' float compare */
if|if
condition|(
name|eflags_p
operator|==
literal|1
condition|)
block|{
comment|/* There is no double popping fcomi variant.  Fortunately, 	     eflags is immune from the fstp's cc clobbering.  */
if|if
condition|(
name|unordered_p
condition|)
name|output_asm_insn
argument_list|(
literal|"fucomip\t{%y1, %0|%0, %y1}"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
else|else
name|output_asm_insn
argument_list|(
literal|"fcomip\t{%y1, %0|%0, %y1}"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return
literal|"fstp\t%y0"
return|;
block|}
else|else
block|{
if|if
condition|(
name|eflags_p
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|unordered_p
condition|)
return|return
literal|"fucompp\n\tfnstsw\t%0"
return|;
else|else
return|return
literal|"fcompp\n\tfnstsw\t%0"
return|;
block|}
else|else
block|{
if|if
condition|(
name|unordered_p
condition|)
return|return
literal|"fucompp"
return|;
else|else
return|return
literal|"fcompp"
return|;
block|}
block|}
block|}
else|else
block|{
comment|/* Encoded here as eflags_p | intmode | unordered_p | stack_top_dies.  */
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|alt
index|[
literal|24
index|]
init|=
block|{
literal|"fcom%z1\t%y1"
block|,
literal|"fcomp%z1\t%y1"
block|,
literal|"fucom%z1\t%y1"
block|,
literal|"fucomp%z1\t%y1"
block|,
literal|"ficom%z1\t%y1"
block|,
literal|"ficomp%z1\t%y1"
block|,
name|NULL
block|,
name|NULL
block|,
literal|"fcomi\t{%y1, %0|%0, %y1}"
block|,
literal|"fcomip\t{%y1, %0|%0, %y1}"
block|,
literal|"fucomi\t{%y1, %0|%0, %y1}"
block|,
literal|"fucomip\t{%y1, %0|%0, %y1}"
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|"fcom%z2\t%y2\n\tfnstsw\t%0"
block|,
literal|"fcomp%z2\t%y2\n\tfnstsw\t%0"
block|,
literal|"fucom%z2\t%y2\n\tfnstsw\t%0"
block|,
literal|"fucomp%z2\t%y2\n\tfnstsw\t%0"
block|,
literal|"ficom%z2\t%y2\n\tfnstsw\t%0"
block|,
literal|"ficomp%z2\t%y2\n\tfnstsw\t%0"
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
name|int
name|mask
decl_stmt|;
specifier|const
name|char
modifier|*
name|ret
decl_stmt|;
name|mask
operator|=
name|eflags_p
operator|<<
literal|3
expr_stmt|;
name|mask
operator||=
operator|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|)
operator|<<
literal|2
expr_stmt|;
name|mask
operator||=
name|unordered_p
operator|<<
literal|1
expr_stmt|;
name|mask
operator||=
name|stack_top_dies
expr_stmt|;
if|if
condition|(
name|mask
operator|>=
literal|24
condition|)
name|abort
argument_list|()
expr_stmt|;
name|ret
operator|=
name|alt
index|[
name|mask
index|]
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|ret
return|;
block|}
block|}
end_function

begin_function
name|void
name|ix86_output_addr_vec_elt
parameter_list|(
name|file
parameter_list|,
name|value
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|value
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|directive
init|=
name|ASM_LONG
decl_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
ifdef|#
directive|ifdef
name|ASM_QUAD
name|directive
operator|=
name|ASM_QUAD
expr_stmt|;
else|#
directive|else
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s%s%d\n"
argument_list|,
name|directive
argument_list|,
name|LPREFIX
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ix86_output_addr_diff_elt
parameter_list|(
name|file
parameter_list|,
name|value
parameter_list|,
name|rel
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|value
decl_stmt|,
name|rel
decl_stmt|;
block|{
if|if
condition|(
name|TARGET_64BIT
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s%s%d-.+4+(.-%s%d)\n"
argument_list|,
name|ASM_LONG
argument_list|,
name|LPREFIX
argument_list|,
name|value
argument_list|,
name|LPREFIX
argument_list|,
name|rel
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|HAVE_AS_GOTOFF_IN_DATA
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s%s%d@GOTOFF\n"
argument_list|,
name|ASM_LONG
argument_list|,
name|LPREFIX
argument_list|,
name|value
argument_list|)
expr_stmt|;
else|else
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"%s%U_GLOBAL_OFFSET_TABLE_+[.-%s%d]\n"
argument_list|,
name|ASM_LONG
argument_list|,
name|LPREFIX
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate either "mov $0, reg" or "xor reg, reg", as appropriate    for the target.  */
end_comment

begin_function
name|void
name|ix86_expand_clear
parameter_list|(
name|dest
parameter_list|)
name|rtx
name|dest
decl_stmt|;
block|{
name|rtx
name|tmp
decl_stmt|;
comment|/* We play register width games, which are only valid after reload.  */
if|if
condition|(
operator|!
name|reload_completed
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Avoid HImode and its attendant prefix byte.  */
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|<
literal|4
condition|)
name|dest
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|dest
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
comment|/* This predicate should match that for movsi_xor and movdi_xor_rex64.  */
if|if
condition|(
name|reload_completed
operator|&&
operator|(
operator|!
name|TARGET_USE_MOV0
operator|||
name|optimize_size
operator|)
condition|)
block|{
name|rtx
name|clob
init|=
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|CCmode
argument_list|,
literal|17
argument_list|)
argument_list|)
decl_stmt|;
name|tmp
operator|=
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|tmp
argument_list|,
name|clob
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|emit_insn
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ix86_expand_move
parameter_list|(
name|mode
parameter_list|,
name|operands
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|operands
index|[]
decl_stmt|;
block|{
name|int
name|strict
init|=
operator|(
name|reload_in_progress
operator|||
name|reload_completed
operator|)
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
name|flag_pic
operator|&&
name|mode
operator|==
name|Pmode
operator|&&
name|symbolic_operand
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|Pmode
argument_list|)
condition|)
block|{
comment|/* Emit insns to move operands[1] into operands[0].  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|MEM
condition|)
name|operands
index|[
literal|1
index|]
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
block|{
name|rtx
name|temp
init|=
name|operands
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|!=
name|REG
condition|)
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|temp
operator|=
name|legitimize_pic_address
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
name|operands
index|[
literal|0
index|]
condition|)
return|return;
name|operands
index|[
literal|1
index|]
operator|=
name|temp
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
name|PUSH_ROUNDING
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|)
operator|!=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|||
operator|!
name|push_operand
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|mode
argument_list|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|MEM
condition|)
name|operands
index|[
literal|1
index|]
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|push_operand
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|mode
argument_list|)
operator|&&
operator|!
name|general_no_elim_operand
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|mode
argument_list|)
condition|)
name|operands
index|[
literal|1
index|]
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* Force large constants in 64bit compilation into register 	 to get them CSEed.  */
if|if
condition|(
name|TARGET_64BIT
operator|&&
name|mode
operator|==
name|DImode
operator|&&
name|immediate_operand
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|mode
argument_list|)
operator|&&
operator|!
name|x86_64_zero_extended_value
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|&&
operator|!
name|register_operand
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|mode
argument_list|)
operator|&&
name|optimize
operator|&&
operator|!
name|reload_completed
operator|&&
operator|!
name|reload_in_progress
condition|)
name|operands
index|[
literal|1
index|]
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
block|{
comment|/* If we are loading a floating point constant to a register, 	     force the value to memory now, since we'll get better code 	     out the back end.  */
if|if
condition|(
name|strict
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|register_operand
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|mode
argument_list|)
condition|)
name|operands
index|[
literal|1
index|]
operator|=
name|validize_mem
argument_list|(
name|force_const_mem
argument_list|(
name|mode
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|insn
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ix86_expand_vector_move
parameter_list|(
name|mode
parameter_list|,
name|operands
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|operands
index|[]
decl_stmt|;
block|{
comment|/* Force constants other than zero into memory.  We do not know how      the instructions used to build constants modify the upper 64 bits      of the register, once we have that information we may be able      to handle some of them more efficiently.  */
if|if
condition|(
operator|(
name|reload_in_progress
operator||
name|reload_completed
operator|)
operator|==
literal|0
operator|&&
name|register_operand
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|mode
argument_list|)
operator|&&
name|CONSTANT_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|rtx
name|addr
init|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|addr
argument_list|,
name|XEXP
argument_list|(
name|force_const_mem
argument_list|(
name|mode
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
comment|/* Make operand1 a register if it isn't already.  */
if|if
condition|(
operator|(
name|reload_in_progress
operator||
name|reload_completed
operator|)
operator|==
literal|0
operator|&&
operator|!
name|register_operand
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|mode
argument_list|)
operator|&&
operator|!
name|register_operand
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|mode
argument_list|)
operator|&&
name|operands
index|[
literal|1
index|]
operator|!=
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|rtx
name|temp
init|=
name|force_reg
argument_list|(
name|TImode
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|temp
argument_list|)
expr_stmt|;
return|return;
block|}
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Attempt to expand a binary operator.  Make the expansion closer to the    actual machine, then just general_operand, which will allow 3 separate    memory references (one output, two input) in a single insn.  */
end_comment

begin_function
name|void
name|ix86_expand_binary_operator
parameter_list|(
name|code
parameter_list|,
name|mode
parameter_list|,
name|operands
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|operands
index|[]
decl_stmt|;
block|{
name|int
name|matching_memory
decl_stmt|;
name|rtx
name|src1
decl_stmt|,
name|src2
decl_stmt|,
name|dst
decl_stmt|,
name|op
decl_stmt|,
name|clob
decl_stmt|;
name|dst
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
name|src1
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
name|src2
operator|=
name|operands
index|[
literal|2
index|]
expr_stmt|;
comment|/* Recognize<var1> =<value><op><var1> for commutative operators */
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'c'
operator|&&
operator|(
name|rtx_equal_p
argument_list|(
name|dst
argument_list|,
name|src2
argument_list|)
operator|||
name|immediate_operand
argument_list|(
name|src1
argument_list|,
name|mode
argument_list|)
operator|)
condition|)
block|{
name|rtx
name|temp
init|=
name|src1
decl_stmt|;
name|src1
operator|=
name|src2
expr_stmt|;
name|src2
operator|=
name|temp
expr_stmt|;
block|}
comment|/* If the destination is memory, and we do not have matching source      operands, do things in registers.  */
name|matching_memory
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|dst
argument_list|,
name|src1
argument_list|)
condition|)
name|matching_memory
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'c'
operator|&&
name|rtx_equal_p
argument_list|(
name|dst
argument_list|,
name|src2
argument_list|)
condition|)
name|matching_memory
operator|=
literal|2
expr_stmt|;
else|else
name|dst
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
comment|/* Both source operands cannot be in memory.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|src1
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|src2
argument_list|)
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
name|matching_memory
operator|!=
literal|2
condition|)
name|src2
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|src2
argument_list|)
expr_stmt|;
else|else
name|src1
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|src1
argument_list|)
expr_stmt|;
block|}
comment|/* If the operation is not commutable, source 1 cannot be a constant      or non-matching memory.  */
if|if
condition|(
operator|(
name|CONSTANT_P
argument_list|(
name|src1
argument_list|)
operator|||
operator|(
operator|!
name|matching_memory
operator|&&
name|GET_CODE
argument_list|(
name|src1
argument_list|)
operator|==
name|MEM
operator|)
operator|)
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|!=
literal|'c'
condition|)
name|src1
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|src1
argument_list|)
expr_stmt|;
comment|/* If optimizing, copy to regs to improve CSE */
if|if
condition|(
name|optimize
operator|&&
operator|!
name|no_new_pseudos
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|==
name|MEM
condition|)
name|dst
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src1
argument_list|)
operator|==
name|MEM
condition|)
name|src1
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|src1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src2
argument_list|)
operator|==
name|MEM
condition|)
name|src2
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|src2
argument_list|)
expr_stmt|;
block|}
comment|/* Emit the instruction.  */
name|op
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|dst
argument_list|,
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|src1
argument_list|,
name|src2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reload_in_progress
condition|)
block|{
comment|/* Reload doesn't know about the flags register, and doesn't know that          it doesn't want to clobber it.  We can only do this with PLUS.  */
if|if
condition|(
name|code
operator|!=
name|PLUS
condition|)
name|abort
argument_list|()
expr_stmt|;
name|emit_insn
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|clob
operator|=
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|CCmode
argument_list|,
name|FLAGS_REG
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|op
argument_list|,
name|clob
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Fix up the destination if needed.  */
if|if
condition|(
name|dst
operator|!=
name|operands
index|[
literal|0
index|]
condition|)
name|emit_move_insn
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|dst
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return TRUE or FALSE depending on whether the binary operator meets the    appropriate constraints.  */
end_comment

begin_function
name|int
name|ix86_binary_operator_ok
parameter_list|(
name|code
parameter_list|,
name|mode
parameter_list|,
name|operands
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|rtx
name|operands
index|[
literal|3
index|]
decl_stmt|;
block|{
comment|/* Both source operands cannot be in memory.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|==
name|MEM
condition|)
return|return
literal|0
return|;
comment|/* If the operation is not commutable, source 1 cannot be a constant.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|!=
literal|'c'
condition|)
return|return
literal|0
return|;
comment|/* If the destination is memory, we must have a matching source operand.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
operator|(
name|rtx_equal_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
operator|||
operator|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'c'
operator|&&
name|rtx_equal_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|)
operator|)
operator|)
condition|)
return|return
literal|0
return|;
comment|/* If the operation is not commutable and the source 1 is memory, we must      have a matching destination.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|!=
literal|'c'
operator|&&
operator|!
name|rtx_equal_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Attempt to expand a unary operator.  Make the expansion closer to the    actual machine, then just general_operand, which will allow 2 separate    memory references (one output, one input) in a single insn.  */
end_comment

begin_function
name|void
name|ix86_expand_unary_operator
parameter_list|(
name|code
parameter_list|,
name|mode
parameter_list|,
name|operands
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|operands
index|[]
decl_stmt|;
block|{
name|int
name|matching_memory
decl_stmt|;
name|rtx
name|src
decl_stmt|,
name|dst
decl_stmt|,
name|op
decl_stmt|,
name|clob
decl_stmt|;
name|dst
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
name|src
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
comment|/* If the destination is memory, and we do not have matching source      operands, do things in registers.  */
name|matching_memory
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|dst
argument_list|,
name|src
argument_list|)
condition|)
name|matching_memory
operator|=
literal|1
expr_stmt|;
else|else
name|dst
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
comment|/* When source operand is memory, destination must match.  */
if|if
condition|(
operator|!
name|matching_memory
operator|&&
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|MEM
condition|)
name|src
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|src
argument_list|)
expr_stmt|;
comment|/* If optimizing, copy to regs to improve CSE */
if|if
condition|(
name|optimize
operator|&&
operator|!
name|no_new_pseudos
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|==
name|MEM
condition|)
name|dst
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|MEM
condition|)
name|src
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|src
argument_list|)
expr_stmt|;
block|}
comment|/* Emit the instruction.  */
name|op
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|dst
argument_list|,
name|gen_rtx_fmt_e
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|src
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reload_in_progress
operator|||
name|code
operator|==
name|NOT
condition|)
block|{
comment|/* Reload doesn't know about the flags register, and doesn't know that          it doesn't want to clobber it.  */
if|if
condition|(
name|code
operator|!=
name|NOT
condition|)
name|abort
argument_list|()
expr_stmt|;
name|emit_insn
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|clob
operator|=
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|CCmode
argument_list|,
name|FLAGS_REG
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|op
argument_list|,
name|clob
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Fix up the destination if needed.  */
if|if
condition|(
name|dst
operator|!=
name|operands
index|[
literal|0
index|]
condition|)
name|emit_move_insn
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|dst
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return TRUE or FALSE depending on whether the unary operator meets the    appropriate constraints.  */
end_comment

begin_function
name|int
name|ix86_unary_operator_ok
parameter_list|(
name|code
parameter_list|,
name|mode
parameter_list|,
name|operands
parameter_list|)
name|enum
name|rtx_code
name|code
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|rtx
name|operands
index|[
literal|2
index|]
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
comment|/* If one of operands is memory, source and destination must match.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|MEM
operator|||
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|MEM
operator|)
operator|&&
operator|!
name|rtx_equal_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE or FALSE depending on whether the first SET in INSN    has source and destination with matching CC modes, and that the    CC mode is at least as constrained as REQ_MODE.  */
end_comment

begin_function
name|int
name|ix86_match_ccmode
parameter_list|(
name|insn
parameter_list|,
name|req_mode
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|enum
name|machine_mode
name|req_mode
decl_stmt|;
block|{
name|rtx
name|set
decl_stmt|;
name|enum
name|machine_mode
name|set_mode
decl_stmt|;
name|set
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|set
argument_list|)
operator|==
name|PARALLEL
condition|)
name|set
operator|=
name|XVECEXP
argument_list|(
name|set
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|set
argument_list|)
operator|!=
name|SET
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|!=
name|COMPARE
condition|)
name|abort
argument_list|()
expr_stmt|;
name|set_mode
operator|=
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|set_mode
condition|)
block|{
case|case
name|CCNOmode
case|:
if|if
condition|(
name|req_mode
operator|!=
name|CCNOmode
operator|&&
operator|(
name|req_mode
operator|!=
name|CCmode
operator|||
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|!=
name|const0_rtx
operator|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
name|CCmode
case|:
if|if
condition|(
name|req_mode
operator|==
name|CCGCmode
condition|)
return|return
literal|0
return|;
comment|/* FALLTHRU */
case|case
name|CCGCmode
case|:
if|if
condition|(
name|req_mode
operator|==
name|CCGOCmode
operator|||
name|req_mode
operator|==
name|CCNOmode
condition|)
return|return
literal|0
return|;
comment|/* FALLTHRU */
case|case
name|CCGOCmode
case|:
if|if
condition|(
name|req_mode
operator|==
name|CCZmode
condition|)
return|return
literal|0
return|;
comment|/* FALLTHRU */
case|case
name|CCZmode
case|:
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|set_mode
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Generate insn patterns to do an integer compare of OPERANDS.  */
end_comment

begin_function
specifier|static
name|rtx
name|ix86_expand_int_compare
parameter_list|(
name|code
parameter_list|,
name|op0
parameter_list|,
name|op1
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
block|{
name|enum
name|machine_mode
name|cmpmode
decl_stmt|;
name|rtx
name|tmp
decl_stmt|,
name|flags
decl_stmt|;
name|cmpmode
operator|=
name|SELECT_CC_MODE
argument_list|(
name|code
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|flags
operator|=
name|gen_rtx_REG
argument_list|(
name|cmpmode
argument_list|,
name|FLAGS_REG
argument_list|)
expr_stmt|;
comment|/* This is very simple, but making the interface the same as in the      FP case makes the rest of the code easier.  */
name|tmp
operator|=
name|gen_rtx_COMPARE
argument_list|(
name|cmpmode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|flags
argument_list|,
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Return the test that should be put into the flags user, i.e.      the bcc, scc, or cmov instruction.  */
return|return
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|VOIDmode
argument_list|,
name|flags
argument_list|,
name|const0_rtx
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Figure out whether to use ordered or unordered fp comparisons.    Return the appropriate mode to use.  */
end_comment

begin_function
name|enum
name|machine_mode
name|ix86_fp_compare_mode
parameter_list|(
name|code
parameter_list|)
name|enum
name|rtx_code
name|code
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
comment|/* ??? In order to make all comparisons reversible, we do all comparisons      non-trapping when compiling for IEEE.  Once gcc is able to distinguish      all forms trapping and nontrapping comparisons, we can make inequality      comparisons trapping again, since it results in better code when using      FCOM based compares.  */
return|return
name|TARGET_IEEE_FP
condition|?
name|CCFPUmode
else|:
name|CCFPmode
return|;
block|}
end_function

begin_function
name|enum
name|machine_mode
name|ix86_cc_mode
parameter_list|(
name|code
parameter_list|,
name|op0
parameter_list|,
name|op1
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
block|{
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
return|return
name|ix86_fp_compare_mode
argument_list|(
name|code
argument_list|)
return|;
switch|switch
condition|(
name|code
condition|)
block|{
comment|/* Only zero flag is needed.  */
case|case
name|EQ
case|:
comment|/* ZF=0 */
case|case
name|NE
case|:
comment|/* ZF!=0 */
return|return
name|CCZmode
return|;
comment|/* Codes needing carry flag.  */
case|case
name|GEU
case|:
comment|/* CF=0 */
case|case
name|GTU
case|:
comment|/* CF=0& ZF=0 */
case|case
name|LTU
case|:
comment|/* CF=1 */
case|case
name|LEU
case|:
comment|/* CF=1 | ZF=1 */
return|return
name|CCmode
return|;
comment|/* Codes possibly doable only with sign flag when          comparing against zero.  */
case|case
name|GE
case|:
comment|/* SF=OF   or   SF=0 */
case|case
name|LT
case|:
comment|/* SF<>OF  or   SF=1 */
if|if
condition|(
name|op1
operator|==
name|const0_rtx
condition|)
return|return
name|CCGOCmode
return|;
else|else
comment|/* For other cases Carry flag is not required.  */
return|return
name|CCGCmode
return|;
comment|/* Codes doable only with sign flag when comparing          against zero, but we miss jump instruction for it          so we need to use relational tests agains overflow          that thus needs to be zero.  */
case|case
name|GT
case|:
comment|/* ZF=0& SF=OF */
case|case
name|LE
case|:
comment|/* ZF=1 | SF<>OF */
if|if
condition|(
name|op1
operator|==
name|const0_rtx
condition|)
return|return
name|CCNOmode
return|;
else|else
return|return
name|CCGCmode
return|;
comment|/* strcmp pattern do (use flags) and combine may ask us for proper 	 mode.  */
case|case
name|USE
case|:
return|return
name|CCmode
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return true if we should use an FCOMI instruction for this fp comparison.  */
end_comment

begin_function
name|int
name|ix86_use_fcomi_compare
parameter_list|(
name|code
parameter_list|)
name|enum
name|rtx_code
name|code
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|enum
name|rtx_code
name|swapped_code
init|=
name|swap_condition
argument_list|(
name|code
argument_list|)
decl_stmt|;
return|return
operator|(
operator|(
name|ix86_fp_comparison_cost
argument_list|(
name|code
argument_list|)
operator|==
name|ix86_fp_comparison_fcomi_cost
argument_list|(
name|code
argument_list|)
operator|)
operator|||
operator|(
name|ix86_fp_comparison_cost
argument_list|(
name|swapped_code
argument_list|)
operator|==
name|ix86_fp_comparison_fcomi_cost
argument_list|(
name|swapped_code
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Swap, force into registers, or otherwise massage the two operands    to a fp comparison.  The operands are updated in place; the new    comparsion code is returned.  */
end_comment

begin_function
specifier|static
name|enum
name|rtx_code
name|ix86_prepare_fp_compare_args
parameter_list|(
name|code
parameter_list|,
name|pop0
parameter_list|,
name|pop1
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
name|rtx
modifier|*
name|pop0
decl_stmt|,
decl|*
name|pop1
decl_stmt|;
end_function

begin_block
block|{
name|enum
name|machine_mode
name|fpcmp_mode
init|=
name|ix86_fp_compare_mode
argument_list|(
name|code
argument_list|)
decl_stmt|;
name|rtx
name|op0
init|=
operator|*
name|pop0
decl_stmt|,
name|op1
init|=
operator|*
name|pop1
decl_stmt|;
name|enum
name|machine_mode
name|op_mode
init|=
name|GET_MODE
argument_list|(
name|op0
argument_list|)
decl_stmt|;
name|int
name|is_sse
init|=
name|SSE_REG_P
argument_list|(
name|op0
argument_list|)
operator||
name|SSE_REG_P
argument_list|(
name|op1
argument_list|)
decl_stmt|;
comment|/* All of the unordered compare instructions only work on registers.      The same is true of the XFmode compare instructions.  The same is      true of the fcomi compare instructions.  */
if|if
condition|(
operator|!
name|is_sse
operator|&&
operator|(
name|fpcmp_mode
operator|==
name|CCFPUmode
operator|||
name|op_mode
operator|==
name|XFmode
operator|||
name|op_mode
operator|==
name|TFmode
operator|||
name|ix86_use_fcomi_compare
argument_list|(
name|code
argument_list|)
operator|)
condition|)
block|{
name|op0
operator|=
name|force_reg
argument_list|(
name|op_mode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|force_reg
argument_list|(
name|op_mode
argument_list|,
name|op1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* %%% We only allow op1 in memory; op0 must be st(0).  So swap 	 things around if they appear profitable, otherwise force op0 	 into a register.  */
if|if
condition|(
name|standard_80387_constant_p
argument_list|(
name|op0
argument_list|)
operator|==
literal|0
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
operator|(
name|standard_80387_constant_p
argument_list|(
name|op1
argument_list|)
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|MEM
operator|)
operator|)
condition|)
block|{
name|rtx
name|tmp
decl_stmt|;
name|tmp
operator|=
name|op0
operator|,
name|op0
operator|=
name|op1
operator|,
name|op1
operator|=
name|tmp
expr_stmt|;
name|code
operator|=
name|swap_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|REG
condition|)
name|op0
operator|=
name|force_reg
argument_list|(
name|op_mode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op1
argument_list|)
condition|)
block|{
if|if
condition|(
name|standard_80387_constant_p
argument_list|(
name|op1
argument_list|)
condition|)
name|op1
operator|=
name|force_reg
argument_list|(
name|op_mode
argument_list|,
name|op1
argument_list|)
expr_stmt|;
else|else
name|op1
operator|=
name|validize_mem
argument_list|(
name|force_const_mem
argument_list|(
name|op_mode
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Try to rearrange the comparison to make it cheaper.  */
if|if
condition|(
name|ix86_fp_comparison_cost
argument_list|(
name|code
argument_list|)
operator|>
name|ix86_fp_comparison_cost
argument_list|(
name|swap_condition
argument_list|(
name|code
argument_list|)
argument_list|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|REG
operator|||
operator|!
name|reload_completed
operator|)
condition|)
block|{
name|rtx
name|tmp
decl_stmt|;
name|tmp
operator|=
name|op0
operator|,
name|op0
operator|=
name|op1
operator|,
name|op1
operator|=
name|tmp
expr_stmt|;
name|code
operator|=
name|swap_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|REG
condition|)
name|op0
operator|=
name|force_reg
argument_list|(
name|op_mode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
block|}
operator|*
name|pop0
operator|=
name|op0
expr_stmt|;
operator|*
name|pop1
operator|=
name|op1
expr_stmt|;
return|return
name|code
return|;
block|}
end_block

begin_comment
comment|/* Convert comparison codes we use to represent FP comparison to integer    code that will result in proper branch.  Return UNKNOWN if no such code    is available.  */
end_comment

begin_function
specifier|static
name|enum
name|rtx_code
name|ix86_fp_compare_code_to_integer
parameter_list|(
name|code
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|GT
case|:
return|return
name|GTU
return|;
case|case
name|GE
case|:
return|return
name|GEU
return|;
case|case
name|ORDERED
case|:
case|case
name|UNORDERED
case|:
return|return
name|code
return|;
break|break;
case|case
name|UNEQ
case|:
return|return
name|EQ
return|;
break|break;
case|case
name|UNLT
case|:
return|return
name|LTU
return|;
break|break;
case|case
name|UNLE
case|:
return|return
name|LEU
return|;
break|break;
case|case
name|LTGT
case|:
return|return
name|NE
return|;
break|break;
default|default:
return|return
name|UNKNOWN
return|;
block|}
block|}
end_function

begin_comment
comment|/* Split comparison code CODE into comparisons we can do using branch    instructions.  BYPASS_CODE is comparison code for branch that will    branch around FIRST_CODE and SECOND_CODE.  If some of branches    is not required, set value to NIL.    We never require more than two branches.  */
end_comment

begin_function
specifier|static
name|void
name|ix86_fp_comparison_codes
parameter_list|(
name|code
parameter_list|,
name|bypass_code
parameter_list|,
name|first_code
parameter_list|,
name|second_code
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|,
decl|*
name|bypass_code
decl_stmt|,
modifier|*
name|first_code
decl_stmt|,
modifier|*
name|second_code
decl_stmt|;
end_function

begin_block
block|{
operator|*
name|first_code
operator|=
name|code
expr_stmt|;
operator|*
name|bypass_code
operator|=
name|NIL
expr_stmt|;
operator|*
name|second_code
operator|=
name|NIL
expr_stmt|;
comment|/* The fcomi comparison sets flags as follows:       cmp    ZF PF CF>      0  0  0<      0  0  1      =      1  0  0      un     1  1  1 */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|GT
case|:
comment|/* GTU - CF=0& ZF=0 */
case|case
name|GE
case|:
comment|/* GEU - CF=0 */
case|case
name|ORDERED
case|:
comment|/* PF=0 */
case|case
name|UNORDERED
case|:
comment|/* PF=1 */
case|case
name|UNEQ
case|:
comment|/* EQ - ZF=1 */
case|case
name|UNLT
case|:
comment|/* LTU - CF=1 */
case|case
name|UNLE
case|:
comment|/* LEU - CF=1 | ZF=1 */
case|case
name|LTGT
case|:
comment|/* EQ - ZF=0 */
break|break;
case|case
name|LT
case|:
comment|/* LTU - CF=1 - fails on unordered */
operator|*
name|first_code
operator|=
name|UNLT
expr_stmt|;
operator|*
name|bypass_code
operator|=
name|UNORDERED
expr_stmt|;
break|break;
case|case
name|LE
case|:
comment|/* LEU - CF=1 | ZF=1 - fails on unordered */
operator|*
name|first_code
operator|=
name|UNLE
expr_stmt|;
operator|*
name|bypass_code
operator|=
name|UNORDERED
expr_stmt|;
break|break;
case|case
name|EQ
case|:
comment|/* EQ - ZF=1 - fails on unordered */
operator|*
name|first_code
operator|=
name|UNEQ
expr_stmt|;
operator|*
name|bypass_code
operator|=
name|UNORDERED
expr_stmt|;
break|break;
case|case
name|NE
case|:
comment|/* NE - ZF=0 - fails on unordered */
operator|*
name|first_code
operator|=
name|LTGT
expr_stmt|;
operator|*
name|second_code
operator|=
name|UNORDERED
expr_stmt|;
break|break;
case|case
name|UNGE
case|:
comment|/* GEU - CF=0 - fails on unordered */
operator|*
name|first_code
operator|=
name|GE
expr_stmt|;
operator|*
name|second_code
operator|=
name|UNORDERED
expr_stmt|;
break|break;
case|case
name|UNGT
case|:
comment|/* GTU - CF=0& ZF=0 - fails on unordered */
operator|*
name|first_code
operator|=
name|GT
expr_stmt|;
operator|*
name|second_code
operator|=
name|UNORDERED
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TARGET_IEEE_FP
condition|)
block|{
operator|*
name|second_code
operator|=
name|NIL
expr_stmt|;
operator|*
name|bypass_code
operator|=
name|NIL
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Return cost of comparison done fcom + arithmetics operations on AX.    All following functions do use number of instructions as an cost metrics.    In future this should be tweaked to compute bytes for optimize_size and    take into account performance of various instructions on various CPUs.  */
end_comment

begin_function
specifier|static
name|int
name|ix86_fp_comparison_arithmetics_cost
parameter_list|(
name|code
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|TARGET_IEEE_FP
condition|)
return|return
literal|4
return|;
comment|/* The cost of code output by ix86_expand_fp_compare.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|UNLE
case|:
case|case
name|UNLT
case|:
case|case
name|LTGT
case|:
case|case
name|GT
case|:
case|case
name|GE
case|:
case|case
name|UNORDERED
case|:
case|case
name|ORDERED
case|:
case|case
name|UNEQ
case|:
return|return
literal|4
return|;
break|break;
case|case
name|LT
case|:
case|case
name|NE
case|:
case|case
name|EQ
case|:
case|case
name|UNGE
case|:
return|return
literal|5
return|;
break|break;
case|case
name|LE
case|:
case|case
name|UNGT
case|:
return|return
literal|6
return|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return cost of comparison done using fcomi operation.    See ix86_fp_comparison_arithmetics_cost for the metrics.  */
end_comment

begin_function
specifier|static
name|int
name|ix86_fp_comparison_fcomi_cost
parameter_list|(
name|code
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
block|{
name|enum
name|rtx_code
name|bypass_code
decl_stmt|,
name|first_code
decl_stmt|,
name|second_code
decl_stmt|;
comment|/* Return arbitarily high cost when instruction is not supported - this      prevents gcc from using it.  */
if|if
condition|(
operator|!
name|TARGET_CMOVE
condition|)
return|return
literal|1024
return|;
name|ix86_fp_comparison_codes
argument_list|(
name|code
argument_list|,
operator|&
name|bypass_code
argument_list|,
operator|&
name|first_code
argument_list|,
operator|&
name|second_code
argument_list|)
expr_stmt|;
return|return
operator|(
name|bypass_code
operator|!=
name|NIL
operator|||
name|second_code
operator|!=
name|NIL
operator|)
operator|+
literal|2
return|;
block|}
end_function

begin_comment
comment|/* Return cost of comparison done using sahf operation.    See ix86_fp_comparison_arithmetics_cost for the metrics.  */
end_comment

begin_function
specifier|static
name|int
name|ix86_fp_comparison_sahf_cost
parameter_list|(
name|code
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
block|{
name|enum
name|rtx_code
name|bypass_code
decl_stmt|,
name|first_code
decl_stmt|,
name|second_code
decl_stmt|;
comment|/* Return arbitarily high cost when instruction is not preferred - this      avoids gcc from using it.  */
if|if
condition|(
operator|!
name|TARGET_USE_SAHF
operator|&&
operator|!
name|optimize_size
condition|)
return|return
literal|1024
return|;
name|ix86_fp_comparison_codes
argument_list|(
name|code
argument_list|,
operator|&
name|bypass_code
argument_list|,
operator|&
name|first_code
argument_list|,
operator|&
name|second_code
argument_list|)
expr_stmt|;
return|return
operator|(
name|bypass_code
operator|!=
name|NIL
operator|||
name|second_code
operator|!=
name|NIL
operator|)
operator|+
literal|3
return|;
block|}
end_function

begin_comment
comment|/* Compute cost of the comparison done using any method.    See ix86_fp_comparison_arithmetics_cost for the metrics.  */
end_comment

begin_function
specifier|static
name|int
name|ix86_fp_comparison_cost
parameter_list|(
name|code
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
block|{
name|int
name|fcomi_cost
decl_stmt|,
name|sahf_cost
decl_stmt|,
name|arithmetics_cost
init|=
literal|1024
decl_stmt|;
name|int
name|min
decl_stmt|;
name|fcomi_cost
operator|=
name|ix86_fp_comparison_fcomi_cost
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|sahf_cost
operator|=
name|ix86_fp_comparison_sahf_cost
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|min
operator|=
name|arithmetics_cost
operator|=
name|ix86_fp_comparison_arithmetics_cost
argument_list|(
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|min
operator|>
name|sahf_cost
condition|)
name|min
operator|=
name|sahf_cost
expr_stmt|;
if|if
condition|(
name|min
operator|>
name|fcomi_cost
condition|)
name|min
operator|=
name|fcomi_cost
expr_stmt|;
return|return
name|min
return|;
block|}
end_function

begin_comment
comment|/* Generate insn patterns to do a floating point compare of OPERANDS.  */
end_comment

begin_function
specifier|static
name|rtx
name|ix86_expand_fp_compare
parameter_list|(
name|code
parameter_list|,
name|op0
parameter_list|,
name|op1
parameter_list|,
name|scratch
parameter_list|,
name|second_test
parameter_list|,
name|bypass_test
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|,
name|scratch
decl_stmt|;
name|rtx
modifier|*
name|second_test
decl_stmt|;
name|rtx
modifier|*
name|bypass_test
decl_stmt|;
block|{
name|enum
name|machine_mode
name|fpcmp_mode
decl_stmt|,
name|intcmp_mode
decl_stmt|;
name|rtx
name|tmp
decl_stmt|,
name|tmp2
decl_stmt|;
name|int
name|cost
init|=
name|ix86_fp_comparison_cost
argument_list|(
name|code
argument_list|)
decl_stmt|;
name|enum
name|rtx_code
name|bypass_code
decl_stmt|,
name|first_code
decl_stmt|,
name|second_code
decl_stmt|;
name|fpcmp_mode
operator|=
name|ix86_fp_compare_mode
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|code
operator|=
name|ix86_prepare_fp_compare_args
argument_list|(
name|code
argument_list|,
operator|&
name|op0
argument_list|,
operator|&
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|second_test
condition|)
operator|*
name|second_test
operator|=
name|NULL_RTX
expr_stmt|;
if|if
condition|(
name|bypass_test
condition|)
operator|*
name|bypass_test
operator|=
name|NULL_RTX
expr_stmt|;
name|ix86_fp_comparison_codes
argument_list|(
name|code
argument_list|,
operator|&
name|bypass_code
argument_list|,
operator|&
name|first_code
argument_list|,
operator|&
name|second_code
argument_list|)
expr_stmt|;
comment|/* Do fcomi/sahf based test when profitable.  */
if|if
condition|(
operator|(
name|bypass_code
operator|==
name|NIL
operator|||
name|bypass_test
operator|)
operator|&&
operator|(
name|second_code
operator|==
name|NIL
operator|||
name|second_test
operator|)
operator|&&
name|ix86_fp_comparison_arithmetics_cost
argument_list|(
name|code
argument_list|)
operator|>
name|cost
condition|)
block|{
if|if
condition|(
name|TARGET_CMOVE
condition|)
block|{
name|tmp
operator|=
name|gen_rtx_COMPARE
argument_list|(
name|fpcmp_mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|fpcmp_mode
argument_list|,
name|FLAGS_REG
argument_list|)
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tmp
operator|=
name|gen_rtx_COMPARE
argument_list|(
name|fpcmp_mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|tmp2
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|HImode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|tmp
argument_list|)
argument_list|,
literal|9
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|scratch
condition|)
name|scratch
operator|=
name|gen_reg_rtx
argument_list|(
name|HImode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|scratch
argument_list|,
name|tmp2
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_x86_sahf_1
argument_list|(
name|scratch
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* The FP codes work out to act like unsigned.  */
name|intcmp_mode
operator|=
name|fpcmp_mode
expr_stmt|;
name|code
operator|=
name|first_code
expr_stmt|;
if|if
condition|(
name|bypass_code
operator|!=
name|NIL
condition|)
operator|*
name|bypass_test
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|bypass_code
argument_list|,
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|intcmp_mode
argument_list|,
name|FLAGS_REG
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|second_code
operator|!=
name|NIL
condition|)
operator|*
name|second_test
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|second_code
argument_list|,
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|intcmp_mode
argument_list|,
name|FLAGS_REG
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Sadness wrt reg-stack pops killing fpsr -- gotta get fnstsw first.  */
name|tmp
operator|=
name|gen_rtx_COMPARE
argument_list|(
name|fpcmp_mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|tmp2
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|HImode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|tmp
argument_list|)
argument_list|,
literal|9
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|scratch
condition|)
name|scratch
operator|=
name|gen_reg_rtx
argument_list|(
name|HImode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|scratch
argument_list|,
name|tmp2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* In the unordered case, we have to check C2 for NaN's, which 	 doesn't happen to work out to anything nice combination-wise. 	 So do some bit twiddling on the value we've got in AH to come 	 up with an appropriate set of condition codes.  */
name|intcmp_mode
operator|=
name|CCNOmode
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|GT
case|:
case|case
name|UNGT
case|:
if|if
condition|(
name|code
operator|==
name|GT
operator|||
operator|!
name|TARGET_IEEE_FP
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_testqi_ext_ccno_0
argument_list|(
name|scratch
argument_list|,
name|GEN_INT
argument_list|(
literal|0x45
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|=
name|EQ
expr_stmt|;
block|}
else|else
block|{
name|emit_insn
argument_list|(
name|gen_andqi_ext_0
argument_list|(
name|scratch
argument_list|,
name|scratch
argument_list|,
name|GEN_INT
argument_list|(
literal|0x45
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_addqi_ext_1
argument_list|(
name|scratch
argument_list|,
name|scratch
argument_list|,
name|constm1_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_cmpqi_ext_3
argument_list|(
name|scratch
argument_list|,
name|GEN_INT
argument_list|(
literal|0x44
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|intcmp_mode
operator|=
name|CCmode
expr_stmt|;
name|code
operator|=
name|GEU
expr_stmt|;
block|}
break|break;
case|case
name|LT
case|:
case|case
name|UNLT
case|:
if|if
condition|(
name|code
operator|==
name|LT
operator|&&
name|TARGET_IEEE_FP
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_andqi_ext_0
argument_list|(
name|scratch
argument_list|,
name|scratch
argument_list|,
name|GEN_INT
argument_list|(
literal|0x45
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_cmpqi_ext_3
argument_list|(
name|scratch
argument_list|,
name|GEN_INT
argument_list|(
literal|0x01
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|intcmp_mode
operator|=
name|CCmode
expr_stmt|;
name|code
operator|=
name|EQ
expr_stmt|;
block|}
else|else
block|{
name|emit_insn
argument_list|(
name|gen_testqi_ext_ccno_0
argument_list|(
name|scratch
argument_list|,
name|GEN_INT
argument_list|(
literal|0x01
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|=
name|NE
expr_stmt|;
block|}
break|break;
case|case
name|GE
case|:
case|case
name|UNGE
case|:
if|if
condition|(
name|code
operator|==
name|GE
operator|||
operator|!
name|TARGET_IEEE_FP
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_testqi_ext_ccno_0
argument_list|(
name|scratch
argument_list|,
name|GEN_INT
argument_list|(
literal|0x05
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|=
name|EQ
expr_stmt|;
block|}
else|else
block|{
name|emit_insn
argument_list|(
name|gen_andqi_ext_0
argument_list|(
name|scratch
argument_list|,
name|scratch
argument_list|,
name|GEN_INT
argument_list|(
literal|0x45
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_xorqi_cc_ext_1
argument_list|(
name|scratch
argument_list|,
name|scratch
argument_list|,
name|GEN_INT
argument_list|(
literal|0x01
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|=
name|NE
expr_stmt|;
block|}
break|break;
case|case
name|LE
case|:
case|case
name|UNLE
case|:
if|if
condition|(
name|code
operator|==
name|LE
operator|&&
name|TARGET_IEEE_FP
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_andqi_ext_0
argument_list|(
name|scratch
argument_list|,
name|scratch
argument_list|,
name|GEN_INT
argument_list|(
literal|0x45
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_addqi_ext_1
argument_list|(
name|scratch
argument_list|,
name|scratch
argument_list|,
name|constm1_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_cmpqi_ext_3
argument_list|(
name|scratch
argument_list|,
name|GEN_INT
argument_list|(
literal|0x40
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|intcmp_mode
operator|=
name|CCmode
expr_stmt|;
name|code
operator|=
name|LTU
expr_stmt|;
block|}
else|else
block|{
name|emit_insn
argument_list|(
name|gen_testqi_ext_ccno_0
argument_list|(
name|scratch
argument_list|,
name|GEN_INT
argument_list|(
literal|0x45
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|=
name|NE
expr_stmt|;
block|}
break|break;
case|case
name|EQ
case|:
case|case
name|UNEQ
case|:
if|if
condition|(
name|code
operator|==
name|EQ
operator|&&
name|TARGET_IEEE_FP
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_andqi_ext_0
argument_list|(
name|scratch
argument_list|,
name|scratch
argument_list|,
name|GEN_INT
argument_list|(
literal|0x45
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_cmpqi_ext_3
argument_list|(
name|scratch
argument_list|,
name|GEN_INT
argument_list|(
literal|0x40
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|intcmp_mode
operator|=
name|CCmode
expr_stmt|;
name|code
operator|=
name|EQ
expr_stmt|;
block|}
else|else
block|{
name|emit_insn
argument_list|(
name|gen_testqi_ext_ccno_0
argument_list|(
name|scratch
argument_list|,
name|GEN_INT
argument_list|(
literal|0x40
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|=
name|NE
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|NE
case|:
case|case
name|LTGT
case|:
if|if
condition|(
name|code
operator|==
name|NE
operator|&&
name|TARGET_IEEE_FP
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_andqi_ext_0
argument_list|(
name|scratch
argument_list|,
name|scratch
argument_list|,
name|GEN_INT
argument_list|(
literal|0x45
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_xorqi_cc_ext_1
argument_list|(
name|scratch
argument_list|,
name|scratch
argument_list|,
name|GEN_INT
argument_list|(
literal|0x40
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|=
name|NE
expr_stmt|;
block|}
else|else
block|{
name|emit_insn
argument_list|(
name|gen_testqi_ext_ccno_0
argument_list|(
name|scratch
argument_list|,
name|GEN_INT
argument_list|(
literal|0x40
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|=
name|EQ
expr_stmt|;
block|}
break|break;
case|case
name|UNORDERED
case|:
name|emit_insn
argument_list|(
name|gen_testqi_ext_ccno_0
argument_list|(
name|scratch
argument_list|,
name|GEN_INT
argument_list|(
literal|0x04
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|=
name|NE
expr_stmt|;
break|break;
case|case
name|ORDERED
case|:
name|emit_insn
argument_list|(
name|gen_testqi_ext_ccno_0
argument_list|(
name|scratch
argument_list|,
name|GEN_INT
argument_list|(
literal|0x04
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|=
name|EQ
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Return the test that should be put into the flags user, i.e.      the bcc, scc, or cmov instruction.  */
return|return
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|intcmp_mode
argument_list|,
name|FLAGS_REG
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
return|;
block|}
end_function

begin_function
name|rtx
name|ix86_expand_compare
parameter_list|(
name|code
parameter_list|,
name|second_test
parameter_list|,
name|bypass_test
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
name|rtx
modifier|*
name|second_test
decl_stmt|,
decl|*
name|bypass_test
decl_stmt|;
end_function

begin_block
block|{
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|,
name|ret
decl_stmt|;
name|op0
operator|=
name|ix86_compare_op0
expr_stmt|;
name|op1
operator|=
name|ix86_compare_op1
expr_stmt|;
if|if
condition|(
name|second_test
condition|)
operator|*
name|second_test
operator|=
name|NULL_RTX
expr_stmt|;
if|if
condition|(
name|bypass_test
condition|)
operator|*
name|bypass_test
operator|=
name|NULL_RTX
expr_stmt|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
name|ret
operator|=
name|ix86_expand_fp_compare
argument_list|(
name|code
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|NULL_RTX
argument_list|,
name|second_test
argument_list|,
name|bypass_test
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|ix86_expand_int_compare
argument_list|(
name|code
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_block

begin_comment
comment|/* Return true if the CODE will result in nontrivial jump sequence.  */
end_comment

begin_function
name|bool
name|ix86_fp_jump_nontrivial_p
parameter_list|(
name|code
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
block|{
name|enum
name|rtx_code
name|bypass_code
decl_stmt|,
name|first_code
decl_stmt|,
name|second_code
decl_stmt|;
if|if
condition|(
operator|!
name|TARGET_CMOVE
condition|)
return|return
name|true
return|;
name|ix86_fp_comparison_codes
argument_list|(
name|code
argument_list|,
operator|&
name|bypass_code
argument_list|,
operator|&
name|first_code
argument_list|,
operator|&
name|second_code
argument_list|)
expr_stmt|;
return|return
name|bypass_code
operator|!=
name|NIL
operator|||
name|second_code
operator|!=
name|NIL
return|;
block|}
end_function

begin_function
name|void
name|ix86_expand_branch
parameter_list|(
name|code
parameter_list|,
name|label
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
name|rtx
name|label
decl_stmt|;
block|{
name|rtx
name|tmp
decl_stmt|;
switch|switch
condition|(
name|GET_MODE
argument_list|(
name|ix86_compare_op0
argument_list|)
condition|)
block|{
case|case
name|QImode
case|:
case|case
name|HImode
case|:
case|case
name|SImode
case|:
name|simple
label|:
name|tmp
operator|=
name|ix86_expand_compare
argument_list|(
name|code
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|VOIDmode
argument_list|,
name|tmp
argument_list|,
name|gen_rtx_LABEL_REF
argument_list|(
name|VOIDmode
argument_list|,
name|label
argument_list|)
argument_list|,
name|pc_rtx
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|pc_rtx
argument_list|,
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|SFmode
case|:
case|case
name|DFmode
case|:
case|case
name|XFmode
case|:
case|case
name|TFmode
case|:
block|{
name|rtvec
name|vec
decl_stmt|;
name|int
name|use_fcomi
decl_stmt|;
name|enum
name|rtx_code
name|bypass_code
decl_stmt|,
name|first_code
decl_stmt|,
name|second_code
decl_stmt|;
name|code
operator|=
name|ix86_prepare_fp_compare_args
argument_list|(
name|code
argument_list|,
operator|&
name|ix86_compare_op0
argument_list|,
operator|&
name|ix86_compare_op1
argument_list|)
expr_stmt|;
name|ix86_fp_comparison_codes
argument_list|(
name|code
argument_list|,
operator|&
name|bypass_code
argument_list|,
operator|&
name|first_code
argument_list|,
operator|&
name|second_code
argument_list|)
expr_stmt|;
comment|/* Check whether we will use the natural sequence with one jump.  If 	   so, we can expand jump early.  Otherwise delay expansion by 	   creating compound insn to not confuse optimizers.  */
if|if
condition|(
name|bypass_code
operator|==
name|NIL
operator|&&
name|second_code
operator|==
name|NIL
operator|&&
name|TARGET_CMOVE
condition|)
block|{
name|ix86_split_fp_branch
argument_list|(
name|code
argument_list|,
name|ix86_compare_op0
argument_list|,
name|ix86_compare_op1
argument_list|,
name|gen_rtx_LABEL_REF
argument_list|(
name|VOIDmode
argument_list|,
name|label
argument_list|)
argument_list|,
name|pc_rtx
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tmp
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|VOIDmode
argument_list|,
name|ix86_compare_op0
argument_list|,
name|ix86_compare_op1
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|VOIDmode
argument_list|,
name|tmp
argument_list|,
name|gen_rtx_LABEL_REF
argument_list|(
name|VOIDmode
argument_list|,
name|label
argument_list|)
argument_list|,
name|pc_rtx
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|pc_rtx
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|use_fcomi
operator|=
name|ix86_use_fcomi_compare
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|vec
operator|=
name|rtvec_alloc
argument_list|(
literal|3
operator|+
operator|!
name|use_fcomi
argument_list|)
expr_stmt|;
name|RTVEC_ELT
argument_list|(
name|vec
argument_list|,
literal|0
argument_list|)
operator|=
name|tmp
expr_stmt|;
name|RTVEC_ELT
argument_list|(
name|vec
argument_list|,
literal|1
argument_list|)
operator|=
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|CCFPmode
argument_list|,
literal|18
argument_list|)
argument_list|)
expr_stmt|;
name|RTVEC_ELT
argument_list|(
name|vec
argument_list|,
literal|2
argument_list|)
operator|=
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|CCFPmode
argument_list|,
literal|17
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|use_fcomi
condition|)
name|RTVEC_ELT
argument_list|(
name|vec
argument_list|,
literal|3
argument_list|)
operator|=
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_SCRATCH
argument_list|(
name|HImode
argument_list|)
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|vec
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
case|case
name|DImode
case|:
if|if
condition|(
name|TARGET_64BIT
condition|)
goto|goto
name|simple
goto|;
comment|/* Expand DImode branch into multiple compare+branch.  */
block|{
name|rtx
name|lo
index|[
literal|2
index|]
decl_stmt|,
name|hi
index|[
literal|2
index|]
decl_stmt|,
name|label2
decl_stmt|;
name|enum
name|rtx_code
name|code1
decl_stmt|,
name|code2
decl_stmt|,
name|code3
decl_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|ix86_compare_op0
argument_list|)
operator|&&
operator|!
name|CONSTANT_P
argument_list|(
name|ix86_compare_op1
argument_list|)
condition|)
block|{
name|tmp
operator|=
name|ix86_compare_op0
expr_stmt|;
name|ix86_compare_op0
operator|=
name|ix86_compare_op1
expr_stmt|;
name|ix86_compare_op1
operator|=
name|tmp
expr_stmt|;
name|code
operator|=
name|swap_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
name|split_di
argument_list|(
operator|&
name|ix86_compare_op0
argument_list|,
literal|1
argument_list|,
name|lo
operator|+
literal|0
argument_list|,
name|hi
operator|+
literal|0
argument_list|)
expr_stmt|;
name|split_di
argument_list|(
operator|&
name|ix86_compare_op1
argument_list|,
literal|1
argument_list|,
name|lo
operator|+
literal|1
argument_list|,
name|hi
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* When comparing for equality, we can use (hi0^hi1)|(lo0^lo1) to 	   avoid two branches.  This costs one extra insn, so disable when 	   optimizing for size.  */
if|if
condition|(
operator|(
name|code
operator|==
name|EQ
operator|||
name|code
operator|==
name|NE
operator|)
operator|&&
operator|(
operator|!
name|optimize_size
operator|||
name|hi
index|[
literal|1
index|]
operator|==
name|const0_rtx
operator|||
name|lo
index|[
literal|1
index|]
operator|==
name|const0_rtx
operator|)
condition|)
block|{
name|rtx
name|xor0
decl_stmt|,
name|xor1
decl_stmt|;
name|xor1
operator|=
name|hi
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|hi
index|[
literal|1
index|]
operator|!=
name|const0_rtx
condition|)
name|xor1
operator|=
name|expand_binop
argument_list|(
name|SImode
argument_list|,
name|xor_optab
argument_list|,
name|xor1
argument_list|,
name|hi
index|[
literal|1
index|]
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
name|xor0
operator|=
name|lo
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|lo
index|[
literal|1
index|]
operator|!=
name|const0_rtx
condition|)
name|xor0
operator|=
name|expand_binop
argument_list|(
name|SImode
argument_list|,
name|xor_optab
argument_list|,
name|xor0
argument_list|,
name|lo
index|[
literal|1
index|]
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|expand_binop
argument_list|(
name|SImode
argument_list|,
name|ior_optab
argument_list|,
name|xor1
argument_list|,
name|xor0
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
name|ix86_compare_op0
operator|=
name|tmp
expr_stmt|;
name|ix86_compare_op1
operator|=
name|const0_rtx
expr_stmt|;
name|ix86_expand_branch
argument_list|(
name|code
argument_list|,
name|label
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Otherwise, if we are doing less-than or greater-or-equal-than, 	   op1 is a constant and the low word is zero, then we can just 	   examine the high word.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|hi
index|[
literal|1
index|]
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|lo
index|[
literal|1
index|]
operator|==
name|const0_rtx
condition|)
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LT
case|:
case|case
name|LTU
case|:
case|case
name|GE
case|:
case|case
name|GEU
case|:
name|ix86_compare_op0
operator|=
name|hi
index|[
literal|0
index|]
expr_stmt|;
name|ix86_compare_op1
operator|=
name|hi
index|[
literal|1
index|]
expr_stmt|;
name|ix86_expand_branch
argument_list|(
name|code
argument_list|,
name|label
argument_list|)
expr_stmt|;
return|return;
default|default:
break|break;
block|}
comment|/* Otherwise, we need two or three jumps.  */
name|label2
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|code1
operator|=
name|code
expr_stmt|;
name|code2
operator|=
name|swap_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|code3
operator|=
name|unsigned_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LT
case|:
case|case
name|GT
case|:
case|case
name|LTU
case|:
case|case
name|GTU
case|:
break|break;
case|case
name|LE
case|:
name|code1
operator|=
name|LT
expr_stmt|;
name|code2
operator|=
name|GT
expr_stmt|;
break|break;
case|case
name|GE
case|:
name|code1
operator|=
name|GT
expr_stmt|;
name|code2
operator|=
name|LT
expr_stmt|;
break|break;
case|case
name|LEU
case|:
name|code1
operator|=
name|LTU
expr_stmt|;
name|code2
operator|=
name|GTU
expr_stmt|;
break|break;
case|case
name|GEU
case|:
name|code1
operator|=
name|GTU
expr_stmt|;
name|code2
operator|=
name|LTU
expr_stmt|;
break|break;
case|case
name|EQ
case|:
name|code1
operator|=
name|NIL
expr_stmt|;
name|code2
operator|=
name|NE
expr_stmt|;
break|break;
case|case
name|NE
case|:
name|code2
operator|=
name|NIL
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* 	 * a< b => 	 *    if (hi(a)< hi(b)) goto true; 	 *    if (hi(a)> hi(b)) goto false; 	 *    if (lo(a)< lo(b)) goto true; 	 *  false: 	 */
name|ix86_compare_op0
operator|=
name|hi
index|[
literal|0
index|]
expr_stmt|;
name|ix86_compare_op1
operator|=
name|hi
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|code1
operator|!=
name|NIL
condition|)
name|ix86_expand_branch
argument_list|(
name|code1
argument_list|,
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
name|code2
operator|!=
name|NIL
condition|)
name|ix86_expand_branch
argument_list|(
name|code2
argument_list|,
name|label2
argument_list|)
expr_stmt|;
name|ix86_compare_op0
operator|=
name|lo
index|[
literal|0
index|]
expr_stmt|;
name|ix86_compare_op1
operator|=
name|lo
index|[
literal|1
index|]
expr_stmt|;
name|ix86_expand_branch
argument_list|(
name|code3
argument_list|,
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
name|code2
operator|!=
name|NIL
condition|)
name|emit_label
argument_list|(
name|label2
argument_list|)
expr_stmt|;
return|return;
block|}
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Split branch based on floating point condition.  */
end_comment

begin_function
name|void
name|ix86_split_fp_branch
parameter_list|(
name|code
parameter_list|,
name|op1
parameter_list|,
name|op2
parameter_list|,
name|target1
parameter_list|,
name|target2
parameter_list|,
name|tmp
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
name|rtx
name|op1
decl_stmt|,
name|op2
decl_stmt|,
name|target1
decl_stmt|,
name|target2
decl_stmt|,
name|tmp
decl_stmt|;
block|{
name|rtx
name|second
decl_stmt|,
name|bypass
decl_stmt|;
name|rtx
name|label
init|=
name|NULL_RTX
decl_stmt|;
name|rtx
name|condition
decl_stmt|;
name|int
name|bypass_probability
init|=
operator|-
literal|1
decl_stmt|,
name|second_probability
init|=
operator|-
literal|1
decl_stmt|,
name|probability
init|=
operator|-
literal|1
decl_stmt|;
name|rtx
name|i
decl_stmt|;
if|if
condition|(
name|target2
operator|!=
name|pc_rtx
condition|)
block|{
name|rtx
name|tmp
init|=
name|target2
decl_stmt|;
name|code
operator|=
name|reverse_condition_maybe_unordered
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|target2
operator|=
name|target1
expr_stmt|;
name|target1
operator|=
name|tmp
expr_stmt|;
block|}
name|condition
operator|=
name|ix86_expand_fp_compare
argument_list|(
name|code
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|,
name|tmp
argument_list|,
operator|&
name|second
argument_list|,
operator|&
name|bypass
argument_list|)
expr_stmt|;
if|if
condition|(
name|split_branch_probability
operator|>=
literal|0
condition|)
block|{
comment|/* Distribute the probabilities across the jumps. 	 Assume the BYPASS and SECOND to be always test 	 for UNORDERED.  */
name|probability
operator|=
name|split_branch_probability
expr_stmt|;
comment|/* Value of 1 is low enough to make no need for probability 	 to be updated.  Later we may run some experiments and see 	 if unordered values are more frequent in practice.  */
if|if
condition|(
name|bypass
condition|)
name|bypass_probability
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|second
condition|)
name|second_probability
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|bypass
operator|!=
name|NULL_RTX
condition|)
block|{
name|label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|i
operator|=
name|emit_jump_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|pc_rtx
argument_list|,
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|VOIDmode
argument_list|,
name|bypass
argument_list|,
name|gen_rtx_LABEL_REF
argument_list|(
name|VOIDmode
argument_list|,
name|label
argument_list|)
argument_list|,
name|pc_rtx
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bypass_probability
operator|>=
literal|0
condition|)
name|REG_NOTES
argument_list|(
name|i
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_BR_PROB
argument_list|,
name|GEN_INT
argument_list|(
name|bypass_probability
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
name|emit_jump_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|pc_rtx
argument_list|,
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|VOIDmode
argument_list|,
name|condition
argument_list|,
name|target1
argument_list|,
name|target2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|probability
operator|>=
literal|0
condition|)
name|REG_NOTES
argument_list|(
name|i
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_BR_PROB
argument_list|,
name|GEN_INT
argument_list|(
name|probability
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|second
operator|!=
name|NULL_RTX
condition|)
block|{
name|i
operator|=
name|emit_jump_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|pc_rtx
argument_list|,
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|VOIDmode
argument_list|,
name|second
argument_list|,
name|target1
argument_list|,
name|target2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|second_probability
operator|>=
literal|0
condition|)
name|REG_NOTES
argument_list|(
name|i
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_BR_PROB
argument_list|,
name|GEN_INT
argument_list|(
name|second_probability
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|label
operator|!=
name|NULL_RTX
condition|)
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ix86_expand_setcc
parameter_list|(
name|code
parameter_list|,
name|dest
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
name|rtx
name|dest
decl_stmt|;
block|{
name|rtx
name|ret
decl_stmt|,
name|tmp
decl_stmt|,
name|tmpreg
decl_stmt|;
name|rtx
name|second_test
decl_stmt|,
name|bypass_test
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|ix86_compare_op0
argument_list|)
operator|==
name|DImode
operator|&&
operator|!
name|TARGET_64BIT
condition|)
return|return
literal|0
return|;
comment|/* FAIL */
if|if
condition|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
operator|!=
name|QImode
condition|)
name|abort
argument_list|()
expr_stmt|;
name|ret
operator|=
name|ix86_expand_compare
argument_list|(
name|code
argument_list|,
operator|&
name|second_test
argument_list|,
operator|&
name|bypass_test
argument_list|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|ret
argument_list|,
name|QImode
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|dest
expr_stmt|;
name|tmpreg
operator|=
name|dest
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|tmp
argument_list|,
name|ret
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bypass_test
operator|||
name|second_test
condition|)
block|{
name|rtx
name|test
init|=
name|second_test
decl_stmt|;
name|int
name|bypass
init|=
literal|0
decl_stmt|;
name|rtx
name|tmp2
init|=
name|gen_reg_rtx
argument_list|(
name|QImode
argument_list|)
decl_stmt|;
if|if
condition|(
name|bypass_test
condition|)
block|{
if|if
condition|(
name|second_test
condition|)
name|abort
argument_list|()
expr_stmt|;
name|test
operator|=
name|bypass_test
expr_stmt|;
name|bypass
operator|=
literal|1
expr_stmt|;
name|PUT_CODE
argument_list|(
name|test
argument_list|,
name|reverse_condition_maybe_unordered
argument_list|(
name|GET_CODE
argument_list|(
name|test
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|PUT_MODE
argument_list|(
name|test
argument_list|,
name|QImode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|tmp2
argument_list|,
name|test
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bypass
condition|)
name|emit_insn
argument_list|(
name|gen_andqi3
argument_list|(
name|tmp
argument_list|,
name|tmpreg
argument_list|,
name|tmp2
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_iorqi3
argument_list|(
name|tmp
argument_list|,
name|tmpreg
argument_list|,
name|tmp2
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
comment|/* DONE */
block|}
end_function

begin_function
name|int
name|ix86_expand_int_movcc
parameter_list|(
name|operands
parameter_list|)
name|rtx
name|operands
index|[]
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
decl_stmt|,
name|compare_code
decl_stmt|;
name|rtx
name|compare_seq
decl_stmt|,
name|compare_op
decl_stmt|;
name|rtx
name|second_test
decl_stmt|,
name|bypass_test
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
comment|/* When the compare code is not LTU or GEU, we can not use sbbl case.      In case comparsion is done with immediate, we can convert it to LTU or      GEU by altering the integer.  */
if|if
condition|(
operator|(
name|code
operator|==
name|LEU
operator|||
name|code
operator|==
name|GTU
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|ix86_compare_op1
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|mode
operator|!=
name|HImode
operator|&&
operator|(
name|unsigned
name|int
operator|)
name|INTVAL
argument_list|(
name|ix86_compare_op1
argument_list|)
operator|!=
literal|0xffffffff
operator|&&
name|GET_CODE
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|operands
index|[
literal|3
index|]
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|LEU
condition|)
name|code
operator|=
name|LTU
expr_stmt|;
else|else
name|code
operator|=
name|GEU
expr_stmt|;
name|ix86_compare_op1
operator|=
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|ix86_compare_op1
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|start_sequence
argument_list|()
expr_stmt|;
name|compare_op
operator|=
name|ix86_expand_compare
argument_list|(
name|code
argument_list|,
operator|&
name|second_test
argument_list|,
operator|&
name|bypass_test
argument_list|)
expr_stmt|;
name|compare_seq
operator|=
name|gen_sequence
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|compare_code
operator|=
name|GET_CODE
argument_list|(
name|compare_op
argument_list|)
expr_stmt|;
comment|/* Don't attempt mode expansion here -- if we had to expand 5 or 6      HImode insns, we'd be swallowed in word prefix ops.  */
if|if
condition|(
name|mode
operator|!=
name|HImode
operator|&&
operator|(
name|mode
operator|!=
name|DImode
operator|||
name|TARGET_64BIT
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|operands
index|[
literal|3
index|]
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|rtx
name|out
init|=
name|operands
index|[
literal|0
index|]
decl_stmt|;
name|HOST_WIDE_INT
name|ct
init|=
name|INTVAL
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|cf
init|=
name|INTVAL
argument_list|(
name|operands
index|[
literal|3
index|]
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|diff
decl_stmt|;
if|if
condition|(
operator|(
name|compare_code
operator|==
name|LTU
operator|||
name|compare_code
operator|==
name|GEU
operator|)
operator|&&
operator|!
name|second_test
operator|&&
operator|!
name|bypass_test
condition|)
block|{
comment|/* Detect overlap between destination and compare sources.  */
name|rtx
name|tmp
init|=
name|out
decl_stmt|;
comment|/* To simplify rest of code, restrict to the GEU case.  */
if|if
condition|(
name|compare_code
operator|==
name|LTU
condition|)
block|{
name|int
name|tmp
init|=
name|ct
decl_stmt|;
name|ct
operator|=
name|cf
expr_stmt|;
name|cf
operator|=
name|tmp
expr_stmt|;
name|compare_code
operator|=
name|reverse_condition
argument_list|(
name|compare_code
argument_list|)
expr_stmt|;
name|code
operator|=
name|reverse_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
name|diff
operator|=
name|ct
operator|-
name|cf
expr_stmt|;
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|out
argument_list|,
name|ix86_compare_op0
argument_list|)
operator|||
name|reg_overlap_mentioned_p
argument_list|(
name|out
argument_list|,
name|ix86_compare_op1
argument_list|)
condition|)
name|tmp
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|compare_seq
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|DImode
condition|)
name|emit_insn
argument_list|(
name|gen_x86_movdicc_0_m1_rex64
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_x86_movsicc_0_m1
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|diff
operator|==
literal|1
condition|)
block|{
comment|/* 	       * cmpl op0,op1 	       * sbbl dest,dest 	       * [addl dest, ct] 	       * 	       * Size 5 - 8. 	       */
if|if
condition|(
name|ct
condition|)
name|tmp
operator|=
name|expand_simple_binop
argument_list|(
name|mode
argument_list|,
name|PLUS
argument_list|,
name|tmp
argument_list|,
name|GEN_INT
argument_list|(
name|ct
argument_list|)
argument_list|,
name|tmp
argument_list|,
literal|1
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cf
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* 	       * cmpl op0,op1 	       * sbbl dest,dest 	       * orl $ct, dest 	       * 	       * Size 8. 	       */
name|tmp
operator|=
name|expand_simple_binop
argument_list|(
name|mode
argument_list|,
name|IOR
argument_list|,
name|tmp
argument_list|,
name|GEN_INT
argument_list|(
name|ct
argument_list|)
argument_list|,
name|tmp
argument_list|,
literal|1
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|diff
operator|==
operator|-
literal|1
operator|&&
name|ct
condition|)
block|{
comment|/* 	       * cmpl op0,op1 	       * sbbl dest,dest 	       * xorl $-1, dest 	       * [addl dest, cf] 	       * 	       * Size 8 - 11. 	       */
name|tmp
operator|=
name|expand_simple_unop
argument_list|(
name|mode
argument_list|,
name|NOT
argument_list|,
name|tmp
argument_list|,
name|tmp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cf
condition|)
name|tmp
operator|=
name|expand_simple_binop
argument_list|(
name|mode
argument_list|,
name|PLUS
argument_list|,
name|tmp
argument_list|,
name|GEN_INT
argument_list|(
name|cf
argument_list|)
argument_list|,
name|tmp
argument_list|,
literal|1
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 	       * cmpl op0,op1 	       * sbbl dest,dest 	       * andl cf - ct, dest 	       * [addl dest, ct] 	       * 	       * Size 8 - 11. 	       */
name|tmp
operator|=
name|expand_simple_binop
argument_list|(
name|mode
argument_list|,
name|AND
argument_list|,
name|tmp
argument_list|,
name|GEN_INT
argument_list|(
name|trunc_int_for_mode
argument_list|(
name|cf
operator|-
name|ct
argument_list|,
name|mode
argument_list|)
argument_list|)
argument_list|,
name|tmp
argument_list|,
literal|1
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ct
condition|)
name|tmp
operator|=
name|expand_simple_binop
argument_list|(
name|mode
argument_list|,
name|PLUS
argument_list|,
name|tmp
argument_list|,
name|GEN_INT
argument_list|(
name|ct
argument_list|)
argument_list|,
name|tmp
argument_list|,
literal|1
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tmp
operator|!=
name|out
condition|)
name|emit_move_insn
argument_list|(
name|out
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
comment|/* DONE */
block|}
name|diff
operator|=
name|ct
operator|-
name|cf
expr_stmt|;
if|if
condition|(
name|diff
operator|<
literal|0
condition|)
block|{
name|HOST_WIDE_INT
name|tmp
decl_stmt|;
name|tmp
operator|=
name|ct
operator|,
name|ct
operator|=
name|cf
operator|,
name|cf
operator|=
name|tmp
expr_stmt|;
name|diff
operator|=
operator|-
name|diff
expr_stmt|;
if|if
condition|(
name|FLOAT_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|ix86_compare_op0
argument_list|)
argument_list|)
condition|)
block|{
comment|/* We may be reversing unordered compare to normal compare, that 		 is not valid in general (we may convert non-trapping condition 		 to trapping one), however on i386 we currently emit all 		 comparisons unordered.  */
name|compare_code
operator|=
name|reverse_condition_maybe_unordered
argument_list|(
name|compare_code
argument_list|)
expr_stmt|;
name|code
operator|=
name|reverse_condition_maybe_unordered
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|compare_code
operator|=
name|reverse_condition
argument_list|(
name|compare_code
argument_list|)
expr_stmt|;
name|code
operator|=
name|reverse_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|diff
operator|==
literal|1
operator|||
name|diff
operator|==
literal|2
operator|||
name|diff
operator|==
literal|4
operator|||
name|diff
operator|==
literal|8
operator|||
name|diff
operator|==
literal|3
operator|||
name|diff
operator|==
literal|5
operator|||
name|diff
operator|==
literal|9
operator|)
operator|&&
operator|(
name|mode
operator|!=
name|DImode
operator|||
name|x86_64_sign_extended_value
argument_list|(
name|GEN_INT
argument_list|(
name|cf
argument_list|)
argument_list|)
operator|)
condition|)
block|{
comment|/* 	   * xorl dest,dest 	   * cmpl op1,op2 	   * setcc dest 	   * lea cf(dest*(ct-cf)),dest 	   * 	   * Size 14. 	   * 	   * This also catches the degenerate setcc-only case. 	   */
name|rtx
name|tmp
decl_stmt|;
name|int
name|nops
decl_stmt|;
name|out
operator|=
name|emit_store_flag
argument_list|(
name|out
argument_list|,
name|code
argument_list|,
name|ix86_compare_op0
argument_list|,
name|ix86_compare_op1
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|nops
operator|=
literal|0
expr_stmt|;
comment|/* On x86_64 the lea instruction operates on Pmode, so we need to get arithmetics 	     done in proper mode to match.  */
if|if
condition|(
name|diff
operator|==
literal|1
condition|)
name|tmp
operator|=
name|out
expr_stmt|;
else|else
block|{
name|rtx
name|out1
decl_stmt|;
name|out1
operator|=
name|out
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_MULT
argument_list|(
name|mode
argument_list|,
name|out1
argument_list|,
name|GEN_INT
argument_list|(
name|diff
operator|&
operator|~
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|nops
operator|++
expr_stmt|;
if|if
condition|(
name|diff
operator|&
literal|1
condition|)
block|{
name|tmp
operator|=
name|gen_rtx_PLUS
argument_list|(
name|mode
argument_list|,
name|tmp
argument_list|,
name|out1
argument_list|)
expr_stmt|;
name|nops
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cf
operator|!=
literal|0
condition|)
block|{
name|tmp
operator|=
name|gen_rtx_PLUS
argument_list|(
name|mode
argument_list|,
name|tmp
argument_list|,
name|GEN_INT
argument_list|(
name|cf
argument_list|)
argument_list|)
expr_stmt|;
name|nops
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|tmp
operator|!=
name|out
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|!=
name|SUBREG
operator|||
name|SUBREG_REG
argument_list|(
name|tmp
argument_list|)
operator|!=
name|out
operator|)
condition|)
block|{
if|if
condition|(
name|nops
operator|==
literal|1
condition|)
block|{
name|rtx
name|clob
decl_stmt|;
name|clob
operator|=
name|gen_rtx_REG
argument_list|(
name|CCmode
argument_list|,
name|FLAGS_REG
argument_list|)
expr_stmt|;
name|clob
operator|=
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|clob
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|out
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|tmp
argument_list|,
name|clob
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
else|else
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|out
argument_list|,
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|out
operator|!=
name|operands
index|[
literal|0
index|]
condition|)
name|emit_move_insn
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|out
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
comment|/* DONE */
block|}
comment|/*        * General case:			Jumpful:        *   xorl dest,dest		cmpl op1, op2        *   cmpl op1, op2		movl ct, dest        *   setcc dest			jcc 1f        *   decl dest			movl cf, dest        *   andl (cf-ct),dest		1:        *   addl ct,dest        *        * Size 20.			Size 14.        *        * This is reasonably steep, but branch mispredict costs are        * high on modern cpus, so consider failing only if optimizing        * for space.        *        * %%% Parameterize branch_cost on the tuning architecture, then        * use that.  The 80386 couldn't care less about mispredicts.        */
if|if
condition|(
operator|!
name|optimize_size
operator|&&
operator|!
name|TARGET_CMOVE
condition|)
block|{
if|if
condition|(
name|ct
operator|==
literal|0
condition|)
block|{
name|ct
operator|=
name|cf
expr_stmt|;
name|cf
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|FLOAT_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|ix86_compare_op0
argument_list|)
argument_list|)
condition|)
block|{
comment|/* We may be reversing unordered compare to normal compare, 		     that is not valid in general (we may convert non-trapping 		     condition to trapping one), however on i386 we currently 		     emit all comparisons unordered.  */
name|compare_code
operator|=
name|reverse_condition_maybe_unordered
argument_list|(
name|compare_code
argument_list|)
expr_stmt|;
name|code
operator|=
name|reverse_condition_maybe_unordered
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|compare_code
operator|=
name|reverse_condition
argument_list|(
name|compare_code
argument_list|)
expr_stmt|;
name|code
operator|=
name|reverse_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
block|}
name|out
operator|=
name|emit_store_flag
argument_list|(
name|out
argument_list|,
name|code
argument_list|,
name|ix86_compare_op0
argument_list|,
name|ix86_compare_op1
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|out
operator|=
name|expand_simple_binop
argument_list|(
name|mode
argument_list|,
name|PLUS
argument_list|,
name|out
argument_list|,
name|constm1_rtx
argument_list|,
name|out
argument_list|,
literal|1
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
name|out
operator|=
name|expand_simple_binop
argument_list|(
name|mode
argument_list|,
name|AND
argument_list|,
name|out
argument_list|,
name|GEN_INT
argument_list|(
name|trunc_int_for_mode
argument_list|(
name|cf
operator|-
name|ct
argument_list|,
name|mode
argument_list|)
argument_list|)
argument_list|,
name|out
argument_list|,
literal|1
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
name|out
operator|=
name|expand_simple_binop
argument_list|(
name|mode
argument_list|,
name|PLUS
argument_list|,
name|out
argument_list|,
name|GEN_INT
argument_list|(
name|ct
argument_list|)
argument_list|,
name|out
argument_list|,
literal|1
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
operator|!=
name|operands
index|[
literal|0
index|]
condition|)
name|emit_move_insn
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|out
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
comment|/* DONE */
block|}
block|}
if|if
condition|(
operator|!
name|TARGET_CMOVE
condition|)
block|{
comment|/* Try a few things more with specific constants and a variable.  */
name|optab
name|op
decl_stmt|;
name|rtx
name|var
decl_stmt|,
name|orig_out
decl_stmt|,
name|out
decl_stmt|,
name|tmp
decl_stmt|;
if|if
condition|(
name|optimize_size
condition|)
return|return
literal|0
return|;
comment|/* FAIL */
comment|/* If one of the two operands is an interesting constant, load a 	 constant with the above and mask it in with a logical operation.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|var
operator|=
name|operands
index|[
literal|3
index|]
expr_stmt|;
if|if
condition|(
name|INTVAL
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|==
literal|0
condition|)
name|operands
index|[
literal|3
index|]
operator|=
name|constm1_rtx
operator|,
name|op
operator|=
name|and_optab
expr_stmt|;
elseif|else
if|if
condition|(
name|INTVAL
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|operands
index|[
literal|3
index|]
operator|=
name|const0_rtx
operator|,
name|op
operator|=
name|ior_optab
expr_stmt|;
else|else
return|return
literal|0
return|;
comment|/* FAIL */
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|3
index|]
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|var
operator|=
name|operands
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|INTVAL
argument_list|(
name|operands
index|[
literal|3
index|]
argument_list|)
operator|==
literal|0
condition|)
name|operands
index|[
literal|2
index|]
operator|=
name|constm1_rtx
operator|,
name|op
operator|=
name|and_optab
expr_stmt|;
elseif|else
if|if
condition|(
name|INTVAL
argument_list|(
name|operands
index|[
literal|3
index|]
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|operands
index|[
literal|2
index|]
operator|=
name|const0_rtx
operator|,
name|op
operator|=
name|ior_optab
expr_stmt|;
else|else
return|return
literal|0
return|;
comment|/* FAIL */
block|}
else|else
return|return
literal|0
return|;
comment|/* FAIL */
name|orig_out
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
name|tmp
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|operands
index|[
literal|0
index|]
operator|=
name|tmp
expr_stmt|;
comment|/* Recurse to get the constant loaded.  */
if|if
condition|(
name|ix86_expand_int_movcc
argument_list|(
name|operands
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* FAIL */
comment|/* Mask in the interesting variable.  */
name|out
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|op
argument_list|,
name|var
argument_list|,
name|tmp
argument_list|,
name|orig_out
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
operator|!=
name|orig_out
condition|)
name|emit_move_insn
argument_list|(
name|orig_out
argument_list|,
name|out
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
comment|/* DONE */
block|}
comment|/*    * For comparison with above,    *    * movl cf,dest    * movl ct,tmp    * cmpl op1,op2    * cmovcc tmp,dest    *    * Size 15.    */
if|if
condition|(
operator|!
name|nonimmediate_operand
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|,
name|mode
argument_list|)
condition|)
name|operands
index|[
literal|2
index|]
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nonimmediate_operand
argument_list|(
name|operands
index|[
literal|3
index|]
argument_list|,
name|mode
argument_list|)
condition|)
name|operands
index|[
literal|3
index|]
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|operands
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|bypass_test
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
name|rtx
name|tmp
init|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|tmp
argument_list|,
name|operands
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|operands
index|[
literal|3
index|]
operator|=
name|tmp
expr_stmt|;
block|}
if|if
condition|(
name|second_test
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
name|rtx
name|tmp
init|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|tmp
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|operands
index|[
literal|2
index|]
operator|=
name|tmp
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|register_operand
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|,
name|VOIDmode
argument_list|)
operator|&&
operator|!
name|register_operand
argument_list|(
name|operands
index|[
literal|3
index|]
argument_list|,
name|VOIDmode
argument_list|)
condition|)
name|operands
index|[
literal|2
index|]
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|compare_seq
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|mode
argument_list|,
name|compare_op
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|,
name|operands
index|[
literal|3
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bypass_test
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|mode
argument_list|,
name|bypass_test
argument_list|,
name|operands
index|[
literal|3
index|]
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|second_test
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|mode
argument_list|,
name|second_test
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
comment|/* DONE */
block|}
end_function

begin_function
name|int
name|ix86_expand_fp_movcc
parameter_list|(
name|operands
parameter_list|)
name|rtx
name|operands
index|[]
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
decl_stmt|;
name|rtx
name|tmp
decl_stmt|;
name|rtx
name|compare_op
decl_stmt|,
name|second_test
decl_stmt|,
name|bypass_test
decl_stmt|;
comment|/* For SF/DFmode conditional moves based on comparisons      in same mode, we may want to use SSE min/max instructions.  */
if|if
condition|(
operator|(
operator|(
name|TARGET_SSE_MATH
operator|&&
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|SFmode
operator|)
operator|||
operator|(
name|TARGET_SSE2
operator|&&
name|TARGET_SSE_MATH
operator|&&
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|DFmode
operator|)
operator|)
operator|&&
name|GET_MODE
argument_list|(
name|ix86_compare_op0
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
comment|/* The SSE comparisons does not support the LTGT/UNEQ pair.  */
operator|&&
operator|(
operator|!
name|TARGET_IEEE_FP
operator|||
operator|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|!=
name|LTGT
operator|&&
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|!=
name|UNEQ
operator|)
operator|)
comment|/* We may be called from the post-reload splitter.  */
operator|&&
operator|(
operator|!
name|REG_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|||
name|SSE_REG_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|||
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
condition|)
block|{
name|rtx
name|op0
init|=
name|ix86_compare_op0
decl_stmt|,
name|op1
init|=
name|ix86_compare_op1
decl_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* See if we have (cross) match between comparison operands and          conditional move operands.  */
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|,
name|op1
argument_list|)
condition|)
block|{
name|rtx
name|tmp
init|=
name|op0
decl_stmt|;
name|op0
operator|=
name|op1
expr_stmt|;
name|op1
operator|=
name|tmp
expr_stmt|;
name|code
operator|=
name|reverse_condition_maybe_unordered
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|,
name|op0
argument_list|)
operator|&&
name|rtx_equal_p
argument_list|(
name|operands
index|[
literal|3
index|]
argument_list|,
name|op1
argument_list|)
condition|)
block|{
comment|/* Check for min operation.  */
if|if
condition|(
name|code
operator|==
name|LT
condition|)
block|{
name|operands
index|[
literal|0
index|]
operator|=
name|force_reg
argument_list|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|memory_operand
argument_list|(
name|op0
argument_list|,
name|VOIDmode
argument_list|)
condition|)
name|op0
operator|=
name|force_reg
argument_list|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|SFmode
condition|)
name|emit_insn
argument_list|(
name|gen_minsf3
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_mindf3
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Check for max operation.  */
if|if
condition|(
name|code
operator|==
name|GT
condition|)
block|{
name|operands
index|[
literal|0
index|]
operator|=
name|force_reg
argument_list|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|memory_operand
argument_list|(
name|op0
argument_list|,
name|VOIDmode
argument_list|)
condition|)
name|op0
operator|=
name|force_reg
argument_list|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|SFmode
condition|)
name|emit_insn
argument_list|(
name|gen_maxsf3
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_maxdf3
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
comment|/* Manage condition to be sse_comparison_operator.  In case we are 	 in non-ieee mode, try to canonicalize the destination operand 	 to be first in the comparison - this helps reload to avoid extra 	 moves.  */
if|if
condition|(
operator|!
name|sse_comparison_operator
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|VOIDmode
argument_list|)
operator|||
operator|(
name|rtx_equal_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|ix86_compare_op1
argument_list|)
operator|&&
operator|!
name|TARGET_IEEE_FP
operator|)
condition|)
block|{
name|rtx
name|tmp
init|=
name|ix86_compare_op0
decl_stmt|;
name|ix86_compare_op0
operator|=
name|ix86_compare_op1
expr_stmt|;
name|ix86_compare_op1
operator|=
name|tmp
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|swap_condition
argument_list|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
argument_list|,
name|VOIDmode
argument_list|,
name|ix86_compare_op0
argument_list|,
name|ix86_compare_op1
argument_list|)
expr_stmt|;
block|}
comment|/* Similary try to manage result to be first operand of conditional 	 move. We also don't support the NE comparison on SSE, so try to 	 avoid it.  */
if|if
condition|(
operator|(
name|rtx_equal_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|3
index|]
argument_list|)
operator|&&
operator|(
operator|!
name|TARGET_IEEE_FP
operator|||
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|!=
name|EQ
operator|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|NE
operator|&&
name|TARGET_IEEE_FP
operator|)
condition|)
block|{
name|rtx
name|tmp
init|=
name|operands
index|[
literal|2
index|]
decl_stmt|;
name|operands
index|[
literal|2
index|]
operator|=
name|operands
index|[
literal|3
index|]
expr_stmt|;
name|operands
index|[
literal|3
index|]
operator|=
name|tmp
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|reverse_condition_maybe_unordered
argument_list|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
argument_list|,
name|VOIDmode
argument_list|,
name|ix86_compare_op0
argument_list|,
name|ix86_compare_op1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|SFmode
condition|)
name|emit_insn
argument_list|(
name|gen_sse_movsfcc
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|,
name|operands
index|[
literal|3
index|]
argument_list|,
name|ix86_compare_op0
argument_list|,
name|ix86_compare_op1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_sse_movdfcc
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|,
name|operands
index|[
literal|3
index|]
argument_list|,
name|ix86_compare_op0
argument_list|,
name|ix86_compare_op1
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* The floating point conditional move instructions don't directly      support conditions resulting from a signed integer comparison.  */
name|code
operator|=
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|compare_op
operator|=
name|ix86_expand_compare
argument_list|(
name|code
argument_list|,
operator|&
name|second_test
argument_list|,
operator|&
name|bypass_test
argument_list|)
expr_stmt|;
comment|/* The floating point conditional move instructions don't directly      support signed integer comparisons.  */
if|if
condition|(
operator|!
name|fcmov_comparison_operator
argument_list|(
name|compare_op
argument_list|,
name|VOIDmode
argument_list|)
condition|)
block|{
if|if
condition|(
name|second_test
operator|!=
name|NULL
operator|||
name|bypass_test
operator|!=
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|tmp
operator|=
name|gen_reg_rtx
argument_list|(
name|QImode
argument_list|)
expr_stmt|;
name|ix86_expand_setcc
argument_list|(
name|code
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|code
operator|=
name|NE
expr_stmt|;
name|ix86_compare_op0
operator|=
name|tmp
expr_stmt|;
name|ix86_compare_op1
operator|=
name|const0_rtx
expr_stmt|;
name|compare_op
operator|=
name|ix86_expand_compare
argument_list|(
name|code
argument_list|,
operator|&
name|second_test
argument_list|,
operator|&
name|bypass_test
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bypass_test
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
name|tmp
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|tmp
argument_list|,
name|operands
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|operands
index|[
literal|3
index|]
operator|=
name|tmp
expr_stmt|;
block|}
if|if
condition|(
name|second_test
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
name|tmp
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|tmp
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|operands
index|[
literal|2
index|]
operator|=
name|tmp
expr_stmt|;
block|}
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|compare_op
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|,
name|operands
index|[
literal|3
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bypass_test
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|bypass_test
argument_list|,
name|operands
index|[
literal|3
index|]
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|second_test
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|second_test
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Split operands 0 and 1 into SImode parts.  Similar to split_di, but    works for floating pointer parameters and nonoffsetable memories.    For pushes, it returns just stack offsets; the values will be saved    in the right order.  Maximally three parts are generated.  */
end_comment

begin_function
specifier|static
name|int
name|ix86_split_to_parts
parameter_list|(
name|operand
parameter_list|,
name|parts
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|operand
decl_stmt|;
name|rtx
modifier|*
name|parts
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|int
name|size
decl_stmt|;
if|if
condition|(
operator|!
name|TARGET_64BIT
condition|)
name|size
operator|=
name|mode
operator|==
name|TFmode
condition|?
literal|3
else|:
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|/
literal|4
operator|)
expr_stmt|;
else|else
name|size
operator|=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|+
literal|4
operator|)
operator|/
literal|8
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|REG
operator|&&
name|MMX_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|operand
argument_list|)
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|2
operator|||
name|size
operator|>
literal|3
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Optimize constant pool reference to immediates.  This is used by fp moves,      that force all constants to memory to allow combining.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|operand
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|operand
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|operand
operator|=
name|get_pool_constant
argument_list|(
name|XEXP
argument_list|(
name|operand
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|offsettable_memref_p
argument_list|(
name|operand
argument_list|)
condition|)
block|{
comment|/* The only non-offsetable memories we handle are pushes.  */
if|if
condition|(
operator|!
name|push_operand
argument_list|(
name|operand
argument_list|,
name|VOIDmode
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|operand
operator|=
name|copy_rtx
argument_list|(
name|operand
argument_list|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|operand
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
name|parts
index|[
literal|0
index|]
operator|=
name|parts
index|[
literal|1
index|]
operator|=
name|parts
index|[
literal|2
index|]
operator|=
name|operand
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|TARGET_64BIT
condition|)
block|{
if|if
condition|(
name|mode
operator|==
name|DImode
condition|)
name|split_di
argument_list|(
operator|&
name|operand
argument_list|,
literal|1
argument_list|,
operator|&
name|parts
index|[
literal|0
index|]
argument_list|,
operator|&
name|parts
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|REG_P
argument_list|(
name|operand
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|reload_completed
condition|)
name|abort
argument_list|()
expr_stmt|;
name|parts
index|[
literal|0
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|operand
argument_list|)
operator|+
literal|0
argument_list|)
expr_stmt|;
name|parts
index|[
literal|1
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|operand
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|3
condition|)
name|parts
index|[
literal|2
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|operand
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|offsettable_memref_p
argument_list|(
name|operand
argument_list|)
condition|)
block|{
name|operand
operator|=
name|adjust_address
argument_list|(
name|operand
argument_list|,
name|SImode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|parts
index|[
literal|0
index|]
operator|=
name|operand
expr_stmt|;
name|parts
index|[
literal|1
index|]
operator|=
name|adjust_address
argument_list|(
name|operand
argument_list|,
name|SImode
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|3
condition|)
name|parts
index|[
literal|2
index|]
operator|=
name|adjust_address
argument_list|(
name|operand
argument_list|,
name|SImode
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|long
name|l
index|[
literal|4
index|]
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|r
argument_list|,
name|operand
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|XFmode
case|:
case|case
name|TFmode
case|:
name|REAL_VALUE_TO_TARGET_LONG_DOUBLE
argument_list|(
name|r
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|parts
index|[
literal|2
index|]
operator|=
name|GEN_INT
argument_list|(
name|trunc_int_for_mode
argument_list|(
name|l
index|[
literal|2
index|]
argument_list|,
name|SImode
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DFmode
case|:
name|REAL_VALUE_TO_TARGET_DOUBLE
argument_list|(
name|r
argument_list|,
name|l
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|parts
index|[
literal|1
index|]
operator|=
name|GEN_INT
argument_list|(
name|trunc_int_for_mode
argument_list|(
name|l
index|[
literal|1
index|]
argument_list|,
name|SImode
argument_list|)
argument_list|)
expr_stmt|;
name|parts
index|[
literal|0
index|]
operator|=
name|GEN_INT
argument_list|(
name|trunc_int_for_mode
argument_list|(
name|l
index|[
literal|0
index|]
argument_list|,
name|SImode
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|mode
operator|==
name|TImode
condition|)
name|split_ti
argument_list|(
operator|&
name|operand
argument_list|,
literal|1
argument_list|,
operator|&
name|parts
index|[
literal|0
index|]
argument_list|,
operator|&
name|parts
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|XFmode
operator|||
name|mode
operator|==
name|TFmode
condition|)
block|{
if|if
condition|(
name|REG_P
argument_list|(
name|operand
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|reload_completed
condition|)
name|abort
argument_list|()
expr_stmt|;
name|parts
index|[
literal|0
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|REGNO
argument_list|(
name|operand
argument_list|)
operator|+
literal|0
argument_list|)
expr_stmt|;
name|parts
index|[
literal|1
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|operand
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|offsettable_memref_p
argument_list|(
name|operand
argument_list|)
condition|)
block|{
name|operand
operator|=
name|adjust_address
argument_list|(
name|operand
argument_list|,
name|DImode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|parts
index|[
literal|0
index|]
operator|=
name|operand
expr_stmt|;
name|parts
index|[
literal|1
index|]
operator|=
name|adjust_address
argument_list|(
name|operand
argument_list|,
name|SImode
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|long
name|l
index|[
literal|3
index|]
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|r
argument_list|,
name|operand
argument_list|)
expr_stmt|;
name|REAL_VALUE_TO_TARGET_LONG_DOUBLE
argument_list|(
name|r
argument_list|,
name|l
argument_list|)
expr_stmt|;
comment|/* Do not use shift by 32 to avoid warning on 32bit systems.  */
if|if
condition|(
name|HOST_BITS_PER_WIDE_INT
operator|>=
literal|64
condition|)
name|parts
index|[
literal|0
index|]
operator|=
name|GEN_INT
argument_list|(
name|trunc_int_for_mode
argument_list|(
operator|(
name|l
index|[
literal|0
index|]
operator|&
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|2
operator|<<
literal|31
operator|)
operator|-
literal|1
operator|)
operator|)
operator|+
operator|(
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
name|l
index|[
literal|1
index|]
operator|)
operator|<<
literal|31
operator|)
operator|<<
literal|1
operator|)
argument_list|,
name|DImode
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|parts
index|[
literal|0
index|]
operator|=
name|immed_double_const
argument_list|(
name|l
index|[
literal|0
index|]
argument_list|,
name|l
index|[
literal|1
index|]
argument_list|,
name|DImode
argument_list|)
expr_stmt|;
name|parts
index|[
literal|1
index|]
operator|=
name|GEN_INT
argument_list|(
name|trunc_int_for_mode
argument_list|(
name|l
index|[
literal|2
index|]
argument_list|,
name|SImode
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|size
return|;
block|}
end_function

begin_comment
comment|/* Emit insns to perform a move or push of DI, DF, and XF values.    Return false when normal moves are needed; true when all required    insns have been emitted.  Operands 2-4 contain the input values    int the correct order; operands 5-7 contain the output values.  */
end_comment

begin_function
name|void
name|ix86_split_long_move
parameter_list|(
name|operands
parameter_list|)
name|rtx
name|operands
index|[]
decl_stmt|;
block|{
name|rtx
name|part
index|[
literal|2
index|]
index|[
literal|3
index|]
decl_stmt|;
name|int
name|nparts
decl_stmt|;
name|int
name|push
init|=
literal|0
decl_stmt|;
name|int
name|collisions
init|=
literal|0
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
comment|/* The DFmode expanders may ask us to move double.      For 64bit target this is single move.  By hiding the fact      here we simplify i386.md splitters.  */
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator|==
literal|8
operator|&&
name|TARGET_64BIT
condition|)
block|{
comment|/* Optimize constant pool reference to immediates.  This is used by 	 fp moves, that force all constants to memory to allow combining.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|operands
index|[
literal|1
index|]
operator|=
name|get_pool_constant
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|push_operand
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|VOIDmode
argument_list|)
condition|)
block|{
name|operands
index|[
literal|0
index|]
operator|=
name|copy_rtx
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
block|}
else|else
name|operands
index|[
literal|0
index|]
operator|=
name|gen_lowpart
argument_list|(
name|DImode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|gen_lowpart
argument_list|(
name|DImode
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* The only non-offsettable memory we handle is push.  */
if|if
condition|(
name|push_operand
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|VOIDmode
argument_list|)
condition|)
name|push
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|offsettable_memref_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|nparts
operator|=
name|ix86_split_to_parts
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|part
index|[
literal|1
index|]
argument_list|,
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ix86_split_to_parts
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|part
index|[
literal|0
index|]
argument_list|,
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* When emitting push, take care for source operands on the stack.  */
if|if
condition|(
name|push
operator|&&
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|MEM
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|nparts
operator|==
literal|3
condition|)
name|part
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|change_address
argument_list|(
name|part
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|,
name|GET_MODE
argument_list|(
name|part
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|part
index|[
literal|1
index|]
index|[
literal|2
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|part
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|change_address
argument_list|(
name|part
index|[
literal|1
index|]
index|[
literal|0
index|]
argument_list|,
name|GET_MODE
argument_list|(
name|part
index|[
literal|1
index|]
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|part
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* We need to do copy in the right order in case an address register      of the source overlaps the destination.  */
if|if
condition|(
name|REG_P
argument_list|(
name|part
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|part
index|[
literal|1
index|]
index|[
literal|0
index|]
argument_list|)
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|part
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|,
name|XEXP
argument_list|(
name|part
index|[
literal|1
index|]
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|collisions
operator|++
expr_stmt|;
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|part
index|[
literal|0
index|]
index|[
literal|1
index|]
argument_list|,
name|XEXP
argument_list|(
name|part
index|[
literal|1
index|]
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|collisions
operator|++
expr_stmt|;
if|if
condition|(
name|nparts
operator|==
literal|3
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|part
index|[
literal|0
index|]
index|[
literal|2
index|]
argument_list|,
name|XEXP
argument_list|(
name|part
index|[
literal|1
index|]
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|collisions
operator|++
expr_stmt|;
comment|/* Collision in the middle part can be handled by reordering.  */
if|if
condition|(
name|collisions
operator|==
literal|1
operator|&&
name|nparts
operator|==
literal|3
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|part
index|[
literal|0
index|]
index|[
literal|1
index|]
argument_list|,
name|XEXP
argument_list|(
name|part
index|[
literal|1
index|]
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|tmp
decl_stmt|;
name|tmp
operator|=
name|part
index|[
literal|0
index|]
index|[
literal|1
index|]
expr_stmt|;
name|part
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
name|part
index|[
literal|0
index|]
index|[
literal|2
index|]
expr_stmt|;
name|part
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|=
name|tmp
expr_stmt|;
name|tmp
operator|=
name|part
index|[
literal|1
index|]
index|[
literal|1
index|]
expr_stmt|;
name|part
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|part
index|[
literal|1
index|]
index|[
literal|2
index|]
expr_stmt|;
name|part
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|=
name|tmp
expr_stmt|;
block|}
comment|/* If there are more collisions, we can't handle it by reordering. 	 Do an lea to the last part and use only one colliding move.  */
elseif|else
if|if
condition|(
name|collisions
operator|>
literal|1
condition|)
block|{
name|collisions
operator|=
literal|1
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|part
index|[
literal|0
index|]
index|[
name|nparts
operator|-
literal|1
index|]
argument_list|,
name|XEXP
argument_list|(
name|part
index|[
literal|1
index|]
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|part
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|change_address
argument_list|(
name|part
index|[
literal|1
index|]
index|[
literal|0
index|]
argument_list|,
name|TARGET_64BIT
condition|?
name|DImode
else|:
name|SImode
argument_list|,
name|part
index|[
literal|0
index|]
index|[
name|nparts
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|part
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|adjust_address
argument_list|(
name|part
index|[
literal|1
index|]
index|[
literal|0
index|]
argument_list|,
name|VOIDmode
argument_list|,
name|UNITS_PER_WORD
argument_list|)
expr_stmt|;
if|if
condition|(
name|nparts
operator|==
literal|3
condition|)
name|part
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|=
name|adjust_address
argument_list|(
name|part
index|[
literal|1
index|]
index|[
literal|0
index|]
argument_list|,
name|VOIDmode
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|push
condition|)
block|{
if|if
condition|(
operator|!
name|TARGET_64BIT
condition|)
block|{
if|if
condition|(
name|nparts
operator|==
literal|3
condition|)
block|{
comment|/* We use only first 12 bytes of TFmode value, but for pushing we 		 are required to adjust stack as if we were pushing real 16byte 		 value.  */
if|if
condition|(
name|mode
operator|==
name|TFmode
operator|&&
operator|!
name|TARGET_64BIT
condition|)
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
operator|-
literal|4
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|part
index|[
literal|0
index|]
index|[
literal|2
index|]
argument_list|,
name|part
index|[
literal|1
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* In 64bit mode we don't have 32bit push available.  In case this is 	     register, it is OK - we will just use larger counterpart.  We also 	     retype memory - these comes from attempt to avoid REX prefix on 	     moving of second half of TFmode value.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|part
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|)
operator|==
name|SImode
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|part
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|)
operator|==
name|MEM
condition|)
name|part
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|adjust_address
argument_list|(
name|part
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|,
name|DImode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|REG_P
argument_list|(
name|part
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|)
condition|)
name|part
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|REGNO
argument_list|(
name|part
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|part
index|[
literal|1
index|]
index|[
literal|0
index|]
argument_list|)
operator|==
name|SImode
condition|)
name|part
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|part
index|[
literal|1
index|]
index|[
literal|1
index|]
expr_stmt|;
block|}
block|}
name|emit_move_insn
argument_list|(
name|part
index|[
literal|0
index|]
index|[
literal|1
index|]
argument_list|,
name|part
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|part
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|,
name|part
index|[
literal|1
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Choose correct order to not overwrite the source before it is copied.  */
if|if
condition|(
operator|(
name|REG_P
argument_list|(
name|part
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|)
operator|&&
name|REG_P
argument_list|(
name|part
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|)
operator|&&
operator|(
name|REGNO
argument_list|(
name|part
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|)
operator|==
name|REGNO
argument_list|(
name|part
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|)
operator|||
operator|(
name|nparts
operator|==
literal|3
operator|&&
name|REGNO
argument_list|(
name|part
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|)
operator|==
name|REGNO
argument_list|(
name|part
index|[
literal|1
index|]
index|[
literal|2
index|]
argument_list|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|collisions
operator|>
literal|0
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|part
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|,
name|XEXP
argument_list|(
name|part
index|[
literal|1
index|]
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|nparts
operator|==
literal|3
condition|)
block|{
name|operands
index|[
literal|2
index|]
operator|=
name|part
index|[
literal|0
index|]
index|[
literal|2
index|]
expr_stmt|;
name|operands
index|[
literal|3
index|]
operator|=
name|part
index|[
literal|0
index|]
index|[
literal|1
index|]
expr_stmt|;
name|operands
index|[
literal|4
index|]
operator|=
name|part
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
name|operands
index|[
literal|5
index|]
operator|=
name|part
index|[
literal|1
index|]
index|[
literal|2
index|]
expr_stmt|;
name|operands
index|[
literal|6
index|]
operator|=
name|part
index|[
literal|1
index|]
index|[
literal|1
index|]
expr_stmt|;
name|operands
index|[
literal|7
index|]
operator|=
name|part
index|[
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
block|{
name|operands
index|[
literal|2
index|]
operator|=
name|part
index|[
literal|0
index|]
index|[
literal|1
index|]
expr_stmt|;
name|operands
index|[
literal|3
index|]
operator|=
name|part
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
name|operands
index|[
literal|5
index|]
operator|=
name|part
index|[
literal|1
index|]
index|[
literal|1
index|]
expr_stmt|;
name|operands
index|[
literal|6
index|]
operator|=
name|part
index|[
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|nparts
operator|==
literal|3
condition|)
block|{
name|operands
index|[
literal|2
index|]
operator|=
name|part
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
name|operands
index|[
literal|3
index|]
operator|=
name|part
index|[
literal|0
index|]
index|[
literal|1
index|]
expr_stmt|;
name|operands
index|[
literal|4
index|]
operator|=
name|part
index|[
literal|0
index|]
index|[
literal|2
index|]
expr_stmt|;
name|operands
index|[
literal|5
index|]
operator|=
name|part
index|[
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
name|operands
index|[
literal|6
index|]
operator|=
name|part
index|[
literal|1
index|]
index|[
literal|1
index|]
expr_stmt|;
name|operands
index|[
literal|7
index|]
operator|=
name|part
index|[
literal|1
index|]
index|[
literal|2
index|]
expr_stmt|;
block|}
else|else
block|{
name|operands
index|[
literal|2
index|]
operator|=
name|part
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
name|operands
index|[
literal|3
index|]
operator|=
name|part
index|[
literal|0
index|]
index|[
literal|1
index|]
expr_stmt|;
name|operands
index|[
literal|5
index|]
operator|=
name|part
index|[
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
name|operands
index|[
literal|6
index|]
operator|=
name|part
index|[
literal|1
index|]
index|[
literal|1
index|]
expr_stmt|;
block|}
block|}
name|emit_move_insn
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|,
name|operands
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|operands
index|[
literal|3
index|]
argument_list|,
name|operands
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|nparts
operator|==
literal|3
condition|)
name|emit_move_insn
argument_list|(
name|operands
index|[
literal|4
index|]
argument_list|,
name|operands
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|ix86_split_ashldi
parameter_list|(
name|operands
parameter_list|,
name|scratch
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|,
name|scratch
decl_stmt|;
block|{
name|rtx
name|low
index|[
literal|2
index|]
decl_stmt|,
name|high
index|[
literal|2
index|]
decl_stmt|;
name|int
name|count
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|split_di
argument_list|(
name|operands
argument_list|,
literal|2
argument_list|,
name|low
argument_list|,
name|high
argument_list|)
expr_stmt|;
name|count
operator|=
name|INTVAL
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|&
literal|63
expr_stmt|;
if|if
condition|(
name|count
operator|>=
literal|32
condition|)
block|{
name|emit_move_insn
argument_list|(
name|high
index|[
literal|0
index|]
argument_list|,
name|low
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|low
index|[
literal|0
index|]
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|32
condition|)
name|emit_insn
argument_list|(
name|gen_ashlsi3
argument_list|(
name|high
index|[
literal|0
index|]
argument_list|,
name|high
index|[
literal|0
index|]
argument_list|,
name|GEN_INT
argument_list|(
name|count
operator|-
literal|32
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
name|emit_move_insn
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_x86_shld_1
argument_list|(
name|high
index|[
literal|0
index|]
argument_list|,
name|low
index|[
literal|0
index|]
argument_list|,
name|GEN_INT
argument_list|(
name|count
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_ashlsi3
argument_list|(
name|low
index|[
literal|0
index|]
argument_list|,
name|low
index|[
literal|0
index|]
argument_list|,
name|GEN_INT
argument_list|(
name|count
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
name|emit_move_insn
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|split_di
argument_list|(
name|operands
argument_list|,
literal|1
argument_list|,
name|low
argument_list|,
name|high
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_x86_shld_1
argument_list|(
name|high
index|[
literal|0
index|]
argument_list|,
name|low
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_ashlsi3
argument_list|(
name|low
index|[
literal|0
index|]
argument_list|,
name|low
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_CMOVE
operator|&&
operator|(
operator|!
name|no_new_pseudos
operator|||
name|scratch
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|no_new_pseudos
condition|)
name|scratch
operator|=
name|force_reg
argument_list|(
name|SImode
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
else|else
name|emit_move_insn
argument_list|(
name|scratch
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_x86_shift_adj_1
argument_list|(
name|high
index|[
literal|0
index|]
argument_list|,
name|low
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|,
name|scratch
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|emit_insn
argument_list|(
name|gen_x86_shift_adj_2
argument_list|(
name|high
index|[
literal|0
index|]
argument_list|,
name|low
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ix86_split_ashrdi
parameter_list|(
name|operands
parameter_list|,
name|scratch
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|,
name|scratch
decl_stmt|;
block|{
name|rtx
name|low
index|[
literal|2
index|]
decl_stmt|,
name|high
index|[
literal|2
index|]
decl_stmt|;
name|int
name|count
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|split_di
argument_list|(
name|operands
argument_list|,
literal|2
argument_list|,
name|low
argument_list|,
name|high
argument_list|)
expr_stmt|;
name|count
operator|=
name|INTVAL
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|&
literal|63
expr_stmt|;
if|if
condition|(
name|count
operator|>=
literal|32
condition|)
block|{
name|emit_move_insn
argument_list|(
name|low
index|[
literal|0
index|]
argument_list|,
name|high
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reload_completed
condition|)
name|emit_insn
argument_list|(
name|gen_ashrsi3
argument_list|(
name|high
index|[
literal|0
index|]
argument_list|,
name|low
index|[
literal|0
index|]
argument_list|,
name|GEN_INT
argument_list|(
literal|31
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|emit_move_insn
argument_list|(
name|high
index|[
literal|0
index|]
argument_list|,
name|low
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_ashrsi3
argument_list|(
name|high
index|[
literal|0
index|]
argument_list|,
name|high
index|[
literal|0
index|]
argument_list|,
name|GEN_INT
argument_list|(
literal|31
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|>
literal|32
condition|)
name|emit_insn
argument_list|(
name|gen_ashrsi3
argument_list|(
name|low
index|[
literal|0
index|]
argument_list|,
name|low
index|[
literal|0
index|]
argument_list|,
name|GEN_INT
argument_list|(
name|count
operator|-
literal|32
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
name|emit_move_insn
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_x86_shrd_1
argument_list|(
name|low
index|[
literal|0
index|]
argument_list|,
name|high
index|[
literal|0
index|]
argument_list|,
name|GEN_INT
argument_list|(
name|count
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_ashrsi3
argument_list|(
name|high
index|[
literal|0
index|]
argument_list|,
name|high
index|[
literal|0
index|]
argument_list|,
name|GEN_INT
argument_list|(
name|count
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
name|emit_move_insn
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|split_di
argument_list|(
name|operands
argument_list|,
literal|1
argument_list|,
name|low
argument_list|,
name|high
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_x86_shrd_1
argument_list|(
name|low
index|[
literal|0
index|]
argument_list|,
name|high
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_ashrsi3
argument_list|(
name|high
index|[
literal|0
index|]
argument_list|,
name|high
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_CMOVE
operator|&&
operator|(
operator|!
name|no_new_pseudos
operator|||
name|scratch
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|no_new_pseudos
condition|)
name|scratch
operator|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|scratch
argument_list|,
name|high
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_ashrsi3
argument_list|(
name|scratch
argument_list|,
name|scratch
argument_list|,
name|GEN_INT
argument_list|(
literal|31
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_x86_shift_adj_1
argument_list|(
name|low
index|[
literal|0
index|]
argument_list|,
name|high
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|,
name|scratch
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|emit_insn
argument_list|(
name|gen_x86_shift_adj_3
argument_list|(
name|low
index|[
literal|0
index|]
argument_list|,
name|high
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ix86_split_lshrdi
parameter_list|(
name|operands
parameter_list|,
name|scratch
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|,
name|scratch
decl_stmt|;
block|{
name|rtx
name|low
index|[
literal|2
index|]
decl_stmt|,
name|high
index|[
literal|2
index|]
decl_stmt|;
name|int
name|count
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|split_di
argument_list|(
name|operands
argument_list|,
literal|2
argument_list|,
name|low
argument_list|,
name|high
argument_list|)
expr_stmt|;
name|count
operator|=
name|INTVAL
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|&
literal|63
expr_stmt|;
if|if
condition|(
name|count
operator|>=
literal|32
condition|)
block|{
name|emit_move_insn
argument_list|(
name|low
index|[
literal|0
index|]
argument_list|,
name|high
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|high
index|[
literal|0
index|]
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|32
condition|)
name|emit_insn
argument_list|(
name|gen_lshrsi3
argument_list|(
name|low
index|[
literal|0
index|]
argument_list|,
name|low
index|[
literal|0
index|]
argument_list|,
name|GEN_INT
argument_list|(
name|count
operator|-
literal|32
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
name|emit_move_insn
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_x86_shrd_1
argument_list|(
name|low
index|[
literal|0
index|]
argument_list|,
name|high
index|[
literal|0
index|]
argument_list|,
name|GEN_INT
argument_list|(
name|count
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_lshrsi3
argument_list|(
name|high
index|[
literal|0
index|]
argument_list|,
name|high
index|[
literal|0
index|]
argument_list|,
name|GEN_INT
argument_list|(
name|count
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
name|emit_move_insn
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|split_di
argument_list|(
name|operands
argument_list|,
literal|1
argument_list|,
name|low
argument_list|,
name|high
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_x86_shrd_1
argument_list|(
name|low
index|[
literal|0
index|]
argument_list|,
name|high
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_lshrsi3
argument_list|(
name|high
index|[
literal|0
index|]
argument_list|,
name|high
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Heh.  By reversing the arguments, we can reuse this pattern.  */
if|if
condition|(
name|TARGET_CMOVE
operator|&&
operator|(
operator|!
name|no_new_pseudos
operator|||
name|scratch
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|no_new_pseudos
condition|)
name|scratch
operator|=
name|force_reg
argument_list|(
name|SImode
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
else|else
name|emit_move_insn
argument_list|(
name|scratch
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_x86_shift_adj_1
argument_list|(
name|low
index|[
literal|0
index|]
argument_list|,
name|high
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|,
name|scratch
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|emit_insn
argument_list|(
name|gen_x86_shift_adj_2
argument_list|(
name|low
index|[
literal|0
index|]
argument_list|,
name|high
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Helper function for the string operations below.  Dest VARIABLE whether    it is aligned to VALUE bytes.  If true, jump to the label.  */
end_comment

begin_function
specifier|static
name|rtx
name|ix86_expand_aligntest
parameter_list|(
name|variable
parameter_list|,
name|value
parameter_list|)
name|rtx
name|variable
decl_stmt|;
name|int
name|value
decl_stmt|;
block|{
name|rtx
name|label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|rtx
name|tmpcount
init|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|variable
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|variable
argument_list|)
operator|==
name|DImode
condition|)
name|emit_insn
argument_list|(
name|gen_anddi3
argument_list|(
name|tmpcount
argument_list|,
name|variable
argument_list|,
name|GEN_INT
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_andsi3
argument_list|(
name|tmpcount
argument_list|,
name|variable
argument_list|,
name|GEN_INT
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|tmpcount
argument_list|,
name|const0_rtx
argument_list|,
name|EQ
argument_list|,
literal|0
argument_list|,
name|GET_MODE
argument_list|(
name|variable
argument_list|)
argument_list|,
literal|1
argument_list|,
name|label
argument_list|)
expr_stmt|;
return|return
name|label
return|;
block|}
end_function

begin_comment
comment|/* Adjust COUNTER by the VALUE.  */
end_comment

begin_function
specifier|static
name|void
name|ix86_adjust_counter
parameter_list|(
name|countreg
parameter_list|,
name|value
parameter_list|)
name|rtx
name|countreg
decl_stmt|;
name|HOST_WIDE_INT
name|value
decl_stmt|;
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|countreg
argument_list|)
operator|==
name|DImode
condition|)
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|countreg
argument_list|,
name|countreg
argument_list|,
name|GEN_INT
argument_list|(
operator|-
name|value
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|countreg
argument_list|,
name|countreg
argument_list|,
name|GEN_INT
argument_list|(
operator|-
name|value
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Zero extend possibly SImode EXP to Pmode register.  */
end_comment

begin_function
name|rtx
name|ix86_zero_extend_to_Pmode
parameter_list|(
name|exp
parameter_list|)
name|rtx
name|exp
decl_stmt|;
block|{
name|rtx
name|r
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|exp
argument_list|)
operator|==
name|VOIDmode
condition|)
return|return
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|exp
argument_list|)
return|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|exp
argument_list|)
operator|==
name|Pmode
condition|)
return|return
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|exp
argument_list|)
return|;
name|r
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_zero_extendsidi2
argument_list|(
name|r
argument_list|,
name|exp
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Expand string move (memcpy) operation.  Use i386 string operations when    profitable.  expand_clrstr contains similar code.  */
end_comment

begin_function
name|int
name|ix86_expand_movstr
parameter_list|(
name|dst
parameter_list|,
name|src
parameter_list|,
name|count_exp
parameter_list|,
name|align_exp
parameter_list|)
name|rtx
name|dst
decl_stmt|,
name|src
decl_stmt|,
name|count_exp
decl_stmt|,
name|align_exp
decl_stmt|;
block|{
name|rtx
name|srcreg
decl_stmt|,
name|destreg
decl_stmt|,
name|countreg
decl_stmt|;
name|enum
name|machine_mode
name|counter_mode
decl_stmt|;
name|HOST_WIDE_INT
name|align
init|=
literal|0
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|count
init|=
literal|0
decl_stmt|;
name|rtx
name|insns
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|align_exp
argument_list|)
operator|==
name|CONST_INT
condition|)
name|align
operator|=
name|INTVAL
argument_list|(
name|align_exp
argument_list|)
expr_stmt|;
comment|/* This simple hack avoids all inlining code and simplifies code below.  */
if|if
condition|(
operator|!
name|TARGET_ALIGN_STRINGOPS
condition|)
name|align
operator|=
literal|64
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|count_exp
argument_list|)
operator|==
name|CONST_INT
condition|)
name|count
operator|=
name|INTVAL
argument_list|(
name|count_exp
argument_list|)
expr_stmt|;
comment|/* Figure out proper mode for counter.  For 32bits it is always SImode,      for 64bits use SImode when possible, otherwise DImode.      Set count to number of bytes copied when known at compile time.  */
if|if
condition|(
operator|!
name|TARGET_64BIT
operator|||
name|GET_MODE
argument_list|(
name|count_exp
argument_list|)
operator|==
name|SImode
operator|||
name|x86_64_zero_extended_value
argument_list|(
name|count_exp
argument_list|)
condition|)
name|counter_mode
operator|=
name|SImode
expr_stmt|;
else|else
name|counter_mode
operator|=
name|DImode
expr_stmt|;
if|if
condition|(
name|counter_mode
operator|!=
name|SImode
operator|&&
name|counter_mode
operator|!=
name|DImode
condition|)
name|abort
argument_list|()
expr_stmt|;
name|destreg
operator|=
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|srcreg
operator|=
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_cld
argument_list|()
argument_list|)
expr_stmt|;
comment|/* When optimizing for size emit simple rep ; movsb instruction for      counts not divisible by 4.  */
if|if
condition|(
operator|(
operator|!
name|optimize
operator|||
name|optimize_size
operator|)
operator|&&
operator|(
name|count
operator|==
literal|0
operator|||
operator|(
name|count
operator|&
literal|0x03
operator|)
operator|)
condition|)
block|{
name|countreg
operator|=
name|ix86_zero_extend_to_Pmode
argument_list|(
name|count_exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
name|emit_insn
argument_list|(
name|gen_rep_movqi_rex64
argument_list|(
name|destreg
argument_list|,
name|srcreg
argument_list|,
name|countreg
argument_list|,
name|destreg
argument_list|,
name|srcreg
argument_list|,
name|countreg
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_rep_movqi
argument_list|(
name|destreg
argument_list|,
name|srcreg
argument_list|,
name|countreg
argument_list|,
name|destreg
argument_list|,
name|srcreg
argument_list|,
name|countreg
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* For constant aligned (or small unaligned) copies use rep movsl      followed by code copying the rest.  For PentiumPro ensure 8 byte      alignment to allow rep movsl acceleration.  */
elseif|else
if|if
condition|(
name|count
operator|!=
literal|0
operator|&&
operator|(
name|align
operator|>=
literal|8
operator|||
operator|(
operator|!
name|TARGET_PENTIUMPRO
operator|&&
operator|!
name|TARGET_64BIT
operator|&&
name|align
operator|>=
literal|4
operator|)
operator|||
name|optimize_size
operator|||
name|count
operator|<
operator|(
name|unsigned
name|int
operator|)
literal|64
operator|)
condition|)
block|{
name|int
name|size
init|=
name|TARGET_64BIT
operator|&&
operator|!
name|optimize_size
condition|?
literal|8
else|:
literal|4
decl_stmt|;
if|if
condition|(
name|count
operator|&
operator|~
operator|(
name|size
operator|-
literal|1
operator|)
condition|)
block|{
name|countreg
operator|=
name|copy_to_mode_reg
argument_list|(
name|counter_mode
argument_list|,
name|GEN_INT
argument_list|(
operator|(
name|count
operator|>>
operator|(
name|size
operator|==
literal|4
condition|?
literal|2
else|:
literal|3
operator|)
operator|)
operator|&
operator|(
name|TARGET_64BIT
condition|?
operator|-
literal|1
else|:
literal|0x3fffffff
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|countreg
operator|=
name|ix86_zero_extend_to_Pmode
argument_list|(
name|countreg
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|4
condition|)
block|{
if|if
condition|(
name|TARGET_64BIT
condition|)
name|emit_insn
argument_list|(
name|gen_rep_movsi_rex64
argument_list|(
name|destreg
argument_list|,
name|srcreg
argument_list|,
name|countreg
argument_list|,
name|destreg
argument_list|,
name|srcreg
argument_list|,
name|countreg
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_rep_movsi
argument_list|(
name|destreg
argument_list|,
name|srcreg
argument_list|,
name|countreg
argument_list|,
name|destreg
argument_list|,
name|srcreg
argument_list|,
name|countreg
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|emit_insn
argument_list|(
name|gen_rep_movdi_rex64
argument_list|(
name|destreg
argument_list|,
name|srcreg
argument_list|,
name|countreg
argument_list|,
name|destreg
argument_list|,
name|srcreg
argument_list|,
name|countreg
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|size
operator|==
literal|8
operator|&&
operator|(
name|count
operator|&
literal|0x04
operator|)
condition|)
name|emit_insn
argument_list|(
name|gen_strmovsi
argument_list|(
name|destreg
argument_list|,
name|srcreg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|&
literal|0x02
condition|)
name|emit_insn
argument_list|(
name|gen_strmovhi
argument_list|(
name|destreg
argument_list|,
name|srcreg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|&
literal|0x01
condition|)
name|emit_insn
argument_list|(
name|gen_strmovqi
argument_list|(
name|destreg
argument_list|,
name|srcreg
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* The generic code based on the glibc implementation:      - align destination to 4 bytes (8 byte alignment is used for PentiumPro      allowing accelerated copying there)      - copy the data using rep movsl      - copy the rest.  */
else|else
block|{
name|rtx
name|countreg2
decl_stmt|;
name|rtx
name|label
init|=
name|NULL
decl_stmt|;
comment|/* In case we don't know anything about the alignment, default to          library version, since it is usually equally fast and result in          shorter code.  */
if|if
condition|(
operator|!
name|TARGET_INLINE_ALL_STRINGOPS
operator|&&
name|align
operator|<
name|UNITS_PER_WORD
condition|)
block|{
name|end_sequence
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|TARGET_SINGLE_STRINGOP
condition|)
name|emit_insn
argument_list|(
name|gen_cld
argument_list|()
argument_list|)
expr_stmt|;
name|countreg2
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|countreg
operator|=
name|copy_to_mode_reg
argument_list|(
name|counter_mode
argument_list|,
name|count_exp
argument_list|)
expr_stmt|;
comment|/* We don't use loops to align destination and to copy parts smaller          than 4 bytes, because gcc is able to optimize such code better (in          the case the destination or the count really is aligned, gcc is often          able to predict the branches) and also it is friendlier to the          hardware branch prediction.           Using loops is benefical for generic case, because we can          handle small counts using the loops.  Many CPUs (such as Athlon)          have large REP prefix setup costs.           This is quite costy.  Maybe we can revisit this decision later or          add some customizability to this code.  */
if|if
condition|(
name|count
operator|==
literal|0
operator|&&
name|align
operator|<
operator|(
name|TARGET_PENTIUMPRO
operator|&&
operator|(
name|count
operator|==
literal|0
operator|||
name|count
operator|>=
operator|(
name|unsigned
name|int
operator|)
literal|260
operator|)
condition|?
literal|8
else|:
name|UNITS_PER_WORD
operator|)
condition|)
block|{
name|label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|countreg
argument_list|,
name|GEN_INT
argument_list|(
name|UNITS_PER_WORD
operator|-
literal|1
argument_list|)
argument_list|,
name|LEU
argument_list|,
literal|0
argument_list|,
name|counter_mode
argument_list|,
literal|1
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|align
operator|<=
literal|1
condition|)
block|{
name|rtx
name|label
init|=
name|ix86_expand_aligntest
argument_list|(
name|destreg
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_strmovqi
argument_list|(
name|destreg
argument_list|,
name|srcreg
argument_list|)
argument_list|)
expr_stmt|;
name|ix86_adjust_counter
argument_list|(
name|countreg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|align
operator|<=
literal|2
condition|)
block|{
name|rtx
name|label
init|=
name|ix86_expand_aligntest
argument_list|(
name|destreg
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_strmovhi
argument_list|(
name|destreg
argument_list|,
name|srcreg
argument_list|)
argument_list|)
expr_stmt|;
name|ix86_adjust_counter
argument_list|(
name|countreg
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|align
operator|<=
literal|4
operator|&&
operator|(
operator|(
name|TARGET_PENTIUMPRO
operator|&&
operator|(
name|count
operator|==
literal|0
operator|||
name|count
operator|>=
operator|(
name|unsigned
name|int
operator|)
literal|260
operator|)
operator|)
operator|||
name|TARGET_64BIT
operator|)
condition|)
block|{
name|rtx
name|label
init|=
name|ix86_expand_aligntest
argument_list|(
name|destreg
argument_list|,
literal|4
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_strmovsi
argument_list|(
name|destreg
argument_list|,
name|srcreg
argument_list|)
argument_list|)
expr_stmt|;
name|ix86_adjust_counter
argument_list|(
name|countreg
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TARGET_SINGLE_STRINGOP
condition|)
name|emit_insn
argument_list|(
name|gen_cld
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_lshrdi3
argument_list|(
name|countreg2
argument_list|,
name|ix86_zero_extend_to_Pmode
argument_list|(
name|countreg
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
literal|3
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rep_movdi_rex64
argument_list|(
name|destreg
argument_list|,
name|srcreg
argument_list|,
name|countreg2
argument_list|,
name|destreg
argument_list|,
name|srcreg
argument_list|,
name|countreg2
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|emit_insn
argument_list|(
name|gen_lshrsi3
argument_list|(
name|countreg2
argument_list|,
name|countreg
argument_list|,
name|GEN_INT
argument_list|(
literal|2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rep_movsi
argument_list|(
name|destreg
argument_list|,
name|srcreg
argument_list|,
name|countreg2
argument_list|,
name|destreg
argument_list|,
name|srcreg
argument_list|,
name|countreg2
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|label
condition|)
block|{
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_64BIT
operator|&&
name|align
operator|>
literal|4
operator|&&
name|count
operator|!=
literal|0
operator|&&
operator|(
name|count
operator|&
literal|4
operator|)
condition|)
name|emit_insn
argument_list|(
name|gen_strmovsi
argument_list|(
name|destreg
argument_list|,
name|srcreg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|align
operator|<=
literal|4
operator|||
name|count
operator|==
literal|0
operator|)
operator|&&
name|TARGET_64BIT
condition|)
block|{
name|rtx
name|label
init|=
name|ix86_expand_aligntest
argument_list|(
name|countreg
argument_list|,
literal|4
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_strmovsi
argument_list|(
name|destreg
argument_list|,
name|srcreg
argument_list|)
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|align
operator|>
literal|2
operator|&&
name|count
operator|!=
literal|0
operator|&&
operator|(
name|count
operator|&
literal|2
operator|)
condition|)
name|emit_insn
argument_list|(
name|gen_strmovhi
argument_list|(
name|destreg
argument_list|,
name|srcreg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|align
operator|<=
literal|2
operator|||
name|count
operator|==
literal|0
condition|)
block|{
name|rtx
name|label
init|=
name|ix86_expand_aligntest
argument_list|(
name|countreg
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_strmovhi
argument_list|(
name|destreg
argument_list|,
name|srcreg
argument_list|)
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|align
operator|>
literal|1
operator|&&
name|count
operator|!=
literal|0
operator|&&
operator|(
name|count
operator|&
literal|1
operator|)
condition|)
name|emit_insn
argument_list|(
name|gen_strmovqi
argument_list|(
name|destreg
argument_list|,
name|srcreg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|align
operator|<=
literal|1
operator|||
name|count
operator|==
literal|0
condition|)
block|{
name|rtx
name|label
init|=
name|ix86_expand_aligntest
argument_list|(
name|countreg
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_strmovqi
argument_list|(
name|destreg
argument_list|,
name|srcreg
argument_list|)
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|ix86_set_move_mem_attrs
argument_list|(
name|insns
argument_list|,
name|dst
argument_list|,
name|src
argument_list|,
name|destreg
argument_list|,
name|srcreg
argument_list|)
expr_stmt|;
name|emit_insns
argument_list|(
name|insns
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Expand string clear operation (bzero).  Use i386 string operations when    profitable.  expand_movstr contains similar code.  */
end_comment

begin_function
name|int
name|ix86_expand_clrstr
parameter_list|(
name|src
parameter_list|,
name|count_exp
parameter_list|,
name|align_exp
parameter_list|)
name|rtx
name|src
decl_stmt|,
name|count_exp
decl_stmt|,
name|align_exp
decl_stmt|;
block|{
name|rtx
name|destreg
decl_stmt|,
name|zeroreg
decl_stmt|,
name|countreg
decl_stmt|;
name|enum
name|machine_mode
name|counter_mode
decl_stmt|;
name|HOST_WIDE_INT
name|align
init|=
literal|0
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|count
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|align_exp
argument_list|)
operator|==
name|CONST_INT
condition|)
name|align
operator|=
name|INTVAL
argument_list|(
name|align_exp
argument_list|)
expr_stmt|;
comment|/* This simple hack avoids all inlining code and simplifies code below.  */
if|if
condition|(
operator|!
name|TARGET_ALIGN_STRINGOPS
condition|)
name|align
operator|=
literal|32
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|count_exp
argument_list|)
operator|==
name|CONST_INT
condition|)
name|count
operator|=
name|INTVAL
argument_list|(
name|count_exp
argument_list|)
expr_stmt|;
comment|/* Figure out proper mode for counter.  For 32bits it is always SImode,      for 64bits use SImode when possible, otherwise DImode.      Set count to number of bytes copied when known at compile time.  */
if|if
condition|(
operator|!
name|TARGET_64BIT
operator|||
name|GET_MODE
argument_list|(
name|count_exp
argument_list|)
operator|==
name|SImode
operator|||
name|x86_64_zero_extended_value
argument_list|(
name|count_exp
argument_list|)
condition|)
name|counter_mode
operator|=
name|SImode
expr_stmt|;
else|else
name|counter_mode
operator|=
name|DImode
expr_stmt|;
name|destreg
operator|=
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_cld
argument_list|()
argument_list|)
expr_stmt|;
comment|/* When optimizing for size emit simple rep ; movsb instruction for      counts not divisible by 4.  */
if|if
condition|(
operator|(
operator|!
name|optimize
operator|||
name|optimize_size
operator|)
operator|&&
operator|(
name|count
operator|==
literal|0
operator|||
operator|(
name|count
operator|&
literal|0x03
operator|)
operator|)
condition|)
block|{
name|countreg
operator|=
name|ix86_zero_extend_to_Pmode
argument_list|(
name|count_exp
argument_list|)
expr_stmt|;
name|zeroreg
operator|=
name|copy_to_mode_reg
argument_list|(
name|QImode
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
name|emit_insn
argument_list|(
name|gen_rep_stosqi_rex64
argument_list|(
name|destreg
argument_list|,
name|countreg
argument_list|,
name|zeroreg
argument_list|,
name|destreg
argument_list|,
name|countreg
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_rep_stosqi
argument_list|(
name|destreg
argument_list|,
name|countreg
argument_list|,
name|zeroreg
argument_list|,
name|destreg
argument_list|,
name|countreg
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|count
operator|!=
literal|0
operator|&&
operator|(
name|align
operator|>=
literal|8
operator|||
operator|(
operator|!
name|TARGET_PENTIUMPRO
operator|&&
operator|!
name|TARGET_64BIT
operator|&&
name|align
operator|>=
literal|4
operator|)
operator|||
name|optimize_size
operator|||
name|count
operator|<
operator|(
name|unsigned
name|int
operator|)
literal|64
operator|)
condition|)
block|{
name|int
name|size
init|=
name|TARGET_64BIT
operator|&&
operator|!
name|optimize_size
condition|?
literal|8
else|:
literal|4
decl_stmt|;
name|zeroreg
operator|=
name|copy_to_mode_reg
argument_list|(
name|size
operator|==
literal|4
condition|?
name|SImode
else|:
name|DImode
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|&
operator|~
operator|(
name|size
operator|-
literal|1
operator|)
condition|)
block|{
name|countreg
operator|=
name|copy_to_mode_reg
argument_list|(
name|counter_mode
argument_list|,
name|GEN_INT
argument_list|(
operator|(
name|count
operator|>>
operator|(
name|size
operator|==
literal|4
condition|?
literal|2
else|:
literal|3
operator|)
operator|)
operator|&
operator|(
name|TARGET_64BIT
condition|?
operator|-
literal|1
else|:
literal|0x3fffffff
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|countreg
operator|=
name|ix86_zero_extend_to_Pmode
argument_list|(
name|countreg
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|4
condition|)
block|{
if|if
condition|(
name|TARGET_64BIT
condition|)
name|emit_insn
argument_list|(
name|gen_rep_stossi_rex64
argument_list|(
name|destreg
argument_list|,
name|countreg
argument_list|,
name|zeroreg
argument_list|,
name|destreg
argument_list|,
name|countreg
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_rep_stossi
argument_list|(
name|destreg
argument_list|,
name|countreg
argument_list|,
name|zeroreg
argument_list|,
name|destreg
argument_list|,
name|countreg
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|emit_insn
argument_list|(
name|gen_rep_stosdi_rex64
argument_list|(
name|destreg
argument_list|,
name|countreg
argument_list|,
name|zeroreg
argument_list|,
name|destreg
argument_list|,
name|countreg
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|size
operator|==
literal|8
operator|&&
operator|(
name|count
operator|&
literal|0x04
operator|)
condition|)
name|emit_insn
argument_list|(
name|gen_strsetsi
argument_list|(
name|destreg
argument_list|,
name|gen_rtx_SUBREG
argument_list|(
name|SImode
argument_list|,
name|zeroreg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|&
literal|0x02
condition|)
name|emit_insn
argument_list|(
name|gen_strsethi
argument_list|(
name|destreg
argument_list|,
name|gen_rtx_SUBREG
argument_list|(
name|HImode
argument_list|,
name|zeroreg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|&
literal|0x01
condition|)
name|emit_insn
argument_list|(
name|gen_strsetqi
argument_list|(
name|destreg
argument_list|,
name|gen_rtx_SUBREG
argument_list|(
name|QImode
argument_list|,
name|zeroreg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|countreg2
decl_stmt|;
name|rtx
name|label
init|=
name|NULL
decl_stmt|;
comment|/* In case we don't know anything about the alignment, default to          library version, since it is usually equally fast and result in          shorter code.  */
if|if
condition|(
operator|!
name|TARGET_INLINE_ALL_STRINGOPS
operator|&&
name|align
operator|<
name|UNITS_PER_WORD
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TARGET_SINGLE_STRINGOP
condition|)
name|emit_insn
argument_list|(
name|gen_cld
argument_list|()
argument_list|)
expr_stmt|;
name|countreg2
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|countreg
operator|=
name|copy_to_mode_reg
argument_list|(
name|counter_mode
argument_list|,
name|count_exp
argument_list|)
expr_stmt|;
name|zeroreg
operator|=
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
operator|&&
name|align
operator|<
operator|(
name|TARGET_PENTIUMPRO
operator|&&
operator|(
name|count
operator|==
literal|0
operator|||
name|count
operator|>=
operator|(
name|unsigned
name|int
operator|)
literal|260
operator|)
condition|?
literal|8
else|:
name|UNITS_PER_WORD
operator|)
condition|)
block|{
name|label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|countreg
argument_list|,
name|GEN_INT
argument_list|(
name|UNITS_PER_WORD
operator|-
literal|1
argument_list|)
argument_list|,
name|LEU
argument_list|,
literal|0
argument_list|,
name|counter_mode
argument_list|,
literal|1
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|align
operator|<=
literal|1
condition|)
block|{
name|rtx
name|label
init|=
name|ix86_expand_aligntest
argument_list|(
name|destreg
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_strsetqi
argument_list|(
name|destreg
argument_list|,
name|gen_rtx_SUBREG
argument_list|(
name|QImode
argument_list|,
name|zeroreg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ix86_adjust_counter
argument_list|(
name|countreg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|align
operator|<=
literal|2
condition|)
block|{
name|rtx
name|label
init|=
name|ix86_expand_aligntest
argument_list|(
name|destreg
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_strsethi
argument_list|(
name|destreg
argument_list|,
name|gen_rtx_SUBREG
argument_list|(
name|HImode
argument_list|,
name|zeroreg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ix86_adjust_counter
argument_list|(
name|countreg
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|align
operator|<=
literal|4
operator|&&
name|TARGET_PENTIUMPRO
operator|&&
operator|(
name|count
operator|==
literal|0
operator|||
name|count
operator|>=
operator|(
name|unsigned
name|int
operator|)
literal|260
operator|)
condition|)
block|{
name|rtx
name|label
init|=
name|ix86_expand_aligntest
argument_list|(
name|destreg
argument_list|,
literal|4
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_strsetsi
argument_list|(
name|destreg
argument_list|,
operator|(
name|TARGET_64BIT
condition|?
name|gen_rtx_SUBREG
argument_list|(
name|SImode
argument_list|,
name|zeroreg
argument_list|,
literal|0
argument_list|)
else|:
name|zeroreg
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|ix86_adjust_counter
argument_list|(
name|countreg
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TARGET_SINGLE_STRINGOP
condition|)
name|emit_insn
argument_list|(
name|gen_cld
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_lshrdi3
argument_list|(
name|countreg2
argument_list|,
name|ix86_zero_extend_to_Pmode
argument_list|(
name|countreg
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
literal|3
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rep_stosdi_rex64
argument_list|(
name|destreg
argument_list|,
name|countreg2
argument_list|,
name|zeroreg
argument_list|,
name|destreg
argument_list|,
name|countreg2
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|emit_insn
argument_list|(
name|gen_lshrsi3
argument_list|(
name|countreg2
argument_list|,
name|countreg
argument_list|,
name|GEN_INT
argument_list|(
literal|2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rep_stossi
argument_list|(
name|destreg
argument_list|,
name|countreg2
argument_list|,
name|zeroreg
argument_list|,
name|destreg
argument_list|,
name|countreg2
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|label
condition|)
block|{
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_64BIT
operator|&&
name|align
operator|>
literal|4
operator|&&
name|count
operator|!=
literal|0
operator|&&
operator|(
name|count
operator|&
literal|4
operator|)
condition|)
name|emit_insn
argument_list|(
name|gen_strsetsi
argument_list|(
name|destreg
argument_list|,
name|gen_rtx_SUBREG
argument_list|(
name|SImode
argument_list|,
name|zeroreg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
operator|&&
operator|(
name|align
operator|<=
literal|4
operator|||
name|count
operator|==
literal|0
operator|)
condition|)
block|{
name|rtx
name|label
init|=
name|ix86_expand_aligntest
argument_list|(
name|destreg
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_strsetsi
argument_list|(
name|destreg
argument_list|,
name|gen_rtx_SUBREG
argument_list|(
name|SImode
argument_list|,
name|zeroreg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|align
operator|>
literal|2
operator|&&
name|count
operator|!=
literal|0
operator|&&
operator|(
name|count
operator|&
literal|2
operator|)
condition|)
name|emit_insn
argument_list|(
name|gen_strsethi
argument_list|(
name|destreg
argument_list|,
name|gen_rtx_SUBREG
argument_list|(
name|HImode
argument_list|,
name|zeroreg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|align
operator|<=
literal|2
operator|||
name|count
operator|==
literal|0
condition|)
block|{
name|rtx
name|label
init|=
name|ix86_expand_aligntest
argument_list|(
name|destreg
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_strsethi
argument_list|(
name|destreg
argument_list|,
name|gen_rtx_SUBREG
argument_list|(
name|HImode
argument_list|,
name|zeroreg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|align
operator|>
literal|1
operator|&&
name|count
operator|!=
literal|0
operator|&&
operator|(
name|count
operator|&
literal|1
operator|)
condition|)
name|emit_insn
argument_list|(
name|gen_strsetqi
argument_list|(
name|destreg
argument_list|,
name|gen_rtx_SUBREG
argument_list|(
name|QImode
argument_list|,
name|zeroreg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|align
operator|<=
literal|1
operator|||
name|count
operator|==
literal|0
condition|)
block|{
name|rtx
name|label
init|=
name|ix86_expand_aligntest
argument_list|(
name|destreg
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_strsetqi
argument_list|(
name|destreg
argument_list|,
name|gen_rtx_SUBREG
argument_list|(
name|QImode
argument_list|,
name|zeroreg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Expand strlen.  */
end_comment

begin_function
name|int
name|ix86_expand_strlen
parameter_list|(
name|out
parameter_list|,
name|src
parameter_list|,
name|eoschar
parameter_list|,
name|align
parameter_list|)
name|rtx
name|out
decl_stmt|,
name|src
decl_stmt|,
name|eoschar
decl_stmt|,
name|align
decl_stmt|;
block|{
name|rtx
name|addr
decl_stmt|,
name|scratch1
decl_stmt|,
name|scratch2
decl_stmt|,
name|scratch3
decl_stmt|,
name|scratch4
decl_stmt|;
comment|/* The generic case of strlen expander is long.  Avoid it's      expanding unless TARGET_INLINE_ALL_STRINGOPS.  */
if|if
condition|(
name|TARGET_UNROLL_STRLEN
operator|&&
name|eoschar
operator|==
name|const0_rtx
operator|&&
name|optimize
operator|>
literal|1
operator|&&
operator|!
name|TARGET_INLINE_ALL_STRINGOPS
operator|&&
operator|!
name|optimize_size
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|align
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|INTVAL
argument_list|(
name|align
argument_list|)
operator|<
literal|4
operator|)
condition|)
return|return
literal|0
return|;
name|addr
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|scratch1
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_UNROLL_STRLEN
operator|&&
name|eoschar
operator|==
name|const0_rtx
operator|&&
name|optimize
operator|>
literal|1
operator|&&
operator|!
name|optimize_size
condition|)
block|{
comment|/* Well it seems that some optimizer does not combine a call like          foo(strlen(bar), strlen(bar));          when the move and the subtraction is done here.  It does calculate          the length just once when these instructions are done inside of          output_strlen_unroll().  But I think since&bar[strlen(bar)] is          often used and I use one fewer register for the lifetime of          output_strlen_unroll() this is better.  */
name|emit_move_insn
argument_list|(
name|out
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|ix86_expand_strlensi_unroll_1
argument_list|(
name|out
argument_list|,
name|align
argument_list|)
expr_stmt|;
comment|/* strlensi_unroll_1 returns the address of the zero at the end of          the string, like memchr(), so compute the length by subtracting          the start address.  */
if|if
condition|(
name|TARGET_64BIT
condition|)
name|emit_insn
argument_list|(
name|gen_subdi3
argument_list|(
name|out
argument_list|,
name|out
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_subsi3
argument_list|(
name|out
argument_list|,
name|out
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|scratch2
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|scratch3
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|scratch4
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|constm1_rtx
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|scratch3
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|eoschar
operator|=
name|force_reg
argument_list|(
name|QImode
argument_list|,
name|eoschar
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_cld
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_strlenqi_rex_1
argument_list|(
name|scratch1
argument_list|,
name|scratch3
argument_list|,
name|eoschar
argument_list|,
name|align
argument_list|,
name|scratch4
argument_list|,
name|scratch3
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_one_cmpldi2
argument_list|(
name|scratch2
argument_list|,
name|scratch1
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|out
argument_list|,
name|scratch2
argument_list|,
name|constm1_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|emit_insn
argument_list|(
name|gen_strlenqi_1
argument_list|(
name|scratch1
argument_list|,
name|scratch3
argument_list|,
name|eoschar
argument_list|,
name|align
argument_list|,
name|scratch4
argument_list|,
name|scratch3
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_one_cmplsi2
argument_list|(
name|scratch2
argument_list|,
name|scratch1
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|out
argument_list|,
name|scratch2
argument_list|,
name|constm1_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Expand the appropriate insns for doing strlen if not just doing    repnz; scasb     out = result, initialized with the start address    align_rtx = alignment of the address.    scratch = scratch register, initialized with the startaddress when 	not aligned, otherwise undefined     This is just the body. It needs the initialisations mentioned above and    some address computing at the end.  These things are done in i386.md.  */
end_comment

begin_function
specifier|static
name|void
name|ix86_expand_strlensi_unroll_1
parameter_list|(
name|out
parameter_list|,
name|align_rtx
parameter_list|)
name|rtx
name|out
decl_stmt|,
name|align_rtx
decl_stmt|;
block|{
name|int
name|align
decl_stmt|;
name|rtx
name|tmp
decl_stmt|;
name|rtx
name|align_2_label
init|=
name|NULL_RTX
decl_stmt|;
name|rtx
name|align_3_label
init|=
name|NULL_RTX
decl_stmt|;
name|rtx
name|align_4_label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|rtx
name|end_0_label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|rtx
name|mem
decl_stmt|;
name|rtx
name|tmpreg
init|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
decl_stmt|;
name|rtx
name|scratch
init|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
decl_stmt|;
name|align
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|align_rtx
argument_list|)
operator|==
name|CONST_INT
condition|)
name|align
operator|=
name|INTVAL
argument_list|(
name|align_rtx
argument_list|)
expr_stmt|;
comment|/* Loop to check 1..3 bytes for null to get an aligned pointer.  */
comment|/* Is there a known alignment and is it less than 4?  */
if|if
condition|(
name|align
operator|<
literal|4
condition|)
block|{
name|rtx
name|scratch1
init|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|scratch1
argument_list|,
name|out
argument_list|)
expr_stmt|;
comment|/* Is there a known alignment and is it not 2? */
if|if
condition|(
name|align
operator|!=
literal|2
condition|)
block|{
name|align_3_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
comment|/* Label when aligned to 3-byte */
name|align_2_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
comment|/* Label when aligned to 2-byte */
comment|/* Leave just the 3 lower bits.  */
name|align_rtx
operator|=
name|expand_binop
argument_list|(
name|Pmode
argument_list|,
name|and_optab
argument_list|,
name|scratch1
argument_list|,
name|GEN_INT
argument_list|(
literal|3
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|align_rtx
argument_list|,
name|const0_rtx
argument_list|,
name|EQ
argument_list|,
name|NULL
argument_list|,
name|Pmode
argument_list|,
literal|1
argument_list|,
name|align_4_label
argument_list|)
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|align_rtx
argument_list|,
name|GEN_INT
argument_list|(
literal|2
argument_list|)
argument_list|,
name|EQ
argument_list|,
name|NULL
argument_list|,
name|Pmode
argument_list|,
literal|1
argument_list|,
name|align_2_label
argument_list|)
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|align_rtx
argument_list|,
name|GEN_INT
argument_list|(
literal|2
argument_list|)
argument_list|,
name|GTU
argument_list|,
name|NULL
argument_list|,
name|Pmode
argument_list|,
literal|1
argument_list|,
name|align_3_label
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Since the alignment is 2, we have to check 2 or 0 bytes; 	     check if is aligned to 4 - byte.  */
name|align_rtx
operator|=
name|expand_binop
argument_list|(
name|Pmode
argument_list|,
name|and_optab
argument_list|,
name|scratch1
argument_list|,
name|GEN_INT
argument_list|(
literal|2
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|align_rtx
argument_list|,
name|const0_rtx
argument_list|,
name|EQ
argument_list|,
name|NULL
argument_list|,
name|Pmode
argument_list|,
literal|1
argument_list|,
name|align_4_label
argument_list|)
expr_stmt|;
block|}
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|QImode
argument_list|,
name|out
argument_list|)
expr_stmt|;
comment|/* Now compare the bytes.  */
comment|/* Compare the first n unaligned byte on a byte per byte basis.  */
name|emit_cmp_and_jump_insns
argument_list|(
name|mem
argument_list|,
name|const0_rtx
argument_list|,
name|EQ
argument_list|,
name|NULL
argument_list|,
name|QImode
argument_list|,
literal|1
argument_list|,
name|end_0_label
argument_list|)
expr_stmt|;
comment|/* Increment the address.  */
if|if
condition|(
name|TARGET_64BIT
condition|)
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|out
argument_list|,
name|out
argument_list|,
name|const1_rtx
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|out
argument_list|,
name|out
argument_list|,
name|const1_rtx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Not needed with an alignment of 2 */
if|if
condition|(
name|align
operator|!=
literal|2
condition|)
block|{
name|emit_label
argument_list|(
name|align_2_label
argument_list|)
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|mem
argument_list|,
name|const0_rtx
argument_list|,
name|EQ
argument_list|,
name|NULL
argument_list|,
name|QImode
argument_list|,
literal|1
argument_list|,
name|end_0_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|out
argument_list|,
name|out
argument_list|,
name|const1_rtx
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|out
argument_list|,
name|out
argument_list|,
name|const1_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|align_3_label
argument_list|)
expr_stmt|;
block|}
name|emit_cmp_and_jump_insns
argument_list|(
name|mem
argument_list|,
name|const0_rtx
argument_list|,
name|EQ
argument_list|,
name|NULL
argument_list|,
name|QImode
argument_list|,
literal|1
argument_list|,
name|end_0_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|out
argument_list|,
name|out
argument_list|,
name|const1_rtx
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|out
argument_list|,
name|out
argument_list|,
name|const1_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Generate loop to check 4 bytes at a time.  It is not a good idea to      align this loop.  It gives only huge programs, but does not help to      speed up.  */
name|emit_label
argument_list|(
name|align_4_label
argument_list|)
expr_stmt|;
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|scratch
argument_list|,
name|mem
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|out
argument_list|,
name|out
argument_list|,
name|GEN_INT
argument_list|(
literal|4
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|out
argument_list|,
name|out
argument_list|,
name|GEN_INT
argument_list|(
literal|4
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This formula yields a nonzero result iff one of the bytes is zero.      This saves three branches inside loop and many cycles.  */
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|tmpreg
argument_list|,
name|scratch
argument_list|,
name|GEN_INT
argument_list|(
operator|-
literal|0x01010101
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_one_cmplsi2
argument_list|(
name|scratch
argument_list|,
name|scratch
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_andsi3
argument_list|(
name|tmpreg
argument_list|,
name|tmpreg
argument_list|,
name|scratch
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_andsi3
argument_list|(
name|tmpreg
argument_list|,
name|tmpreg
argument_list|,
name|GEN_INT
argument_list|(
name|trunc_int_for_mode
argument_list|(
literal|0x80808080
argument_list|,
name|SImode
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|tmpreg
argument_list|,
name|const0_rtx
argument_list|,
name|EQ
argument_list|,
literal|0
argument_list|,
name|SImode
argument_list|,
literal|1
argument_list|,
name|align_4_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_CMOVE
condition|)
block|{
name|rtx
name|reg
init|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
decl_stmt|;
name|rtx
name|reg2
init|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|tmpreg
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_lshrsi3
argument_list|(
name|reg
argument_list|,
name|reg
argument_list|,
name|GEN_INT
argument_list|(
literal|16
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If zero is not in the first two bytes, move two bytes forward.  */
name|emit_insn
argument_list|(
name|gen_testsi_ccno_1
argument_list|(
name|tmpreg
argument_list|,
name|GEN_INT
argument_list|(
literal|0x8080
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_REG
argument_list|(
name|CCNOmode
argument_list|,
name|FLAGS_REG
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_EQ
argument_list|(
name|VOIDmode
argument_list|,
name|tmp
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|tmpreg
argument_list|,
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|SImode
argument_list|,
name|tmp
argument_list|,
name|reg
argument_list|,
name|tmpreg
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Emit lea manually to avoid clobbering of flags.  */
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|SImode
argument_list|,
name|reg2
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|out
argument_list|,
name|GEN_INT
argument_list|(
literal|2
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_REG
argument_list|(
name|CCNOmode
argument_list|,
name|FLAGS_REG
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_EQ
argument_list|(
name|VOIDmode
argument_list|,
name|tmp
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|out
argument_list|,
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|Pmode
argument_list|,
name|tmp
argument_list|,
name|reg2
argument_list|,
name|out
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|end_2_label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
comment|/* Is zero in the first two bytes? */
name|emit_insn
argument_list|(
name|gen_testsi_ccno_1
argument_list|(
name|tmpreg
argument_list|,
name|GEN_INT
argument_list|(
literal|0x8080
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_REG
argument_list|(
name|CCNOmode
argument_list|,
name|FLAGS_REG
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_NE
argument_list|(
name|VOIDmode
argument_list|,
name|tmp
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|VOIDmode
argument_list|,
name|tmp
argument_list|,
name|gen_rtx_LABEL_REF
argument_list|(
name|VOIDmode
argument_list|,
name|end_2_label
argument_list|)
argument_list|,
name|pc_rtx
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|emit_jump_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|pc_rtx
argument_list|,
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|JUMP_LABEL
argument_list|(
name|tmp
argument_list|)
operator|=
name|end_2_label
expr_stmt|;
comment|/* Not in the first two.  Move two bytes forward.  */
name|emit_insn
argument_list|(
name|gen_lshrsi3
argument_list|(
name|tmpreg
argument_list|,
name|tmpreg
argument_list|,
name|GEN_INT
argument_list|(
literal|16
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|out
argument_list|,
name|out
argument_list|,
name|GEN_INT
argument_list|(
literal|2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|out
argument_list|,
name|out
argument_list|,
name|GEN_INT
argument_list|(
literal|2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|end_2_label
argument_list|)
expr_stmt|;
block|}
comment|/* Avoid branch in fixing the byte.  */
name|tmpreg
operator|=
name|gen_lowpart
argument_list|(
name|QImode
argument_list|,
name|tmpreg
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_addqi3_cc
argument_list|(
name|tmpreg
argument_list|,
name|tmpreg
argument_list|,
name|tmpreg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
name|emit_insn
argument_list|(
name|gen_subdi3_carry_rex64
argument_list|(
name|out
argument_list|,
name|out
argument_list|,
name|GEN_INT
argument_list|(
literal|3
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_subsi3_carry
argument_list|(
name|out
argument_list|,
name|out
argument_list|,
name|GEN_INT
argument_list|(
literal|3
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|end_0_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Clear stack slot assignments remembered from previous functions.    This is called from INIT_EXPANDERS once before RTL is emitted for each    function.  */
end_comment

begin_function
specifier|static
name|void
name|ix86_init_machine_status
parameter_list|(
name|p
parameter_list|)
name|struct
name|function
modifier|*
name|p
decl_stmt|;
block|{
name|p
operator|->
name|machine
operator|=
operator|(
expr|struct
name|machine_function
operator|*
operator|)
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|machine_function
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Mark machine specific bits of P for GC.  */
end_comment

begin_function
specifier|static
name|void
name|ix86_mark_machine_status
parameter_list|(
name|p
parameter_list|)
name|struct
name|function
modifier|*
name|p
decl_stmt|;
block|{
name|struct
name|machine_function
modifier|*
name|machine
init|=
name|p
operator|->
name|machine
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|n
decl_stmt|;
if|if
condition|(
operator|!
name|machine
condition|)
return|return;
for|for
control|(
name|mode
operator|=
name|VOIDmode
init|;
operator|(
name|int
operator|)
name|mode
operator|<
operator|(
name|int
operator|)
name|MAX_MACHINE_MODE
condition|;
name|mode
operator|=
operator|(
expr|enum
name|machine_mode
operator|)
operator|(
operator|(
name|int
operator|)
name|mode
operator|+
literal|1
operator|)
control|)
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|MAX_386_STACK_LOCALS
condition|;
name|n
operator|++
control|)
name|ggc_mark_rtx
argument_list|(
name|machine
operator|->
name|stack_locals
index|[
operator|(
name|int
operator|)
name|mode
index|]
index|[
name|n
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ix86_free_machine_status
parameter_list|(
name|p
parameter_list|)
name|struct
name|function
modifier|*
name|p
decl_stmt|;
block|{
name|free
argument_list|(
name|p
operator|->
name|machine
argument_list|)
expr_stmt|;
name|p
operator|->
name|machine
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a MEM corresponding to a stack slot with mode MODE.    Allocate a new slot if necessary.     The RTL for a function can have several slots available: N is    which slot to use.  */
end_comment

begin_function
name|rtx
name|assign_386_stack_local
parameter_list|(
name|mode
parameter_list|,
name|n
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
if|if
condition|(
name|n
operator|<
literal|0
operator|||
name|n
operator|>=
name|MAX_386_STACK_LOCALS
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|ix86_stack_locals
index|[
operator|(
name|int
operator|)
name|mode
index|]
index|[
name|n
index|]
operator|==
name|NULL_RTX
condition|)
name|ix86_stack_locals
index|[
operator|(
name|int
operator|)
name|mode
index|]
index|[
name|n
index|]
operator|=
name|assign_stack_local
argument_list|(
name|mode
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|ix86_stack_locals
index|[
operator|(
name|int
operator|)
name|mode
index|]
index|[
name|n
index|]
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Calculate the length of the memory address in the instruction    encoding.  Does not include the one-byte modrm, opcode, or prefix.  */
end_comment

begin_function
specifier|static
name|int
name|memory_address_length
parameter_list|(
name|addr
parameter_list|)
name|rtx
name|addr
decl_stmt|;
block|{
name|struct
name|ix86_address
name|parts
decl_stmt|;
name|rtx
name|base
decl_stmt|,
name|index
decl_stmt|,
name|disp
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PRE_DEC
operator|||
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|POST_INC
operator|||
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PRE_MODIFY
operator|||
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|POST_MODIFY
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|ix86_decompose_address
argument_list|(
name|addr
argument_list|,
operator|&
name|parts
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|base
operator|=
name|parts
operator|.
name|base
expr_stmt|;
name|index
operator|=
name|parts
operator|.
name|index
expr_stmt|;
name|disp
operator|=
name|parts
operator|.
name|disp
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
comment|/* Register Indirect.  */
if|if
condition|(
name|base
operator|&&
operator|!
name|index
operator|&&
operator|!
name|disp
condition|)
block|{
comment|/* Special cases: ebp and esp need the two-byte modrm form.  */
if|if
condition|(
name|addr
operator|==
name|stack_pointer_rtx
operator|||
name|addr
operator|==
name|arg_pointer_rtx
operator|||
name|addr
operator|==
name|frame_pointer_rtx
operator|||
name|addr
operator|==
name|hard_frame_pointer_rtx
condition|)
name|len
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Direct Addressing.  */
elseif|else
if|if
condition|(
name|disp
operator|&&
operator|!
name|base
operator|&&
operator|!
name|index
condition|)
name|len
operator|=
literal|4
expr_stmt|;
else|else
block|{
comment|/* Find the length of the displacement constant.  */
if|if
condition|(
name|disp
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|INTVAL
argument_list|(
name|disp
argument_list|)
argument_list|,
literal|'K'
argument_list|)
condition|)
name|len
operator|=
literal|1
expr_stmt|;
else|else
name|len
operator|=
literal|4
expr_stmt|;
block|}
comment|/* An index requires the two-byte modrm form.  */
if|if
condition|(
name|index
condition|)
name|len
operator|+=
literal|1
expr_stmt|;
block|}
return|return
name|len
return|;
block|}
end_function

begin_comment
comment|/* Compute default value for "length_immediate" attribute.  When SHORTFORM is set    expect that insn have 8bit immediate alternative.  */
end_comment

begin_function
name|int
name|ix86_attr_length_immediate_default
parameter_list|(
name|insn
parameter_list|,
name|shortform
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|int
name|shortform
decl_stmt|;
block|{
name|int
name|len
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|extract_insn_cached
argument_list|(
name|insn
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|recog_data
operator|.
name|n_operands
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|len
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|shortform
operator|&&
name|GET_CODE
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|INTVAL
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
argument_list|,
literal|'K'
argument_list|)
condition|)
name|len
operator|=
literal|1
expr_stmt|;
else|else
block|{
switch|switch
condition|(
name|get_attr_mode
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|MODE_QI
case|:
name|len
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|MODE_HI
case|:
name|len
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|MODE_SI
case|:
name|len
operator|+=
literal|4
expr_stmt|;
break|break;
comment|/* Immediates for DImode instructions are encoded as 32bit sign extended values.  */
case|case
name|MODE_DI
case|:
name|len
operator|+=
literal|4
expr_stmt|;
break|break;
default|default:
name|fatal_insn
argument_list|(
literal|"unknown insn mode"
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|len
return|;
block|}
end_function

begin_comment
comment|/* Compute default value for "length_address" attribute.  */
end_comment

begin_function
name|int
name|ix86_attr_length_address_default
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|extract_insn_cached
argument_list|(
name|insn
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|recog_data
operator|.
name|n_operands
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
operator|==
name|MEM
condition|)
block|{
return|return
name|memory_address_length
argument_list|(
name|XEXP
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the maximum number of instructions a cpu can issue.  */
end_comment

begin_function
specifier|static
name|int
name|ix86_issue_rate
parameter_list|()
block|{
switch|switch
condition|(
name|ix86_cpu
condition|)
block|{
case|case
name|PROCESSOR_PENTIUM
case|:
case|case
name|PROCESSOR_K6
case|:
return|return
literal|2
return|;
case|case
name|PROCESSOR_PENTIUMPRO
case|:
case|case
name|PROCESSOR_PENTIUM4
case|:
case|case
name|PROCESSOR_ATHLON
case|:
return|return
literal|3
return|;
default|default:
return|return
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/* A subroutine of ix86_adjust_cost -- return true iff INSN reads flags set    by DEP_INSN and nothing set by DEP_INSN.  */
end_comment

begin_function
specifier|static
name|int
name|ix86_flags_dependant
parameter_list|(
name|insn
parameter_list|,
name|dep_insn
parameter_list|,
name|insn_type
parameter_list|)
name|rtx
name|insn
decl_stmt|,
name|dep_insn
decl_stmt|;
name|enum
name|attr_type
name|insn_type
decl_stmt|;
block|{
name|rtx
name|set
decl_stmt|,
name|set2
decl_stmt|;
comment|/* Simplify the test for uninteresting insns.  */
if|if
condition|(
name|insn_type
operator|!=
name|TYPE_SETCC
operator|&&
name|insn_type
operator|!=
name|TYPE_ICMOV
operator|&&
name|insn_type
operator|!=
name|TYPE_FCMOV
operator|&&
name|insn_type
operator|!=
name|TYPE_IBR
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|dep_insn
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|set
operator|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|set2
operator|=
name|NULL_RTX
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|dep_insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|dep_insn
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
literal|2
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|dep_insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|dep_insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
block|{
name|set
operator|=
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|dep_insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|set2
operator|=
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|dep_insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|set
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|set
argument_list|)
operator|!=
name|FLAGS_REG
condition|)
return|return
literal|0
return|;
comment|/* This test is true if the dependent insn reads the flags but      not any other potentially set register.  */
if|if
condition|(
operator|!
name|reg_overlap_mentioned_p
argument_list|(
name|set
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|set2
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|set2
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of ix86_adjust_cost -- return true iff INSN has a memory    address with operands set by DEP_INSN.  */
end_comment

begin_function
specifier|static
name|int
name|ix86_agi_dependant
parameter_list|(
name|insn
parameter_list|,
name|dep_insn
parameter_list|,
name|insn_type
parameter_list|)
name|rtx
name|insn
decl_stmt|,
name|dep_insn
decl_stmt|;
name|enum
name|attr_type
name|insn_type
decl_stmt|;
block|{
name|rtx
name|addr
decl_stmt|;
if|if
condition|(
name|insn_type
operator|==
name|TYPE_LEA
operator|&&
name|TARGET_PENTIUM
condition|)
block|{
name|addr
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|SET
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
name|addr
operator|=
name|XVECEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
name|addr
operator|=
name|SET_SRC
argument_list|(
name|addr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
name|extract_insn_cached
argument_list|(
name|insn
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|recog_data
operator|.
name|n_operands
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|addr
operator|=
name|XEXP
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|found
goto|;
block|}
return|return
literal|0
return|;
name|found
label|:
empty_stmt|;
block|}
return|return
name|modified_in_p
argument_list|(
name|addr
argument_list|,
name|dep_insn
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ix86_adjust_cost
parameter_list|(
name|insn
parameter_list|,
name|link
parameter_list|,
name|dep_insn
parameter_list|,
name|cost
parameter_list|)
name|rtx
name|insn
decl_stmt|,
name|link
decl_stmt|,
name|dep_insn
decl_stmt|;
name|int
name|cost
decl_stmt|;
block|{
name|enum
name|attr_type
name|insn_type
decl_stmt|,
name|dep_insn_type
decl_stmt|;
name|enum
name|attr_memory
name|memory
decl_stmt|,
name|dep_memory
decl_stmt|;
name|rtx
name|set
decl_stmt|,
name|set2
decl_stmt|;
name|int
name|dep_insn_code_number
decl_stmt|;
comment|/* Anti and output depenancies have zero cost on all CPUs.  */
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
name|dep_insn_code_number
operator|=
name|recog_memoized
argument_list|(
name|dep_insn
argument_list|)
expr_stmt|;
comment|/* If we can't recognize the insns, we can't really do anything.  */
if|if
condition|(
name|dep_insn_code_number
operator|<
literal|0
operator|||
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|<
literal|0
condition|)
return|return
name|cost
return|;
name|insn_type
operator|=
name|get_attr_type
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|dep_insn_type
operator|=
name|get_attr_type
argument_list|(
name|dep_insn
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ix86_cpu
condition|)
block|{
case|case
name|PROCESSOR_PENTIUM
case|:
comment|/* Address Generation Interlock adds a cycle of latency.  */
if|if
condition|(
name|ix86_agi_dependant
argument_list|(
name|insn
argument_list|,
name|dep_insn
argument_list|,
name|insn_type
argument_list|)
condition|)
name|cost
operator|+=
literal|1
expr_stmt|;
comment|/* ??? Compares pair with jump/setcc.  */
if|if
condition|(
name|ix86_flags_dependant
argument_list|(
name|insn
argument_list|,
name|dep_insn
argument_list|,
name|insn_type
argument_list|)
condition|)
name|cost
operator|=
literal|0
expr_stmt|;
comment|/* Floating point stores require value to be ready one cycle ealier.  */
if|if
condition|(
name|insn_type
operator|==
name|TYPE_FMOV
operator|&&
name|get_attr_memory
argument_list|(
name|insn
argument_list|)
operator|==
name|MEMORY_STORE
operator|&&
operator|!
name|ix86_agi_dependant
argument_list|(
name|insn
argument_list|,
name|dep_insn
argument_list|,
name|insn_type
argument_list|)
condition|)
name|cost
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|PROCESSOR_PENTIUMPRO
case|:
name|memory
operator|=
name|get_attr_memory
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|dep_memory
operator|=
name|get_attr_memory
argument_list|(
name|dep_insn
argument_list|)
expr_stmt|;
comment|/* Since we can't represent delayed latencies of load+operation, 	 increase the cost here for non-imov insns.  */
if|if
condition|(
name|dep_insn_type
operator|!=
name|TYPE_IMOV
operator|&&
name|dep_insn_type
operator|!=
name|TYPE_FMOV
operator|&&
operator|(
name|dep_memory
operator|==
name|MEMORY_LOAD
operator|||
name|dep_memory
operator|==
name|MEMORY_BOTH
operator|)
condition|)
name|cost
operator|+=
literal|1
expr_stmt|;
comment|/* INT->FP conversion is expensive.  */
if|if
condition|(
name|get_attr_fp_int_src
argument_list|(
name|dep_insn
argument_list|)
condition|)
name|cost
operator|+=
literal|5
expr_stmt|;
comment|/* There is one cycle extra latency between an FP op and a store.  */
if|if
condition|(
name|insn_type
operator|==
name|TYPE_FMOV
operator|&&
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|dep_insn
argument_list|)
operator|)
operator|!=
name|NULL_RTX
operator|&&
operator|(
name|set2
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
name|NULL_RTX
operator|&&
name|rtx_equal_p
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|set2
argument_list|)
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set2
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
name|cost
operator|+=
literal|1
expr_stmt|;
comment|/* Show ability of reorder buffer to hide latency of load by executing 	 in parallel with previous instruction in case 	 previous instruction is not needed to compute the address.  */
if|if
condition|(
operator|(
name|memory
operator|==
name|MEMORY_LOAD
operator|||
name|memory
operator|==
name|MEMORY_BOTH
operator|)
operator|&&
operator|!
name|ix86_agi_dependant
argument_list|(
name|insn
argument_list|,
name|dep_insn
argument_list|,
name|insn_type
argument_list|)
condition|)
block|{
comment|/* Claim moves to take one cycle, as core can issue one load 	     at time and the next load can start cycle later.  */
if|if
condition|(
name|dep_insn_type
operator|==
name|TYPE_IMOV
operator|||
name|dep_insn_type
operator|==
name|TYPE_FMOV
condition|)
name|cost
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|cost
operator|>
literal|1
condition|)
name|cost
operator|--
expr_stmt|;
block|}
break|break;
case|case
name|PROCESSOR_K6
case|:
name|memory
operator|=
name|get_attr_memory
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|dep_memory
operator|=
name|get_attr_memory
argument_list|(
name|dep_insn
argument_list|)
expr_stmt|;
comment|/* The esp dependency is resolved before the instruction is really          finished.  */
if|if
condition|(
operator|(
name|insn_type
operator|==
name|TYPE_PUSH
operator|||
name|insn_type
operator|==
name|TYPE_POP
operator|)
operator|&&
operator|(
name|dep_insn_type
operator|==
name|TYPE_PUSH
operator|||
name|dep_insn_type
operator|==
name|TYPE_POP
operator|)
condition|)
return|return
literal|1
return|;
comment|/* Since we can't represent delayed latencies of load+operation, 	 increase the cost here for non-imov insns.  */
if|if
condition|(
name|dep_memory
operator|==
name|MEMORY_LOAD
operator|||
name|dep_memory
operator|==
name|MEMORY_BOTH
condition|)
name|cost
operator|+=
operator|(
name|dep_insn_type
operator|!=
name|TYPE_IMOV
operator|)
condition|?
literal|2
else|:
literal|1
expr_stmt|;
comment|/* INT->FP conversion is expensive.  */
if|if
condition|(
name|get_attr_fp_int_src
argument_list|(
name|dep_insn
argument_list|)
condition|)
name|cost
operator|+=
literal|5
expr_stmt|;
comment|/* Show ability of reorder buffer to hide latency of load by executing 	 in parallel with previous instruction in case 	 previous instruction is not needed to compute the address.  */
if|if
condition|(
operator|(
name|memory
operator|==
name|MEMORY_LOAD
operator|||
name|memory
operator|==
name|MEMORY_BOTH
operator|)
operator|&&
operator|!
name|ix86_agi_dependant
argument_list|(
name|insn
argument_list|,
name|dep_insn
argument_list|,
name|insn_type
argument_list|)
condition|)
block|{
comment|/* Claim moves to take one cycle, as core can issue one load 	     at time and the next load can start cycle later.  */
if|if
condition|(
name|dep_insn_type
operator|==
name|TYPE_IMOV
operator|||
name|dep_insn_type
operator|==
name|TYPE_FMOV
condition|)
name|cost
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|cost
operator|>
literal|2
condition|)
name|cost
operator|-=
literal|2
expr_stmt|;
else|else
name|cost
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|PROCESSOR_ATHLON
case|:
name|memory
operator|=
name|get_attr_memory
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|dep_memory
operator|=
name|get_attr_memory
argument_list|(
name|dep_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|dep_memory
operator|==
name|MEMORY_LOAD
operator|||
name|dep_memory
operator|==
name|MEMORY_BOTH
condition|)
block|{
if|if
condition|(
name|dep_insn_type
operator|==
name|TYPE_IMOV
operator|||
name|dep_insn_type
operator|==
name|TYPE_FMOV
condition|)
name|cost
operator|+=
literal|2
expr_stmt|;
else|else
name|cost
operator|+=
literal|3
expr_stmt|;
block|}
comment|/* Show ability of reorder buffer to hide latency of load by executing 	 in parallel with previous instruction in case 	 previous instruction is not needed to compute the address.  */
if|if
condition|(
operator|(
name|memory
operator|==
name|MEMORY_LOAD
operator|||
name|memory
operator|==
name|MEMORY_BOTH
operator|)
operator|&&
operator|!
name|ix86_agi_dependant
argument_list|(
name|insn
argument_list|,
name|dep_insn
argument_list|,
name|insn_type
argument_list|)
condition|)
block|{
comment|/* Claim moves to take one cycle, as core can issue one load 	     at time and the next load can start cycle later.  */
if|if
condition|(
name|dep_insn_type
operator|==
name|TYPE_IMOV
operator|||
name|dep_insn_type
operator|==
name|TYPE_FMOV
condition|)
name|cost
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|cost
operator|>=
literal|3
condition|)
name|cost
operator|-=
literal|3
expr_stmt|;
else|else
name|cost
operator|=
literal|0
expr_stmt|;
block|}
default|default:
break|break;
block|}
return|return
name|cost
return|;
block|}
end_function

begin_union
specifier|static
union|union
block|{
struct|struct
name|ppro_sched_data
block|{
name|rtx
name|decode
index|[
literal|3
index|]
decl_stmt|;
name|int
name|issued_this_cycle
decl_stmt|;
block|}
name|ppro
struct|;
block|}
name|ix86_sched_data
union|;
end_union

begin_function
specifier|static
name|int
name|ix86_safe_length
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
if|if
condition|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|>=
literal|0
condition|)
return|return
name|get_attr_length
argument_list|(
name|insn
argument_list|)
return|;
else|else
return|return
literal|128
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ix86_safe_length_prefix
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
if|if
condition|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|>=
literal|0
condition|)
return|return
name|get_attr_length
argument_list|(
name|insn
argument_list|)
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|attr_memory
name|ix86_safe_memory
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
if|if
condition|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|>=
literal|0
condition|)
return|return
name|get_attr_memory
argument_list|(
name|insn
argument_list|)
return|;
else|else
return|return
name|MEMORY_UNKNOWN
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|attr_pent_pair
name|ix86_safe_pent_pair
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
if|if
condition|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|>=
literal|0
condition|)
return|return
name|get_attr_pent_pair
argument_list|(
name|insn
argument_list|)
return|;
else|else
return|return
name|PENT_PAIR_NP
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|attr_ppro_uops
name|ix86_safe_ppro_uops
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
if|if
condition|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|>=
literal|0
condition|)
return|return
name|get_attr_ppro_uops
argument_list|(
name|insn
argument_list|)
return|;
else|else
return|return
name|PPRO_UOPS_MANY
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ix86_dump_ppro_packet
parameter_list|(
name|dump
parameter_list|)
name|FILE
modifier|*
name|dump
decl_stmt|;
block|{
if|if
condition|(
name|ix86_sched_data
operator|.
name|ppro
operator|.
name|decode
index|[
literal|0
index|]
condition|)
block|{
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"PPRO packet: %d"
argument_list|,
name|INSN_UID
argument_list|(
name|ix86_sched_data
operator|.
name|ppro
operator|.
name|decode
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ix86_sched_data
operator|.
name|ppro
operator|.
name|decode
index|[
literal|1
index|]
condition|)
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|" %d"
argument_list|,
name|INSN_UID
argument_list|(
name|ix86_sched_data
operator|.
name|ppro
operator|.
name|decode
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ix86_sched_data
operator|.
name|ppro
operator|.
name|decode
index|[
literal|2
index|]
condition|)
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|" %d"
argument_list|,
name|INSN_UID
argument_list|(
name|ix86_sched_data
operator|.
name|ppro
operator|.
name|decode
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|dump
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* We're beginning a new block.  Initialize data structures as necessary.  */
end_comment

begin_function
specifier|static
name|void
name|ix86_sched_init
parameter_list|(
name|dump
parameter_list|,
name|sched_verbose
parameter_list|,
name|veclen
parameter_list|)
name|FILE
modifier|*
name|dump
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|sched_verbose
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|veclen
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|memset
argument_list|(
operator|&
name|ix86_sched_data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ix86_sched_data
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Shift INSN to SLOT, and shift everything else down.  */
end_comment

begin_function
specifier|static
name|void
name|ix86_reorder_insn
parameter_list|(
name|insnp
parameter_list|,
name|slot
parameter_list|)
name|rtx
modifier|*
name|insnp
decl_stmt|,
decl|*
name|slot
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
name|insnp
operator|!=
name|slot
condition|)
block|{
name|rtx
name|insn
init|=
operator|*
name|insnp
decl_stmt|;
do|do
name|insnp
index|[
literal|0
index|]
operator|=
name|insnp
index|[
literal|1
index|]
expr_stmt|;
do|while
condition|(
operator|++
name|insnp
operator|!=
name|slot
condition|)
do|;
operator|*
name|insnp
operator|=
name|insn
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Find an instruction with given pairability and minimal amount of cycles    lost by the fact that the CPU waits for both pipelines to finish before    reading next instructions.  Also take care that both instructions together    can not exceed 7 bytes.  */
end_comment

begin_function
specifier|static
name|rtx
modifier|*
name|ix86_pent_find_pair
parameter_list|(
name|e_ready
parameter_list|,
name|ready
parameter_list|,
name|type
parameter_list|,
name|first
parameter_list|)
name|rtx
modifier|*
name|e_ready
decl_stmt|;
name|rtx
modifier|*
name|ready
decl_stmt|;
name|enum
name|attr_pent_pair
name|type
decl_stmt|;
name|rtx
name|first
decl_stmt|;
block|{
name|int
name|mincycles
decl_stmt|,
name|cycles
decl_stmt|;
name|enum
name|attr_pent_pair
name|tmp
decl_stmt|;
name|enum
name|attr_memory
name|memory
decl_stmt|;
name|rtx
modifier|*
name|insnp
decl_stmt|,
modifier|*
name|bestinsnp
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|ix86_safe_length
argument_list|(
name|first
argument_list|)
operator|>
literal|7
operator|+
name|ix86_safe_length_prefix
argument_list|(
name|first
argument_list|)
condition|)
return|return
name|NULL
return|;
name|memory
operator|=
name|ix86_safe_memory
argument_list|(
name|first
argument_list|)
expr_stmt|;
name|cycles
operator|=
name|result_ready_cost
argument_list|(
name|first
argument_list|)
expr_stmt|;
name|mincycles
operator|=
name|INT_MAX
expr_stmt|;
for|for
control|(
name|insnp
operator|=
name|e_ready
init|;
name|insnp
operator|>=
name|ready
operator|&&
name|mincycles
condition|;
operator|--
name|insnp
control|)
if|if
condition|(
operator|(
name|tmp
operator|=
name|ix86_safe_pent_pair
argument_list|(
operator|*
name|insnp
argument_list|)
operator|)
operator|==
name|type
operator|&&
name|ix86_safe_length
argument_list|(
operator|*
name|insnp
argument_list|)
operator|<=
literal|7
operator|+
name|ix86_safe_length_prefix
argument_list|(
operator|*
name|insnp
argument_list|)
condition|)
block|{
name|enum
name|attr_memory
name|second_memory
decl_stmt|;
name|int
name|secondcycles
decl_stmt|,
name|currentcycles
decl_stmt|;
name|second_memory
operator|=
name|ix86_safe_memory
argument_list|(
operator|*
name|insnp
argument_list|)
expr_stmt|;
name|secondcycles
operator|=
name|result_ready_cost
argument_list|(
operator|*
name|insnp
argument_list|)
expr_stmt|;
name|currentcycles
operator|=
name|abs
argument_list|(
name|cycles
operator|-
name|secondcycles
argument_list|)
expr_stmt|;
if|if
condition|(
name|secondcycles
operator|>=
literal|1
operator|&&
name|cycles
operator|>=
literal|1
condition|)
block|{
comment|/* Two read/modify/write instructions together takes two 	       cycles longer.  */
if|if
condition|(
name|memory
operator|==
name|MEMORY_BOTH
operator|&&
name|second_memory
operator|==
name|MEMORY_BOTH
condition|)
name|currentcycles
operator|+=
literal|2
expr_stmt|;
comment|/* Read modify/write instruction followed by read/modify 	       takes one cycle longer.  */
if|if
condition|(
name|memory
operator|==
name|MEMORY_BOTH
operator|&&
name|second_memory
operator|==
name|MEMORY_LOAD
operator|&&
name|tmp
operator|!=
name|PENT_PAIR_UV
operator|&&
name|ix86_safe_pent_pair
argument_list|(
name|first
argument_list|)
operator|!=
name|PENT_PAIR_UV
condition|)
name|currentcycles
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|currentcycles
operator|<
name|mincycles
condition|)
name|bestinsnp
operator|=
name|insnp
operator|,
name|mincycles
operator|=
name|currentcycles
expr_stmt|;
block|}
return|return
name|bestinsnp
return|;
block|}
end_function

begin_comment
comment|/* Subroutines of ix86_sched_reorder.  */
end_comment

begin_function
specifier|static
name|void
name|ix86_sched_reorder_pentium
parameter_list|(
name|ready
parameter_list|,
name|e_ready
parameter_list|)
name|rtx
modifier|*
name|ready
decl_stmt|;
name|rtx
modifier|*
name|e_ready
decl_stmt|;
block|{
name|enum
name|attr_pent_pair
name|pair1
decl_stmt|,
name|pair2
decl_stmt|;
name|rtx
modifier|*
name|insnp
decl_stmt|;
comment|/* This wouldn't be necessary if Haifa knew that static insn ordering      is important to which pipe an insn is issued to.  So we have to make      some minor rearrangements.  */
name|pair1
operator|=
name|ix86_safe_pent_pair
argument_list|(
operator|*
name|e_ready
argument_list|)
expr_stmt|;
comment|/* If the first insn is non-pairable, let it be.  */
if|if
condition|(
name|pair1
operator|==
name|PENT_PAIR_NP
condition|)
return|return;
name|pair2
operator|=
name|PENT_PAIR_NP
expr_stmt|;
name|insnp
operator|=
literal|0
expr_stmt|;
comment|/* If the first insn is UV or PV pairable, search for a PU      insn to go with.  */
if|if
condition|(
name|pair1
operator|==
name|PENT_PAIR_UV
operator|||
name|pair1
operator|==
name|PENT_PAIR_PV
condition|)
block|{
name|insnp
operator|=
name|ix86_pent_find_pair
argument_list|(
name|e_ready
operator|-
literal|1
argument_list|,
name|ready
argument_list|,
name|PENT_PAIR_PU
argument_list|,
operator|*
name|e_ready
argument_list|)
expr_stmt|;
if|if
condition|(
name|insnp
condition|)
name|pair2
operator|=
name|PENT_PAIR_PU
expr_stmt|;
block|}
comment|/* If the first insn is PU or UV pairable, search for a PV      insn to go with.  */
if|if
condition|(
name|pair2
operator|==
name|PENT_PAIR_NP
operator|&&
operator|(
name|pair1
operator|==
name|PENT_PAIR_PU
operator|||
name|pair1
operator|==
name|PENT_PAIR_UV
operator|)
condition|)
block|{
name|insnp
operator|=
name|ix86_pent_find_pair
argument_list|(
name|e_ready
operator|-
literal|1
argument_list|,
name|ready
argument_list|,
name|PENT_PAIR_PV
argument_list|,
operator|*
name|e_ready
argument_list|)
expr_stmt|;
if|if
condition|(
name|insnp
condition|)
name|pair2
operator|=
name|PENT_PAIR_PV
expr_stmt|;
block|}
comment|/* If the first insn is pairable, search for a UV      insn to go with.  */
if|if
condition|(
name|pair2
operator|==
name|PENT_PAIR_NP
condition|)
block|{
name|insnp
operator|=
name|ix86_pent_find_pair
argument_list|(
name|e_ready
operator|-
literal|1
argument_list|,
name|ready
argument_list|,
name|PENT_PAIR_UV
argument_list|,
operator|*
name|e_ready
argument_list|)
expr_stmt|;
if|if
condition|(
name|insnp
condition|)
name|pair2
operator|=
name|PENT_PAIR_UV
expr_stmt|;
block|}
if|if
condition|(
name|pair2
operator|==
name|PENT_PAIR_NP
condition|)
return|return;
comment|/* Found something!  Decide if we need to swap the order.  */
if|if
condition|(
name|pair1
operator|==
name|PENT_PAIR_PV
operator|||
name|pair2
operator|==
name|PENT_PAIR_PU
operator|||
operator|(
name|pair1
operator|==
name|PENT_PAIR_UV
operator|&&
name|pair2
operator|==
name|PENT_PAIR_UV
operator|&&
name|ix86_safe_memory
argument_list|(
operator|*
name|e_ready
argument_list|)
operator|==
name|MEMORY_BOTH
operator|&&
name|ix86_safe_memory
argument_list|(
operator|*
name|insnp
argument_list|)
operator|==
name|MEMORY_LOAD
operator|)
condition|)
name|ix86_reorder_insn
argument_list|(
name|insnp
argument_list|,
name|e_ready
argument_list|)
expr_stmt|;
else|else
name|ix86_reorder_insn
argument_list|(
name|insnp
argument_list|,
name|e_ready
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ix86_sched_reorder_ppro
parameter_list|(
name|ready
parameter_list|,
name|e_ready
parameter_list|)
name|rtx
modifier|*
name|ready
decl_stmt|;
name|rtx
modifier|*
name|e_ready
decl_stmt|;
block|{
name|rtx
name|decode
index|[
literal|3
index|]
decl_stmt|;
name|enum
name|attr_ppro_uops
name|cur_uops
decl_stmt|;
name|int
name|issued_this_cycle
decl_stmt|;
name|rtx
modifier|*
name|insnp
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* At this point .ppro.decode contains the state of the three      decoders from last "cycle".  That is, those insns that were      actually independent.  But here we're scheduling for the      decoder, and we may find things that are decodable in the      same cycle.  */
name|memcpy
argument_list|(
name|decode
argument_list|,
name|ix86_sched_data
operator|.
name|ppro
operator|.
name|decode
argument_list|,
sizeof|sizeof
argument_list|(
name|decode
argument_list|)
argument_list|)
expr_stmt|;
name|issued_this_cycle
operator|=
literal|0
expr_stmt|;
name|insnp
operator|=
name|e_ready
expr_stmt|;
name|cur_uops
operator|=
name|ix86_safe_ppro_uops
argument_list|(
operator|*
name|insnp
argument_list|)
expr_stmt|;
comment|/* If the decoders are empty, and we've a complex insn at the      head of the priority queue, let it issue without complaint.  */
if|if
condition|(
name|decode
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|cur_uops
operator|==
name|PPRO_UOPS_MANY
condition|)
block|{
name|decode
index|[
literal|0
index|]
operator|=
operator|*
name|insnp
expr_stmt|;
goto|goto
name|ppro_done
goto|;
block|}
comment|/* Otherwise, search for a 2-4 uop unsn to issue.  */
while|while
condition|(
name|cur_uops
operator|!=
name|PPRO_UOPS_FEW
condition|)
block|{
if|if
condition|(
name|insnp
operator|==
name|ready
condition|)
break|break;
name|cur_uops
operator|=
name|ix86_safe_ppro_uops
argument_list|(
operator|*
operator|--
name|insnp
argument_list|)
expr_stmt|;
block|}
comment|/* If so, move it to the head of the line.  */
if|if
condition|(
name|cur_uops
operator|==
name|PPRO_UOPS_FEW
condition|)
name|ix86_reorder_insn
argument_list|(
name|insnp
argument_list|,
name|e_ready
argument_list|)
expr_stmt|;
comment|/* Issue the head of the queue.  */
name|issued_this_cycle
operator|=
literal|1
expr_stmt|;
name|decode
index|[
literal|0
index|]
operator|=
operator|*
name|e_ready
operator|--
expr_stmt|;
block|}
comment|/* Look for simple insns to fill in the other two slots.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|3
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|decode
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|ready
operator|>=
name|e_ready
condition|)
goto|goto
name|ppro_done
goto|;
name|insnp
operator|=
name|e_ready
expr_stmt|;
name|cur_uops
operator|=
name|ix86_safe_ppro_uops
argument_list|(
operator|*
name|insnp
argument_list|)
expr_stmt|;
while|while
condition|(
name|cur_uops
operator|!=
name|PPRO_UOPS_ONE
condition|)
block|{
if|if
condition|(
name|insnp
operator|==
name|ready
condition|)
break|break;
name|cur_uops
operator|=
name|ix86_safe_ppro_uops
argument_list|(
operator|*
operator|--
name|insnp
argument_list|)
expr_stmt|;
block|}
comment|/* Found one.  Move it to the head of the queue and issue it.  */
if|if
condition|(
name|cur_uops
operator|==
name|PPRO_UOPS_ONE
condition|)
block|{
name|ix86_reorder_insn
argument_list|(
name|insnp
argument_list|,
name|e_ready
argument_list|)
expr_stmt|;
name|decode
index|[
name|i
index|]
operator|=
operator|*
name|e_ready
operator|--
expr_stmt|;
name|issued_this_cycle
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* ??? Didn't find one.  Ideally, here we would do a lazy split 	   of 2-uop insns, issue one and queue the other.  */
block|}
name|ppro_done
label|:
if|if
condition|(
name|issued_this_cycle
operator|==
literal|0
condition|)
name|issued_this_cycle
operator|=
literal|1
expr_stmt|;
name|ix86_sched_data
operator|.
name|ppro
operator|.
name|issued_this_cycle
operator|=
name|issued_this_cycle
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We are about to being issuing insns for this clock cycle.    Override the default sort algorithm to better slot instructions.  */
end_comment

begin_function
specifier|static
name|int
name|ix86_sched_reorder
parameter_list|(
name|dump
parameter_list|,
name|sched_verbose
parameter_list|,
name|ready
parameter_list|,
name|n_readyp
parameter_list|,
name|clock_var
parameter_list|)
name|FILE
modifier|*
name|dump
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|sched_verbose
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|rtx
modifier|*
name|ready
decl_stmt|;
name|int
modifier|*
name|n_readyp
decl_stmt|;
name|int
name|clock_var
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|int
name|n_ready
init|=
operator|*
name|n_readyp
decl_stmt|;
name|rtx
modifier|*
name|e_ready
init|=
name|ready
operator|+
name|n_ready
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|n_ready
operator|<
literal|2
condition|)
goto|goto
name|out
goto|;
switch|switch
condition|(
name|ix86_cpu
condition|)
block|{
default|default:
break|break;
case|case
name|PROCESSOR_PENTIUM
case|:
name|ix86_sched_reorder_pentium
argument_list|(
name|ready
argument_list|,
name|e_ready
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROCESSOR_PENTIUMPRO
case|:
name|ix86_sched_reorder_ppro
argument_list|(
name|ready
argument_list|,
name|e_ready
argument_list|)
expr_stmt|;
break|break;
block|}
name|out
label|:
return|return
name|ix86_issue_rate
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/* We are about to issue INSN.  Return the number of insns left on the    ready queue that can be issued this cycle.  */
end_comment

begin_function
specifier|static
name|int
name|ix86_variable_issue
parameter_list|(
name|dump
parameter_list|,
name|sched_verbose
parameter_list|,
name|insn
parameter_list|,
name|can_issue_more
parameter_list|)
name|FILE
modifier|*
name|dump
decl_stmt|;
name|int
name|sched_verbose
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|can_issue_more
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|ix86_cpu
condition|)
block|{
default|default:
return|return
name|can_issue_more
operator|-
literal|1
return|;
case|case
name|PROCESSOR_PENTIUMPRO
case|:
block|{
name|enum
name|attr_ppro_uops
name|uops
init|=
name|ix86_safe_ppro_uops
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|uops
operator|==
name|PPRO_UOPS_MANY
condition|)
block|{
if|if
condition|(
name|sched_verbose
condition|)
name|ix86_dump_ppro_packet
argument_list|(
name|dump
argument_list|)
expr_stmt|;
name|ix86_sched_data
operator|.
name|ppro
operator|.
name|decode
index|[
literal|0
index|]
operator|=
name|insn
expr_stmt|;
name|ix86_sched_data
operator|.
name|ppro
operator|.
name|decode
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|ix86_sched_data
operator|.
name|ppro
operator|.
name|decode
index|[
literal|2
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|sched_verbose
condition|)
name|ix86_dump_ppro_packet
argument_list|(
name|dump
argument_list|)
expr_stmt|;
name|ix86_sched_data
operator|.
name|ppro
operator|.
name|decode
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|uops
operator|==
name|PPRO_UOPS_FEW
condition|)
block|{
if|if
condition|(
name|sched_verbose
condition|)
name|ix86_dump_ppro_packet
argument_list|(
name|dump
argument_list|)
expr_stmt|;
name|ix86_sched_data
operator|.
name|ppro
operator|.
name|decode
index|[
literal|0
index|]
operator|=
name|insn
expr_stmt|;
name|ix86_sched_data
operator|.
name|ppro
operator|.
name|decode
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|ix86_sched_data
operator|.
name|ppro
operator|.
name|decode
index|[
literal|2
index|]
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|ix86_sched_data
operator|.
name|ppro
operator|.
name|decode
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
name|ix86_sched_data
operator|.
name|ppro
operator|.
name|decode
index|[
name|i
index|]
operator|=
name|insn
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|==
literal|3
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|sched_verbose
condition|)
name|ix86_dump_ppro_packet
argument_list|(
name|dump
argument_list|)
expr_stmt|;
name|ix86_sched_data
operator|.
name|ppro
operator|.
name|decode
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
name|ix86_sched_data
operator|.
name|ppro
operator|.
name|decode
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|ix86_sched_data
operator|.
name|ppro
operator|.
name|decode
index|[
literal|2
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
return|return
operator|--
name|ix86_sched_data
operator|.
name|ppro
operator|.
name|issued_this_cycle
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Walk through INSNS and look for MEM references whose address is DSTREG or    SRCREG and set the memory attribute to those of DSTREF and SRCREF, as    appropriate.  */
end_comment

begin_function
name|void
name|ix86_set_move_mem_attrs
parameter_list|(
name|insns
parameter_list|,
name|dstref
parameter_list|,
name|srcref
parameter_list|,
name|dstreg
parameter_list|,
name|srcreg
parameter_list|)
name|rtx
name|insns
decl_stmt|;
name|rtx
name|dstref
decl_stmt|,
name|srcref
decl_stmt|,
name|dstreg
decl_stmt|,
name|srcreg
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|insns
init|;
name|insn
operator|!=
literal|0
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
name|ix86_set_move_mem_attrs_1
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|dstref
argument_list|,
name|srcref
argument_list|,
name|dstreg
argument_list|,
name|srcreg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Subroutine of above to actually do the updating by recursively walking    the rtx.  */
end_comment

begin_function
specifier|static
name|void
name|ix86_set_move_mem_attrs_1
parameter_list|(
name|x
parameter_list|,
name|dstref
parameter_list|,
name|srcref
parameter_list|,
name|dstreg
parameter_list|,
name|srcreg
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|dstref
decl_stmt|,
name|srcref
decl_stmt|,
name|dstreg
decl_stmt|,
name|srcreg
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|format_ptr
init|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|MEM
operator|&&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|dstreg
condition|)
name|MEM_COPY_ATTRIBUTES
argument_list|(
name|x
argument_list|,
name|dstref
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|MEM
operator|&&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|srcreg
condition|)
name|MEM_COPY_ATTRIBUTES
argument_list|(
name|x
argument_list|,
name|srcref
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
condition|;
name|i
operator|++
operator|,
name|format_ptr
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|format_ptr
operator|==
literal|'e'
condition|)
name|ix86_set_move_mem_attrs_1
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|dstref
argument_list|,
name|srcref
argument_list|,
name|dstreg
argument_list|,
name|srcreg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|format_ptr
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|ix86_set_move_mem_attrs_1
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|dstref
argument_list|,
name|srcref
argument_list|,
name|dstreg
argument_list|,
name|srcreg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compute the alignment given to a constant that is being placed in memory.    EXP is the constant and ALIGN is the alignment that the object would    ordinarily have.    The value of this function is used instead of that alignment to align    the object.  */
end_comment

begin_function
name|int
name|ix86_constant_alignment
parameter_list|(
name|exp
parameter_list|,
name|align
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|int
name|align
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|REAL_CST
condition|)
block|{
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|DFmode
operator|&&
name|align
operator|<
literal|64
condition|)
return|return
literal|64
return|;
elseif|else
if|if
condition|(
name|ALIGN_MODE_128
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|align
operator|<
literal|128
condition|)
return|return
literal|128
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|STRING_CST
operator|&&
name|TREE_STRING_LENGTH
argument_list|(
name|exp
argument_list|)
operator|>=
literal|31
operator|&&
name|align
operator|<
literal|256
condition|)
return|return
literal|256
return|;
return|return
name|align
return|;
block|}
end_function

begin_comment
comment|/* Compute the alignment for a static variable.    TYPE is the data type, and ALIGN is the alignment that    the object would ordinarily have.  The value of this function is used    instead of that alignment to align the object.  */
end_comment

begin_function
name|int
name|ix86_data_alignment
parameter_list|(
name|type
parameter_list|,
name|align
parameter_list|)
name|tree
name|type
decl_stmt|;
name|int
name|align
decl_stmt|;
block|{
if|if
condition|(
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|>=
literal|256
operator|||
name|TREE_INT_CST_HIGH
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
operator|&&
name|align
operator|<
literal|256
condition|)
return|return
literal|256
return|;
comment|/* x86-64 ABI requires arrays greater than 16 bytes to be aligned      to 16byte boundary.  */
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
if|if
condition|(
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|>=
literal|128
operator|||
name|TREE_INT_CST_HIGH
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
operator|&&
name|align
operator|<
literal|128
condition|)
return|return
literal|128
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|DFmode
operator|&&
name|align
operator|<
literal|64
condition|)
return|return
literal|64
return|;
if|if
condition|(
name|ALIGN_MODE_128
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|align
operator|<
literal|128
condition|)
return|return
literal|128
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|COMPLEX_TYPE
condition|)
block|{
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|DCmode
operator|&&
name|align
operator|<
literal|64
condition|)
return|return
literal|64
return|;
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|XCmode
operator|&&
name|align
operator|<
literal|128
condition|)
return|return
literal|128
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|QUAL_UNION_TYPE
operator|)
operator|&&
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_MODE
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|DFmode
operator|&&
name|align
operator|<
literal|64
condition|)
return|return
literal|64
return|;
if|if
condition|(
name|ALIGN_MODE_128
argument_list|(
name|DECL_MODE
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|align
operator|<
literal|128
condition|)
return|return
literal|128
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REAL_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VECTOR_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
condition|)
block|{
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|DFmode
operator|&&
name|align
operator|<
literal|64
condition|)
return|return
literal|64
return|;
if|if
condition|(
name|ALIGN_MODE_128
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
name|align
operator|<
literal|128
condition|)
return|return
literal|128
return|;
block|}
return|return
name|align
return|;
block|}
end_function

begin_comment
comment|/* Compute the alignment for a local variable.    TYPE is the data type, and ALIGN is the alignment that    the object would ordinarily have.  The value of this macro is used    instead of that alignment to align the object.  */
end_comment

begin_function
name|int
name|ix86_local_alignment
parameter_list|(
name|type
parameter_list|,
name|align
parameter_list|)
name|tree
name|type
decl_stmt|;
name|int
name|align
decl_stmt|;
block|{
comment|/* x86-64 ABI requires arrays greater than 16 bytes to be aligned      to 16byte boundary.  */
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
if|if
condition|(
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|>=
literal|16
operator|||
name|TREE_INT_CST_HIGH
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
operator|&&
name|align
operator|<
literal|128
condition|)
return|return
literal|128
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|DFmode
operator|&&
name|align
operator|<
literal|64
condition|)
return|return
literal|64
return|;
if|if
condition|(
name|ALIGN_MODE_128
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|align
operator|<
literal|128
condition|)
return|return
literal|128
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|COMPLEX_TYPE
condition|)
block|{
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|DCmode
operator|&&
name|align
operator|<
literal|64
condition|)
return|return
literal|64
return|;
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|XCmode
operator|&&
name|align
operator|<
literal|128
condition|)
return|return
literal|128
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|QUAL_UNION_TYPE
operator|)
operator|&&
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_MODE
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|DFmode
operator|&&
name|align
operator|<
literal|64
condition|)
return|return
literal|64
return|;
if|if
condition|(
name|ALIGN_MODE_128
argument_list|(
name|DECL_MODE
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|align
operator|<
literal|128
condition|)
return|return
literal|128
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REAL_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VECTOR_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
condition|)
block|{
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|DFmode
operator|&&
name|align
operator|<
literal|64
condition|)
return|return
literal|64
return|;
if|if
condition|(
name|ALIGN_MODE_128
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
name|align
operator|<
literal|128
condition|)
return|return
literal|128
return|;
block|}
return|return
name|align
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit RTL insns to initialize the variable parts of a trampoline.    FNADDR is an RTX for the address of the function's pure code.    CXT is an RTX for the static chain value for the function.  */
end_comment

begin_function
name|void
name|x86_initialize_trampoline
parameter_list|(
name|tramp
parameter_list|,
name|fnaddr
parameter_list|,
name|cxt
parameter_list|)
name|rtx
name|tramp
decl_stmt|,
name|fnaddr
decl_stmt|,
name|cxt
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|TARGET_64BIT
condition|)
block|{
comment|/* Compute offset from the end of the jmp to the target function.  */
name|rtx
name|disp
init|=
name|expand_binop
argument_list|(
name|SImode
argument_list|,
name|sub_optab
argument_list|,
name|fnaddr
argument_list|,
name|plus_constant
argument_list|(
name|tramp
argument_list|,
literal|10
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_DIRECT
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|QImode
argument_list|,
name|tramp
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|trunc_int_for_mode
argument_list|(
literal|0xb9
argument_list|,
name|QImode
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|tramp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|cxt
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|QImode
argument_list|,
name|plus_constant
argument_list|(
name|tramp
argument_list|,
literal|5
argument_list|)
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|trunc_int_for_mode
argument_list|(
literal|0xe9
argument_list|,
name|QImode
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|tramp
argument_list|,
literal|6
argument_list|)
argument_list|)
argument_list|,
name|disp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|offset
init|=
literal|0
decl_stmt|;
comment|/* Try to load address using shorter movl instead of movabs.          We may want to support movq for kernel mode, but kernel does not use          trampolines at the moment.  */
if|if
condition|(
name|x86_64_zero_extended_value
argument_list|(
name|fnaddr
argument_list|)
condition|)
block|{
name|fnaddr
operator|=
name|copy_to_mode_reg
argument_list|(
name|DImode
argument_list|,
name|fnaddr
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|HImode
argument_list|,
name|plus_constant
argument_list|(
name|tramp
argument_list|,
name|offset
argument_list|)
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|trunc_int_for_mode
argument_list|(
literal|0xbb41
argument_list|,
name|HImode
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|tramp
argument_list|,
name|offset
operator|+
literal|2
argument_list|)
argument_list|)
argument_list|,
name|gen_lowpart
argument_list|(
name|SImode
argument_list|,
name|fnaddr
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|6
expr_stmt|;
block|}
else|else
block|{
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|HImode
argument_list|,
name|plus_constant
argument_list|(
name|tramp
argument_list|,
name|offset
argument_list|)
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|trunc_int_for_mode
argument_list|(
literal|0xbb49
argument_list|,
name|HImode
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|DImode
argument_list|,
name|plus_constant
argument_list|(
name|tramp
argument_list|,
name|offset
operator|+
literal|2
argument_list|)
argument_list|)
argument_list|,
name|fnaddr
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|10
expr_stmt|;
block|}
comment|/* Load static chain using movabs to r10.  */
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|HImode
argument_list|,
name|plus_constant
argument_list|(
name|tramp
argument_list|,
name|offset
argument_list|)
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|trunc_int_for_mode
argument_list|(
literal|0xba49
argument_list|,
name|HImode
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|DImode
argument_list|,
name|plus_constant
argument_list|(
name|tramp
argument_list|,
name|offset
operator|+
literal|2
argument_list|)
argument_list|)
argument_list|,
name|cxt
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|10
expr_stmt|;
comment|/* Jump to the r11 */
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|HImode
argument_list|,
name|plus_constant
argument_list|(
name|tramp
argument_list|,
name|offset
argument_list|)
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|trunc_int_for_mode
argument_list|(
literal|0xff49
argument_list|,
name|HImode
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|QImode
argument_list|,
name|plus_constant
argument_list|(
name|tramp
argument_list|,
name|offset
operator|+
literal|2
argument_list|)
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|trunc_int_for_mode
argument_list|(
literal|0xe3
argument_list|,
name|QImode
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
name|offset
operator|>
name|TRAMPOLINE_SIZE
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_define
define|#
directive|define
name|def_builtin
parameter_list|(
name|MASK
parameter_list|,
name|NAME
parameter_list|,
name|TYPE
parameter_list|,
name|CODE
parameter_list|)
define|\
value|do {									\   if ((MASK)& target_flags)						\     builtin_function ((NAME), (TYPE), (CODE), BUILT_IN_MD, NULL);	\ } while (0)
end_define

begin_struct
struct|struct
name|builtin_description
block|{
specifier|const
name|unsigned
name|int
name|mask
decl_stmt|;
specifier|const
name|enum
name|insn_code
name|icode
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
specifier|const
name|enum
name|ix86_builtins
name|code
decl_stmt|;
specifier|const
name|enum
name|rtx_code
name|comparison
decl_stmt|;
specifier|const
name|unsigned
name|int
name|flag
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|builtin_description
name|bdesc_comi
index|[]
init|=
block|{
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_comi
block|,
literal|"__builtin_ia32_comieq"
block|,
name|IX86_BUILTIN_COMIEQSS
block|,
name|EQ
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_comi
block|,
literal|"__builtin_ia32_comilt"
block|,
name|IX86_BUILTIN_COMILTSS
block|,
name|LT
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_comi
block|,
literal|"__builtin_ia32_comile"
block|,
name|IX86_BUILTIN_COMILESS
block|,
name|LE
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_comi
block|,
literal|"__builtin_ia32_comigt"
block|,
name|IX86_BUILTIN_COMIGTSS
block|,
name|LT
block|,
literal|1
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_comi
block|,
literal|"__builtin_ia32_comige"
block|,
name|IX86_BUILTIN_COMIGESS
block|,
name|LE
block|,
literal|1
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_comi
block|,
literal|"__builtin_ia32_comineq"
block|,
name|IX86_BUILTIN_COMINEQSS
block|,
name|NE
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_ucomi
block|,
literal|"__builtin_ia32_ucomieq"
block|,
name|IX86_BUILTIN_UCOMIEQSS
block|,
name|EQ
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_ucomi
block|,
literal|"__builtin_ia32_ucomilt"
block|,
name|IX86_BUILTIN_UCOMILTSS
block|,
name|LT
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_ucomi
block|,
literal|"__builtin_ia32_ucomile"
block|,
name|IX86_BUILTIN_UCOMILESS
block|,
name|LE
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_ucomi
block|,
literal|"__builtin_ia32_ucomigt"
block|,
name|IX86_BUILTIN_UCOMIGTSS
block|,
name|LT
block|,
literal|1
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_ucomi
block|,
literal|"__builtin_ia32_ucomige"
block|,
name|IX86_BUILTIN_UCOMIGESS
block|,
name|LE
block|,
literal|1
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_ucomi
block|,
literal|"__builtin_ia32_ucomineq"
block|,
name|IX86_BUILTIN_UCOMINEQSS
block|,
name|NE
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|builtin_description
name|bdesc_2arg
index|[]
init|=
block|{
comment|/* SSE */
block|{
name|MASK_SSE
block|,
name|CODE_FOR_addv4sf3
block|,
literal|"__builtin_ia32_addps"
block|,
name|IX86_BUILTIN_ADDPS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_subv4sf3
block|,
literal|"__builtin_ia32_subps"
block|,
name|IX86_BUILTIN_SUBPS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_mulv4sf3
block|,
literal|"__builtin_ia32_mulps"
block|,
name|IX86_BUILTIN_MULPS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_divv4sf3
block|,
literal|"__builtin_ia32_divps"
block|,
name|IX86_BUILTIN_DIVPS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_vmaddv4sf3
block|,
literal|"__builtin_ia32_addss"
block|,
name|IX86_BUILTIN_ADDSS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_vmsubv4sf3
block|,
literal|"__builtin_ia32_subss"
block|,
name|IX86_BUILTIN_SUBSS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_vmmulv4sf3
block|,
literal|"__builtin_ia32_mulss"
block|,
name|IX86_BUILTIN_MULSS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_vmdivv4sf3
block|,
literal|"__builtin_ia32_divss"
block|,
name|IX86_BUILTIN_DIVSS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_maskcmpv4sf3
block|,
literal|"__builtin_ia32_cmpeqps"
block|,
name|IX86_BUILTIN_CMPEQPS
block|,
name|EQ
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_maskcmpv4sf3
block|,
literal|"__builtin_ia32_cmpltps"
block|,
name|IX86_BUILTIN_CMPLTPS
block|,
name|LT
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_maskcmpv4sf3
block|,
literal|"__builtin_ia32_cmpleps"
block|,
name|IX86_BUILTIN_CMPLEPS
block|,
name|LE
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_maskcmpv4sf3
block|,
literal|"__builtin_ia32_cmpgtps"
block|,
name|IX86_BUILTIN_CMPGTPS
block|,
name|LT
block|,
literal|1
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_maskcmpv4sf3
block|,
literal|"__builtin_ia32_cmpgeps"
block|,
name|IX86_BUILTIN_CMPGEPS
block|,
name|LE
block|,
literal|1
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_maskcmpv4sf3
block|,
literal|"__builtin_ia32_cmpunordps"
block|,
name|IX86_BUILTIN_CMPUNORDPS
block|,
name|UNORDERED
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_maskncmpv4sf3
block|,
literal|"__builtin_ia32_cmpneqps"
block|,
name|IX86_BUILTIN_CMPNEQPS
block|,
name|EQ
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_maskncmpv4sf3
block|,
literal|"__builtin_ia32_cmpnltps"
block|,
name|IX86_BUILTIN_CMPNLTPS
block|,
name|LT
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_maskncmpv4sf3
block|,
literal|"__builtin_ia32_cmpnleps"
block|,
name|IX86_BUILTIN_CMPNLEPS
block|,
name|LE
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_maskncmpv4sf3
block|,
literal|"__builtin_ia32_cmpngtps"
block|,
name|IX86_BUILTIN_CMPNGTPS
block|,
name|LT
block|,
literal|1
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_maskncmpv4sf3
block|,
literal|"__builtin_ia32_cmpngeps"
block|,
name|IX86_BUILTIN_CMPNGEPS
block|,
name|LE
block|,
literal|1
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_maskncmpv4sf3
block|,
literal|"__builtin_ia32_cmpordps"
block|,
name|IX86_BUILTIN_CMPORDPS
block|,
name|UNORDERED
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_vmmaskcmpv4sf3
block|,
literal|"__builtin_ia32_cmpeqss"
block|,
name|IX86_BUILTIN_CMPEQSS
block|,
name|EQ
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_vmmaskcmpv4sf3
block|,
literal|"__builtin_ia32_cmpltss"
block|,
name|IX86_BUILTIN_CMPLTSS
block|,
name|LT
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_vmmaskcmpv4sf3
block|,
literal|"__builtin_ia32_cmpless"
block|,
name|IX86_BUILTIN_CMPLESS
block|,
name|LE
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_vmmaskcmpv4sf3
block|,
literal|"__builtin_ia32_cmpgtss"
block|,
name|IX86_BUILTIN_CMPGTSS
block|,
name|LT
block|,
literal|1
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_vmmaskcmpv4sf3
block|,
literal|"__builtin_ia32_cmpgess"
block|,
name|IX86_BUILTIN_CMPGESS
block|,
name|LE
block|,
literal|1
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_vmmaskcmpv4sf3
block|,
literal|"__builtin_ia32_cmpunordss"
block|,
name|IX86_BUILTIN_CMPUNORDSS
block|,
name|UNORDERED
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_vmmaskncmpv4sf3
block|,
literal|"__builtin_ia32_cmpneqss"
block|,
name|IX86_BUILTIN_CMPNEQSS
block|,
name|EQ
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_vmmaskncmpv4sf3
block|,
literal|"__builtin_ia32_cmpnltss"
block|,
name|IX86_BUILTIN_CMPNLTSS
block|,
name|LT
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_vmmaskncmpv4sf3
block|,
literal|"__builtin_ia32_cmpnless"
block|,
name|IX86_BUILTIN_CMPNLESS
block|,
name|LE
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_vmmaskncmpv4sf3
block|,
literal|"__builtin_ia32_cmpngtss"
block|,
name|IX86_BUILTIN_CMPNGTSS
block|,
name|LT
block|,
literal|1
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_vmmaskncmpv4sf3
block|,
literal|"__builtin_ia32_cmpngess"
block|,
name|IX86_BUILTIN_CMPNGESS
block|,
name|LE
block|,
literal|1
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_vmmaskncmpv4sf3
block|,
literal|"__builtin_ia32_cmpordss"
block|,
name|IX86_BUILTIN_CMPORDSS
block|,
name|UNORDERED
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sminv4sf3
block|,
literal|"__builtin_ia32_minps"
block|,
name|IX86_BUILTIN_MINPS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_smaxv4sf3
block|,
literal|"__builtin_ia32_maxps"
block|,
name|IX86_BUILTIN_MAXPS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_vmsminv4sf3
block|,
literal|"__builtin_ia32_minss"
block|,
name|IX86_BUILTIN_MINSS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_vmsmaxv4sf3
block|,
literal|"__builtin_ia32_maxss"
block|,
name|IX86_BUILTIN_MAXSS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_movss
block|,
literal|"__builtin_ia32_movss"
block|,
name|IX86_BUILTIN_MOVSS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_movhlps
block|,
literal|"__builtin_ia32_movhlps"
block|,
name|IX86_BUILTIN_MOVHLPS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_movlhps
block|,
literal|"__builtin_ia32_movlhps"
block|,
name|IX86_BUILTIN_MOVLHPS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_unpckhps
block|,
literal|"__builtin_ia32_unpckhps"
block|,
name|IX86_BUILTIN_UNPCKHPS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_unpcklps
block|,
literal|"__builtin_ia32_unpcklps"
block|,
name|IX86_BUILTIN_UNPCKLPS
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* MMX */
block|{
name|MASK_MMX
block|,
name|CODE_FOR_addv8qi3
block|,
literal|"__builtin_ia32_paddb"
block|,
name|IX86_BUILTIN_PADDB
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_addv4hi3
block|,
literal|"__builtin_ia32_paddw"
block|,
name|IX86_BUILTIN_PADDW
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_addv2si3
block|,
literal|"__builtin_ia32_paddd"
block|,
name|IX86_BUILTIN_PADDD
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_subv8qi3
block|,
literal|"__builtin_ia32_psubb"
block|,
name|IX86_BUILTIN_PSUBB
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_subv4hi3
block|,
literal|"__builtin_ia32_psubw"
block|,
name|IX86_BUILTIN_PSUBW
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_subv2si3
block|,
literal|"__builtin_ia32_psubd"
block|,
name|IX86_BUILTIN_PSUBD
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_ssaddv8qi3
block|,
literal|"__builtin_ia32_paddsb"
block|,
name|IX86_BUILTIN_PADDSB
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_ssaddv4hi3
block|,
literal|"__builtin_ia32_paddsw"
block|,
name|IX86_BUILTIN_PADDSW
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_sssubv8qi3
block|,
literal|"__builtin_ia32_psubsb"
block|,
name|IX86_BUILTIN_PSUBSB
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_sssubv4hi3
block|,
literal|"__builtin_ia32_psubsw"
block|,
name|IX86_BUILTIN_PSUBSW
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_usaddv8qi3
block|,
literal|"__builtin_ia32_paddusb"
block|,
name|IX86_BUILTIN_PADDUSB
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_usaddv4hi3
block|,
literal|"__builtin_ia32_paddusw"
block|,
name|IX86_BUILTIN_PADDUSW
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_ussubv8qi3
block|,
literal|"__builtin_ia32_psubusb"
block|,
name|IX86_BUILTIN_PSUBUSB
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_ussubv4hi3
block|,
literal|"__builtin_ia32_psubusw"
block|,
name|IX86_BUILTIN_PSUBUSW
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mulv4hi3
block|,
literal|"__builtin_ia32_pmullw"
block|,
name|IX86_BUILTIN_PMULLW
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_smulv4hi3_highpart
block|,
literal|"__builtin_ia32_pmulhw"
block|,
name|IX86_BUILTIN_PMULHW
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
operator||
name|MASK_3DNOW_A
block|,
name|CODE_FOR_umulv4hi3_highpart
block|,
literal|"__builtin_ia32_pmulhuw"
block|,
name|IX86_BUILTIN_PMULHUW
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_anddi3
block|,
literal|"__builtin_ia32_pand"
block|,
name|IX86_BUILTIN_PAND
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_nanddi3
block|,
literal|"__builtin_ia32_pandn"
block|,
name|IX86_BUILTIN_PANDN
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_iordi3
block|,
literal|"__builtin_ia32_por"
block|,
name|IX86_BUILTIN_POR
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_xordi3
block|,
literal|"__builtin_ia32_pxor"
block|,
name|IX86_BUILTIN_PXOR
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
operator||
name|MASK_3DNOW_A
block|,
name|CODE_FOR_mmx_uavgv8qi3
block|,
literal|"__builtin_ia32_pavgb"
block|,
name|IX86_BUILTIN_PAVGB
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
operator||
name|MASK_3DNOW_A
block|,
name|CODE_FOR_mmx_uavgv4hi3
block|,
literal|"__builtin_ia32_pavgw"
block|,
name|IX86_BUILTIN_PAVGW
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_eqv8qi3
block|,
literal|"__builtin_ia32_pcmpeqb"
block|,
name|IX86_BUILTIN_PCMPEQB
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_eqv4hi3
block|,
literal|"__builtin_ia32_pcmpeqw"
block|,
name|IX86_BUILTIN_PCMPEQW
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_eqv2si3
block|,
literal|"__builtin_ia32_pcmpeqd"
block|,
name|IX86_BUILTIN_PCMPEQD
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_gtv8qi3
block|,
literal|"__builtin_ia32_pcmpgtb"
block|,
name|IX86_BUILTIN_PCMPGTB
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_gtv4hi3
block|,
literal|"__builtin_ia32_pcmpgtw"
block|,
name|IX86_BUILTIN_PCMPGTW
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_gtv2si3
block|,
literal|"__builtin_ia32_pcmpgtd"
block|,
name|IX86_BUILTIN_PCMPGTD
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
operator||
name|MASK_3DNOW_A
block|,
name|CODE_FOR_umaxv8qi3
block|,
literal|"__builtin_ia32_pmaxub"
block|,
name|IX86_BUILTIN_PMAXUB
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
operator||
name|MASK_3DNOW_A
block|,
name|CODE_FOR_smaxv4hi3
block|,
literal|"__builtin_ia32_pmaxsw"
block|,
name|IX86_BUILTIN_PMAXSW
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
operator||
name|MASK_3DNOW_A
block|,
name|CODE_FOR_uminv8qi3
block|,
literal|"__builtin_ia32_pminub"
block|,
name|IX86_BUILTIN_PMINUB
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
operator||
name|MASK_3DNOW_A
block|,
name|CODE_FOR_sminv4hi3
block|,
literal|"__builtin_ia32_pminsw"
block|,
name|IX86_BUILTIN_PMINSW
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_punpckhbw
block|,
literal|"__builtin_ia32_punpckhbw"
block|,
name|IX86_BUILTIN_PUNPCKHBW
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_punpckhwd
block|,
literal|"__builtin_ia32_punpckhwd"
block|,
name|IX86_BUILTIN_PUNPCKHWD
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_punpckhdq
block|,
literal|"__builtin_ia32_punpckhdq"
block|,
name|IX86_BUILTIN_PUNPCKHDQ
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_punpcklbw
block|,
literal|"__builtin_ia32_punpcklbw"
block|,
name|IX86_BUILTIN_PUNPCKLBW
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_punpcklwd
block|,
literal|"__builtin_ia32_punpcklwd"
block|,
name|IX86_BUILTIN_PUNPCKLWD
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_punpckldq
block|,
literal|"__builtin_ia32_punpckldq"
block|,
name|IX86_BUILTIN_PUNPCKLDQ
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Special.  */
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_packsswb
block|,
literal|0
block|,
name|IX86_BUILTIN_PACKSSWB
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_packssdw
block|,
literal|0
block|,
name|IX86_BUILTIN_PACKSSDW
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_packuswb
block|,
literal|0
block|,
name|IX86_BUILTIN_PACKUSWB
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_cvtpi2ps
block|,
literal|0
block|,
name|IX86_BUILTIN_CVTPI2PS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_cvtsi2ss
block|,
literal|0
block|,
name|IX86_BUILTIN_CVTSI2SS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_ashlv4hi3
block|,
literal|0
block|,
name|IX86_BUILTIN_PSLLW
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_ashlv4hi3
block|,
literal|0
block|,
name|IX86_BUILTIN_PSLLWI
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_ashlv2si3
block|,
literal|0
block|,
name|IX86_BUILTIN_PSLLD
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_ashlv2si3
block|,
literal|0
block|,
name|IX86_BUILTIN_PSLLDI
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_ashldi3
block|,
literal|0
block|,
name|IX86_BUILTIN_PSLLQ
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_ashldi3
block|,
literal|0
block|,
name|IX86_BUILTIN_PSLLQI
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_lshrv4hi3
block|,
literal|0
block|,
name|IX86_BUILTIN_PSRLW
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_lshrv4hi3
block|,
literal|0
block|,
name|IX86_BUILTIN_PSRLWI
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_lshrv2si3
block|,
literal|0
block|,
name|IX86_BUILTIN_PSRLD
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_lshrv2si3
block|,
literal|0
block|,
name|IX86_BUILTIN_PSRLDI
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_lshrdi3
block|,
literal|0
block|,
name|IX86_BUILTIN_PSRLQ
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_lshrdi3
block|,
literal|0
block|,
name|IX86_BUILTIN_PSRLQI
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_ashrv4hi3
block|,
literal|0
block|,
name|IX86_BUILTIN_PSRAW
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_ashrv4hi3
block|,
literal|0
block|,
name|IX86_BUILTIN_PSRAWI
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_ashrv2si3
block|,
literal|0
block|,
name|IX86_BUILTIN_PSRAD
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_ashrv2si3
block|,
literal|0
block|,
name|IX86_BUILTIN_PSRADI
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
operator||
name|MASK_3DNOW_A
block|,
name|CODE_FOR_mmx_psadbw
block|,
literal|0
block|,
name|IX86_BUILTIN_PSADBW
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_pmaddwd
block|,
literal|0
block|,
name|IX86_BUILTIN_PMADDWD
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|builtin_description
name|bdesc_1arg
index|[]
init|=
block|{
block|{
name|MASK_SSE
operator||
name|MASK_3DNOW_A
block|,
name|CODE_FOR_mmx_pmovmskb
block|,
literal|0
block|,
name|IX86_BUILTIN_PMOVMSKB
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_movmskps
block|,
literal|0
block|,
name|IX86_BUILTIN_MOVMSKPS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sqrtv4sf2
block|,
literal|0
block|,
name|IX86_BUILTIN_SQRTPS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_rsqrtv4sf2
block|,
literal|0
block|,
name|IX86_BUILTIN_RSQRTPS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_rcpv4sf2
block|,
literal|0
block|,
name|IX86_BUILTIN_RCPPS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_cvtps2pi
block|,
literal|0
block|,
name|IX86_BUILTIN_CVTPS2PI
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_cvtss2si
block|,
literal|0
block|,
name|IX86_BUILTIN_CVTSS2SI
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_cvttps2pi
block|,
literal|0
block|,
name|IX86_BUILTIN_CVTTPS2PI
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_cvttss2si
block|,
literal|0
block|,
name|IX86_BUILTIN_CVTTSS2SI
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|ix86_init_builtins
parameter_list|()
block|{
if|if
condition|(
name|TARGET_MMX
condition|)
name|ix86_init_mmx_sse_builtins
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set up all the MMX/SSE builtins.  This is not called if TARGET_MMX    is zero.  Otherwise, if TARGET_SSE is not set, only expand the MMX    builtins.  */
end_comment

begin_function
specifier|static
name|void
name|ix86_init_mmx_sse_builtins
parameter_list|()
block|{
specifier|const
name|struct
name|builtin_description
modifier|*
name|d
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|tree
name|endlink
init|=
name|void_list_node
decl_stmt|;
name|tree
name|pchar_type_node
init|=
name|build_pointer_type
argument_list|(
name|char_type_node
argument_list|)
decl_stmt|;
name|tree
name|pfloat_type_node
init|=
name|build_pointer_type
argument_list|(
name|float_type_node
argument_list|)
decl_stmt|;
name|tree
name|pv2si_type_node
init|=
name|build_pointer_type
argument_list|(
name|V2SI_type_node
argument_list|)
decl_stmt|;
name|tree
name|pdi_type_node
init|=
name|build_pointer_type
argument_list|(
name|long_long_unsigned_type_node
argument_list|)
decl_stmt|;
comment|/* Comparisons.  */
name|tree
name|int_ftype_v4sf_v4sf
init|=
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4SF_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4SF_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v4si_ftype_v4sf_v4sf
init|=
name|build_function_type
argument_list|(
name|V4SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4SF_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4SF_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* MMX/SSE/integer conversions.  */
name|tree
name|int_ftype_v4sf
init|=
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4SF_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|int_ftype_v8qi
init|=
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V8QI_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v4sf_ftype_v4sf_int
init|=
name|build_function_type
argument_list|(
name|V4SF_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4SF_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v4sf_ftype_v4sf_v2si
init|=
name|build_function_type
argument_list|(
name|V4SF_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4SF_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V2SI_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|int_ftype_v4hi_int
init|=
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4HI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v4hi_ftype_v4hi_int_int
init|=
name|build_function_type
argument_list|(
name|V4HI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4HI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Miscellaneous.  */
name|tree
name|v8qi_ftype_v4hi_v4hi
init|=
name|build_function_type
argument_list|(
name|V8QI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4HI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4HI_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v4hi_ftype_v2si_v2si
init|=
name|build_function_type
argument_list|(
name|V4HI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V2SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V2SI_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v4sf_ftype_v4sf_v4sf_int
init|=
name|build_function_type
argument_list|(
name|V4SF_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4SF_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4SF_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v4hi_ftype_v8qi_v8qi
init|=
name|build_function_type
argument_list|(
name|V4HI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V8QI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V8QI_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v2si_ftype_v4hi_v4hi
init|=
name|build_function_type
argument_list|(
name|V2SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4HI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4HI_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v4hi_ftype_v4hi_int
init|=
name|build_function_type
argument_list|(
name|V4HI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4HI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v4hi_ftype_v4hi_di
init|=
name|build_function_type
argument_list|(
name|V4HI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4HI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|long_long_integer_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v2si_ftype_v2si_di
init|=
name|build_function_type
argument_list|(
name|V2SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V2SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|long_long_integer_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|void_ftype_void
init|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|endlink
argument_list|)
decl_stmt|;
name|tree
name|void_ftype_unsigned
init|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|unsigned_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|unsigned_ftype_void
init|=
name|build_function_type
argument_list|(
name|unsigned_type_node
argument_list|,
name|endlink
argument_list|)
decl_stmt|;
name|tree
name|di_ftype_void
init|=
name|build_function_type
argument_list|(
name|long_long_unsigned_type_node
argument_list|,
name|endlink
argument_list|)
decl_stmt|;
name|tree
name|v4sf_ftype_void
init|=
name|build_function_type
argument_list|(
name|V4SF_type_node
argument_list|,
name|endlink
argument_list|)
decl_stmt|;
name|tree
name|v2si_ftype_v4sf
init|=
name|build_function_type
argument_list|(
name|V2SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4SF_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Loads/stores.  */
name|tree
name|maskmovq_args
init|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V8QI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V8QI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|pchar_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|void_ftype_v8qi_v8qi_pchar
init|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|maskmovq_args
argument_list|)
decl_stmt|;
name|tree
name|v4sf_ftype_pfloat
init|=
name|build_function_type
argument_list|(
name|V4SF_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|pfloat_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
decl_stmt|;
comment|/* @@@ the type is bogus */
name|tree
name|v4sf_ftype_v4sf_pv2si
init|=
name|build_function_type
argument_list|(
name|V4SF_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4SF_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|pv2si_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|void_ftype_pv2si_v4sf
init|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|pv2si_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4SF_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|void_ftype_pfloat_v4sf
init|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|pfloat_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4SF_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|void_ftype_pdi_di
init|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|pdi_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|long_long_unsigned_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Normal vector unops.  */
name|tree
name|v4sf_ftype_v4sf
init|=
name|build_function_type
argument_list|(
name|V4SF_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4SF_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Normal vector binops.  */
name|tree
name|v4sf_ftype_v4sf_v4sf
init|=
name|build_function_type
argument_list|(
name|V4SF_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4SF_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4SF_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v8qi_ftype_v8qi_v8qi
init|=
name|build_function_type
argument_list|(
name|V8QI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V8QI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V8QI_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v4hi_ftype_v4hi_v4hi
init|=
name|build_function_type
argument_list|(
name|V4HI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4HI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4HI_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v2si_ftype_v2si_v2si
init|=
name|build_function_type
argument_list|(
name|V2SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V2SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V2SI_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|di_ftype_di_di
init|=
name|build_function_type
argument_list|(
name|long_long_unsigned_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|long_long_unsigned_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|long_long_unsigned_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v2si_ftype_v2sf
init|=
name|build_function_type
argument_list|(
name|V2SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V2SF_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v2sf_ftype_v2si
init|=
name|build_function_type
argument_list|(
name|V2SF_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V2SI_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v2si_ftype_v2si
init|=
name|build_function_type
argument_list|(
name|V2SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V2SI_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v2sf_ftype_v2sf
init|=
name|build_function_type
argument_list|(
name|V2SF_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V2SF_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v2sf_ftype_v2sf_v2sf
init|=
name|build_function_type
argument_list|(
name|V2SF_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V2SF_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V2SF_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v2si_ftype_v2sf_v2sf
init|=
name|build_function_type
argument_list|(
name|V2SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V2SF_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V2SF_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Add all builtins that are more or less simple operations on two      operands.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|d
operator|=
name|bdesc_2arg
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|bdesc_2arg
argument_list|)
operator|/
sizeof|sizeof
expr|*
name|d
condition|;
name|i
operator|++
operator|,
name|d
operator|++
control|)
block|{
comment|/* Use one of the operands; the target can have a different mode for 	 mask-generating compares.  */
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|name
operator|==
literal|0
condition|)
continue|continue;
name|mode
operator|=
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|V4SFmode
case|:
name|type
operator|=
name|v4sf_ftype_v4sf_v4sf
expr_stmt|;
break|break;
case|case
name|V8QImode
case|:
name|type
operator|=
name|v8qi_ftype_v8qi_v8qi
expr_stmt|;
break|break;
case|case
name|V4HImode
case|:
name|type
operator|=
name|v4hi_ftype_v4hi_v4hi
expr_stmt|;
break|break;
case|case
name|V2SImode
case|:
name|type
operator|=
name|v2si_ftype_v2si_v2si
expr_stmt|;
break|break;
case|case
name|DImode
case|:
name|type
operator|=
name|di_ftype_di_di
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Override for comparisons.  */
if|if
condition|(
name|d
operator|->
name|icode
operator|==
name|CODE_FOR_maskcmpv4sf3
operator|||
name|d
operator|->
name|icode
operator|==
name|CODE_FOR_maskncmpv4sf3
operator|||
name|d
operator|->
name|icode
operator|==
name|CODE_FOR_vmmaskcmpv4sf3
operator|||
name|d
operator|->
name|icode
operator|==
name|CODE_FOR_vmmaskncmpv4sf3
condition|)
name|type
operator|=
name|v4si_ftype_v4sf_v4sf
expr_stmt|;
name|def_builtin
argument_list|(
name|d
operator|->
name|mask
argument_list|,
name|d
operator|->
name|name
argument_list|,
name|type
argument_list|,
name|d
operator|->
name|code
argument_list|)
expr_stmt|;
block|}
comment|/* Add the remaining MMX insns with somewhat more complicated types.  */
name|def_builtin
argument_list|(
name|MASK_MMX
argument_list|,
literal|"__builtin_ia32_mmx_zero"
argument_list|,
name|di_ftype_void
argument_list|,
name|IX86_BUILTIN_MMX_ZERO
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_MMX
argument_list|,
literal|"__builtin_ia32_emms"
argument_list|,
name|void_ftype_void
argument_list|,
name|IX86_BUILTIN_EMMS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_MMX
argument_list|,
literal|"__builtin_ia32_ldmxcsr"
argument_list|,
name|void_ftype_unsigned
argument_list|,
name|IX86_BUILTIN_LDMXCSR
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_MMX
argument_list|,
literal|"__builtin_ia32_stmxcsr"
argument_list|,
name|unsigned_ftype_void
argument_list|,
name|IX86_BUILTIN_STMXCSR
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_MMX
argument_list|,
literal|"__builtin_ia32_psllw"
argument_list|,
name|v4hi_ftype_v4hi_di
argument_list|,
name|IX86_BUILTIN_PSLLW
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_MMX
argument_list|,
literal|"__builtin_ia32_pslld"
argument_list|,
name|v2si_ftype_v2si_di
argument_list|,
name|IX86_BUILTIN_PSLLD
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_MMX
argument_list|,
literal|"__builtin_ia32_psllq"
argument_list|,
name|di_ftype_di_di
argument_list|,
name|IX86_BUILTIN_PSLLQ
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_MMX
argument_list|,
literal|"__builtin_ia32_psrlw"
argument_list|,
name|v4hi_ftype_v4hi_di
argument_list|,
name|IX86_BUILTIN_PSRLW
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_MMX
argument_list|,
literal|"__builtin_ia32_psrld"
argument_list|,
name|v2si_ftype_v2si_di
argument_list|,
name|IX86_BUILTIN_PSRLD
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_MMX
argument_list|,
literal|"__builtin_ia32_psrlq"
argument_list|,
name|di_ftype_di_di
argument_list|,
name|IX86_BUILTIN_PSRLQ
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_MMX
argument_list|,
literal|"__builtin_ia32_psraw"
argument_list|,
name|v4hi_ftype_v4hi_di
argument_list|,
name|IX86_BUILTIN_PSRAW
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_MMX
argument_list|,
literal|"__builtin_ia32_psrad"
argument_list|,
name|v2si_ftype_v2si_di
argument_list|,
name|IX86_BUILTIN_PSRAD
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_MMX
argument_list|,
literal|"__builtin_ia32_pshufw"
argument_list|,
name|v4hi_ftype_v4hi_int
argument_list|,
name|IX86_BUILTIN_PSHUFW
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_MMX
argument_list|,
literal|"__builtin_ia32_pmaddwd"
argument_list|,
name|v2si_ftype_v4hi_v4hi
argument_list|,
name|IX86_BUILTIN_PMADDWD
argument_list|)
expr_stmt|;
comment|/* comi/ucomi insns.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|d
operator|=
name|bdesc_comi
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|bdesc_comi
argument_list|)
operator|/
sizeof|sizeof
expr|*
name|d
condition|;
name|i
operator|++
operator|,
name|d
operator|++
control|)
name|def_builtin
argument_list|(
name|d
operator|->
name|mask
argument_list|,
name|d
operator|->
name|name
argument_list|,
name|int_ftype_v4sf_v4sf
argument_list|,
name|d
operator|->
name|code
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_MMX
argument_list|,
literal|"__builtin_ia32_packsswb"
argument_list|,
name|v8qi_ftype_v4hi_v4hi
argument_list|,
name|IX86_BUILTIN_PACKSSWB
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_MMX
argument_list|,
literal|"__builtin_ia32_packssdw"
argument_list|,
name|v4hi_ftype_v2si_v2si
argument_list|,
name|IX86_BUILTIN_PACKSSDW
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_MMX
argument_list|,
literal|"__builtin_ia32_packuswb"
argument_list|,
name|v8qi_ftype_v4hi_v4hi
argument_list|,
name|IX86_BUILTIN_PACKUSWB
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
argument_list|,
literal|"__builtin_ia32_cvtpi2ps"
argument_list|,
name|v4sf_ftype_v4sf_v2si
argument_list|,
name|IX86_BUILTIN_CVTPI2PS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
argument_list|,
literal|"__builtin_ia32_cvtps2pi"
argument_list|,
name|v2si_ftype_v4sf
argument_list|,
name|IX86_BUILTIN_CVTPS2PI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
argument_list|,
literal|"__builtin_ia32_cvtsi2ss"
argument_list|,
name|v4sf_ftype_v4sf_int
argument_list|,
name|IX86_BUILTIN_CVTSI2SS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
argument_list|,
literal|"__builtin_ia32_cvtss2si"
argument_list|,
name|int_ftype_v4sf
argument_list|,
name|IX86_BUILTIN_CVTSS2SI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
argument_list|,
literal|"__builtin_ia32_cvttps2pi"
argument_list|,
name|v2si_ftype_v4sf
argument_list|,
name|IX86_BUILTIN_CVTTPS2PI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
argument_list|,
literal|"__builtin_ia32_cvttss2si"
argument_list|,
name|int_ftype_v4sf
argument_list|,
name|IX86_BUILTIN_CVTTSS2SI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
argument_list|,
literal|"__builtin_ia32_andps"
argument_list|,
name|v4sf_ftype_v4sf_v4sf
argument_list|,
name|IX86_BUILTIN_ANDPS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
argument_list|,
literal|"__builtin_ia32_andnps"
argument_list|,
name|v4sf_ftype_v4sf_v4sf
argument_list|,
name|IX86_BUILTIN_ANDNPS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
argument_list|,
literal|"__builtin_ia32_orps"
argument_list|,
name|v4sf_ftype_v4sf_v4sf
argument_list|,
name|IX86_BUILTIN_ORPS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
argument_list|,
literal|"__builtin_ia32_xorps"
argument_list|,
name|v4sf_ftype_v4sf_v4sf
argument_list|,
name|IX86_BUILTIN_XORPS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
operator||
name|MASK_3DNOW_A
argument_list|,
literal|"__builtin_ia32_pextrw"
argument_list|,
name|int_ftype_v4hi_int
argument_list|,
name|IX86_BUILTIN_PEXTRW
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
operator||
name|MASK_3DNOW_A
argument_list|,
literal|"__builtin_ia32_pinsrw"
argument_list|,
name|v4hi_ftype_v4hi_int_int
argument_list|,
name|IX86_BUILTIN_PINSRW
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
operator||
name|MASK_3DNOW_A
argument_list|,
literal|"__builtin_ia32_maskmovq"
argument_list|,
name|void_ftype_v8qi_v8qi_pchar
argument_list|,
name|IX86_BUILTIN_MASKMOVQ
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
argument_list|,
literal|"__builtin_ia32_loadaps"
argument_list|,
name|v4sf_ftype_pfloat
argument_list|,
name|IX86_BUILTIN_LOADAPS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
argument_list|,
literal|"__builtin_ia32_loadups"
argument_list|,
name|v4sf_ftype_pfloat
argument_list|,
name|IX86_BUILTIN_LOADUPS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
argument_list|,
literal|"__builtin_ia32_loadss"
argument_list|,
name|v4sf_ftype_pfloat
argument_list|,
name|IX86_BUILTIN_LOADSS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
argument_list|,
literal|"__builtin_ia32_storeaps"
argument_list|,
name|void_ftype_pfloat_v4sf
argument_list|,
name|IX86_BUILTIN_STOREAPS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
argument_list|,
literal|"__builtin_ia32_storeups"
argument_list|,
name|void_ftype_pfloat_v4sf
argument_list|,
name|IX86_BUILTIN_STOREUPS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
argument_list|,
literal|"__builtin_ia32_storess"
argument_list|,
name|void_ftype_pfloat_v4sf
argument_list|,
name|IX86_BUILTIN_STORESS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
argument_list|,
literal|"__builtin_ia32_loadhps"
argument_list|,
name|v4sf_ftype_v4sf_pv2si
argument_list|,
name|IX86_BUILTIN_LOADHPS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
argument_list|,
literal|"__builtin_ia32_loadlps"
argument_list|,
name|v4sf_ftype_v4sf_pv2si
argument_list|,
name|IX86_BUILTIN_LOADLPS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
argument_list|,
literal|"__builtin_ia32_storehps"
argument_list|,
name|void_ftype_pv2si_v4sf
argument_list|,
name|IX86_BUILTIN_STOREHPS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
argument_list|,
literal|"__builtin_ia32_storelps"
argument_list|,
name|void_ftype_pv2si_v4sf
argument_list|,
name|IX86_BUILTIN_STORELPS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
argument_list|,
literal|"__builtin_ia32_movmskps"
argument_list|,
name|int_ftype_v4sf
argument_list|,
name|IX86_BUILTIN_MOVMSKPS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
operator||
name|MASK_3DNOW_A
argument_list|,
literal|"__builtin_ia32_pmovmskb"
argument_list|,
name|int_ftype_v8qi
argument_list|,
name|IX86_BUILTIN_PMOVMSKB
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
argument_list|,
literal|"__builtin_ia32_movntps"
argument_list|,
name|void_ftype_pfloat_v4sf
argument_list|,
name|IX86_BUILTIN_MOVNTPS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
operator||
name|MASK_3DNOW_A
argument_list|,
literal|"__builtin_ia32_movntq"
argument_list|,
name|void_ftype_pdi_di
argument_list|,
name|IX86_BUILTIN_MOVNTQ
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
operator||
name|MASK_3DNOW_A
argument_list|,
literal|"__builtin_ia32_sfence"
argument_list|,
name|void_ftype_void
argument_list|,
name|IX86_BUILTIN_SFENCE
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
operator||
name|MASK_3DNOW_A
argument_list|,
literal|"__builtin_ia32_psadbw"
argument_list|,
name|v4hi_ftype_v8qi_v8qi
argument_list|,
name|IX86_BUILTIN_PSADBW
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
argument_list|,
literal|"__builtin_ia32_rcpps"
argument_list|,
name|v4sf_ftype_v4sf
argument_list|,
name|IX86_BUILTIN_RCPPS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
argument_list|,
literal|"__builtin_ia32_rcpss"
argument_list|,
name|v4sf_ftype_v4sf
argument_list|,
name|IX86_BUILTIN_RCPSS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
argument_list|,
literal|"__builtin_ia32_rsqrtps"
argument_list|,
name|v4sf_ftype_v4sf
argument_list|,
name|IX86_BUILTIN_RSQRTPS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
argument_list|,
literal|"__builtin_ia32_rsqrtss"
argument_list|,
name|v4sf_ftype_v4sf
argument_list|,
name|IX86_BUILTIN_RSQRTSS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
argument_list|,
literal|"__builtin_ia32_sqrtps"
argument_list|,
name|v4sf_ftype_v4sf
argument_list|,
name|IX86_BUILTIN_SQRTPS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
argument_list|,
literal|"__builtin_ia32_sqrtss"
argument_list|,
name|v4sf_ftype_v4sf
argument_list|,
name|IX86_BUILTIN_SQRTSS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
argument_list|,
literal|"__builtin_ia32_shufps"
argument_list|,
name|v4sf_ftype_v4sf_v4sf_int
argument_list|,
name|IX86_BUILTIN_SHUFPS
argument_list|)
expr_stmt|;
comment|/* Original 3DNow!  */
name|def_builtin
argument_list|(
name|MASK_3DNOW
argument_list|,
literal|"__builtin_ia32_femms"
argument_list|,
name|void_ftype_void
argument_list|,
name|IX86_BUILTIN_FEMMS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_3DNOW
argument_list|,
literal|"__builtin_ia32_pavgusb"
argument_list|,
name|v8qi_ftype_v8qi_v8qi
argument_list|,
name|IX86_BUILTIN_PAVGUSB
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_3DNOW
argument_list|,
literal|"__builtin_ia32_pf2id"
argument_list|,
name|v2si_ftype_v2sf
argument_list|,
name|IX86_BUILTIN_PF2ID
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_3DNOW
argument_list|,
literal|"__builtin_ia32_pfacc"
argument_list|,
name|v2sf_ftype_v2sf_v2sf
argument_list|,
name|IX86_BUILTIN_PFACC
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_3DNOW
argument_list|,
literal|"__builtin_ia32_pfadd"
argument_list|,
name|v2sf_ftype_v2sf_v2sf
argument_list|,
name|IX86_BUILTIN_PFADD
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_3DNOW
argument_list|,
literal|"__builtin_ia32_pfcmpeq"
argument_list|,
name|v2si_ftype_v2sf_v2sf
argument_list|,
name|IX86_BUILTIN_PFCMPEQ
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_3DNOW
argument_list|,
literal|"__builtin_ia32_pfcmpge"
argument_list|,
name|v2si_ftype_v2sf_v2sf
argument_list|,
name|IX86_BUILTIN_PFCMPGE
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_3DNOW
argument_list|,
literal|"__builtin_ia32_pfcmpgt"
argument_list|,
name|v2si_ftype_v2sf_v2sf
argument_list|,
name|IX86_BUILTIN_PFCMPGT
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_3DNOW
argument_list|,
literal|"__builtin_ia32_pfmax"
argument_list|,
name|v2sf_ftype_v2sf_v2sf
argument_list|,
name|IX86_BUILTIN_PFMAX
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_3DNOW
argument_list|,
literal|"__builtin_ia32_pfmin"
argument_list|,
name|v2sf_ftype_v2sf_v2sf
argument_list|,
name|IX86_BUILTIN_PFMIN
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_3DNOW
argument_list|,
literal|"__builtin_ia32_pfmul"
argument_list|,
name|v2sf_ftype_v2sf_v2sf
argument_list|,
name|IX86_BUILTIN_PFMUL
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_3DNOW
argument_list|,
literal|"__builtin_ia32_pfrcp"
argument_list|,
name|v2sf_ftype_v2sf
argument_list|,
name|IX86_BUILTIN_PFRCP
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_3DNOW
argument_list|,
literal|"__builtin_ia32_pfrcpit1"
argument_list|,
name|v2sf_ftype_v2sf_v2sf
argument_list|,
name|IX86_BUILTIN_PFRCPIT1
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_3DNOW
argument_list|,
literal|"__builtin_ia32_pfrcpit2"
argument_list|,
name|v2sf_ftype_v2sf_v2sf
argument_list|,
name|IX86_BUILTIN_PFRCPIT2
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_3DNOW
argument_list|,
literal|"__builtin_ia32_pfrsqrt"
argument_list|,
name|v2sf_ftype_v2sf
argument_list|,
name|IX86_BUILTIN_PFRSQRT
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_3DNOW
argument_list|,
literal|"__builtin_ia32_pfrsqit1"
argument_list|,
name|v2sf_ftype_v2sf_v2sf
argument_list|,
name|IX86_BUILTIN_PFRSQIT1
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_3DNOW
argument_list|,
literal|"__builtin_ia32_pfsub"
argument_list|,
name|v2sf_ftype_v2sf_v2sf
argument_list|,
name|IX86_BUILTIN_PFSUB
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_3DNOW
argument_list|,
literal|"__builtin_ia32_pfsubr"
argument_list|,
name|v2sf_ftype_v2sf_v2sf
argument_list|,
name|IX86_BUILTIN_PFSUBR
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_3DNOW
argument_list|,
literal|"__builtin_ia32_pi2fd"
argument_list|,
name|v2sf_ftype_v2si
argument_list|,
name|IX86_BUILTIN_PI2FD
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_3DNOW
argument_list|,
literal|"__builtin_ia32_pmulhrw"
argument_list|,
name|v4hi_ftype_v4hi_v4hi
argument_list|,
name|IX86_BUILTIN_PMULHRW
argument_list|)
expr_stmt|;
comment|/* 3DNow! extension as used in the Athlon CPU.  */
name|def_builtin
argument_list|(
name|MASK_3DNOW_A
argument_list|,
literal|"__builtin_ia32_pf2iw"
argument_list|,
name|v2si_ftype_v2sf
argument_list|,
name|IX86_BUILTIN_PF2IW
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_3DNOW_A
argument_list|,
literal|"__builtin_ia32_pfnacc"
argument_list|,
name|v2sf_ftype_v2sf_v2sf
argument_list|,
name|IX86_BUILTIN_PFNACC
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_3DNOW_A
argument_list|,
literal|"__builtin_ia32_pfpnacc"
argument_list|,
name|v2sf_ftype_v2sf_v2sf
argument_list|,
name|IX86_BUILTIN_PFPNACC
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_3DNOW_A
argument_list|,
literal|"__builtin_ia32_pi2fw"
argument_list|,
name|v2sf_ftype_v2si
argument_list|,
name|IX86_BUILTIN_PI2FW
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_3DNOW_A
argument_list|,
literal|"__builtin_ia32_pswapdsf"
argument_list|,
name|v2sf_ftype_v2sf
argument_list|,
name|IX86_BUILTIN_PSWAPDSF
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_3DNOW_A
argument_list|,
literal|"__builtin_ia32_pswapdsi"
argument_list|,
name|v2si_ftype_v2si
argument_list|,
name|IX86_BUILTIN_PSWAPDSI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
argument_list|,
literal|"__builtin_ia32_setzerops"
argument_list|,
name|v4sf_ftype_void
argument_list|,
name|IX86_BUILTIN_SSE_ZERO
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Errors in the source file can cause expand_expr to return const0_rtx    where we expect a vector.  To avoid crashing, use one of the vector    clear instructions.  */
end_comment

begin_function
specifier|static
name|rtx
name|safe_vector_operand
parameter_list|(
name|x
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|x
operator|!=
name|const0_rtx
condition|)
return|return
name|x
return|;
name|x
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|VALID_MMX_REG_MODE
argument_list|(
name|mode
argument_list|)
operator|||
name|VALID_MMX_REG_MODE_3DNOW
argument_list|(
name|mode
argument_list|)
condition|)
name|emit_insn
argument_list|(
name|gen_mmx_clrdi
argument_list|(
name|mode
operator|==
name|DImode
condition|?
name|x
else|:
name|gen_rtx_SUBREG
argument_list|(
name|DImode
argument_list|,
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_sse_clrv4sf
argument_list|(
name|mode
operator|==
name|V4SFmode
condition|?
name|x
else|:
name|gen_rtx_SUBREG
argument_list|(
name|V4SFmode
argument_list|,
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of ix86_expand_builtin to take care of binop insns.  */
end_comment

begin_function
specifier|static
name|rtx
name|ix86_expand_binop_builtin
parameter_list|(
name|icode
parameter_list|,
name|arglist
parameter_list|,
name|target
parameter_list|)
name|enum
name|insn_code
name|icode
decl_stmt|;
name|tree
name|arglist
decl_stmt|;
name|rtx
name|target
decl_stmt|;
block|{
name|rtx
name|pat
decl_stmt|;
name|tree
name|arg0
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|tree
name|arg1
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|op0
init|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|expand_expr
argument_list|(
name|arg1
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|tmode
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|mode0
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|mode1
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
decl_stmt|;
if|if
condition|(
name|VECTOR_MODE_P
argument_list|(
name|mode0
argument_list|)
condition|)
name|op0
operator|=
name|safe_vector_operand
argument_list|(
name|op0
argument_list|,
name|mode0
argument_list|)
expr_stmt|;
if|if
condition|(
name|VECTOR_MODE_P
argument_list|(
name|mode1
argument_list|)
condition|)
name|op1
operator|=
name|safe_vector_operand
argument_list|(
name|op1
argument_list|,
name|mode1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|tmode
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|target
operator|,
name|tmode
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
comment|/* In case the insn wants input operands in modes different from      the result, abort.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|mode0
operator|||
name|GET_MODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|mode1
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode0
operator|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
operator|)
operator|(
name|op1
operator|,
name|mode1
operator|)
condition|)
name|op1
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode1
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_comment
comment|/* In type_for_mode we restrict the ability to create TImode types     to hosts with 64-bit H_W_I.  So we've defined the SSE logicals    to have a V4SFmode signature.  Convert them in-place to TImode.  */
end_comment

begin_function
specifier|static
name|rtx
name|ix86_expand_timode_binop_builtin
parameter_list|(
name|icode
parameter_list|,
name|arglist
parameter_list|,
name|target
parameter_list|)
name|enum
name|insn_code
name|icode
decl_stmt|;
name|tree
name|arglist
decl_stmt|;
name|rtx
name|target
decl_stmt|;
block|{
name|rtx
name|pat
decl_stmt|;
name|tree
name|arg0
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|tree
name|arg1
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|op0
init|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|expand_expr
argument_list|(
name|arg1
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|op0
operator|=
name|gen_lowpart
argument_list|(
name|TImode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|gen_lowpart
argument_list|(
name|TImode
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|TImode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|TImode
operator|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|TImode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
operator|)
operator|(
name|op1
operator|,
name|TImode
operator|)
condition|)
name|op1
operator|=
name|copy_to_mode_reg
argument_list|(
name|TImode
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|gen_lowpart
argument_list|(
name|V4SFmode
argument_list|,
name|target
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of ix86_expand_builtin to take care of stores.  */
end_comment

begin_function
specifier|static
name|rtx
name|ix86_expand_store_builtin
parameter_list|(
name|icode
parameter_list|,
name|arglist
parameter_list|)
name|enum
name|insn_code
name|icode
decl_stmt|;
name|tree
name|arglist
decl_stmt|;
block|{
name|rtx
name|pat
decl_stmt|;
name|tree
name|arg0
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|tree
name|arg1
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|op0
init|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|expand_expr
argument_list|(
name|arg1
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode0
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|mode1
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
decl_stmt|;
if|if
condition|(
name|VECTOR_MODE_P
argument_list|(
name|mode1
argument_list|)
condition|)
name|op1
operator|=
name|safe_vector_operand
argument_list|(
name|op1
argument_list|,
name|mode1
argument_list|)
expr_stmt|;
name|op0
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode0
argument_list|,
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|op0
argument_list|)
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
condition|)
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of ix86_expand_builtin to take care of unop insns.  */
end_comment

begin_function
specifier|static
name|rtx
name|ix86_expand_unop_builtin
parameter_list|(
name|icode
parameter_list|,
name|arglist
parameter_list|,
name|target
parameter_list|,
name|do_load
parameter_list|)
name|enum
name|insn_code
name|icode
decl_stmt|;
name|tree
name|arglist
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|int
name|do_load
decl_stmt|;
block|{
name|rtx
name|pat
decl_stmt|;
name|tree
name|arg0
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|rtx
name|op0
init|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|tmode
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|mode0
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
decl_stmt|;
if|if
condition|(
operator|!
name|target
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|tmode
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|target
operator|,
name|tmode
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_load
condition|)
name|op0
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode0
argument_list|,
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|op0
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|VECTOR_MODE_P
argument_list|(
name|mode0
argument_list|)
condition|)
name|op0
operator|=
name|safe_vector_operand
argument_list|(
name|op0
argument_list|,
name|mode0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode0
operator|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
block|}
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of ix86_expand_builtin to take care of three special unop insns:    sqrtss, rsqrtss, rcpss.  */
end_comment

begin_function
specifier|static
name|rtx
name|ix86_expand_unop1_builtin
parameter_list|(
name|icode
parameter_list|,
name|arglist
parameter_list|,
name|target
parameter_list|)
name|enum
name|insn_code
name|icode
decl_stmt|;
name|tree
name|arglist
decl_stmt|;
name|rtx
name|target
decl_stmt|;
block|{
name|rtx
name|pat
decl_stmt|;
name|tree
name|arg0
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|rtx
name|op0
init|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|tmode
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|mode0
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
decl_stmt|;
if|if
condition|(
operator|!
name|target
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|tmode
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|target
operator|,
name|tmode
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|VECTOR_MODE_P
argument_list|(
name|mode0
argument_list|)
condition|)
name|op0
operator|=
name|safe_vector_operand
argument_list|(
name|op0
argument_list|,
name|mode0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode0
operator|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|,
name|op0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of ix86_expand_builtin to take care of comparison insns.  */
end_comment

begin_function
specifier|static
name|rtx
name|ix86_expand_sse_compare
parameter_list|(
name|d
parameter_list|,
name|arglist
parameter_list|,
name|target
parameter_list|)
specifier|const
name|struct
name|builtin_description
modifier|*
name|d
decl_stmt|;
name|tree
name|arglist
decl_stmt|;
name|rtx
name|target
decl_stmt|;
block|{
name|rtx
name|pat
decl_stmt|;
name|tree
name|arg0
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|tree
name|arg1
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|op0
init|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|expand_expr
argument_list|(
name|arg1
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|op2
decl_stmt|;
name|enum
name|machine_mode
name|tmode
init|=
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|mode0
init|=
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|mode1
init|=
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
decl_stmt|;
name|enum
name|rtx_code
name|comparison
init|=
name|d
operator|->
name|comparison
decl_stmt|;
if|if
condition|(
name|VECTOR_MODE_P
argument_list|(
name|mode0
argument_list|)
condition|)
name|op0
operator|=
name|safe_vector_operand
argument_list|(
name|op0
argument_list|,
name|mode0
argument_list|)
expr_stmt|;
if|if
condition|(
name|VECTOR_MODE_P
argument_list|(
name|mode1
argument_list|)
condition|)
name|op1
operator|=
name|safe_vector_operand
argument_list|(
name|op1
argument_list|,
name|mode1
argument_list|)
expr_stmt|;
comment|/* Swap operands if we have a comparison that isn't available in      hardware.  */
if|if
condition|(
name|d
operator|->
name|flag
condition|)
block|{
name|rtx
name|tmp
init|=
name|gen_reg_rtx
argument_list|(
name|mode1
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|tmp
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|op1
operator|=
name|op0
expr_stmt|;
name|op0
operator|=
name|tmp
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|target
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|tmode
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|target
operator|,
name|tmode
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode0
operator|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
operator|)
operator|(
name|op1
operator|,
name|mode1
operator|)
condition|)
name|op1
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode1
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|op2
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|comparison
argument_list|,
name|mode0
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|d
operator|->
name|icode
argument_list|)
argument_list|(
name|target
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of ix86_expand_builtin to take care of comi insns.  */
end_comment

begin_function
specifier|static
name|rtx
name|ix86_expand_sse_comi
parameter_list|(
name|d
parameter_list|,
name|arglist
parameter_list|,
name|target
parameter_list|)
specifier|const
name|struct
name|builtin_description
modifier|*
name|d
decl_stmt|;
name|tree
name|arglist
decl_stmt|;
name|rtx
name|target
decl_stmt|;
block|{
name|rtx
name|pat
decl_stmt|;
name|tree
name|arg0
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|tree
name|arg1
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|op0
init|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|expand_expr
argument_list|(
name|arg1
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|op2
decl_stmt|;
name|enum
name|machine_mode
name|mode0
init|=
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|mode1
init|=
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
decl_stmt|;
name|enum
name|rtx_code
name|comparison
init|=
name|d
operator|->
name|comparison
decl_stmt|;
if|if
condition|(
name|VECTOR_MODE_P
argument_list|(
name|mode0
argument_list|)
condition|)
name|op0
operator|=
name|safe_vector_operand
argument_list|(
name|op0
argument_list|,
name|mode0
argument_list|)
expr_stmt|;
if|if
condition|(
name|VECTOR_MODE_P
argument_list|(
name|mode1
argument_list|)
condition|)
name|op1
operator|=
name|safe_vector_operand
argument_list|(
name|op1
argument_list|,
name|mode1
argument_list|)
expr_stmt|;
comment|/* Swap operands if we have a comparison that isn't available in      hardware.  */
if|if
condition|(
name|d
operator|->
name|flag
condition|)
block|{
name|rtx
name|tmp
init|=
name|op1
decl_stmt|;
name|op1
operator|=
name|op0
expr_stmt|;
name|op0
operator|=
name|tmp
expr_stmt|;
block|}
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|target
operator|=
name|gen_rtx_SUBREG
argument_list|(
name|QImode
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode0
operator|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op1
operator|,
name|mode1
operator|)
condition|)
name|op1
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode1
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|op2
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|comparison
argument_list|,
name|mode0
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|d
operator|->
name|icode
argument_list|)
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_STRICT_LOW_PART
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|)
argument_list|,
name|gen_rtx_fmt_ee
argument_list|(
name|comparison
argument_list|,
name|QImode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|CCmode
argument_list|,
name|FLAGS_REG
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SUBREG_REG
argument_list|(
name|target
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Expand an expression EXP that calls a built-in function,    with result going to TARGET if that's convenient    (and in mode MODE if that's convenient).    SUBTARGET may be used as the target for computing one of EXP's operands.    IGNORE is nonzero if the value is to be ignored.  */
end_comment

begin_function
name|rtx
name|ix86_expand_builtin
parameter_list|(
name|exp
parameter_list|,
name|target
parameter_list|,
name|subtarget
parameter_list|,
name|mode
parameter_list|,
name|ignore
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|rtx
name|subtarget
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
specifier|const
name|struct
name|builtin_description
modifier|*
name|d
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|enum
name|insn_code
name|icode
decl_stmt|;
name|tree
name|fndecl
init|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|arg0
decl_stmt|,
name|arg1
decl_stmt|,
name|arg2
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|,
name|op2
decl_stmt|,
name|pat
decl_stmt|;
name|enum
name|machine_mode
name|tmode
decl_stmt|,
name|mode0
decl_stmt|,
name|mode1
decl_stmt|,
name|mode2
decl_stmt|;
name|unsigned
name|int
name|fcode
init|=
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|fcode
condition|)
block|{
case|case
name|IX86_BUILTIN_EMMS
case|:
name|emit_insn
argument_list|(
name|gen_emms
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|IX86_BUILTIN_SFENCE
case|:
name|emit_insn
argument_list|(
name|gen_sfence
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|IX86_BUILTIN_PEXTRW
case|:
name|icode
operator|=
name|CODE_FOR_mmx_pextrw
expr_stmt|;
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_expr
argument_list|(
name|arg1
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tmode
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
expr_stmt|;
name|mode0
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
expr_stmt|;
name|mode1
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode0
operator|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
operator|)
operator|(
name|op1
operator|,
name|mode1
operator|)
condition|)
block|{
comment|/* @@@ better error message */
name|error
argument_list|(
literal|"selector must be an immediate"
argument_list|)
expr_stmt|;
return|return
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
return|;
block|}
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|tmode
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|target
operator|,
name|tmode
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|target
return|;
case|case
name|IX86_BUILTIN_PINSRW
case|:
name|icode
operator|=
name|CODE_FOR_mmx_pinsrw
expr_stmt|;
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_expr
argument_list|(
name|arg1
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op2
operator|=
name|expand_expr
argument_list|(
name|arg2
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tmode
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
expr_stmt|;
name|mode0
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
expr_stmt|;
name|mode1
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
expr_stmt|;
name|mode2
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|3
index|]
operator|.
name|mode
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode0
operator|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
operator|)
operator|(
name|op1
operator|,
name|mode1
operator|)
condition|)
name|op1
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode1
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|3
index|]
operator|.
name|predicate
operator|)
operator|(
name|op2
operator|,
name|mode2
operator|)
condition|)
block|{
comment|/* @@@ better error message */
name|error
argument_list|(
literal|"selector must be an immediate"
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|tmode
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|target
operator|,
name|tmode
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|target
return|;
case|case
name|IX86_BUILTIN_MASKMOVQ
case|:
name|icode
operator|=
name|CODE_FOR_mmx_maskmovq
expr_stmt|;
comment|/* Note the arg order is different from the operand order.  */
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_expr
argument_list|(
name|arg1
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op2
operator|=
name|expand_expr
argument_list|(
name|arg2
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mode0
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
expr_stmt|;
name|mode1
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
expr_stmt|;
name|mode2
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode0
operator|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op1
operator|,
name|mode1
operator|)
condition|)
name|op1
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode1
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
operator|)
operator|(
name|op2
operator|,
name|mode2
operator|)
condition|)
name|op2
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode2
argument_list|,
name|op2
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|IX86_BUILTIN_SQRTSS
case|:
return|return
name|ix86_expand_unop1_builtin
argument_list|(
name|CODE_FOR_vmsqrtv4sf2
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IX86_BUILTIN_RSQRTSS
case|:
return|return
name|ix86_expand_unop1_builtin
argument_list|(
name|CODE_FOR_vmrsqrtv4sf2
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IX86_BUILTIN_RCPSS
case|:
return|return
name|ix86_expand_unop1_builtin
argument_list|(
name|CODE_FOR_vmrcpv4sf2
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IX86_BUILTIN_ANDPS
case|:
return|return
name|ix86_expand_timode_binop_builtin
argument_list|(
name|CODE_FOR_sse_andti3
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IX86_BUILTIN_ANDNPS
case|:
return|return
name|ix86_expand_timode_binop_builtin
argument_list|(
name|CODE_FOR_sse_nandti3
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IX86_BUILTIN_ORPS
case|:
return|return
name|ix86_expand_timode_binop_builtin
argument_list|(
name|CODE_FOR_sse_iorti3
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IX86_BUILTIN_XORPS
case|:
return|return
name|ix86_expand_timode_binop_builtin
argument_list|(
name|CODE_FOR_sse_xorti3
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IX86_BUILTIN_LOADAPS
case|:
return|return
name|ix86_expand_unop_builtin
argument_list|(
name|CODE_FOR_sse_movaps
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|,
literal|1
argument_list|)
return|;
case|case
name|IX86_BUILTIN_LOADUPS
case|:
return|return
name|ix86_expand_unop_builtin
argument_list|(
name|CODE_FOR_sse_movups
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|,
literal|1
argument_list|)
return|;
case|case
name|IX86_BUILTIN_STOREAPS
case|:
return|return
name|ix86_expand_store_builtin
argument_list|(
name|CODE_FOR_sse_movaps
argument_list|,
name|arglist
argument_list|)
return|;
case|case
name|IX86_BUILTIN_STOREUPS
case|:
return|return
name|ix86_expand_store_builtin
argument_list|(
name|CODE_FOR_sse_movups
argument_list|,
name|arglist
argument_list|)
return|;
case|case
name|IX86_BUILTIN_LOADSS
case|:
return|return
name|ix86_expand_unop_builtin
argument_list|(
name|CODE_FOR_sse_loadss
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|,
literal|1
argument_list|)
return|;
case|case
name|IX86_BUILTIN_STORESS
case|:
return|return
name|ix86_expand_store_builtin
argument_list|(
name|CODE_FOR_sse_storess
argument_list|,
name|arglist
argument_list|)
return|;
case|case
name|IX86_BUILTIN_LOADHPS
case|:
case|case
name|IX86_BUILTIN_LOADLPS
case|:
name|icode
operator|=
operator|(
name|fcode
operator|==
name|IX86_BUILTIN_LOADHPS
condition|?
name|CODE_FOR_sse_movhps
else|:
name|CODE_FOR_sse_movlps
operator|)
expr_stmt|;
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_expr
argument_list|(
name|arg1
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tmode
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
expr_stmt|;
name|mode0
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
expr_stmt|;
name|mode1
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode0
operator|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode1
argument_list|,
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|tmode
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|target
operator|,
name|tmode
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|target
return|;
case|case
name|IX86_BUILTIN_STOREHPS
case|:
case|case
name|IX86_BUILTIN_STORELPS
case|:
name|icode
operator|=
operator|(
name|fcode
operator|==
name|IX86_BUILTIN_STOREHPS
condition|?
name|CODE_FOR_sse_movhps
else|:
name|CODE_FOR_sse_movlps
operator|)
expr_stmt|;
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_expr
argument_list|(
name|arg1
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mode0
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
expr_stmt|;
name|mode1
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
expr_stmt|;
name|op0
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode0
argument_list|,
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|op0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
operator|)
operator|(
name|op1
operator|,
name|mode1
operator|)
condition|)
name|op1
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode1
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|op0
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|IX86_BUILTIN_MOVNTPS
case|:
return|return
name|ix86_expand_store_builtin
argument_list|(
name|CODE_FOR_sse_movntv4sf
argument_list|,
name|arglist
argument_list|)
return|;
case|case
name|IX86_BUILTIN_MOVNTQ
case|:
return|return
name|ix86_expand_store_builtin
argument_list|(
name|CODE_FOR_sse_movntdi
argument_list|,
name|arglist
argument_list|)
return|;
case|case
name|IX86_BUILTIN_LDMXCSR
case|:
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|target
operator|=
name|assign_386_stack_local
argument_list|(
name|SImode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_ldmxcsr
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|IX86_BUILTIN_STMXCSR
case|:
name|target
operator|=
name|assign_386_stack_local
argument_list|(
name|SImode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_stmxcsr
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|copy_to_mode_reg
argument_list|(
name|SImode
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IX86_BUILTIN_SHUFPS
case|:
name|icode
operator|=
name|CODE_FOR_sse_shufps
expr_stmt|;
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_expr
argument_list|(
name|arg1
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op2
operator|=
name|expand_expr
argument_list|(
name|arg2
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tmode
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
expr_stmt|;
name|mode0
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
expr_stmt|;
name|mode1
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
expr_stmt|;
name|mode2
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|3
index|]
operator|.
name|mode
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode0
operator|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
operator|)
operator|(
name|op1
operator|,
name|mode1
operator|)
condition|)
name|op1
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode1
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|3
index|]
operator|.
name|predicate
operator|)
operator|(
name|op2
operator|,
name|mode2
operator|)
condition|)
block|{
comment|/* @@@ better error message */
name|error
argument_list|(
literal|"mask must be an immediate"
argument_list|)
expr_stmt|;
return|return
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
return|;
block|}
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|tmode
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|target
operator|,
name|tmode
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|target
return|;
case|case
name|IX86_BUILTIN_PSHUFW
case|:
name|icode
operator|=
name|CODE_FOR_mmx_pshufw
expr_stmt|;
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_expr
argument_list|(
name|arg1
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tmode
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
expr_stmt|;
name|mode1
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
expr_stmt|;
name|mode2
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode1
operator|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode1
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
operator|)
operator|(
name|op1
operator|,
name|mode2
operator|)
condition|)
block|{
comment|/* @@@ better error message */
name|error
argument_list|(
literal|"mask must be an immediate"
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|tmode
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|target
operator|,
name|tmode
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|target
return|;
case|case
name|IX86_BUILTIN_FEMMS
case|:
name|emit_insn
argument_list|(
name|gen_femms
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|NULL_RTX
return|;
case|case
name|IX86_BUILTIN_PAVGUSB
case|:
return|return
name|ix86_expand_binop_builtin
argument_list|(
name|CODE_FOR_pavgusb
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IX86_BUILTIN_PF2ID
case|:
return|return
name|ix86_expand_unop_builtin
argument_list|(
name|CODE_FOR_pf2id
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|IX86_BUILTIN_PFACC
case|:
return|return
name|ix86_expand_binop_builtin
argument_list|(
name|CODE_FOR_pfacc
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IX86_BUILTIN_PFADD
case|:
return|return
name|ix86_expand_binop_builtin
argument_list|(
name|CODE_FOR_addv2sf3
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IX86_BUILTIN_PFCMPEQ
case|:
return|return
name|ix86_expand_binop_builtin
argument_list|(
name|CODE_FOR_eqv2sf3
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IX86_BUILTIN_PFCMPGE
case|:
return|return
name|ix86_expand_binop_builtin
argument_list|(
name|CODE_FOR_gev2sf3
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IX86_BUILTIN_PFCMPGT
case|:
return|return
name|ix86_expand_binop_builtin
argument_list|(
name|CODE_FOR_gtv2sf3
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IX86_BUILTIN_PFMAX
case|:
return|return
name|ix86_expand_binop_builtin
argument_list|(
name|CODE_FOR_pfmaxv2sf3
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IX86_BUILTIN_PFMIN
case|:
return|return
name|ix86_expand_binop_builtin
argument_list|(
name|CODE_FOR_pfminv2sf3
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IX86_BUILTIN_PFMUL
case|:
return|return
name|ix86_expand_binop_builtin
argument_list|(
name|CODE_FOR_mulv2sf3
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IX86_BUILTIN_PFRCP
case|:
return|return
name|ix86_expand_unop_builtin
argument_list|(
name|CODE_FOR_pfrcpv2sf2
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|IX86_BUILTIN_PFRCPIT1
case|:
return|return
name|ix86_expand_binop_builtin
argument_list|(
name|CODE_FOR_pfrcpit1v2sf3
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IX86_BUILTIN_PFRCPIT2
case|:
return|return
name|ix86_expand_binop_builtin
argument_list|(
name|CODE_FOR_pfrcpit2v2sf3
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IX86_BUILTIN_PFRSQIT1
case|:
return|return
name|ix86_expand_binop_builtin
argument_list|(
name|CODE_FOR_pfrsqit1v2sf3
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IX86_BUILTIN_PFRSQRT
case|:
return|return
name|ix86_expand_unop_builtin
argument_list|(
name|CODE_FOR_pfrsqrtv2sf2
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|IX86_BUILTIN_PFSUB
case|:
return|return
name|ix86_expand_binop_builtin
argument_list|(
name|CODE_FOR_subv2sf3
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IX86_BUILTIN_PFSUBR
case|:
return|return
name|ix86_expand_binop_builtin
argument_list|(
name|CODE_FOR_subrv2sf3
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IX86_BUILTIN_PI2FD
case|:
return|return
name|ix86_expand_unop_builtin
argument_list|(
name|CODE_FOR_floatv2si2
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|IX86_BUILTIN_PMULHRW
case|:
return|return
name|ix86_expand_binop_builtin
argument_list|(
name|CODE_FOR_pmulhrwv4hi3
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IX86_BUILTIN_PF2IW
case|:
return|return
name|ix86_expand_unop_builtin
argument_list|(
name|CODE_FOR_pf2iw
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|IX86_BUILTIN_PFNACC
case|:
return|return
name|ix86_expand_binop_builtin
argument_list|(
name|CODE_FOR_pfnacc
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IX86_BUILTIN_PFPNACC
case|:
return|return
name|ix86_expand_binop_builtin
argument_list|(
name|CODE_FOR_pfpnacc
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IX86_BUILTIN_PI2FW
case|:
return|return
name|ix86_expand_unop_builtin
argument_list|(
name|CODE_FOR_pi2fw
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|IX86_BUILTIN_PSWAPDSI
case|:
return|return
name|ix86_expand_unop_builtin
argument_list|(
name|CODE_FOR_pswapdv2si2
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|IX86_BUILTIN_PSWAPDSF
case|:
return|return
name|ix86_expand_unop_builtin
argument_list|(
name|CODE_FOR_pswapdv2sf2
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|IX86_BUILTIN_SSE_ZERO
case|:
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|V4SFmode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_sse_clrv4sf
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|target
return|;
case|case
name|IX86_BUILTIN_MMX_ZERO
case|:
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_mmx_clrdi
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|target
return|;
default|default:
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|d
operator|=
name|bdesc_2arg
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|bdesc_2arg
argument_list|)
operator|/
sizeof|sizeof
expr|*
name|d
condition|;
name|i
operator|++
operator|,
name|d
operator|++
control|)
if|if
condition|(
name|d
operator|->
name|code
operator|==
name|fcode
condition|)
block|{
comment|/* Compares are treated specially.  */
if|if
condition|(
name|d
operator|->
name|icode
operator|==
name|CODE_FOR_maskcmpv4sf3
operator|||
name|d
operator|->
name|icode
operator|==
name|CODE_FOR_vmmaskcmpv4sf3
operator|||
name|d
operator|->
name|icode
operator|==
name|CODE_FOR_maskncmpv4sf3
operator|||
name|d
operator|->
name|icode
operator|==
name|CODE_FOR_vmmaskncmpv4sf3
condition|)
return|return
name|ix86_expand_sse_compare
argument_list|(
name|d
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
return|return
name|ix86_expand_binop_builtin
argument_list|(
name|d
operator|->
name|icode
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|d
operator|=
name|bdesc_1arg
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|bdesc_1arg
argument_list|)
operator|/
sizeof|sizeof
expr|*
name|d
condition|;
name|i
operator|++
operator|,
name|d
operator|++
control|)
if|if
condition|(
name|d
operator|->
name|code
operator|==
name|fcode
condition|)
return|return
name|ix86_expand_unop_builtin
argument_list|(
name|d
operator|->
name|icode
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
return|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|d
operator|=
name|bdesc_comi
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|bdesc_comi
argument_list|)
operator|/
sizeof|sizeof
expr|*
name|d
condition|;
name|i
operator|++
operator|,
name|d
operator|++
control|)
if|if
condition|(
name|d
operator|->
name|code
operator|==
name|fcode
condition|)
return|return
name|ix86_expand_sse_comi
argument_list|(
name|d
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
comment|/* @@@ Should really do something sensible here.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Store OPERAND to the memory after reload is completed.  This means    that we can't easily use assign_stack_local.  */
end_comment

begin_function
name|rtx
name|ix86_force_to_memory
parameter_list|(
name|mode
parameter_list|,
name|operand
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|operand
decl_stmt|;
block|{
name|rtx
name|result
decl_stmt|;
if|if
condition|(
operator|!
name|reload_completed
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
operator|&&
name|TARGET_RED_ZONE
condition|)
block|{
name|result
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
operator|-
name|RED_ZONE_SIZE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|result
argument_list|,
name|operand
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TARGET_64BIT
operator|&&
operator|!
name|TARGET_RED_ZONE
condition|)
block|{
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|HImode
case|:
case|case
name|SImode
case|:
name|operand
operator|=
name|gen_lowpart
argument_list|(
name|DImode
argument_list|,
name|operand
argument_list|)
expr_stmt|;
comment|/* FALLTHRU */
case|case
name|DImode
case|:
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|DImode
argument_list|,
name|gen_rtx_PRE_DEC
argument_list|(
name|DImode
argument_list|,
name|stack_pointer_rtx
argument_list|)
argument_list|)
argument_list|,
name|operand
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|result
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode
argument_list|,
name|stack_pointer_rtx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|DImode
case|:
block|{
name|rtx
name|operands
index|[
literal|2
index|]
decl_stmt|;
name|split_di
argument_list|(
operator|&
name|operand
argument_list|,
literal|1
argument_list|,
name|operands
argument_list|,
name|operands
operator|+
literal|1
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|gen_rtx_PRE_DEC
argument_list|(
name|Pmode
argument_list|,
name|stack_pointer_rtx
argument_list|)
argument_list|)
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|gen_rtx_PRE_DEC
argument_list|(
name|Pmode
argument_list|,
name|stack_pointer_rtx
argument_list|)
argument_list|)
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|HImode
case|:
comment|/* It is better to store HImodes as SImodes.  */
if|if
condition|(
operator|!
name|TARGET_PARTIAL_REG_STALL
condition|)
name|operand
operator|=
name|gen_lowpart
argument_list|(
name|SImode
argument_list|,
name|operand
argument_list|)
expr_stmt|;
comment|/* FALLTHRU */
case|case
name|SImode
case|:
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|GET_MODE
argument_list|(
name|operand
argument_list|)
argument_list|,
name|gen_rtx_PRE_DEC
argument_list|(
name|SImode
argument_list|,
name|stack_pointer_rtx
argument_list|)
argument_list|)
argument_list|,
name|operand
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|result
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode
argument_list|,
name|stack_pointer_rtx
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Free operand from the memory.  */
end_comment

begin_function
name|void
name|ix86_free_from_memory
parameter_list|(
name|mode
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|TARGET_64BIT
operator|||
operator|!
name|TARGET_RED_ZONE
condition|)
block|{
name|int
name|size
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|DImode
operator|||
name|TARGET_64BIT
condition|)
name|size
operator|=
literal|8
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|HImode
operator|&&
name|TARGET_PARTIAL_REG_STALL
condition|)
name|size
operator|=
literal|2
expr_stmt|;
else|else
name|size
operator|=
literal|4
expr_stmt|;
comment|/* Use LEA to deallocate stack space.  In peephole2 it will be converted          to pop or add instruction if registers are available.  */
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|size
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Put float CONST_DOUBLE in the constant pool instead of fp regs.    QImode must go into class Q_REGS.    Narrow ALL_REGS to GENERAL_REGS.  This supports allowing movsf and    movdf to do mem-to-mem moves through integer regs.  */
end_comment

begin_function
name|enum
name|reg_class
name|ix86_preferred_reload_class
parameter_list|(
name|x
parameter_list|,
name|class
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|enum
name|reg_class
name|class
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|VOIDmode
condition|)
block|{
comment|/* SSE can't load any constant directly yet.  */
if|if
condition|(
name|SSE_CLASS_P
argument_list|(
name|class
argument_list|)
condition|)
return|return
name|NO_REGS
return|;
comment|/* Floats can load 0 and 1.  */
if|if
condition|(
name|MAYBE_FLOAT_CLASS_P
argument_list|(
name|class
argument_list|)
operator|&&
name|standard_80387_constant_p
argument_list|(
name|x
argument_list|)
condition|)
block|{
comment|/* Limit class to non-SSE.  Use GENERAL_REGS if possible.  */
if|if
condition|(
name|MAYBE_SSE_CLASS_P
argument_list|(
name|class
argument_list|)
condition|)
return|return
operator|(
name|reg_class_subset_p
argument_list|(
name|class
argument_list|,
name|GENERAL_REGS
argument_list|)
condition|?
name|GENERAL_REGS
else|:
name|FLOAT_REGS
operator|)
return|;
else|else
return|return
name|class
return|;
block|}
comment|/* General regs can load everything.  */
if|if
condition|(
name|reg_class_subset_p
argument_list|(
name|class
argument_list|,
name|GENERAL_REGS
argument_list|)
condition|)
return|return
name|GENERAL_REGS
return|;
comment|/* In case we haven't resolved FLOAT or SSE yet, give up.  */
if|if
condition|(
name|MAYBE_FLOAT_CLASS_P
argument_list|(
name|class
argument_list|)
operator|||
name|MAYBE_SSE_CLASS_P
argument_list|(
name|class
argument_list|)
condition|)
return|return
name|NO_REGS
return|;
block|}
if|if
condition|(
name|MAYBE_MMX_CLASS_P
argument_list|(
name|class
argument_list|)
operator|&&
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|NO_REGS
return|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|QImode
operator|&&
operator|!
name|reg_class_subset_p
argument_list|(
name|class
argument_list|,
name|Q_REGS
argument_list|)
condition|)
return|return
name|Q_REGS
return|;
return|return
name|class
return|;
block|}
end_function

begin_comment
comment|/* If we are copying between general and FP registers, we need a memory    location. The same is true for SSE and MMX registers.     The macro can't work reliably when one of the CLASSES is class containing    registers from multiple units (SSE, MMX, integer).  We avoid this by never    combining those units in single alternative in the machine description.    Ensure that this constraint holds to avoid unexpected surprises.     When STRICT is false, we are being called from REGISTER_MOVE_COST, so do not    enforce these sanity checks.  */
end_comment

begin_function
name|int
name|ix86_secondary_memory_needed
parameter_list|(
name|class1
parameter_list|,
name|class2
parameter_list|,
name|mode
parameter_list|,
name|strict
parameter_list|)
name|enum
name|reg_class
name|class1
decl_stmt|,
name|class2
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|strict
decl_stmt|;
block|{
if|if
condition|(
name|MAYBE_FLOAT_CLASS_P
argument_list|(
name|class1
argument_list|)
operator|!=
name|FLOAT_CLASS_P
argument_list|(
name|class1
argument_list|)
operator|||
name|MAYBE_FLOAT_CLASS_P
argument_list|(
name|class2
argument_list|)
operator|!=
name|FLOAT_CLASS_P
argument_list|(
name|class2
argument_list|)
operator|||
name|MAYBE_SSE_CLASS_P
argument_list|(
name|class1
argument_list|)
operator|!=
name|SSE_CLASS_P
argument_list|(
name|class1
argument_list|)
operator|||
name|MAYBE_SSE_CLASS_P
argument_list|(
name|class2
argument_list|)
operator|!=
name|SSE_CLASS_P
argument_list|(
name|class2
argument_list|)
operator|||
name|MAYBE_MMX_CLASS_P
argument_list|(
name|class1
argument_list|)
operator|!=
name|MMX_CLASS_P
argument_list|(
name|class1
argument_list|)
operator|||
name|MAYBE_MMX_CLASS_P
argument_list|(
name|class2
argument_list|)
operator|!=
name|MMX_CLASS_P
argument_list|(
name|class2
argument_list|)
condition|)
block|{
if|if
condition|(
name|strict
condition|)
name|abort
argument_list|()
expr_stmt|;
else|else
return|return
literal|1
return|;
block|}
return|return
operator|(
name|FLOAT_CLASS_P
argument_list|(
name|class1
argument_list|)
operator|!=
name|FLOAT_CLASS_P
argument_list|(
name|class2
argument_list|)
operator|||
operator|(
name|SSE_CLASS_P
argument_list|(
name|class1
argument_list|)
operator|!=
name|SSE_CLASS_P
argument_list|(
name|class2
argument_list|)
operator|&&
operator|(
name|mode
operator|)
operator|!=
name|SImode
operator|)
operator|||
operator|(
name|MMX_CLASS_P
argument_list|(
name|class1
argument_list|)
operator|!=
name|MMX_CLASS_P
argument_list|(
name|class2
argument_list|)
operator|&&
operator|(
name|mode
operator|)
operator|!=
name|SImode
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the cost of moving data from a register in class CLASS1 to    one in class CLASS2.     It is not required that the cost always equal 2 when FROM is the same as TO;    on some machines it is expensive to move between registers if they are not    general registers.  */
end_comment

begin_function
name|int
name|ix86_register_move_cost
parameter_list|(
name|mode
parameter_list|,
name|class1
parameter_list|,
name|class2
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|enum
name|reg_class
name|class1
decl_stmt|,
name|class2
decl_stmt|;
block|{
comment|/* In case we require secondary memory, compute cost of the store followed      by load.  In case of copying from general_purpose_register we may emit      multiple stores followed by single load causing memory size mismatch      stall.  Count this as arbitarily high cost of 20.  */
if|if
condition|(
name|ix86_secondary_memory_needed
argument_list|(
name|class1
argument_list|,
name|class2
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|int
name|add_cost
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|CLASS_MAX_NREGS
argument_list|(
name|class1
argument_list|,
name|mode
argument_list|)
operator|>
name|CLASS_MAX_NREGS
argument_list|(
name|class2
argument_list|,
name|mode
argument_list|)
condition|)
name|add_cost
operator|=
literal|20
expr_stmt|;
return|return
operator|(
name|MEMORY_MOVE_COST
argument_list|(
name|mode
argument_list|,
name|class1
argument_list|,
literal|0
argument_list|)
operator|+
name|MEMORY_MOVE_COST
argument_list|(
name|mode
argument_list|,
name|class2
argument_list|,
literal|1
argument_list|)
operator|+
name|add_cost
operator|)
return|;
block|}
comment|/* Moves between SSE/MMX and integer unit are expensive.  */
if|if
condition|(
name|MMX_CLASS_P
argument_list|(
name|class1
argument_list|)
operator|!=
name|MMX_CLASS_P
argument_list|(
name|class2
argument_list|)
operator|||
name|SSE_CLASS_P
argument_list|(
name|class1
argument_list|)
operator|!=
name|SSE_CLASS_P
argument_list|(
name|class2
argument_list|)
condition|)
return|return
name|ix86_cost
operator|->
name|mmxsse_to_integer
return|;
if|if
condition|(
name|MAYBE_FLOAT_CLASS_P
argument_list|(
name|class1
argument_list|)
condition|)
return|return
name|ix86_cost
operator|->
name|fp_move
return|;
if|if
condition|(
name|MAYBE_SSE_CLASS_P
argument_list|(
name|class1
argument_list|)
condition|)
return|return
name|ix86_cost
operator|->
name|sse_move
return|;
if|if
condition|(
name|MAYBE_MMX_CLASS_P
argument_list|(
name|class1
argument_list|)
condition|)
return|return
name|ix86_cost
operator|->
name|mmx_move
return|;
return|return
literal|2
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if hard register REGNO can hold a value of machine-mode MODE.  */
end_comment

begin_function
name|int
name|ix86_hard_regno_mode_ok
parameter_list|(
name|regno
parameter_list|,
name|mode
parameter_list|)
name|int
name|regno
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
comment|/* Flags and only flags can only hold CCmode values.  */
if|if
condition|(
name|CC_REGNO_P
argument_list|(
name|regno
argument_list|)
condition|)
return|return
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_CC
return|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_CC
operator|||
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_RANDOM
operator|||
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_PARTIAL_INT
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|FP_REGNO_P
argument_list|(
name|regno
argument_list|)
condition|)
return|return
name|VALID_FP_MODE_P
argument_list|(
name|mode
argument_list|)
return|;
if|if
condition|(
name|SSE_REGNO_P
argument_list|(
name|regno
argument_list|)
condition|)
return|return
name|VALID_SSE_REG_MODE
argument_list|(
name|mode
argument_list|)
return|;
if|if
condition|(
name|MMX_REGNO_P
argument_list|(
name|regno
argument_list|)
condition|)
return|return
name|VALID_MMX_REG_MODE
argument_list|(
name|mode
argument_list|)
operator|||
name|VALID_MMX_REG_MODE_3DNOW
argument_list|(
name|mode
argument_list|)
return|;
comment|/* We handle both integer and floats in the general purpose registers.      In future we should be able to handle vector modes as well.  */
if|if
condition|(
operator|!
name|VALID_INT_MODE_P
argument_list|(
name|mode
argument_list|)
operator|&&
operator|!
name|VALID_FP_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Take care for QImode values - they can be in non-QI regs, but then      they do cause partial register stalls.  */
if|if
condition|(
name|regno
operator|<
literal|4
operator|||
name|mode
operator|!=
name|QImode
operator|||
name|TARGET_64BIT
condition|)
return|return
literal|1
return|;
return|return
name|reload_in_progress
operator|||
name|reload_completed
operator|||
operator|!
name|TARGET_PARTIAL_REG_STALL
return|;
block|}
end_function

begin_comment
comment|/* Return the cost of moving data of mode M between a    register and memory.  A value of 2 is the default; this cost is    relative to those in `REGISTER_MOVE_COST'.     If moving between registers and memory is more expensive than    between two registers, you should define this macro to express the    relative cost.     Model also increased moving costs of QImode registers in non    Q_REGS classes.  */
end_comment

begin_function
name|int
name|ix86_memory_move_cost
parameter_list|(
name|mode
parameter_list|,
name|class
parameter_list|,
name|in
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|enum
name|reg_class
name|class
decl_stmt|;
name|int
name|in
decl_stmt|;
block|{
if|if
condition|(
name|FLOAT_CLASS_P
argument_list|(
name|class
argument_list|)
condition|)
block|{
name|int
name|index
decl_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|SFmode
case|:
name|index
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|DFmode
case|:
name|index
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|XFmode
case|:
case|case
name|TFmode
case|:
name|index
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
return|return
literal|100
return|;
block|}
return|return
name|in
condition|?
name|ix86_cost
operator|->
name|fp_load
index|[
name|index
index|]
else|:
name|ix86_cost
operator|->
name|fp_store
index|[
name|index
index|]
return|;
block|}
if|if
condition|(
name|SSE_CLASS_P
argument_list|(
name|class
argument_list|)
condition|)
block|{
name|int
name|index
decl_stmt|;
switch|switch
condition|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
condition|)
block|{
case|case
literal|4
case|:
name|index
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|index
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|index
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
return|return
literal|100
return|;
block|}
return|return
name|in
condition|?
name|ix86_cost
operator|->
name|sse_load
index|[
name|index
index|]
else|:
name|ix86_cost
operator|->
name|sse_store
index|[
name|index
index|]
return|;
block|}
if|if
condition|(
name|MMX_CLASS_P
argument_list|(
name|class
argument_list|)
condition|)
block|{
name|int
name|index
decl_stmt|;
switch|switch
condition|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
condition|)
block|{
case|case
literal|4
case|:
name|index
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|index
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
return|return
literal|100
return|;
block|}
return|return
name|in
condition|?
name|ix86_cost
operator|->
name|mmx_load
index|[
name|index
index|]
else|:
name|ix86_cost
operator|->
name|mmx_store
index|[
name|index
index|]
return|;
block|}
switch|switch
condition|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
if|if
condition|(
name|in
condition|)
return|return
operator|(
name|Q_CLASS_P
argument_list|(
name|class
argument_list|)
condition|?
name|ix86_cost
operator|->
name|int_load
index|[
literal|0
index|]
else|:
name|ix86_cost
operator|->
name|movzbl_load
operator|)
return|;
else|else
return|return
operator|(
name|Q_CLASS_P
argument_list|(
name|class
argument_list|)
condition|?
name|ix86_cost
operator|->
name|int_store
index|[
literal|0
index|]
else|:
name|ix86_cost
operator|->
name|int_store
index|[
literal|0
index|]
operator|+
literal|4
operator|)
return|;
break|break;
case|case
literal|2
case|:
return|return
name|in
condition|?
name|ix86_cost
operator|->
name|int_load
index|[
literal|1
index|]
else|:
name|ix86_cost
operator|->
name|int_store
index|[
literal|1
index|]
return|;
default|default:
comment|/* Compute number of 32bit moves needed.  TFmode is moved as XFmode.  */
if|if
condition|(
name|mode
operator|==
name|TFmode
condition|)
name|mode
operator|=
name|XFmode
expr_stmt|;
return|return
operator|(
operator|(
name|in
condition|?
name|ix86_cost
operator|->
name|int_load
index|[
literal|2
index|]
else|:
name|ix86_cost
operator|->
name|int_store
index|[
literal|2
index|]
operator|)
operator|*
operator|(
name|int
operator|)
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|/
literal|4
operator|)
return|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DO_GLOBAL_CTORS_BODY
end_ifdef

begin_function
specifier|static
name|void
name|ix86_svr3_asm_out_constructor
parameter_list|(
name|symbol
parameter_list|,
name|priority
parameter_list|)
name|rtx
name|symbol
decl_stmt|;
name|int
name|priority
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|init_section
argument_list|()
expr_stmt|;
name|fputs
argument_list|(
literal|"\tpushl $"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|asm_out_file
argument_list|,
name|XSTR
argument_list|(
name|symbol
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

