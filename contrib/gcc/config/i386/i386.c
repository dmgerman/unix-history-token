begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Subroutines used for code generation on IA-32.    Copyright (C) 1988, 1992, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,    2002, 2003, 2004 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"conditions.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"optabs.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"target-def.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"cgraph.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|CHECK_STACK_LIMIT
end_ifndef

begin_define
define|#
directive|define
name|CHECK_STACK_LIMIT
value|(-1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Return index of given mode in mult and division cost tables.  */
end_comment

begin_define
define|#
directive|define
name|MODE_INDEX
parameter_list|(
name|mode
parameter_list|)
define|\
value|((mode) == QImode ? 0						\    : (mode) == HImode ? 1					\    : (mode) == SImode ? 2					\    : (mode) == DImode ? 3					\    : 4)
end_define

begin_comment
comment|/* Processor costs (relative to an add) */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|processor_costs
name|size_cost
init|=
block|{
comment|/* costs for tunning for size */
literal|2
block|,
comment|/* cost of an add instruction */
literal|3
block|,
comment|/* cost of a lea instruction */
literal|2
block|,
comment|/* variable shift costs */
literal|3
block|,
comment|/* constant shift costs */
block|{
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|5
block|}
block|,
comment|/* cost of starting a multiply */
literal|0
block|,
comment|/* cost of multiply per each bit set */
block|{
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|5
block|}
block|,
comment|/* cost of a divide/mod */
literal|3
block|,
comment|/* cost of movsx */
literal|3
block|,
comment|/* cost of movzx */
literal|0
block|,
comment|/* "large" insn */
literal|2
block|,
comment|/* MOVE_RATIO */
literal|2
block|,
comment|/* cost for loading QImode using movzbl */
block|{
literal|2
block|,
literal|2
block|,
literal|2
block|}
block|,
comment|/* cost of loading integer registers 					   in QImode, HImode and SImode. 					   Relative to reg-reg move (2).  */
block|{
literal|2
block|,
literal|2
block|,
literal|2
block|}
block|,
comment|/* cost of storing integer registers */
literal|2
block|,
comment|/* cost of reg,reg fld/fst */
block|{
literal|2
block|,
literal|2
block|,
literal|2
block|}
block|,
comment|/* cost of loading fp registers 					   in SFmode, DFmode and XFmode */
block|{
literal|2
block|,
literal|2
block|,
literal|2
block|}
block|,
comment|/* cost of loading integer registers */
literal|3
block|,
comment|/* cost of moving MMX register */
block|{
literal|3
block|,
literal|3
block|}
block|,
comment|/* cost of loading MMX registers 					   in SImode and DImode */
block|{
literal|3
block|,
literal|3
block|}
block|,
comment|/* cost of storing MMX registers 					   in SImode and DImode */
literal|3
block|,
comment|/* cost of moving SSE register */
block|{
literal|3
block|,
literal|3
block|,
literal|3
block|}
block|,
comment|/* cost of loading SSE registers 					   in SImode, DImode and TImode */
block|{
literal|3
block|,
literal|3
block|,
literal|3
block|}
block|,
comment|/* cost of storing SSE registers 					   in SImode, DImode and TImode */
literal|3
block|,
comment|/* MMX or SSE register to integer */
literal|0
block|,
comment|/* size of prefetch block */
literal|0
block|,
comment|/* number of parallel prefetches */
literal|1
block|,
comment|/* Branch cost */
literal|2
block|,
comment|/* cost of FADD and FSUB insns.  */
literal|2
block|,
comment|/* cost of FMUL instruction.  */
literal|2
block|,
comment|/* cost of FDIV instruction.  */
literal|2
block|,
comment|/* cost of FABS instruction.  */
literal|2
block|,
comment|/* cost of FCHS instruction.  */
literal|2
block|,
comment|/* cost of FSQRT instruction.  */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Processor costs (relative to an add) */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|processor_costs
name|i386_cost
init|=
block|{
comment|/* 386 specific costs */
literal|1
block|,
comment|/* cost of an add instruction */
literal|1
block|,
comment|/* cost of a lea instruction */
literal|3
block|,
comment|/* variable shift costs */
literal|2
block|,
comment|/* constant shift costs */
block|{
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|}
block|,
comment|/* cost of starting a multiply */
literal|1
block|,
comment|/* cost of multiply per each bit set */
block|{
literal|23
block|,
literal|23
block|,
literal|23
block|,
literal|23
block|,
literal|23
block|}
block|,
comment|/* cost of a divide/mod */
literal|3
block|,
comment|/* cost of movsx */
literal|2
block|,
comment|/* cost of movzx */
literal|15
block|,
comment|/* "large" insn */
literal|3
block|,
comment|/* MOVE_RATIO */
literal|4
block|,
comment|/* cost for loading QImode using movzbl */
block|{
literal|2
block|,
literal|4
block|,
literal|2
block|}
block|,
comment|/* cost of loading integer registers 					   in QImode, HImode and SImode. 					   Relative to reg-reg move (2).  */
block|{
literal|2
block|,
literal|4
block|,
literal|2
block|}
block|,
comment|/* cost of storing integer registers */
literal|2
block|,
comment|/* cost of reg,reg fld/fst */
block|{
literal|8
block|,
literal|8
block|,
literal|8
block|}
block|,
comment|/* cost of loading fp registers 					   in SFmode, DFmode and XFmode */
block|{
literal|8
block|,
literal|8
block|,
literal|8
block|}
block|,
comment|/* cost of loading integer registers */
literal|2
block|,
comment|/* cost of moving MMX register */
block|{
literal|4
block|,
literal|8
block|}
block|,
comment|/* cost of loading MMX registers 					   in SImode and DImode */
block|{
literal|4
block|,
literal|8
block|}
block|,
comment|/* cost of storing MMX registers 					   in SImode and DImode */
literal|2
block|,
comment|/* cost of moving SSE register */
block|{
literal|4
block|,
literal|8
block|,
literal|16
block|}
block|,
comment|/* cost of loading SSE registers 					   in SImode, DImode and TImode */
block|{
literal|4
block|,
literal|8
block|,
literal|16
block|}
block|,
comment|/* cost of storing SSE registers 					   in SImode, DImode and TImode */
literal|3
block|,
comment|/* MMX or SSE register to integer */
literal|0
block|,
comment|/* size of prefetch block */
literal|0
block|,
comment|/* number of parallel prefetches */
literal|1
block|,
comment|/* Branch cost */
literal|23
block|,
comment|/* cost of FADD and FSUB insns.  */
literal|27
block|,
comment|/* cost of FMUL instruction.  */
literal|88
block|,
comment|/* cost of FDIV instruction.  */
literal|22
block|,
comment|/* cost of FABS instruction.  */
literal|24
block|,
comment|/* cost of FCHS instruction.  */
literal|122
block|,
comment|/* cost of FSQRT instruction.  */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|processor_costs
name|i486_cost
init|=
block|{
comment|/* 486 specific costs */
literal|1
block|,
comment|/* cost of an add instruction */
literal|1
block|,
comment|/* cost of a lea instruction */
literal|3
block|,
comment|/* variable shift costs */
literal|2
block|,
comment|/* constant shift costs */
block|{
literal|12
block|,
literal|12
block|,
literal|12
block|,
literal|12
block|,
literal|12
block|}
block|,
comment|/* cost of starting a multiply */
literal|1
block|,
comment|/* cost of multiply per each bit set */
block|{
literal|40
block|,
literal|40
block|,
literal|40
block|,
literal|40
block|,
literal|40
block|}
block|,
comment|/* cost of a divide/mod */
literal|3
block|,
comment|/* cost of movsx */
literal|2
block|,
comment|/* cost of movzx */
literal|15
block|,
comment|/* "large" insn */
literal|3
block|,
comment|/* MOVE_RATIO */
literal|4
block|,
comment|/* cost for loading QImode using movzbl */
block|{
literal|2
block|,
literal|4
block|,
literal|2
block|}
block|,
comment|/* cost of loading integer registers 					   in QImode, HImode and SImode. 					   Relative to reg-reg move (2).  */
block|{
literal|2
block|,
literal|4
block|,
literal|2
block|}
block|,
comment|/* cost of storing integer registers */
literal|2
block|,
comment|/* cost of reg,reg fld/fst */
block|{
literal|8
block|,
literal|8
block|,
literal|8
block|}
block|,
comment|/* cost of loading fp registers 					   in SFmode, DFmode and XFmode */
block|{
literal|8
block|,
literal|8
block|,
literal|8
block|}
block|,
comment|/* cost of loading integer registers */
literal|2
block|,
comment|/* cost of moving MMX register */
block|{
literal|4
block|,
literal|8
block|}
block|,
comment|/* cost of loading MMX registers 					   in SImode and DImode */
block|{
literal|4
block|,
literal|8
block|}
block|,
comment|/* cost of storing MMX registers 					   in SImode and DImode */
literal|2
block|,
comment|/* cost of moving SSE register */
block|{
literal|4
block|,
literal|8
block|,
literal|16
block|}
block|,
comment|/* cost of loading SSE registers 					   in SImode, DImode and TImode */
block|{
literal|4
block|,
literal|8
block|,
literal|16
block|}
block|,
comment|/* cost of storing SSE registers 					   in SImode, DImode and TImode */
literal|3
block|,
comment|/* MMX or SSE register to integer */
literal|0
block|,
comment|/* size of prefetch block */
literal|0
block|,
comment|/* number of parallel prefetches */
literal|1
block|,
comment|/* Branch cost */
literal|8
block|,
comment|/* cost of FADD and FSUB insns.  */
literal|16
block|,
comment|/* cost of FMUL instruction.  */
literal|73
block|,
comment|/* cost of FDIV instruction.  */
literal|3
block|,
comment|/* cost of FABS instruction.  */
literal|3
block|,
comment|/* cost of FCHS instruction.  */
literal|83
block|,
comment|/* cost of FSQRT instruction.  */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|processor_costs
name|pentium_cost
init|=
block|{
literal|1
block|,
comment|/* cost of an add instruction */
literal|1
block|,
comment|/* cost of a lea instruction */
literal|4
block|,
comment|/* variable shift costs */
literal|1
block|,
comment|/* constant shift costs */
block|{
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|}
block|,
comment|/* cost of starting a multiply */
literal|0
block|,
comment|/* cost of multiply per each bit set */
block|{
literal|25
block|,
literal|25
block|,
literal|25
block|,
literal|25
block|,
literal|25
block|}
block|,
comment|/* cost of a divide/mod */
literal|3
block|,
comment|/* cost of movsx */
literal|2
block|,
comment|/* cost of movzx */
literal|8
block|,
comment|/* "large" insn */
literal|6
block|,
comment|/* MOVE_RATIO */
literal|6
block|,
comment|/* cost for loading QImode using movzbl */
block|{
literal|2
block|,
literal|4
block|,
literal|2
block|}
block|,
comment|/* cost of loading integer registers 					   in QImode, HImode and SImode. 					   Relative to reg-reg move (2).  */
block|{
literal|2
block|,
literal|4
block|,
literal|2
block|}
block|,
comment|/* cost of storing integer registers */
literal|2
block|,
comment|/* cost of reg,reg fld/fst */
block|{
literal|2
block|,
literal|2
block|,
literal|6
block|}
block|,
comment|/* cost of loading fp registers 					   in SFmode, DFmode and XFmode */
block|{
literal|4
block|,
literal|4
block|,
literal|6
block|}
block|,
comment|/* cost of loading integer registers */
literal|8
block|,
comment|/* cost of moving MMX register */
block|{
literal|8
block|,
literal|8
block|}
block|,
comment|/* cost of loading MMX registers 					   in SImode and DImode */
block|{
literal|8
block|,
literal|8
block|}
block|,
comment|/* cost of storing MMX registers 					   in SImode and DImode */
literal|2
block|,
comment|/* cost of moving SSE register */
block|{
literal|4
block|,
literal|8
block|,
literal|16
block|}
block|,
comment|/* cost of loading SSE registers 					   in SImode, DImode and TImode */
block|{
literal|4
block|,
literal|8
block|,
literal|16
block|}
block|,
comment|/* cost of storing SSE registers 					   in SImode, DImode and TImode */
literal|3
block|,
comment|/* MMX or SSE register to integer */
literal|0
block|,
comment|/* size of prefetch block */
literal|0
block|,
comment|/* number of parallel prefetches */
literal|2
block|,
comment|/* Branch cost */
literal|3
block|,
comment|/* cost of FADD and FSUB insns.  */
literal|3
block|,
comment|/* cost of FMUL instruction.  */
literal|39
block|,
comment|/* cost of FDIV instruction.  */
literal|1
block|,
comment|/* cost of FABS instruction.  */
literal|1
block|,
comment|/* cost of FCHS instruction.  */
literal|70
block|,
comment|/* cost of FSQRT instruction.  */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|processor_costs
name|pentiumpro_cost
init|=
block|{
literal|1
block|,
comment|/* cost of an add instruction */
literal|1
block|,
comment|/* cost of a lea instruction */
literal|1
block|,
comment|/* variable shift costs */
literal|1
block|,
comment|/* constant shift costs */
block|{
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|}
block|,
comment|/* cost of starting a multiply */
literal|0
block|,
comment|/* cost of multiply per each bit set */
block|{
literal|17
block|,
literal|17
block|,
literal|17
block|,
literal|17
block|,
literal|17
block|}
block|,
comment|/* cost of a divide/mod */
literal|1
block|,
comment|/* cost of movsx */
literal|1
block|,
comment|/* cost of movzx */
literal|8
block|,
comment|/* "large" insn */
literal|6
block|,
comment|/* MOVE_RATIO */
literal|2
block|,
comment|/* cost for loading QImode using movzbl */
block|{
literal|4
block|,
literal|4
block|,
literal|4
block|}
block|,
comment|/* cost of loading integer registers 					   in QImode, HImode and SImode. 					   Relative to reg-reg move (2).  */
block|{
literal|2
block|,
literal|2
block|,
literal|2
block|}
block|,
comment|/* cost of storing integer registers */
literal|2
block|,
comment|/* cost of reg,reg fld/fst */
block|{
literal|2
block|,
literal|2
block|,
literal|6
block|}
block|,
comment|/* cost of loading fp registers 					   in SFmode, DFmode and XFmode */
block|{
literal|4
block|,
literal|4
block|,
literal|6
block|}
block|,
comment|/* cost of loading integer registers */
literal|2
block|,
comment|/* cost of moving MMX register */
block|{
literal|2
block|,
literal|2
block|}
block|,
comment|/* cost of loading MMX registers 					   in SImode and DImode */
block|{
literal|2
block|,
literal|2
block|}
block|,
comment|/* cost of storing MMX registers 					   in SImode and DImode */
literal|2
block|,
comment|/* cost of moving SSE register */
block|{
literal|2
block|,
literal|2
block|,
literal|8
block|}
block|,
comment|/* cost of loading SSE registers 					   in SImode, DImode and TImode */
block|{
literal|2
block|,
literal|2
block|,
literal|8
block|}
block|,
comment|/* cost of storing SSE registers 					   in SImode, DImode and TImode */
literal|3
block|,
comment|/* MMX or SSE register to integer */
literal|32
block|,
comment|/* size of prefetch block */
literal|6
block|,
comment|/* number of parallel prefetches */
literal|2
block|,
comment|/* Branch cost */
literal|3
block|,
comment|/* cost of FADD and FSUB insns.  */
literal|5
block|,
comment|/* cost of FMUL instruction.  */
literal|56
block|,
comment|/* cost of FDIV instruction.  */
literal|2
block|,
comment|/* cost of FABS instruction.  */
literal|2
block|,
comment|/* cost of FCHS instruction.  */
literal|56
block|,
comment|/* cost of FSQRT instruction.  */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|processor_costs
name|k6_cost
init|=
block|{
literal|1
block|,
comment|/* cost of an add instruction */
literal|2
block|,
comment|/* cost of a lea instruction */
literal|1
block|,
comment|/* variable shift costs */
literal|1
block|,
comment|/* constant shift costs */
block|{
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|}
block|,
comment|/* cost of starting a multiply */
literal|0
block|,
comment|/* cost of multiply per each bit set */
block|{
literal|18
block|,
literal|18
block|,
literal|18
block|,
literal|18
block|,
literal|18
block|}
block|,
comment|/* cost of a divide/mod */
literal|2
block|,
comment|/* cost of movsx */
literal|2
block|,
comment|/* cost of movzx */
literal|8
block|,
comment|/* "large" insn */
literal|4
block|,
comment|/* MOVE_RATIO */
literal|3
block|,
comment|/* cost for loading QImode using movzbl */
block|{
literal|4
block|,
literal|5
block|,
literal|4
block|}
block|,
comment|/* cost of loading integer registers 					   in QImode, HImode and SImode. 					   Relative to reg-reg move (2).  */
block|{
literal|2
block|,
literal|3
block|,
literal|2
block|}
block|,
comment|/* cost of storing integer registers */
literal|4
block|,
comment|/* cost of reg,reg fld/fst */
block|{
literal|6
block|,
literal|6
block|,
literal|6
block|}
block|,
comment|/* cost of loading fp registers 					   in SFmode, DFmode and XFmode */
block|{
literal|4
block|,
literal|4
block|,
literal|4
block|}
block|,
comment|/* cost of loading integer registers */
literal|2
block|,
comment|/* cost of moving MMX register */
block|{
literal|2
block|,
literal|2
block|}
block|,
comment|/* cost of loading MMX registers 					   in SImode and DImode */
block|{
literal|2
block|,
literal|2
block|}
block|,
comment|/* cost of storing MMX registers 					   in SImode and DImode */
literal|2
block|,
comment|/* cost of moving SSE register */
block|{
literal|2
block|,
literal|2
block|,
literal|8
block|}
block|,
comment|/* cost of loading SSE registers 					   in SImode, DImode and TImode */
block|{
literal|2
block|,
literal|2
block|,
literal|8
block|}
block|,
comment|/* cost of storing SSE registers 					   in SImode, DImode and TImode */
literal|6
block|,
comment|/* MMX or SSE register to integer */
literal|32
block|,
comment|/* size of prefetch block */
literal|1
block|,
comment|/* number of parallel prefetches */
literal|1
block|,
comment|/* Branch cost */
literal|2
block|,
comment|/* cost of FADD and FSUB insns.  */
literal|2
block|,
comment|/* cost of FMUL instruction.  */
literal|56
block|,
comment|/* cost of FDIV instruction.  */
literal|2
block|,
comment|/* cost of FABS instruction.  */
literal|2
block|,
comment|/* cost of FCHS instruction.  */
literal|56
block|,
comment|/* cost of FSQRT instruction.  */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|processor_costs
name|athlon_cost
init|=
block|{
literal|1
block|,
comment|/* cost of an add instruction */
literal|2
block|,
comment|/* cost of a lea instruction */
literal|1
block|,
comment|/* variable shift costs */
literal|1
block|,
comment|/* constant shift costs */
block|{
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|}
block|,
comment|/* cost of starting a multiply */
literal|0
block|,
comment|/* cost of multiply per each bit set */
block|{
literal|18
block|,
literal|26
block|,
literal|42
block|,
literal|74
block|,
literal|74
block|}
block|,
comment|/* cost of a divide/mod */
literal|1
block|,
comment|/* cost of movsx */
literal|1
block|,
comment|/* cost of movzx */
literal|8
block|,
comment|/* "large" insn */
literal|9
block|,
comment|/* MOVE_RATIO */
literal|4
block|,
comment|/* cost for loading QImode using movzbl */
block|{
literal|3
block|,
literal|4
block|,
literal|3
block|}
block|,
comment|/* cost of loading integer registers 					   in QImode, HImode and SImode. 					   Relative to reg-reg move (2).  */
block|{
literal|3
block|,
literal|4
block|,
literal|3
block|}
block|,
comment|/* cost of storing integer registers */
literal|4
block|,
comment|/* cost of reg,reg fld/fst */
block|{
literal|4
block|,
literal|4
block|,
literal|12
block|}
block|,
comment|/* cost of loading fp registers 					   in SFmode, DFmode and XFmode */
block|{
literal|6
block|,
literal|6
block|,
literal|8
block|}
block|,
comment|/* cost of loading integer registers */
literal|2
block|,
comment|/* cost of moving MMX register */
block|{
literal|4
block|,
literal|4
block|}
block|,
comment|/* cost of loading MMX registers 					   in SImode and DImode */
block|{
literal|4
block|,
literal|4
block|}
block|,
comment|/* cost of storing MMX registers 					   in SImode and DImode */
literal|2
block|,
comment|/* cost of moving SSE register */
block|{
literal|4
block|,
literal|4
block|,
literal|6
block|}
block|,
comment|/* cost of loading SSE registers 					   in SImode, DImode and TImode */
block|{
literal|4
block|,
literal|4
block|,
literal|5
block|}
block|,
comment|/* cost of storing SSE registers 					   in SImode, DImode and TImode */
literal|5
block|,
comment|/* MMX or SSE register to integer */
literal|64
block|,
comment|/* size of prefetch block */
literal|6
block|,
comment|/* number of parallel prefetches */
literal|2
block|,
comment|/* Branch cost */
literal|4
block|,
comment|/* cost of FADD and FSUB insns.  */
literal|4
block|,
comment|/* cost of FMUL instruction.  */
literal|24
block|,
comment|/* cost of FDIV instruction.  */
literal|2
block|,
comment|/* cost of FABS instruction.  */
literal|2
block|,
comment|/* cost of FCHS instruction.  */
literal|35
block|,
comment|/* cost of FSQRT instruction.  */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|processor_costs
name|k8_cost
init|=
block|{
literal|1
block|,
comment|/* cost of an add instruction */
literal|2
block|,
comment|/* cost of a lea instruction */
literal|1
block|,
comment|/* variable shift costs */
literal|1
block|,
comment|/* constant shift costs */
block|{
literal|3
block|,
literal|4
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|}
block|,
comment|/* cost of starting a multiply */
literal|0
block|,
comment|/* cost of multiply per each bit set */
block|{
literal|18
block|,
literal|26
block|,
literal|42
block|,
literal|74
block|,
literal|74
block|}
block|,
comment|/* cost of a divide/mod */
literal|1
block|,
comment|/* cost of movsx */
literal|1
block|,
comment|/* cost of movzx */
literal|8
block|,
comment|/* "large" insn */
literal|9
block|,
comment|/* MOVE_RATIO */
literal|4
block|,
comment|/* cost for loading QImode using movzbl */
block|{
literal|3
block|,
literal|4
block|,
literal|3
block|}
block|,
comment|/* cost of loading integer registers 					   in QImode, HImode and SImode. 					   Relative to reg-reg move (2).  */
block|{
literal|3
block|,
literal|4
block|,
literal|3
block|}
block|,
comment|/* cost of storing integer registers */
literal|4
block|,
comment|/* cost of reg,reg fld/fst */
block|{
literal|4
block|,
literal|4
block|,
literal|12
block|}
block|,
comment|/* cost of loading fp registers 					   in SFmode, DFmode and XFmode */
block|{
literal|6
block|,
literal|6
block|,
literal|8
block|}
block|,
comment|/* cost of loading integer registers */
literal|2
block|,
comment|/* cost of moving MMX register */
block|{
literal|3
block|,
literal|3
block|}
block|,
comment|/* cost of loading MMX registers 					   in SImode and DImode */
block|{
literal|4
block|,
literal|4
block|}
block|,
comment|/* cost of storing MMX registers 					   in SImode and DImode */
literal|2
block|,
comment|/* cost of moving SSE register */
block|{
literal|4
block|,
literal|3
block|,
literal|6
block|}
block|,
comment|/* cost of loading SSE registers 					   in SImode, DImode and TImode */
block|{
literal|4
block|,
literal|4
block|,
literal|5
block|}
block|,
comment|/* cost of storing SSE registers 					   in SImode, DImode and TImode */
literal|5
block|,
comment|/* MMX or SSE register to integer */
literal|64
block|,
comment|/* size of prefetch block */
literal|6
block|,
comment|/* number of parallel prefetches */
literal|2
block|,
comment|/* Branch cost */
literal|4
block|,
comment|/* cost of FADD and FSUB insns.  */
literal|4
block|,
comment|/* cost of FMUL instruction.  */
literal|19
block|,
comment|/* cost of FDIV instruction.  */
literal|2
block|,
comment|/* cost of FABS instruction.  */
literal|2
block|,
comment|/* cost of FCHS instruction.  */
literal|35
block|,
comment|/* cost of FSQRT instruction.  */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|processor_costs
name|pentium4_cost
init|=
block|{
literal|1
block|,
comment|/* cost of an add instruction */
literal|1
block|,
comment|/* cost of a lea instruction */
literal|4
block|,
comment|/* variable shift costs */
literal|4
block|,
comment|/* constant shift costs */
block|{
literal|15
block|,
literal|15
block|,
literal|15
block|,
literal|15
block|,
literal|15
block|}
block|,
comment|/* cost of starting a multiply */
literal|0
block|,
comment|/* cost of multiply per each bit set */
block|{
literal|56
block|,
literal|56
block|,
literal|56
block|,
literal|56
block|,
literal|56
block|}
block|,
comment|/* cost of a divide/mod */
literal|1
block|,
comment|/* cost of movsx */
literal|1
block|,
comment|/* cost of movzx */
literal|16
block|,
comment|/* "large" insn */
literal|6
block|,
comment|/* MOVE_RATIO */
literal|2
block|,
comment|/* cost for loading QImode using movzbl */
block|{
literal|4
block|,
literal|5
block|,
literal|4
block|}
block|,
comment|/* cost of loading integer registers 					   in QImode, HImode and SImode. 					   Relative to reg-reg move (2).  */
block|{
literal|2
block|,
literal|3
block|,
literal|2
block|}
block|,
comment|/* cost of storing integer registers */
literal|2
block|,
comment|/* cost of reg,reg fld/fst */
block|{
literal|2
block|,
literal|2
block|,
literal|6
block|}
block|,
comment|/* cost of loading fp registers 					   in SFmode, DFmode and XFmode */
block|{
literal|4
block|,
literal|4
block|,
literal|6
block|}
block|,
comment|/* cost of loading integer registers */
literal|2
block|,
comment|/* cost of moving MMX register */
block|{
literal|2
block|,
literal|2
block|}
block|,
comment|/* cost of loading MMX registers 					   in SImode and DImode */
block|{
literal|2
block|,
literal|2
block|}
block|,
comment|/* cost of storing MMX registers 					   in SImode and DImode */
literal|12
block|,
comment|/* cost of moving SSE register */
block|{
literal|12
block|,
literal|12
block|,
literal|12
block|}
block|,
comment|/* cost of loading SSE registers 					   in SImode, DImode and TImode */
block|{
literal|2
block|,
literal|2
block|,
literal|8
block|}
block|,
comment|/* cost of storing SSE registers 					   in SImode, DImode and TImode */
literal|10
block|,
comment|/* MMX or SSE register to integer */
literal|64
block|,
comment|/* size of prefetch block */
literal|6
block|,
comment|/* number of parallel prefetches */
literal|2
block|,
comment|/* Branch cost */
literal|5
block|,
comment|/* cost of FADD and FSUB insns.  */
literal|7
block|,
comment|/* cost of FMUL instruction.  */
literal|43
block|,
comment|/* cost of FDIV instruction.  */
literal|2
block|,
comment|/* cost of FABS instruction.  */
literal|2
block|,
comment|/* cost of FCHS instruction.  */
literal|43
block|,
comment|/* cost of FSQRT instruction.  */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|processor_costs
modifier|*
name|ix86_cost
init|=
operator|&
name|pentium_cost
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Processor feature/optimization bitmasks.  */
end_comment

begin_define
define|#
directive|define
name|m_386
value|(1<<PROCESSOR_I386)
end_define

begin_define
define|#
directive|define
name|m_486
value|(1<<PROCESSOR_I486)
end_define

begin_define
define|#
directive|define
name|m_PENT
value|(1<<PROCESSOR_PENTIUM)
end_define

begin_define
define|#
directive|define
name|m_PPRO
value|(1<<PROCESSOR_PENTIUMPRO)
end_define

begin_define
define|#
directive|define
name|m_K6
value|(1<<PROCESSOR_K6)
end_define

begin_define
define|#
directive|define
name|m_ATHLON
value|(1<<PROCESSOR_ATHLON)
end_define

begin_define
define|#
directive|define
name|m_PENT4
value|(1<<PROCESSOR_PENTIUM4)
end_define

begin_define
define|#
directive|define
name|m_K8
value|(1<<PROCESSOR_K8)
end_define

begin_define
define|#
directive|define
name|m_ATHLON_K8
value|(m_K8 | m_ATHLON)
end_define

begin_decl_stmt
specifier|const
name|int
name|x86_use_leave
init|=
name|m_386
operator||
name|m_K6
operator||
name|m_ATHLON_K8
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_push_memory
init|=
name|m_386
operator||
name|m_K6
operator||
name|m_ATHLON_K8
operator||
name|m_PENT4
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_zero_extend_with_and
init|=
name|m_486
operator||
name|m_PENT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_movx
init|=
name|m_ATHLON_K8
operator||
name|m_PPRO
operator||
name|m_PENT4
comment|/* m_386 | m_K6 */
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_double_with_add
init|=
operator|~
name|m_386
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_use_bit_test
init|=
name|m_386
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_unroll_strlen
init|=
name|m_486
operator||
name|m_PENT
operator||
name|m_PPRO
operator||
name|m_ATHLON_K8
operator||
name|m_K6
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_cmove
init|=
name|m_PPRO
operator||
name|m_ATHLON_K8
operator||
name|m_PENT4
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_3dnow_a
init|=
name|m_ATHLON_K8
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_deep_branch
init|=
name|m_PPRO
operator||
name|m_K6
operator||
name|m_ATHLON_K8
operator||
name|m_PENT4
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_branch_hints
init|=
name|m_PENT4
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_use_sahf
init|=
name|m_PPRO
operator||
name|m_K6
operator||
name|m_PENT4
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_partial_reg_stall
init|=
name|m_PPRO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_use_loop
init|=
name|m_K6
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_use_fiop
init|=
operator|~
operator|(
name|m_PPRO
operator||
name|m_ATHLON_K8
operator||
name|m_PENT
operator|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_use_mov0
init|=
name|m_K6
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_use_cltd
init|=
operator|~
operator|(
name|m_PENT
operator||
name|m_K6
operator|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_read_modify_write
init|=
operator|~
name|m_PENT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_read_modify
init|=
operator|~
operator|(
name|m_PENT
operator||
name|m_PPRO
operator|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_split_long_moves
init|=
name|m_PPRO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_promote_QImode
init|=
name|m_K6
operator||
name|m_PENT
operator||
name|m_386
operator||
name|m_486
operator||
name|m_ATHLON_K8
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_fast_prefix
init|=
operator|~
operator|(
name|m_PENT
operator||
name|m_486
operator||
name|m_386
operator|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_single_stringop
init|=
name|m_386
operator||
name|m_PENT4
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_qimode_math
init|=
operator|~
operator|(
literal|0
operator|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_promote_qi_regs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_himode_math
init|=
operator|~
operator|(
name|m_PPRO
operator|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_promote_hi_regs
init|=
name|m_PPRO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_sub_esp_4
init|=
name|m_ATHLON_K8
operator||
name|m_PPRO
operator||
name|m_PENT4
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_sub_esp_8
init|=
name|m_ATHLON_K8
operator||
name|m_PPRO
operator||
name|m_386
operator||
name|m_486
operator||
name|m_PENT4
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_add_esp_4
init|=
name|m_ATHLON_K8
operator||
name|m_K6
operator||
name|m_PENT4
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_add_esp_8
init|=
name|m_ATHLON_K8
operator||
name|m_PPRO
operator||
name|m_K6
operator||
name|m_386
operator||
name|m_486
operator||
name|m_PENT4
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_integer_DFmode_moves
init|=
operator|~
operator|(
name|m_ATHLON_K8
operator||
name|m_PENT4
operator||
name|m_PPRO
operator|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_partial_reg_dependency
init|=
name|m_ATHLON_K8
operator||
name|m_PENT4
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_memory_mismatch_stall
init|=
name|m_ATHLON_K8
operator||
name|m_PENT4
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_accumulate_outgoing_args
init|=
name|m_ATHLON_K8
operator||
name|m_PENT4
operator||
name|m_PPRO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_prologue_using_move
init|=
name|m_ATHLON_K8
operator||
name|m_PENT4
operator||
name|m_PPRO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_epilogue_using_move
init|=
name|m_ATHLON_K8
operator||
name|m_PENT4
operator||
name|m_PPRO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_decompose_lea
init|=
name|m_PENT4
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_shift1
init|=
operator|~
name|m_486
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_arch_always_fancy_math_387
init|=
name|m_PENT
operator||
name|m_PPRO
operator||
name|m_ATHLON_K8
operator||
name|m_PENT4
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_sse_partial_reg_dependency
init|=
name|m_PENT4
operator||
name|m_PPRO
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set for machines where the type and dependencies are resolved on SSE register    parts instead of whole registers, so we may maintain just lower part of    scalar values in proper format leaving the upper part undefined.  */
end_comment

begin_decl_stmt
specifier|const
name|int
name|x86_sse_partial_regs
init|=
name|m_ATHLON_K8
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Athlon optimizes partial-register FPS special case, thus avoiding the    need for extra instructions beforehand  */
end_comment

begin_decl_stmt
specifier|const
name|int
name|x86_sse_partial_regs_for_cvtsd2ss
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_sse_typeless_stores
init|=
name|m_ATHLON_K8
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_sse_load0_by_pxor
init|=
name|m_PPRO
operator||
name|m_PENT4
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_use_ffreep
init|=
name|m_ATHLON_K8
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_rep_movl_optimal
init|=
name|m_386
operator||
name|m_PENT
operator||
name|m_PPRO
operator||
name|m_K6
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_inter_unit_moves
init|=
operator|~
operator|(
name|m_ATHLON_K8
operator|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|x86_ext_80387_constants
init|=
name|m_K6
operator||
name|m_ATHLON
operator||
name|m_PENT4
operator||
name|m_PPRO
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* In case the average insn count for single function invocation is    lower than this constant, emit fast (but longer) prologue and    epilogue code.  */
end_comment

begin_define
define|#
directive|define
name|FAST_PROLOGUE_INSN_COUNT
value|20
end_define

begin_comment
comment|/* Names for 8 (low), 8 (high), and 16-bit registers, respectively.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|qi_reg_name
index|[]
init|=
name|QI_REGISTER_NAMES
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|qi_high_reg_name
index|[]
init|=
name|QI_HIGH_REGISTER_NAMES
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|hi_reg_name
index|[]
init|=
name|HI_REGISTER_NAMES
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Array of the smallest class containing reg number REGNO, indexed by    REGNO.  Used by REGNO_REG_CLASS in i386.h.  */
end_comment

begin_decl_stmt
name|enum
name|reg_class
specifier|const
name|regclass_map
index|[
name|FIRST_PSEUDO_REGISTER
index|]
init|=
block|{
comment|/* ax, dx, cx, bx */
name|AREG
block|,
name|DREG
block|,
name|CREG
block|,
name|BREG
block|,
comment|/* si, di, bp, sp */
name|SIREG
block|,
name|DIREG
block|,
name|NON_Q_REGS
block|,
name|NON_Q_REGS
block|,
comment|/* FP registers */
name|FP_TOP_REG
block|,
name|FP_SECOND_REG
block|,
name|FLOAT_REGS
block|,
name|FLOAT_REGS
block|,
name|FLOAT_REGS
block|,
name|FLOAT_REGS
block|,
name|FLOAT_REGS
block|,
name|FLOAT_REGS
block|,
comment|/* arg pointer */
name|NON_Q_REGS
block|,
comment|/* flags, fpsr, dirflag, frame */
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NO_REGS
block|,
name|NON_Q_REGS
block|,
name|SSE_REGS
block|,
name|SSE_REGS
block|,
name|SSE_REGS
block|,
name|SSE_REGS
block|,
name|SSE_REGS
block|,
name|SSE_REGS
block|,
name|SSE_REGS
block|,
name|SSE_REGS
block|,
name|MMX_REGS
block|,
name|MMX_REGS
block|,
name|MMX_REGS
block|,
name|MMX_REGS
block|,
name|MMX_REGS
block|,
name|MMX_REGS
block|,
name|MMX_REGS
block|,
name|MMX_REGS
block|,
name|NON_Q_REGS
block|,
name|NON_Q_REGS
block|,
name|NON_Q_REGS
block|,
name|NON_Q_REGS
block|,
name|NON_Q_REGS
block|,
name|NON_Q_REGS
block|,
name|NON_Q_REGS
block|,
name|NON_Q_REGS
block|,
name|SSE_REGS
block|,
name|SSE_REGS
block|,
name|SSE_REGS
block|,
name|SSE_REGS
block|,
name|SSE_REGS
block|,
name|SSE_REGS
block|,
name|SSE_REGS
block|,
name|SSE_REGS
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The "default" register map used in 32bit mode.  */
end_comment

begin_decl_stmt
name|int
specifier|const
name|dbx_register_map
index|[
name|FIRST_PSEUDO_REGISTER
index|]
init|=
block|{
literal|0
block|,
literal|2
block|,
literal|1
block|,
literal|3
block|,
literal|6
block|,
literal|7
block|,
literal|4
block|,
literal|5
block|,
comment|/* general regs */
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|16
block|,
literal|17
block|,
literal|18
block|,
literal|19
block|,
comment|/* fp regs */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* arg, flags, fpsr, dir, frame */
literal|21
block|,
literal|22
block|,
literal|23
block|,
literal|24
block|,
literal|25
block|,
literal|26
block|,
literal|27
block|,
literal|28
block|,
comment|/* SSE */
literal|29
block|,
literal|30
block|,
literal|31
block|,
literal|32
block|,
literal|33
block|,
literal|34
block|,
literal|35
block|,
literal|36
block|,
comment|/* MMX */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* extended integer registers */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* extended SSE registers */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
specifier|const
name|x86_64_int_parameter_registers
index|[
literal|6
index|]
init|=
block|{
literal|5
comment|/*RDI*/
block|,
literal|4
comment|/*RSI*/
block|,
literal|1
comment|/*RDX*/
block|,
literal|2
comment|/*RCX*/
block|,
name|FIRST_REX_INT_REG
comment|/*R8 */
block|,
name|FIRST_REX_INT_REG
operator|+
literal|1
comment|/*R9 */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
specifier|const
name|x86_64_int_return_registers
index|[
literal|4
index|]
init|=
block|{
literal|0
comment|/*RAX*/
block|,
literal|1
comment|/*RDI*/
block|,
literal|5
comment|/*RDI*/
block|,
literal|4
comment|/*RSI*/
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The "default" register map used in 64bit mode.  */
end_comment

begin_decl_stmt
name|int
specifier|const
name|dbx64_register_map
index|[
name|FIRST_PSEUDO_REGISTER
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
comment|/* general regs */
literal|33
block|,
literal|34
block|,
literal|35
block|,
literal|36
block|,
literal|37
block|,
literal|38
block|,
literal|39
block|,
literal|40
block|,
comment|/* fp regs */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* arg, flags, fpsr, dir, frame */
literal|17
block|,
literal|18
block|,
literal|19
block|,
literal|20
block|,
literal|21
block|,
literal|22
block|,
literal|23
block|,
literal|24
block|,
comment|/* SSE */
literal|41
block|,
literal|42
block|,
literal|43
block|,
literal|44
block|,
literal|45
block|,
literal|46
block|,
literal|47
block|,
literal|48
block|,
comment|/* MMX */
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
comment|/* extended integer registers */
literal|25
block|,
literal|26
block|,
literal|27
block|,
literal|28
block|,
literal|29
block|,
literal|30
block|,
literal|31
block|,
literal|32
block|,
comment|/* extended SSE registers */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Define the register numbers to be used in Dwarf debugging information.    The SVR4 reference port C compiler uses the following register numbers    in its Dwarf output code: 	0 for %eax (gcc regno = 0) 	1 for %ecx (gcc regno = 2) 	2 for %edx (gcc regno = 1) 	3 for %ebx (gcc regno = 3) 	4 for %esp (gcc regno = 7) 	5 for %ebp (gcc regno = 6) 	6 for %esi (gcc regno = 4) 	7 for %edi (gcc regno = 5)    The following three DWARF register numbers are never generated by    the SVR4 C compiler or by the GNU compilers, but SDB on x86/svr4    believes these numbers have these meanings. 	8  for %eip    (no gcc equivalent) 	9  for %eflags (gcc regno = 17) 	10 for %trapno (no gcc equivalent)    It is not at all clear how we should number the FP stack registers    for the x86 architecture.  If the version of SDB on x86/svr4 were    a bit less brain dead with respect to floating-point then we would    have a precedent to follow with respect to DWARF register numbers    for x86 FP registers, but the SDB on x86/svr4 is so completely    broken with respect to FP registers that it is hardly worth thinking    of it as something to strive for compatibility with.    The version of x86/svr4 SDB I have at the moment does (partially)    seem to believe that DWARF register number 11 is associated with    the x86 register %st(0), but that's about all.  Higher DWARF    register numbers don't seem to be associated with anything in    particular, and even for DWARF regno 11, SDB only seems to under-    stand that it should say that a variable lives in %st(0) (when    asked via an `=' command) if we said it was in DWARF regno 11,    but SDB still prints garbage when asked for the value of the    variable in question (via a `/' command).    (Also note that the labels SDB prints for various FP stack regs    when doing an `x' command are all wrong.)    Note that these problems generally don't affect the native SVR4    C compiler because it doesn't allow the use of -O with -g and    because when it is *not* optimizing, it allocates a memory    location for each floating-point variable, and the memory    location is what gets described in the DWARF AT_location    attribute for the variable in question.    Regardless of the severe mental illness of the x86/svr4 SDB, we    do something sensible here and we use the following DWARF    register numbers.  Note that these are all stack-top-relative    numbers. 	11 for %st(0) (gcc regno = 8) 	12 for %st(1) (gcc regno = 9) 	13 for %st(2) (gcc regno = 10) 	14 for %st(3) (gcc regno = 11) 	15 for %st(4) (gcc regno = 12) 	16 for %st(5) (gcc regno = 13) 	17 for %st(6) (gcc regno = 14) 	18 for %st(7) (gcc regno = 15) */
end_comment

begin_decl_stmt
name|int
specifier|const
name|svr4_dbx_register_map
index|[
name|FIRST_PSEUDO_REGISTER
index|]
init|=
block|{
literal|0
block|,
literal|2
block|,
literal|1
block|,
literal|3
block|,
literal|6
block|,
literal|7
block|,
literal|5
block|,
literal|4
block|,
comment|/* general regs */
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|16
block|,
literal|17
block|,
literal|18
block|,
comment|/* fp regs */
operator|-
literal|1
block|,
literal|9
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* arg, flags, fpsr, dir, frame */
literal|21
block|,
literal|22
block|,
literal|23
block|,
literal|24
block|,
literal|25
block|,
literal|26
block|,
literal|27
block|,
literal|28
block|,
comment|/* SSE registers */
literal|29
block|,
literal|30
block|,
literal|31
block|,
literal|32
block|,
literal|33
block|,
literal|34
block|,
literal|35
block|,
literal|36
block|,
comment|/* MMX registers */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* extended integer registers */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* extended SSE registers */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Test and compare insns in i386.md store the information needed to    generate branch and scc insns here.  */
end_comment

begin_decl_stmt
name|rtx
name|ix86_compare_op0
init|=
name|NULL_RTX
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|ix86_compare_op1
init|=
name|NULL_RTX
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MAX_386_STACK_LOCALS
value|3
end_define

begin_comment
comment|/* Size of the register save area.  */
end_comment

begin_define
define|#
directive|define
name|X86_64_VARARGS_SIZE
value|(REGPARM_MAX * UNITS_PER_WORD + SSE_REGPARM_MAX * 16)
end_define

begin_comment
comment|/* Define the structure for the machine field in struct function.  */
end_comment

begin_decl_stmt
name|struct
name|stack_local_entry
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
name|unsigned
name|short
name|mode
decl_stmt|;
name|unsigned
name|short
name|n
decl_stmt|;
name|rtx
name|rtl
decl_stmt|;
name|struct
name|stack_local_entry
modifier|*
name|next
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* Structure describing stack frame layout.    Stack grows downward:     [arguments]<- ARG_POINTER    saved pc     saved frame pointer if frame_pointer_needed<- HARD_FRAME_POINTER    [saved regs]     [padding1]          \ 		        )    [va_arg registers]  (> to_allocate<- FRAME_POINTER    [frame]	       ( 		        )    [padding2]	       /   */
end_comment

begin_struct
struct|struct
name|ix86_frame
block|{
name|int
name|nregs
decl_stmt|;
name|int
name|padding1
decl_stmt|;
name|int
name|va_arg_size
decl_stmt|;
name|HOST_WIDE_INT
name|frame
decl_stmt|;
name|int
name|padding2
decl_stmt|;
name|int
name|outgoing_arguments_size
decl_stmt|;
name|int
name|red_zone_size
decl_stmt|;
name|HOST_WIDE_INT
name|to_allocate
decl_stmt|;
comment|/* The offsets relative to ARG_POINTER.  */
name|HOST_WIDE_INT
name|frame_pointer_offset
decl_stmt|;
name|HOST_WIDE_INT
name|hard_frame_pointer_offset
decl_stmt|;
name|HOST_WIDE_INT
name|stack_pointer_offset
decl_stmt|;
comment|/* When save_regs_using_mov is set, emit prologue using      move instead of push instructions.  */
name|bool
name|save_regs_using_mov
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Used to enable/disable debugging features.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|ix86_debug_arg_string
decl_stmt|,
modifier|*
name|ix86_debug_addr_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Code model option as passed by user.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|ix86_cmodel_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parsed value.  */
end_comment

begin_decl_stmt
name|enum
name|cmodel
name|ix86_cmodel
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Asm dialect.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|ix86_asm_string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|asm_dialect
name|ix86_asm_dialect
init|=
name|ASM_ATT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TLS dialext.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|ix86_tls_dialect_string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|tls_dialect
name|ix86_tls_dialect
init|=
name|TLS_DIALECT_GNU
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Which unit we are generating floating point math for.  */
end_comment

begin_decl_stmt
name|enum
name|fpmath_unit
name|ix86_fpmath
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Which cpu are we scheduling for.  */
end_comment

begin_decl_stmt
name|enum
name|processor_type
name|ix86_tune
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Which instruction set architecture to use.  */
end_comment

begin_decl_stmt
name|enum
name|processor_type
name|ix86_arch
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Strings to hold which cpu and instruction set architecture  to use.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|ix86_tune_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for -mtune=<xxx> */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|ix86_arch_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for -march=<xxx> */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|ix86_fpmath_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for -mfpmath=<xxx> */
end_comment

begin_comment
comment|/* # of registers to use to pass arguments.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|ix86_regparm_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if sse prefetch instruction is not NOOP.  */
end_comment

begin_decl_stmt
name|int
name|x86_prefetch_sse
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ix86_regparm_string as a number */
end_comment

begin_decl_stmt
name|int
name|ix86_regparm
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Alignment to use for loops and jumps:  */
end_comment

begin_comment
comment|/* Power of two alignment for loops.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|ix86_align_loops_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Power of two alignment for non-loop jumps.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|ix86_align_jumps_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Power of two alignment for stack boundary in bytes.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|ix86_preferred_stack_boundary_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Preferred alignment for stack boundary in bits.  */
end_comment

begin_decl_stmt
name|int
name|ix86_preferred_stack_boundary
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Values 1-5: see jump.c */
end_comment

begin_decl_stmt
name|int
name|ix86_branch_cost
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|ix86_branch_cost_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Power of two alignment for functions.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|ix86_align_funcs_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Prefix built by ASM_GENERATE_INTERNAL_LABEL.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|internal_label_prefix
index|[
literal|16
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|internal_label_prefix_len
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function_decl
specifier|static
name|int
name|local_symbolic_operand
parameter_list|(
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tls_symbolic_operand_1
parameter_list|(
name|rtx
parameter_list|,
name|enum
name|tls_model
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|output_pic_addr_const
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|put_condition_code
parameter_list|(
name|enum
name|rtx_code
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|get_some_local_dynamic_name
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_some_local_dynamic_name_1
parameter_list|(
name|rtx
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|maybe_get_pool_constant
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|ix86_expand_int_compare
parameter_list|(
name|enum
name|rtx_code
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|rtx_code
name|ix86_prepare_fp_compare_args
parameter_list|(
name|enum
name|rtx_code
parameter_list|,
name|rtx
modifier|*
parameter_list|,
name|rtx
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|ix86_fixed_condition_code_regs
parameter_list|(
name|unsigned
name|int
modifier|*
parameter_list|,
name|unsigned
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|machine_mode
name|ix86_cc_modes_compatible
parameter_list|(
name|enum
name|machine_mode
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|get_thread_pointer
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|legitimize_tls_address
parameter_list|(
name|rtx
parameter_list|,
name|enum
name|tls_model
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|get_pc_thunk_name
parameter_list|(
name|char
index|[
literal|32
index|]
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|gen_push
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|memory_address_length
parameter_list|(
name|rtx
name|addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ix86_flags_dependant
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|attr_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ix86_agi_dependant
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|attr_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|attr_ppro_uops
name|ix86_safe_ppro_uops
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ix86_dump_ppro_packet
parameter_list|(
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ix86_reorder_insn
parameter_list|(
name|rtx
modifier|*
parameter_list|,
name|rtx
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|machine_function
modifier|*
name|ix86_init_machine_status
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ix86_split_to_parts
parameter_list|(
name|rtx
parameter_list|,
name|rtx
modifier|*
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ix86_nsaved_regs
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ix86_emit_save_regs
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ix86_emit_save_regs_using_mov
parameter_list|(
name|rtx
parameter_list|,
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ix86_emit_restore_regs_using_mov
parameter_list|(
name|rtx
parameter_list|,
name|HOST_WIDE_INT
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ix86_output_function_epilogue
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ix86_sched_reorder_ppro
parameter_list|(
name|rtx
modifier|*
parameter_list|,
name|rtx
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|HOST_WIDE_INT
name|ix86_GOT_alias_set
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ix86_adjust_counter
parameter_list|(
name|rtx
parameter_list|,
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|ix86_expand_aligntest
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ix86_expand_strlensi_unroll_1
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ix86_issue_rate
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ix86_adjust_cost
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ix86_sched_init
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ix86_sched_reorder
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|,
name|rtx
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ix86_variable_issue
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ia32_use_dfa_pipeline_interface
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ia32_multipass_dfa_lookahead
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ix86_init_mmx_sse_builtins
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|x86_this_parameter
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|x86_output_mi_thunk
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|HOST_WIDE_INT
parameter_list|,
name|HOST_WIDE_INT
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|x86_can_output_mi_thunk
parameter_list|(
name|tree
parameter_list|,
name|HOST_WIDE_INT
parameter_list|,
name|HOST_WIDE_INT
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|x86_file_start
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ix86_reorg
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|ix86_expand_carry_flag_compare
parameter_list|(
name|enum
name|rtx_code
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|ix86_build_builtin_va_list
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_struct
struct|struct
name|ix86_address
block|{
name|rtx
name|base
decl_stmt|,
name|index
decl_stmt|,
name|disp
decl_stmt|;
name|HOST_WIDE_INT
name|scale
decl_stmt|;
enum|enum
name|ix86_address_seg
block|{
name|SEG_DEFAULT
block|,
name|SEG_FS
block|,
name|SEG_GS
block|}
name|seg
enum|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|ix86_decompose_address
parameter_list|(
name|rtx
parameter_list|,
name|struct
name|ix86_address
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ix86_address_cost
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|ix86_cannot_force_const_mem
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|ix86_delegitimize_address
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_struct_decl
struct_decl|struct
name|builtin_description
struct_decl|;
end_struct_decl

begin_function_decl
specifier|static
name|rtx
name|ix86_expand_sse_comi
parameter_list|(
specifier|const
name|struct
name|builtin_description
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|ix86_expand_sse_compare
parameter_list|(
specifier|const
name|struct
name|builtin_description
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|ix86_expand_unop1_builtin
parameter_list|(
name|enum
name|insn_code
parameter_list|,
name|tree
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|ix86_expand_unop_builtin
parameter_list|(
name|enum
name|insn_code
parameter_list|,
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|ix86_expand_binop_builtin
parameter_list|(
name|enum
name|insn_code
parameter_list|,
name|tree
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|ix86_expand_store_builtin
parameter_list|(
name|enum
name|insn_code
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|safe_vector_operand
parameter_list|(
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|rtx_code
name|ix86_fp_compare_code_to_integer
parameter_list|(
name|enum
name|rtx_code
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ix86_fp_comparison_codes
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|enum
name|rtx_code
modifier|*
parameter_list|,
name|enum
name|rtx_code
modifier|*
parameter_list|,
name|enum
name|rtx_code
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|ix86_expand_fp_compare
parameter_list|(
name|enum
name|rtx_code
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
modifier|*
parameter_list|,
name|rtx
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ix86_fp_comparison_arithmetics_cost
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ix86_fp_comparison_fcomi_cost
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ix86_fp_comparison_sahf_cost
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ix86_fp_comparison_cost
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|int
name|ix86_select_alt_pic_regnum
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ix86_save_reg
parameter_list|(
name|unsigned
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ix86_compute_frame_layout
parameter_list|(
name|struct
name|ix86_frame
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ix86_comp_type_attributes
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ix86_function_regparm
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|const
name|struct
name|attribute_spec
name|ix86_attribute_table
index|[]
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|bool
name|ix86_function_ok_for_sibcall
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|ix86_handle_cdecl_attribute
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|ix86_handle_regparm_attribute
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ix86_value_regno
parameter_list|(
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|contains_128bit_aligned_vector_p
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|ix86_ms_bitfield_layout_p
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|ix86_handle_struct_attribute
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|extended_reg_mentioned_1
parameter_list|(
name|rtx
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|ix86_rtx_costs
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|min_insn_size
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|k8_avoid_jump_misspredicts
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DO_GLOBAL_CTORS_BODY
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAS_INIT_SECTION
argument_list|)
end_if

begin_function_decl
specifier|static
name|void
name|ix86_svr3_asm_out_constructor
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Register class used for passing given 64bit part of the argument.    These represent classes as documented by the PS ABI, with the exception    of SSESF, SSEDF classes, that are basically SSE class, just gcc will    use SF or DFmode move instead of DImode to avoid reformatting penalties.     Similarly we play games with INTEGERSI_CLASS to use cheaper SImode moves    whenever possible (upper half does contain padding).  */
end_comment

begin_enum
enum|enum
name|x86_64_reg_class
block|{
name|X86_64_NO_CLASS
block|,
name|X86_64_INTEGER_CLASS
block|,
name|X86_64_INTEGERSI_CLASS
block|,
name|X86_64_SSE_CLASS
block|,
name|X86_64_SSESF_CLASS
block|,
name|X86_64_SSEDF_CLASS
block|,
name|X86_64_SSEUP_CLASS
block|,
name|X86_64_X87_CLASS
block|,
name|X86_64_X87UP_CLASS
block|,
name|X86_64_MEMORY_CLASS
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|x86_64_reg_class_name
index|[]
init|=
block|{
literal|"no"
block|,
literal|"integer"
block|,
literal|"integerSI"
block|,
literal|"sse"
block|,
literal|"sseSF"
block|,
literal|"sseDF"
block|,
literal|"sseup"
block|,
literal|"x87"
block|,
literal|"x87up"
block|,
literal|"no"
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MAX_CLASSES
value|4
end_define

begin_function_decl
specifier|static
name|int
name|classify_argument
parameter_list|(
name|enum
name|machine_mode
parameter_list|,
name|tree
parameter_list|,
name|enum
name|x86_64_reg_class
type|[
function_decl|MAX_CLASSES]
operator|,
function_decl|int
end_function_decl

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|static
name|int
name|examine_argument
parameter_list|(
name|enum
name|machine_mode
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|construct_container
parameter_list|(
name|enum
name|machine_mode
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
specifier|const
name|int
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|x86_64_reg_class
name|merge_classes
parameter_list|(
name|enum
name|x86_64_reg_class
parameter_list|,
name|enum
name|x86_64_reg_class
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Table of constants used by fldpi, fldln2, etc....  */
end_comment

begin_decl_stmt
specifier|static
name|REAL_VALUE_TYPE
name|ext_80387_constants_table
index|[
literal|5
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|ext_80387_constants_init
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|init_ext_80387_constants
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Initialize the GCC target structure.  */
end_comment

begin_undef
undef|#
directive|undef
name|TARGET_ATTRIBUTE_TABLE
end_undef

begin_define
define|#
directive|define
name|TARGET_ATTRIBUTE_TABLE
value|ix86_attribute_table
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|TARGET_DLLIMPORT_DECL_ATTRIBUTES
end_ifdef

begin_undef
undef|#
directive|undef
name|TARGET_MERGE_DECL_ATTRIBUTES
end_undef

begin_define
define|#
directive|define
name|TARGET_MERGE_DECL_ATTRIBUTES
value|merge_dllimport_decl_attributes
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|TARGET_COMP_TYPE_ATTRIBUTES
end_undef

begin_define
define|#
directive|define
name|TARGET_COMP_TYPE_ATTRIBUTES
value|ix86_comp_type_attributes
end_define

begin_undef
undef|#
directive|undef
name|TARGET_INIT_BUILTINS
end_undef

begin_define
define|#
directive|define
name|TARGET_INIT_BUILTINS
value|ix86_init_builtins
end_define

begin_undef
undef|#
directive|undef
name|TARGET_EXPAND_BUILTIN
end_undef

begin_define
define|#
directive|define
name|TARGET_EXPAND_BUILTIN
value|ix86_expand_builtin
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_FUNCTION_EPILOGUE
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_FUNCTION_EPILOGUE
value|ix86_output_function_epilogue
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_OPEN_PAREN
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_OPEN_PAREN
value|""
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_CLOSE_PAREN
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_CLOSE_PAREN
value|""
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_ALIGNED_HI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_ALIGNED_HI_OP
value|ASM_SHORT
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_ALIGNED_SI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_ALIGNED_SI_OP
value|ASM_LONG
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|ASM_QUAD
end_ifdef

begin_undef
undef|#
directive|undef
name|TARGET_ASM_ALIGNED_DI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_ALIGNED_DI_OP
value|ASM_QUAD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|TARGET_ASM_UNALIGNED_HI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_UNALIGNED_HI_OP
value|TARGET_ASM_ALIGNED_HI_OP
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_UNALIGNED_SI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_UNALIGNED_SI_OP
value|TARGET_ASM_ALIGNED_SI_OP
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_UNALIGNED_DI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_UNALIGNED_DI_OP
value|TARGET_ASM_ALIGNED_DI_OP
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_ADJUST_COST
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_ADJUST_COST
value|ix86_adjust_cost
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_ISSUE_RATE
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_ISSUE_RATE
value|ix86_issue_rate
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_VARIABLE_ISSUE
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_VARIABLE_ISSUE
value|ix86_variable_issue
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_INIT
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_INIT
value|ix86_sched_init
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_REORDER
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_REORDER
value|ix86_sched_reorder
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE
define|\
value|ia32_use_dfa_pipeline_interface
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD
define|\
value|ia32_multipass_dfa_lookahead
end_define

begin_undef
undef|#
directive|undef
name|TARGET_FUNCTION_OK_FOR_SIBCALL
end_undef

begin_define
define|#
directive|define
name|TARGET_FUNCTION_OK_FOR_SIBCALL
value|ix86_function_ok_for_sibcall
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_AS_TLS
end_ifdef

begin_undef
undef|#
directive|undef
name|TARGET_HAVE_TLS
end_undef

begin_define
define|#
directive|define
name|TARGET_HAVE_TLS
value|true
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|TARGET_CANNOT_FORCE_CONST_MEM
end_undef

begin_define
define|#
directive|define
name|TARGET_CANNOT_FORCE_CONST_MEM
value|ix86_cannot_force_const_mem
end_define

begin_undef
undef|#
directive|undef
name|TARGET_DELEGITIMIZE_ADDRESS
end_undef

begin_define
define|#
directive|define
name|TARGET_DELEGITIMIZE_ADDRESS
value|ix86_delegitimize_address
end_define

begin_undef
undef|#
directive|undef
name|TARGET_MS_BITFIELD_LAYOUT_P
end_undef

begin_define
define|#
directive|define
name|TARGET_MS_BITFIELD_LAYOUT_P
value|ix86_ms_bitfield_layout_p
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_OUTPUT_MI_THUNK
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_OUTPUT_MI_THUNK
value|x86_output_mi_thunk
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_CAN_OUTPUT_MI_THUNK
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_CAN_OUTPUT_MI_THUNK
value|x86_can_output_mi_thunk
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_FILE_START
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_FILE_START
value|x86_file_start
end_define

begin_undef
undef|#
directive|undef
name|TARGET_RTX_COSTS
end_undef

begin_define
define|#
directive|define
name|TARGET_RTX_COSTS
value|ix86_rtx_costs
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ADDRESS_COST
end_undef

begin_define
define|#
directive|define
name|TARGET_ADDRESS_COST
value|ix86_address_cost
end_define

begin_undef
undef|#
directive|undef
name|TARGET_FIXED_CONDITION_CODE_REGS
end_undef

begin_define
define|#
directive|define
name|TARGET_FIXED_CONDITION_CODE_REGS
value|ix86_fixed_condition_code_regs
end_define

begin_undef
undef|#
directive|undef
name|TARGET_CC_MODES_COMPATIBLE
end_undef

begin_define
define|#
directive|define
name|TARGET_CC_MODES_COMPATIBLE
value|ix86_cc_modes_compatible
end_define

begin_undef
undef|#
directive|undef
name|TARGET_MACHINE_DEPENDENT_REORG
end_undef

begin_define
define|#
directive|define
name|TARGET_MACHINE_DEPENDENT_REORG
value|ix86_reorg
end_define

begin_undef
undef|#
directive|undef
name|TARGET_BUILD_BUILTIN_VA_LIST
end_undef

begin_define
define|#
directive|define
name|TARGET_BUILD_BUILTIN_VA_LIST
value|ix86_build_builtin_va_list
end_define

begin_decl_stmt
name|struct
name|gcc_target
name|targetm
init|=
name|TARGET_INITIALIZER
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* The svr4 ABI for the i386 says that records and unions are returned    in memory.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DEFAULT_PCC_STRUCT_RETURN
end_ifndef

begin_define
define|#
directive|define
name|DEFAULT_PCC_STRUCT_RETURN
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Sometimes certain combinations of command options do not make    sense on a particular target machine.  You can define a macro    `OVERRIDE_OPTIONS' to take account of this.  This macro, if    defined, is executed once just after all the command options have    been parsed.     Don't use this macro to turn on various extra optimizations for    `-O'.  That is what `OPTIMIZATION_OPTIONS' is for.  */
end_comment

begin_function
name|void
name|override_options
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Comes from final.c -- no real reason to change it.  */
define|#
directive|define
name|MAX_CODE_ALIGN
value|16
specifier|static
struct|struct
name|ptt
block|{
specifier|const
name|struct
name|processor_costs
modifier|*
name|cost
decl_stmt|;
comment|/* Processor costs */
specifier|const
name|int
name|target_enable
decl_stmt|;
comment|/* Target flags to enable.  */
specifier|const
name|int
name|target_disable
decl_stmt|;
comment|/* Target flags to disable.  */
specifier|const
name|int
name|align_loop
decl_stmt|;
comment|/* Default alignments.  */
specifier|const
name|int
name|align_loop_max_skip
decl_stmt|;
specifier|const
name|int
name|align_jump
decl_stmt|;
specifier|const
name|int
name|align_jump_max_skip
decl_stmt|;
specifier|const
name|int
name|align_func
decl_stmt|;
block|}
decl|const
name|processor_target_table
index|[
name|PROCESSOR_max
index|]
init|=
block|{
block|{
operator|&
name|i386_cost
block|,
literal|0
block|,
literal|0
block|,
literal|4
block|,
literal|3
block|,
literal|4
block|,
literal|3
block|,
literal|4
block|}
block|,
block|{
operator|&
name|i486_cost
block|,
literal|0
block|,
literal|0
block|,
literal|16
block|,
literal|15
block|,
literal|16
block|,
literal|15
block|,
literal|16
block|}
block|,
block|{
operator|&
name|pentium_cost
block|,
literal|0
block|,
literal|0
block|,
literal|16
block|,
literal|7
block|,
literal|16
block|,
literal|7
block|,
literal|16
block|}
block|,
block|{
operator|&
name|pentiumpro_cost
block|,
literal|0
block|,
literal|0
block|,
literal|16
block|,
literal|15
block|,
literal|16
block|,
literal|7
block|,
literal|16
block|}
block|,
block|{
operator|&
name|k6_cost
block|,
literal|0
block|,
literal|0
block|,
literal|32
block|,
literal|7
block|,
literal|32
block|,
literal|7
block|,
literal|32
block|}
block|,
block|{
operator|&
name|athlon_cost
block|,
literal|0
block|,
literal|0
block|,
literal|16
block|,
literal|7
block|,
literal|16
block|,
literal|7
block|,
literal|16
block|}
block|,
block|{
operator|&
name|pentium4_cost
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
operator|&
name|k8_cost
block|,
literal|0
block|,
literal|0
block|,
literal|16
block|,
literal|7
block|,
literal|16
block|,
literal|7
block|,
literal|16
block|}
block|}
struct|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|cpu_names
index|[]
init|=
name|TARGET_CPU_DEFAULT_NAMES
decl_stmt|;
specifier|static
struct|struct
name|pta
block|{
specifier|const
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
comment|/* processor name or nickname.  */
specifier|const
name|enum
name|processor_type
name|processor
decl_stmt|;
specifier|const
enum|enum
name|pta_flags
block|{
name|PTA_SSE
init|=
literal|1
block|,
name|PTA_SSE2
init|=
literal|2
block|,
name|PTA_SSE3
init|=
literal|4
block|,
name|PTA_MMX
init|=
literal|8
block|,
name|PTA_PREFETCH_SSE
init|=
literal|16
block|,
name|PTA_3DNOW
init|=
literal|32
block|,
name|PTA_3DNOW_A
init|=
literal|64
block|,
name|PTA_64BIT
init|=
literal|128
block|}
name|flags
enum|;
block|}
decl|const
name|processor_alias_table
index|[]
init|=
block|{
block|{
literal|"i386"
block|,
name|PROCESSOR_I386
block|,
literal|0
block|}
block|,
block|{
literal|"i486"
block|,
name|PROCESSOR_I486
block|,
literal|0
block|}
block|,
block|{
literal|"i586"
block|,
name|PROCESSOR_PENTIUM
block|,
literal|0
block|}
block|,
block|{
literal|"pentium"
block|,
name|PROCESSOR_PENTIUM
block|,
literal|0
block|}
block|,
block|{
literal|"pentium-mmx"
block|,
name|PROCESSOR_PENTIUM
block|,
name|PTA_MMX
block|}
block|,
block|{
literal|"winchip-c6"
block|,
name|PROCESSOR_I486
block|,
name|PTA_MMX
block|}
block|,
block|{
literal|"winchip2"
block|,
name|PROCESSOR_I486
block|,
name|PTA_MMX
operator||
name|PTA_3DNOW
block|}
block|,
block|{
literal|"c3"
block|,
name|PROCESSOR_I486
block|,
name|PTA_MMX
operator||
name|PTA_3DNOW
block|}
block|,
block|{
literal|"c3-2"
block|,
name|PROCESSOR_PENTIUMPRO
block|,
name|PTA_MMX
operator||
name|PTA_PREFETCH_SSE
operator||
name|PTA_SSE
block|}
block|,
block|{
literal|"i686"
block|,
name|PROCESSOR_PENTIUMPRO
block|,
literal|0
block|}
block|,
block|{
literal|"pentiumpro"
block|,
name|PROCESSOR_PENTIUMPRO
block|,
literal|0
block|}
block|,
block|{
literal|"pentium2"
block|,
name|PROCESSOR_PENTIUMPRO
block|,
name|PTA_MMX
block|}
block|,
block|{
literal|"pentium3"
block|,
name|PROCESSOR_PENTIUMPRO
block|,
name|PTA_MMX
operator||
name|PTA_SSE
operator||
name|PTA_PREFETCH_SSE
block|}
block|,
block|{
literal|"pentium3m"
block|,
name|PROCESSOR_PENTIUMPRO
block|,
name|PTA_MMX
operator||
name|PTA_SSE
operator||
name|PTA_PREFETCH_SSE
block|}
block|,
block|{
literal|"pentium-m"
block|,
name|PROCESSOR_PENTIUMPRO
block|,
name|PTA_MMX
operator||
name|PTA_SSE
operator||
name|PTA_PREFETCH_SSE
operator||
name|PTA_SSE2
block|}
block|,
block|{
literal|"pentium4"
block|,
name|PROCESSOR_PENTIUM4
block|,
name|PTA_SSE
operator||
name|PTA_SSE2
operator||
name|PTA_MMX
operator||
name|PTA_PREFETCH_SSE
block|}
block|,
block|{
literal|"pentium4m"
block|,
name|PROCESSOR_PENTIUM4
block|,
name|PTA_SSE
operator||
name|PTA_SSE2
operator||
name|PTA_MMX
operator||
name|PTA_PREFETCH_SSE
block|}
block|,
block|{
literal|"prescott"
block|,
name|PROCESSOR_PENTIUM4
block|,
name|PTA_SSE
operator||
name|PTA_SSE2
operator||
name|PTA_SSE3
operator||
name|PTA_MMX
operator||
name|PTA_PREFETCH_SSE
block|}
block|,
block|{
literal|"nocona"
block|,
name|PROCESSOR_PENTIUM4
block|,
name|PTA_SSE
operator||
name|PTA_SSE2
operator||
name|PTA_SSE3
operator||
name|PTA_64BIT
operator||
name|PTA_MMX
operator||
name|PTA_PREFETCH_SSE
block|}
block|,
block|{
literal|"k6"
block|,
name|PROCESSOR_K6
block|,
name|PTA_MMX
block|}
block|,
block|{
literal|"k6-2"
block|,
name|PROCESSOR_K6
block|,
name|PTA_MMX
operator||
name|PTA_3DNOW
block|}
block|,
block|{
literal|"k6-3"
block|,
name|PROCESSOR_K6
block|,
name|PTA_MMX
operator||
name|PTA_3DNOW
block|}
block|,
block|{
literal|"athlon"
block|,
name|PROCESSOR_ATHLON
block|,
name|PTA_MMX
operator||
name|PTA_PREFETCH_SSE
operator||
name|PTA_3DNOW
operator||
name|PTA_3DNOW_A
block|}
block|,
block|{
literal|"athlon-tbird"
block|,
name|PROCESSOR_ATHLON
block|,
name|PTA_MMX
operator||
name|PTA_PREFETCH_SSE
operator||
name|PTA_3DNOW
operator||
name|PTA_3DNOW_A
block|}
block|,
block|{
literal|"athlon-4"
block|,
name|PROCESSOR_ATHLON
block|,
name|PTA_MMX
operator||
name|PTA_PREFETCH_SSE
operator||
name|PTA_3DNOW
operator||
name|PTA_3DNOW_A
operator||
name|PTA_SSE
block|}
block|,
block|{
literal|"athlon-xp"
block|,
name|PROCESSOR_ATHLON
block|,
name|PTA_MMX
operator||
name|PTA_PREFETCH_SSE
operator||
name|PTA_3DNOW
operator||
name|PTA_3DNOW_A
operator||
name|PTA_SSE
block|}
block|,
block|{
literal|"athlon-mp"
block|,
name|PROCESSOR_ATHLON
block|,
name|PTA_MMX
operator||
name|PTA_PREFETCH_SSE
operator||
name|PTA_3DNOW
operator||
name|PTA_3DNOW_A
operator||
name|PTA_SSE
block|}
block|,
block|{
literal|"x86-64"
block|,
name|PROCESSOR_K8
block|,
name|PTA_MMX
operator||
name|PTA_PREFETCH_SSE
operator||
name|PTA_64BIT
operator||
name|PTA_SSE
operator||
name|PTA_SSE2
block|}
block|,
block|{
literal|"k8"
block|,
name|PROCESSOR_K8
block|,
name|PTA_MMX
operator||
name|PTA_PREFETCH_SSE
operator||
name|PTA_3DNOW
operator||
name|PTA_64BIT
operator||
name|PTA_3DNOW_A
operator||
name|PTA_SSE
operator||
name|PTA_SSE2
block|}
block|,
block|{
literal|"opteron"
block|,
name|PROCESSOR_K8
block|,
name|PTA_MMX
operator||
name|PTA_PREFETCH_SSE
operator||
name|PTA_3DNOW
operator||
name|PTA_64BIT
operator||
name|PTA_3DNOW_A
operator||
name|PTA_SSE
operator||
name|PTA_SSE2
block|}
block|,
block|{
literal|"athlon64"
block|,
name|PROCESSOR_K8
block|,
name|PTA_MMX
operator||
name|PTA_PREFETCH_SSE
operator||
name|PTA_3DNOW
operator||
name|PTA_64BIT
operator||
name|PTA_3DNOW_A
operator||
name|PTA_SSE
operator||
name|PTA_SSE2
block|}
block|,
block|{
literal|"athlon-fx"
block|,
name|PROCESSOR_K8
block|,
name|PTA_MMX
operator||
name|PTA_PREFETCH_SSE
operator||
name|PTA_3DNOW
operator||
name|PTA_64BIT
operator||
name|PTA_3DNOW_A
operator||
name|PTA_SSE
operator||
name|PTA_SSE2
block|}
block|,     }
struct|;
name|int
specifier|const
name|pta_size
init|=
name|ARRAY_SIZE
argument_list|(
name|processor_alias_table
argument_list|)
decl_stmt|;
comment|/* Set the default values for switches whose default depends on TARGET_64BIT      in case they weren't overwritten by command line options.  */
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
if|if
condition|(
name|flag_omit_frame_pointer
operator|==
literal|2
condition|)
name|flag_omit_frame_pointer
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|flag_asynchronous_unwind_tables
operator|==
literal|2
condition|)
name|flag_asynchronous_unwind_tables
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|flag_pcc_struct_return
operator|==
literal|2
condition|)
name|flag_pcc_struct_return
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|flag_omit_frame_pointer
operator|==
literal|2
condition|)
name|flag_omit_frame_pointer
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flag_asynchronous_unwind_tables
operator|==
literal|2
condition|)
name|flag_asynchronous_unwind_tables
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flag_pcc_struct_return
operator|==
literal|2
condition|)
name|flag_pcc_struct_return
operator|=
name|DEFAULT_PCC_STRUCT_RETURN
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SUBTARGET_OVERRIDE_OPTIONS
name|SUBTARGET_OVERRIDE_OPTIONS
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|ix86_tune_string
operator|&&
name|ix86_arch_string
condition|)
name|ix86_tune_string
operator|=
name|ix86_arch_string
expr_stmt|;
if|if
condition|(
operator|!
name|ix86_tune_string
condition|)
name|ix86_tune_string
operator|=
name|cpu_names
index|[
name|TARGET_CPU_DEFAULT
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|ix86_arch_string
condition|)
name|ix86_arch_string
operator|=
name|TARGET_64BIT
condition|?
literal|"x86-64"
else|:
literal|"i386"
expr_stmt|;
if|if
condition|(
name|ix86_cmodel_string
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ix86_cmodel_string
argument_list|,
literal|"small"
argument_list|)
condition|)
name|ix86_cmodel
operator|=
name|flag_pic
condition|?
name|CM_SMALL_PIC
else|:
name|CM_SMALL
expr_stmt|;
elseif|else
if|if
condition|(
name|flag_pic
condition|)
name|sorry
argument_list|(
literal|"code model %s not supported in PIC mode"
argument_list|,
name|ix86_cmodel_string
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ix86_cmodel_string
argument_list|,
literal|"32"
argument_list|)
condition|)
name|ix86_cmodel
operator|=
name|CM_32
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ix86_cmodel_string
argument_list|,
literal|"kernel"
argument_list|)
operator|&&
operator|!
name|flag_pic
condition|)
name|ix86_cmodel
operator|=
name|CM_KERNEL
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ix86_cmodel_string
argument_list|,
literal|"medium"
argument_list|)
operator|&&
operator|!
name|flag_pic
condition|)
name|ix86_cmodel
operator|=
name|CM_MEDIUM
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ix86_cmodel_string
argument_list|,
literal|"large"
argument_list|)
operator|&&
operator|!
name|flag_pic
condition|)
name|ix86_cmodel
operator|=
name|CM_LARGE
expr_stmt|;
else|else
name|error
argument_list|(
literal|"bad value (%s) for -mcmodel= switch"
argument_list|,
name|ix86_cmodel_string
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ix86_cmodel
operator|=
name|CM_32
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
name|ix86_cmodel
operator|=
name|flag_pic
condition|?
name|CM_SMALL_PIC
else|:
name|CM_SMALL
expr_stmt|;
block|}
if|if
condition|(
name|ix86_asm_string
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ix86_asm_string
argument_list|,
literal|"intel"
argument_list|)
condition|)
name|ix86_asm_dialect
operator|=
name|ASM_INTEL
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ix86_asm_string
argument_list|,
literal|"att"
argument_list|)
condition|)
name|ix86_asm_dialect
operator|=
name|ASM_ATT
expr_stmt|;
else|else
name|error
argument_list|(
literal|"bad value (%s) for -masm= switch"
argument_list|,
name|ix86_asm_string
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|TARGET_64BIT
operator|==
literal|0
operator|)
operator|!=
operator|(
name|ix86_cmodel
operator|==
name|CM_32
operator|)
condition|)
name|error
argument_list|(
literal|"code model `%s' not supported in the %s bit mode"
argument_list|,
name|ix86_cmodel_string
argument_list|,
name|TARGET_64BIT
condition|?
literal|"64"
else|:
literal|"32"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ix86_cmodel
operator|==
name|CM_LARGE
condition|)
name|sorry
argument_list|(
literal|"code model `large' not supported yet"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TARGET_64BIT
operator|!=
literal|0
operator|)
operator|!=
operator|(
operator|(
name|target_flags
operator|&
name|MASK_64BIT
operator|)
operator|!=
literal|0
operator|)
condition|)
name|sorry
argument_list|(
literal|"%i-bit mode not compiled in"
argument_list|,
operator|(
name|target_flags
operator|&
name|MASK_64BIT
operator|)
condition|?
literal|64
else|:
literal|32
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pta_size
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ix86_arch_string
argument_list|,
name|processor_alias_table
index|[
name|i
index|]
operator|.
name|name
argument_list|)
condition|)
block|{
name|ix86_arch
operator|=
name|processor_alias_table
index|[
name|i
index|]
operator|.
name|processor
expr_stmt|;
comment|/* Default cpu tuning to the architecture.  */
name|ix86_tune
operator|=
name|ix86_arch
expr_stmt|;
if|if
condition|(
name|processor_alias_table
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|PTA_MMX
operator|&&
operator|!
operator|(
name|target_flags_explicit
operator|&
name|MASK_MMX
operator|)
condition|)
name|target_flags
operator||=
name|MASK_MMX
expr_stmt|;
if|if
condition|(
name|processor_alias_table
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|PTA_3DNOW
operator|&&
operator|!
operator|(
name|target_flags_explicit
operator|&
name|MASK_3DNOW
operator|)
condition|)
name|target_flags
operator||=
name|MASK_3DNOW
expr_stmt|;
if|if
condition|(
name|processor_alias_table
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|PTA_3DNOW_A
operator|&&
operator|!
operator|(
name|target_flags_explicit
operator|&
name|MASK_3DNOW_A
operator|)
condition|)
name|target_flags
operator||=
name|MASK_3DNOW_A
expr_stmt|;
if|if
condition|(
name|processor_alias_table
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|PTA_SSE
operator|&&
operator|!
operator|(
name|target_flags_explicit
operator|&
name|MASK_SSE
operator|)
condition|)
name|target_flags
operator||=
name|MASK_SSE
expr_stmt|;
if|if
condition|(
name|processor_alias_table
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|PTA_SSE2
operator|&&
operator|!
operator|(
name|target_flags_explicit
operator|&
name|MASK_SSE2
operator|)
condition|)
name|target_flags
operator||=
name|MASK_SSE2
expr_stmt|;
if|if
condition|(
name|processor_alias_table
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|PTA_SSE3
operator|&&
operator|!
operator|(
name|target_flags_explicit
operator|&
name|MASK_SSE3
operator|)
condition|)
name|target_flags
operator||=
name|MASK_SSE3
expr_stmt|;
if|if
condition|(
name|processor_alias_table
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|PTA_PREFETCH_SSE
condition|)
name|x86_prefetch_sse
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
operator|&&
operator|!
operator|(
name|processor_alias_table
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|PTA_64BIT
operator|)
condition|)
name|error
argument_list|(
literal|"CPU you selected does not support x86-64 instruction set"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|pta_size
condition|)
name|error
argument_list|(
literal|"bad value (%s) for -march= switch"
argument_list|,
name|ix86_arch_string
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pta_size
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ix86_tune_string
argument_list|,
name|processor_alias_table
index|[
name|i
index|]
operator|.
name|name
argument_list|)
condition|)
block|{
name|ix86_tune
operator|=
name|processor_alias_table
index|[
name|i
index|]
operator|.
name|processor
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
operator|&&
operator|!
operator|(
name|processor_alias_table
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|PTA_64BIT
operator|)
condition|)
name|error
argument_list|(
literal|"CPU you selected does not support x86-64 instruction set"
argument_list|)
expr_stmt|;
comment|/* Intel CPUs have always interpreted SSE prefetch instructions as 	   NOPs; so, we can enable SSE prefetch instructions even when 	   -mtune (rather than -march) points us to a processor that has them. 	   However, the VIA C3 gives a SIGILL, so we only do that for i686 and 	   higher processors.  */
if|if
condition|(
name|TARGET_CMOVE
operator|&&
operator|(
name|processor_alias_table
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|PTA_PREFETCH_SSE
operator|)
condition|)
name|x86_prefetch_sse
operator|=
name|true
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|pta_size
condition|)
name|error
argument_list|(
literal|"bad value (%s) for -mtune= switch"
argument_list|,
name|ix86_tune_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|optimize_size
condition|)
name|ix86_cost
operator|=
operator|&
name|size_cost
expr_stmt|;
else|else
name|ix86_cost
operator|=
name|processor_target_table
index|[
name|ix86_tune
index|]
operator|.
name|cost
expr_stmt|;
name|target_flags
operator||=
name|processor_target_table
index|[
name|ix86_tune
index|]
operator|.
name|target_enable
expr_stmt|;
name|target_flags
operator|&=
operator|~
name|processor_target_table
index|[
name|ix86_tune
index|]
operator|.
name|target_disable
expr_stmt|;
comment|/* Arrange to set up i386_stack_locals for all functions.  */
name|init_machine_status
operator|=
name|ix86_init_machine_status
expr_stmt|;
comment|/* Validate -mregparm= value.  */
if|if
condition|(
name|ix86_regparm_string
condition|)
block|{
name|i
operator|=
name|atoi
argument_list|(
name|ix86_regparm_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|>
name|REGPARM_MAX
condition|)
name|error
argument_list|(
literal|"-mregparm=%d is not between 0 and %d"
argument_list|,
name|i
argument_list|,
name|REGPARM_MAX
argument_list|)
expr_stmt|;
else|else
name|ix86_regparm
operator|=
name|i
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TARGET_64BIT
condition|)
name|ix86_regparm
operator|=
name|REGPARM_MAX
expr_stmt|;
comment|/* If the user has provided any of the -malign-* options,      warn and use that value only if -falign-* is not set.      Remove this code in GCC 3.2 or later.  */
if|if
condition|(
name|ix86_align_loops_string
condition|)
block|{
name|warning
argument_list|(
literal|"-malign-loops is obsolete, use -falign-loops"
argument_list|)
expr_stmt|;
if|if
condition|(
name|align_loops
operator|==
literal|0
condition|)
block|{
name|i
operator|=
name|atoi
argument_list|(
name|ix86_align_loops_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|>
name|MAX_CODE_ALIGN
condition|)
name|error
argument_list|(
literal|"-malign-loops=%d is not between 0 and %d"
argument_list|,
name|i
argument_list|,
name|MAX_CODE_ALIGN
argument_list|)
expr_stmt|;
else|else
name|align_loops
operator|=
literal|1
operator|<<
name|i
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ix86_align_jumps_string
condition|)
block|{
name|warning
argument_list|(
literal|"-malign-jumps is obsolete, use -falign-jumps"
argument_list|)
expr_stmt|;
if|if
condition|(
name|align_jumps
operator|==
literal|0
condition|)
block|{
name|i
operator|=
name|atoi
argument_list|(
name|ix86_align_jumps_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|>
name|MAX_CODE_ALIGN
condition|)
name|error
argument_list|(
literal|"-malign-loops=%d is not between 0 and %d"
argument_list|,
name|i
argument_list|,
name|MAX_CODE_ALIGN
argument_list|)
expr_stmt|;
else|else
name|align_jumps
operator|=
literal|1
operator|<<
name|i
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ix86_align_funcs_string
condition|)
block|{
name|warning
argument_list|(
literal|"-malign-functions is obsolete, use -falign-functions"
argument_list|)
expr_stmt|;
if|if
condition|(
name|align_functions
operator|==
literal|0
condition|)
block|{
name|i
operator|=
name|atoi
argument_list|(
name|ix86_align_funcs_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|>
name|MAX_CODE_ALIGN
condition|)
name|error
argument_list|(
literal|"-malign-loops=%d is not between 0 and %d"
argument_list|,
name|i
argument_list|,
name|MAX_CODE_ALIGN
argument_list|)
expr_stmt|;
else|else
name|align_functions
operator|=
literal|1
operator|<<
name|i
expr_stmt|;
block|}
block|}
comment|/* Default align_* from the processor table.  */
if|if
condition|(
name|align_loops
operator|==
literal|0
condition|)
block|{
name|align_loops
operator|=
name|processor_target_table
index|[
name|ix86_tune
index|]
operator|.
name|align_loop
expr_stmt|;
name|align_loops_max_skip
operator|=
name|processor_target_table
index|[
name|ix86_tune
index|]
operator|.
name|align_loop_max_skip
expr_stmt|;
block|}
if|if
condition|(
name|align_jumps
operator|==
literal|0
condition|)
block|{
name|align_jumps
operator|=
name|processor_target_table
index|[
name|ix86_tune
index|]
operator|.
name|align_jump
expr_stmt|;
name|align_jumps_max_skip
operator|=
name|processor_target_table
index|[
name|ix86_tune
index|]
operator|.
name|align_jump_max_skip
expr_stmt|;
block|}
if|if
condition|(
name|align_functions
operator|==
literal|0
condition|)
block|{
name|align_functions
operator|=
name|processor_target_table
index|[
name|ix86_tune
index|]
operator|.
name|align_func
expr_stmt|;
block|}
comment|/* Validate -mpreferred-stack-boundary= value, or provide default.      The default of 128 bits is for Pentium III's SSE __m128, but we      don't want additional code to keep the stack aligned when      optimizing for code size.  */
name|ix86_preferred_stack_boundary
operator|=
operator|(
name|optimize_size
condition|?
name|TARGET_64BIT
condition|?
literal|128
else|:
literal|32
else|:
literal|128
operator|)
expr_stmt|;
if|if
condition|(
name|ix86_preferred_stack_boundary_string
condition|)
block|{
name|i
operator|=
name|atoi
argument_list|(
name|ix86_preferred_stack_boundary_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
operator|(
name|TARGET_64BIT
condition|?
literal|4
else|:
literal|2
operator|)
operator|||
name|i
operator|>
literal|12
condition|)
name|error
argument_list|(
literal|"-mpreferred-stack-boundary=%d is not between %d and 12"
argument_list|,
name|i
argument_list|,
name|TARGET_64BIT
condition|?
literal|4
else|:
literal|2
argument_list|)
expr_stmt|;
else|else
name|ix86_preferred_stack_boundary
operator|=
operator|(
literal|1
operator|<<
name|i
operator|)
operator|*
name|BITS_PER_UNIT
expr_stmt|;
block|}
comment|/* Validate -mbranch-cost= value, or provide default.  */
name|ix86_branch_cost
operator|=
name|processor_target_table
index|[
name|ix86_tune
index|]
operator|.
name|cost
operator|->
name|branch_cost
expr_stmt|;
if|if
condition|(
name|ix86_branch_cost_string
condition|)
block|{
name|i
operator|=
name|atoi
argument_list|(
name|ix86_branch_cost_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|>
literal|5
condition|)
name|error
argument_list|(
literal|"-mbranch-cost=%d is not between 0 and 5"
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
name|ix86_branch_cost
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|ix86_tls_dialect_string
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|ix86_tls_dialect_string
argument_list|,
literal|"gnu"
argument_list|)
operator|==
literal|0
condition|)
name|ix86_tls_dialect
operator|=
name|TLS_DIALECT_GNU
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|ix86_tls_dialect_string
argument_list|,
literal|"sun"
argument_list|)
operator|==
literal|0
condition|)
name|ix86_tls_dialect
operator|=
name|TLS_DIALECT_SUN
expr_stmt|;
else|else
name|error
argument_list|(
literal|"bad value (%s) for -mtls-dialect= switch"
argument_list|,
name|ix86_tls_dialect_string
argument_list|)
expr_stmt|;
block|}
comment|/* Keep nonleaf frame pointers.  */
if|if
condition|(
name|TARGET_OMIT_LEAF_FRAME_POINTER
condition|)
name|flag_omit_frame_pointer
operator|=
literal|1
expr_stmt|;
comment|/* If we're doing fast math, we don't care about comparison order      wrt NaNs.  This lets us use a shorter comparison sequence.  */
if|if
condition|(
name|flag_unsafe_math_optimizations
condition|)
name|target_flags
operator|&=
operator|~
name|MASK_IEEE_FP
expr_stmt|;
comment|/* If the architecture always has an FPU, turn off NO_FANCY_MATH_387,      since the insns won't need emulation.  */
if|if
condition|(
name|x86_arch_always_fancy_math_387
operator|&
operator|(
literal|1
operator|<<
name|ix86_arch
operator|)
condition|)
name|target_flags
operator|&=
operator|~
name|MASK_NO_FANCY_MATH_387
expr_stmt|;
comment|/* Turn on SSE2 builtins for -msse3.  */
if|if
condition|(
name|TARGET_SSE3
condition|)
name|target_flags
operator||=
name|MASK_SSE2
expr_stmt|;
comment|/* Turn on SSE builtins for -msse2.  */
if|if
condition|(
name|TARGET_SSE2
condition|)
name|target_flags
operator||=
name|MASK_SSE
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
if|if
condition|(
name|TARGET_ALIGN_DOUBLE
condition|)
name|error
argument_list|(
literal|"-malign-double makes no sense in the 64bit mode"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_RTD
condition|)
name|error
argument_list|(
literal|"-mrtd calling convention not supported in the 64bit mode"
argument_list|)
expr_stmt|;
comment|/* Enable by default the SSE and MMX builtins.  */
name|target_flags
operator||=
operator|(
name|MASK_SSE2
operator||
name|MASK_SSE
operator||
name|MASK_MMX
operator||
name|MASK_128BIT_LONG_DOUBLE
operator|)
expr_stmt|;
name|ix86_fpmath
operator|=
name|FPMATH_SSE
expr_stmt|;
block|}
else|else
block|{
name|ix86_fpmath
operator|=
name|FPMATH_387
expr_stmt|;
comment|/* i386 ABI does not specify red zone.  It still makes sense to use it          when programmer takes care to stack from being destroyed.  */
if|if
condition|(
operator|!
operator|(
name|target_flags_explicit
operator|&
name|MASK_NO_RED_ZONE
operator|)
condition|)
name|target_flags
operator||=
name|MASK_NO_RED_ZONE
expr_stmt|;
block|}
if|if
condition|(
name|ix86_fpmath_string
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ix86_fpmath_string
argument_list|,
literal|"387"
argument_list|)
condition|)
name|ix86_fpmath
operator|=
name|FPMATH_387
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ix86_fpmath_string
argument_list|,
literal|"sse"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|TARGET_SSE
condition|)
block|{
name|warning
argument_list|(
literal|"SSE instruction set disabled, using 387 arithmetics"
argument_list|)
expr_stmt|;
name|ix86_fpmath
operator|=
name|FPMATH_387
expr_stmt|;
block|}
else|else
name|ix86_fpmath
operator|=
name|FPMATH_SSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ix86_fpmath_string
argument_list|,
literal|"387,sse"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|ix86_fpmath_string
argument_list|,
literal|"sse,387"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|TARGET_SSE
condition|)
block|{
name|warning
argument_list|(
literal|"SSE instruction set disabled, using 387 arithmetics"
argument_list|)
expr_stmt|;
name|ix86_fpmath
operator|=
name|FPMATH_387
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|TARGET_80387
condition|)
block|{
name|warning
argument_list|(
literal|"387 instruction set disabled, using SSE arithmetics"
argument_list|)
expr_stmt|;
name|ix86_fpmath
operator|=
name|FPMATH_SSE
expr_stmt|;
block|}
else|else
name|ix86_fpmath
operator|=
name|FPMATH_SSE
operator||
name|FPMATH_387
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"bad value (%s) for -mfpmath= switch"
argument_list|,
name|ix86_fpmath_string
argument_list|)
expr_stmt|;
block|}
comment|/* It makes no sense to ask for just SSE builtins, so MMX is also turned      on by -msse.  */
if|if
condition|(
name|TARGET_SSE
condition|)
block|{
name|target_flags
operator||=
name|MASK_MMX
expr_stmt|;
name|x86_prefetch_sse
operator|=
name|true
expr_stmt|;
block|}
comment|/* If it has 3DNow! it also has MMX so MMX is also turned on by -m3dnow */
if|if
condition|(
name|TARGET_3DNOW
condition|)
block|{
name|target_flags
operator||=
name|MASK_MMX
expr_stmt|;
comment|/* If we are targeting the Athlon architecture, enable the 3Dnow/MMX 	 extensions it adds.  */
if|if
condition|(
name|x86_3dnow_a
operator|&
operator|(
literal|1
operator|<<
name|ix86_arch
operator|)
condition|)
name|target_flags
operator||=
name|MASK_3DNOW_A
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|x86_accumulate_outgoing_args
operator|&
name|TUNEMASK
operator|)
operator|&&
operator|!
operator|(
name|target_flags_explicit
operator|&
name|MASK_ACCUMULATE_OUTGOING_ARGS
operator|)
operator|&&
operator|!
name|optimize_size
condition|)
name|target_flags
operator||=
name|MASK_ACCUMULATE_OUTGOING_ARGS
expr_stmt|;
comment|/* Figure out what ASM_GENERATE_INTERNAL_LABEL builds as a prefix.  */
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|internal_label_prefix
argument_list|,
literal|"LX"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|internal_label_prefix
argument_list|,
literal|'X'
argument_list|)
expr_stmt|;
name|internal_label_prefix_len
operator|=
name|p
operator|-
name|internal_label_prefix
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|optimization_options
parameter_list|(
name|int
name|level
parameter_list|,
name|int
name|size
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* For -O2 and beyond, turn off -fschedule-insns by default.  It tends to      make the problem with not enough registers even worse.  */
ifdef|#
directive|ifdef
name|INSN_SCHEDULING
if|if
condition|(
name|level
operator|>
literal|1
condition|)
name|flag_schedule_insns
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* The default values of these switches depend on the TARGET_64BIT      that is not known at this moment.  Mark these values with 2 and      let user the to override these.  In case there is no command line option      specifying them, we will set the defaults in override_options.  */
if|if
condition|(
name|optimize
operator|>=
literal|1
condition|)
name|flag_omit_frame_pointer
operator|=
literal|2
expr_stmt|;
name|flag_pcc_struct_return
operator|=
literal|2
expr_stmt|;
name|flag_asynchronous_unwind_tables
operator|=
literal|2
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Table of valid machine attributes.  */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|attribute_spec
name|ix86_attribute_table
index|[]
init|=
block|{
comment|/* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */
comment|/* Stdcall attribute says callee is responsible for popping arguments      if they are not variable.  */
block|{
literal|"stdcall"
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|true
block|,
name|true
block|,
name|ix86_handle_cdecl_attribute
block|}
block|,
comment|/* Fastcall attribute says callee is responsible for popping arguments      if they are not variable.  */
block|{
literal|"fastcall"
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|true
block|,
name|true
block|,
name|ix86_handle_cdecl_attribute
block|}
block|,
comment|/* Cdecl attribute says the callee is a normal C declaration */
block|{
literal|"cdecl"
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|true
block|,
name|true
block|,
name|ix86_handle_cdecl_attribute
block|}
block|,
comment|/* Regparm attribute specifies how many integer arguments are to be      passed in registers.  */
block|{
literal|"regparm"
block|,
literal|1
block|,
literal|1
block|,
name|false
block|,
name|true
block|,
name|true
block|,
name|ix86_handle_regparm_attribute
block|}
block|,
ifdef|#
directive|ifdef
name|TARGET_DLLIMPORT_DECL_ATTRIBUTES
block|{
literal|"dllimport"
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|ix86_handle_dll_attribute
block|}
block|,
block|{
literal|"dllexport"
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|ix86_handle_dll_attribute
block|}
block|,
block|{
literal|"shared"
block|,
literal|0
block|,
literal|0
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|ix86_handle_shared_attribute
block|}
block|,
endif|#
directive|endif
block|{
literal|"ms_struct"
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|ix86_handle_struct_attribute
block|}
block|,
block|{
literal|"gcc_struct"
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|ix86_handle_struct_attribute
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Decide whether we can make a sibling call to a function.  DECL is the    declaration of the function being targeted by the call and EXP is the    CALL_EXPR representing the call.  */
end_comment

begin_function
specifier|static
name|bool
name|ix86_function_ok_for_sibcall
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|exp
parameter_list|)
block|{
comment|/* If we are generating position-independent code, we cannot sibcall      optimize any indirect call, or a direct call to a global function,      as the PLT requires %ebx be live.  */
if|if
condition|(
operator|!
name|TARGET_64BIT
operator|&&
name|flag_pic
operator|&&
operator|(
operator|!
name|decl
operator|||
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
comment|/* If we are returning floats on the 80387 register stack, we cannot      make a sibcall from a function that doesn't return a float to a      function that does or, conversely, from a function that does return      a float to a function that doesn't; the necessary stack adjustment      would not be executed.  */
if|if
condition|(
name|STACK_REG_P
argument_list|(
name|ix86_function_value
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|STACK_REG_P
argument_list|(
name|ix86_function_value
argument_list|(
name|TREE_TYPE
argument_list|(
name|DECL_RESULT
argument_list|(
name|cfun
operator|->
name|decl
argument_list|)
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* If this call is indirect, we'll need to be able to use a call-clobbered      register for the address of the target function.  Make sure that all      such registers are not used for passing parameters.  */
if|if
condition|(
operator|!
name|decl
operator|&&
operator|!
name|TARGET_64BIT
condition|)
block|{
name|tree
name|type
decl_stmt|;
comment|/* We're looking at the CALL_EXPR, we need the type of the function.  */
name|type
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* pointer expression */
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* pointer type */
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* function type */
if|if
condition|(
name|ix86_function_regparm
argument_list|(
name|type
argument_list|,
name|NULL
argument_list|)
operator|>=
literal|3
condition|)
block|{
comment|/* ??? Need to count the actual number of registers to be used, 	     not the possible number of registers.  Fix later.  */
return|return
name|false
return|;
block|}
block|}
comment|/* Otherwise okay.  That also includes certain types of indirect calls.  */
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Handle a "cdecl", "stdcall", or "fastcall" attribute;    arguments as in struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|ix86_handle_cdecl_attribute
parameter_list|(
name|tree
modifier|*
name|node
parameter_list|,
name|tree
name|name
parameter_list|,
name|tree
name|args
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|flags
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bool
modifier|*
name|no_add_attrs
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|!=
name|FUNCTION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|!=
name|METHOD_TYPE
operator|&&
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|!=
name|FIELD_DECL
operator|&&
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
block|{
name|warning
argument_list|(
literal|"`%s' attribute only applies to functions"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|is_attribute_p
argument_list|(
literal|"fastcall"
argument_list|,
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"stdcall"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
operator|*
name|node
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"fastcall and stdcall attributes are not compatible"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"regparm"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
operator|*
name|node
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"fastcall and regparm attributes are not compatible"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|is_attribute_p
argument_list|(
literal|"stdcall"
argument_list|,
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"fastcall"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
operator|*
name|node
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"fastcall and stdcall attributes are not compatible"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
name|warning
argument_list|(
literal|"`%s' attribute ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle a "regparm" attribute;    arguments as in struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|ix86_handle_regparm_attribute
parameter_list|(
name|tree
modifier|*
name|node
parameter_list|,
name|tree
name|name
parameter_list|,
name|tree
name|args
parameter_list|,
name|int
name|flags
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bool
modifier|*
name|no_add_attrs
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|!=
name|FUNCTION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|!=
name|METHOD_TYPE
operator|&&
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|!=
name|FIELD_DECL
operator|&&
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
block|{
name|warning
argument_list|(
literal|"`%s' attribute only applies to functions"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
name|tree
name|cst
decl_stmt|;
name|cst
operator|=
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cst
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
name|warning
argument_list|(
literal|"`%s' attribute requires an integer constant argument"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|compare_tree_int
argument_list|(
name|cst
argument_list|,
name|REGPARM_MAX
argument_list|)
operator|>
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"argument to `%s' attribute larger than %d"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|,
name|REGPARM_MAX
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"fastcall"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
operator|*
name|node
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"fastcall and regparm attributes are not compatible"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Return 0 if the attributes for two types are incompatible, 1 if they    are compatible, and 2 if they are nearly compatible (which causes a    warning to be generated).  */
end_comment

begin_function
specifier|static
name|int
name|ix86_comp_type_attributes
parameter_list|(
name|tree
name|type1
parameter_list|,
name|tree
name|type2
parameter_list|)
block|{
comment|/* Check for mismatch of non-default calling convention.  */
specifier|const
name|char
modifier|*
specifier|const
name|rtdstr
init|=
name|TARGET_RTD
condition|?
literal|"cdecl"
else|:
literal|"stdcall"
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type1
argument_list|)
operator|!=
name|FUNCTION_TYPE
condition|)
return|return
literal|1
return|;
comment|/*  Check for mismatched fastcall types */
if|if
condition|(
operator|!
name|lookup_attribute
argument_list|(
literal|"fastcall"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|type1
argument_list|)
argument_list|)
operator|!=
operator|!
name|lookup_attribute
argument_list|(
literal|"fastcall"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|type2
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Check for mismatched return types (cdecl vs stdcall).  */
if|if
condition|(
operator|!
name|lookup_attribute
argument_list|(
name|rtdstr
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|type1
argument_list|)
argument_list|)
operator|!=
operator|!
name|lookup_attribute
argument_list|(
name|rtdstr
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|type2
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|ix86_function_regparm
argument_list|(
name|type1
argument_list|,
name|NULL
argument_list|)
operator|!=
name|ix86_function_regparm
argument_list|(
name|type2
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the regparm value for a fuctio with the indicated TYPE and DECL.    DECL may be NULL when calling function indirectly    or considering a libcall.  */
end_comment

begin_function
specifier|static
name|int
name|ix86_function_regparm
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|decl
parameter_list|)
block|{
name|tree
name|attr
decl_stmt|;
name|int
name|regparm
init|=
name|ix86_regparm
decl_stmt|;
name|bool
name|user_convention
init|=
name|false
decl_stmt|;
if|if
condition|(
operator|!
name|TARGET_64BIT
condition|)
block|{
name|attr
operator|=
name|lookup_attribute
argument_list|(
literal|"regparm"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
condition|)
block|{
name|regparm
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_VALUE
argument_list|(
name|attr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|user_convention
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"fastcall"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
name|regparm
operator|=
literal|2
expr_stmt|;
name|user_convention
operator|=
name|true
expr_stmt|;
block|}
comment|/* Use register calling convention for local functions when possible.  */
if|if
condition|(
operator|!
name|TARGET_64BIT
operator|&&
operator|!
name|user_convention
operator|&&
name|decl
operator|&&
name|flag_unit_at_a_time
operator|&&
operator|!
name|profile_flag
condition|)
block|{
name|struct
name|cgraph_local_info
modifier|*
name|i
init|=
name|cgraph_local_info
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|&&
name|i
operator|->
name|local
condition|)
block|{
comment|/* We can't use regparm(3) for nested functions as these use 		 static chain pointer in third argument.  */
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_NO_STATIC_CHAIN
argument_list|(
name|decl
argument_list|)
condition|)
name|regparm
operator|=
literal|2
expr_stmt|;
else|else
name|regparm
operator|=
literal|3
expr_stmt|;
block|}
block|}
block|}
return|return
name|regparm
return|;
block|}
end_function

begin_comment
comment|/* Return true if EAX is live at the start of the function.  Used by     ix86_expand_prologue to determine if we need special help before    calling allocate_stack_worker.  */
end_comment

begin_function
specifier|static
name|bool
name|ix86_eax_live_at_start_p
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Cheat.  Don't bother working forward from ix86_function_regparm      to the function type to whether an actual argument is located in      eax.  Instead just look at cfg info, which is still close enough      to correct at this point.  This gives false positives for broken      functions that might use uninitialized data that happens to be      allocated in eax, but who cares?  */
return|return
name|REGNO_REG_SET_P
argument_list|(
name|ENTRY_BLOCK_PTR
operator|->
name|global_live_at_end
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Value is the number of bytes of arguments automatically    popped when returning from a subroutine call.    FUNDECL is the declaration node of the function (as a tree),    FUNTYPE is the data type of the function (as a tree),    or for a library call it is an identifier node for the subroutine name.    SIZE is the number of bytes of arguments passed on the stack.     On the 80386, the RTD insn may be used to pop them if the number      of args is fixed, but if the number is variable then the caller      must pop them all.  RTD can't be used for library calls now      because the library is compiled with the Unix compiler.    Use of RTD is a selectable option, since it is incompatible with    standard Unix calling sequences.  If the option is not selected,    the caller must always pop the args.     The attribute stdcall is equivalent to RTD on a per module basis.  */
end_comment

begin_function
name|int
name|ix86_return_pops_args
parameter_list|(
name|tree
name|fundecl
parameter_list|,
name|tree
name|funtype
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|int
name|rtd
init|=
name|TARGET_RTD
operator|&&
operator|(
operator|!
name|fundecl
operator|||
name|TREE_CODE
argument_list|(
name|fundecl
argument_list|)
operator|!=
name|IDENTIFIER_NODE
operator|)
decl_stmt|;
comment|/* Cdecl functions override -mrtd, and never pop the stack.  */
if|if
condition|(
operator|!
name|lookup_attribute
argument_list|(
literal|"cdecl"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|funtype
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Stdcall and fastcall functions will pop the stack if not        variable args.  */
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"stdcall"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|funtype
argument_list|)
argument_list|)
operator|||
name|lookup_attribute
argument_list|(
literal|"fastcall"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|funtype
argument_list|)
argument_list|)
condition|)
name|rtd
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|rtd
operator|&&
operator|(
name|TYPE_ARG_TYPES
argument_list|(
name|funtype
argument_list|)
operator|==
name|NULL_TREE
operator|||
operator|(
name|TREE_VALUE
argument_list|(
name|tree_last
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|funtype
argument_list|)
argument_list|)
argument_list|)
operator|==
name|void_type_node
operator|)
operator|)
condition|)
return|return
name|size
return|;
block|}
comment|/* Lose any fake structure return argument if it is passed on the stack.  */
if|if
condition|(
name|aggregate_value_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|funtype
argument_list|)
argument_list|,
name|fundecl
argument_list|)
operator|&&
operator|!
name|TARGET_64BIT
condition|)
block|{
name|int
name|nregs
init|=
name|ix86_function_regparm
argument_list|(
name|funtype
argument_list|,
name|fundecl
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|nregs
condition|)
return|return
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Argument support functions.  */
end_comment

begin_comment
comment|/* Return true when register may be used to pass function parameters.  */
end_comment

begin_function
name|bool
name|ix86_function_arg_regno_p
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|TARGET_64BIT
condition|)
return|return
operator|(
name|regno
operator|<
name|REGPARM_MAX
operator|||
operator|(
name|TARGET_SSE
operator|&&
name|SSE_REGNO_P
argument_list|(
name|regno
argument_list|)
operator|&&
operator|!
name|fixed_regs
index|[
name|regno
index|]
operator|)
operator|)
return|;
if|if
condition|(
name|SSE_REGNO_P
argument_list|(
name|regno
argument_list|)
operator|&&
name|TARGET_SSE
condition|)
return|return
name|true
return|;
comment|/* RAX is used as hidden argument to va_arg functions.  */
if|if
condition|(
operator|!
name|regno
condition|)
return|return
name|true
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGPARM_MAX
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regno
operator|==
name|x86_64_int_parameter_registers
index|[
name|i
index|]
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Initialize a variable CUM of type CUMULATIVE_ARGS    for a call to a function whose data type is FNTYPE.    For a library call, FNTYPE is 0.  */
end_comment

begin_function
name|void
name|init_cumulative_args
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
name|cum
parameter_list|,
comment|/* Argument info to initialize */
name|tree
name|fntype
parameter_list|,
comment|/* tree ptr for function decl */
name|rtx
name|libname
parameter_list|,
comment|/* SYMBOL_REF of library name or 0 */
name|tree
name|fndecl
parameter_list|)
block|{
specifier|static
name|CUMULATIVE_ARGS
name|zero_cum
decl_stmt|;
name|tree
name|param
decl_stmt|,
name|next_param
decl_stmt|;
if|if
condition|(
name|TARGET_DEBUG_ARG
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ninit_cumulative_args ("
argument_list|)
expr_stmt|;
if|if
condition|(
name|fntype
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"fntype code = %s, ret code = %s"
argument_list|,
name|tree_code_name
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|fntype
argument_list|)
index|]
argument_list|,
name|tree_code_name
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|)
index|]
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"no fntype"
argument_list|)
expr_stmt|;
if|if
condition|(
name|libname
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|", libname = %s"
argument_list|,
name|XSTR
argument_list|(
name|libname
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|cum
operator|=
name|zero_cum
expr_stmt|;
comment|/* Set up the number of registers to use for passing arguments.  */
if|if
condition|(
name|fntype
condition|)
name|cum
operator|->
name|nregs
operator|=
name|ix86_function_regparm
argument_list|(
name|fntype
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
else|else
name|cum
operator|->
name|nregs
operator|=
name|ix86_regparm
expr_stmt|;
name|cum
operator|->
name|sse_nregs
operator|=
name|SSE_REGPARM_MAX
expr_stmt|;
name|cum
operator|->
name|mmx_nregs
operator|=
name|MMX_REGPARM_MAX
expr_stmt|;
name|cum
operator|->
name|warn_sse
operator|=
name|true
expr_stmt|;
name|cum
operator|->
name|warn_mmx
operator|=
name|true
expr_stmt|;
name|cum
operator|->
name|maybe_vaarg
operator|=
name|false
expr_stmt|;
comment|/* Use ecx and edx registers if function has fastcall attribute */
if|if
condition|(
name|fntype
operator|&&
operator|!
name|TARGET_64BIT
condition|)
block|{
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"fastcall"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|fntype
argument_list|)
argument_list|)
condition|)
block|{
name|cum
operator|->
name|nregs
operator|=
literal|2
expr_stmt|;
name|cum
operator|->
name|fastcall
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Determine if this function has variable arguments.  This is      indicated by the last argument being 'void_type_mode' if there      are no variable arguments.  If there are variable arguments, then      we won't pass anything in registers */
if|if
condition|(
name|cum
operator|->
name|nregs
operator|||
operator|!
name|TARGET_MMX
operator|||
operator|!
name|TARGET_SSE
condition|)
block|{
for|for
control|(
name|param
operator|=
operator|(
name|fntype
operator|)
condition|?
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
else|:
literal|0
init|;
name|param
operator|!=
literal|0
condition|;
name|param
operator|=
name|next_param
control|)
block|{
name|next_param
operator|=
name|TREE_CHAIN
argument_list|(
name|param
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_param
operator|==
literal|0
operator|&&
name|TREE_VALUE
argument_list|(
name|param
argument_list|)
operator|!=
name|void_type_node
condition|)
block|{
if|if
condition|(
operator|!
name|TARGET_64BIT
condition|)
block|{
name|cum
operator|->
name|nregs
operator|=
literal|0
expr_stmt|;
name|cum
operator|->
name|sse_nregs
operator|=
literal|0
expr_stmt|;
name|cum
operator|->
name|mmx_nregs
operator|=
literal|0
expr_stmt|;
name|cum
operator|->
name|warn_sse
operator|=
literal|0
expr_stmt|;
name|cum
operator|->
name|warn_mmx
operator|=
literal|0
expr_stmt|;
name|cum
operator|->
name|fastcall
operator|=
literal|0
expr_stmt|;
block|}
name|cum
operator|->
name|maybe_vaarg
operator|=
name|true
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
operator|!
name|fntype
operator|&&
operator|!
name|libname
operator|)
operator|||
operator|(
name|fntype
operator|&&
operator|!
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
operator|)
condition|)
name|cum
operator|->
name|maybe_vaarg
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TARGET_DEBUG_ARG
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|", nregs=%d )\n"
argument_list|,
name|cum
operator|->
name|nregs
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* x86-64 register passing implementation.  See x86-64 ABI for details.  Goal    of this code is to classify each 8bytes of incoming argument by the register    class and assign registers accordingly.  */
end_comment

begin_comment
comment|/* Return the union class of CLASS1 and CLASS2.    See the x86-64 PS ABI for details.  */
end_comment

begin_function
specifier|static
name|enum
name|x86_64_reg_class
name|merge_classes
parameter_list|(
name|enum
name|x86_64_reg_class
name|class1
parameter_list|,
name|enum
name|x86_64_reg_class
name|class2
parameter_list|)
block|{
comment|/* Rule #1: If both classes are equal, this is the resulting class.  */
if|if
condition|(
name|class1
operator|==
name|class2
condition|)
return|return
name|class1
return|;
comment|/* Rule #2: If one of the classes is NO_CLASS, the resulting class is      the other class.  */
if|if
condition|(
name|class1
operator|==
name|X86_64_NO_CLASS
condition|)
return|return
name|class2
return|;
if|if
condition|(
name|class2
operator|==
name|X86_64_NO_CLASS
condition|)
return|return
name|class1
return|;
comment|/* Rule #3: If one of the classes is MEMORY, the result is MEMORY.  */
if|if
condition|(
name|class1
operator|==
name|X86_64_MEMORY_CLASS
operator|||
name|class2
operator|==
name|X86_64_MEMORY_CLASS
condition|)
return|return
name|X86_64_MEMORY_CLASS
return|;
comment|/* Rule #4: If one of the classes is INTEGER, the result is INTEGER.  */
if|if
condition|(
operator|(
name|class1
operator|==
name|X86_64_INTEGERSI_CLASS
operator|&&
name|class2
operator|==
name|X86_64_SSESF_CLASS
operator|)
operator|||
operator|(
name|class2
operator|==
name|X86_64_INTEGERSI_CLASS
operator|&&
name|class1
operator|==
name|X86_64_SSESF_CLASS
operator|)
condition|)
return|return
name|X86_64_INTEGERSI_CLASS
return|;
if|if
condition|(
name|class1
operator|==
name|X86_64_INTEGER_CLASS
operator|||
name|class1
operator|==
name|X86_64_INTEGERSI_CLASS
operator|||
name|class2
operator|==
name|X86_64_INTEGER_CLASS
operator|||
name|class2
operator|==
name|X86_64_INTEGERSI_CLASS
condition|)
return|return
name|X86_64_INTEGER_CLASS
return|;
comment|/* Rule #5: If one of the classes is X87 or X87UP class, MEMORY is used.  */
if|if
condition|(
name|class1
operator|==
name|X86_64_X87_CLASS
operator|||
name|class1
operator|==
name|X86_64_X87UP_CLASS
operator|||
name|class2
operator|==
name|X86_64_X87_CLASS
operator|||
name|class2
operator|==
name|X86_64_X87UP_CLASS
condition|)
return|return
name|X86_64_MEMORY_CLASS
return|;
comment|/* Rule #6: Otherwise class SSE is used.  */
return|return
name|X86_64_SSE_CLASS
return|;
block|}
end_function

begin_comment
comment|/* Classify the argument of type TYPE and mode MODE.    CLASSES will be filled by the register class used to pass each word    of the operand.  The number of words is returned.  In case the parameter    should be passed in memory, 0 is returned. As a special case for zero    sized containers, classes[0] will be NO_CLASS and 1 is returned.     BIT_OFFSET is used internally for handling records and specifies offset    of the offset in bits modulo 256 to avoid overflow cases.     See the x86-64 PS ABI for details. */
end_comment

begin_function
specifier|static
name|int
name|classify_argument
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|type
parameter_list|,
name|enum
name|x86_64_reg_class
name|classes
index|[
name|MAX_CLASSES
index|]
parameter_list|,
name|int
name|bit_offset
parameter_list|)
block|{
name|HOST_WIDE_INT
name|bytes
init|=
operator|(
name|mode
operator|==
name|BLKmode
operator|)
condition|?
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
else|:
operator|(
name|int
operator|)
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|int
name|words
init|=
operator|(
name|bytes
operator|+
operator|(
name|bit_offset
operator|%
literal|64
operator|)
operator|/
literal|8
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
decl_stmt|;
comment|/* Variable sized entities are always passed/returned in memory.  */
if|if
condition|(
name|bytes
operator|<
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|MUST_PASS_IN_STACK
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|type
operator|&&
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
name|tree
name|field
decl_stmt|;
name|enum
name|x86_64_reg_class
name|subclasses
index|[
name|MAX_CLASSES
index|]
decl_stmt|;
comment|/* On x86-64 we pass structures larger than 16 bytes on the stack.  */
if|if
condition|(
name|bytes
operator|>
literal|16
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
name|i
operator|++
control|)
name|classes
index|[
name|i
index|]
operator|=
name|X86_64_NO_CLASS
expr_stmt|;
comment|/* Zero sized arrays or structures are NO_CLASS.  We return 0 to 	 signalize memory class, so handle it as special case.  */
if|if
condition|(
operator|!
name|words
condition|)
block|{
name|classes
index|[
literal|0
index|]
operator|=
name|X86_64_NO_CLASS
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Classify each field of record and merge classes.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
block|{
comment|/* For classes first merge in the field of the subclasses.  */
if|if
condition|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL
operator|&&
name|TYPE_BINFO_BASETYPES
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|tree
name|bases
init|=
name|TYPE_BINFO_BASETYPES
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|n_bases
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|bases
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_bases
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|bases
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|int
name|num
decl_stmt|;
name|int
name|offset
init|=
name|tree_low_cst
argument_list|(
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|*
literal|8
decl_stmt|;
name|tree
name|type
init|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|num
operator|=
name|classify_argument
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|type
argument_list|,
name|subclasses
argument_list|,
operator|(
name|offset
operator|+
name|bit_offset
operator|)
operator|%
literal|256
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|num
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|int
name|pos
init|=
operator|(
name|offset
operator|+
operator|(
name|bit_offset
operator|%
literal|64
operator|)
operator|)
operator|/
literal|8
operator|/
literal|8
decl_stmt|;
name|classes
index|[
name|i
operator|+
name|pos
index|]
operator|=
name|merge_classes
argument_list|(
name|subclasses
index|[
name|i
index|]
argument_list|,
name|classes
index|[
name|i
operator|+
name|pos
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* And now merge the fields of structure.  */
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
name|int
name|num
decl_stmt|;
comment|/* Bitfields are always classified as integer.  Handle them 		     early, since later code would consider them to be 		     misaligned integers.  */
if|if
condition|(
name|DECL_BIT_FIELD
argument_list|(
name|field
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
name|int_bit_position
argument_list|(
name|field
argument_list|)
operator|/
literal|8
operator|/
literal|8
init|;
name|i
operator|<
operator|(
name|int_bit_position
argument_list|(
name|field
argument_list|)
operator|+
name|tree_low_cst
argument_list|(
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|+
literal|63
operator|)
operator|/
literal|8
operator|/
literal|8
condition|;
name|i
operator|++
control|)
name|classes
index|[
name|i
index|]
operator|=
name|merge_classes
argument_list|(
name|X86_64_INTEGER_CLASS
argument_list|,
name|classes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|num
operator|=
name|classify_argument
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
name|subclasses
argument_list|,
operator|(
name|int_bit_position
argument_list|(
name|field
argument_list|)
operator|+
name|bit_offset
operator|)
operator|%
literal|256
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|num
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|int
name|pos
init|=
operator|(
name|int_bit_position
argument_list|(
name|field
argument_list|)
operator|+
operator|(
name|bit_offset
operator|%
literal|64
operator|)
operator|)
operator|/
literal|8
operator|/
literal|8
decl_stmt|;
name|classes
index|[
name|i
operator|+
name|pos
index|]
operator|=
name|merge_classes
argument_list|(
name|subclasses
index|[
name|i
index|]
argument_list|,
name|classes
index|[
name|i
operator|+
name|pos
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/* Arrays are handled as small records.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|int
name|num
decl_stmt|;
name|num
operator|=
name|classify_argument
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|subclasses
argument_list|,
name|bit_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|num
condition|)
return|return
literal|0
return|;
comment|/* The partial classes are now full classes.  */
if|if
condition|(
name|subclasses
index|[
literal|0
index|]
operator|==
name|X86_64_SSESF_CLASS
operator|&&
name|bytes
operator|!=
literal|4
condition|)
name|subclasses
index|[
literal|0
index|]
operator|=
name|X86_64_SSE_CLASS
expr_stmt|;
if|if
condition|(
name|subclasses
index|[
literal|0
index|]
operator|==
name|X86_64_INTEGERSI_CLASS
operator|&&
name|bytes
operator|!=
literal|4
condition|)
name|subclasses
index|[
literal|0
index|]
operator|=
name|X86_64_INTEGER_CLASS
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
name|i
operator|++
control|)
name|classes
index|[
name|i
index|]
operator|=
name|subclasses
index|[
name|i
operator|%
name|num
index|]
expr_stmt|;
block|}
comment|/* Unions are similar to RECORD_TYPE but offset is always 0.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|QUAL_UNION_TYPE
condition|)
block|{
comment|/* For classes first merge in the field of the subclasses.  */
if|if
condition|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL
operator|&&
name|TYPE_BINFO_BASETYPES
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|tree
name|bases
init|=
name|TYPE_BINFO_BASETYPES
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|n_bases
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|bases
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_bases
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|bases
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|int
name|num
decl_stmt|;
name|int
name|offset
init|=
name|tree_low_cst
argument_list|(
name|BINFO_OFFSET
argument_list|(
name|binfo
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|*
literal|8
decl_stmt|;
name|tree
name|type
init|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
name|num
operator|=
name|classify_argument
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|type
argument_list|,
name|subclasses
argument_list|,
operator|(
name|offset
operator|+
operator|(
name|bit_offset
operator|%
literal|64
operator|)
operator|)
operator|%
literal|256
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|num
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|int
name|pos
init|=
operator|(
name|offset
operator|+
operator|(
name|bit_offset
operator|%
literal|64
operator|)
operator|)
operator|/
literal|8
operator|/
literal|8
decl_stmt|;
name|classes
index|[
name|i
operator|+
name|pos
index|]
operator|=
name|merge_classes
argument_list|(
name|subclasses
index|[
name|i
index|]
argument_list|,
name|classes
index|[
name|i
operator|+
name|pos
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
name|int
name|num
decl_stmt|;
name|num
operator|=
name|classify_argument
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
name|subclasses
argument_list|,
name|bit_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|num
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
name|classes
index|[
name|i
index|]
operator|=
name|merge_classes
argument_list|(
name|subclasses
index|[
name|i
index|]
argument_list|,
name|classes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|SET_TYPE
condition|)
block|{
if|if
condition|(
name|bytes
operator|<=
literal|4
condition|)
block|{
name|classes
index|[
literal|0
index|]
operator|=
name|X86_64_INTEGERSI_CLASS
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|bytes
operator|<=
literal|8
condition|)
block|{
name|classes
index|[
literal|0
index|]
operator|=
name|X86_64_INTEGER_CLASS
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|bytes
operator|<=
literal|12
condition|)
block|{
name|classes
index|[
literal|0
index|]
operator|=
name|X86_64_INTEGER_CLASS
expr_stmt|;
name|classes
index|[
literal|1
index|]
operator|=
name|X86_64_INTEGERSI_CLASS
expr_stmt|;
return|return
literal|2
return|;
block|}
else|else
block|{
name|classes
index|[
literal|0
index|]
operator|=
name|X86_64_INTEGER_CLASS
expr_stmt|;
name|classes
index|[
literal|1
index|]
operator|=
name|X86_64_INTEGER_CLASS
expr_stmt|;
return|return
literal|2
return|;
block|}
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* Final merger cleanup.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
name|i
operator|++
control|)
block|{
comment|/* If one class is MEMORY, everything should be passed in 	     memory.  */
if|if
condition|(
name|classes
index|[
name|i
index|]
operator|==
name|X86_64_MEMORY_CLASS
condition|)
return|return
literal|0
return|;
comment|/* The X86_64_SSEUP_CLASS should be always preceded by 	     X86_64_SSE_CLASS.  */
if|if
condition|(
name|classes
index|[
name|i
index|]
operator|==
name|X86_64_SSEUP_CLASS
operator|&&
operator|(
name|i
operator|==
literal|0
operator|||
name|classes
index|[
name|i
operator|-
literal|1
index|]
operator|!=
name|X86_64_SSE_CLASS
operator|)
condition|)
name|classes
index|[
name|i
index|]
operator|=
name|X86_64_SSE_CLASS
expr_stmt|;
comment|/*  X86_64_X87UP_CLASS should be preceded by X86_64_X87_CLASS.  */
if|if
condition|(
name|classes
index|[
name|i
index|]
operator|==
name|X86_64_X87UP_CLASS
operator|&&
operator|(
name|i
operator|==
literal|0
operator|||
name|classes
index|[
name|i
operator|-
literal|1
index|]
operator|!=
name|X86_64_X87_CLASS
operator|)
condition|)
name|classes
index|[
name|i
index|]
operator|=
name|X86_64_SSE_CLASS
expr_stmt|;
block|}
return|return
name|words
return|;
block|}
comment|/* Compute alignment needed.  We align all types to natural boundaries with      exception of XFmode that is aligned to 64bits.  */
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|mode
operator|!=
name|BLKmode
condition|)
block|{
name|int
name|mode_alignment
init|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|XFmode
condition|)
name|mode_alignment
operator|=
literal|128
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|XCmode
condition|)
name|mode_alignment
operator|=
literal|256
expr_stmt|;
if|if
condition|(
name|COMPLEX_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
name|mode_alignment
operator|/=
literal|2
expr_stmt|;
comment|/* Misaligned fields are always returned in memory.  */
if|if
condition|(
name|bit_offset
operator|%
name|mode_alignment
condition|)
return|return
literal|0
return|;
block|}
comment|/* Classification of atomic types.  */
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|DImode
case|:
case|case
name|SImode
case|:
case|case
name|HImode
case|:
case|case
name|QImode
case|:
case|case
name|CSImode
case|:
case|case
name|CHImode
case|:
case|case
name|CQImode
case|:
if|if
condition|(
name|bit_offset
operator|+
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<=
literal|32
condition|)
name|classes
index|[
literal|0
index|]
operator|=
name|X86_64_INTEGERSI_CLASS
expr_stmt|;
else|else
name|classes
index|[
literal|0
index|]
operator|=
name|X86_64_INTEGER_CLASS
expr_stmt|;
return|return
literal|1
return|;
case|case
name|CDImode
case|:
case|case
name|TImode
case|:
name|classes
index|[
literal|0
index|]
operator|=
name|classes
index|[
literal|1
index|]
operator|=
name|X86_64_INTEGER_CLASS
expr_stmt|;
return|return
literal|2
return|;
case|case
name|CTImode
case|:
name|classes
index|[
literal|0
index|]
operator|=
name|classes
index|[
literal|1
index|]
operator|=
name|X86_64_INTEGER_CLASS
expr_stmt|;
name|classes
index|[
literal|2
index|]
operator|=
name|classes
index|[
literal|3
index|]
operator|=
name|X86_64_INTEGER_CLASS
expr_stmt|;
return|return
literal|4
return|;
case|case
name|SFmode
case|:
if|if
condition|(
operator|!
operator|(
name|bit_offset
operator|%
literal|64
operator|)
condition|)
name|classes
index|[
literal|0
index|]
operator|=
name|X86_64_SSESF_CLASS
expr_stmt|;
else|else
name|classes
index|[
literal|0
index|]
operator|=
name|X86_64_SSE_CLASS
expr_stmt|;
return|return
literal|1
return|;
case|case
name|DFmode
case|:
name|classes
index|[
literal|0
index|]
operator|=
name|X86_64_SSEDF_CLASS
expr_stmt|;
return|return
literal|1
return|;
case|case
name|XFmode
case|:
name|classes
index|[
literal|0
index|]
operator|=
name|X86_64_X87_CLASS
expr_stmt|;
name|classes
index|[
literal|1
index|]
operator|=
name|X86_64_X87UP_CLASS
expr_stmt|;
return|return
literal|2
return|;
case|case
name|TFmode
case|:
case|case
name|TCmode
case|:
return|return
literal|0
return|;
case|case
name|XCmode
case|:
name|classes
index|[
literal|0
index|]
operator|=
name|X86_64_X87_CLASS
expr_stmt|;
name|classes
index|[
literal|1
index|]
operator|=
name|X86_64_X87UP_CLASS
expr_stmt|;
name|classes
index|[
literal|2
index|]
operator|=
name|X86_64_X87_CLASS
expr_stmt|;
name|classes
index|[
literal|3
index|]
operator|=
name|X86_64_X87UP_CLASS
expr_stmt|;
return|return
literal|4
return|;
case|case
name|DCmode
case|:
name|classes
index|[
literal|0
index|]
operator|=
name|X86_64_SSEDF_CLASS
expr_stmt|;
name|classes
index|[
literal|1
index|]
operator|=
name|X86_64_SSEDF_CLASS
expr_stmt|;
return|return
literal|2
return|;
case|case
name|SCmode
case|:
name|classes
index|[
literal|0
index|]
operator|=
name|X86_64_SSE_CLASS
expr_stmt|;
return|return
literal|1
return|;
case|case
name|V4SFmode
case|:
case|case
name|V4SImode
case|:
case|case
name|V16QImode
case|:
case|case
name|V8HImode
case|:
case|case
name|V2DFmode
case|:
case|case
name|V2DImode
case|:
name|classes
index|[
literal|0
index|]
operator|=
name|X86_64_SSE_CLASS
expr_stmt|;
name|classes
index|[
literal|1
index|]
operator|=
name|X86_64_SSEUP_CLASS
expr_stmt|;
return|return
literal|2
return|;
case|case
name|V2SFmode
case|:
case|case
name|V2SImode
case|:
case|case
name|V4HImode
case|:
case|case
name|V8QImode
case|:
return|return
literal|0
return|;
case|case
name|BLKmode
case|:
case|case
name|VOIDmode
case|:
return|return
literal|0
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Examine the argument and return set number of register required in each    class.  Return 0 iff parameter should be passed in memory.  */
end_comment

begin_function
specifier|static
name|int
name|examine_argument
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|type
parameter_list|,
name|int
name|in_return
parameter_list|,
name|int
modifier|*
name|int_nregs
parameter_list|,
name|int
modifier|*
name|sse_nregs
parameter_list|)
block|{
name|enum
name|x86_64_reg_class
name|class
index|[
name|MAX_CLASSES
index|]
decl_stmt|;
name|int
name|n
init|=
name|classify_argument
argument_list|(
name|mode
argument_list|,
name|type
argument_list|,
name|class
argument_list|,
literal|0
argument_list|)
decl_stmt|;
operator|*
name|int_nregs
operator|=
literal|0
expr_stmt|;
operator|*
name|sse_nregs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
return|return
literal|0
return|;
for|for
control|(
name|n
operator|--
init|;
name|n
operator|>=
literal|0
condition|;
name|n
operator|--
control|)
switch|switch
condition|(
name|class
index|[
name|n
index|]
condition|)
block|{
case|case
name|X86_64_INTEGER_CLASS
case|:
case|case
name|X86_64_INTEGERSI_CLASS
case|:
operator|(
operator|*
name|int_nregs
operator|)
operator|++
expr_stmt|;
break|break;
case|case
name|X86_64_SSE_CLASS
case|:
case|case
name|X86_64_SSESF_CLASS
case|:
case|case
name|X86_64_SSEDF_CLASS
case|:
operator|(
operator|*
name|sse_nregs
operator|)
operator|++
expr_stmt|;
break|break;
case|case
name|X86_64_NO_CLASS
case|:
case|case
name|X86_64_SSEUP_CLASS
case|:
break|break;
case|case
name|X86_64_X87_CLASS
case|:
case|case
name|X86_64_X87UP_CLASS
case|:
if|if
condition|(
operator|!
name|in_return
condition|)
return|return
literal|0
return|;
break|break;
case|case
name|X86_64_MEMORY_CLASS
case|:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Construct container for the argument used by GCC interface.  See    FUNCTION_ARG for the detailed description.  */
end_comment

begin_function
specifier|static
name|rtx
name|construct_container
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|type
parameter_list|,
name|int
name|in_return
parameter_list|,
name|int
name|nintregs
parameter_list|,
name|int
name|nsseregs
parameter_list|,
specifier|const
name|int
modifier|*
name|intreg
parameter_list|,
name|int
name|sse_regno
parameter_list|)
block|{
name|enum
name|machine_mode
name|tmpmode
decl_stmt|;
name|int
name|bytes
init|=
operator|(
name|mode
operator|==
name|BLKmode
operator|)
condition|?
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
else|:
operator|(
name|int
operator|)
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|enum
name|x86_64_reg_class
name|class
index|[
name|MAX_CLASSES
index|]
decl_stmt|;
name|int
name|n
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|nexps
init|=
literal|0
decl_stmt|;
name|int
name|needed_sseregs
decl_stmt|,
name|needed_intregs
decl_stmt|;
name|rtx
name|exp
index|[
name|MAX_CLASSES
index|]
decl_stmt|;
name|rtx
name|ret
decl_stmt|;
name|n
operator|=
name|classify_argument
argument_list|(
name|mode
argument_list|,
name|type
argument_list|,
name|class
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_DEBUG_ARG
condition|)
block|{
if|if
condition|(
operator|!
name|n
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Memory class\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Classes:"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %s"
argument_list|,
name|x86_64_reg_class_name
index|[
name|class
index|[
name|i
index|]
index|]
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|n
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|examine_argument
argument_list|(
name|mode
argument_list|,
name|type
argument_list|,
name|in_return
argument_list|,
operator|&
name|needed_intregs
argument_list|,
operator|&
name|needed_sseregs
argument_list|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|needed_intregs
operator|>
name|nintregs
operator|||
name|needed_sseregs
operator|>
name|nsseregs
condition|)
return|return
name|NULL
return|;
comment|/* First construct simple cases.  Avoid SCmode, since we want to use      single register to pass this type.  */
if|if
condition|(
name|n
operator|==
literal|1
operator|&&
name|mode
operator|!=
name|SCmode
condition|)
switch|switch
condition|(
name|class
index|[
literal|0
index|]
condition|)
block|{
case|case
name|X86_64_INTEGER_CLASS
case|:
case|case
name|X86_64_INTEGERSI_CLASS
case|:
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|intreg
index|[
literal|0
index|]
argument_list|)
return|;
case|case
name|X86_64_SSE_CLASS
case|:
case|case
name|X86_64_SSESF_CLASS
case|:
case|case
name|X86_64_SSEDF_CLASS
case|:
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|SSE_REGNO
argument_list|(
name|sse_regno
argument_list|)
argument_list|)
return|;
case|case
name|X86_64_X87_CLASS
case|:
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|FIRST_STACK_REG
argument_list|)
return|;
case|case
name|X86_64_NO_CLASS
case|:
comment|/* Zero sized array, struct or class.  */
return|return
name|NULL
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|==
literal|2
operator|&&
name|class
index|[
literal|0
index|]
operator|==
name|X86_64_SSE_CLASS
operator|&&
name|class
index|[
literal|1
index|]
operator|==
name|X86_64_SSEUP_CLASS
operator|&&
name|mode
operator|!=
name|BLKmode
condition|)
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|SSE_REGNO
argument_list|(
name|sse_regno
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|n
operator|==
literal|2
operator|&&
name|class
index|[
literal|0
index|]
operator|==
name|X86_64_X87_CLASS
operator|&&
name|class
index|[
literal|1
index|]
operator|==
name|X86_64_X87UP_CLASS
condition|)
return|return
name|gen_rtx_REG
argument_list|(
name|XFmode
argument_list|,
name|FIRST_STACK_REG
argument_list|)
return|;
if|if
condition|(
name|n
operator|==
literal|2
operator|&&
name|class
index|[
literal|0
index|]
operator|==
name|X86_64_INTEGER_CLASS
operator|&&
name|class
index|[
literal|1
index|]
operator|==
name|X86_64_INTEGER_CLASS
operator|&&
operator|(
name|mode
operator|==
name|CDImode
operator|||
name|mode
operator|==
name|TImode
operator|||
name|mode
operator|==
name|TFmode
operator|)
operator|&&
name|intreg
index|[
literal|0
index|]
operator|+
literal|1
operator|==
name|intreg
index|[
literal|1
index|]
condition|)
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|intreg
index|[
literal|0
index|]
argument_list|)
return|;
if|if
condition|(
name|n
operator|==
literal|4
operator|&&
name|class
index|[
literal|0
index|]
operator|==
name|X86_64_X87_CLASS
operator|&&
name|class
index|[
literal|1
index|]
operator|==
name|X86_64_X87UP_CLASS
operator|&&
name|class
index|[
literal|2
index|]
operator|==
name|X86_64_X87_CLASS
operator|&&
name|class
index|[
literal|3
index|]
operator|==
name|X86_64_X87UP_CLASS
operator|&&
name|mode
operator|!=
name|BLKmode
condition|)
return|return
name|gen_rtx_REG
argument_list|(
name|XCmode
argument_list|,
name|FIRST_STACK_REG
argument_list|)
return|;
comment|/* Otherwise figure out the entries of the PARALLEL.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|class
index|[
name|i
index|]
condition|)
block|{
case|case
name|X86_64_NO_CLASS
case|:
break|break;
case|case
name|X86_64_INTEGER_CLASS
case|:
case|case
name|X86_64_INTEGERSI_CLASS
case|:
comment|/* Merge TImodes on aligned occasions here too.  */
if|if
condition|(
name|i
operator|*
literal|8
operator|+
literal|8
operator|>
name|bytes
condition|)
name|tmpmode
operator|=
name|mode_for_size
argument_list|(
operator|(
name|bytes
operator|-
name|i
operator|*
literal|8
operator|)
operator|*
name|BITS_PER_UNIT
argument_list|,
name|MODE_INT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|class
index|[
name|i
index|]
operator|==
name|X86_64_INTEGERSI_CLASS
condition|)
name|tmpmode
operator|=
name|SImode
expr_stmt|;
else|else
name|tmpmode
operator|=
name|DImode
expr_stmt|;
comment|/* We've requested 24 bytes we don't have mode for.  Use DImode.  */
if|if
condition|(
name|tmpmode
operator|==
name|BLKmode
condition|)
name|tmpmode
operator|=
name|DImode
expr_stmt|;
name|exp
index|[
name|nexps
operator|++
index|]
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|tmpmode
argument_list|,
operator|*
name|intreg
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|i
operator|*
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|intreg
operator|++
expr_stmt|;
break|break;
case|case
name|X86_64_SSESF_CLASS
case|:
name|exp
index|[
name|nexps
operator|++
index|]
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|SFmode
argument_list|,
name|SSE_REGNO
argument_list|(
name|sse_regno
argument_list|)
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|i
operator|*
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|sse_regno
operator|++
expr_stmt|;
break|break;
case|case
name|X86_64_SSEDF_CLASS
case|:
name|exp
index|[
name|nexps
operator|++
index|]
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|DFmode
argument_list|,
name|SSE_REGNO
argument_list|(
name|sse_regno
argument_list|)
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|i
operator|*
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|sse_regno
operator|++
expr_stmt|;
break|break;
case|case
name|X86_64_SSE_CLASS
case|:
if|if
condition|(
name|i
operator|<
name|n
operator|-
literal|1
operator|&&
name|class
index|[
name|i
operator|+
literal|1
index|]
operator|==
name|X86_64_SSEUP_CLASS
condition|)
name|tmpmode
operator|=
name|TImode
expr_stmt|;
else|else
name|tmpmode
operator|=
name|DImode
expr_stmt|;
name|exp
index|[
name|nexps
operator|++
index|]
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|tmpmode
argument_list|,
name|SSE_REGNO
argument_list|(
name|sse_regno
argument_list|)
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|i
operator|*
literal|8
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpmode
operator|==
name|TImode
condition|)
name|i
operator|++
expr_stmt|;
name|sse_regno
operator|++
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
name|ret
operator|=
name|gen_rtx_PARALLEL
argument_list|(
name|mode
argument_list|,
name|rtvec_alloc
argument_list|(
name|nexps
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nexps
condition|;
name|i
operator|++
control|)
name|XVECEXP
argument_list|(
name|ret
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
operator|=
name|exp
index|[
name|i
index|]
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Update the data in CUM to advance over an argument    of mode MODE and data type TYPE.    (TYPE is null for libcalls where that information may not be available.)  */
end_comment

begin_function
name|void
name|function_arg_advance
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
name|cum
parameter_list|,
comment|/* current arg information */
name|enum
name|machine_mode
name|mode
parameter_list|,
comment|/* current arg mode */
name|tree
name|type
parameter_list|,
comment|/* type of the argument or 0 if lib support */
name|int
name|named
parameter_list|)
comment|/* whether or not the argument was named */
block|{
name|int
name|bytes
init|=
operator|(
name|mode
operator|==
name|BLKmode
operator|)
condition|?
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
else|:
operator|(
name|int
operator|)
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|int
name|words
init|=
operator|(
name|bytes
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
decl_stmt|;
if|if
condition|(
name|TARGET_DEBUG_ARG
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"function_adv (sz=%d, wds=%2d, nregs=%d, ssenregs=%d, mode=%s, named=%d)\n\n"
argument_list|,
name|words
argument_list|,
name|cum
operator|->
name|words
argument_list|,
name|cum
operator|->
name|nregs
argument_list|,
name|cum
operator|->
name|sse_nregs
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|mode
argument_list|)
argument_list|,
name|named
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
name|int
name|int_nregs
decl_stmt|,
name|sse_nregs
decl_stmt|;
if|if
condition|(
operator|!
name|examine_argument
argument_list|(
name|mode
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
operator|&
name|int_nregs
argument_list|,
operator|&
name|sse_nregs
argument_list|)
condition|)
name|cum
operator|->
name|words
operator|+=
name|words
expr_stmt|;
elseif|else
if|if
condition|(
name|sse_nregs
operator|<=
name|cum
operator|->
name|sse_nregs
operator|&&
name|int_nregs
operator|<=
name|cum
operator|->
name|nregs
condition|)
block|{
name|cum
operator|->
name|nregs
operator|-=
name|int_nregs
expr_stmt|;
name|cum
operator|->
name|sse_nregs
operator|-=
name|sse_nregs
expr_stmt|;
name|cum
operator|->
name|regno
operator|+=
name|int_nregs
expr_stmt|;
name|cum
operator|->
name|sse_regno
operator|+=
name|sse_nregs
expr_stmt|;
block|}
else|else
name|cum
operator|->
name|words
operator|+=
name|words
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|TARGET_SSE
operator|&&
name|SSE_REG_MODE_P
argument_list|(
name|mode
argument_list|)
operator|&&
operator|(
operator|!
name|type
operator|||
operator|!
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
operator|)
condition|)
block|{
name|cum
operator|->
name|sse_words
operator|+=
name|words
expr_stmt|;
name|cum
operator|->
name|sse_nregs
operator|-=
literal|1
expr_stmt|;
name|cum
operator|->
name|sse_regno
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|cum
operator|->
name|sse_nregs
operator|<=
literal|0
condition|)
block|{
name|cum
operator|->
name|sse_nregs
operator|=
literal|0
expr_stmt|;
name|cum
operator|->
name|sse_regno
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TARGET_MMX
operator|&&
name|MMX_REG_MODE_P
argument_list|(
name|mode
argument_list|)
operator|&&
operator|(
operator|!
name|type
operator|||
operator|!
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
operator|)
condition|)
block|{
name|cum
operator|->
name|mmx_words
operator|+=
name|words
expr_stmt|;
name|cum
operator|->
name|mmx_nregs
operator|-=
literal|1
expr_stmt|;
name|cum
operator|->
name|mmx_regno
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|cum
operator|->
name|mmx_nregs
operator|<=
literal|0
condition|)
block|{
name|cum
operator|->
name|mmx_nregs
operator|=
literal|0
expr_stmt|;
name|cum
operator|->
name|mmx_regno
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|cum
operator|->
name|words
operator|+=
name|words
expr_stmt|;
name|cum
operator|->
name|nregs
operator|-=
name|words
expr_stmt|;
name|cum
operator|->
name|regno
operator|+=
name|words
expr_stmt|;
if|if
condition|(
name|cum
operator|->
name|nregs
operator|<=
literal|0
condition|)
block|{
name|cum
operator|->
name|nregs
operator|=
literal|0
expr_stmt|;
name|cum
operator|->
name|regno
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|/* Define where to put the arguments to a function.    Value is zero to push the argument on the stack,    or a hard register in which to store the argument.     MODE is the argument's machine mode.    TYPE is the data type of the argument (as a tree).     This is null for libcalls where that information may     not be available.    CUM is a variable of type CUMULATIVE_ARGS which gives info about     the preceding args and about the function being called.    NAMED is nonzero if this argument is a named parameter     (otherwise it is an extra parameter matching an ellipsis).  */
end_comment

begin_function
name|rtx
name|function_arg
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
name|cum
parameter_list|,
comment|/* current arg information */
name|enum
name|machine_mode
name|mode
parameter_list|,
comment|/* current arg mode */
name|tree
name|type
parameter_list|,
comment|/* type of the argument or 0 if lib support */
name|int
name|named
parameter_list|)
comment|/* != 0 for normal args, == 0 for ...  args */
block|{
name|rtx
name|ret
init|=
name|NULL_RTX
decl_stmt|;
name|int
name|bytes
init|=
operator|(
name|mode
operator|==
name|BLKmode
operator|)
condition|?
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
else|:
operator|(
name|int
operator|)
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|int
name|words
init|=
operator|(
name|bytes
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
decl_stmt|;
specifier|static
name|bool
name|warnedsse
decl_stmt|,
name|warnedmmx
decl_stmt|;
comment|/* Handle a hidden AL argument containing number of registers for varargs      x86-64 functions.  For i386 ABI just return constm1_rtx to avoid      any AL settings.  */
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
block|{
if|if
condition|(
name|TARGET_64BIT
condition|)
return|return
name|GEN_INT
argument_list|(
name|cum
operator|->
name|maybe_vaarg
condition|?
operator|(
name|cum
operator|->
name|sse_nregs
operator|<
literal|0
condition|?
name|SSE_REGPARM_MAX
else|:
name|cum
operator|->
name|sse_regno
operator|)
else|:
operator|-
literal|1
argument_list|)
return|;
else|else
return|return
name|constm1_rtx
return|;
block|}
if|if
condition|(
name|TARGET_64BIT
condition|)
name|ret
operator|=
name|construct_container
argument_list|(
name|mode
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
name|cum
operator|->
name|nregs
argument_list|,
name|cum
operator|->
name|sse_nregs
argument_list|,
operator|&
name|x86_64_int_parameter_registers
index|[
name|cum
operator|->
name|regno
index|]
argument_list|,
name|cum
operator|->
name|sse_regno
argument_list|)
expr_stmt|;
else|else
switch|switch
condition|(
name|mode
condition|)
block|{
comment|/* For now, pass fp/complex values on the stack.  */
default|default:
break|break;
case|case
name|BLKmode
case|:
if|if
condition|(
name|bytes
operator|<
literal|0
condition|)
break|break;
comment|/* FALLTHRU */
case|case
name|DImode
case|:
case|case
name|SImode
case|:
case|case
name|HImode
case|:
case|case
name|QImode
case|:
if|if
condition|(
name|words
operator|<=
name|cum
operator|->
name|nregs
condition|)
block|{
name|int
name|regno
init|=
name|cum
operator|->
name|regno
decl_stmt|;
comment|/* Fastcall allocates the first two DWORD (SImode) or 	       smaller arguments to ECX and EDX.  */
if|if
condition|(
name|cum
operator|->
name|fastcall
condition|)
block|{
if|if
condition|(
name|mode
operator|==
name|BLKmode
operator|||
name|mode
operator|==
name|DImode
condition|)
break|break;
comment|/* ECX not EAX is the first allocated register.  */
if|if
condition|(
name|regno
operator|==
literal|0
condition|)
name|regno
operator|=
literal|2
expr_stmt|;
block|}
name|ret
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TImode
case|:
case|case
name|V16QImode
case|:
case|case
name|V8HImode
case|:
case|case
name|V4SImode
case|:
case|case
name|V2DImode
case|:
case|case
name|V4SFmode
case|:
case|case
name|V2DFmode
case|:
if|if
condition|(
operator|!
name|type
operator|||
operator|!
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|TARGET_SSE
operator|&&
operator|!
name|warnedmmx
operator|&&
name|cum
operator|->
name|warn_sse
condition|)
block|{
name|warnedsse
operator|=
name|true
expr_stmt|;
name|warning
argument_list|(
literal|"SSE vector argument without SSE enabled "
literal|"changes the ABI"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cum
operator|->
name|sse_nregs
condition|)
name|ret
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|cum
operator|->
name|sse_regno
operator|+
name|FIRST_SSE_REG
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|V8QImode
case|:
case|case
name|V4HImode
case|:
case|case
name|V2SImode
case|:
case|case
name|V2SFmode
case|:
if|if
condition|(
operator|!
name|type
operator|||
operator|!
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|TARGET_MMX
operator|&&
operator|!
name|warnedmmx
operator|&&
name|cum
operator|->
name|warn_mmx
condition|)
block|{
name|warnedmmx
operator|=
name|true
expr_stmt|;
name|warning
argument_list|(
literal|"MMX vector argument without MMX enabled "
literal|"changes the ABI"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cum
operator|->
name|mmx_nregs
condition|)
name|ret
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|cum
operator|->
name|mmx_regno
operator|+
name|FIRST_MMX_REG
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|TARGET_DEBUG_ARG
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"function_arg (size=%d, wds=%2d, nregs=%d, mode=%4s, named=%d, "
argument_list|,
name|words
argument_list|,
name|cum
operator|->
name|words
argument_list|,
name|cum
operator|->
name|nregs
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|mode
argument_list|)
argument_list|,
name|named
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|print_simple_rtl
argument_list|(
name|stderr
argument_list|,
name|ret
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|", stack"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" )\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* A C expression that indicates when an argument must be passed by    reference.  If nonzero for an argument, a copy of that argument is    made in memory and a pointer to the argument is passed instead of    the argument itself.  The pointer is passed in whatever way is    appropriate for passing a pointer to that type.  */
end_comment

begin_function
name|int
name|function_arg_pass_by_reference
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
name|cum
name|ATTRIBUTE_UNUSED
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|,
name|tree
name|type
parameter_list|,
name|int
name|named
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
operator|!
name|TARGET_64BIT
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|type
operator|&&
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|TARGET_DEBUG_ARG
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"function_arg_pass_by_reference\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return true when TYPE should be 128bit aligned for 32bit argument passing    ABI  */
end_comment

begin_function
specifier|static
name|bool
name|contains_128bit_aligned_vector_p
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|SSE_REG_MODE_P
argument_list|(
name|mode
argument_list|)
operator|&&
operator|(
operator|!
name|TYPE_USER_ALIGN
argument_list|(
name|type
argument_list|)
operator|||
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|>
literal|128
operator|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|<
literal|128
condition|)
return|return
name|false
return|;
if|if
condition|(
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* Walk the aggregates recursively.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|QUAL_UNION_TYPE
condition|)
block|{
name|tree
name|field
decl_stmt|;
if|if
condition|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL
operator|&&
name|TYPE_BINFO_BASETYPES
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|tree
name|bases
init|=
name|TYPE_BINFO_BASETYPES
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|n_bases
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|bases
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_bases
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|binfo
init|=
name|TREE_VEC_ELT
argument_list|(
name|bases
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|type
init|=
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|contains_128bit_aligned_vector_p
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|true
return|;
block|}
block|}
comment|/* And now merge the fields of structure.  */
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
name|contains_128bit_aligned_vector_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
block|}
block|}
comment|/* Just for use if some languages passes arrays by value.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
if|if
condition|(
name|contains_128bit_aligned_vector_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Gives the alignment boundary, in bits, of an argument with the    specified mode and type.  */
end_comment

begin_function
name|int
name|ix86_function_arg_boundary
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|int
name|align
decl_stmt|;
if|if
condition|(
name|type
condition|)
name|align
operator|=
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
expr_stmt|;
else|else
name|align
operator|=
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|align
operator|<
name|PARM_BOUNDARY
condition|)
name|align
operator|=
name|PARM_BOUNDARY
expr_stmt|;
if|if
condition|(
operator|!
name|TARGET_64BIT
condition|)
block|{
comment|/* i386 ABI defines all arguments to be 4 byte aligned.  We have to 	 make an exception for SSE modes since these require 128bit 	 alignment.  	 The handling here differs from field_alignment.  ICC aligns MMX 	 arguments to 4 byte boundaries, while structure fields are aligned 	 to 8 byte boundaries.  */
if|if
condition|(
operator|!
name|type
condition|)
block|{
if|if
condition|(
operator|!
name|SSE_REG_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
name|align
operator|=
name|PARM_BOUNDARY
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|contains_128bit_aligned_vector_p
argument_list|(
name|type
argument_list|)
condition|)
name|align
operator|=
name|PARM_BOUNDARY
expr_stmt|;
block|}
block|}
if|if
condition|(
name|align
operator|>
literal|128
condition|)
name|align
operator|=
literal|128
expr_stmt|;
return|return
name|align
return|;
block|}
end_function

begin_comment
comment|/* Return true if N is a possible register number of function value.  */
end_comment

begin_function
name|bool
name|ix86_function_value_regno_p
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
if|if
condition|(
operator|!
name|TARGET_64BIT
condition|)
block|{
return|return
operator|(
operator|(
name|regno
operator|)
operator|==
literal|0
operator|||
operator|(
operator|(
name|regno
operator|)
operator|==
name|FIRST_FLOAT_REG
operator|&&
name|TARGET_FLOAT_RETURNS_IN_80387
operator|)
operator|||
operator|(
operator|(
name|regno
operator|)
operator|==
name|FIRST_SSE_REG
operator|&&
name|TARGET_SSE
operator|)
operator|)
return|;
block|}
return|return
operator|(
operator|(
name|regno
operator|)
operator|==
literal|0
operator|||
operator|(
name|regno
operator|)
operator|==
name|FIRST_FLOAT_REG
operator|||
operator|(
operator|(
name|regno
operator|)
operator|==
name|FIRST_SSE_REG
operator|&&
name|TARGET_SSE
operator|)
operator|||
operator|(
operator|(
name|regno
operator|)
operator|==
name|FIRST_FLOAT_REG
operator|&&
name|TARGET_FLOAT_RETURNS_IN_80387
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Define how to find the value returned by a function.    VALTYPE is the data type of the value (as a tree).    If the precise function being called is known, FUNC is its FUNCTION_DECL;    otherwise, FUNC is 0.  */
end_comment

begin_function
name|rtx
name|ix86_function_value
parameter_list|(
name|tree
name|valtype
parameter_list|)
block|{
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
name|rtx
name|ret
init|=
name|construct_container
argument_list|(
name|TYPE_MODE
argument_list|(
name|valtype
argument_list|)
argument_list|,
name|valtype
argument_list|,
literal|1
argument_list|,
name|REGPARM_MAX
argument_list|,
name|SSE_REGPARM_MAX
argument_list|,
name|x86_64_int_return_registers
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* For zero sized structures, construct_container return NULL, but we need          to keep rest of compiler happy by returning meaningful value.  */
if|if
condition|(
operator|!
name|ret
condition|)
name|ret
operator|=
name|gen_rtx_REG
argument_list|(
name|TYPE_MODE
argument_list|(
name|valtype
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
else|else
return|return
name|gen_rtx_REG
argument_list|(
name|TYPE_MODE
argument_list|(
name|valtype
argument_list|)
argument_list|,
name|ix86_value_regno
argument_list|(
name|TYPE_MODE
argument_list|(
name|valtype
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return false iff type is returned in memory.  */
end_comment

begin_function
name|int
name|ix86_return_in_memory
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|int
name|needed_intregs
decl_stmt|,
name|needed_sseregs
decl_stmt|,
name|size
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
return|return
operator|!
name|examine_argument
argument_list|(
name|mode
argument_list|,
name|type
argument_list|,
literal|1
argument_list|,
operator|&
name|needed_intregs
argument_list|,
operator|&
name|needed_sseregs
argument_list|)
return|;
if|if
condition|(
name|mode
operator|==
name|BLKmode
condition|)
return|return
literal|1
return|;
name|size
operator|=
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|MS_AGGREGATE_RETURN
operator|&&
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|size
operator|<=
literal|8
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|VECTOR_MODE_P
argument_list|(
name|mode
argument_list|)
operator|||
name|mode
operator|==
name|TImode
condition|)
block|{
comment|/* User-created vectors small enough to fit in EAX.  */
if|if
condition|(
name|size
operator|<
literal|8
condition|)
return|return
literal|0
return|;
comment|/* MMX/3dNow values are returned on the stack, since we've 	 got to EMMS/FEMMS before returning.  */
if|if
condition|(
name|size
operator|==
literal|8
condition|)
return|return
literal|1
return|;
comment|/* SSE values are returned in XMM0.  */
comment|/* ??? Except when it doesn't exist?  We have a choice of 	 either (1) being abi incompatible with a -march switch, 	 or (2) generating an error here.  Given no good solution, 	 I think the safest thing is one warning.  The user won't 	 be able to use -Werror, but....  */
if|if
condition|(
name|size
operator|==
literal|16
condition|)
block|{
specifier|static
name|bool
name|warned
decl_stmt|;
if|if
condition|(
name|TARGET_SSE
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|warned
condition|)
block|{
name|warned
operator|=
name|true
expr_stmt|;
name|warning
argument_list|(
literal|"SSE vector return without SSE enabled "
literal|"changes the ABI"
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
block|}
if|if
condition|(
name|mode
operator|==
name|XFmode
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|size
operator|>
literal|12
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Define how to find the value returned by a library function    assuming the value has mode MODE.  */
end_comment

begin_function
name|rtx
name|ix86_libcall_value
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|SFmode
case|:
case|case
name|SCmode
case|:
case|case
name|DFmode
case|:
case|case
name|DCmode
case|:
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|FIRST_SSE_REG
argument_list|)
return|;
case|case
name|XFmode
case|:
case|case
name|XCmode
case|:
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|FIRST_FLOAT_REG
argument_list|)
return|;
case|case
name|TFmode
case|:
case|case
name|TCmode
case|:
return|return
name|NULL
return|;
default|default:
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
literal|0
argument_list|)
return|;
block|}
block|}
else|else
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|ix86_value_regno
argument_list|(
name|mode
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given a mode, return the register to use for a return value.  */
end_comment

begin_function
specifier|static
name|int
name|ix86_value_regno
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
comment|/* Floating point return values in %st(0).  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|TARGET_FLOAT_RETURNS_IN_80387
condition|)
return|return
name|FIRST_FLOAT_REG
return|;
comment|/* 16-byte vector modes in %xmm0.  See ix86_return_in_memory for where      we prevent this case when sse is not available.  */
if|if
condition|(
name|mode
operator|==
name|TImode
operator|||
operator|(
name|VECTOR_MODE_P
argument_list|(
name|mode
argument_list|)
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|==
literal|16
operator|)
condition|)
return|return
name|FIRST_SSE_REG
return|;
comment|/* Everything else in %eax.  */
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create the va_list data type.  */
end_comment

begin_function
specifier|static
name|tree
name|ix86_build_builtin_va_list
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|f_gpr
decl_stmt|,
name|f_fpr
decl_stmt|,
name|f_ovf
decl_stmt|,
name|f_sav
decl_stmt|,
name|record
decl_stmt|,
name|type_decl
decl_stmt|;
comment|/* For i386 we use plain pointer to argument area.  */
if|if
condition|(
operator|!
name|TARGET_64BIT
condition|)
return|return
name|build_pointer_type
argument_list|(
name|char_type_node
argument_list|)
return|;
name|record
operator|=
call|(
modifier|*
name|lang_hooks
operator|.
name|types
operator|.
name|make_type
call|)
argument_list|(
name|RECORD_TYPE
argument_list|)
expr_stmt|;
name|type_decl
operator|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__va_list_tag"
argument_list|)
argument_list|,
name|record
argument_list|)
expr_stmt|;
name|f_gpr
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"gp_offset"
argument_list|)
argument_list|,
name|unsigned_type_node
argument_list|)
expr_stmt|;
name|f_fpr
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"fp_offset"
argument_list|)
argument_list|,
name|unsigned_type_node
argument_list|)
expr_stmt|;
name|f_ovf
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"overflow_arg_area"
argument_list|)
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
name|f_sav
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"reg_save_area"
argument_list|)
argument_list|,
name|ptr_type_node
argument_list|)
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|f_gpr
argument_list|)
operator|=
name|record
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|f_fpr
argument_list|)
operator|=
name|record
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|f_ovf
argument_list|)
operator|=
name|record
expr_stmt|;
name|DECL_FIELD_CONTEXT
argument_list|(
name|f_sav
argument_list|)
operator|=
name|record
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|record
argument_list|)
operator|=
name|type_decl
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|record
argument_list|)
operator|=
name|type_decl
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|record
argument_list|)
operator|=
name|f_gpr
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|f_gpr
argument_list|)
operator|=
name|f_fpr
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|f_fpr
argument_list|)
operator|=
name|f_ovf
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|f_ovf
argument_list|)
operator|=
name|f_sav
expr_stmt|;
name|layout_type
argument_list|(
name|record
argument_list|)
expr_stmt|;
comment|/* The correct type is an array type of one element.  */
return|return
name|build_array_type
argument_list|(
name|record
argument_list|,
name|build_index_type
argument_list|(
name|size_zero_node
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Perform any needed actions needed for a function that is receiving a    variable number of arguments.     CUM is as above.     MODE and TYPE are the mode and type of the current parameter.     PRETEND_SIZE is a variable that should be set to the amount of stack    that must be pushed by the prolog to pretend that our caller pushed    it.     Normally, this macro will push all remaining incoming registers on the    stack and set PRETEND_SIZE to the length of the registers pushed.  */
end_comment

begin_function
name|void
name|ix86_setup_incoming_varargs
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
name|cum
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|type
parameter_list|,
name|int
modifier|*
name|pretend_size
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|no_rtl
parameter_list|)
block|{
name|CUMULATIVE_ARGS
name|next_cum
decl_stmt|;
name|rtx
name|save_area
init|=
name|NULL_RTX
decl_stmt|,
name|mem
decl_stmt|;
name|rtx
name|label
decl_stmt|;
name|rtx
name|label_ref
decl_stmt|;
name|rtx
name|tmp_reg
decl_stmt|;
name|rtx
name|nsse_reg
decl_stmt|;
name|int
name|set
decl_stmt|;
name|tree
name|fntype
decl_stmt|;
name|int
name|stdarg_p
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|TARGET_64BIT
condition|)
return|return;
comment|/* Indicate to allocate space on the stack for varargs save area.  */
name|ix86_save_varrargs_registers
operator|=
literal|1
expr_stmt|;
name|cfun
operator|->
name|stack_alignment_needed
operator|=
literal|128
expr_stmt|;
name|fntype
operator|=
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
name|stdarg_p
operator|=
operator|(
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|TREE_VALUE
argument_list|(
name|tree_last
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|void_type_node
operator|)
operator|)
expr_stmt|;
comment|/* For varargs, we do not want to skip the dummy va_dcl argument.      For stdargs, we do want to skip the last named argument.  */
name|next_cum
operator|=
operator|*
name|cum
expr_stmt|;
if|if
condition|(
name|stdarg_p
condition|)
name|function_arg_advance
argument_list|(
operator|&
name|next_cum
argument_list|,
name|mode
argument_list|,
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|no_rtl
condition|)
name|save_area
operator|=
name|frame_pointer_rtx
expr_stmt|;
name|set
operator|=
name|get_varargs_alias_set
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
name|next_cum
operator|.
name|regno
init|;
name|i
operator|<
name|ix86_regparm
condition|;
name|i
operator|++
control|)
block|{
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|plus_constant
argument_list|(
name|save_area
argument_list|,
name|i
operator|*
name|UNITS_PER_WORD
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|set
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|x86_64_int_parameter_registers
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|next_cum
operator|.
name|sse_nregs
condition|)
block|{
comment|/* Now emit code to save SSE registers.  The AX parameter contains number 	 of SSE parameter registers used to call this function.  We use 	 sse_prologue_save insn template that produces computed jump across 	 SSE saves.  We need some preparation work to get this working.  */
name|label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|label_ref
operator|=
name|gen_rtx_LABEL_REF
argument_list|(
name|Pmode
argument_list|,
name|label
argument_list|)
expr_stmt|;
comment|/* Compute address to jump to :          label - 5*eax + nnamed_sse_arguments*5  */
name|tmp_reg
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|nsse_reg
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_zero_extendqidi2
argument_list|(
name|nsse_reg
argument_list|,
name|gen_rtx_REG
argument_list|(
name|QImode
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|tmp_reg
argument_list|,
name|gen_rtx_MULT
argument_list|(
name|Pmode
argument_list|,
name|nsse_reg
argument_list|,
name|GEN_INT
argument_list|(
literal|4
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_cum
operator|.
name|sse_regno
condition|)
name|emit_move_insn
argument_list|(
name|nsse_reg
argument_list|,
name|gen_rtx_CONST
argument_list|(
name|DImode
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|DImode
argument_list|,
name|label_ref
argument_list|,
name|GEN_INT
argument_list|(
name|next_cum
operator|.
name|sse_regno
operator|*
literal|4
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_move_insn
argument_list|(
name|nsse_reg
argument_list|,
name|label_ref
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_subdi3
argument_list|(
name|nsse_reg
argument_list|,
name|nsse_reg
argument_list|,
name|tmp_reg
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Compute address of memory block we save into.  We always use pointer 	 pointing 127 bytes after first byte to store - this is needed to keep 	 instruction size limited by 4 bytes.  */
name|tmp_reg
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|tmp_reg
argument_list|,
name|plus_constant
argument_list|(
name|save_area
argument_list|,
literal|8
operator|*
name|REGPARM_MAX
operator|+
literal|127
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|plus_constant
argument_list|(
name|tmp_reg
argument_list|,
operator|-
literal|127
argument_list|)
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|set
argument_list|)
expr_stmt|;
name|set_mem_align
argument_list|(
name|mem
argument_list|,
name|BITS_PER_WORD
argument_list|)
expr_stmt|;
comment|/* And finally do the dirty job!  */
name|emit_insn
argument_list|(
name|gen_sse_prologue_save
argument_list|(
name|mem
argument_list|,
name|nsse_reg
argument_list|,
name|GEN_INT
argument_list|(
name|next_cum
operator|.
name|sse_regno
argument_list|)
argument_list|,
name|label
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Implement va_start.  */
end_comment

begin_function
name|void
name|ix86_va_start
parameter_list|(
name|tree
name|valist
parameter_list|,
name|rtx
name|nextarg
parameter_list|)
block|{
name|HOST_WIDE_INT
name|words
decl_stmt|,
name|n_gpr
decl_stmt|,
name|n_fpr
decl_stmt|;
name|tree
name|f_gpr
decl_stmt|,
name|f_fpr
decl_stmt|,
name|f_ovf
decl_stmt|,
name|f_sav
decl_stmt|;
name|tree
name|gpr
decl_stmt|,
name|fpr
decl_stmt|,
name|ovf
decl_stmt|,
name|sav
decl_stmt|,
name|t
decl_stmt|;
comment|/* Only 64bit target needs something special.  */
if|if
condition|(
operator|!
name|TARGET_64BIT
condition|)
block|{
name|std_expand_builtin_va_start
argument_list|(
name|valist
argument_list|,
name|nextarg
argument_list|)
expr_stmt|;
return|return;
block|}
name|f_gpr
operator|=
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|va_list_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|f_fpr
operator|=
name|TREE_CHAIN
argument_list|(
name|f_gpr
argument_list|)
expr_stmt|;
name|f_ovf
operator|=
name|TREE_CHAIN
argument_list|(
name|f_fpr
argument_list|)
expr_stmt|;
name|f_sav
operator|=
name|TREE_CHAIN
argument_list|(
name|f_ovf
argument_list|)
expr_stmt|;
name|valist
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|valist
argument_list|)
argument_list|)
argument_list|,
name|valist
argument_list|)
expr_stmt|;
name|gpr
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_gpr
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_gpr
argument_list|)
expr_stmt|;
name|fpr
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_fpr
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_fpr
argument_list|)
expr_stmt|;
name|ovf
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_ovf
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_ovf
argument_list|)
expr_stmt|;
name|sav
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_sav
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_sav
argument_list|)
expr_stmt|;
comment|/* Count number of gp and fp argument registers used.  */
name|words
operator|=
name|current_function_args_info
operator|.
name|words
expr_stmt|;
name|n_gpr
operator|=
name|current_function_args_info
operator|.
name|regno
expr_stmt|;
name|n_fpr
operator|=
name|current_function_args_info
operator|.
name|sse_regno
expr_stmt|;
if|if
condition|(
name|TARGET_DEBUG_ARG
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"va_start: words = %d, n_gpr = %d, n_fpr = %d\n"
argument_list|,
operator|(
name|int
operator|)
name|words
argument_list|,
operator|(
name|int
operator|)
name|n_gpr
argument_list|,
operator|(
name|int
operator|)
name|n_fpr
argument_list|)
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|gpr
argument_list|)
argument_list|,
name|gpr
argument_list|,
name|build_int_2
argument_list|(
name|n_gpr
operator|*
literal|8
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|fpr
argument_list|)
argument_list|,
name|fpr
argument_list|,
name|build_int_2
argument_list|(
name|n_fpr
operator|*
literal|16
operator|+
literal|8
operator|*
name|REGPARM_MAX
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
comment|/* Find the overflow area.  */
name|t
operator|=
name|make_tree
argument_list|(
name|TREE_TYPE
argument_list|(
name|ovf
argument_list|)
argument_list|,
name|virtual_incoming_args_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|words
operator|!=
literal|0
condition|)
name|t
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|ovf
argument_list|)
argument_list|,
name|t
argument_list|,
name|build_int_2
argument_list|(
name|words
operator|*
name|UNITS_PER_WORD
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|ovf
argument_list|)
argument_list|,
name|ovf
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
comment|/* Find the register save area.      Prologue of the function save it right above stack frame.  */
name|t
operator|=
name|make_tree
argument_list|(
name|TREE_TYPE
argument_list|(
name|sav
argument_list|)
argument_list|,
name|frame_pointer_rtx
argument_list|)
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|sav
argument_list|)
argument_list|,
name|sav
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Implement va_arg.  */
end_comment

begin_function
name|rtx
name|ix86_va_arg
parameter_list|(
name|tree
name|valist
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
specifier|static
specifier|const
name|int
name|intreg
index|[
literal|6
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|}
decl_stmt|;
name|tree
name|f_gpr
decl_stmt|,
name|f_fpr
decl_stmt|,
name|f_ovf
decl_stmt|,
name|f_sav
decl_stmt|;
name|tree
name|gpr
decl_stmt|,
name|fpr
decl_stmt|,
name|ovf
decl_stmt|,
name|sav
decl_stmt|,
name|t
decl_stmt|;
name|int
name|size
decl_stmt|,
name|rsize
decl_stmt|;
name|rtx
name|lab_false
decl_stmt|,
name|lab_over
init|=
name|NULL_RTX
decl_stmt|;
name|rtx
name|addr_rtx
decl_stmt|,
name|r
decl_stmt|;
name|rtx
name|container
decl_stmt|;
name|int
name|indirect_p
init|=
literal|0
decl_stmt|;
comment|/* Only 64bit target needs something special.  */
if|if
condition|(
operator|!
name|TARGET_64BIT
condition|)
block|{
return|return
name|std_expand_builtin_va_arg
argument_list|(
name|valist
argument_list|,
name|type
argument_list|)
return|;
block|}
name|f_gpr
operator|=
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|va_list_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|f_fpr
operator|=
name|TREE_CHAIN
argument_list|(
name|f_gpr
argument_list|)
expr_stmt|;
name|f_ovf
operator|=
name|TREE_CHAIN
argument_list|(
name|f_fpr
argument_list|)
expr_stmt|;
name|f_sav
operator|=
name|TREE_CHAIN
argument_list|(
name|f_ovf
argument_list|)
expr_stmt|;
name|valist
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|valist
argument_list|)
argument_list|)
argument_list|,
name|valist
argument_list|)
expr_stmt|;
name|gpr
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_gpr
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_gpr
argument_list|)
expr_stmt|;
name|fpr
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_fpr
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_fpr
argument_list|)
expr_stmt|;
name|ovf
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_ovf
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_ovf
argument_list|)
expr_stmt|;
name|sav
operator|=
name|build
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|f_sav
argument_list|)
argument_list|,
name|valist
argument_list|,
name|f_sav
argument_list|)
expr_stmt|;
name|size
operator|=
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* Passed by reference.  */
name|indirect_p
operator|=
literal|1
expr_stmt|;
name|type
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|size
operator|=
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
name|rsize
operator|=
operator|(
name|size
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
expr_stmt|;
name|container
operator|=
name|construct_container
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
name|REGPARM_MAX
argument_list|,
name|SSE_REGPARM_MAX
argument_list|,
name|intreg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*    * Pull the value out of the saved registers ...    */
name|addr_rtx
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|container
condition|)
block|{
name|rtx
name|int_addr_rtx
decl_stmt|,
name|sse_addr_rtx
decl_stmt|;
name|int
name|needed_intregs
decl_stmt|,
name|needed_sseregs
decl_stmt|;
name|int
name|need_temp
decl_stmt|;
name|lab_over
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|lab_false
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|examine_argument
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
operator|&
name|needed_intregs
argument_list|,
operator|&
name|needed_sseregs
argument_list|)
expr_stmt|;
name|need_temp
operator|=
operator|(
operator|(
name|needed_intregs
operator|&&
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|>
literal|64
operator|)
operator|||
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|>
literal|128
operator|)
expr_stmt|;
comment|/* In case we are passing structure, verify that it is consecutive block          on the register save area.  If not we need to do moves.  */
if|if
condition|(
operator|!
name|need_temp
operator|&&
operator|!
name|REG_P
argument_list|(
name|container
argument_list|)
condition|)
block|{
comment|/* Verify that all registers are strictly consecutive  */
if|if
condition|(
name|SSE_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|container
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|container
argument_list|,
literal|0
argument_list|)
operator|&&
operator|!
name|need_temp
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|slot
init|=
name|XVECEXP
argument_list|(
name|container
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|slot
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|FIRST_SSE_REG
operator|+
operator|(
name|unsigned
name|int
operator|)
name|i
operator|||
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|slot
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|i
operator|*
literal|16
condition|)
name|need_temp
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|container
argument_list|,
literal|0
argument_list|)
operator|&&
operator|!
name|need_temp
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|slot
init|=
name|XVECEXP
argument_list|(
name|container
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|slot
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
operator|(
name|unsigned
name|int
operator|)
name|i
operator|||
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|slot
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|i
operator|*
literal|8
condition|)
name|need_temp
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|need_temp
condition|)
block|{
name|int_addr_rtx
operator|=
name|addr_rtx
expr_stmt|;
name|sse_addr_rtx
operator|=
name|addr_rtx
expr_stmt|;
block|}
else|else
block|{
name|int_addr_rtx
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|sse_addr_rtx
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
block|}
comment|/* First ensure that we fit completely in registers.  */
if|if
condition|(
name|needed_intregs
condition|)
block|{
name|emit_cmp_and_jump_insns
argument_list|(
name|expand_expr
argument_list|(
name|gpr
argument_list|,
name|NULL_RTX
argument_list|,
name|SImode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
operator|(
name|REGPARM_MAX
operator|-
name|needed_intregs
operator|+
literal|1
operator|)
operator|*
literal|8
argument_list|)
argument_list|,
name|GE
argument_list|,
name|const1_rtx
argument_list|,
name|SImode
argument_list|,
literal|1
argument_list|,
name|lab_false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|needed_sseregs
condition|)
block|{
name|emit_cmp_and_jump_insns
argument_list|(
name|expand_expr
argument_list|(
name|fpr
argument_list|,
name|NULL_RTX
argument_list|,
name|SImode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
operator|(
name|SSE_REGPARM_MAX
operator|-
name|needed_sseregs
operator|+
literal|1
operator|)
operator|*
literal|16
operator|+
name|REGPARM_MAX
operator|*
literal|8
argument_list|)
argument_list|,
name|GE
argument_list|,
name|const1_rtx
argument_list|,
name|SImode
argument_list|,
literal|1
argument_list|,
name|lab_false
argument_list|)
expr_stmt|;
block|}
comment|/* Compute index to start of area used for integer regs.  */
if|if
condition|(
name|needed_intregs
condition|)
block|{
name|t
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|ptr_type_node
argument_list|,
name|sav
argument_list|,
name|gpr
argument_list|)
expr_stmt|;
name|r
operator|=
name|expand_expr
argument_list|(
name|t
argument_list|,
name|int_addr_rtx
argument_list|,
name|Pmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|int_addr_rtx
condition|)
name|emit_move_insn
argument_list|(
name|int_addr_rtx
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|needed_sseregs
condition|)
block|{
name|t
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|ptr_type_node
argument_list|,
name|sav
argument_list|,
name|fpr
argument_list|)
expr_stmt|;
name|r
operator|=
name|expand_expr
argument_list|(
name|t
argument_list|,
name|sse_addr_rtx
argument_list|,
name|Pmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|sse_addr_rtx
condition|)
name|emit_move_insn
argument_list|(
name|sse_addr_rtx
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|need_temp
condition|)
block|{
name|int
name|i
decl_stmt|;
name|rtx
name|mem
decl_stmt|;
name|rtx
name|x
decl_stmt|;
comment|/* Never use the memory itself, as it has the alias set.  */
name|x
operator|=
name|XEXP
argument_list|(
name|assign_temp
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|force_operand
argument_list|(
name|x
argument_list|,
name|addr_rtx
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|get_varargs_alias_set
argument_list|()
argument_list|)
expr_stmt|;
name|set_mem_align
argument_list|(
name|mem
argument_list|,
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|container
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|slot
init|=
name|XVECEXP
argument_list|(
name|container
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|rtx
name|reg
init|=
name|XEXP
argument_list|(
name|slot
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|reg
argument_list|)
decl_stmt|;
name|rtx
name|src_addr
decl_stmt|;
name|rtx
name|src_mem
decl_stmt|;
name|int
name|src_offset
decl_stmt|;
name|rtx
name|dest_mem
decl_stmt|;
if|if
condition|(
name|SSE_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
condition|)
block|{
name|src_addr
operator|=
name|sse_addr_rtx
expr_stmt|;
name|src_offset
operator|=
operator|(
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|-
name|FIRST_SSE_REG
operator|)
operator|*
literal|16
expr_stmt|;
block|}
else|else
block|{
name|src_addr
operator|=
name|int_addr_rtx
expr_stmt|;
name|src_offset
operator|=
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|*
literal|8
expr_stmt|;
block|}
name|src_mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode
argument_list|,
name|src_addr
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|src_mem
argument_list|,
name|get_varargs_alias_set
argument_list|()
argument_list|)
expr_stmt|;
name|src_mem
operator|=
name|adjust_address
argument_list|(
name|src_mem
argument_list|,
name|mode
argument_list|,
name|src_offset
argument_list|)
expr_stmt|;
name|dest_mem
operator|=
name|adjust_address
argument_list|(
name|mem
argument_list|,
name|mode
argument_list|,
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|slot
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|dest_mem
argument_list|,
name|src_mem
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|needed_intregs
condition|)
block|{
name|t
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|gpr
argument_list|)
argument_list|,
name|gpr
argument_list|,
name|build_int_2
argument_list|(
name|needed_intregs
operator|*
literal|8
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|gpr
argument_list|)
argument_list|,
name|gpr
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|needed_sseregs
condition|)
block|{
name|t
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|fpr
argument_list|)
argument_list|,
name|fpr
argument_list|,
name|build_int_2
argument_list|(
name|needed_sseregs
operator|*
literal|16
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|fpr
argument_list|)
argument_list|,
name|fpr
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
block|}
name|emit_jump_insn
argument_list|(
name|gen_jump
argument_list|(
name|lab_over
argument_list|)
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|lab_false
argument_list|)
expr_stmt|;
block|}
comment|/* ... otherwise out of the overflow area.  */
comment|/* Care for on-stack alignment if needed.  */
if|if
condition|(
name|FUNCTION_ARG_BOUNDARY
argument_list|(
name|VOIDmode
argument_list|,
name|type
argument_list|)
operator|<=
literal|64
condition|)
name|t
operator|=
name|ovf
expr_stmt|;
else|else
block|{
name|HOST_WIDE_INT
name|align
init|=
name|FUNCTION_ARG_BOUNDARY
argument_list|(
name|VOIDmode
argument_list|,
name|type
argument_list|)
operator|/
literal|8
decl_stmt|;
name|t
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|ovf
argument_list|)
argument_list|,
name|ovf
argument_list|,
name|build_int_2
argument_list|(
name|align
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|t
argument_list|,
name|build_int_2
argument_list|(
operator|-
name|align
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|save_expr
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|r
operator|=
name|expand_expr
argument_list|(
name|t
argument_list|,
name|addr_rtx
argument_list|,
name|Pmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|addr_rtx
condition|)
name|emit_move_insn
argument_list|(
name|addr_rtx
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|t
argument_list|,
name|build_int_2
argument_list|(
name|rsize
operator|*
name|UNITS_PER_WORD
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|ovf
argument_list|)
argument_list|,
name|ovf
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|container
condition|)
name|emit_label
argument_list|(
name|lab_over
argument_list|)
expr_stmt|;
if|if
condition|(
name|indirect_p
condition|)
block|{
name|r
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|addr_rtx
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|r
argument_list|,
name|get_varargs_alias_set
argument_list|()
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|addr_rtx
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
return|return
name|addr_rtx
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if OP is either a i387 or SSE fp register.  */
end_comment

begin_function
name|int
name|any_fp_register_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|ANY_FP_REG_P
argument_list|(
name|op
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if OP is an i387 fp register.  */
end_comment

begin_function
name|int
name|fp_register_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|FP_REG_P
argument_list|(
name|op
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if OP is a non-fp register_operand.  */
end_comment

begin_function
name|int
name|register_and_not_any_fp_reg_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
return|return
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|&&
operator|!
name|ANY_FP_REG_P
argument_list|(
name|op
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if OP is a register operand other than an    i387 fp register.  */
end_comment

begin_function
name|int
name|register_and_not_fp_reg_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
return|return
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|&&
operator|!
name|FP_REG_P
argument_list|(
name|op
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if OP is general operand representable on x86_64.  */
end_comment

begin_function
name|int
name|x86_64_general_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|TARGET_64BIT
condition|)
return|return
name|general_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
if|if
condition|(
name|nonimmediate_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
name|x86_64_sign_extended_value
argument_list|(
name|op
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if OP is general operand representable on x86_64    as either sign extended or zero extended constant.  */
end_comment

begin_function
name|int
name|x86_64_szext_general_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|TARGET_64BIT
condition|)
return|return
name|general_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
if|if
condition|(
name|nonimmediate_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
name|x86_64_sign_extended_value
argument_list|(
name|op
argument_list|)
operator|||
name|x86_64_zero_extended_value
argument_list|(
name|op
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if OP is nonmemory operand representable on x86_64.  */
end_comment

begin_function
name|int
name|x86_64_nonmemory_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|TARGET_64BIT
condition|)
return|return
name|nonmemory_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
if|if
condition|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
name|x86_64_sign_extended_value
argument_list|(
name|op
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if OP is nonmemory operand acceptable by movabs patterns.  */
end_comment

begin_function
name|int
name|x86_64_movabs_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|TARGET_64BIT
operator|||
operator|!
name|flag_pic
condition|)
return|return
name|nonmemory_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
if|if
condition|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
name|x86_64_sign_extended_value
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
operator|&&
operator|!
name|symbolic_reference_mentioned_p
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if OPNUM's MEM should be matched    in movabs* patterns.  */
end_comment

begin_function
name|int
name|ix86_check_movabs
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|int
name|opnum
parameter_list|)
block|{
name|rtx
name|set
decl_stmt|,
name|mem
decl_stmt|;
name|set
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|set
argument_list|)
operator|==
name|PARALLEL
condition|)
name|set
operator|=
name|XVECEXP
argument_list|(
name|set
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|set
argument_list|)
operator|!=
name|SET
condition|)
name|abort
argument_list|()
expr_stmt|;
name|mem
operator|=
name|XEXP
argument_list|(
name|set
argument_list|,
name|opnum
argument_list|)
expr_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|mem
argument_list|)
operator|==
name|SUBREG
condition|)
name|mem
operator|=
name|SUBREG_REG
argument_list|(
name|mem
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|mem
argument_list|)
operator|!=
name|MEM
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
operator|(
name|volatile_ok
operator|||
operator|!
name|MEM_VOLATILE_P
argument_list|(
name|mem
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if OP is nonmemory operand representable on x86_64.  */
end_comment

begin_function
name|int
name|x86_64_szext_nonmemory_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|TARGET_64BIT
condition|)
return|return
name|nonmemory_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
if|if
condition|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
name|x86_64_sign_extended_value
argument_list|(
name|op
argument_list|)
operator|||
name|x86_64_zero_extended_value
argument_list|(
name|op
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if OP is immediate operand representable on x86_64.  */
end_comment

begin_function
name|int
name|x86_64_immediate_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|TARGET_64BIT
condition|)
return|return
name|immediate_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
return|return
name|x86_64_sign_extended_value
argument_list|(
name|op
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if OP is immediate operand representable on x86_64.  */
end_comment

begin_function
name|int
name|x86_64_zext_immediate_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|x86_64_zero_extended_value
argument_list|(
name|op
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if OP is CONST_INT>= 1 and<= 31 (a valid operand    for shift& compare patterns, as shifting by 0 does not change flags),    else return zero.  */
end_comment

begin_function
name|int
name|const_int_1_31_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|>=
literal|1
operator|&&
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<=
literal|31
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if OP is either a symbol reference or a sum of a symbol    reference and a constant.  */
end_comment

begin_function
name|int
name|symbolic_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
return|return
literal|1
return|;
case|case
name|CONST
case|:
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|LABEL_REF
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|UNSPEC
operator|&&
operator|(
name|XINT
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPEC_GOT
operator|||
name|XINT
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPEC_GOTOFF
operator|||
name|XINT
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPEC_GOTPCREL
operator|)
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
literal|0
return|;
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|LABEL_REF
condition|)
return|return
literal|1
return|;
comment|/* Only @GOTOFF gets offsets.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|UNSPEC
operator|||
name|XINT
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
operator|!=
name|UNSPEC_GOTOFF
condition|)
return|return
literal|0
return|;
name|op
operator|=
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|LABEL_REF
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return true if the operand contains a @GOT or @GOTOFF reference.  */
end_comment

begin_function
name|int
name|pic_symbolic_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|CONST
condition|)
return|return
literal|0
return|;
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|UNSPEC
operator|&&
name|XINT
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPEC_GOTPCREL
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|UNSPEC
operator|&&
name|XINT
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPEC_GOTPCREL
condition|)
return|return
literal|1
return|;
block|}
else|else
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|UNSPEC
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
literal|0
return|;
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|UNSPEC
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return true if OP is a symbolic operand that resolves locally.  */
end_comment

begin_function
specifier|static
name|int
name|local_symbolic_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
name|op
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|LABEL_REF
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|SYMBOL_REF
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|SYMBOL_REF_LOCAL_P
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* There is, however, a not insubstantial body of code in the rest of      the compiler that assumes it can just stick the results of      ASM_GENERATE_INTERNAL_LABEL in a symbol_ref and have done.  */
comment|/* ??? This is a hack.  Should update the body of the compiler to      always create a DECL an invoke targetm.encode_section_info.  */
if|if
condition|(
name|strncmp
argument_list|(
name|XSTR
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|internal_label_prefix
argument_list|,
name|internal_label_prefix_len
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Test for various thread-local symbols.  */
end_comment

begin_function
name|int
name|tls_symbolic_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|SYMBOL_REF
condition|)
return|return
literal|0
return|;
return|return
name|SYMBOL_REF_TLS_MODEL
argument_list|(
name|op
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|tls_symbolic_operand_1
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|tls_model
name|kind
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|SYMBOL_REF
condition|)
return|return
literal|0
return|;
return|return
name|SYMBOL_REF_TLS_MODEL
argument_list|(
name|op
argument_list|)
operator|==
name|kind
return|;
block|}
end_function

begin_function
name|int
name|global_dynamic_symbolic_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|tls_symbolic_operand_1
argument_list|(
name|op
argument_list|,
name|TLS_MODEL_GLOBAL_DYNAMIC
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|local_dynamic_symbolic_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|tls_symbolic_operand_1
argument_list|(
name|op
argument_list|,
name|TLS_MODEL_LOCAL_DYNAMIC
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|initial_exec_symbolic_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|tls_symbolic_operand_1
argument_list|(
name|op
argument_list|,
name|TLS_MODEL_INITIAL_EXEC
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|local_exec_symbolic_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|tls_symbolic_operand_1
argument_list|(
name|op
argument_list|,
name|TLS_MODEL_LOCAL_EXEC
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Test for a valid operand for a call instruction.  Don't allow the    arg pointer register or virtual regs since they may decay into    reg + const, which the patterns can't handle.  */
end_comment

begin_function
name|int
name|call_insn_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* Disallow indirect through a virtual register.  This leads to      compiler aborts when trying to eliminate them.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|op
operator|==
name|arg_pointer_rtx
operator|||
name|op
operator|==
name|frame_pointer_rtx
operator|||
operator|(
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|<=
name|LAST_VIRTUAL_REGISTER
operator|)
operator|)
condition|)
return|return
literal|0
return|;
comment|/* Disallow `call 1234'.  Due to varying assembler lameness this      gets either rejected or translated to `call .+1234'.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
literal|0
return|;
comment|/* Explicitly allow SYMBOL_REF even if pic.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
return|return
literal|1
return|;
comment|/* Otherwise we can allow any general_operand in the address.  */
return|return
name|general_operand
argument_list|(
name|op
argument_list|,
name|Pmode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Test for a valid operand for a call instruction.  Don't allow the    arg pointer register or virtual regs since they may decay into    reg + const, which the patterns can't handle.  */
end_comment

begin_function
name|int
name|sibcall_insn_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* Disallow indirect through a virtual register.  This leads to      compiler aborts when trying to eliminate them.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|op
operator|==
name|arg_pointer_rtx
operator|||
name|op
operator|==
name|frame_pointer_rtx
operator|||
operator|(
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|<=
name|LAST_VIRTUAL_REGISTER
operator|)
operator|)
condition|)
return|return
literal|0
return|;
comment|/* Explicitly allow SYMBOL_REF even if pic.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
return|return
literal|1
return|;
comment|/* Otherwise we can only allow register operands.  */
return|return
name|register_operand
argument_list|(
name|op
argument_list|,
name|Pmode
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|constant_call_address_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
name|op
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SYMBOL_REF
return|;
block|}
end_function

begin_comment
comment|/* Match exactly zero and one.  */
end_comment

begin_function
name|int
name|const0_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
return|return
name|op
operator|==
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|const1_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|op
operator|==
name|const1_rtx
return|;
block|}
end_function

begin_comment
comment|/* Match 2, 4, or 8.  Used for leal multiplicands.  */
end_comment

begin_function
name|int
name|const248_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|==
literal|2
operator|||
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|==
literal|4
operator|||
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|==
literal|8
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|const_0_to_3_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|>=
literal|0
operator|&&
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<
literal|4
operator|)
return|;
block|}
end_function

begin_function
name|int
name|const_0_to_7_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|>=
literal|0
operator|&&
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<
literal|8
operator|)
return|;
block|}
end_function

begin_function
name|int
name|const_0_to_15_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|>=
literal|0
operator|&&
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<
literal|16
operator|)
return|;
block|}
end_function

begin_function
name|int
name|const_0_to_255_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|>=
literal|0
operator|&&
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<
literal|256
operator|)
return|;
block|}
end_function

begin_comment
comment|/* True if this is a constant appropriate for an increment or decrement.  */
end_comment

begin_function
name|int
name|incdec_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* On Pentium4, the inc and dec operations causes extra dependency on flag      registers, since carry flag is not set.  */
if|if
condition|(
name|TARGET_PENTIUM4
operator|&&
operator|!
name|optimize_size
condition|)
return|return
literal|0
return|;
return|return
name|op
operator|==
name|const1_rtx
operator|||
name|op
operator|==
name|constm1_rtx
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if OP is acceptable as operand of DImode shift    expander.  */
end_comment

begin_function
name|int
name|shiftdi_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|TARGET_64BIT
condition|)
return|return
name|nonimmediate_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
else|else
return|return
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return false if this is the stack pointer, or any other fake    register eliminable to the stack pointer.  Otherwise, this is    a register operand.     This is used to prevent esp from being used as an index reg.    Which would only happen in pathological cases.  */
end_comment

begin_function
name|int
name|reg_no_sp_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|rtx
name|t
init|=
name|op
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|SUBREG
condition|)
name|t
operator|=
name|SUBREG_REG
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|stack_pointer_rtx
operator|||
name|t
operator|==
name|arg_pointer_rtx
operator|||
name|t
operator|==
name|frame_pointer_rtx
condition|)
return|return
literal|0
return|;
return|return
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|mmx_reg_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|MMX_REG_P
argument_list|(
name|op
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return false if this is any eliminable register.  Otherwise    general_operand.  */
end_comment

begin_function
name|int
name|general_no_elim_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|rtx
name|t
init|=
name|op
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|SUBREG
condition|)
name|t
operator|=
name|SUBREG_REG
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|arg_pointer_rtx
operator|||
name|t
operator|==
name|frame_pointer_rtx
operator|||
name|t
operator|==
name|virtual_incoming_args_rtx
operator|||
name|t
operator|==
name|virtual_stack_vars_rtx
operator|||
name|t
operator|==
name|virtual_stack_dynamic_rtx
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|REG_P
argument_list|(
name|t
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|t
argument_list|)
operator|>=
name|FIRST_VIRTUAL_REGISTER
operator|&&
name|REGNO
argument_list|(
name|t
argument_list|)
operator|<=
name|LAST_VIRTUAL_REGISTER
condition|)
return|return
literal|0
return|;
return|return
name|general_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return false if this is any eliminable register.  Otherwise    register_operand or const_int.  */
end_comment

begin_function
name|int
name|nonmemory_no_elim_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|rtx
name|t
init|=
name|op
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|SUBREG
condition|)
name|t
operator|=
name|SUBREG_REG
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|arg_pointer_rtx
operator|||
name|t
operator|==
name|frame_pointer_rtx
operator|||
name|t
operator|==
name|virtual_incoming_args_rtx
operator|||
name|t
operator|==
name|virtual_stack_vars_rtx
operator|||
name|t
operator|==
name|virtual_stack_dynamic_rtx
condition|)
return|return
literal|0
return|;
return|return
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|||
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return false if this is any eliminable register or stack register,    otherwise work like register_operand.  */
end_comment

begin_function
name|int
name|index_register_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|rtx
name|t
init|=
name|op
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|SUBREG
condition|)
name|t
operator|=
name|SUBREG_REG
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|t
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|t
operator|==
name|arg_pointer_rtx
operator|||
name|t
operator|==
name|frame_pointer_rtx
operator|||
name|t
operator|==
name|virtual_incoming_args_rtx
operator|||
name|t
operator|==
name|virtual_stack_vars_rtx
operator|||
name|t
operator|==
name|virtual_stack_dynamic_rtx
operator|||
name|REGNO
argument_list|(
name|t
argument_list|)
operator|==
name|STACK_POINTER_REGNUM
condition|)
return|return
literal|0
return|;
return|return
name|general_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if op is a Q_REGS class register.  */
end_comment

begin_function
name|int
name|q_regs_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
return|return
name|ANY_QI_REG_P
argument_list|(
name|op
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if op is an flags register.  */
end_comment

begin_function
name|int
name|flags_reg_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
condition|)
return|return
literal|0
return|;
return|return
name|REG_P
argument_list|(
name|op
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|==
name|FLAGS_REG
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|VOIDmode
return|;
block|}
end_function

begin_comment
comment|/* Return true if op is a NON_Q_REGS class register.  */
end_comment

begin_function
name|int
name|non_q_regs_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
return|return
name|NON_QI_REG_P
argument_list|(
name|op
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|zero_extended_scalar_load_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|unsigned
name|n_elts
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|MEM
condition|)
return|return
literal|0
return|;
name|op
operator|=
name|maybe_get_pool_constant
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|op
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|CONST_VECTOR
condition|)
return|return
literal|0
return|;
name|n_elts
operator|=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|/
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE_INNER
argument_list|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|)
argument_list|)
operator|)
expr_stmt|;
for|for
control|(
name|n_elts
operator|--
init|;
name|n_elts
operator|>
literal|0
condition|;
name|n_elts
operator|--
control|)
block|{
name|rtx
name|elt
init|=
name|CONST_VECTOR_ELT
argument_list|(
name|op
argument_list|,
name|n_elts
argument_list|)
decl_stmt|;
if|if
condition|(
name|elt
operator|!=
name|CONST0_RTX
argument_list|(
name|GET_MODE_INNER
argument_list|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  Return 1 when OP is operand acceptable for standard SSE move.  */
end_comment

begin_function
name|int
name|vector_move_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|nonimmediate_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|op
operator|==
name|CONST0_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if op if a valid address, and does not contain    a segment override.  */
end_comment

begin_function
name|int
name|no_seg_address_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|struct
name|ix86_address
name|parts
decl_stmt|;
if|if
condition|(
operator|!
name|address_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|ix86_decompose_address
argument_list|(
name|op
argument_list|,
operator|&
name|parts
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|parts
operator|.
name|seg
operator|==
name|SEG_DEFAULT
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a comparison that can be used in the CMPSS/CMPPS    insns.  */
end_comment

begin_function
name|int
name|sse_comparison_operator
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
comment|/* Operations supported directly.  */
case|case
name|EQ
case|:
case|case
name|LT
case|:
case|case
name|LE
case|:
case|case
name|UNORDERED
case|:
case|case
name|NE
case|:
case|case
name|UNGE
case|:
case|case
name|UNGT
case|:
case|case
name|ORDERED
case|:
return|return
literal|1
return|;
comment|/* These are equivalent to ones above in non-IEEE comparisons.  */
case|case
name|UNEQ
case|:
case|case
name|UNLT
case|:
case|case
name|UNLE
case|:
case|case
name|LTGT
case|:
case|case
name|GE
case|:
case|case
name|GT
case|:
return|return
operator|!
name|TARGET_IEEE_FP
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a valid comparison operator in valid mode.  */
end_comment

begin_function
name|int
name|ix86_comparison_operator
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|enum
name|machine_mode
name|inmode
decl_stmt|;
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|!=
literal|'<'
condition|)
return|return
literal|0
return|;
name|inmode
operator|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|inmode
operator|==
name|CCFPmode
operator|||
name|inmode
operator|==
name|CCFPUmode
condition|)
block|{
name|enum
name|rtx_code
name|second_code
decl_stmt|,
name|bypass_code
decl_stmt|;
name|ix86_fp_comparison_codes
argument_list|(
name|code
argument_list|,
operator|&
name|bypass_code
argument_list|,
operator|&
name|code
argument_list|,
operator|&
name|second_code
argument_list|)
expr_stmt|;
return|return
operator|(
name|bypass_code
operator|==
name|NIL
operator|&&
name|second_code
operator|==
name|NIL
operator|)
return|;
block|}
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EQ
case|:
case|case
name|NE
case|:
return|return
literal|1
return|;
case|case
name|LT
case|:
case|case
name|GE
case|:
if|if
condition|(
name|inmode
operator|==
name|CCmode
operator|||
name|inmode
operator|==
name|CCGCmode
operator|||
name|inmode
operator|==
name|CCGOCmode
operator|||
name|inmode
operator|==
name|CCNOmode
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
case|case
name|LTU
case|:
case|case
name|GTU
case|:
case|case
name|LEU
case|:
case|case
name|ORDERED
case|:
case|case
name|UNORDERED
case|:
case|case
name|GEU
case|:
if|if
condition|(
name|inmode
operator|==
name|CCmode
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
case|case
name|GT
case|:
case|case
name|LE
case|:
if|if
condition|(
name|inmode
operator|==
name|CCmode
operator|||
name|inmode
operator|==
name|CCGCmode
operator|||
name|inmode
operator|==
name|CCNOmode
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a valid comparison operator testing carry flag    to be set.  */
end_comment

begin_function
name|int
name|ix86_carry_flag_operator
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|enum
name|machine_mode
name|inmode
decl_stmt|;
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|!=
literal|'<'
condition|)
return|return
literal|0
return|;
name|inmode
operator|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
literal|17
operator|||
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
operator|!=
name|const0_rtx
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|inmode
operator|==
name|CCFPmode
operator|||
name|inmode
operator|==
name|CCFPUmode
condition|)
block|{
name|enum
name|rtx_code
name|second_code
decl_stmt|,
name|bypass_code
decl_stmt|;
name|ix86_fp_comparison_codes
argument_list|(
name|code
argument_list|,
operator|&
name|bypass_code
argument_list|,
operator|&
name|code
argument_list|,
operator|&
name|second_code
argument_list|)
expr_stmt|;
if|if
condition|(
name|bypass_code
operator|!=
name|NIL
operator|||
name|second_code
operator|!=
name|NIL
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|ix86_fp_compare_code_to_integer
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|inmode
operator|!=
name|CCmode
condition|)
return|return
literal|0
return|;
return|return
name|code
operator|==
name|LTU
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a comparison operator that can be issued by fcmov.  */
end_comment

begin_function
name|int
name|fcmov_comparison_operator
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|enum
name|machine_mode
name|inmode
decl_stmt|;
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|!=
literal|'<'
condition|)
return|return
literal|0
return|;
name|inmode
operator|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|inmode
operator|==
name|CCFPmode
operator|||
name|inmode
operator|==
name|CCFPUmode
condition|)
block|{
name|enum
name|rtx_code
name|second_code
decl_stmt|,
name|bypass_code
decl_stmt|;
name|ix86_fp_comparison_codes
argument_list|(
name|code
argument_list|,
operator|&
name|bypass_code
argument_list|,
operator|&
name|code
argument_list|,
operator|&
name|second_code
argument_list|)
expr_stmt|;
if|if
condition|(
name|bypass_code
operator|!=
name|NIL
operator|||
name|second_code
operator|!=
name|NIL
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|ix86_fp_compare_code_to_integer
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
comment|/* i387 supports just limited amount of conditional codes.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LTU
case|:
case|case
name|GTU
case|:
case|case
name|LEU
case|:
case|case
name|GEU
case|:
if|if
condition|(
name|inmode
operator|==
name|CCmode
operator|||
name|inmode
operator|==
name|CCFPmode
operator|||
name|inmode
operator|==
name|CCFPUmode
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
case|case
name|ORDERED
case|:
case|case
name|UNORDERED
case|:
case|case
name|EQ
case|:
case|case
name|NE
case|:
return|return
literal|1
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a binary operator that can be promoted to wider mode.  */
end_comment

begin_function
name|int
name|promotable_binary_operator
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|MULT
case|:
comment|/* Modern CPUs have same latency for HImode and SImode multiply,          but 386 and 486 do HImode multiply faster.  */
return|return
name|ix86_tune
operator|>
name|PROCESSOR_I486
return|;
case|case
name|PLUS
case|:
case|case
name|AND
case|:
case|case
name|IOR
case|:
case|case
name|XOR
case|:
case|case
name|ASHIFT
case|:
return|return
literal|1
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Nearly general operand, but accept any const_double, since we wish    to be able to drop them into memory rather than have them get pulled    into registers.  */
end_comment

begin_function
name|int
name|cmp_fp_expander_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
return|return
literal|1
return|;
return|return
name|general_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Match an SI or HImode register for a zero_extract.  */
end_comment

begin_function
name|int
name|ext_register_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
name|regno
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|TARGET_64BIT
operator|||
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|DImode
operator|)
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|SImode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|HImode
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|register_operand
argument_list|(
name|op
argument_list|,
name|VOIDmode
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Be careful to accept only registers having upper parts.  */
name|regno
operator|=
name|REG_P
argument_list|(
name|op
argument_list|)
condition|?
name|REGNO
argument_list|(
name|op
argument_list|)
else|:
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|regno
operator|>
name|LAST_VIRTUAL_REGISTER
operator|||
name|regno
operator|<
literal|4
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if this is a valid binary floating-point operation.    OP is the expression matched, and MODE is its mode.  */
end_comment

begin_function
name|int
name|binary_fp_operator
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
case|case
name|MULT
case|:
case|case
name|DIV
case|:
return|return
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_function
name|int
name|mult_operator
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MULT
return|;
block|}
end_function

begin_function
name|int
name|div_operator
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|DIV
return|;
block|}
end_function

begin_function
name|int
name|arith_or_logical_operator
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
return|return
operator|(
operator|(
name|mode
operator|==
name|VOIDmode
operator|||
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|mode
operator|)
operator|&&
operator|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
literal|'c'
operator|||
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
literal|'2'
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if OP is memory operand with a displacement.  */
end_comment

begin_function
name|int
name|memory_displacement_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|struct
name|ix86_address
name|parts
decl_stmt|;
if|if
condition|(
operator|!
name|memory_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|ix86_decompose_address
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|parts
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|parts
operator|.
name|disp
operator|!=
name|NULL_RTX
return|;
block|}
end_function

begin_comment
comment|/* To avoid problems when jump re-emits comparisons like testqi_ext_ccno_0,    re-recognize the operand to avoid a copy_to_mode_reg that will fail.     ??? It seems likely that this will only work because cmpsi is an    expander, and no actual insns use this.  */
end_comment

begin_function
name|int
name|cmpsi_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|nonimmediate_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|AND
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|SImode
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
literal|8
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
literal|8
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if OP is memory operand that can not be represented by the    modRM array.  */
end_comment

begin_function
name|int
name|long_memory_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|memory_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|memory_address_length
argument_list|(
name|op
argument_list|)
operator|!=
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if the rtx is known aligned.  */
end_comment

begin_function
name|int
name|aligned_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|struct
name|ix86_address
name|parts
decl_stmt|;
if|if
condition|(
operator|!
name|general_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Registers and immediate operands are always "aligned".  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|MEM
condition|)
return|return
literal|1
return|;
comment|/* Don't even try to do any aligned optimizations with volatiles.  */
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Pushes and pops are only valid on the stack pointer.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|PRE_DEC
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|POST_INC
condition|)
return|return
literal|1
return|;
comment|/* Decode the address.  */
if|if
condition|(
operator|!
name|ix86_decompose_address
argument_list|(
name|op
argument_list|,
operator|&
name|parts
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Look for some component that isn't known to be aligned.  */
if|if
condition|(
name|parts
operator|.
name|index
condition|)
block|{
if|if
condition|(
name|parts
operator|.
name|scale
operator|<
literal|4
operator|&&
name|REGNO_POINTER_ALIGN
argument_list|(
name|REGNO
argument_list|(
name|parts
operator|.
name|index
argument_list|)
argument_list|)
operator|<
literal|32
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|parts
operator|.
name|base
condition|)
block|{
if|if
condition|(
name|REGNO_POINTER_ALIGN
argument_list|(
name|REGNO
argument_list|(
name|parts
operator|.
name|base
argument_list|)
argument_list|)
operator|<
literal|32
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|parts
operator|.
name|disp
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|parts
operator|.
name|disp
argument_list|)
operator|!=
name|CONST_INT
operator|||
operator|(
name|INTVAL
argument_list|(
name|parts
operator|.
name|disp
argument_list|)
operator|&
literal|3
operator|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
block|}
comment|/* Didn't find one -- this must be an aligned address.  */
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Initialize the table of extra 80387 mathematical constants.  */
end_comment

begin_function
specifier|static
name|void
name|init_ext_80387_constants
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|cst
index|[
literal|5
index|]
init|=
block|{
literal|"0.3010299956639811952256464283594894482"
block|,
comment|/* 0: fldlg2  */
literal|"0.6931471805599453094286904741849753009"
block|,
comment|/* 1: fldln2  */
literal|"1.4426950408889634073876517827983434472"
block|,
comment|/* 2: fldl2e  */
literal|"3.3219280948873623478083405569094566090"
block|,
comment|/* 3: fldl2t  */
literal|"3.1415926535897932385128089594061862044"
block|,
comment|/* 4: fldpi   */
block|}
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
name|real_from_string
argument_list|(
operator|&
name|ext_80387_constants_table
index|[
name|i
index|]
argument_list|,
name|cst
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Ensure each constant is rounded to XFmode precision.  */
name|real_convert
argument_list|(
operator|&
name|ext_80387_constants_table
index|[
name|i
index|]
argument_list|,
name|XFmode
argument_list|,
operator|&
name|ext_80387_constants_table
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|ext_80387_constants_init
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return true if the constant is something that can be loaded with    a special instruction.  */
end_comment

begin_function
name|int
name|standard_80387_constant_p
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_DOUBLE
operator|||
operator|!
name|FLOAT_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|x
operator|==
name|CONST0_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|x
operator|==
name|CONST1_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
return|return
literal|2
return|;
comment|/* For XFmode constants, try to find a special 80387 instruction on      those CPUs that benefit from them.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|XFmode
operator|&&
name|x86_ext_80387_constants
operator|&
name|TUNEMASK
condition|)
block|{
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|ext_80387_constants_init
condition|)
name|init_ext_80387_constants
argument_list|()
expr_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|r
argument_list|,
name|x
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|real_identical
argument_list|(
operator|&
name|r
argument_list|,
operator|&
name|ext_80387_constants_table
index|[
name|i
index|]
argument_list|)
condition|)
return|return
name|i
operator|+
literal|3
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the opcode of the special instruction to be used to load    the constant X.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|standard_80387_constant_opcode
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
switch|switch
condition|(
name|standard_80387_constant_p
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
return|return
literal|"fldz"
return|;
case|case
literal|2
case|:
return|return
literal|"fld1"
return|;
case|case
literal|3
case|:
return|return
literal|"fldlg2"
return|;
case|case
literal|4
case|:
return|return
literal|"fldln2"
return|;
case|case
literal|5
case|:
return|return
literal|"fldl2e"
return|;
case|case
literal|6
case|:
return|return
literal|"fldl2t"
return|;
case|case
literal|7
case|:
return|return
literal|"fldpi"
return|;
block|}
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the CONST_DOUBLE representing the 80387 constant that is    loaded by the specified special instruction.  The argument IDX    matches the return value from standard_80387_constant_p.  */
end_comment

begin_function
name|rtx
name|standard_80387_constant_rtx
parameter_list|(
name|int
name|idx
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|ext_80387_constants_init
condition|)
name|init_ext_80387_constants
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|idx
condition|)
block|{
case|case
literal|3
case|:
case|case
literal|4
case|:
case|case
literal|5
case|:
case|case
literal|6
case|:
case|case
literal|7
case|:
name|i
operator|=
name|idx
operator|-
literal|3
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|CONST_DOUBLE_FROM_REAL_VALUE
argument_list|(
name|ext_80387_constants_table
index|[
name|i
index|]
argument_list|,
name|XFmode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if X is FP constant we can load to SSE register w/o using memory.  */
end_comment

begin_function
name|int
name|standard_sse_constant_p
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
if|if
condition|(
name|x
operator|==
name|const0_rtx
condition|)
return|return
literal|1
return|;
return|return
operator|(
name|x
operator|==
name|CONST0_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if OP contains a symbol reference */
end_comment

begin_function
name|int
name|symbolic_reference_mentioned_p
parameter_list|(
name|rtx
name|op
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|LABEL_REF
condition|)
return|return
literal|1
return|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|op
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|symbolic_reference_mentioned_p
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|&&
name|symbolic_reference_mentioned_p
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if it is appropriate to emit `ret' instructions in the    body of a function.  Do this only if the epilogue is simple, needing a    couple of insns.  Prior to reloading, we can't tell how many registers    must be saved, so return 0 then.  Return 0 if there is no frame    marker to de-allocate.     If NON_SAVING_SETJMP is defined and true, then it is not possible    for the epilogue to be simple, so return 0.  This is a special case    since NON_SAVING_SETJMP will not cause regs_ever_live to change    until final, but jump_optimize may need to know sooner if a    `return' is OK.  */
end_comment

begin_function
name|int
name|ix86_can_use_return_insn_p
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|ix86_frame
name|frame
decl_stmt|;
ifdef|#
directive|ifdef
name|NON_SAVING_SETJMP
if|if
condition|(
name|NON_SAVING_SETJMP
operator|&&
name|current_function_calls_setjmp
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|reload_completed
operator|||
name|frame_pointer_needed
condition|)
return|return
literal|0
return|;
comment|/* Don't allow more than 32 pop, since that's all we can do      with one instruction.  */
if|if
condition|(
name|current_function_pops_args
operator|&&
name|current_function_args_size
operator|>=
literal|32768
condition|)
return|return
literal|0
return|;
name|ix86_compute_frame_layout
argument_list|(
operator|&
name|frame
argument_list|)
expr_stmt|;
return|return
name|frame
operator|.
name|to_allocate
operator|==
literal|0
operator|&&
name|frame
operator|.
name|nregs
operator|==
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if VALUE can be stored in the sign extended immediate field.  */
end_comment

begin_function
name|int
name|x86_64_sign_extended_value
parameter_list|(
name|rtx
name|value
parameter_list|)
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
condition|)
block|{
comment|/* CONST_DOUBLES never match, since HOST_BITS_PER_WIDE_INT is known          to be at least 32 and this all acceptable constants are 	 represented as CONST_INT.  */
case|case
name|CONST_INT
case|:
if|if
condition|(
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|32
condition|)
return|return
literal|1
return|;
else|else
block|{
name|HOST_WIDE_INT
name|val
init|=
name|trunc_int_for_mode
argument_list|(
name|INTVAL
argument_list|(
name|value
argument_list|)
argument_list|,
name|DImode
argument_list|)
decl_stmt|;
return|return
name|trunc_int_for_mode
argument_list|(
name|val
argument_list|,
name|SImode
argument_list|)
operator|==
name|val
return|;
block|}
break|break;
comment|/* For certain code models, the symbolic references are known to fit. 	 in CM_SMALL_PIC model we know it fits if it is local to the shared 	 library.  Don't count TLS SYMBOL_REFs here, since they should fit 	 only if inside of UNSPEC handled below.  */
case|case
name|SYMBOL_REF
case|:
comment|/* TLS symbols are not constant.  */
if|if
condition|(
name|tls_symbolic_operand
argument_list|(
name|value
argument_list|,
name|Pmode
argument_list|)
condition|)
return|return
name|false
return|;
return|return
operator|(
name|ix86_cmodel
operator|==
name|CM_SMALL
operator|||
name|ix86_cmodel
operator|==
name|CM_KERNEL
operator|)
return|;
comment|/* For certain code models, the code is near as well.  */
case|case
name|LABEL_REF
case|:
return|return
operator|(
name|ix86_cmodel
operator|==
name|CM_SMALL
operator|||
name|ix86_cmodel
operator|==
name|CM_MEDIUM
operator|||
name|ix86_cmodel
operator|==
name|CM_KERNEL
operator|)
return|;
comment|/* We also may accept the offsetted memory references in certain special          cases.  */
case|case
name|CONST
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|UNSPEC
condition|)
switch|switch
condition|(
name|XINT
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
block|{
case|case
name|UNSPEC_GOTPCREL
case|:
case|case
name|UNSPEC_DTPOFF
case|:
case|case
name|UNSPEC_GOTNTPOFF
case|:
case|case
name|UNSPEC_NTPOFF
case|:
return|return
literal|1
return|;
default|default:
break|break;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|rtx
name|op1
init|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|op2
init|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|offset
decl_stmt|;
if|if
condition|(
name|ix86_cmodel
operator|==
name|CM_LARGE
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op2
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
literal|0
return|;
name|offset
operator|=
name|trunc_int_for_mode
argument_list|(
name|INTVAL
argument_list|(
name|op2
argument_list|)
argument_list|,
name|DImode
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
condition|)
block|{
case|case
name|SYMBOL_REF
case|:
comment|/* For CM_SMALL assume that latest object is 16MB before 		     end of 31bits boundary.  We may also accept pretty 		     large negative constants knowing that all objects are 		     in the positive half of address space.  */
if|if
condition|(
name|ix86_cmodel
operator|==
name|CM_SMALL
operator|&&
name|offset
operator|<
literal|16
operator|*
literal|1024
operator|*
literal|1024
operator|&&
name|trunc_int_for_mode
argument_list|(
name|offset
argument_list|,
name|SImode
argument_list|)
operator|==
name|offset
condition|)
return|return
literal|1
return|;
comment|/* For CM_KERNEL we know that all object resist in the 		     negative half of 32bits address space.  We may not 		     accept negative offsets, since they may be just off 		     and we may accept pretty large positive ones.  */
if|if
condition|(
name|ix86_cmodel
operator|==
name|CM_KERNEL
operator|&&
name|offset
operator|>
literal|0
operator|&&
name|trunc_int_for_mode
argument_list|(
name|offset
argument_list|,
name|SImode
argument_list|)
operator|==
name|offset
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|LABEL_REF
case|:
comment|/* These conditions are similar to SYMBOL_REF ones, just the 		     constraints for code models differ.  */
if|if
condition|(
operator|(
name|ix86_cmodel
operator|==
name|CM_SMALL
operator|||
name|ix86_cmodel
operator|==
name|CM_MEDIUM
operator|)
operator|&&
name|offset
operator|<
literal|16
operator|*
literal|1024
operator|*
literal|1024
operator|&&
name|trunc_int_for_mode
argument_list|(
name|offset
argument_list|,
name|SImode
argument_list|)
operator|==
name|offset
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|ix86_cmodel
operator|==
name|CM_KERNEL
operator|&&
name|offset
operator|>
literal|0
operator|&&
name|trunc_int_for_mode
argument_list|(
name|offset
argument_list|,
name|SImode
argument_list|)
operator|==
name|offset
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|UNSPEC
case|:
switch|switch
condition|(
name|XINT
argument_list|(
name|op1
argument_list|,
literal|1
argument_list|)
condition|)
block|{
case|case
name|UNSPEC_DTPOFF
case|:
case|case
name|UNSPEC_NTPOFF
case|:
if|if
condition|(
name|offset
operator|>
literal|0
operator|&&
name|trunc_int_for_mode
argument_list|(
name|offset
argument_list|,
name|SImode
argument_list|)
operator|==
name|offset
condition|)
return|return
literal|1
return|;
block|}
break|break;
default|default:
return|return
literal|0
return|;
block|}
block|}
return|return
literal|0
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return 1 if VALUE can be stored in the zero extended immediate field.  */
end_comment

begin_function
name|int
name|x86_64_zero_extended_value
parameter_list|(
name|rtx
name|value
parameter_list|)
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
condition|)
block|{
case|case
name|CONST_DOUBLE
case|:
if|if
condition|(
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|32
condition|)
return|return
operator|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
operator|==
name|VOIDmode
operator|&&
operator|!
name|CONST_DOUBLE_HIGH
argument_list|(
name|value
argument_list|)
operator|)
return|;
else|else
return|return
literal|0
return|;
case|case
name|CONST_INT
case|:
if|if
condition|(
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|32
condition|)
return|return
name|INTVAL
argument_list|(
name|value
argument_list|)
operator|>=
literal|0
return|;
else|else
return|return
operator|!
operator|(
name|INTVAL
argument_list|(
name|value
argument_list|)
operator|&
operator|~
operator|(
name|HOST_WIDE_INT
operator|)
literal|0xffffffff
operator|)
return|;
break|break;
comment|/* For certain code models, the symbolic references are known to fit.  */
case|case
name|SYMBOL_REF
case|:
comment|/* TLS symbols are not constant.  */
if|if
condition|(
name|tls_symbolic_operand
argument_list|(
name|value
argument_list|,
name|Pmode
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|ix86_cmodel
operator|==
name|CM_SMALL
return|;
comment|/* For certain code models, the code is near as well.  */
case|case
name|LABEL_REF
case|:
return|return
name|ix86_cmodel
operator|==
name|CM_SMALL
operator|||
name|ix86_cmodel
operator|==
name|CM_MEDIUM
return|;
comment|/* We also may accept the offsetted memory references in certain special          cases.  */
case|case
name|CONST
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|rtx
name|op1
init|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|op2
init|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|ix86_cmodel
operator|==
name|CM_LARGE
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
condition|)
block|{
case|case
name|SYMBOL_REF
case|:
return|return
literal|0
return|;
comment|/* For small code model we may accept pretty large positive 		     offsets, since one bit is available for free.  Negative 		     offsets are limited by the size of NULL pointer area 		     specified by the ABI.  */
if|if
condition|(
name|ix86_cmodel
operator|==
name|CM_SMALL
operator|&&
name|GET_CODE
argument_list|(
name|op2
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|trunc_int_for_mode
argument_list|(
name|INTVAL
argument_list|(
name|op2
argument_list|)
argument_list|,
name|DImode
argument_list|)
operator|>
operator|-
literal|0x10000
operator|&&
operator|(
name|trunc_int_for_mode
argument_list|(
name|INTVAL
argument_list|(
name|op2
argument_list|)
argument_list|,
name|SImode
argument_list|)
operator|==
name|INTVAL
argument_list|(
name|op2
argument_list|)
operator|)
condition|)
return|return
literal|1
return|;
comment|/* ??? For the kernel, we may accept adjustment of 		     -0x10000000, since we know that it will just convert 		     negative address space to positive, but perhaps this 		     is not worthwhile.  */
break|break;
case|case
name|LABEL_REF
case|:
comment|/* These conditions are similar to SYMBOL_REF ones, just the 		     constraints for code models differ.  */
if|if
condition|(
operator|(
name|ix86_cmodel
operator|==
name|CM_SMALL
operator|||
name|ix86_cmodel
operator|==
name|CM_MEDIUM
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|op2
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|trunc_int_for_mode
argument_list|(
name|INTVAL
argument_list|(
name|op2
argument_list|)
argument_list|,
name|DImode
argument_list|)
operator|>
operator|-
literal|0x10000
operator|&&
operator|(
name|trunc_int_for_mode
argument_list|(
name|INTVAL
argument_list|(
name|op2
argument_list|)
argument_list|,
name|SImode
argument_list|)
operator|==
name|INTVAL
argument_list|(
name|op2
argument_list|)
operator|)
condition|)
return|return
literal|1
return|;
break|break;
default|default:
return|return
literal|0
return|;
block|}
block|}
return|return
literal|0
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Value should be nonzero if functions must have frame pointers.    Zero means the frame pointer need not be set up (and parms may    be accessed via the stack pointer) in functions that seem suitable.  */
end_comment

begin_function
name|int
name|ix86_frame_pointer_required
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* If we accessed previous frames, then the generated code expects      to be able to access the saved ebp value in our frame.  */
if|if
condition|(
name|cfun
operator|->
name|machine
operator|->
name|accesses_prev_frame
condition|)
return|return
literal|1
return|;
comment|/* Several x86 os'es need a frame pointer for other reasons,      usually pertaining to setjmp.  */
if|if
condition|(
name|SUBTARGET_FRAME_POINTER_REQUIRED
condition|)
return|return
literal|1
return|;
comment|/* In override_options, TARGET_OMIT_LEAF_FRAME_POINTER turns off      the frame pointer by default.  Turn it back on now if we've not      got a leaf function.  */
if|if
condition|(
name|TARGET_OMIT_LEAF_FRAME_POINTER
operator|&&
operator|(
operator|!
name|current_function_is_leaf
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|current_function_profile
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Record that the current function accesses previous call frames.  */
end_comment

begin_function
name|void
name|ix86_setup_frame_addresses
parameter_list|(
name|void
parameter_list|)
block|{
name|cfun
operator|->
name|machine
operator|->
name|accesses_prev_frame
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_GAS_HIDDEN
argument_list|)
operator|&&
name|defined
argument_list|(
name|SUPPORTS_ONE_ONLY
argument_list|)
end_if

begin_define
define|#
directive|define
name|USE_HIDDEN_LINKONCE
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|USE_HIDDEN_LINKONCE
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|pic_labels_used
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Fills in the label name that should be used for a pc thunk for    the given register.  */
end_comment

begin_function
specifier|static
name|void
name|get_pc_thunk_name
parameter_list|(
name|char
name|name
index|[
literal|32
index|]
parameter_list|,
name|unsigned
name|int
name|regno
parameter_list|)
block|{
if|if
condition|(
name|USE_HIDDEN_LINKONCE
condition|)
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"__i686.get_pc_thunk.%s"
argument_list|,
name|reg_names
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
else|else
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|name
argument_list|,
literal|"LPR"
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function generates code for -fpic that loads %ebx with    the return address of the caller and then returns.  */
end_comment

begin_function
name|void
name|ix86_file_end
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|xops
index|[
literal|2
index|]
decl_stmt|;
name|int
name|regno
decl_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
literal|8
condition|;
operator|++
name|regno
control|)
block|{
name|char
name|name
index|[
literal|32
index|]
decl_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|pic_labels_used
operator|>>
name|regno
operator|)
operator|&
literal|1
operator|)
condition|)
continue|continue;
name|get_pc_thunk_name
argument_list|(
name|name
argument_list|,
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|USE_HIDDEN_LINKONCE
condition|)
block|{
name|tree
name|decl
decl_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|get_identifier
argument_list|(
name|name
argument_list|)
argument_list|,
name|error_mark_node
argument_list|)
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_ONE_ONLY
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
call|(
modifier|*
name|targetm
operator|.
name|asm_out
operator|.
name|unique_section
call|)
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|named_section
argument_list|(
name|decl
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
call|(
modifier|*
name|targetm
operator|.
name|asm_out
operator|.
name|globalize_label
call|)
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\t.hidden\t"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_DECLARE_FUNCTION_NAME
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|text_section
argument_list|()
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|xops
index|[
literal|0
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|xops
index|[
literal|1
index|]
operator|=
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|stack_pointer_rtx
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"mov{l}\t{%1, %0|%0, %1}"
argument_list|,
name|xops
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ret"
argument_list|,
name|xops
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|NEED_INDICATE_EXEC_STACK
condition|)
name|file_end_indicate_exec_stack
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit code for the SET_GOT patterns.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|output_set_got
parameter_list|(
name|rtx
name|dest
parameter_list|)
block|{
name|rtx
name|xops
index|[
literal|3
index|]
decl_stmt|;
name|xops
index|[
literal|0
index|]
operator|=
name|dest
expr_stmt|;
name|xops
index|[
literal|1
index|]
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|GOT_SYMBOL_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TARGET_DEEP_BRANCH_PREDICTION
operator|||
operator|!
name|flag_pic
condition|)
block|{
name|xops
index|[
literal|2
index|]
operator|=
name|gen_rtx_LABEL_REF
argument_list|(
name|Pmode
argument_list|,
name|gen_label_rtx
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flag_pic
condition|)
name|output_asm_insn
argument_list|(
literal|"mov{l}\t{%2, %0|%0, %2}"
argument_list|,
name|xops
argument_list|)
expr_stmt|;
else|else
name|output_asm_insn
argument_list|(
literal|"call\t%a2"
argument_list|,
name|xops
argument_list|)
expr_stmt|;
if|#
directive|if
name|TARGET_MACHO
comment|/* Output the "canonical" label name ("Lxx$pb") here too.  This          is what will be referred to by the Mach-O PIC subsystem.  */
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|machopic_function_base_name
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
call|(
modifier|*
name|targetm
operator|.
name|asm_out
operator|.
name|internal_label
call|)
argument_list|(
name|asm_out_file
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|xops
index|[
literal|2
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_pic
condition|)
name|output_asm_insn
argument_list|(
literal|"pop{l}\t%0"
argument_list|,
name|xops
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
name|name
index|[
literal|32
index|]
decl_stmt|;
name|get_pc_thunk_name
argument_list|(
name|name
argument_list|,
name|REGNO
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
name|pic_labels_used
operator||=
literal|1
operator|<<
name|REGNO
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|xops
index|[
literal|2
index|]
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|ggc_strdup
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|xops
index|[
literal|2
index|]
operator|=
name|gen_rtx_MEM
argument_list|(
name|QImode
argument_list|,
name|xops
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"call\t%X2"
argument_list|,
name|xops
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|flag_pic
operator|||
name|TARGET_DEEP_BRANCH_PREDICTION
condition|)
name|output_asm_insn
argument_list|(
literal|"add{l}\t{%1, %0|%0, %1}"
argument_list|,
name|xops
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|TARGET_MACHO
condition|)
name|output_asm_insn
argument_list|(
literal|"add{l}\t{%1+[.-%a2], %0|%0, %a1+(.-%a2)}"
argument_list|,
name|xops
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
end_function

begin_comment
comment|/* Generate an "push" pattern for input ARG.  */
end_comment

begin_function
specifier|static
name|rtx
name|gen_push
parameter_list|(
name|rtx
name|arg
parameter_list|)
block|{
return|return
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_PRE_DEC
argument_list|(
name|Pmode
argument_list|,
name|stack_pointer_rtx
argument_list|)
argument_list|)
argument_list|,
name|arg
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return>= 0 if there is an unused call-clobbered register available    for the entire function.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|ix86_select_alt_pic_regnum
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|current_function_is_leaf
operator|&&
operator|!
name|current_function_profile
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
if|if
condition|(
operator|!
name|regs_ever_live
index|[
name|i
index|]
condition|)
return|return
name|i
return|;
block|}
return|return
name|INVALID_REGNUM
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if we need to save REGNO.  */
end_comment

begin_function
specifier|static
name|int
name|ix86_save_reg
parameter_list|(
name|unsigned
name|int
name|regno
parameter_list|,
name|int
name|maybe_eh_return
parameter_list|)
block|{
if|if
condition|(
name|pic_offset_table_rtx
operator|&&
name|regno
operator|==
name|REAL_PIC_OFFSET_TABLE_REGNUM
operator|&&
operator|(
name|regs_ever_live
index|[
name|REAL_PIC_OFFSET_TABLE_REGNUM
index|]
operator|||
name|current_function_profile
operator|||
name|current_function_calls_eh_return
operator|||
name|current_function_uses_const_pool
operator|)
condition|)
block|{
if|if
condition|(
name|ix86_select_alt_pic_regnum
argument_list|()
operator|!=
name|INVALID_REGNUM
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|current_function_calls_eh_return
operator|&&
name|maybe_eh_return
condition|)
block|{
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|test
init|=
name|EH_RETURN_DATA_REGNO
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|test
operator|==
name|INVALID_REGNUM
condition|)
break|break;
if|if
condition|(
name|test
operator|==
name|regno
condition|)
return|return
literal|1
return|;
block|}
block|}
return|return
operator|(
name|regs_ever_live
index|[
name|regno
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|regno
index|]
operator|&&
operator|!
name|fixed_regs
index|[
name|regno
index|]
operator|&&
operator|(
name|regno
operator|!=
name|HARD_FRAME_POINTER_REGNUM
operator|||
operator|!
name|frame_pointer_needed
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return number of registers to be saved on the stack.  */
end_comment

begin_function
specifier|static
name|int
name|ix86_nsaved_regs
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|nregs
init|=
literal|0
decl_stmt|;
name|int
name|regno
decl_stmt|;
for|for
control|(
name|regno
operator|=
name|FIRST_PSEUDO_REGISTER
operator|-
literal|1
init|;
name|regno
operator|>=
literal|0
condition|;
name|regno
operator|--
control|)
if|if
condition|(
name|ix86_save_reg
argument_list|(
name|regno
argument_list|,
name|true
argument_list|)
condition|)
name|nregs
operator|++
expr_stmt|;
return|return
name|nregs
return|;
block|}
end_function

begin_comment
comment|/* Return the offset between two registers, one to be eliminated, and the other    its replacement, at the start of a routine.  */
end_comment

begin_function
name|HOST_WIDE_INT
name|ix86_initial_elimination_offset
parameter_list|(
name|int
name|from
parameter_list|,
name|int
name|to
parameter_list|)
block|{
name|struct
name|ix86_frame
name|frame
decl_stmt|;
name|ix86_compute_frame_layout
argument_list|(
operator|&
name|frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|from
operator|==
name|ARG_POINTER_REGNUM
operator|&&
name|to
operator|==
name|HARD_FRAME_POINTER_REGNUM
condition|)
return|return
name|frame
operator|.
name|hard_frame_pointer_offset
return|;
elseif|else
if|if
condition|(
name|from
operator|==
name|FRAME_POINTER_REGNUM
operator|&&
name|to
operator|==
name|HARD_FRAME_POINTER_REGNUM
condition|)
return|return
name|frame
operator|.
name|hard_frame_pointer_offset
operator|-
name|frame
operator|.
name|frame_pointer_offset
return|;
else|else
block|{
if|if
condition|(
name|to
operator|!=
name|STACK_POINTER_REGNUM
condition|)
name|abort
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|from
operator|==
name|ARG_POINTER_REGNUM
condition|)
return|return
name|frame
operator|.
name|stack_pointer_offset
return|;
elseif|else
if|if
condition|(
name|from
operator|!=
name|FRAME_POINTER_REGNUM
condition|)
name|abort
argument_list|()
expr_stmt|;
else|else
return|return
name|frame
operator|.
name|stack_pointer_offset
operator|-
name|frame
operator|.
name|frame_pointer_offset
return|;
block|}
block|}
end_function

begin_comment
comment|/* Fill structure ix86_frame about frame of currently computed function.  */
end_comment

begin_function
specifier|static
name|void
name|ix86_compute_frame_layout
parameter_list|(
name|struct
name|ix86_frame
modifier|*
name|frame
parameter_list|)
block|{
name|HOST_WIDE_INT
name|total_size
decl_stmt|;
name|int
name|stack_alignment_needed
init|=
name|cfun
operator|->
name|stack_alignment_needed
operator|/
name|BITS_PER_UNIT
decl_stmt|;
name|HOST_WIDE_INT
name|offset
decl_stmt|;
name|int
name|preferred_alignment
init|=
name|cfun
operator|->
name|preferred_stack_boundary
operator|/
name|BITS_PER_UNIT
decl_stmt|;
name|HOST_WIDE_INT
name|size
init|=
name|get_frame_size
argument_list|()
decl_stmt|;
name|frame
operator|->
name|nregs
operator|=
name|ix86_nsaved_regs
argument_list|()
expr_stmt|;
name|total_size
operator|=
name|size
expr_stmt|;
comment|/* During reload iteration the amount of registers saved can change.      Recompute the value as needed.  Do not recompute when amount of registers      didn't change as reload does mutiple calls to the function and does not      expect the decision to change within single iteration.  */
if|if
condition|(
operator|!
name|optimize_size
operator|&&
name|cfun
operator|->
name|machine
operator|->
name|use_fast_prologue_epilogue_nregs
operator|!=
name|frame
operator|->
name|nregs
condition|)
block|{
name|int
name|count
init|=
name|frame
operator|->
name|nregs
decl_stmt|;
name|cfun
operator|->
name|machine
operator|->
name|use_fast_prologue_epilogue_nregs
operator|=
name|count
expr_stmt|;
comment|/* The fast prologue uses move instead of push to save registers.  This          is significantly longer, but also executes faster as modern hardware          can execute the moves in parallel, but can't do that for push/pop.  	 Be careful about choosing what prologue to emit:  When function takes 	 many instructions to execute we may use slow version as well as in 	 case function is known to be outside hot spot (this is known with 	 feedback only).  Weight the size of function by number of registers 	 to save as it is cheap to use one or two push instructions but very 	 slow to use many of them.  */
if|if
condition|(
name|count
condition|)
name|count
operator|=
operator|(
name|count
operator|-
literal|1
operator|)
operator|*
name|FAST_PROLOGUE_INSN_COUNT
expr_stmt|;
if|if
condition|(
name|cfun
operator|->
name|function_frequency
operator|<
name|FUNCTION_FREQUENCY_NORMAL
operator|||
operator|(
name|flag_branch_probabilities
operator|&&
name|cfun
operator|->
name|function_frequency
operator|<
name|FUNCTION_FREQUENCY_HOT
operator|)
condition|)
name|cfun
operator|->
name|machine
operator|->
name|use_fast_prologue_epilogue
operator|=
name|false
expr_stmt|;
else|else
name|cfun
operator|->
name|machine
operator|->
name|use_fast_prologue_epilogue
operator|=
operator|!
name|expensive_function_p
argument_list|(
name|count
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_PROLOGUE_USING_MOVE
operator|&&
name|cfun
operator|->
name|machine
operator|->
name|use_fast_prologue_epilogue
condition|)
name|frame
operator|->
name|save_regs_using_mov
operator|=
name|true
expr_stmt|;
else|else
name|frame
operator|->
name|save_regs_using_mov
operator|=
name|false
expr_stmt|;
comment|/* Skip return address and saved base pointer.  */
name|offset
operator|=
name|frame_pointer_needed
condition|?
name|UNITS_PER_WORD
operator|*
literal|2
else|:
name|UNITS_PER_WORD
expr_stmt|;
name|frame
operator|->
name|hard_frame_pointer_offset
operator|=
name|offset
expr_stmt|;
comment|/* Do some sanity checking of stack_alignment_needed and      preferred_alignment, since i386 port is the only using those features      that may break easily.  */
if|if
condition|(
name|size
operator|&&
operator|!
name|stack_alignment_needed
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|preferred_alignment
operator|<
name|STACK_BOUNDARY
operator|/
name|BITS_PER_UNIT
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|preferred_alignment
operator|>
name|PREFERRED_STACK_BOUNDARY
operator|/
name|BITS_PER_UNIT
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|stack_alignment_needed
operator|>
name|PREFERRED_STACK_BOUNDARY
operator|/
name|BITS_PER_UNIT
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|stack_alignment_needed
operator|<
name|STACK_BOUNDARY
operator|/
name|BITS_PER_UNIT
condition|)
name|stack_alignment_needed
operator|=
name|STACK_BOUNDARY
operator|/
name|BITS_PER_UNIT
expr_stmt|;
comment|/* Register save area */
name|offset
operator|+=
name|frame
operator|->
name|nregs
operator|*
name|UNITS_PER_WORD
expr_stmt|;
comment|/* Va-arg area */
if|if
condition|(
name|ix86_save_varrargs_registers
condition|)
block|{
name|offset
operator|+=
name|X86_64_VARARGS_SIZE
expr_stmt|;
name|frame
operator|->
name|va_arg_size
operator|=
name|X86_64_VARARGS_SIZE
expr_stmt|;
block|}
else|else
name|frame
operator|->
name|va_arg_size
operator|=
literal|0
expr_stmt|;
comment|/* Align start of frame for local function.  */
name|frame
operator|->
name|padding1
operator|=
operator|(
operator|(
name|offset
operator|+
name|stack_alignment_needed
operator|-
literal|1
operator|)
operator|&
operator|-
name|stack_alignment_needed
operator|)
operator|-
name|offset
expr_stmt|;
name|offset
operator|+=
name|frame
operator|->
name|padding1
expr_stmt|;
comment|/* Frame pointer points here.  */
name|frame
operator|->
name|frame_pointer_offset
operator|=
name|offset
expr_stmt|;
name|offset
operator|+=
name|size
expr_stmt|;
comment|/* Add outgoing arguments area.  Can be skipped if we eliminated      all the function calls as dead code.      Skipping is however impossible when function calls alloca.  Alloca      expander assumes that last current_function_outgoing_args_size      of stack frame are unused.  */
if|if
condition|(
name|ACCUMULATE_OUTGOING_ARGS
operator|&&
operator|(
operator|!
name|current_function_is_leaf
operator|||
name|current_function_calls_alloca
operator|)
condition|)
block|{
name|offset
operator|+=
name|current_function_outgoing_args_size
expr_stmt|;
name|frame
operator|->
name|outgoing_arguments_size
operator|=
name|current_function_outgoing_args_size
expr_stmt|;
block|}
else|else
name|frame
operator|->
name|outgoing_arguments_size
operator|=
literal|0
expr_stmt|;
comment|/* Align stack boundary.  Only needed if we're calling another function      or using alloca.  */
if|if
condition|(
operator|!
name|current_function_is_leaf
operator|||
name|current_function_calls_alloca
condition|)
name|frame
operator|->
name|padding2
operator|=
operator|(
operator|(
name|offset
operator|+
name|preferred_alignment
operator|-
literal|1
operator|)
operator|&
operator|-
name|preferred_alignment
operator|)
operator|-
name|offset
expr_stmt|;
else|else
name|frame
operator|->
name|padding2
operator|=
literal|0
expr_stmt|;
name|offset
operator|+=
name|frame
operator|->
name|padding2
expr_stmt|;
comment|/* We've reached end of stack frame.  */
name|frame
operator|->
name|stack_pointer_offset
operator|=
name|offset
expr_stmt|;
comment|/* Size prologue needs to allocate.  */
name|frame
operator|->
name|to_allocate
operator|=
operator|(
name|size
operator|+
name|frame
operator|->
name|padding1
operator|+
name|frame
operator|->
name|padding2
operator|+
name|frame
operator|->
name|outgoing_arguments_size
operator|+
name|frame
operator|->
name|va_arg_size
operator|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|frame
operator|->
name|to_allocate
operator|&&
name|frame
operator|->
name|nregs
operator|<=
literal|1
operator|)
operator|||
operator|(
name|TARGET_64BIT
operator|&&
name|frame
operator|->
name|to_allocate
operator|>=
operator|(
name|HOST_WIDE_INT
operator|)
literal|0x80000000
operator|)
condition|)
name|frame
operator|->
name|save_regs_using_mov
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|TARGET_RED_ZONE
operator|&&
name|current_function_sp_is_unchanging
operator|&&
name|current_function_is_leaf
condition|)
block|{
name|frame
operator|->
name|red_zone_size
operator|=
name|frame
operator|->
name|to_allocate
expr_stmt|;
if|if
condition|(
name|frame
operator|->
name|save_regs_using_mov
condition|)
name|frame
operator|->
name|red_zone_size
operator|+=
name|frame
operator|->
name|nregs
operator|*
name|UNITS_PER_WORD
expr_stmt|;
if|if
condition|(
name|frame
operator|->
name|red_zone_size
operator|>
name|RED_ZONE_SIZE
operator|-
name|RED_ZONE_RESERVE
condition|)
name|frame
operator|->
name|red_zone_size
operator|=
name|RED_ZONE_SIZE
operator|-
name|RED_ZONE_RESERVE
expr_stmt|;
block|}
else|else
name|frame
operator|->
name|red_zone_size
operator|=
literal|0
expr_stmt|;
name|frame
operator|->
name|to_allocate
operator|-=
name|frame
operator|->
name|red_zone_size
expr_stmt|;
name|frame
operator|->
name|stack_pointer_offset
operator|-=
name|frame
operator|->
name|red_zone_size
expr_stmt|;
if|#
directive|if
literal|0
block|fprintf (stderr, "nregs: %i\n", frame->nregs);   fprintf (stderr, "size: %i\n", size);   fprintf (stderr, "alignment1: %i\n", stack_alignment_needed);   fprintf (stderr, "padding1: %i\n", frame->padding1);   fprintf (stderr, "va_arg: %i\n", frame->va_arg_size);   fprintf (stderr, "padding2: %i\n", frame->padding2);   fprintf (stderr, "to_allocate: %i\n", frame->to_allocate);   fprintf (stderr, "red_zone_size: %i\n", frame->red_zone_size);   fprintf (stderr, "frame_pointer_offset: %i\n", frame->frame_pointer_offset);   fprintf (stderr, "hard_frame_pointer_offset: %i\n", 	   frame->hard_frame_pointer_offset);   fprintf (stderr, "stack_pointer_offset: %i\n", frame->stack_pointer_offset);
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Emit code to save registers in the prologue.  */
end_comment

begin_function
specifier|static
name|void
name|ix86_emit_save_regs
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|regno
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|regno
operator|=
name|FIRST_PSEUDO_REGISTER
operator|-
literal|1
init|;
name|regno
operator|>=
literal|0
condition|;
name|regno
operator|--
control|)
if|if
condition|(
name|ix86_save_reg
argument_list|(
name|regno
argument_list|,
name|true
argument_list|)
condition|)
block|{
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_push
argument_list|(
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|regno
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Emit code to save registers using MOV insns.  First register    is restored from POINTER + OFFSET.  */
end_comment

begin_function
specifier|static
name|void
name|ix86_emit_save_regs_using_mov
parameter_list|(
name|rtx
name|pointer
parameter_list|,
name|HOST_WIDE_INT
name|offset
parameter_list|)
block|{
name|int
name|regno
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|ix86_save_reg
argument_list|(
name|regno
argument_list|,
name|true
argument_list|)
condition|)
block|{
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|adjust_address
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|pointer
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|offset
argument_list|)
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|regno
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|offset
operator|+=
name|UNITS_PER_WORD
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Expand prologue or epilogue stack adjustment.    The pattern exist to put a dependency on all ebp-based memory accesses.    STYLE should be negative if instructions should be marked as frame related,    zero if %r11 register is live and cannot be freely used and positive    otherwise.  */
end_comment

begin_function
specifier|static
name|void
name|pro_epilogue_adjust_stack
parameter_list|(
name|rtx
name|dest
parameter_list|,
name|rtx
name|src
parameter_list|,
name|rtx
name|offset
parameter_list|,
name|int
name|style
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
operator|!
name|TARGET_64BIT
condition|)
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_pro_epilogue_adjust_stack_1
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|x86_64_immediate_operand
argument_list|(
name|offset
argument_list|,
name|DImode
argument_list|)
condition|)
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_pro_epilogue_adjust_stack_rex64
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|rtx
name|r11
decl_stmt|;
comment|/* r11 is used by indirect sibcall return as well, set before the 	 epilogue and used after the epilogue.  ATM indirect sibcall 	 shouldn't be used together with huge frame sizes in one 	 function because of the frame_size check in sibcall.c.  */
if|if
condition|(
name|style
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|r11
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|FIRST_REX_INT_REG
operator|+
literal|3
comment|/* R11 */
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|DImode
argument_list|,
name|r11
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|style
operator|<
literal|0
condition|)
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_pro_epilogue_adjust_stack_rex64_2
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|r11
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|style
operator|<
literal|0
condition|)
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Expand the prologue into a bunch of separate insns.  */
end_comment

begin_function
name|void
name|ix86_expand_prologue
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
name|bool
name|pic_reg_used
decl_stmt|;
name|struct
name|ix86_frame
name|frame
decl_stmt|;
name|HOST_WIDE_INT
name|allocate
decl_stmt|;
name|ix86_compute_frame_layout
argument_list|(
operator|&
name|frame
argument_list|)
expr_stmt|;
comment|/* Note: AT&T enter does NOT have reversed args.  Enter is probably      slower on all targets.  Also sdb doesn't like it.  */
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_push
argument_list|(
name|hard_frame_pointer_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|allocate
operator|=
name|frame
operator|.
name|to_allocate
expr_stmt|;
if|if
condition|(
operator|!
name|frame
operator|.
name|save_regs_using_mov
condition|)
name|ix86_emit_save_regs
argument_list|()
expr_stmt|;
else|else
name|allocate
operator|+=
name|frame
operator|.
name|nregs
operator|*
name|UNITS_PER_WORD
expr_stmt|;
comment|/* When using red zone we may start register saving before allocating      the stack frame saving one cycle of the prologue.  */
if|if
condition|(
name|TARGET_RED_ZONE
operator|&&
name|frame
operator|.
name|save_regs_using_mov
condition|)
name|ix86_emit_save_regs_using_mov
argument_list|(
name|frame_pointer_needed
condition|?
name|hard_frame_pointer_rtx
else|:
name|stack_pointer_rtx
argument_list|,
operator|-
name|frame
operator|.
name|nregs
operator|*
name|UNITS_PER_WORD
argument_list|)
expr_stmt|;
if|if
condition|(
name|allocate
operator|==
literal|0
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|TARGET_STACK_PROBE
operator|||
name|allocate
operator|<
name|CHECK_STACK_LIMIT
condition|)
name|pro_epilogue_adjust_stack
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
operator|-
name|allocate
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Only valid for Win32.  */
name|rtx
name|eax
init|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|bool
name|eax_live
init|=
name|ix86_eax_live_at_start_p
argument_list|()
decl_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|eax_live
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_push
argument_list|(
name|eax
argument_list|)
argument_list|)
expr_stmt|;
name|allocate
operator|-=
literal|4
expr_stmt|;
block|}
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|eax
argument_list|,
name|GEN_INT
argument_list|(
name|allocate
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_allocate_stack_worker
argument_list|(
name|eax
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|eax_live
condition|)
block|{
name|rtx
name|t
init|=
name|plus_constant
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|allocate
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|eax
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|frame
operator|.
name|save_regs_using_mov
operator|&&
operator|!
name|TARGET_RED_ZONE
condition|)
block|{
if|if
condition|(
operator|!
name|frame_pointer_needed
operator|||
operator|!
name|frame
operator|.
name|to_allocate
condition|)
name|ix86_emit_save_regs_using_mov
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|frame
operator|.
name|to_allocate
argument_list|)
expr_stmt|;
else|else
name|ix86_emit_save_regs_using_mov
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
operator|-
name|frame
operator|.
name|nregs
operator|*
name|UNITS_PER_WORD
argument_list|)
expr_stmt|;
block|}
name|pic_reg_used
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|pic_offset_table_rtx
operator|&&
operator|(
name|regs_ever_live
index|[
name|REAL_PIC_OFFSET_TABLE_REGNUM
index|]
operator|||
name|current_function_profile
operator|)
condition|)
block|{
name|unsigned
name|int
name|alt_pic_reg_used
init|=
name|ix86_select_alt_pic_regnum
argument_list|()
decl_stmt|;
if|if
condition|(
name|alt_pic_reg_used
operator|!=
name|INVALID_REGNUM
condition|)
name|REGNO
argument_list|(
name|pic_offset_table_rtx
argument_list|)
operator|=
name|alt_pic_reg_used
expr_stmt|;
name|pic_reg_used
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|pic_reg_used
condition|)
block|{
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_set_got
argument_list|(
name|pic_offset_table_rtx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Even with accurate pre-reload life analysis, we can wind up 	 deleting all references to the pic register after reload. 	 Consider if cross-jumping unifies two sides of a branch 	 controlled by a comparison vs the only read from a global. 	 In which case, allow the set_got to be deleted, though we're 	 too late to do anything about the ebx save in the prologue.  */
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_MAYBE_DEAD
argument_list|,
name|const0_rtx
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* Prevent function calls from be scheduled before the call to mcount.      In the pic_reg_used case, make sure that the got load isn't deleted.  */
if|if
condition|(
name|current_function_profile
condition|)
name|emit_insn
argument_list|(
name|gen_blockage
argument_list|(
name|pic_reg_used
condition|?
name|pic_offset_table_rtx
else|:
name|const0_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit code to restore saved registers using MOV insns.  First register    is restored from POINTER + OFFSET.  */
end_comment

begin_function
specifier|static
name|void
name|ix86_emit_restore_regs_using_mov
parameter_list|(
name|rtx
name|pointer
parameter_list|,
name|HOST_WIDE_INT
name|offset
parameter_list|,
name|int
name|maybe_eh_return
parameter_list|)
block|{
name|int
name|regno
decl_stmt|;
name|rtx
name|base_address
init|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|pointer
argument_list|)
decl_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|ix86_save_reg
argument_list|(
name|regno
argument_list|,
name|maybe_eh_return
argument_list|)
condition|)
block|{
comment|/* Ensure that adjust_address won't be forced to produce pointer 	   out of range allowed by x86-64 instruction set.  */
if|if
condition|(
name|TARGET_64BIT
operator|&&
name|offset
operator|!=
name|trunc_int_for_mode
argument_list|(
name|offset
argument_list|,
name|SImode
argument_list|)
condition|)
block|{
name|rtx
name|r11
decl_stmt|;
name|r11
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|FIRST_REX_INT_REG
operator|+
literal|3
comment|/* R11 */
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|r11
argument_list|,
name|GEN_INT
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|r11
argument_list|,
name|r11
argument_list|,
name|pointer
argument_list|)
argument_list|)
expr_stmt|;
name|base_address
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|r11
argument_list|)
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
block|}
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|regno
argument_list|)
argument_list|,
name|adjust_address
argument_list|(
name|base_address
argument_list|,
name|Pmode
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|UNITS_PER_WORD
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Restore function stack, frame, and registers.  */
end_comment

begin_function
name|void
name|ix86_expand_epilogue
parameter_list|(
name|int
name|style
parameter_list|)
block|{
name|int
name|regno
decl_stmt|;
name|int
name|sp_valid
init|=
operator|!
name|frame_pointer_needed
operator|||
name|current_function_sp_is_unchanging
decl_stmt|;
name|struct
name|ix86_frame
name|frame
decl_stmt|;
name|HOST_WIDE_INT
name|offset
decl_stmt|;
name|ix86_compute_frame_layout
argument_list|(
operator|&
name|frame
argument_list|)
expr_stmt|;
comment|/* Calculate start of saved registers relative to ebp.  Special care      must be taken for the normal return case of a function using      eh_return: the eax and edx registers are marked as saved, but not      restored along this path.  */
name|offset
operator|=
name|frame
operator|.
name|nregs
expr_stmt|;
if|if
condition|(
name|current_function_calls_eh_return
operator|&&
name|style
operator|!=
literal|2
condition|)
name|offset
operator|-=
literal|2
expr_stmt|;
name|offset
operator|*=
operator|-
name|UNITS_PER_WORD
expr_stmt|;
comment|/* If we're only restoring one register and sp is not valid then      using a move instruction to restore the register since it's      less work than reloading sp and popping the register.       The default code result in stack adjustment using add/lea instruction,      while this code results in LEAVE instruction (or discrete equivalent),      so it is profitable in some other cases as well.  Especially when there      are no registers to restore.  We also use this code when TARGET_USE_LEAVE      and there is exactly one register to pop. This heuristic may need some      tuning in future.  */
if|if
condition|(
operator|(
operator|!
name|sp_valid
operator|&&
name|frame
operator|.
name|nregs
operator|<=
literal|1
operator|)
operator|||
operator|(
name|TARGET_EPILOGUE_USING_MOVE
operator|&&
name|cfun
operator|->
name|machine
operator|->
name|use_fast_prologue_epilogue
operator|&&
operator|(
name|frame
operator|.
name|nregs
operator|>
literal|1
operator|||
name|frame
operator|.
name|to_allocate
operator|)
operator|)
operator|||
operator|(
name|frame_pointer_needed
operator|&&
operator|!
name|frame
operator|.
name|nregs
operator|&&
name|frame
operator|.
name|to_allocate
operator|)
operator|||
operator|(
name|frame_pointer_needed
operator|&&
name|TARGET_USE_LEAVE
operator|&&
name|cfun
operator|->
name|machine
operator|->
name|use_fast_prologue_epilogue
operator|&&
name|frame
operator|.
name|nregs
operator|==
literal|1
operator|)
operator|||
name|current_function_calls_eh_return
condition|)
block|{
comment|/* Restore registers.  We can use ebp or esp to address the memory 	 locations.  If both are available, default to ebp, since offsets 	 are known to be small.  Only exception is esp pointing directly to the 	 end of block of saved registers, where we may simplify addressing 	 mode.  */
if|if
condition|(
operator|!
name|frame_pointer_needed
operator|||
operator|(
name|sp_valid
operator|&&
operator|!
name|frame
operator|.
name|to_allocate
operator|)
condition|)
name|ix86_emit_restore_regs_using_mov
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|frame
operator|.
name|to_allocate
argument_list|,
name|style
operator|==
literal|2
argument_list|)
expr_stmt|;
else|else
name|ix86_emit_restore_regs_using_mov
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
name|offset
argument_list|,
name|style
operator|==
literal|2
argument_list|)
expr_stmt|;
comment|/* eh_return epilogues need %ecx added to the stack pointer.  */
if|if
condition|(
name|style
operator|==
literal|2
condition|)
block|{
name|rtx
name|tmp
decl_stmt|,
name|sa
init|=
name|EH_RETURN_STACKADJ_RTX
decl_stmt|;
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
name|tmp
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|hard_frame_pointer_rtx
argument_list|,
name|sa
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|plus_constant
argument_list|(
name|tmp
argument_list|,
name|UNITS_PER_WORD
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|sa
argument_list|,
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|hard_frame_pointer_rtx
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|pro_epilogue_adjust_stack
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|sa
argument_list|,
name|const0_rtx
argument_list|,
name|style
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tmp
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|sa
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|plus_constant
argument_list|(
name|tmp
argument_list|,
operator|(
name|frame
operator|.
name|to_allocate
operator|+
name|frame
operator|.
name|nregs
operator|*
name|UNITS_PER_WORD
operator|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|frame_pointer_needed
condition|)
name|pro_epilogue_adjust_stack
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|frame
operator|.
name|to_allocate
operator|+
name|frame
operator|.
name|nregs
operator|*
name|UNITS_PER_WORD
argument_list|)
argument_list|,
name|style
argument_list|)
expr_stmt|;
comment|/* If not an i386, mov& pop is faster than "leave".  */
elseif|else
if|if
condition|(
name|TARGET_USE_LEAVE
operator|||
name|optimize_size
operator|||
operator|!
name|cfun
operator|->
name|machine
operator|->
name|use_fast_prologue_epilogue
condition|)
name|emit_insn
argument_list|(
name|TARGET_64BIT
condition|?
name|gen_leave_rex64
argument_list|()
else|:
name|gen_leave
argument_list|()
argument_list|)
expr_stmt|;
else|else
block|{
name|pro_epilogue_adjust_stack
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|hard_frame_pointer_rtx
argument_list|,
name|const0_rtx
argument_list|,
name|style
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
name|emit_insn
argument_list|(
name|gen_popdi1
argument_list|(
name|hard_frame_pointer_rtx
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_popsi1
argument_list|(
name|hard_frame_pointer_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* First step is to deallocate the stack frame so that we can 	 pop the registers.  */
if|if
condition|(
operator|!
name|sp_valid
condition|)
block|{
if|if
condition|(
operator|!
name|frame_pointer_needed
condition|)
name|abort
argument_list|()
expr_stmt|;
name|pro_epilogue_adjust_stack
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|hard_frame_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|offset
argument_list|)
argument_list|,
name|style
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|frame
operator|.
name|to_allocate
condition|)
name|pro_epilogue_adjust_stack
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|frame
operator|.
name|to_allocate
argument_list|)
argument_list|,
name|style
argument_list|)
expr_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|ix86_save_reg
argument_list|(
name|regno
argument_list|,
name|false
argument_list|)
condition|)
block|{
if|if
condition|(
name|TARGET_64BIT
condition|)
name|emit_insn
argument_list|(
name|gen_popdi1
argument_list|(
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|regno
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_popsi1
argument_list|(
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|regno
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
comment|/* Leave results in shorter dependency chains on CPUs that are 	     able to grok it fast.  */
if|if
condition|(
name|TARGET_USE_LEAVE
condition|)
name|emit_insn
argument_list|(
name|TARGET_64BIT
condition|?
name|gen_leave_rex64
argument_list|()
else|:
name|gen_leave
argument_list|()
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TARGET_64BIT
condition|)
name|emit_insn
argument_list|(
name|gen_popdi1
argument_list|(
name|hard_frame_pointer_rtx
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_popsi1
argument_list|(
name|hard_frame_pointer_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Sibcall epilogues don't want a return instruction.  */
if|if
condition|(
name|style
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|current_function_pops_args
operator|&&
name|current_function_args_size
condition|)
block|{
name|rtx
name|popc
init|=
name|GEN_INT
argument_list|(
name|current_function_pops_args
argument_list|)
decl_stmt|;
comment|/* i386 can only pop 64K bytes.  If asked to pop more, pop 	 return address, do explicit add, and jump indirectly to the 	 caller.  */
if|if
condition|(
name|current_function_pops_args
operator|>=
literal|65536
condition|)
block|{
name|rtx
name|ecx
init|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
literal|2
argument_list|)
decl_stmt|;
comment|/* There is no "pascal" calling convention in 64bit ABI.  */
if|if
condition|(
name|TARGET_64BIT
condition|)
name|abort
argument_list|()
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_popsi1
argument_list|(
name|ecx
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|popc
argument_list|)
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_return_indirect_internal
argument_list|(
name|ecx
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|emit_jump_insn
argument_list|(
name|gen_return_pop_internal
argument_list|(
name|popc
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|emit_jump_insn
argument_list|(
name|gen_return_internal
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Reset from the function's potential modifications.  */
end_comment

begin_function
specifier|static
name|void
name|ix86_output_function_epilogue
parameter_list|(
name|FILE
modifier|*
name|file
name|ATTRIBUTE_UNUSED
parameter_list|,
name|HOST_WIDE_INT
name|size
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|pic_offset_table_rtx
condition|)
name|REGNO
argument_list|(
name|pic_offset_table_rtx
argument_list|)
operator|=
name|REAL_PIC_OFFSET_TABLE_REGNUM
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Extract the parts of an RTL expression that is a valid memory address    for an instruction.  Return 0 if the structure of the address is    grossly off.  Return -1 if the address contains ASHIFT, so it is not    strictly valid, but still used for computing length of lea instruction.  */
end_comment

begin_function
specifier|static
name|int
name|ix86_decompose_address
parameter_list|(
name|rtx
name|addr
parameter_list|,
name|struct
name|ix86_address
modifier|*
name|out
parameter_list|)
block|{
name|rtx
name|base
init|=
name|NULL_RTX
decl_stmt|;
name|rtx
name|index
init|=
name|NULL_RTX
decl_stmt|;
name|rtx
name|disp
init|=
name|NULL_RTX
decl_stmt|;
name|HOST_WIDE_INT
name|scale
init|=
literal|1
decl_stmt|;
name|rtx
name|scale_rtx
init|=
name|NULL_RTX
decl_stmt|;
name|int
name|retval
init|=
literal|1
decl_stmt|;
name|enum
name|ix86_address_seg
name|seg
init|=
name|SEG_DEFAULT
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|SUBREG
condition|)
name|base
operator|=
name|addr
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|rtx
name|addends
index|[
literal|4
index|]
decl_stmt|,
name|op
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
name|op
operator|=
name|addr
expr_stmt|;
do|do
block|{
if|if
condition|(
name|n
operator|>=
literal|4
condition|)
return|return
literal|0
return|;
name|addends
index|[
name|n
operator|++
index|]
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|PLUS
condition|)
do|;
if|if
condition|(
name|n
operator|>=
literal|4
condition|)
return|return
literal|0
return|;
name|addends
index|[
name|n
index|]
operator|=
name|op
expr_stmt|;
for|for
control|(
name|i
operator|=
name|n
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|op
operator|=
name|addends
index|[
name|i
index|]
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|MULT
case|:
if|if
condition|(
name|index
condition|)
return|return
literal|0
return|;
name|index
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|scale_rtx
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSPEC
case|:
if|if
condition|(
name|XINT
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPEC_TP
operator|&&
name|TARGET_TLS_DIRECT_SEG_REFS
operator|&&
name|seg
operator|==
name|SEG_DEFAULT
condition|)
name|seg
operator|=
name|TARGET_64BIT
condition|?
name|SEG_FS
else|:
name|SEG_GS
expr_stmt|;
else|else
return|return
literal|0
return|;
break|break;
case|case
name|REG
case|:
case|case
name|SUBREG
case|:
if|if
condition|(
operator|!
name|base
condition|)
name|base
operator|=
name|op
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|index
condition|)
name|index
operator|=
name|op
expr_stmt|;
else|else
return|return
literal|0
return|;
break|break;
case|case
name|CONST
case|:
case|case
name|CONST_INT
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
if|if
condition|(
name|disp
condition|)
return|return
literal|0
return|;
name|disp
operator|=
name|op
expr_stmt|;
break|break;
default|default:
return|return
literal|0
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|MULT
condition|)
block|{
name|index
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* index*scale */
name|scale_rtx
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|ASHIFT
condition|)
block|{
name|rtx
name|tmp
decl_stmt|;
comment|/* We're called for lea too, which implements ashift on occasion.  */
name|index
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
literal|0
return|;
name|scale
operator|=
name|INTVAL
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|scale
operator|>
literal|3
condition|)
return|return
literal|0
return|;
name|scale
operator|=
literal|1
operator|<<
name|scale
expr_stmt|;
name|retval
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|disp
operator|=
name|addr
expr_stmt|;
comment|/* displacement */
comment|/* Extract the integral value of scale.  */
if|if
condition|(
name|scale_rtx
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|scale_rtx
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
literal|0
return|;
name|scale
operator|=
name|INTVAL
argument_list|(
name|scale_rtx
argument_list|)
expr_stmt|;
block|}
comment|/* Allow arg pointer and stack pointer as index if there is not scaling.  */
if|if
condition|(
name|base
operator|&&
name|index
operator|&&
name|scale
operator|==
literal|1
operator|&&
operator|(
name|index
operator|==
name|arg_pointer_rtx
operator|||
name|index
operator|==
name|frame_pointer_rtx
operator|||
operator|(
name|REG_P
argument_list|(
name|index
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|index
argument_list|)
operator|==
name|STACK_POINTER_REGNUM
operator|)
operator|)
condition|)
block|{
name|rtx
name|tmp
init|=
name|base
decl_stmt|;
name|base
operator|=
name|index
expr_stmt|;
name|index
operator|=
name|tmp
expr_stmt|;
block|}
comment|/* Special case: %ebp cannot be encoded as a base without a displacement.  */
if|if
condition|(
operator|(
name|base
operator|==
name|hard_frame_pointer_rtx
operator|||
name|base
operator|==
name|frame_pointer_rtx
operator|||
name|base
operator|==
name|arg_pointer_rtx
operator|)
operator|&&
operator|!
name|disp
condition|)
name|disp
operator|=
name|const0_rtx
expr_stmt|;
comment|/* Special case: on K6, [%esi] makes the instruction vector decoded.      Avoid this by transforming to [%esi+0].  */
if|if
condition|(
name|ix86_tune
operator|==
name|PROCESSOR_K6
operator|&&
operator|!
name|optimize_size
operator|&&
name|base
operator|&&
operator|!
name|index
operator|&&
operator|!
name|disp
operator|&&
name|REG_P
argument_list|(
name|base
argument_list|)
operator|&&
name|REGNO_REG_CLASS
argument_list|(
name|REGNO
argument_list|(
name|base
argument_list|)
argument_list|)
operator|==
name|SIREG
condition|)
name|disp
operator|=
name|const0_rtx
expr_stmt|;
comment|/* Special case: encode reg+reg instead of reg*2.  */
if|if
condition|(
operator|!
name|base
operator|&&
name|index
operator|&&
name|scale
operator|&&
name|scale
operator|==
literal|2
condition|)
name|base
operator|=
name|index
operator|,
name|scale
operator|=
literal|1
expr_stmt|;
comment|/* Special case: scaling cannot be encoded without base or displacement.  */
if|if
condition|(
operator|!
name|base
operator|&&
operator|!
name|disp
operator|&&
name|index
operator|&&
name|scale
operator|!=
literal|1
condition|)
name|disp
operator|=
name|const0_rtx
expr_stmt|;
name|out
operator|->
name|base
operator|=
name|base
expr_stmt|;
name|out
operator|->
name|index
operator|=
name|index
expr_stmt|;
name|out
operator|->
name|disp
operator|=
name|disp
expr_stmt|;
name|out
operator|->
name|scale
operator|=
name|scale
expr_stmt|;
name|out
operator|->
name|seg
operator|=
name|seg
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return cost of the memory address x.    For i386, it is better to use a complex address than let gcc copy    the address into a reg and make a new pseudo.  But not if the address    requires to two regs - that would mean more pseudos with longer    lifetimes.  */
end_comment

begin_function
specifier|static
name|int
name|ix86_address_cost
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|struct
name|ix86_address
name|parts
decl_stmt|;
name|int
name|cost
init|=
literal|1
decl_stmt|;
if|if
condition|(
operator|!
name|ix86_decompose_address
argument_list|(
name|x
argument_list|,
operator|&
name|parts
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* More complex memory references are better.  */
if|if
condition|(
name|parts
operator|.
name|disp
operator|&&
name|parts
operator|.
name|disp
operator|!=
name|const0_rtx
condition|)
name|cost
operator|--
expr_stmt|;
if|if
condition|(
name|parts
operator|.
name|seg
operator|!=
name|SEG_DEFAULT
condition|)
name|cost
operator|--
expr_stmt|;
comment|/* Attempt to minimize number of registers in the address.  */
if|if
condition|(
operator|(
name|parts
operator|.
name|base
operator|&&
operator|(
operator|!
name|REG_P
argument_list|(
name|parts
operator|.
name|base
argument_list|)
operator|||
name|REGNO
argument_list|(
name|parts
operator|.
name|base
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|)
operator|||
operator|(
name|parts
operator|.
name|index
operator|&&
operator|(
operator|!
name|REG_P
argument_list|(
name|parts
operator|.
name|index
argument_list|)
operator|||
name|REGNO
argument_list|(
name|parts
operator|.
name|index
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|)
condition|)
name|cost
operator|++
expr_stmt|;
if|if
condition|(
name|parts
operator|.
name|base
operator|&&
operator|(
operator|!
name|REG_P
argument_list|(
name|parts
operator|.
name|base
argument_list|)
operator|||
name|REGNO
argument_list|(
name|parts
operator|.
name|base
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|&&
name|parts
operator|.
name|index
operator|&&
operator|(
operator|!
name|REG_P
argument_list|(
name|parts
operator|.
name|index
argument_list|)
operator|||
name|REGNO
argument_list|(
name|parts
operator|.
name|index
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|&&
name|parts
operator|.
name|base
operator|!=
name|parts
operator|.
name|index
condition|)
name|cost
operator|++
expr_stmt|;
comment|/* AMD-K6 don't like addresses with ModR/M set to 00_xxx_100b,      since it's predecode logic can't detect the length of instructions      and it degenerates to vector decoded.  Increase cost of such      addresses here.  The penalty is minimally 2 cycles.  It may be worthwhile      to split such addresses or even refuse such addresses at all.       Following addressing modes are affected:       [base+scale*index]       [scale*index+disp]       [base+index]       The first and last case  may be avoidable by explicitly coding the zero in      memory address, but I don't have AMD-K6 machine handy to check this      theory.  */
if|if
condition|(
name|TARGET_K6
operator|&&
operator|(
operator|(
operator|!
name|parts
operator|.
name|disp
operator|&&
name|parts
operator|.
name|base
operator|&&
name|parts
operator|.
name|index
operator|&&
name|parts
operator|.
name|scale
operator|!=
literal|1
operator|)
operator|||
operator|(
name|parts
operator|.
name|disp
operator|&&
operator|!
name|parts
operator|.
name|base
operator|&&
name|parts
operator|.
name|index
operator|&&
name|parts
operator|.
name|scale
operator|!=
literal|1
operator|)
operator|||
operator|(
operator|!
name|parts
operator|.
name|disp
operator|&&
name|parts
operator|.
name|base
operator|&&
name|parts
operator|.
name|index
operator|&&
name|parts
operator|.
name|scale
operator|==
literal|1
operator|)
operator|)
condition|)
name|cost
operator|+=
literal|10
expr_stmt|;
return|return
name|cost
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If X is a machine specific address (i.e. a symbol or label being    referenced as a displacement from the GOT implemented using an    UNSPEC), then return the base term.  Otherwise return X.  */
end_comment

begin_function
name|rtx
name|ix86_find_base_term
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|rtx
name|term
decl_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST
condition|)
return|return
name|x
return|;
name|term
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|term
argument_list|)
operator|==
name|PLUS
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|term
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|term
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_DOUBLE
operator|)
condition|)
name|term
operator|=
name|XEXP
argument_list|(
name|term
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|term
argument_list|)
operator|!=
name|UNSPEC
operator|||
name|XINT
argument_list|(
name|term
argument_list|,
literal|1
argument_list|)
operator|!=
name|UNSPEC_GOTPCREL
condition|)
return|return
name|x
return|;
name|term
operator|=
name|XVECEXP
argument_list|(
name|term
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|term
argument_list|)
operator|!=
name|SYMBOL_REF
operator|&&
name|GET_CODE
argument_list|(
name|term
argument_list|)
operator|!=
name|LABEL_REF
condition|)
return|return
name|x
return|;
return|return
name|term
return|;
block|}
name|term
operator|=
name|ix86_delegitimize_address
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|term
argument_list|)
operator|!=
name|SYMBOL_REF
operator|&&
name|GET_CODE
argument_list|(
name|term
argument_list|)
operator|!=
name|LABEL_REF
condition|)
return|return
name|x
return|;
return|return
name|term
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Determine if a given RTX is a valid constant.  We already know this    satisfies CONSTANT_P.  */
end_comment

begin_function
name|bool
name|legitimate_constant_p
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|rtx
name|inner
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|SYMBOL_REF
case|:
comment|/* TLS symbols are not constant.  */
if|if
condition|(
name|tls_symbolic_operand
argument_list|(
name|x
argument_list|,
name|Pmode
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
case|case
name|CONST
case|:
name|inner
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Offsets of TLS symbols are never valid. 	 Discourage CSE from creating them.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|PLUS
operator|&&
name|tls_symbolic_operand
argument_list|(
name|XEXP
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|MINUS
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|inner
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
name|false
return|;
name|inner
operator|=
name|XEXP
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Only some unspecs are valid as "constants".  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|UNSPEC
condition|)
switch|switch
condition|(
name|XINT
argument_list|(
name|inner
argument_list|,
literal|1
argument_list|)
condition|)
block|{
case|case
name|UNSPEC_TPOFF
case|:
case|case
name|UNSPEC_NTPOFF
case|:
return|return
name|local_exec_symbolic_operand
argument_list|(
name|XVECEXP
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|)
return|;
case|case
name|UNSPEC_DTPOFF
case|:
return|return
name|local_dynamic_symbolic_operand
argument_list|(
name|XVECEXP
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|)
return|;
default|default:
return|return
name|false
return|;
block|}
break|break;
default|default:
break|break;
block|}
comment|/* Otherwise we handle everything else in the move patterns.  */
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Determine if it's legal to put X into the constant pool.  This    is not possible for the address of thread-local symbols, which    is checked above.  */
end_comment

begin_function
specifier|static
name|bool
name|ix86_cannot_force_const_mem
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
return|return
operator|!
name|legitimate_constant_p
argument_list|(
name|x
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Determine if a given RTX is a valid constant address.  */
end_comment

begin_function
name|bool
name|constant_address_p
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
return|return
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
operator|&&
name|legitimate_address_p
argument_list|(
name|Pmode
argument_list|,
name|x
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Nonzero if the constant value X is a legitimate general operand    when generating PIC code.  It is given that flag_pic is on and    that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */
end_comment

begin_function
name|bool
name|legitimate_pic_operand_p
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|rtx
name|inner
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|CONST
case|:
name|inner
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Only some unspecs are valid as "constants".  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|UNSPEC
condition|)
switch|switch
condition|(
name|XINT
argument_list|(
name|inner
argument_list|,
literal|1
argument_list|)
condition|)
block|{
case|case
name|UNSPEC_TPOFF
case|:
return|return
name|local_exec_symbolic_operand
argument_list|(
name|XVECEXP
argument_list|(
name|inner
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|)
return|;
default|default:
return|return
name|false
return|;
block|}
comment|/* FALLTHRU */
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
return|return
name|legitimate_pic_address_disp_p
argument_list|(
name|x
argument_list|)
return|;
default|default:
return|return
name|true
return|;
block|}
block|}
end_function

begin_comment
comment|/* Determine if a given CONST RTX is a valid memory displacement    in PIC mode.  */
end_comment

begin_function
name|int
name|legitimate_pic_address_disp_p
parameter_list|(
name|rtx
name|disp
parameter_list|)
block|{
name|bool
name|saw_plus
decl_stmt|;
comment|/* In 64bit mode we can allow direct addresses of symbols and labels      when they are not dynamic symbols.  */
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
comment|/* TLS references should always be enclosed in UNSPEC.  */
if|if
condition|(
name|tls_symbolic_operand
argument_list|(
name|disp
argument_list|,
name|GET_MODE
argument_list|(
name|disp
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|ix86_cmodel
operator|==
name|CM_SMALL_PIC
operator|&&
name|SYMBOL_REF_LOCAL_P
argument_list|(
name|disp
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|==
name|LABEL_REF
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|rtx
name|op0
init|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* TLS references should always be enclosed in UNSPEC.  */
if|if
condition|(
name|tls_symbolic_operand
argument_list|(
name|op0
argument_list|,
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|ix86_cmodel
operator|==
name|CM_SMALL_PIC
operator|&&
name|SYMBOL_REF_LOCAL_P
argument_list|(
name|op0
argument_list|)
operator|)
operator|||
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|LABEL_REF
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|<
literal|16
operator|*
literal|1024
operator|*
literal|1024
operator|&&
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|>=
operator|-
literal|16
operator|*
literal|1024
operator|*
literal|1024
condition|)
return|return
literal|1
return|;
block|}
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|!=
name|CONST
condition|)
return|return
literal|0
return|;
name|disp
operator|=
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
comment|/* We are unsafe to allow PLUS expressions.  This limit allowed distance          of GOT tables.  We should not need these anyway.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|!=
name|UNSPEC
operator|||
name|XINT
argument_list|(
name|disp
argument_list|,
literal|1
argument_list|)
operator|!=
name|UNSPEC_GOTPCREL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|SYMBOL_REF
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|LABEL_REF
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
name|saw_plus
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|==
name|PLUS
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
literal|0
return|;
name|disp
operator|=
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|saw_plus
operator|=
name|true
expr_stmt|;
block|}
comment|/* Allow {LABEL | SYMBOL}_REF - SYMBOL_REF-FOR-PICBASE for Mach-O.  */
if|if
condition|(
name|TARGET_MACHO
operator|&&
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|==
name|MINUS
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
block|{
specifier|const
name|char
modifier|*
name|sym_name
init|=
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|sym_name
argument_list|,
literal|"<pic base>"
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|!=
name|UNSPEC
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|XINT
argument_list|(
name|disp
argument_list|,
literal|1
argument_list|)
condition|)
block|{
case|case
name|UNSPEC_GOT
case|:
if|if
condition|(
name|saw_plus
condition|)
return|return
name|false
return|;
return|return
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
return|;
case|case
name|UNSPEC_GOTOFF
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
condition|)
return|return
name|local_symbolic_operand
argument_list|(
name|XVECEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|)
return|;
return|return
name|false
return|;
case|case
name|UNSPEC_GOTTPOFF
case|:
case|case
name|UNSPEC_GOTNTPOFF
case|:
case|case
name|UNSPEC_INDNTPOFF
case|:
if|if
condition|(
name|saw_plus
condition|)
return|return
name|false
return|;
return|return
name|initial_exec_symbolic_operand
argument_list|(
name|XVECEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|)
return|;
case|case
name|UNSPEC_NTPOFF
case|:
return|return
name|local_exec_symbolic_operand
argument_list|(
name|XVECEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|)
return|;
case|case
name|UNSPEC_DTPOFF
case|:
return|return
name|local_dynamic_symbolic_operand
argument_list|(
name|XVECEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression that is a valid    memory address for an instruction.  The MODE argument is the machine mode    for the MEM expression that wants to use this address.     It only recognizes address in canonical form.  LEGITIMIZE_ADDRESS should    convert common non-canonical forms to canonical form so that they will    be recognized.  */
end_comment

begin_function
name|int
name|legitimate_address_p
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|addr
parameter_list|,
name|int
name|strict
parameter_list|)
block|{
name|struct
name|ix86_address
name|parts
decl_stmt|;
name|rtx
name|base
decl_stmt|,
name|index
decl_stmt|,
name|disp
decl_stmt|;
name|HOST_WIDE_INT
name|scale
decl_stmt|;
specifier|const
name|char
modifier|*
name|reason
init|=
name|NULL
decl_stmt|;
name|rtx
name|reason_rtx
init|=
name|NULL_RTX
decl_stmt|;
if|if
condition|(
name|TARGET_DEBUG_ADDR
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n======\nGO_IF_LEGITIMATE_ADDRESS, mode = %s, strict = %d\n"
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|mode
argument_list|)
argument_list|,
name|strict
argument_list|)
expr_stmt|;
name|debug_rtx
argument_list|(
name|addr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ix86_decompose_address
argument_list|(
name|addr
argument_list|,
operator|&
name|parts
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|reason
operator|=
literal|"decomposition failed"
expr_stmt|;
goto|goto
name|report_error
goto|;
block|}
name|base
operator|=
name|parts
operator|.
name|base
expr_stmt|;
name|index
operator|=
name|parts
operator|.
name|index
expr_stmt|;
name|disp
operator|=
name|parts
operator|.
name|disp
expr_stmt|;
name|scale
operator|=
name|parts
operator|.
name|scale
expr_stmt|;
comment|/* Validate base register.       Don't allow SUBREG's here, it can lead to spill failures when the base      is one word out of a two word structure, which is represented internally      as a DImode int.  */
if|if
condition|(
name|base
condition|)
block|{
name|reason_rtx
operator|=
name|base
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|!=
name|REG
condition|)
block|{
name|reason
operator|=
literal|"base is not a register"
expr_stmt|;
goto|goto
name|report_error
goto|;
block|}
if|if
condition|(
name|GET_MODE
argument_list|(
name|base
argument_list|)
operator|!=
name|Pmode
condition|)
block|{
name|reason
operator|=
literal|"base is not in Pmode"
expr_stmt|;
goto|goto
name|report_error
goto|;
block|}
if|if
condition|(
operator|(
name|strict
operator|&&
operator|!
name|REG_OK_FOR_BASE_STRICT_P
argument_list|(
name|base
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|strict
operator|&&
operator|!
name|REG_OK_FOR_BASE_NONSTRICT_P
argument_list|(
name|base
argument_list|)
operator|)
condition|)
block|{
name|reason
operator|=
literal|"base is not valid"
expr_stmt|;
goto|goto
name|report_error
goto|;
block|}
block|}
comment|/* Validate index register.       Don't allow SUBREG's here, it can lead to spill failures when the index      is one word out of a two word structure, which is represented internally      as a DImode int.  */
if|if
condition|(
name|index
condition|)
block|{
name|reason_rtx
operator|=
name|index
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|index
argument_list|)
operator|!=
name|REG
condition|)
block|{
name|reason
operator|=
literal|"index is not a register"
expr_stmt|;
goto|goto
name|report_error
goto|;
block|}
if|if
condition|(
name|GET_MODE
argument_list|(
name|index
argument_list|)
operator|!=
name|Pmode
condition|)
block|{
name|reason
operator|=
literal|"index is not in Pmode"
expr_stmt|;
goto|goto
name|report_error
goto|;
block|}
if|if
condition|(
operator|(
name|strict
operator|&&
operator|!
name|REG_OK_FOR_INDEX_STRICT_P
argument_list|(
name|index
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|strict
operator|&&
operator|!
name|REG_OK_FOR_INDEX_NONSTRICT_P
argument_list|(
name|index
argument_list|)
operator|)
condition|)
block|{
name|reason
operator|=
literal|"index is not valid"
expr_stmt|;
goto|goto
name|report_error
goto|;
block|}
block|}
comment|/* Validate scale factor.  */
if|if
condition|(
name|scale
operator|!=
literal|1
condition|)
block|{
name|reason_rtx
operator|=
name|GEN_INT
argument_list|(
name|scale
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|index
condition|)
block|{
name|reason
operator|=
literal|"scale without index"
expr_stmt|;
goto|goto
name|report_error
goto|;
block|}
if|if
condition|(
name|scale
operator|!=
literal|2
operator|&&
name|scale
operator|!=
literal|4
operator|&&
name|scale
operator|!=
literal|8
condition|)
block|{
name|reason
operator|=
literal|"scale is not a valid multiplier"
expr_stmt|;
goto|goto
name|report_error
goto|;
block|}
block|}
comment|/* Validate displacement.  */
if|if
condition|(
name|disp
condition|)
block|{
name|reason_rtx
operator|=
name|disp
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|UNSPEC
condition|)
switch|switch
condition|(
name|XINT
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
block|{
case|case
name|UNSPEC_GOT
case|:
case|case
name|UNSPEC_GOTOFF
case|:
case|case
name|UNSPEC_GOTPCREL
case|:
if|if
condition|(
operator|!
name|flag_pic
condition|)
name|abort
argument_list|()
expr_stmt|;
goto|goto
name|is_legitimate_pic
goto|;
case|case
name|UNSPEC_GOTTPOFF
case|:
case|case
name|UNSPEC_GOTNTPOFF
case|:
case|case
name|UNSPEC_INDNTPOFF
case|:
case|case
name|UNSPEC_NTPOFF
case|:
case|case
name|UNSPEC_DTPOFF
case|:
break|break;
default|default:
name|reason
operator|=
literal|"invalid address unspec"
expr_stmt|;
goto|goto
name|report_error
goto|;
block|}
elseif|else
if|if
condition|(
name|flag_pic
operator|&&
operator|(
name|SYMBOLIC_CONST
argument_list|(
name|disp
argument_list|)
if|#
directive|if
name|TARGET_MACHO
operator|&&
operator|!
name|machopic_operand_p
argument_list|(
name|disp
argument_list|)
endif|#
directive|endif
operator|)
condition|)
block|{
name|is_legitimate_pic
label|:
if|if
condition|(
name|TARGET_64BIT
operator|&&
operator|(
name|index
operator|||
name|base
operator|)
condition|)
block|{
comment|/* foo@dtpoff(%rX) is ok.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|!=
name|CONST
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|UNSPEC
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|||
operator|(
name|XINT
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|!=
name|UNSPEC_DTPOFF
operator|&&
name|XINT
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|!=
name|UNSPEC_NTPOFF
operator|)
condition|)
block|{
name|reason
operator|=
literal|"non-constant pic memory reference"
expr_stmt|;
goto|goto
name|report_error
goto|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|legitimate_pic_address_disp_p
argument_list|(
name|disp
argument_list|)
condition|)
block|{
name|reason
operator|=
literal|"displacement is an invalid pic construct"
expr_stmt|;
goto|goto
name|report_error
goto|;
block|}
comment|/* This code used to verify that a symbolic pic displacement 	     includes the pic_offset_table_rtx register.  	     While this is good idea, unfortunately these constructs may 	     be created by "adds using lea" optimization for incorrect 	     code like:  	     int a; 	     int foo(int i) 	       { 	         return *(&a+i); 	       }  	     This code is nonsensical, but results in addressing 	     GOT table with pic_offset_table_rtx base.  We can't 	     just refuse it easily, since it gets matched by 	     "addsi3" pattern, that later gets split to lea in the 	     case output register differs from input.  While this 	     can be handled by separate addsi pattern for this case 	     that never results in lea, this seems to be easier and 	     correct fix for crash to disable this test.  */
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|!=
name|LABEL_REF
operator|&&
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|!=
name|CONST_INT
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|!=
name|CONST
operator|||
operator|!
name|legitimate_constant_p
argument_list|(
name|disp
argument_list|)
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|!=
name|SYMBOL_REF
operator|||
operator|!
name|legitimate_constant_p
argument_list|(
name|disp
argument_list|)
operator|)
condition|)
block|{
name|reason
operator|=
literal|"displacement is not constant"
expr_stmt|;
goto|goto
name|report_error
goto|;
block|}
elseif|else
if|if
condition|(
name|TARGET_64BIT
operator|&&
operator|!
name|x86_64_sign_extended_value
argument_list|(
name|disp
argument_list|)
condition|)
block|{
name|reason
operator|=
literal|"displacement is out of range"
expr_stmt|;
goto|goto
name|report_error
goto|;
block|}
block|}
comment|/* Everything looks valid.  */
if|if
condition|(
name|TARGET_DEBUG_ADDR
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Success.\n"
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
name|report_error
label|:
if|if
condition|(
name|TARGET_DEBUG_ADDR
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: %s\n"
argument_list|,
name|reason
argument_list|)
expr_stmt|;
name|debug_rtx
argument_list|(
name|reason_rtx
argument_list|)
expr_stmt|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return an unique alias set for the GOT.  */
end_comment

begin_function
specifier|static
name|HOST_WIDE_INT
name|ix86_GOT_alias_set
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|HOST_WIDE_INT
name|set
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|set
operator|==
operator|-
literal|1
condition|)
name|set
operator|=
name|new_alias_set
argument_list|()
expr_stmt|;
return|return
name|set
return|;
block|}
end_function

begin_comment
comment|/* Return a legitimate reference for ORIG (an address) using the    register REG.  If REG is 0, a new pseudo is generated.     There are two types of references that must be handled:     1. Global data references must load the address from the GOT, via       the PIC reg.  An insn is emitted to do this load, and the reg is       returned.     2. Static data references, constant pool addresses, and code labels       compute the address as an offset from the GOT, whose base is in       the PIC reg.  Static data objects have SYMBOL_FLAG_LOCAL set to       differentiate them from global data objects.  The returned       address is the PIC reg + an unspec constant.     GO_IF_LEGITIMATE_ADDRESS rejects symbolic references unless the PIC    reg also appears in the address.  */
end_comment

begin_function
name|rtx
name|legitimize_pic_address
parameter_list|(
name|rtx
name|orig
parameter_list|,
name|rtx
name|reg
parameter_list|)
block|{
name|rtx
name|addr
init|=
name|orig
decl_stmt|;
name|rtx
name|new
init|=
name|orig
decl_stmt|;
name|rtx
name|base
decl_stmt|;
if|#
directive|if
name|TARGET_MACHO
if|if
condition|(
name|reg
operator|==
literal|0
condition|)
name|reg
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
comment|/* Use the generic Mach-O PIC machinery.  */
return|return
name|machopic_legitimize_pic_address
argument_list|(
name|orig
argument_list|,
name|GET_MODE
argument_list|(
name|orig
argument_list|)
argument_list|,
name|reg
argument_list|)
return|;
endif|#
directive|endif
if|if
condition|(
name|TARGET_64BIT
operator|&&
name|legitimate_pic_address_disp_p
argument_list|(
name|addr
argument_list|)
condition|)
name|new
operator|=
name|addr
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|TARGET_64BIT
operator|&&
name|local_symbolic_operand
argument_list|(
name|addr
argument_list|,
name|Pmode
argument_list|)
condition|)
block|{
comment|/* This symbol may be referenced via a displacement from the PIC 	 base address (@GOTOFF).  */
if|if
condition|(
name|reload_in_progress
condition|)
name|regs_ever_live
index|[
name|PIC_OFFSET_TABLE_REGNUM
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|CONST
condition|)
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|new
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|UNSPEC_GOTOFF
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|,
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|new
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|addr
argument_list|)
argument_list|,
name|UNSPEC_GOTOFF
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
literal|0
condition|)
block|{
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|reg
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
block|{
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
name|new
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|addr
argument_list|)
argument_list|,
name|UNSPEC_GOTPCREL
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|new
argument_list|)
operator|=
literal|1
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|new
argument_list|,
name|ix86_GOT_alias_set
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|==
literal|0
condition|)
name|reg
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
comment|/* Use directly gen_movsi, otherwise the address is loaded 	     into register for CSE.  We don't want to CSE this addresses, 	     instead we CSE addresses from the GOT table, so skip this.  */
name|emit_insn
argument_list|(
name|gen_movsi
argument_list|(
name|reg
argument_list|,
name|new
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|=
name|reg
expr_stmt|;
block|}
else|else
block|{
comment|/* This symbol must be referenced via a load from the 	     Global Offset Table (@GOT).  */
if|if
condition|(
name|reload_in_progress
condition|)
name|regs_ever_live
index|[
name|PIC_OFFSET_TABLE_REGNUM
index|]
operator|=
literal|1
expr_stmt|;
name|new
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|addr
argument_list|)
argument_list|,
name|UNSPEC_GOT
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|new
argument_list|)
operator|=
literal|1
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|new
argument_list|,
name|ix86_GOT_alias_set
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|==
literal|0
condition|)
name|reg
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|reg
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|CONST
condition|)
block|{
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* We must match stuff we generate before.  Assume the only 	     unspecs that can get here are ours.  Not that we could do 	     anything with them anyway....  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|UNSPEC
operator|||
operator|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|UNSPEC
operator|)
condition|)
return|return
name|orig
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|!=
name|PLUS
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|rtx
name|op0
init|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
decl_stmt|,
name|op1
init|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* Check first to see if this is a constant offset from a @GOTOFF 	     symbol reference.  */
if|if
condition|(
name|local_symbolic_operand
argument_list|(
name|op0
argument_list|,
name|Pmode
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
operator|!
name|TARGET_64BIT
condition|)
block|{
if|if
condition|(
name|reload_in_progress
condition|)
name|regs_ever_live
index|[
name|PIC_OFFSET_TABLE_REGNUM
index|]
operator|=
literal|1
expr_stmt|;
name|new
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|op0
argument_list|)
argument_list|,
name|UNSPEC_GOTOFF
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
literal|0
condition|)
block|{
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|new
operator|=
name|reg
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|<
operator|-
literal|16
operator|*
literal|1024
operator|*
literal|1024
operator|||
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|>=
literal|16
operator|*
literal|1024
operator|*
literal|1024
condition|)
name|new
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|op0
argument_list|,
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|base
operator|=
name|legitimize_pic_address
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|new
operator|=
name|legitimize_pic_address
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|,
name|base
operator|==
name|reg
condition|?
name|NULL_RTX
else|:
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|new
argument_list|)
operator|==
name|CONST_INT
condition|)
name|new
operator|=
name|plus_constant
argument_list|(
name|base
argument_list|,
name|INTVAL
argument_list|(
name|new
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|new
argument_list|)
operator|==
name|PLUS
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|new
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|base
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|base
argument_list|,
name|XEXP
argument_list|(
name|new
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|=
name|XEXP
argument_list|(
name|new
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|new
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|base
argument_list|,
name|new
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|new
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Load the thread pointer.  If TO_REG is true, force it into a register.  */
end_comment

begin_function
specifier|static
name|rtx
name|get_thread_pointer
parameter_list|(
name|int
name|to_reg
parameter_list|)
block|{
name|rtx
name|tp
decl_stmt|,
name|reg
decl_stmt|,
name|insn
decl_stmt|;
name|tp
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|const0_rtx
argument_list|)
argument_list|,
name|UNSPEC_TP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|to_reg
condition|)
return|return
name|tp
return|;
name|reg
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|insn
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|tp
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
return|return
name|reg
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of legitimize_address and ix86_expand_move.  FOR_MOV is    false if we expect this to be used for a memory address and true if    we expect to load the address into a register.  */
end_comment

begin_function
specifier|static
name|rtx
name|legitimize_tls_address
parameter_list|(
name|rtx
name|x
parameter_list|,
name|enum
name|tls_model
name|model
parameter_list|,
name|int
name|for_mov
parameter_list|)
block|{
name|rtx
name|dest
decl_stmt|,
name|base
decl_stmt|,
name|off
decl_stmt|,
name|pic
decl_stmt|;
name|int
name|type
decl_stmt|;
switch|switch
condition|(
name|model
condition|)
block|{
case|case
name|TLS_MODEL_GLOBAL_DYNAMIC
case|:
name|dest
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
name|rtx
name|rax
init|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|0
argument_list|)
decl_stmt|,
name|insns
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|emit_call_insn
argument_list|(
name|gen_tls_global_dynamic_64
argument_list|(
name|rax
argument_list|,
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_libcall_block
argument_list|(
name|insns
argument_list|,
name|dest
argument_list|,
name|rax
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
else|else
name|emit_insn
argument_list|(
name|gen_tls_global_dynamic_32
argument_list|(
name|dest
argument_list|,
name|x
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TLS_MODEL_LOCAL_DYNAMIC
case|:
name|base
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
name|rtx
name|rax
init|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|0
argument_list|)
decl_stmt|,
name|insns
decl_stmt|,
name|note
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|emit_call_insn
argument_list|(
name|gen_tls_local_dynamic_base_64
argument_list|(
name|rax
argument_list|)
argument_list|)
expr_stmt|;
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|note
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|const0_rtx
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|note
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|ix86_tls_get_addr
argument_list|()
argument_list|,
name|note
argument_list|)
expr_stmt|;
name|emit_libcall_block
argument_list|(
name|insns
argument_list|,
name|base
argument_list|,
name|rax
argument_list|,
name|note
argument_list|)
expr_stmt|;
block|}
else|else
name|emit_insn
argument_list|(
name|gen_tls_local_dynamic_base_32
argument_list|(
name|base
argument_list|)
argument_list|)
expr_stmt|;
name|off
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|x
argument_list|)
argument_list|,
name|UNSPEC_DTPOFF
argument_list|)
expr_stmt|;
name|off
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|off
argument_list|)
expr_stmt|;
return|return
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|base
argument_list|,
name|off
argument_list|)
return|;
case|case
name|TLS_MODEL_INITIAL_EXEC
case|:
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
name|pic
operator|=
name|NULL
expr_stmt|;
name|type
operator|=
name|UNSPEC_GOTNTPOFF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flag_pic
condition|)
block|{
if|if
condition|(
name|reload_in_progress
condition|)
name|regs_ever_live
index|[
name|PIC_OFFSET_TABLE_REGNUM
index|]
operator|=
literal|1
expr_stmt|;
name|pic
operator|=
name|pic_offset_table_rtx
expr_stmt|;
name|type
operator|=
name|TARGET_GNU_TLS
condition|?
name|UNSPEC_GOTNTPOFF
else|:
name|UNSPEC_GOTTPOFF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|TARGET_GNU_TLS
condition|)
block|{
name|pic
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_set_got
argument_list|(
name|pic
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|UNSPEC_GOTTPOFF
expr_stmt|;
block|}
else|else
block|{
name|pic
operator|=
name|NULL
expr_stmt|;
name|type
operator|=
name|UNSPEC_INDNTPOFF
expr_stmt|;
block|}
name|off
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|x
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|off
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|off
argument_list|)
expr_stmt|;
if|if
condition|(
name|pic
condition|)
name|off
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|pic
argument_list|,
name|off
argument_list|)
expr_stmt|;
name|off
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|off
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|off
argument_list|)
operator|=
literal|1
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|off
argument_list|,
name|ix86_GOT_alias_set
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
operator|||
name|TARGET_GNU_TLS
condition|)
block|{
name|base
operator|=
name|get_thread_pointer
argument_list|(
name|for_mov
operator|||
operator|!
name|TARGET_TLS_DIRECT_SEG_REFS
argument_list|)
expr_stmt|;
name|off
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|off
argument_list|)
expr_stmt|;
return|return
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|base
argument_list|,
name|off
argument_list|)
return|;
block|}
else|else
block|{
name|base
operator|=
name|get_thread_pointer
argument_list|(
name|true
argument_list|)
expr_stmt|;
name|dest
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_subsi3
argument_list|(
name|dest
argument_list|,
name|base
argument_list|,
name|off
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TLS_MODEL_LOCAL_EXEC
case|:
name|off
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|x
argument_list|)
argument_list|,
operator|(
name|TARGET_64BIT
operator|||
name|TARGET_GNU_TLS
operator|)
condition|?
name|UNSPEC_NTPOFF
else|:
name|UNSPEC_TPOFF
argument_list|)
expr_stmt|;
name|off
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|off
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
operator|||
name|TARGET_GNU_TLS
condition|)
block|{
name|base
operator|=
name|get_thread_pointer
argument_list|(
name|for_mov
operator|||
operator|!
name|TARGET_TLS_DIRECT_SEG_REFS
argument_list|)
expr_stmt|;
return|return
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|base
argument_list|,
name|off
argument_list|)
return|;
block|}
else|else
block|{
name|base
operator|=
name|get_thread_pointer
argument_list|(
name|true
argument_list|)
expr_stmt|;
name|dest
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_subsi3
argument_list|(
name|dest
argument_list|,
name|base
argument_list|,
name|off
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|dest
return|;
block|}
end_function

begin_comment
comment|/* Try machine-dependent ways of modifying an illegitimate address    to be legitimate.  If we find one, return the new, valid address.    This macro is used in only one place: `memory_address' in explow.c.     OLDX is the address as it was before break_out_memory_refs was called.    In some cases it is useful to look at this to decide what needs to be done.     MODE and WIN are passed so that this macro can use    GO_IF_LEGITIMATE_ADDRESS.     It is always safe for this macro to do nothing.  It exists to recognize    opportunities to optimize the output.     For the 80386, we handle X+REG by loading X into a register R and    using R+REG.  R will go in a general reg and indexing will be used.    However, if REG is a broken-out memory address or multiplication,    nothing needs to be done because REG can certainly go in a general reg.     When -fpic is used, special handling is needed for symbolic references.    See comments by legitimize_pic_address in i386.c for details.  */
end_comment

begin_function
name|rtx
name|legitimize_address
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|oldx
name|ATTRIBUTE_UNUSED
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|int
name|changed
init|=
literal|0
decl_stmt|;
name|unsigned
name|log
decl_stmt|;
if|if
condition|(
name|TARGET_DEBUG_ADDR
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n==========\nLEGITIMIZE_ADDRESS, mode = %s\n"
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
name|debug_rtx
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
name|log
operator|=
name|tls_symbolic_operand
argument_list|(
name|x
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|log
condition|)
return|return
name|legitimize_tls_address
argument_list|(
name|x
argument_list|,
name|log
argument_list|,
name|false
argument_list|)
return|;
if|if
condition|(
name|flag_pic
operator|&&
name|SYMBOLIC_CONST
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|legitimize_pic_address
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
return|;
comment|/* Canonicalize shifts by 0, 1, 2, 3 into multiply */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|ASHIFT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|log
operator|=
operator|(
name|unsigned
operator|)
name|exact_log2
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|<
literal|4
condition|)
block|{
name|changed
operator|=
literal|1
expr_stmt|;
name|x
operator|=
name|gen_rtx_MULT
argument_list|(
name|Pmode
argument_list|,
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
literal|1
operator|<<
name|log
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
condition|)
block|{
comment|/* Canonicalize shifts by 0, 1, 2, 3 into multiply.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ASHIFT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|log
operator|=
operator|(
name|unsigned
operator|)
name|exact_log2
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|<
literal|4
condition|)
block|{
name|changed
operator|=
literal|1
expr_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|gen_rtx_MULT
argument_list|(
name|Pmode
argument_list|,
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
literal|1
operator|<<
name|log
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|ASHIFT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|log
operator|=
operator|(
name|unsigned
operator|)
name|exact_log2
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|<
literal|4
condition|)
block|{
name|changed
operator|=
literal|1
expr_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|=
name|gen_rtx_MULT
argument_list|(
name|Pmode
argument_list|,
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
literal|1
operator|<<
name|log
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Put multiply first if it isn't already.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|MULT
condition|)
block|{
name|rtx
name|tmp
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|=
name|tmp
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Canonicalize (plus (mult (reg) (const)) (plus (reg) (const))) 	 into (plus (plus (mult (reg) (const)) (reg)) (const)).  This can be 	 created by virtual register instantiation, register elimination, and 	 similar optimizations.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MULT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|changed
operator|=
literal|1
expr_stmt|;
name|x
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Canonicalize 	 (plus (plus (mult (reg) (const)) (plus (reg) (const))) const) 	 into (plus (plus (mult (reg) (const)) (reg)) (const)).  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MULT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|constant
decl_stmt|;
name|rtx
name|other
init|=
name|NULL_RTX
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|constant
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|other
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|constant
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|other
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|constant
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|constant
condition|)
block|{
name|changed
operator|=
literal|1
expr_stmt|;
name|x
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|plus_constant
argument_list|(
name|other
argument_list|,
name|INTVAL
argument_list|(
name|constant
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|changed
operator|&&
name|legitimate_address_p
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
name|FALSE
argument_list|)
condition|)
return|return
name|x
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MULT
condition|)
block|{
name|changed
operator|=
literal|1
expr_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|MULT
condition|)
block|{
name|changed
operator|=
literal|1
expr_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|=
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|changed
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
return|return
name|x
return|;
if|if
condition|(
name|flag_pic
operator|&&
name|SYMBOLIC_CONST
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|changed
operator|=
literal|1
expr_stmt|;
name|x
operator|=
name|legitimize_pic_address
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|changed
operator|&&
name|legitimate_address_p
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
name|FALSE
argument_list|)
condition|)
return|return
name|x
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|rtx
name|temp
init|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
name|rtx
name|val
init|=
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|temp
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|!=
name|temp
condition|)
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|=
name|temp
expr_stmt|;
return|return
name|x
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|rtx
name|temp
init|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
name|rtx
name|val
init|=
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|temp
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|!=
name|temp
condition|)
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|temp
expr_stmt|;
return|return
name|x
return|;
block|}
block|}
return|return
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print an integer constant expression in assembler syntax.  Addition    and subtraction are the only arithmetic that may appear in these    expressions.  FILE is the stdio stream to write to, X is the rtx, and    CODE is the operand print code from the output string.  */
end_comment

begin_function
specifier|static
name|void
name|output_pic_addr_const
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|rtx
name|x
parameter_list|,
name|int
name|code
parameter_list|)
block|{
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|PC
case|:
if|if
condition|(
name|flag_pic
condition|)
name|putc
argument_list|(
literal|'.'
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
break|break;
case|case
name|SYMBOL_REF
case|:
name|assemble_name
argument_list|(
name|file
argument_list|,
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TARGET_MACHO
operator|&&
name|code
operator|==
literal|'P'
operator|&&
operator|!
name|SYMBOL_REF_LOCAL_P
argument_list|(
name|x
argument_list|)
condition|)
name|fputs
argument_list|(
literal|"@PLT"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|LABEL_REF
case|:
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* FALLTHRU */
case|case
name|CODE_LABEL
case|:
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|asm_out_file
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST_INT
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST
case|:
comment|/* This used to output parentheses around the expression, 	 but that does not work on the 386 (either ATT or BSD assembler).  */
name|output_pic_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|code
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST_DOUBLE
case|:
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|VOIDmode
condition|)
block|{
comment|/* We can use %d if the number is<32 bits and positive.  */
if|if
condition|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
operator|||
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0x%lx%08lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* We can't handle floating point constants; 	   PRINT_OPERAND must handle them.  */
name|output_operand_lossage
argument_list|(
literal|"floating constant misused"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PLUS
case|:
comment|/* Some assemblers need integer constants to appear first.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|output_pic_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'+'
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|output_pic_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|code
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|output_pic_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'+'
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|output_pic_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|code
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
break|break;
case|case
name|MINUS
case|:
if|if
condition|(
operator|!
name|TARGET_MACHO
condition|)
name|putc
argument_list|(
name|ASSEMBLER_DIALECT
operator|==
name|ASM_INTEL
condition|?
literal|'('
else|:
literal|'['
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|output_pic_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'-'
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|output_pic_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TARGET_MACHO
condition|)
name|putc
argument_list|(
name|ASSEMBLER_DIALECT
operator|==
name|ASM_INTEL
condition|?
literal|')'
else|:
literal|']'
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSPEC
case|:
if|if
condition|(
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|!=
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
name|output_pic_addr_const
argument_list|(
name|file
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|code
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|XINT
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|)
block|{
case|case
name|UNSPEC_GOT
case|:
name|fputs
argument_list|(
literal|"@GOT"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSPEC_GOTOFF
case|:
name|fputs
argument_list|(
literal|"@GOTOFF"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSPEC_GOTPCREL
case|:
name|fputs
argument_list|(
literal|"@GOTPCREL(%rip)"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSPEC_GOTTPOFF
case|:
comment|/* FIXME: This might be @TPOFF in Sun ld too.  */
name|fputs
argument_list|(
literal|"@GOTTPOFF"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSPEC_TPOFF
case|:
name|fputs
argument_list|(
literal|"@TPOFF"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSPEC_NTPOFF
case|:
if|if
condition|(
name|TARGET_64BIT
condition|)
name|fputs
argument_list|(
literal|"@TPOFF"
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
literal|"@NTPOFF"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSPEC_DTPOFF
case|:
name|fputs
argument_list|(
literal|"@DTPOFF"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSPEC_GOTNTPOFF
case|:
if|if
condition|(
name|TARGET_64BIT
condition|)
name|fputs
argument_list|(
literal|"@GOTTPOFF(%rip)"
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
literal|"@GOTNTPOFF"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSPEC_INDNTPOFF
case|:
name|fputs
argument_list|(
literal|"@INDNTPOFF"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
default|default:
name|output_operand_lossage
argument_list|(
literal|"invalid UNSPEC as operand"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|output_operand_lossage
argument_list|(
literal|"invalid expression as operand"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This is called from dwarfout.c via ASM_OUTPUT_DWARF_ADDR_CONST.    We need to handle our special PIC relocations.  */
end_comment

begin_function
name|void
name|i386_dwarf_output_addr_const
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|rtx
name|x
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ASM_QUAD
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|TARGET_64BIT
condition|?
name|ASM_QUAD
else|:
name|ASM_LONG
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|TARGET_64BIT
condition|)
name|abort
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|ASM_LONG
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|flag_pic
condition|)
name|output_pic_addr_const
argument_list|(
name|file
argument_list|,
name|x
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
else|else
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is called from dwarf2out.c via ASM_OUTPUT_DWARF_DTPREL.    We need to emit DTP-relative relocations.  */
end_comment

begin_function
name|void
name|i386_output_dwarf_dtprel
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|int
name|size
parameter_list|,
name|rtx
name|x
parameter_list|)
block|{
name|fputs
argument_list|(
name|ASM_LONG
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"@DTPOFF"
argument_list|,
name|file
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|4
case|:
break|break;
case|case
literal|8
case|:
name|fputs
argument_list|(
literal|", 0"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* In the name of slightly smaller debug output, and to cater to    general assembler losage, recognize PIC+GOTOFF and turn it back    into a direct symbol reference.  */
end_comment

begin_function
specifier|static
name|rtx
name|ix86_delegitimize_address
parameter_list|(
name|rtx
name|orig_x
parameter_list|)
block|{
name|rtx
name|x
init|=
name|orig_x
decl_stmt|,
name|y
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|UNSPEC
operator|||
name|XINT
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|!=
name|UNSPEC_GOTPCREL
operator|||
name|GET_CODE
argument_list|(
name|orig_x
argument_list|)
operator|!=
name|MEM
condition|)
return|return
name|orig_x
return|;
return|return
name|XVECEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST
condition|)
return|return
name|orig_x
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PIC_OFFSET_TABLE_REGNUM
condition|)
comment|/* %ebx + GOT/GOTOFF */
name|y
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|)
block|{
comment|/* %ebx + %reg * scale + GOT/GOTOFF */
name|y
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PIC_OFFSET_TABLE_REGNUM
condition|)
name|y
operator|=
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|PIC_OFFSET_TABLE_REGNUM
condition|)
name|y
operator|=
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
return|return
name|orig_x
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|!=
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|!=
name|MULT
operator|&&
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|!=
name|ASHIFT
condition|)
return|return
name|orig_x
return|;
block|}
else|else
return|return
name|orig_x
return|;
name|x
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|UNSPEC
operator|&&
operator|(
operator|(
name|XINT
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPEC_GOT
operator|&&
name|GET_CODE
argument_list|(
name|orig_x
argument_list|)
operator|==
name|MEM
operator|)
operator|||
operator|(
name|XINT
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPEC_GOTOFF
operator|&&
name|GET_CODE
argument_list|(
name|orig_x
argument_list|)
operator|!=
name|MEM
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|y
condition|)
return|return
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|y
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
return|return
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|UNSPEC
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
operator|(
name|XINT
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPEC_GOT
operator|&&
name|GET_CODE
argument_list|(
name|orig_x
argument_list|)
operator|==
name|MEM
operator|)
operator|||
operator|(
name|XINT
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPEC_GOTOFF
operator|&&
name|GET_CODE
argument_list|(
name|orig_x
argument_list|)
operator|!=
name|MEM
operator|)
operator|)
condition|)
block|{
name|x
operator|=
name|gen_rtx_PLUS
argument_list|(
name|VOIDmode
argument_list|,
name|XVECEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
condition|)
return|return
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
return|;
return|return
name|x
return|;
block|}
return|return
name|orig_x
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|put_condition_code
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|int
name|reverse
parameter_list|,
name|int
name|fp
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|suffix
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|CCFPmode
operator|||
name|mode
operator|==
name|CCFPUmode
condition|)
block|{
name|enum
name|rtx_code
name|second_code
decl_stmt|,
name|bypass_code
decl_stmt|;
name|ix86_fp_comparison_codes
argument_list|(
name|code
argument_list|,
operator|&
name|bypass_code
argument_list|,
operator|&
name|code
argument_list|,
operator|&
name|second_code
argument_list|)
expr_stmt|;
if|if
condition|(
name|bypass_code
operator|!=
name|NIL
operator|||
name|second_code
operator|!=
name|NIL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|code
operator|=
name|ix86_fp_compare_code_to_integer
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|mode
operator|=
name|CCmode
expr_stmt|;
block|}
if|if
condition|(
name|reverse
condition|)
name|code
operator|=
name|reverse_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EQ
case|:
name|suffix
operator|=
literal|"e"
expr_stmt|;
break|break;
case|case
name|NE
case|:
name|suffix
operator|=
literal|"ne"
expr_stmt|;
break|break;
case|case
name|GT
case|:
if|if
condition|(
name|mode
operator|!=
name|CCmode
operator|&&
name|mode
operator|!=
name|CCNOmode
operator|&&
name|mode
operator|!=
name|CCGCmode
condition|)
name|abort
argument_list|()
expr_stmt|;
name|suffix
operator|=
literal|"g"
expr_stmt|;
break|break;
case|case
name|GTU
case|:
comment|/* ??? Use "nbe" instead of "a" for fcmov losage on some assemblers. 	 Those same assemblers have the same but opposite losage on cmov.  */
if|if
condition|(
name|mode
operator|!=
name|CCmode
condition|)
name|abort
argument_list|()
expr_stmt|;
name|suffix
operator|=
name|fp
condition|?
literal|"nbe"
else|:
literal|"a"
expr_stmt|;
break|break;
case|case
name|LT
case|:
if|if
condition|(
name|mode
operator|==
name|CCNOmode
operator|||
name|mode
operator|==
name|CCGOCmode
condition|)
name|suffix
operator|=
literal|"s"
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|CCmode
operator|||
name|mode
operator|==
name|CCGCmode
condition|)
name|suffix
operator|=
literal|"l"
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
break|break;
case|case
name|LTU
case|:
if|if
condition|(
name|mode
operator|!=
name|CCmode
condition|)
name|abort
argument_list|()
expr_stmt|;
name|suffix
operator|=
literal|"b"
expr_stmt|;
break|break;
case|case
name|GE
case|:
if|if
condition|(
name|mode
operator|==
name|CCNOmode
operator|||
name|mode
operator|==
name|CCGOCmode
condition|)
name|suffix
operator|=
literal|"ns"
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|CCmode
operator|||
name|mode
operator|==
name|CCGCmode
condition|)
name|suffix
operator|=
literal|"ge"
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
break|break;
case|case
name|GEU
case|:
comment|/* ??? As above.  */
if|if
condition|(
name|mode
operator|!=
name|CCmode
condition|)
name|abort
argument_list|()
expr_stmt|;
name|suffix
operator|=
name|fp
condition|?
literal|"nb"
else|:
literal|"ae"
expr_stmt|;
break|break;
case|case
name|LE
case|:
if|if
condition|(
name|mode
operator|!=
name|CCmode
operator|&&
name|mode
operator|!=
name|CCGCmode
operator|&&
name|mode
operator|!=
name|CCNOmode
condition|)
name|abort
argument_list|()
expr_stmt|;
name|suffix
operator|=
literal|"le"
expr_stmt|;
break|break;
case|case
name|LEU
case|:
if|if
condition|(
name|mode
operator|!=
name|CCmode
condition|)
name|abort
argument_list|()
expr_stmt|;
name|suffix
operator|=
literal|"be"
expr_stmt|;
break|break;
case|case
name|UNORDERED
case|:
name|suffix
operator|=
name|fp
condition|?
literal|"u"
else|:
literal|"p"
expr_stmt|;
break|break;
case|case
name|ORDERED
case|:
name|suffix
operator|=
name|fp
condition|?
literal|"nu"
else|:
literal|"np"
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|fputs
argument_list|(
name|suffix
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print the name of register X to FILE based on its machine mode and number.    If CODE is 'w', pretend the mode is HImode.    If CODE is 'b', pretend the mode is QImode.    If CODE is 'k', pretend the mode is SImode.    If CODE is 'q', pretend the mode is DImode.    If CODE is 'h', pretend the reg is the `high' byte register.    If CODE is 'y', print "st(0)" instead of "st", if the reg is stack op.  */
end_comment

begin_function
name|void
name|print_reg
parameter_list|(
name|rtx
name|x
parameter_list|,
name|int
name|code
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|)
block|{
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|==
name|ARG_POINTER_REGNUM
operator|||
name|REGNO
argument_list|(
name|x
argument_list|)
operator|==
name|FRAME_POINTER_REGNUM
operator|||
name|REGNO
argument_list|(
name|x
argument_list|)
operator|==
name|FLAGS_REG
operator|||
name|REGNO
argument_list|(
name|x
argument_list|)
operator|==
name|FPSR_REG
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|ASSEMBLER_DIALECT
operator|==
name|ASM_ATT
operator|||
name|USER_LABEL_PREFIX
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|putc
argument_list|(
literal|'%'
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
literal|'w'
operator|||
name|MMX_REG_P
argument_list|(
name|x
argument_list|)
condition|)
name|code
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
literal|'b'
condition|)
name|code
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
literal|'k'
condition|)
name|code
operator|=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
literal|'q'
condition|)
name|code
operator|=
literal|8
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
literal|'y'
condition|)
name|code
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
literal|'h'
condition|)
name|code
operator|=
literal|0
expr_stmt|;
else|else
name|code
operator|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Irritatingly, AMD extended registers use different naming convention      from the normal registers.  */
if|if
condition|(
name|REX_INT_REG_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|TARGET_64BIT
condition|)
name|abort
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
literal|0
case|:
name|error
argument_list|(
literal|"extended registers have no high halves"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"r%ib"
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
operator|-
name|FIRST_REX_INT_REG
operator|+
literal|8
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"r%iw"
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
operator|-
name|FIRST_REX_INT_REG
operator|+
literal|8
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"r%id"
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
operator|-
name|FIRST_REX_INT_REG
operator|+
literal|8
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"r%i"
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
operator|-
name|FIRST_REX_INT_REG
operator|+
literal|8
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"unsupported operand size for extended register"
argument_list|)
expr_stmt|;
break|break;
block|}
return|return;
block|}
switch|switch
condition|(
name|code
condition|)
block|{
case|case
literal|3
case|:
if|if
condition|(
name|STACK_TOP_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|fputs
argument_list|(
literal|"st(0)"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* FALLTHRU */
case|case
literal|8
case|:
case|case
literal|4
case|:
case|case
literal|12
case|:
if|if
condition|(
operator|!
name|ANY_FP_REG_P
argument_list|(
name|x
argument_list|)
condition|)
name|putc
argument_list|(
name|code
operator|==
literal|8
operator|&&
name|TARGET_64BIT
condition|?
literal|'r'
else|:
literal|'e'
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* FALLTHRU */
case|case
literal|16
case|:
case|case
literal|2
case|:
name|normal
label|:
name|fputs
argument_list|(
name|hi_reg_name
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|>=
name|ARRAY_SIZE
argument_list|(
name|qi_reg_name
argument_list|)
condition|)
goto|goto
name|normal
goto|;
name|fputs
argument_list|(
name|qi_reg_name
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|>=
name|ARRAY_SIZE
argument_list|(
name|qi_high_reg_name
argument_list|)
condition|)
goto|goto
name|normal
goto|;
name|fputs
argument_list|(
name|qi_high_reg_name
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Locate some local-dynamic symbol still in use by this function    so that we can print its name in some tls_local_dynamic_base    pattern.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_some_local_dynamic_name
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
name|cfun
operator|->
name|machine
operator|->
name|some_ld_name
condition|)
return|return
name|cfun
operator|->
name|machine
operator|->
name|some_ld_name
return|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|for_each_rtx
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|get_some_local_dynamic_name_1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|cfun
operator|->
name|machine
operator|->
name|some_ld_name
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_some_local_dynamic_name_1
parameter_list|(
name|rtx
modifier|*
name|px
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|rtx
name|x
init|=
operator|*
name|px
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|local_dynamic_symbolic_operand
argument_list|(
name|x
argument_list|,
name|Pmode
argument_list|)
condition|)
block|{
name|cfun
operator|->
name|machine
operator|->
name|some_ld_name
operator|=
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Meaning of CODE:    L,W,B,Q,S,T -- print the opcode suffix for specified size of operand.    C -- print opcode suffix for set/cmov insn.    c -- like C, but print reversed condition    F,f -- likewise, but for floating-point.    O -- if HAVE_AS_IX86_CMOV_SUN_SYNTAX, expand to "w.", "l." or "q.",         otherwise nothing    R -- print the prefix for register names.    z -- print the opcode suffix for the size of the current operand.    * -- print a star (in certain assembler syntax)    A -- print an absolute memory reference.    w -- print the operand as if it's a "word" (HImode) even if it isn't.    s -- print a shift double count, followed by the assemblers argument 	delimiter.    b -- print the QImode name of the register for the indicated operand. 	%b0 would print %al if operands[0] is reg 0.    w --  likewise, print the HImode name of the register.    k --  likewise, print the SImode name of the register.    q --  likewise, print the DImode name of the register.    h -- print the QImode name for a "high" register, either ah, bh, ch or dh.    y -- print "st(0)" instead of "st" as a register.    D -- print condition for SSE cmp instruction.    P -- if PIC, print an @PLT suffix.    X -- don't print any sort of PIC '@' suffix for a symbol.& -- print some in-use local-dynamic symbol name.  */
end_comment

begin_function
name|void
name|print_operand
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|rtx
name|x
parameter_list|,
name|int
name|code
parameter_list|)
block|{
if|if
condition|(
name|code
condition|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
literal|'*'
case|:
if|if
condition|(
name|ASSEMBLER_DIALECT
operator|==
name|ASM_ATT
condition|)
name|putc
argument_list|(
literal|'*'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'&'
case|:
name|assemble_name
argument_list|(
name|file
argument_list|,
name|get_some_local_dynamic_name
argument_list|()
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'A'
case|:
if|if
condition|(
name|ASSEMBLER_DIALECT
operator|==
name|ASM_ATT
condition|)
name|putc
argument_list|(
literal|'*'
argument_list|,
name|file
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ASSEMBLER_DIALECT
operator|==
name|ASM_INTEL
condition|)
block|{
comment|/* Intel syntax. For absolute addresses, registers should not 		 be surrounded by braces.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
condition|)
block|{
name|putc
argument_list|(
literal|'['
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|PRINT_OPERAND
argument_list|(
name|file
argument_list|,
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|']'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
name|PRINT_OPERAND
argument_list|(
name|file
argument_list|,
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'L'
case|:
if|if
condition|(
name|ASSEMBLER_DIALECT
operator|==
name|ASM_ATT
condition|)
name|putc
argument_list|(
literal|'l'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'W'
case|:
if|if
condition|(
name|ASSEMBLER_DIALECT
operator|==
name|ASM_ATT
condition|)
name|putc
argument_list|(
literal|'w'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'B'
case|:
if|if
condition|(
name|ASSEMBLER_DIALECT
operator|==
name|ASM_ATT
condition|)
name|putc
argument_list|(
literal|'b'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'Q'
case|:
if|if
condition|(
name|ASSEMBLER_DIALECT
operator|==
name|ASM_ATT
condition|)
name|putc
argument_list|(
literal|'l'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'S'
case|:
if|if
condition|(
name|ASSEMBLER_DIALECT
operator|==
name|ASM_ATT
condition|)
name|putc
argument_list|(
literal|'s'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'T'
case|:
if|if
condition|(
name|ASSEMBLER_DIALECT
operator|==
name|ASM_ATT
condition|)
name|putc
argument_list|(
literal|'t'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'z'
case|:
comment|/* 387 opcodes don't get size suffixes if the operands are 	     registers.  */
if|if
condition|(
name|STACK_REG_P
argument_list|(
name|x
argument_list|)
condition|)
return|return;
comment|/* Likewise if using Intel opcodes.  */
if|if
condition|(
name|ASSEMBLER_DIALECT
operator|==
name|ASM_INTEL
condition|)
return|return;
comment|/* This is the size of op from size of operand.  */
switch|switch
condition|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
block|{
case|case
literal|2
case|:
ifdef|#
directive|ifdef
name|HAVE_GAS_FILDS_FISTS
name|putc
argument_list|(
literal|'s'
argument_list|,
name|file
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
case|case
literal|4
case|:
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|SFmode
condition|)
block|{
name|putc
argument_list|(
literal|'s'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|putc
argument_list|(
literal|'l'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|12
case|:
case|case
literal|16
case|:
name|putc
argument_list|(
literal|'t'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|8
case|:
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MODE_INT
condition|)
block|{
ifdef|#
directive|ifdef
name|GAS_MNEMONICS
name|putc
argument_list|(
literal|'q'
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|#
directive|else
name|putc
argument_list|(
literal|'l'
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'l'
argument_list|,
name|file
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|putc
argument_list|(
literal|'l'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
case|case
literal|'b'
case|:
case|case
literal|'w'
case|:
case|case
literal|'k'
case|:
case|case
literal|'q'
case|:
case|case
literal|'h'
case|:
case|case
literal|'y'
case|:
case|case
literal|'X'
case|:
case|case
literal|'P'
case|:
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
operator|||
operator|!
name|SHIFT_DOUBLE_OMITS_COUNT
condition|)
block|{
name|PRINT_OPERAND
argument_list|(
name|file
argument_list|,
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|','
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
literal|'D'
case|:
comment|/* Little bit of braindamage here.  The SSE compare instructions 	     does use completely different names for the comparisons that the 	     fp conditional moves.  */
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|EQ
case|:
case|case
name|UNEQ
case|:
name|fputs
argument_list|(
literal|"eq"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|LT
case|:
case|case
name|UNLT
case|:
name|fputs
argument_list|(
literal|"lt"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|LE
case|:
case|case
name|UNLE
case|:
name|fputs
argument_list|(
literal|"le"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNORDERED
case|:
name|fputs
argument_list|(
literal|"unord"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|NE
case|:
case|case
name|LTGT
case|:
name|fputs
argument_list|(
literal|"neq"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNGE
case|:
case|case
name|GE
case|:
name|fputs
argument_list|(
literal|"nlt"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNGT
case|:
case|case
name|GT
case|:
name|fputs
argument_list|(
literal|"nle"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|ORDERED
case|:
name|fputs
argument_list|(
literal|"ord"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
break|break;
block|}
return|return;
case|case
literal|'O'
case|:
ifdef|#
directive|ifdef
name|HAVE_AS_IX86_CMOV_SUN_SYNTAX
if|if
condition|(
name|ASSEMBLER_DIALECT
operator|==
name|ASM_ATT
condition|)
block|{
switch|switch
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|HImode
case|:
name|putc
argument_list|(
literal|'w'
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|SImode
case|:
case|case
name|SFmode
case|:
name|putc
argument_list|(
literal|'l'
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|DImode
case|:
case|case
name|DFmode
case|:
name|putc
argument_list|(
literal|'q'
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'.'
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return;
case|case
literal|'C'
case|:
name|put_condition_code
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'F'
case|:
ifdef|#
directive|ifdef
name|HAVE_AS_IX86_CMOV_SUN_SYNTAX
if|if
condition|(
name|ASSEMBLER_DIALECT
operator|==
name|ASM_ATT
condition|)
name|putc
argument_list|(
literal|'.'
argument_list|,
name|file
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|put_condition_code
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
comment|/* Like above, but reverse condition */
case|case
literal|'c'
case|:
comment|/* Check to see if argument to %c is really a constant 	     and not a condition code which needs to be reversed.  */
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
literal|'<'
condition|)
block|{
name|output_operand_lossage
argument_list|(
literal|"operand is neither a constant nor a condition code, invalid operand code 'c'"
argument_list|)
expr_stmt|;
return|return;
block|}
name|put_condition_code
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'f'
case|:
ifdef|#
directive|ifdef
name|HAVE_AS_IX86_CMOV_SUN_SYNTAX
if|if
condition|(
name|ASSEMBLER_DIALECT
operator|==
name|ASM_ATT
condition|)
name|putc
argument_list|(
literal|'.'
argument_list|,
name|file
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|put_condition_code
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'+'
case|:
block|{
name|rtx
name|x
decl_stmt|;
if|if
condition|(
operator|!
name|optimize
operator|||
name|optimize_size
operator|||
operator|!
name|TARGET_BRANCH_PREDICTION_HINTS
condition|)
return|return;
name|x
operator|=
name|find_reg_note
argument_list|(
name|current_output_insn
argument_list|,
name|REG_BR_PROB
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
condition|)
block|{
name|int
name|pred_val
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|pred_val
operator|<
name|REG_BR_PROB_BASE
operator|*
literal|45
operator|/
literal|100
operator|||
name|pred_val
operator|>
name|REG_BR_PROB_BASE
operator|*
literal|55
operator|/
literal|100
condition|)
block|{
name|int
name|taken
init|=
name|pred_val
operator|>
name|REG_BR_PROB_BASE
operator|/
literal|2
decl_stmt|;
name|int
name|cputaken
init|=
name|final_forward_branch_p
argument_list|(
name|current_output_insn
argument_list|)
operator|==
literal|0
decl_stmt|;
comment|/* Emit hints only in the case default branch prediction 		       heuristics would fail.  */
if|if
condition|(
name|taken
operator|!=
name|cputaken
condition|)
block|{
comment|/* We use 3e (DS) prefix for taken branches and 			   2e (CS) prefix for not taken branches.  */
if|if
condition|(
name|taken
condition|)
name|fputs
argument_list|(
literal|"ds ; "
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
literal|"cs ; "
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return;
block|}
default|default:
name|output_operand_lossage
argument_list|(
literal|"invalid operand code `%c'"
argument_list|,
name|code
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
name|print_reg
argument_list|(
name|x
argument_list|,
name|code
argument_list|,
name|file
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
block|{
comment|/* No `byte ptr' prefix for call instructions.  */
if|if
condition|(
name|ASSEMBLER_DIALECT
operator|==
name|ASM_INTEL
operator|&&
name|code
operator|!=
literal|'X'
operator|&&
name|code
operator|!=
literal|'P'
condition|)
block|{
specifier|const
name|char
modifier|*
name|size
decl_stmt|;
switch|switch
condition|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
name|size
operator|=
literal|"BYTE"
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|size
operator|=
literal|"WORD"
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|size
operator|=
literal|"DWORD"
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|size
operator|=
literal|"QWORD"
expr_stmt|;
break|break;
case|case
literal|12
case|:
name|size
operator|=
literal|"XWORD"
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|size
operator|=
literal|"XMMWORD"
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Check for explicit size override (codes 'b', 'w' and 'k')  */
if|if
condition|(
name|code
operator|==
literal|'b'
condition|)
name|size
operator|=
literal|"BYTE"
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
literal|'w'
condition|)
name|size
operator|=
literal|"WORD"
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
literal|'k'
condition|)
name|size
operator|=
literal|"DWORD"
expr_stmt|;
name|fputs
argument_list|(
name|size
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|" PTR "
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Avoid (%rip) for call operands.  */
if|if
condition|(
name|CONSTANT_ADDRESS_P
argument_list|(
name|x
argument_list|)
operator|&&
name|code
operator|==
literal|'P'
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|this_is_asm_operands
operator|&&
operator|!
name|address_operand
argument_list|(
name|x
argument_list|,
name|VOIDmode
argument_list|)
condition|)
name|output_operand_lossage
argument_list|(
literal|"invalid constraints for operand"
argument_list|)
expr_stmt|;
else|else
name|output_address
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|SFmode
condition|)
block|{
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|long
name|l
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|r
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|REAL_VALUE_TO_TARGET_SINGLE
argument_list|(
name|r
argument_list|,
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|ASSEMBLER_DIALECT
operator|==
name|ASM_ATT
condition|)
name|putc
argument_list|(
literal|'$'
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0x%08lx"
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
comment|/* These float cases don't actually occur as immediate operands.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|DFmode
condition|)
block|{
name|char
name|dstr
index|[
literal|30
index|]
decl_stmt|;
name|real_to_decimal
argument_list|(
name|dstr
argument_list|,
name|CONST_DOUBLE_REAL_VALUE
argument_list|(
name|x
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|dstr
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|dstr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|XFmode
condition|)
block|{
name|char
name|dstr
index|[
literal|30
index|]
decl_stmt|;
name|real_to_decimal
argument_list|(
name|dstr
argument_list|,
name|CONST_DOUBLE_REAL_VALUE
argument_list|(
name|x
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|dstr
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|dstr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|code
operator|!=
literal|'P'
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
if|if
condition|(
name|ASSEMBLER_DIALECT
operator|==
name|ASM_ATT
condition|)
name|putc
argument_list|(
literal|'$'
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LABEL_REF
condition|)
block|{
if|if
condition|(
name|ASSEMBLER_DIALECT
operator|==
name|ASM_ATT
condition|)
name|putc
argument_list|(
literal|'$'
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
literal|"OFFSET FLAT:"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|flag_pic
condition|)
name|output_pic_addr_const
argument_list|(
name|file
argument_list|,
name|x
argument_list|,
name|code
argument_list|)
expr_stmt|;
else|else
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print a memory operand whose address is ADDR.  */
end_comment

begin_function
name|void
name|print_operand_address
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|rtx
name|addr
parameter_list|)
block|{
name|struct
name|ix86_address
name|parts
decl_stmt|;
name|rtx
name|base
decl_stmt|,
name|index
decl_stmt|,
name|disp
decl_stmt|;
name|int
name|scale
decl_stmt|;
if|if
condition|(
operator|!
name|ix86_decompose_address
argument_list|(
name|addr
argument_list|,
operator|&
name|parts
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|base
operator|=
name|parts
operator|.
name|base
expr_stmt|;
name|index
operator|=
name|parts
operator|.
name|index
expr_stmt|;
name|disp
operator|=
name|parts
operator|.
name|disp
expr_stmt|;
name|scale
operator|=
name|parts
operator|.
name|scale
expr_stmt|;
switch|switch
condition|(
name|parts
operator|.
name|seg
condition|)
block|{
case|case
name|SEG_DEFAULT
case|:
break|break;
case|case
name|SEG_FS
case|:
case|case
name|SEG_GS
case|:
if|if
condition|(
name|USER_LABEL_PREFIX
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|putc
argument_list|(
literal|'%'
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
operator|(
name|parts
operator|.
name|seg
operator|==
name|SEG_FS
condition|?
literal|"fs:"
else|:
literal|"gs:"
operator|)
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|base
operator|&&
operator|!
name|index
condition|)
block|{
comment|/* Displacement only requires special attention.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|ASSEMBLER_DIALECT
operator|==
name|ASM_INTEL
operator|&&
name|parts
operator|.
name|seg
operator|==
name|SEG_DEFAULT
condition|)
block|{
if|if
condition|(
name|USER_LABEL_PREFIX
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|putc
argument_list|(
literal|'%'
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"ds:"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|INTVAL
argument_list|(
name|disp
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flag_pic
condition|)
name|output_pic_addr_const
argument_list|(
name|file
argument_list|,
name|disp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|disp
argument_list|)
expr_stmt|;
comment|/* Use one byte shorter RIP relative addressing for 64bit mode.  */
if|if
condition|(
name|TARGET_64BIT
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
operator|!
name|tls_symbolic_operand
argument_list|(
name|disp
argument_list|,
name|GET_MODE
argument_list|(
name|disp
argument_list|)
argument_list|)
operator|)
operator|||
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|==
name|LABEL_REF
operator|||
operator|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|)
operator|)
condition|)
name|fputs
argument_list|(
literal|"(%rip)"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ASSEMBLER_DIALECT
operator|==
name|ASM_ATT
condition|)
block|{
if|if
condition|(
name|disp
condition|)
block|{
if|if
condition|(
name|flag_pic
condition|)
name|output_pic_addr_const
argument_list|(
name|file
argument_list|,
name|disp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|==
name|LABEL_REF
condition|)
name|output_asm_label
argument_list|(
name|disp
argument_list|)
expr_stmt|;
else|else
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|disp
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'('
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
condition|)
name|print_reg
argument_list|(
name|base
argument_list|,
literal|0
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
condition|)
block|{
name|putc
argument_list|(
literal|','
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|print_reg
argument_list|(
name|index
argument_list|,
literal|0
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|scale
operator|!=
literal|1
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|",%d"
argument_list|,
name|scale
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|')'
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|offset
init|=
name|NULL_RTX
decl_stmt|;
if|if
condition|(
name|disp
condition|)
block|{
comment|/* Pull out the offset of a symbol; print any symbol itself.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|offset
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|disp
operator|=
name|gen_rtx_CONST
argument_list|(
name|VOIDmode
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|disp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_pic
condition|)
name|output_pic_addr_const
argument_list|(
name|file
argument_list|,
name|disp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|==
name|LABEL_REF
condition|)
name|output_asm_label
argument_list|(
name|disp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|==
name|CONST_INT
condition|)
name|offset
operator|=
name|disp
expr_stmt|;
else|else
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|disp
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'['
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
condition|)
block|{
name|print_reg
argument_list|(
name|base
argument_list|,
literal|0
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
condition|)
block|{
if|if
condition|(
name|INTVAL
argument_list|(
name|offset
argument_list|)
operator|>=
literal|0
condition|)
name|putc
argument_list|(
literal|'+'
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|INTVAL
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|offset
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|INTVAL
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|putc
argument_list|(
literal|'0'
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
condition|)
block|{
name|putc
argument_list|(
literal|'+'
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|print_reg
argument_list|(
name|index
argument_list|,
literal|0
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|scale
operator|!=
literal|1
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"*%d"
argument_list|,
name|scale
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|']'
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|bool
name|output_addr_const_extra
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|rtx
name|x
parameter_list|)
block|{
name|rtx
name|op
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|UNSPEC
condition|)
return|return
name|false
return|;
name|op
operator|=
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|XINT
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|)
block|{
case|case
name|UNSPEC_GOTTPOFF
case|:
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|op
argument_list|)
expr_stmt|;
comment|/* FIXME: This might be @TPOFF in Sun ld.  */
name|fputs
argument_list|(
literal|"@GOTTPOFF"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSPEC_TPOFF
case|:
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"@TPOFF"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSPEC_NTPOFF
case|:
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
name|fputs
argument_list|(
literal|"@TPOFF"
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
literal|"@NTPOFF"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSPEC_DTPOFF
case|:
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"@DTPOFF"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSPEC_GOTNTPOFF
case|:
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
name|fputs
argument_list|(
literal|"@GOTTPOFF(%rip)"
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
literal|"@GOTNTPOFF"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSPEC_INDNTPOFF
case|:
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"@INDNTPOFF"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Split one or more DImode RTL references into pairs of SImode    references.  The RTL can be REG, offsettable MEM, integer constant, or    CONST_DOUBLE.  "operands" is a pointer to an array of DImode RTL to    split and "num" is its length.  lo_half and hi_half are output arrays    that parallel "operands".  */
end_comment

begin_function
name|void
name|split_di
parameter_list|(
name|rtx
name|operands
index|[]
parameter_list|,
name|int
name|num
parameter_list|,
name|rtx
name|lo_half
index|[]
parameter_list|,
name|rtx
name|hi_half
index|[]
parameter_list|)
block|{
while|while
condition|(
name|num
operator|--
condition|)
block|{
name|rtx
name|op
init|=
name|operands
index|[
name|num
index|]
decl_stmt|;
comment|/* simplify_subreg refuse to split volatile memory addresses,          but we still have to handle it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|lo_half
index|[
name|num
index|]
operator|=
name|adjust_address
argument_list|(
name|op
argument_list|,
name|SImode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|hi_half
index|[
name|num
index|]
operator|=
name|adjust_address
argument_list|(
name|op
argument_list|,
name|SImode
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lo_half
index|[
name|num
index|]
operator|=
name|simplify_gen_subreg
argument_list|(
name|SImode
argument_list|,
name|op
argument_list|,
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
condition|?
name|DImode
else|:
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|hi_half
index|[
name|num
index|]
operator|=
name|simplify_gen_subreg
argument_list|(
name|SImode
argument_list|,
name|op
argument_list|,
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
condition|?
name|DImode
else|:
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Split one or more TImode RTL references into pairs of SImode    references.  The RTL can be REG, offsettable MEM, integer constant, or    CONST_DOUBLE.  "operands" is a pointer to an array of DImode RTL to    split and "num" is its length.  lo_half and hi_half are output arrays    that parallel "operands".  */
end_comment

begin_function
name|void
name|split_ti
parameter_list|(
name|rtx
name|operands
index|[]
parameter_list|,
name|int
name|num
parameter_list|,
name|rtx
name|lo_half
index|[]
parameter_list|,
name|rtx
name|hi_half
index|[]
parameter_list|)
block|{
while|while
condition|(
name|num
operator|--
condition|)
block|{
name|rtx
name|op
init|=
name|operands
index|[
name|num
index|]
decl_stmt|;
comment|/* simplify_subreg refuse to split volatile memory addresses, but we          still have to handle it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|lo_half
index|[
name|num
index|]
operator|=
name|adjust_address
argument_list|(
name|op
argument_list|,
name|DImode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|hi_half
index|[
name|num
index|]
operator|=
name|adjust_address
argument_list|(
name|op
argument_list|,
name|DImode
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lo_half
index|[
name|num
index|]
operator|=
name|simplify_gen_subreg
argument_list|(
name|DImode
argument_list|,
name|op
argument_list|,
name|TImode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|hi_half
index|[
name|num
index|]
operator|=
name|simplify_gen_subreg
argument_list|(
name|DImode
argument_list|,
name|op
argument_list|,
name|TImode
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output code to perform a 387 binary operation in INSN, one of PLUS,    MINUS, MULT or DIV.  OPERANDS are the insn operands, where operands[3]    is the expression of the binary operation.  The output may either be    emitted here, or returned to the caller, like all output_* functions.     There is no guarantee that the operands are the same mode, as they    might be within FLOAT or FLOAT_EXTEND expressions.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SYSV386_COMPAT
end_ifndef

begin_comment
comment|/* Set to 1 for compatibility with brain-damaged assemblers.  No-one    wants to fix the assemblers because that causes incompatibility    with gcc.  No-one wants to fix gcc because that causes    incompatibility with assemblers...  You can use the option of    -DSYSV386_COMPAT=0 if you recompile both gcc and gas this way.  */
end_comment

begin_define
define|#
directive|define
name|SYSV386_COMPAT
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|const
name|char
modifier|*
name|output_387_binary_op
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
modifier|*
name|operands
parameter_list|)
block|{
specifier|static
name|char
name|buf
index|[
literal|30
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|ssep
decl_stmt|;
name|int
name|is_sse
init|=
name|SSE_REG_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator||
name|SSE_REG_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator||
name|SSE_REG_P
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
comment|/* Even if we do not want to check the inputs, this documents input      constraints.  Which helps in understanding the following code.  */
if|if
condition|(
name|STACK_REG_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|&&
operator|(
operator|(
name|REG_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|&&
operator|(
name|STACK_REG_P
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|==
name|MEM
operator|)
operator|)
operator|||
operator|(
name|REG_P
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|REGNO
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|&&
operator|(
name|STACK_REG_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|MEM
operator|)
operator|)
operator|)
operator|&&
operator|(
name|STACK_TOP_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|||
name|STACK_TOP_P
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|)
condition|)
empty_stmt|;
comment|/* ok */
elseif|else
if|if
condition|(
operator|!
name|is_sse
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
case|case
name|PLUS
case|:
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|||
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
argument_list|)
operator|==
name|MODE_INT
condition|)
name|p
operator|=
literal|"fiadd"
expr_stmt|;
else|else
name|p
operator|=
literal|"fadd"
expr_stmt|;
name|ssep
operator|=
literal|"add"
expr_stmt|;
break|break;
case|case
name|MINUS
case|:
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|||
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
argument_list|)
operator|==
name|MODE_INT
condition|)
name|p
operator|=
literal|"fisub"
expr_stmt|;
else|else
name|p
operator|=
literal|"fsub"
expr_stmt|;
name|ssep
operator|=
literal|"sub"
expr_stmt|;
break|break;
case|case
name|MULT
case|:
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|||
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
argument_list|)
operator|==
name|MODE_INT
condition|)
name|p
operator|=
literal|"fimul"
expr_stmt|;
else|else
name|p
operator|=
literal|"fmul"
expr_stmt|;
name|ssep
operator|=
literal|"mul"
expr_stmt|;
break|break;
case|case
name|DIV
case|:
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|||
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
argument_list|)
operator|==
name|MODE_INT
condition|)
name|p
operator|=
literal|"fidiv"
expr_stmt|;
else|else
name|p
operator|=
literal|"fdiv"
expr_stmt|;
name|ssep
operator|=
literal|"div"
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|is_sse
condition|)
block|{
name|strcpy
argument_list|(
name|buf
argument_list|,
name|ssep
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|SFmode
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"ss\t{%2, %0|%0, %2}"
argument_list|)
expr_stmt|;
else|else
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"sd\t{%2, %0|%0, %2}"
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
name|strcpy
argument_list|(
name|buf
argument_list|,
name|p
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
case|case
name|MULT
case|:
case|case
name|PLUS
case|:
if|if
condition|(
name|REG_P
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|REGNO
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
name|rtx
name|temp
init|=
name|operands
index|[
literal|2
index|]
decl_stmt|;
name|operands
index|[
literal|2
index|]
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|temp
expr_stmt|;
block|}
comment|/* know operands[0] == operands[1].  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|p
operator|=
literal|"%z2\t%2"
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|STACK_TOP_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
comment|/* How is it that we are storing to a dead operand[2]? 	       Well, presumably operands[1] is dead too.  We can't 	       store the result to st(0) as st(0) gets popped on this 	       instruction.  Instead store to operands[2] (which I 	       think has to be st(1)).  st(1) will be popped later. 	       gcc<= 2.8.1 didn't have this check and generated 	       assembly code that the Unixware assembler rejected.  */
name|p
operator|=
literal|"p\t{%0, %2|%2, %0}"
expr_stmt|;
comment|/* st(1) = st(0) op st(1); pop */
else|else
name|p
operator|=
literal|"p\t{%2, %0|%0, %2}"
expr_stmt|;
comment|/* st(r1) = st(r1) op st(0); pop */
break|break;
block|}
if|if
condition|(
name|STACK_TOP_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
name|p
operator|=
literal|"\t{%y2, %0|%0, %y2}"
expr_stmt|;
comment|/* st(0) = st(0) op st(r2) */
else|else
name|p
operator|=
literal|"\t{%2, %0|%0, %2}"
expr_stmt|;
comment|/* st(r1) = st(r1) op st(0) */
break|break;
case|case
name|MINUS
case|:
case|case
name|DIV
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|p
operator|=
literal|"r%z1\t%1"
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|p
operator|=
literal|"%z2\t%2"
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|SYSV386_COMPAT
comment|/* The SystemV/386 SVR3.2 assembler, and probably all AT&T 	     derived assemblers, confusingly reverse the direction of 	     the operation for fsub{r} and fdiv{r} when the 	     destination register is not st(0).  The Intel assembler 	     doesn't have this brain damage.  Read !SYSV386_COMPAT to 	     figure out what the hardware really does.  */
if|if
condition|(
name|STACK_TOP_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
name|p
operator|=
literal|"{p\t%0, %2|rp\t%2, %0}"
expr_stmt|;
else|else
name|p
operator|=
literal|"{rp\t%2, %0|p\t%0, %2}"
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|STACK_TOP_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
comment|/* As above for fmul/fadd, we can't store to st(0).  */
name|p
operator|=
literal|"rp\t{%0, %2|%2, %0}"
expr_stmt|;
comment|/* st(1) = st(0) op st(1); pop */
else|else
name|p
operator|=
literal|"p\t{%2, %0|%0, %2}"
expr_stmt|;
comment|/* st(r1) = st(r1) op st(0); pop */
endif|#
directive|endif
break|break;
block|}
if|if
condition|(
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
condition|)
block|{
if|#
directive|if
name|SYSV386_COMPAT
if|if
condition|(
name|STACK_TOP_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
name|p
operator|=
literal|"{rp\t%0, %1|p\t%1, %0}"
expr_stmt|;
else|else
name|p
operator|=
literal|"{p\t%1, %0|rp\t%0, %1}"
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|STACK_TOP_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
name|p
operator|=
literal|"p\t{%0, %1|%1, %0}"
expr_stmt|;
comment|/* st(1) = st(1) op st(0); pop */
else|else
name|p
operator|=
literal|"rp\t{%1, %0|%0, %1}"
expr_stmt|;
comment|/* st(r2) = st(0) op st(r2); pop */
endif|#
directive|endif
break|break;
block|}
if|if
condition|(
name|STACK_TOP_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|STACK_TOP_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
name|p
operator|=
literal|"\t{%y2, %0|%0, %y2}"
expr_stmt|;
comment|/* st(0) = st(0) op st(r2) */
else|else
name|p
operator|=
literal|"r\t{%y1, %0|%0, %y1}"
expr_stmt|;
comment|/* st(0) = st(r1) op st(0) */
break|break;
block|}
elseif|else
if|if
condition|(
name|STACK_TOP_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
if|#
directive|if
name|SYSV386_COMPAT
name|p
operator|=
literal|"{\t%1, %0|r\t%0, %1}"
expr_stmt|;
else|#
directive|else
name|p
operator|=
literal|"r\t{%1, %0|%0, %1}"
expr_stmt|;
comment|/* st(r2) = st(0) op st(r2) */
endif|#
directive|endif
block|}
else|else
block|{
if|#
directive|if
name|SYSV386_COMPAT
name|p
operator|=
literal|"{r\t%2, %0|\t%0, %2}"
expr_stmt|;
else|#
directive|else
name|p
operator|=
literal|"\t{%2, %0|%0, %2}"
expr_stmt|;
comment|/* st(r1) = st(r1) op st(0) */
endif|#
directive|endif
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|strcat
argument_list|(
name|buf
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/* Output code to initialize control word copies used by    trunc?f?i patterns.  NORMAL is set to current control word, while ROUND_DOWN    is set to control word rounding downwards.  */
end_comment

begin_function
name|void
name|emit_i387_cw_initialization
parameter_list|(
name|rtx
name|normal
parameter_list|,
name|rtx
name|round_down
parameter_list|)
block|{
name|rtx
name|reg
init|=
name|gen_reg_rtx
argument_list|(
name|HImode
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_x86_fnstcw_1
argument_list|(
name|normal
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|normal
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TARGET_PARTIAL_REG_STALL
operator|&&
operator|!
name|optimize_size
operator|&&
operator|!
name|TARGET_64BIT
condition|)
name|emit_insn
argument_list|(
name|gen_movsi_insv_1
argument_list|(
name|reg
argument_list|,
name|GEN_INT
argument_list|(
literal|0xc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_iorhi3
argument_list|(
name|reg
argument_list|,
name|reg
argument_list|,
name|GEN_INT
argument_list|(
literal|0xc00
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|round_down
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output code for INSN to convert a float to a signed int.  OPERANDS    are the insn operands.  The output may be [HSD]Imode and the input    operand may be [SDX]Fmode.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|output_fix_trunc
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
modifier|*
name|operands
parameter_list|)
block|{
name|int
name|stack_top_dies
init|=
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|FIRST_STACK_REG
argument_list|)
operator|!=
literal|0
decl_stmt|;
name|int
name|dimode_p
init|=
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|DImode
decl_stmt|;
comment|/* Jump through a hoop or two for DImode, since the hardware has no      non-popping instruction.  We used to do this a different way, but      that was somewhat fragile and broke with post-reload splitters.  */
if|if
condition|(
name|dimode_p
operator|&&
operator|!
name|stack_top_dies
condition|)
name|output_asm_insn
argument_list|(
literal|"fld\t%y1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|STACK_TOP_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|!=
name|MEM
condition|)
name|abort
argument_list|()
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"fldcw\t%3"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
if|if
condition|(
name|stack_top_dies
operator|||
name|dimode_p
condition|)
name|output_asm_insn
argument_list|(
literal|"fistp%z0\t%0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
else|else
name|output_asm_insn
argument_list|(
literal|"fist%z0\t%0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"fldcw\t%2"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
end_function

begin_comment
comment|/* Output code for INSN to compare OPERANDS.  EFLAGS_P is 1 when fcomi    should be used and 2 when fnstsw should be used.  UNORDERED_P is true    when fucom should be used.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|output_fp_compare
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
modifier|*
name|operands
parameter_list|,
name|int
name|eflags_p
parameter_list|,
name|int
name|unordered_p
parameter_list|)
block|{
name|int
name|stack_top_dies
decl_stmt|;
name|rtx
name|cmp_op0
init|=
name|operands
index|[
literal|0
index|]
decl_stmt|;
name|rtx
name|cmp_op1
init|=
name|operands
index|[
literal|1
index|]
decl_stmt|;
name|int
name|is_sse
init|=
name|SSE_REG_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator||
name|SSE_REG_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|eflags_p
operator|==
literal|2
condition|)
block|{
name|cmp_op0
operator|=
name|cmp_op1
expr_stmt|;
name|cmp_op1
operator|=
name|operands
index|[
literal|2
index|]
expr_stmt|;
block|}
if|if
condition|(
name|is_sse
condition|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|SFmode
condition|)
if|if
condition|(
name|unordered_p
condition|)
return|return
literal|"ucomiss\t{%1, %0|%0, %1}"
return|;
else|else
return|return
literal|"comiss\t{%1, %0|%0, %1}"
return|;
elseif|else
if|if
condition|(
name|unordered_p
condition|)
return|return
literal|"ucomisd\t{%1, %0|%0, %1}"
return|;
else|else
return|return
literal|"comisd\t{%1, %0|%0, %1}"
return|;
block|}
if|if
condition|(
operator|!
name|STACK_TOP_P
argument_list|(
name|cmp_op0
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|stack_top_dies
operator|=
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|FIRST_STACK_REG
argument_list|)
operator|!=
literal|0
expr_stmt|;
if|if
condition|(
name|STACK_REG_P
argument_list|(
name|cmp_op1
argument_list|)
operator|&&
name|stack_top_dies
operator|&&
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
name|cmp_op1
argument_list|)
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|cmp_op1
argument_list|)
operator|!=
name|FIRST_STACK_REG
condition|)
block|{
comment|/* If both the top of the 387 stack dies, and the other operand 	 is also a stack register that dies, then this must be a 	 `fcompp' float compare */
if|if
condition|(
name|eflags_p
operator|==
literal|1
condition|)
block|{
comment|/* There is no double popping fcomi variant.  Fortunately, 	     eflags is immune from the fstp's cc clobbering.  */
if|if
condition|(
name|unordered_p
condition|)
name|output_asm_insn
argument_list|(
literal|"fucomip\t{%y1, %0|%0, %y1}"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
else|else
name|output_asm_insn
argument_list|(
literal|"fcomip\t{%y1, %0|%0, %y1}"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return
literal|"fstp\t%y0"
return|;
block|}
else|else
block|{
if|if
condition|(
name|eflags_p
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|unordered_p
condition|)
return|return
literal|"fucompp\n\tfnstsw\t%0"
return|;
else|else
return|return
literal|"fcompp\n\tfnstsw\t%0"
return|;
block|}
else|else
block|{
if|if
condition|(
name|unordered_p
condition|)
return|return
literal|"fucompp"
return|;
else|else
return|return
literal|"fcompp"
return|;
block|}
block|}
block|}
else|else
block|{
comment|/* Encoded here as eflags_p | intmode | unordered_p | stack_top_dies.  */
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|alt
index|[
literal|24
index|]
init|=
block|{
literal|"fcom%z1\t%y1"
block|,
literal|"fcomp%z1\t%y1"
block|,
literal|"fucom%z1\t%y1"
block|,
literal|"fucomp%z1\t%y1"
block|,
literal|"ficom%z1\t%y1"
block|,
literal|"ficomp%z1\t%y1"
block|,
name|NULL
block|,
name|NULL
block|,
literal|"fcomi\t{%y1, %0|%0, %y1}"
block|,
literal|"fcomip\t{%y1, %0|%0, %y1}"
block|,
literal|"fucomi\t{%y1, %0|%0, %y1}"
block|,
literal|"fucomip\t{%y1, %0|%0, %y1}"
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|"fcom%z2\t%y2\n\tfnstsw\t%0"
block|,
literal|"fcomp%z2\t%y2\n\tfnstsw\t%0"
block|,
literal|"fucom%z2\t%y2\n\tfnstsw\t%0"
block|,
literal|"fucomp%z2\t%y2\n\tfnstsw\t%0"
block|,
literal|"ficom%z2\t%y2\n\tfnstsw\t%0"
block|,
literal|"ficomp%z2\t%y2\n\tfnstsw\t%0"
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
name|int
name|mask
decl_stmt|;
specifier|const
name|char
modifier|*
name|ret
decl_stmt|;
name|mask
operator|=
name|eflags_p
operator|<<
literal|3
expr_stmt|;
name|mask
operator||=
operator|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|)
operator|<<
literal|2
expr_stmt|;
name|mask
operator||=
name|unordered_p
operator|<<
literal|1
expr_stmt|;
name|mask
operator||=
name|stack_top_dies
expr_stmt|;
if|if
condition|(
name|mask
operator|>=
literal|24
condition|)
name|abort
argument_list|()
expr_stmt|;
name|ret
operator|=
name|alt
index|[
name|mask
index|]
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|ret
return|;
block|}
block|}
end_function

begin_function
name|void
name|ix86_output_addr_vec_elt
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|int
name|value
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|directive
init|=
name|ASM_LONG
decl_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
ifdef|#
directive|ifdef
name|ASM_QUAD
name|directive
operator|=
name|ASM_QUAD
expr_stmt|;
else|#
directive|else
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s%s%d\n"
argument_list|,
name|directive
argument_list|,
name|LPREFIX
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ix86_output_addr_diff_elt
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|int
name|value
parameter_list|,
name|int
name|rel
parameter_list|)
block|{
if|if
condition|(
name|TARGET_64BIT
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s%s%d-%s%d\n"
argument_list|,
name|ASM_LONG
argument_list|,
name|LPREFIX
argument_list|,
name|value
argument_list|,
name|LPREFIX
argument_list|,
name|rel
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|HAVE_AS_GOTOFF_IN_DATA
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s%s%d@GOTOFF\n"
argument_list|,
name|ASM_LONG
argument_list|,
name|LPREFIX
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|#
directive|if
name|TARGET_MACHO
elseif|else
if|if
condition|(
name|TARGET_MACHO
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s%s%d-"
argument_list|,
name|ASM_LONG
argument_list|,
name|LPREFIX
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|machopic_output_function_base_name
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
else|else
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"%s%U%s+[.-%s%d]\n"
argument_list|,
name|ASM_LONG
argument_list|,
name|GOT_SYMBOL_NAME
argument_list|,
name|LPREFIX
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate either "mov $0, reg" or "xor reg, reg", as appropriate    for the target.  */
end_comment

begin_function
name|void
name|ix86_expand_clear
parameter_list|(
name|rtx
name|dest
parameter_list|)
block|{
name|rtx
name|tmp
decl_stmt|;
comment|/* We play register width games, which are only valid after reload.  */
if|if
condition|(
operator|!
name|reload_completed
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Avoid HImode and its attendant prefix byte.  */
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|<
literal|4
condition|)
name|dest
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|dest
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
comment|/* This predicate should match that for movsi_xor and movdi_xor_rex64.  */
if|if
condition|(
name|reload_completed
operator|&&
operator|(
operator|!
name|TARGET_USE_MOV0
operator|||
name|optimize_size
operator|)
condition|)
block|{
name|rtx
name|clob
init|=
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|CCmode
argument_list|,
literal|17
argument_list|)
argument_list|)
decl_stmt|;
name|tmp
operator|=
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|tmp
argument_list|,
name|clob
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|emit_insn
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* X is an unchanging MEM.  If it is a constant pool reference, return    the constant pool rtx, else NULL.  */
end_comment

begin_function
specifier|static
name|rtx
name|maybe_get_pool_constant
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|x
operator|=
name|ix86_delegitimize_address
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|get_pool_constant
argument_list|(
name|x
argument_list|)
return|;
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_function
name|void
name|ix86_expand_move
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|operands
index|[]
parameter_list|)
block|{
name|int
name|strict
init|=
operator|(
name|reload_in_progress
operator|||
name|reload_completed
operator|)
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
name|enum
name|tls_model
name|model
decl_stmt|;
name|op0
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
name|op1
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
name|model
operator|=
name|tls_symbolic_operand
argument_list|(
name|op1
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|model
condition|)
block|{
name|op1
operator|=
name|legitimize_tls_address
argument_list|(
name|op1
argument_list|,
name|model
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|op1
operator|=
name|force_operand
argument_list|(
name|op1
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
operator|==
name|op0
condition|)
return|return;
block|}
if|if
condition|(
name|flag_pic
operator|&&
name|mode
operator|==
name|Pmode
operator|&&
name|symbolic_operand
argument_list|(
name|op1
argument_list|,
name|Pmode
argument_list|)
condition|)
block|{
if|#
directive|if
name|TARGET_MACHO
if|if
condition|(
name|MACHOPIC_PURE
condition|)
block|{
name|rtx
name|temp
init|=
operator|(
operator|(
name|reload_in_progress
operator|||
operator|(
operator|(
name|op0
operator|&&
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|REG
operator|)
operator|&&
name|mode
operator|==
name|Pmode
operator|)
operator|)
condition|?
name|op0
else|:
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
operator|)
decl_stmt|;
name|op1
operator|=
name|machopic_indirect_data_reference
argument_list|(
name|op1
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|op1
operator|=
name|machopic_legitimize_pic_address
argument_list|(
name|op1
argument_list|,
name|mode
argument_list|,
name|temp
operator|==
name|op1
condition|?
literal|0
else|:
name|temp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|MACHOPIC_INDIRECT
condition|)
name|op1
operator|=
name|machopic_indirect_data_reference
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
operator|==
name|op1
condition|)
return|return;
else|#
directive|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|MEM
condition|)
name|op1
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|op1
argument_list|)
expr_stmt|;
else|else
block|{
name|rtx
name|temp
init|=
name|op0
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|!=
name|REG
condition|)
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|temp
operator|=
name|legitimize_pic_address
argument_list|(
name|op1
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
name|op0
condition|)
return|return;
name|op1
operator|=
name|temp
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TARGET_MACHO */
block|}
else|else
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
name|PUSH_ROUNDING
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|)
operator|!=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|||
operator|!
name|push_operand
argument_list|(
name|op0
argument_list|,
name|mode
argument_list|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|MEM
condition|)
name|op1
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|push_operand
argument_list|(
name|op0
argument_list|,
name|mode
argument_list|)
operator|&&
operator|!
name|general_no_elim_operand
argument_list|(
name|op1
argument_list|,
name|mode
argument_list|)
condition|)
name|op1
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode
argument_list|,
name|op1
argument_list|)
expr_stmt|;
comment|/* Force large constants in 64bit compilation into register 	 to get them CSEed.  */
if|if
condition|(
name|TARGET_64BIT
operator|&&
name|mode
operator|==
name|DImode
operator|&&
name|immediate_operand
argument_list|(
name|op1
argument_list|,
name|mode
argument_list|)
operator|&&
operator|!
name|x86_64_zero_extended_value
argument_list|(
name|op1
argument_list|)
operator|&&
operator|!
name|register_operand
argument_list|(
name|op0
argument_list|,
name|mode
argument_list|)
operator|&&
name|optimize
operator|&&
operator|!
name|reload_completed
operator|&&
operator|!
name|reload_in_progress
condition|)
name|op1
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
block|{
comment|/* If we are loading a floating point constant to a register, 	     force the value to memory now, since we'll get better code 	     out the back end.  */
if|if
condition|(
name|strict
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
name|op1
operator|=
name|validize_mem
argument_list|(
name|force_const_mem
argument_list|(
name|mode
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|register_operand
argument_list|(
name|op0
argument_list|,
name|mode
argument_list|)
condition|)
block|{
name|rtx
name|temp
init|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|temp
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|op0
argument_list|,
name|temp
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
block|}
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ix86_expand_vector_move
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|operands
index|[]
parameter_list|)
block|{
comment|/* Force constants other than zero into memory.  We do not know how      the instructions used to build constants modify the upper 64 bits      of the register, once we have that information we may be able      to handle some of them more efficiently.  */
if|if
condition|(
operator|(
name|reload_in_progress
operator||
name|reload_completed
operator|)
operator|==
literal|0
operator|&&
name|register_operand
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|mode
argument_list|)
operator|&&
name|CONSTANT_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|&&
name|operands
index|[
literal|1
index|]
operator|!=
name|CONST0_RTX
argument_list|(
name|mode
argument_list|)
condition|)
name|operands
index|[
literal|1
index|]
operator|=
name|validize_mem
argument_list|(
name|force_const_mem
argument_list|(
name|mode
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make operand1 a register if it isn't already.  */
if|if
condition|(
operator|!
name|no_new_pseudos
operator|&&
operator|!
name|register_operand
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|mode
argument_list|)
operator|&&
operator|!
name|register_operand
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|mode
argument_list|)
condition|)
block|{
name|rtx
name|temp
init|=
name|force_reg
argument_list|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|temp
argument_list|)
expr_stmt|;
return|return;
block|}
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Attempt to expand a binary operator.  Make the expansion closer to the    actual machine, then just general_operand, which will allow 3 separate    memory references (one output, two input) in a single insn.  */
end_comment

begin_function
name|void
name|ix86_expand_binary_operator
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|operands
index|[]
parameter_list|)
block|{
name|int
name|matching_memory
decl_stmt|;
name|rtx
name|src1
decl_stmt|,
name|src2
decl_stmt|,
name|dst
decl_stmt|,
name|op
decl_stmt|,
name|clob
decl_stmt|;
name|dst
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
name|src1
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
name|src2
operator|=
name|operands
index|[
literal|2
index|]
expr_stmt|;
comment|/* Recognize<var1> =<value><op><var1> for commutative operators */
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'c'
operator|&&
operator|(
name|rtx_equal_p
argument_list|(
name|dst
argument_list|,
name|src2
argument_list|)
operator|||
name|immediate_operand
argument_list|(
name|src1
argument_list|,
name|mode
argument_list|)
operator|)
condition|)
block|{
name|rtx
name|temp
init|=
name|src1
decl_stmt|;
name|src1
operator|=
name|src2
expr_stmt|;
name|src2
operator|=
name|temp
expr_stmt|;
block|}
comment|/* If the destination is memory, and we do not have matching source      operands, do things in registers.  */
name|matching_memory
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|dst
argument_list|,
name|src1
argument_list|)
condition|)
name|matching_memory
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'c'
operator|&&
name|rtx_equal_p
argument_list|(
name|dst
argument_list|,
name|src2
argument_list|)
condition|)
name|matching_memory
operator|=
literal|2
expr_stmt|;
else|else
name|dst
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
comment|/* Both source operands cannot be in memory.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|src1
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|src2
argument_list|)
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
name|matching_memory
operator|!=
literal|2
condition|)
name|src2
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|src2
argument_list|)
expr_stmt|;
else|else
name|src1
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|src1
argument_list|)
expr_stmt|;
block|}
comment|/* If the operation is not commutable, source 1 cannot be a constant      or non-matching memory.  */
if|if
condition|(
operator|(
name|CONSTANT_P
argument_list|(
name|src1
argument_list|)
operator|||
operator|(
operator|!
name|matching_memory
operator|&&
name|GET_CODE
argument_list|(
name|src1
argument_list|)
operator|==
name|MEM
operator|)
operator|)
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|!=
literal|'c'
condition|)
name|src1
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|src1
argument_list|)
expr_stmt|;
comment|/* If optimizing, copy to regs to improve CSE */
if|if
condition|(
name|optimize
operator|&&
operator|!
name|no_new_pseudos
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|==
name|MEM
condition|)
name|dst
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src1
argument_list|)
operator|==
name|MEM
condition|)
name|src1
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|src1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src2
argument_list|)
operator|==
name|MEM
condition|)
name|src2
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|src2
argument_list|)
expr_stmt|;
block|}
comment|/* Emit the instruction.  */
name|op
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|dst
argument_list|,
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|src1
argument_list|,
name|src2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reload_in_progress
condition|)
block|{
comment|/* Reload doesn't know about the flags register, and doesn't know that          it doesn't want to clobber it.  We can only do this with PLUS.  */
if|if
condition|(
name|code
operator|!=
name|PLUS
condition|)
name|abort
argument_list|()
expr_stmt|;
name|emit_insn
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|clob
operator|=
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|CCmode
argument_list|,
name|FLAGS_REG
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|op
argument_list|,
name|clob
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Fix up the destination if needed.  */
if|if
condition|(
name|dst
operator|!=
name|operands
index|[
literal|0
index|]
condition|)
name|emit_move_insn
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|dst
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return TRUE or FALSE depending on whether the binary operator meets the    appropriate constraints.  */
end_comment

begin_function
name|int
name|ix86_binary_operator_ok
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|,
name|rtx
name|operands
index|[
literal|3
index|]
parameter_list|)
block|{
comment|/* Both source operands cannot be in memory.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|==
name|MEM
condition|)
return|return
literal|0
return|;
comment|/* If the operation is not commutable, source 1 cannot be a constant.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|!=
literal|'c'
condition|)
return|return
literal|0
return|;
comment|/* If the destination is memory, we must have a matching source operand.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
operator|(
name|rtx_equal_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
operator|||
operator|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'c'
operator|&&
name|rtx_equal_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|)
operator|)
operator|)
condition|)
return|return
literal|0
return|;
comment|/* If the operation is not commutable and the source 1 is memory, we must      have a matching destination.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|!=
literal|'c'
operator|&&
operator|!
name|rtx_equal_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Attempt to expand a unary operator.  Make the expansion closer to the    actual machine, then just general_operand, which will allow 2 separate    memory references (one output, one input) in a single insn.  */
end_comment

begin_function
name|void
name|ix86_expand_unary_operator
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|operands
index|[]
parameter_list|)
block|{
name|int
name|matching_memory
decl_stmt|;
name|rtx
name|src
decl_stmt|,
name|dst
decl_stmt|,
name|op
decl_stmt|,
name|clob
decl_stmt|;
name|dst
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
name|src
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
comment|/* If the destination is memory, and we do not have matching source      operands, do things in registers.  */
name|matching_memory
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|dst
argument_list|,
name|src
argument_list|)
condition|)
name|matching_memory
operator|=
literal|1
expr_stmt|;
else|else
name|dst
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
comment|/* When source operand is memory, destination must match.  */
if|if
condition|(
operator|!
name|matching_memory
operator|&&
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|MEM
condition|)
name|src
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|src
argument_list|)
expr_stmt|;
comment|/* If optimizing, copy to regs to improve CSE */
if|if
condition|(
name|optimize
operator|&&
operator|!
name|no_new_pseudos
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|==
name|MEM
condition|)
name|dst
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|MEM
condition|)
name|src
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|src
argument_list|)
expr_stmt|;
block|}
comment|/* Emit the instruction.  */
name|op
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|dst
argument_list|,
name|gen_rtx_fmt_e
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|src
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reload_in_progress
operator|||
name|code
operator|==
name|NOT
condition|)
block|{
comment|/* Reload doesn't know about the flags register, and doesn't know that          it doesn't want to clobber it.  */
if|if
condition|(
name|code
operator|!=
name|NOT
condition|)
name|abort
argument_list|()
expr_stmt|;
name|emit_insn
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|clob
operator|=
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|CCmode
argument_list|,
name|FLAGS_REG
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|op
argument_list|,
name|clob
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Fix up the destination if needed.  */
if|if
condition|(
name|dst
operator|!=
name|operands
index|[
literal|0
index|]
condition|)
name|emit_move_insn
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|dst
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return TRUE or FALSE depending on whether the unary operator meets the    appropriate constraints.  */
end_comment

begin_function
name|int
name|ix86_unary_operator_ok
parameter_list|(
name|enum
name|rtx_code
name|code
name|ATTRIBUTE_UNUSED
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|,
name|rtx
name|operands
index|[
literal|2
index|]
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* If one of operands is memory, source and destination must match.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|MEM
operator|||
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|MEM
operator|)
operator|&&
operator|!
name|rtx_equal_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE or FALSE depending on whether the first SET in INSN    has source and destination with matching CC modes, and that the    CC mode is at least as constrained as REQ_MODE.  */
end_comment

begin_function
name|int
name|ix86_match_ccmode
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|enum
name|machine_mode
name|req_mode
parameter_list|)
block|{
name|rtx
name|set
decl_stmt|;
name|enum
name|machine_mode
name|set_mode
decl_stmt|;
name|set
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|set
argument_list|)
operator|==
name|PARALLEL
condition|)
name|set
operator|=
name|XVECEXP
argument_list|(
name|set
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|set
argument_list|)
operator|!=
name|SET
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|!=
name|COMPARE
condition|)
name|abort
argument_list|()
expr_stmt|;
name|set_mode
operator|=
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|set_mode
condition|)
block|{
case|case
name|CCNOmode
case|:
if|if
condition|(
name|req_mode
operator|!=
name|CCNOmode
operator|&&
operator|(
name|req_mode
operator|!=
name|CCmode
operator|||
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|!=
name|const0_rtx
operator|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
name|CCmode
case|:
if|if
condition|(
name|req_mode
operator|==
name|CCGCmode
condition|)
return|return
literal|0
return|;
comment|/* FALLTHRU */
case|case
name|CCGCmode
case|:
if|if
condition|(
name|req_mode
operator|==
name|CCGOCmode
operator|||
name|req_mode
operator|==
name|CCNOmode
condition|)
return|return
literal|0
return|;
comment|/* FALLTHRU */
case|case
name|CCGOCmode
case|:
if|if
condition|(
name|req_mode
operator|==
name|CCZmode
condition|)
return|return
literal|0
return|;
comment|/* FALLTHRU */
case|case
name|CCZmode
case|:
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|set_mode
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Generate insn patterns to do an integer compare of OPERANDS.  */
end_comment

begin_function
specifier|static
name|rtx
name|ix86_expand_int_compare
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|rtx
name|op0
parameter_list|,
name|rtx
name|op1
parameter_list|)
block|{
name|enum
name|machine_mode
name|cmpmode
decl_stmt|;
name|rtx
name|tmp
decl_stmt|,
name|flags
decl_stmt|;
name|cmpmode
operator|=
name|SELECT_CC_MODE
argument_list|(
name|code
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|flags
operator|=
name|gen_rtx_REG
argument_list|(
name|cmpmode
argument_list|,
name|FLAGS_REG
argument_list|)
expr_stmt|;
comment|/* This is very simple, but making the interface the same as in the      FP case makes the rest of the code easier.  */
name|tmp
operator|=
name|gen_rtx_COMPARE
argument_list|(
name|cmpmode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|flags
argument_list|,
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Return the test that should be put into the flags user, i.e.      the bcc, scc, or cmov instruction.  */
return|return
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|VOIDmode
argument_list|,
name|flags
argument_list|,
name|const0_rtx
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Figure out whether to use ordered or unordered fp comparisons.    Return the appropriate mode to use.  */
end_comment

begin_function
name|enum
name|machine_mode
name|ix86_fp_compare_mode
parameter_list|(
name|enum
name|rtx_code
name|code
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* ??? In order to make all comparisons reversible, we do all comparisons      non-trapping when compiling for IEEE.  Once gcc is able to distinguish      all forms trapping and nontrapping comparisons, we can make inequality      comparisons trapping again, since it results in better code when using      FCOM based compares.  */
return|return
name|TARGET_IEEE_FP
condition|?
name|CCFPUmode
else|:
name|CCFPmode
return|;
block|}
end_function

begin_function
name|enum
name|machine_mode
name|ix86_cc_mode
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|rtx
name|op0
parameter_list|,
name|rtx
name|op1
parameter_list|)
block|{
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
return|return
name|ix86_fp_compare_mode
argument_list|(
name|code
argument_list|)
return|;
switch|switch
condition|(
name|code
condition|)
block|{
comment|/* Only zero flag is needed.  */
case|case
name|EQ
case|:
comment|/* ZF=0 */
case|case
name|NE
case|:
comment|/* ZF!=0 */
return|return
name|CCZmode
return|;
comment|/* Codes needing carry flag.  */
case|case
name|GEU
case|:
comment|/* CF=0 */
case|case
name|GTU
case|:
comment|/* CF=0& ZF=0 */
case|case
name|LTU
case|:
comment|/* CF=1 */
case|case
name|LEU
case|:
comment|/* CF=1 | ZF=1 */
return|return
name|CCmode
return|;
comment|/* Codes possibly doable only with sign flag when          comparing against zero.  */
case|case
name|GE
case|:
comment|/* SF=OF   or   SF=0 */
case|case
name|LT
case|:
comment|/* SF<>OF  or   SF=1 */
if|if
condition|(
name|op1
operator|==
name|const0_rtx
condition|)
return|return
name|CCGOCmode
return|;
else|else
comment|/* For other cases Carry flag is not required.  */
return|return
name|CCGCmode
return|;
comment|/* Codes doable only with sign flag when comparing          against zero, but we miss jump instruction for it          so we need to use relational tests against overflow          that thus needs to be zero.  */
case|case
name|GT
case|:
comment|/* ZF=0& SF=OF */
case|case
name|LE
case|:
comment|/* ZF=1 | SF<>OF */
if|if
condition|(
name|op1
operator|==
name|const0_rtx
condition|)
return|return
name|CCNOmode
return|;
else|else
return|return
name|CCGCmode
return|;
comment|/* strcmp pattern do (use flags) and combine may ask us for proper 	 mode.  */
case|case
name|USE
case|:
return|return
name|CCmode
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return the fixed registers used for condition codes.  */
end_comment

begin_function
specifier|static
name|bool
name|ix86_fixed_condition_code_regs
parameter_list|(
name|unsigned
name|int
modifier|*
name|p1
parameter_list|,
name|unsigned
name|int
modifier|*
name|p2
parameter_list|)
block|{
operator|*
name|p1
operator|=
name|FLAGS_REG
expr_stmt|;
operator|*
name|p2
operator|=
name|FPSR_REG
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* If two condition code modes are compatible, return a condition code    mode which is compatible with both.  Otherwise, return    VOIDmode.  */
end_comment

begin_function
specifier|static
name|enum
name|machine_mode
name|ix86_cc_modes_compatible
parameter_list|(
name|enum
name|machine_mode
name|m1
parameter_list|,
name|enum
name|machine_mode
name|m2
parameter_list|)
block|{
if|if
condition|(
name|m1
operator|==
name|m2
condition|)
return|return
name|m1
return|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|m1
argument_list|)
operator|!=
name|MODE_CC
operator|||
name|GET_MODE_CLASS
argument_list|(
name|m2
argument_list|)
operator|!=
name|MODE_CC
condition|)
return|return
name|VOIDmode
return|;
if|if
condition|(
operator|(
name|m1
operator|==
name|CCGCmode
operator|&&
name|m2
operator|==
name|CCGOCmode
operator|)
operator|||
operator|(
name|m1
operator|==
name|CCGOCmode
operator|&&
name|m2
operator|==
name|CCGCmode
operator|)
condition|)
return|return
name|CCGCmode
return|;
switch|switch
condition|(
name|m1
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
name|CCmode
case|:
case|case
name|CCGCmode
case|:
case|case
name|CCGOCmode
case|:
case|case
name|CCNOmode
case|:
case|case
name|CCZmode
case|:
switch|switch
condition|(
name|m2
condition|)
block|{
default|default:
return|return
name|VOIDmode
return|;
case|case
name|CCmode
case|:
case|case
name|CCGCmode
case|:
case|case
name|CCGOCmode
case|:
case|case
name|CCNOmode
case|:
case|case
name|CCZmode
case|:
return|return
name|CCmode
return|;
block|}
case|case
name|CCFPmode
case|:
case|case
name|CCFPUmode
case|:
comment|/* These are only compatible with themselves, which we already 	 checked above.  */
return|return
name|VOIDmode
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return true if we should use an FCOMI instruction for this fp comparison.  */
end_comment

begin_function
name|int
name|ix86_use_fcomi_compare
parameter_list|(
name|enum
name|rtx_code
name|code
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|enum
name|rtx_code
name|swapped_code
init|=
name|swap_condition
argument_list|(
name|code
argument_list|)
decl_stmt|;
return|return
operator|(
operator|(
name|ix86_fp_comparison_cost
argument_list|(
name|code
argument_list|)
operator|==
name|ix86_fp_comparison_fcomi_cost
argument_list|(
name|code
argument_list|)
operator|)
operator|||
operator|(
name|ix86_fp_comparison_cost
argument_list|(
name|swapped_code
argument_list|)
operator|==
name|ix86_fp_comparison_fcomi_cost
argument_list|(
name|swapped_code
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Swap, force into registers, or otherwise massage the two operands    to a fp comparison.  The operands are updated in place; the new    comparison code is returned.  */
end_comment

begin_function
specifier|static
name|enum
name|rtx_code
name|ix86_prepare_fp_compare_args
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|rtx
modifier|*
name|pop0
parameter_list|,
name|rtx
modifier|*
name|pop1
parameter_list|)
block|{
name|enum
name|machine_mode
name|fpcmp_mode
init|=
name|ix86_fp_compare_mode
argument_list|(
name|code
argument_list|)
decl_stmt|;
name|rtx
name|op0
init|=
operator|*
name|pop0
decl_stmt|,
name|op1
init|=
operator|*
name|pop1
decl_stmt|;
name|enum
name|machine_mode
name|op_mode
init|=
name|GET_MODE
argument_list|(
name|op0
argument_list|)
decl_stmt|;
name|int
name|is_sse
init|=
name|SSE_REG_P
argument_list|(
name|op0
argument_list|)
operator||
name|SSE_REG_P
argument_list|(
name|op1
argument_list|)
decl_stmt|;
comment|/* All of the unordered compare instructions only work on registers.      The same is true of the XFmode compare instructions.  The same is      true of the fcomi compare instructions.  */
if|if
condition|(
operator|!
name|is_sse
operator|&&
operator|(
name|fpcmp_mode
operator|==
name|CCFPUmode
operator|||
name|op_mode
operator|==
name|XFmode
operator|||
name|ix86_use_fcomi_compare
argument_list|(
name|code
argument_list|)
operator|)
condition|)
block|{
name|op0
operator|=
name|force_reg
argument_list|(
name|op_mode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|force_reg
argument_list|(
name|op_mode
argument_list|,
name|op1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* %%% We only allow op1 in memory; op0 must be st(0).  So swap 	 things around if they appear profitable, otherwise force op0 	 into a register.  */
if|if
condition|(
name|standard_80387_constant_p
argument_list|(
name|op0
argument_list|)
operator|==
literal|0
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
operator|(
name|standard_80387_constant_p
argument_list|(
name|op1
argument_list|)
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|MEM
operator|)
operator|)
condition|)
block|{
name|rtx
name|tmp
decl_stmt|;
name|tmp
operator|=
name|op0
operator|,
name|op0
operator|=
name|op1
operator|,
name|op1
operator|=
name|tmp
expr_stmt|;
name|code
operator|=
name|swap_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|REG
condition|)
name|op0
operator|=
name|force_reg
argument_list|(
name|op_mode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op1
argument_list|)
condition|)
block|{
if|if
condition|(
name|standard_80387_constant_p
argument_list|(
name|op1
argument_list|)
condition|)
name|op1
operator|=
name|force_reg
argument_list|(
name|op_mode
argument_list|,
name|op1
argument_list|)
expr_stmt|;
else|else
name|op1
operator|=
name|validize_mem
argument_list|(
name|force_const_mem
argument_list|(
name|op_mode
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Try to rearrange the comparison to make it cheaper.  */
if|if
condition|(
name|ix86_fp_comparison_cost
argument_list|(
name|code
argument_list|)
operator|>
name|ix86_fp_comparison_cost
argument_list|(
name|swap_condition
argument_list|(
name|code
argument_list|)
argument_list|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|REG
operator|||
operator|!
name|no_new_pseudos
operator|)
condition|)
block|{
name|rtx
name|tmp
decl_stmt|;
name|tmp
operator|=
name|op0
operator|,
name|op0
operator|=
name|op1
operator|,
name|op1
operator|=
name|tmp
expr_stmt|;
name|code
operator|=
name|swap_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|REG
condition|)
name|op0
operator|=
name|force_reg
argument_list|(
name|op_mode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
block|}
operator|*
name|pop0
operator|=
name|op0
expr_stmt|;
operator|*
name|pop1
operator|=
name|op1
expr_stmt|;
return|return
name|code
return|;
block|}
end_function

begin_comment
comment|/* Convert comparison codes we use to represent FP comparison to integer    code that will result in proper branch.  Return UNKNOWN if no such code    is available.  */
end_comment

begin_function
specifier|static
name|enum
name|rtx_code
name|ix86_fp_compare_code_to_integer
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|GT
case|:
return|return
name|GTU
return|;
case|case
name|GE
case|:
return|return
name|GEU
return|;
case|case
name|ORDERED
case|:
case|case
name|UNORDERED
case|:
return|return
name|code
return|;
break|break;
case|case
name|UNEQ
case|:
return|return
name|EQ
return|;
break|break;
case|case
name|UNLT
case|:
return|return
name|LTU
return|;
break|break;
case|case
name|UNLE
case|:
return|return
name|LEU
return|;
break|break;
case|case
name|LTGT
case|:
return|return
name|NE
return|;
break|break;
default|default:
return|return
name|UNKNOWN
return|;
block|}
block|}
end_function

begin_comment
comment|/* Split comparison code CODE into comparisons we can do using branch    instructions.  BYPASS_CODE is comparison code for branch that will    branch around FIRST_CODE and SECOND_CODE.  If some of branches    is not required, set value to NIL.    We never require more than two branches.  */
end_comment

begin_function
specifier|static
name|void
name|ix86_fp_comparison_codes
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|enum
name|rtx_code
modifier|*
name|bypass_code
parameter_list|,
name|enum
name|rtx_code
modifier|*
name|first_code
parameter_list|,
name|enum
name|rtx_code
modifier|*
name|second_code
parameter_list|)
block|{
operator|*
name|first_code
operator|=
name|code
expr_stmt|;
operator|*
name|bypass_code
operator|=
name|NIL
expr_stmt|;
operator|*
name|second_code
operator|=
name|NIL
expr_stmt|;
comment|/* The fcomi comparison sets flags as follows:       cmp    ZF PF CF>      0  0  0<      0  0  1      =      1  0  0      un     1  1  1 */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|GT
case|:
comment|/* GTU - CF=0& ZF=0 */
case|case
name|GE
case|:
comment|/* GEU - CF=0 */
case|case
name|ORDERED
case|:
comment|/* PF=0 */
case|case
name|UNORDERED
case|:
comment|/* PF=1 */
case|case
name|UNEQ
case|:
comment|/* EQ - ZF=1 */
case|case
name|UNLT
case|:
comment|/* LTU - CF=1 */
case|case
name|UNLE
case|:
comment|/* LEU - CF=1 | ZF=1 */
case|case
name|LTGT
case|:
comment|/* EQ - ZF=0 */
break|break;
case|case
name|LT
case|:
comment|/* LTU - CF=1 - fails on unordered */
operator|*
name|first_code
operator|=
name|UNLT
expr_stmt|;
operator|*
name|bypass_code
operator|=
name|UNORDERED
expr_stmt|;
break|break;
case|case
name|LE
case|:
comment|/* LEU - CF=1 | ZF=1 - fails on unordered */
operator|*
name|first_code
operator|=
name|UNLE
expr_stmt|;
operator|*
name|bypass_code
operator|=
name|UNORDERED
expr_stmt|;
break|break;
case|case
name|EQ
case|:
comment|/* EQ - ZF=1 - fails on unordered */
operator|*
name|first_code
operator|=
name|UNEQ
expr_stmt|;
operator|*
name|bypass_code
operator|=
name|UNORDERED
expr_stmt|;
break|break;
case|case
name|NE
case|:
comment|/* NE - ZF=0 - fails on unordered */
operator|*
name|first_code
operator|=
name|LTGT
expr_stmt|;
operator|*
name|second_code
operator|=
name|UNORDERED
expr_stmt|;
break|break;
case|case
name|UNGE
case|:
comment|/* GEU - CF=0 - fails on unordered */
operator|*
name|first_code
operator|=
name|GE
expr_stmt|;
operator|*
name|second_code
operator|=
name|UNORDERED
expr_stmt|;
break|break;
case|case
name|UNGT
case|:
comment|/* GTU - CF=0& ZF=0 - fails on unordered */
operator|*
name|first_code
operator|=
name|GT
expr_stmt|;
operator|*
name|second_code
operator|=
name|UNORDERED
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TARGET_IEEE_FP
condition|)
block|{
operator|*
name|second_code
operator|=
name|NIL
expr_stmt|;
operator|*
name|bypass_code
operator|=
name|NIL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return cost of comparison done fcom + arithmetics operations on AX.    All following functions do use number of instructions as a cost metrics.    In future this should be tweaked to compute bytes for optimize_size and    take into account performance of various instructions on various CPUs.  */
end_comment

begin_function
specifier|static
name|int
name|ix86_fp_comparison_arithmetics_cost
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|)
block|{
if|if
condition|(
operator|!
name|TARGET_IEEE_FP
condition|)
return|return
literal|4
return|;
comment|/* The cost of code output by ix86_expand_fp_compare.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|UNLE
case|:
case|case
name|UNLT
case|:
case|case
name|LTGT
case|:
case|case
name|GT
case|:
case|case
name|GE
case|:
case|case
name|UNORDERED
case|:
case|case
name|ORDERED
case|:
case|case
name|UNEQ
case|:
return|return
literal|4
return|;
break|break;
case|case
name|LT
case|:
case|case
name|NE
case|:
case|case
name|EQ
case|:
case|case
name|UNGE
case|:
return|return
literal|5
return|;
break|break;
case|case
name|LE
case|:
case|case
name|UNGT
case|:
return|return
literal|6
return|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return cost of comparison done using fcomi operation.    See ix86_fp_comparison_arithmetics_cost for the metrics.  */
end_comment

begin_function
specifier|static
name|int
name|ix86_fp_comparison_fcomi_cost
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|)
block|{
name|enum
name|rtx_code
name|bypass_code
decl_stmt|,
name|first_code
decl_stmt|,
name|second_code
decl_stmt|;
comment|/* Return arbitrarily high cost when instruction is not supported - this      prevents gcc from using it.  */
if|if
condition|(
operator|!
name|TARGET_CMOVE
condition|)
return|return
literal|1024
return|;
name|ix86_fp_comparison_codes
argument_list|(
name|code
argument_list|,
operator|&
name|bypass_code
argument_list|,
operator|&
name|first_code
argument_list|,
operator|&
name|second_code
argument_list|)
expr_stmt|;
return|return
operator|(
name|bypass_code
operator|!=
name|NIL
operator|||
name|second_code
operator|!=
name|NIL
operator|)
operator|+
literal|2
return|;
block|}
end_function

begin_comment
comment|/* Return cost of comparison done using sahf operation.    See ix86_fp_comparison_arithmetics_cost for the metrics.  */
end_comment

begin_function
specifier|static
name|int
name|ix86_fp_comparison_sahf_cost
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|)
block|{
name|enum
name|rtx_code
name|bypass_code
decl_stmt|,
name|first_code
decl_stmt|,
name|second_code
decl_stmt|;
comment|/* Return arbitrarily high cost when instruction is not preferred - this      avoids gcc from using it.  */
if|if
condition|(
operator|!
name|TARGET_USE_SAHF
operator|&&
operator|!
name|optimize_size
condition|)
return|return
literal|1024
return|;
name|ix86_fp_comparison_codes
argument_list|(
name|code
argument_list|,
operator|&
name|bypass_code
argument_list|,
operator|&
name|first_code
argument_list|,
operator|&
name|second_code
argument_list|)
expr_stmt|;
return|return
operator|(
name|bypass_code
operator|!=
name|NIL
operator|||
name|second_code
operator|!=
name|NIL
operator|)
operator|+
literal|3
return|;
block|}
end_function

begin_comment
comment|/* Compute cost of the comparison done using any method.    See ix86_fp_comparison_arithmetics_cost for the metrics.  */
end_comment

begin_function
specifier|static
name|int
name|ix86_fp_comparison_cost
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|)
block|{
name|int
name|fcomi_cost
decl_stmt|,
name|sahf_cost
decl_stmt|,
name|arithmetics_cost
init|=
literal|1024
decl_stmt|;
name|int
name|min
decl_stmt|;
name|fcomi_cost
operator|=
name|ix86_fp_comparison_fcomi_cost
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|sahf_cost
operator|=
name|ix86_fp_comparison_sahf_cost
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|min
operator|=
name|arithmetics_cost
operator|=
name|ix86_fp_comparison_arithmetics_cost
argument_list|(
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|min
operator|>
name|sahf_cost
condition|)
name|min
operator|=
name|sahf_cost
expr_stmt|;
if|if
condition|(
name|min
operator|>
name|fcomi_cost
condition|)
name|min
operator|=
name|fcomi_cost
expr_stmt|;
return|return
name|min
return|;
block|}
end_function

begin_comment
comment|/* Generate insn patterns to do a floating point compare of OPERANDS.  */
end_comment

begin_function
specifier|static
name|rtx
name|ix86_expand_fp_compare
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|rtx
name|op0
parameter_list|,
name|rtx
name|op1
parameter_list|,
name|rtx
name|scratch
parameter_list|,
name|rtx
modifier|*
name|second_test
parameter_list|,
name|rtx
modifier|*
name|bypass_test
parameter_list|)
block|{
name|enum
name|machine_mode
name|fpcmp_mode
decl_stmt|,
name|intcmp_mode
decl_stmt|;
name|rtx
name|tmp
decl_stmt|,
name|tmp2
decl_stmt|;
name|int
name|cost
init|=
name|ix86_fp_comparison_cost
argument_list|(
name|code
argument_list|)
decl_stmt|;
name|enum
name|rtx_code
name|bypass_code
decl_stmt|,
name|first_code
decl_stmt|,
name|second_code
decl_stmt|;
name|fpcmp_mode
operator|=
name|ix86_fp_compare_mode
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|code
operator|=
name|ix86_prepare_fp_compare_args
argument_list|(
name|code
argument_list|,
operator|&
name|op0
argument_list|,
operator|&
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|second_test
condition|)
operator|*
name|second_test
operator|=
name|NULL_RTX
expr_stmt|;
if|if
condition|(
name|bypass_test
condition|)
operator|*
name|bypass_test
operator|=
name|NULL_RTX
expr_stmt|;
name|ix86_fp_comparison_codes
argument_list|(
name|code
argument_list|,
operator|&
name|bypass_code
argument_list|,
operator|&
name|first_code
argument_list|,
operator|&
name|second_code
argument_list|)
expr_stmt|;
comment|/* Do fcomi/sahf based test when profitable.  */
if|if
condition|(
operator|(
name|bypass_code
operator|==
name|NIL
operator|||
name|bypass_test
operator|)
operator|&&
operator|(
name|second_code
operator|==
name|NIL
operator|||
name|second_test
operator|)
operator|&&
name|ix86_fp_comparison_arithmetics_cost
argument_list|(
name|code
argument_list|)
operator|>
name|cost
condition|)
block|{
if|if
condition|(
name|TARGET_CMOVE
condition|)
block|{
name|tmp
operator|=
name|gen_rtx_COMPARE
argument_list|(
name|fpcmp_mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|fpcmp_mode
argument_list|,
name|FLAGS_REG
argument_list|)
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tmp
operator|=
name|gen_rtx_COMPARE
argument_list|(
name|fpcmp_mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|tmp2
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|HImode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|tmp
argument_list|)
argument_list|,
name|UNSPEC_FNSTSW
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|scratch
condition|)
name|scratch
operator|=
name|gen_reg_rtx
argument_list|(
name|HImode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|scratch
argument_list|,
name|tmp2
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_x86_sahf_1
argument_list|(
name|scratch
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* The FP codes work out to act like unsigned.  */
name|intcmp_mode
operator|=
name|fpcmp_mode
expr_stmt|;
name|code
operator|=
name|first_code
expr_stmt|;
if|if
condition|(
name|bypass_code
operator|!=
name|NIL
condition|)
operator|*
name|bypass_test
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|bypass_code
argument_list|,
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|intcmp_mode
argument_list|,
name|FLAGS_REG
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|second_code
operator|!=
name|NIL
condition|)
operator|*
name|second_test
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|second_code
argument_list|,
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|intcmp_mode
argument_list|,
name|FLAGS_REG
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Sadness wrt reg-stack pops killing fpsr -- gotta get fnstsw first.  */
name|tmp
operator|=
name|gen_rtx_COMPARE
argument_list|(
name|fpcmp_mode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|tmp2
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|HImode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|tmp
argument_list|)
argument_list|,
name|UNSPEC_FNSTSW
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|scratch
condition|)
name|scratch
operator|=
name|gen_reg_rtx
argument_list|(
name|HImode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|scratch
argument_list|,
name|tmp2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* In the unordered case, we have to check C2 for NaN's, which 	 doesn't happen to work out to anything nice combination-wise. 	 So do some bit twiddling on the value we've got in AH to come 	 up with an appropriate set of condition codes.  */
name|intcmp_mode
operator|=
name|CCNOmode
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|GT
case|:
case|case
name|UNGT
case|:
if|if
condition|(
name|code
operator|==
name|GT
operator|||
operator|!
name|TARGET_IEEE_FP
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_testqi_ext_ccno_0
argument_list|(
name|scratch
argument_list|,
name|GEN_INT
argument_list|(
literal|0x45
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|=
name|EQ
expr_stmt|;
block|}
else|else
block|{
name|emit_insn
argument_list|(
name|gen_andqi_ext_0
argument_list|(
name|scratch
argument_list|,
name|scratch
argument_list|,
name|GEN_INT
argument_list|(
literal|0x45
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_addqi_ext_1
argument_list|(
name|scratch
argument_list|,
name|scratch
argument_list|,
name|constm1_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_cmpqi_ext_3
argument_list|(
name|scratch
argument_list|,
name|GEN_INT
argument_list|(
literal|0x44
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|intcmp_mode
operator|=
name|CCmode
expr_stmt|;
name|code
operator|=
name|GEU
expr_stmt|;
block|}
break|break;
case|case
name|LT
case|:
case|case
name|UNLT
case|:
if|if
condition|(
name|code
operator|==
name|LT
operator|&&
name|TARGET_IEEE_FP
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_andqi_ext_0
argument_list|(
name|scratch
argument_list|,
name|scratch
argument_list|,
name|GEN_INT
argument_list|(
literal|0x45
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_cmpqi_ext_3
argument_list|(
name|scratch
argument_list|,
name|GEN_INT
argument_list|(
literal|0x01
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|intcmp_mode
operator|=
name|CCmode
expr_stmt|;
name|code
operator|=
name|EQ
expr_stmt|;
block|}
else|else
block|{
name|emit_insn
argument_list|(
name|gen_testqi_ext_ccno_0
argument_list|(
name|scratch
argument_list|,
name|GEN_INT
argument_list|(
literal|0x01
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|=
name|NE
expr_stmt|;
block|}
break|break;
case|case
name|GE
case|:
case|case
name|UNGE
case|:
if|if
condition|(
name|code
operator|==
name|GE
operator|||
operator|!
name|TARGET_IEEE_FP
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_testqi_ext_ccno_0
argument_list|(
name|scratch
argument_list|,
name|GEN_INT
argument_list|(
literal|0x05
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|=
name|EQ
expr_stmt|;
block|}
else|else
block|{
name|emit_insn
argument_list|(
name|gen_andqi_ext_0
argument_list|(
name|scratch
argument_list|,
name|scratch
argument_list|,
name|GEN_INT
argument_list|(
literal|0x45
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_xorqi_cc_ext_1
argument_list|(
name|scratch
argument_list|,
name|scratch
argument_list|,
name|GEN_INT
argument_list|(
literal|0x01
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|=
name|NE
expr_stmt|;
block|}
break|break;
case|case
name|LE
case|:
case|case
name|UNLE
case|:
if|if
condition|(
name|code
operator|==
name|LE
operator|&&
name|TARGET_IEEE_FP
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_andqi_ext_0
argument_list|(
name|scratch
argument_list|,
name|scratch
argument_list|,
name|GEN_INT
argument_list|(
literal|0x45
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_addqi_ext_1
argument_list|(
name|scratch
argument_list|,
name|scratch
argument_list|,
name|constm1_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_cmpqi_ext_3
argument_list|(
name|scratch
argument_list|,
name|GEN_INT
argument_list|(
literal|0x40
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|intcmp_mode
operator|=
name|CCmode
expr_stmt|;
name|code
operator|=
name|LTU
expr_stmt|;
block|}
else|else
block|{
name|emit_insn
argument_list|(
name|gen_testqi_ext_ccno_0
argument_list|(
name|scratch
argument_list|,
name|GEN_INT
argument_list|(
literal|0x45
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|=
name|NE
expr_stmt|;
block|}
break|break;
case|case
name|EQ
case|:
case|case
name|UNEQ
case|:
if|if
condition|(
name|code
operator|==
name|EQ
operator|&&
name|TARGET_IEEE_FP
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_andqi_ext_0
argument_list|(
name|scratch
argument_list|,
name|scratch
argument_list|,
name|GEN_INT
argument_list|(
literal|0x45
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_cmpqi_ext_3
argument_list|(
name|scratch
argument_list|,
name|GEN_INT
argument_list|(
literal|0x40
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|intcmp_mode
operator|=
name|CCmode
expr_stmt|;
name|code
operator|=
name|EQ
expr_stmt|;
block|}
else|else
block|{
name|emit_insn
argument_list|(
name|gen_testqi_ext_ccno_0
argument_list|(
name|scratch
argument_list|,
name|GEN_INT
argument_list|(
literal|0x40
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|=
name|NE
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|NE
case|:
case|case
name|LTGT
case|:
if|if
condition|(
name|code
operator|==
name|NE
operator|&&
name|TARGET_IEEE_FP
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_andqi_ext_0
argument_list|(
name|scratch
argument_list|,
name|scratch
argument_list|,
name|GEN_INT
argument_list|(
literal|0x45
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_xorqi_cc_ext_1
argument_list|(
name|scratch
argument_list|,
name|scratch
argument_list|,
name|GEN_INT
argument_list|(
literal|0x40
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|=
name|NE
expr_stmt|;
block|}
else|else
block|{
name|emit_insn
argument_list|(
name|gen_testqi_ext_ccno_0
argument_list|(
name|scratch
argument_list|,
name|GEN_INT
argument_list|(
literal|0x40
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|=
name|EQ
expr_stmt|;
block|}
break|break;
case|case
name|UNORDERED
case|:
name|emit_insn
argument_list|(
name|gen_testqi_ext_ccno_0
argument_list|(
name|scratch
argument_list|,
name|GEN_INT
argument_list|(
literal|0x04
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|=
name|NE
expr_stmt|;
break|break;
case|case
name|ORDERED
case|:
name|emit_insn
argument_list|(
name|gen_testqi_ext_ccno_0
argument_list|(
name|scratch
argument_list|,
name|GEN_INT
argument_list|(
literal|0x04
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|=
name|EQ
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Return the test that should be put into the flags user, i.e.      the bcc, scc, or cmov instruction.  */
return|return
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|intcmp_mode
argument_list|,
name|FLAGS_REG
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
return|;
block|}
end_function

begin_function
name|rtx
name|ix86_expand_compare
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|rtx
modifier|*
name|second_test
parameter_list|,
name|rtx
modifier|*
name|bypass_test
parameter_list|)
block|{
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|,
name|ret
decl_stmt|;
name|op0
operator|=
name|ix86_compare_op0
expr_stmt|;
name|op1
operator|=
name|ix86_compare_op1
expr_stmt|;
if|if
condition|(
name|second_test
condition|)
operator|*
name|second_test
operator|=
name|NULL_RTX
expr_stmt|;
if|if
condition|(
name|bypass_test
condition|)
operator|*
name|bypass_test
operator|=
name|NULL_RTX
expr_stmt|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
name|ret
operator|=
name|ix86_expand_fp_compare
argument_list|(
name|code
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|NULL_RTX
argument_list|,
name|second_test
argument_list|,
name|bypass_test
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|ix86_expand_int_compare
argument_list|(
name|code
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Return true if the CODE will result in nontrivial jump sequence.  */
end_comment

begin_function
name|bool
name|ix86_fp_jump_nontrivial_p
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|)
block|{
name|enum
name|rtx_code
name|bypass_code
decl_stmt|,
name|first_code
decl_stmt|,
name|second_code
decl_stmt|;
if|if
condition|(
operator|!
name|TARGET_CMOVE
condition|)
return|return
name|true
return|;
name|ix86_fp_comparison_codes
argument_list|(
name|code
argument_list|,
operator|&
name|bypass_code
argument_list|,
operator|&
name|first_code
argument_list|,
operator|&
name|second_code
argument_list|)
expr_stmt|;
return|return
name|bypass_code
operator|!=
name|NIL
operator|||
name|second_code
operator|!=
name|NIL
return|;
block|}
end_function

begin_function
name|void
name|ix86_expand_branch
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|rtx
name|label
parameter_list|)
block|{
name|rtx
name|tmp
decl_stmt|;
switch|switch
condition|(
name|GET_MODE
argument_list|(
name|ix86_compare_op0
argument_list|)
condition|)
block|{
case|case
name|QImode
case|:
case|case
name|HImode
case|:
case|case
name|SImode
case|:
name|simple
label|:
name|tmp
operator|=
name|ix86_expand_compare
argument_list|(
name|code
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|VOIDmode
argument_list|,
name|tmp
argument_list|,
name|gen_rtx_LABEL_REF
argument_list|(
name|VOIDmode
argument_list|,
name|label
argument_list|)
argument_list|,
name|pc_rtx
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|pc_rtx
argument_list|,
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|SFmode
case|:
case|case
name|DFmode
case|:
case|case
name|XFmode
case|:
block|{
name|rtvec
name|vec
decl_stmt|;
name|int
name|use_fcomi
decl_stmt|;
name|enum
name|rtx_code
name|bypass_code
decl_stmt|,
name|first_code
decl_stmt|,
name|second_code
decl_stmt|;
name|code
operator|=
name|ix86_prepare_fp_compare_args
argument_list|(
name|code
argument_list|,
operator|&
name|ix86_compare_op0
argument_list|,
operator|&
name|ix86_compare_op1
argument_list|)
expr_stmt|;
name|ix86_fp_comparison_codes
argument_list|(
name|code
argument_list|,
operator|&
name|bypass_code
argument_list|,
operator|&
name|first_code
argument_list|,
operator|&
name|second_code
argument_list|)
expr_stmt|;
comment|/* Check whether we will use the natural sequence with one jump.  If 	   so, we can expand jump early.  Otherwise delay expansion by 	   creating compound insn to not confuse optimizers.  */
if|if
condition|(
name|bypass_code
operator|==
name|NIL
operator|&&
name|second_code
operator|==
name|NIL
operator|&&
name|TARGET_CMOVE
condition|)
block|{
name|ix86_split_fp_branch
argument_list|(
name|code
argument_list|,
name|ix86_compare_op0
argument_list|,
name|ix86_compare_op1
argument_list|,
name|gen_rtx_LABEL_REF
argument_list|(
name|VOIDmode
argument_list|,
name|label
argument_list|)
argument_list|,
name|pc_rtx
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tmp
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|VOIDmode
argument_list|,
name|ix86_compare_op0
argument_list|,
name|ix86_compare_op1
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|VOIDmode
argument_list|,
name|tmp
argument_list|,
name|gen_rtx_LABEL_REF
argument_list|(
name|VOIDmode
argument_list|,
name|label
argument_list|)
argument_list|,
name|pc_rtx
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|pc_rtx
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|use_fcomi
operator|=
name|ix86_use_fcomi_compare
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|vec
operator|=
name|rtvec_alloc
argument_list|(
literal|3
operator|+
operator|!
name|use_fcomi
argument_list|)
expr_stmt|;
name|RTVEC_ELT
argument_list|(
name|vec
argument_list|,
literal|0
argument_list|)
operator|=
name|tmp
expr_stmt|;
name|RTVEC_ELT
argument_list|(
name|vec
argument_list|,
literal|1
argument_list|)
operator|=
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|CCFPmode
argument_list|,
literal|18
argument_list|)
argument_list|)
expr_stmt|;
name|RTVEC_ELT
argument_list|(
name|vec
argument_list|,
literal|2
argument_list|)
operator|=
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|CCFPmode
argument_list|,
literal|17
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|use_fcomi
condition|)
name|RTVEC_ELT
argument_list|(
name|vec
argument_list|,
literal|3
argument_list|)
operator|=
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_SCRATCH
argument_list|(
name|HImode
argument_list|)
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|vec
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
case|case
name|DImode
case|:
if|if
condition|(
name|TARGET_64BIT
condition|)
goto|goto
name|simple
goto|;
comment|/* Expand DImode branch into multiple compare+branch.  */
block|{
name|rtx
name|lo
index|[
literal|2
index|]
decl_stmt|,
name|hi
index|[
literal|2
index|]
decl_stmt|,
name|label2
decl_stmt|;
name|enum
name|rtx_code
name|code1
decl_stmt|,
name|code2
decl_stmt|,
name|code3
decl_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|ix86_compare_op0
argument_list|)
operator|&&
operator|!
name|CONSTANT_P
argument_list|(
name|ix86_compare_op1
argument_list|)
condition|)
block|{
name|tmp
operator|=
name|ix86_compare_op0
expr_stmt|;
name|ix86_compare_op0
operator|=
name|ix86_compare_op1
expr_stmt|;
name|ix86_compare_op1
operator|=
name|tmp
expr_stmt|;
name|code
operator|=
name|swap_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
name|split_di
argument_list|(
operator|&
name|ix86_compare_op0
argument_list|,
literal|1
argument_list|,
name|lo
operator|+
literal|0
argument_list|,
name|hi
operator|+
literal|0
argument_list|)
expr_stmt|;
name|split_di
argument_list|(
operator|&
name|ix86_compare_op1
argument_list|,
literal|1
argument_list|,
name|lo
operator|+
literal|1
argument_list|,
name|hi
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* When comparing for equality, we can use (hi0^hi1)|(lo0^lo1) to 	   avoid two branches.  This costs one extra insn, so disable when 	   optimizing for size.  */
if|if
condition|(
operator|(
name|code
operator|==
name|EQ
operator|||
name|code
operator|==
name|NE
operator|)
operator|&&
operator|(
operator|!
name|optimize_size
operator|||
name|hi
index|[
literal|1
index|]
operator|==
name|const0_rtx
operator|||
name|lo
index|[
literal|1
index|]
operator|==
name|const0_rtx
operator|)
condition|)
block|{
name|rtx
name|xor0
decl_stmt|,
name|xor1
decl_stmt|;
name|xor1
operator|=
name|hi
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|hi
index|[
literal|1
index|]
operator|!=
name|const0_rtx
condition|)
name|xor1
operator|=
name|expand_binop
argument_list|(
name|SImode
argument_list|,
name|xor_optab
argument_list|,
name|xor1
argument_list|,
name|hi
index|[
literal|1
index|]
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
name|xor0
operator|=
name|lo
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|lo
index|[
literal|1
index|]
operator|!=
name|const0_rtx
condition|)
name|xor0
operator|=
name|expand_binop
argument_list|(
name|SImode
argument_list|,
name|xor_optab
argument_list|,
name|xor0
argument_list|,
name|lo
index|[
literal|1
index|]
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|expand_binop
argument_list|(
name|SImode
argument_list|,
name|ior_optab
argument_list|,
name|xor1
argument_list|,
name|xor0
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
name|ix86_compare_op0
operator|=
name|tmp
expr_stmt|;
name|ix86_compare_op1
operator|=
name|const0_rtx
expr_stmt|;
name|ix86_expand_branch
argument_list|(
name|code
argument_list|,
name|label
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Otherwise, if we are doing less-than or greater-or-equal-than, 	   op1 is a constant and the low word is zero, then we can just 	   examine the high word.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|hi
index|[
literal|1
index|]
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|lo
index|[
literal|1
index|]
operator|==
name|const0_rtx
condition|)
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LT
case|:
case|case
name|LTU
case|:
case|case
name|GE
case|:
case|case
name|GEU
case|:
name|ix86_compare_op0
operator|=
name|hi
index|[
literal|0
index|]
expr_stmt|;
name|ix86_compare_op1
operator|=
name|hi
index|[
literal|1
index|]
expr_stmt|;
name|ix86_expand_branch
argument_list|(
name|code
argument_list|,
name|label
argument_list|)
expr_stmt|;
return|return;
default|default:
break|break;
block|}
comment|/* Otherwise, we need two or three jumps.  */
name|label2
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|code1
operator|=
name|code
expr_stmt|;
name|code2
operator|=
name|swap_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|code3
operator|=
name|unsigned_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LT
case|:
case|case
name|GT
case|:
case|case
name|LTU
case|:
case|case
name|GTU
case|:
break|break;
case|case
name|LE
case|:
name|code1
operator|=
name|LT
expr_stmt|;
name|code2
operator|=
name|GT
expr_stmt|;
break|break;
case|case
name|GE
case|:
name|code1
operator|=
name|GT
expr_stmt|;
name|code2
operator|=
name|LT
expr_stmt|;
break|break;
case|case
name|LEU
case|:
name|code1
operator|=
name|LTU
expr_stmt|;
name|code2
operator|=
name|GTU
expr_stmt|;
break|break;
case|case
name|GEU
case|:
name|code1
operator|=
name|GTU
expr_stmt|;
name|code2
operator|=
name|LTU
expr_stmt|;
break|break;
case|case
name|EQ
case|:
name|code1
operator|=
name|NIL
expr_stmt|;
name|code2
operator|=
name|NE
expr_stmt|;
break|break;
case|case
name|NE
case|:
name|code2
operator|=
name|NIL
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* 	 * a< b => 	 *    if (hi(a)< hi(b)) goto true; 	 *    if (hi(a)> hi(b)) goto false; 	 *    if (lo(a)< lo(b)) goto true; 	 *  false: 	 */
name|ix86_compare_op0
operator|=
name|hi
index|[
literal|0
index|]
expr_stmt|;
name|ix86_compare_op1
operator|=
name|hi
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|code1
operator|!=
name|NIL
condition|)
name|ix86_expand_branch
argument_list|(
name|code1
argument_list|,
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
name|code2
operator|!=
name|NIL
condition|)
name|ix86_expand_branch
argument_list|(
name|code2
argument_list|,
name|label2
argument_list|)
expr_stmt|;
name|ix86_compare_op0
operator|=
name|lo
index|[
literal|0
index|]
expr_stmt|;
name|ix86_compare_op1
operator|=
name|lo
index|[
literal|1
index|]
expr_stmt|;
name|ix86_expand_branch
argument_list|(
name|code3
argument_list|,
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
name|code2
operator|!=
name|NIL
condition|)
name|emit_label
argument_list|(
name|label2
argument_list|)
expr_stmt|;
return|return;
block|}
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Split branch based on floating point condition.  */
end_comment

begin_function
name|void
name|ix86_split_fp_branch
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|rtx
name|op1
parameter_list|,
name|rtx
name|op2
parameter_list|,
name|rtx
name|target1
parameter_list|,
name|rtx
name|target2
parameter_list|,
name|rtx
name|tmp
parameter_list|)
block|{
name|rtx
name|second
decl_stmt|,
name|bypass
decl_stmt|;
name|rtx
name|label
init|=
name|NULL_RTX
decl_stmt|;
name|rtx
name|condition
decl_stmt|;
name|int
name|bypass_probability
init|=
operator|-
literal|1
decl_stmt|,
name|second_probability
init|=
operator|-
literal|1
decl_stmt|,
name|probability
init|=
operator|-
literal|1
decl_stmt|;
name|rtx
name|i
decl_stmt|;
if|if
condition|(
name|target2
operator|!=
name|pc_rtx
condition|)
block|{
name|rtx
name|tmp
init|=
name|target2
decl_stmt|;
name|code
operator|=
name|reverse_condition_maybe_unordered
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|target2
operator|=
name|target1
expr_stmt|;
name|target1
operator|=
name|tmp
expr_stmt|;
block|}
name|condition
operator|=
name|ix86_expand_fp_compare
argument_list|(
name|code
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|,
name|tmp
argument_list|,
operator|&
name|second
argument_list|,
operator|&
name|bypass
argument_list|)
expr_stmt|;
if|if
condition|(
name|split_branch_probability
operator|>=
literal|0
condition|)
block|{
comment|/* Distribute the probabilities across the jumps. 	 Assume the BYPASS and SECOND to be always test 	 for UNORDERED.  */
name|probability
operator|=
name|split_branch_probability
expr_stmt|;
comment|/* Value of 1 is low enough to make no need for probability 	 to be updated.  Later we may run some experiments and see 	 if unordered values are more frequent in practice.  */
if|if
condition|(
name|bypass
condition|)
name|bypass_probability
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|second
condition|)
name|second_probability
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|bypass
operator|!=
name|NULL_RTX
condition|)
block|{
name|label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|i
operator|=
name|emit_jump_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|pc_rtx
argument_list|,
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|VOIDmode
argument_list|,
name|bypass
argument_list|,
name|gen_rtx_LABEL_REF
argument_list|(
name|VOIDmode
argument_list|,
name|label
argument_list|)
argument_list|,
name|pc_rtx
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bypass_probability
operator|>=
literal|0
condition|)
name|REG_NOTES
argument_list|(
name|i
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_BR_PROB
argument_list|,
name|GEN_INT
argument_list|(
name|bypass_probability
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
name|emit_jump_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|pc_rtx
argument_list|,
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|VOIDmode
argument_list|,
name|condition
argument_list|,
name|target1
argument_list|,
name|target2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|probability
operator|>=
literal|0
condition|)
name|REG_NOTES
argument_list|(
name|i
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_BR_PROB
argument_list|,
name|GEN_INT
argument_list|(
name|probability
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|second
operator|!=
name|NULL_RTX
condition|)
block|{
name|i
operator|=
name|emit_jump_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|pc_rtx
argument_list|,
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|VOIDmode
argument_list|,
name|second
argument_list|,
name|target1
argument_list|,
name|target2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|second_probability
operator|>=
literal|0
condition|)
name|REG_NOTES
argument_list|(
name|i
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_BR_PROB
argument_list|,
name|GEN_INT
argument_list|(
name|second_probability
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|label
operator|!=
name|NULL_RTX
condition|)
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ix86_expand_setcc
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|rtx
name|dest
parameter_list|)
block|{
name|rtx
name|ret
decl_stmt|,
name|tmp
decl_stmt|,
name|tmpreg
decl_stmt|,
name|equiv
decl_stmt|;
name|rtx
name|second_test
decl_stmt|,
name|bypass_test
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|ix86_compare_op0
argument_list|)
operator|==
name|DImode
operator|&&
operator|!
name|TARGET_64BIT
condition|)
return|return
literal|0
return|;
comment|/* FAIL */
if|if
condition|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
operator|!=
name|QImode
condition|)
name|abort
argument_list|()
expr_stmt|;
name|ret
operator|=
name|ix86_expand_compare
argument_list|(
name|code
argument_list|,
operator|&
name|second_test
argument_list|,
operator|&
name|bypass_test
argument_list|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|ret
argument_list|,
name|QImode
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|dest
expr_stmt|;
name|tmpreg
operator|=
name|dest
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|tmp
argument_list|,
name|ret
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bypass_test
operator|||
name|second_test
condition|)
block|{
name|rtx
name|test
init|=
name|second_test
decl_stmt|;
name|int
name|bypass
init|=
literal|0
decl_stmt|;
name|rtx
name|tmp2
init|=
name|gen_reg_rtx
argument_list|(
name|QImode
argument_list|)
decl_stmt|;
if|if
condition|(
name|bypass_test
condition|)
block|{
if|if
condition|(
name|second_test
condition|)
name|abort
argument_list|()
expr_stmt|;
name|test
operator|=
name|bypass_test
expr_stmt|;
name|bypass
operator|=
literal|1
expr_stmt|;
name|PUT_CODE
argument_list|(
name|test
argument_list|,
name|reverse_condition_maybe_unordered
argument_list|(
name|GET_CODE
argument_list|(
name|test
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|PUT_MODE
argument_list|(
name|test
argument_list|,
name|QImode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|tmp2
argument_list|,
name|test
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bypass
condition|)
name|emit_insn
argument_list|(
name|gen_andqi3
argument_list|(
name|tmp
argument_list|,
name|tmpreg
argument_list|,
name|tmp2
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_iorqi3
argument_list|(
name|tmp
argument_list|,
name|tmpreg
argument_list|,
name|tmp2
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Attach a REG_EQUAL note describing the comparison result.  */
name|equiv
operator|=
name|simplify_gen_relational
argument_list|(
name|code
argument_list|,
name|QImode
argument_list|,
name|GET_MODE
argument_list|(
name|ix86_compare_op0
argument_list|)
argument_list|,
name|ix86_compare_op0
argument_list|,
name|ix86_compare_op1
argument_list|)
expr_stmt|;
name|set_unique_reg_note
argument_list|(
name|get_last_insn
argument_list|()
argument_list|,
name|REG_EQUAL
argument_list|,
name|equiv
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
comment|/* DONE */
block|}
end_function

begin_comment
comment|/* Expand comparison setting or clearing carry flag.  Return true when    successful and set pop for the operation.  */
end_comment

begin_function
specifier|static
name|bool
name|ix86_expand_carry_flag_compare
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|rtx
name|op0
parameter_list|,
name|rtx
name|op1
parameter_list|,
name|rtx
modifier|*
name|pop
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|VOIDmode
condition|?
name|GET_MODE
argument_list|(
name|op0
argument_list|)
else|:
name|GET_MODE
argument_list|(
name|op1
argument_list|)
decl_stmt|;
comment|/* Do not handle DImode compares that go trought special path.  Also we can't      deal with FP compares yet.  This is possible to add.  */
if|if
condition|(
operator|(
name|mode
operator|==
name|DImode
operator|&&
operator|!
name|TARGET_64BIT
operator|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|rtx
name|second_test
init|=
name|NULL
decl_stmt|,
name|bypass_test
init|=
name|NULL
decl_stmt|;
name|rtx
name|compare_op
decl_stmt|,
name|compare_seq
decl_stmt|;
comment|/* Shortcut:  following common codes never translate into carry flag compares.  */
if|if
condition|(
name|code
operator|==
name|EQ
operator|||
name|code
operator|==
name|NE
operator|||
name|code
operator|==
name|UNEQ
operator|||
name|code
operator|==
name|LTGT
operator|||
name|code
operator|==
name|ORDERED
operator|||
name|code
operator|==
name|UNORDERED
condition|)
return|return
name|false
return|;
comment|/* These comparisons require zero flag; swap operands so they won't.  */
if|if
condition|(
operator|(
name|code
operator|==
name|GT
operator|||
name|code
operator|==
name|UNLE
operator|||
name|code
operator|==
name|LE
operator|||
name|code
operator|==
name|UNGT
operator|)
operator|&&
operator|!
name|TARGET_IEEE_FP
condition|)
block|{
name|rtx
name|tmp
init|=
name|op0
decl_stmt|;
name|op0
operator|=
name|op1
expr_stmt|;
name|op1
operator|=
name|tmp
expr_stmt|;
name|code
operator|=
name|swap_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
comment|/* Try to expand the comparison and verify that we end up with carry flag 	 based comparison.  This is fails to be true only when we decide to expand 	 comparison using arithmetic that is not too common scenario.  */
name|start_sequence
argument_list|()
expr_stmt|;
name|compare_op
operator|=
name|ix86_expand_fp_compare
argument_list|(
name|code
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|NULL_RTX
argument_list|,
operator|&
name|second_test
argument_list|,
operator|&
name|bypass_test
argument_list|)
expr_stmt|;
name|compare_seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
name|second_test
operator|||
name|bypass_test
condition|)
return|return
name|false
return|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|compare_op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CCFPmode
operator|||
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|compare_op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CCFPUmode
condition|)
name|code
operator|=
name|ix86_fp_compare_code_to_integer
argument_list|(
name|GET_CODE
argument_list|(
name|compare_op
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|code
operator|=
name|GET_CODE
argument_list|(
name|compare_op
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|!=
name|LTU
operator|&&
name|code
operator|!=
name|GEU
condition|)
return|return
name|false
return|;
name|emit_insn
argument_list|(
name|compare_seq
argument_list|)
expr_stmt|;
operator|*
name|pop
operator|=
name|compare_op
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
operator|!
name|INTEGRAL_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
return|return
name|false
return|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LTU
case|:
case|case
name|GEU
case|:
break|break;
comment|/* Convert a==0 into (unsigned)a<1.  */
case|case
name|EQ
case|:
case|case
name|NE
case|:
if|if
condition|(
name|op1
operator|!=
name|const0_rtx
condition|)
return|return
name|false
return|;
name|op1
operator|=
name|const1_rtx
expr_stmt|;
name|code
operator|=
operator|(
name|code
operator|==
name|EQ
condition|?
name|LTU
else|:
name|GEU
operator|)
expr_stmt|;
break|break;
comment|/* Convert a>b into b<a or a>=b-1.  */
case|case
name|GTU
case|:
case|case
name|LEU
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|op1
operator|=
name|gen_int_mode
argument_list|(
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|+
literal|1
argument_list|,
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Bail out on overflow.  We still can swap operands but that 	     would force loading of the constant into register.  */
if|if
condition|(
name|op1
operator|==
name|const0_rtx
operator|||
operator|!
name|x86_64_immediate_operand
argument_list|(
name|op1
argument_list|,
name|GET_MODE
argument_list|(
name|op1
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
name|code
operator|=
operator|(
name|code
operator|==
name|GTU
condition|?
name|GEU
else|:
name|LTU
operator|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|tmp
init|=
name|op1
decl_stmt|;
name|op1
operator|=
name|op0
expr_stmt|;
name|op0
operator|=
name|tmp
expr_stmt|;
name|code
operator|=
operator|(
name|code
operator|==
name|GTU
condition|?
name|LTU
else|:
name|GEU
operator|)
expr_stmt|;
block|}
break|break;
comment|/* Convert a>=0 into (unsigned)a<0x80000000.  */
case|case
name|LT
case|:
case|case
name|GE
case|:
if|if
condition|(
name|mode
operator|==
name|DImode
operator|||
name|op1
operator|!=
name|const0_rtx
condition|)
return|return
name|false
return|;
name|op1
operator|=
name|gen_int_mode
argument_list|(
literal|1
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
literal|1
operator|)
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|code
operator|=
operator|(
name|code
operator|==
name|LT
condition|?
name|GEU
else|:
name|LTU
operator|)
expr_stmt|;
break|break;
case|case
name|LE
case|:
case|case
name|GT
case|:
if|if
condition|(
name|mode
operator|==
name|DImode
operator|||
name|op1
operator|!=
name|constm1_rtx
condition|)
return|return
name|false
return|;
name|op1
operator|=
name|gen_int_mode
argument_list|(
literal|1
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
literal|1
operator|)
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|code
operator|=
operator|(
name|code
operator|==
name|LE
condition|?
name|GEU
else|:
name|LTU
operator|)
expr_stmt|;
break|break;
default|default:
return|return
name|false
return|;
block|}
comment|/* Swapping operands may cause constant to appear as first operand.  */
if|if
condition|(
operator|!
name|nonimmediate_operand
argument_list|(
name|op0
argument_list|,
name|VOIDmode
argument_list|)
condition|)
block|{
if|if
condition|(
name|no_new_pseudos
condition|)
return|return
name|false
return|;
name|op0
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
block|}
name|ix86_compare_op0
operator|=
name|op0
expr_stmt|;
name|ix86_compare_op1
operator|=
name|op1
expr_stmt|;
operator|*
name|pop
operator|=
name|ix86_expand_compare
argument_list|(
name|code
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
operator|*
name|pop
argument_list|)
operator|!=
name|LTU
operator|&&
name|GET_CODE
argument_list|(
operator|*
name|pop
argument_list|)
operator|!=
name|GEU
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
name|int
name|ix86_expand_int_movcc
parameter_list|(
name|rtx
name|operands
index|[]
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
decl_stmt|,
name|compare_code
decl_stmt|;
name|rtx
name|compare_seq
decl_stmt|,
name|compare_op
decl_stmt|;
name|rtx
name|second_test
decl_stmt|,
name|bypass_test
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|bool
name|sign_bit_compare_p
init|=
name|false
decl_stmt|;
empty_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|compare_op
operator|=
name|ix86_expand_compare
argument_list|(
name|code
argument_list|,
operator|&
name|second_test
argument_list|,
operator|&
name|bypass_test
argument_list|)
expr_stmt|;
name|compare_seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|compare_code
operator|=
name|GET_CODE
argument_list|(
name|compare_op
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ix86_compare_op1
operator|==
name|const0_rtx
operator|&&
operator|(
name|code
operator|==
name|GE
operator|||
name|code
operator|==
name|LT
operator|)
operator|)
operator|||
operator|(
name|ix86_compare_op1
operator|==
name|constm1_rtx
operator|&&
operator|(
name|code
operator|==
name|GT
operator|||
name|code
operator|==
name|LE
operator|)
operator|)
condition|)
name|sign_bit_compare_p
operator|=
name|true
expr_stmt|;
comment|/* Don't attempt mode expansion here -- if we had to expand 5 or 6      HImode insns, we'd be swallowed in word prefix ops.  */
if|if
condition|(
operator|(
name|mode
operator|!=
name|HImode
operator|||
name|TARGET_FAST_PREFIX
operator|)
operator|&&
operator|(
name|mode
operator|!=
name|DImode
operator|||
name|TARGET_64BIT
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|operands
index|[
literal|3
index|]
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|rtx
name|out
init|=
name|operands
index|[
literal|0
index|]
decl_stmt|;
name|HOST_WIDE_INT
name|ct
init|=
name|INTVAL
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|cf
init|=
name|INTVAL
argument_list|(
name|operands
index|[
literal|3
index|]
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|diff
decl_stmt|;
name|diff
operator|=
name|ct
operator|-
name|cf
expr_stmt|;
comment|/*  Sign bit compares are better done using shifts than we do by using 	  sbb.  */
if|if
condition|(
name|sign_bit_compare_p
operator|||
name|ix86_expand_carry_flag_compare
argument_list|(
name|code
argument_list|,
name|ix86_compare_op0
argument_list|,
name|ix86_compare_op1
argument_list|,
operator|&
name|compare_op
argument_list|)
condition|)
block|{
comment|/* Detect overlap between destination and compare sources.  */
name|rtx
name|tmp
init|=
name|out
decl_stmt|;
if|if
condition|(
operator|!
name|sign_bit_compare_p
condition|)
block|{
name|bool
name|fpcmp
init|=
name|false
decl_stmt|;
name|compare_code
operator|=
name|GET_CODE
argument_list|(
name|compare_op
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|compare_op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CCFPmode
operator|||
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|compare_op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CCFPUmode
condition|)
block|{
name|fpcmp
operator|=
name|true
expr_stmt|;
name|compare_code
operator|=
name|ix86_fp_compare_code_to_integer
argument_list|(
name|compare_code
argument_list|)
expr_stmt|;
block|}
comment|/* To simplify rest of code, restrict to the GEU case.  */
if|if
condition|(
name|compare_code
operator|==
name|LTU
condition|)
block|{
name|HOST_WIDE_INT
name|tmp
init|=
name|ct
decl_stmt|;
name|ct
operator|=
name|cf
expr_stmt|;
name|cf
operator|=
name|tmp
expr_stmt|;
name|compare_code
operator|=
name|reverse_condition
argument_list|(
name|compare_code
argument_list|)
expr_stmt|;
name|code
operator|=
name|reverse_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|fpcmp
condition|)
name|PUT_CODE
argument_list|(
name|compare_op
argument_list|,
name|reverse_condition_maybe_unordered
argument_list|(
name|GET_CODE
argument_list|(
name|compare_op
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|PUT_CODE
argument_list|(
name|compare_op
argument_list|,
name|reverse_condition
argument_list|(
name|GET_CODE
argument_list|(
name|compare_op
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|diff
operator|=
name|ct
operator|-
name|cf
expr_stmt|;
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|out
argument_list|,
name|ix86_compare_op0
argument_list|)
operator|||
name|reg_overlap_mentioned_p
argument_list|(
name|out
argument_list|,
name|ix86_compare_op1
argument_list|)
condition|)
name|tmp
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|DImode
condition|)
name|emit_insn
argument_list|(
name|gen_x86_movdicc_0_m1_rex64
argument_list|(
name|tmp
argument_list|,
name|compare_op
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_x86_movsicc_0_m1
argument_list|(
name|gen_lowpart
argument_list|(
name|SImode
argument_list|,
name|tmp
argument_list|)
argument_list|,
name|compare_op
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|code
operator|==
name|GT
operator|||
name|code
operator|==
name|GE
condition|)
name|code
operator|=
name|reverse_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
else|else
block|{
name|HOST_WIDE_INT
name|tmp
init|=
name|ct
decl_stmt|;
name|ct
operator|=
name|cf
expr_stmt|;
name|cf
operator|=
name|tmp
expr_stmt|;
name|diff
operator|=
name|ct
operator|-
name|cf
expr_stmt|;
block|}
name|tmp
operator|=
name|emit_store_flag
argument_list|(
name|tmp
argument_list|,
name|code
argument_list|,
name|ix86_compare_op0
argument_list|,
name|ix86_compare_op1
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|diff
operator|==
literal|1
condition|)
block|{
comment|/* 	       * cmpl op0,op1 	       * sbbl dest,dest 	       * [addl dest, ct] 	       * 	       * Size 5 - 8. 	       */
if|if
condition|(
name|ct
condition|)
name|tmp
operator|=
name|expand_simple_binop
argument_list|(
name|mode
argument_list|,
name|PLUS
argument_list|,
name|tmp
argument_list|,
name|GEN_INT
argument_list|(
name|ct
argument_list|)
argument_list|,
name|copy_rtx
argument_list|(
name|tmp
argument_list|)
argument_list|,
literal|1
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cf
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* 	       * cmpl op0,op1 	       * sbbl dest,dest 	       * orl $ct, dest 	       * 	       * Size 8. 	       */
name|tmp
operator|=
name|expand_simple_binop
argument_list|(
name|mode
argument_list|,
name|IOR
argument_list|,
name|tmp
argument_list|,
name|GEN_INT
argument_list|(
name|ct
argument_list|)
argument_list|,
name|copy_rtx
argument_list|(
name|tmp
argument_list|)
argument_list|,
literal|1
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|diff
operator|==
operator|-
literal|1
operator|&&
name|ct
condition|)
block|{
comment|/* 	       * cmpl op0,op1 	       * sbbl dest,dest 	       * notl dest 	       * [addl dest, cf] 	       * 	       * Size 8 - 11. 	       */
name|tmp
operator|=
name|expand_simple_unop
argument_list|(
name|mode
argument_list|,
name|NOT
argument_list|,
name|tmp
argument_list|,
name|copy_rtx
argument_list|(
name|tmp
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cf
condition|)
name|tmp
operator|=
name|expand_simple_binop
argument_list|(
name|mode
argument_list|,
name|PLUS
argument_list|,
name|copy_rtx
argument_list|(
name|tmp
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|cf
argument_list|)
argument_list|,
name|copy_rtx
argument_list|(
name|tmp
argument_list|)
argument_list|,
literal|1
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 	       * cmpl op0,op1 	       * sbbl dest,dest 	       * [notl dest] 	       * andl cf - ct, dest 	       * [addl dest, ct] 	       * 	       * Size 8 - 11. 	       */
if|if
condition|(
name|cf
operator|==
literal|0
condition|)
block|{
name|cf
operator|=
name|ct
expr_stmt|;
name|ct
operator|=
literal|0
expr_stmt|;
name|tmp
operator|=
name|expand_simple_unop
argument_list|(
name|mode
argument_list|,
name|NOT
argument_list|,
name|tmp
argument_list|,
name|copy_rtx
argument_list|(
name|tmp
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|tmp
operator|=
name|expand_simple_binop
argument_list|(
name|mode
argument_list|,
name|AND
argument_list|,
name|copy_rtx
argument_list|(
name|tmp
argument_list|)
argument_list|,
name|gen_int_mode
argument_list|(
name|cf
operator|-
name|ct
argument_list|,
name|mode
argument_list|)
argument_list|,
name|copy_rtx
argument_list|(
name|tmp
argument_list|)
argument_list|,
literal|1
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ct
condition|)
name|tmp
operator|=
name|expand_simple_binop
argument_list|(
name|mode
argument_list|,
name|PLUS
argument_list|,
name|copy_rtx
argument_list|(
name|tmp
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|ct
argument_list|)
argument_list|,
name|copy_rtx
argument_list|(
name|tmp
argument_list|)
argument_list|,
literal|1
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|tmp
argument_list|,
name|out
argument_list|)
condition|)
name|emit_move_insn
argument_list|(
name|copy_rtx
argument_list|(
name|out
argument_list|)
argument_list|,
name|copy_rtx
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
comment|/* DONE */
block|}
if|if
condition|(
name|diff
operator|<
literal|0
condition|)
block|{
name|HOST_WIDE_INT
name|tmp
decl_stmt|;
name|tmp
operator|=
name|ct
operator|,
name|ct
operator|=
name|cf
operator|,
name|cf
operator|=
name|tmp
expr_stmt|;
name|diff
operator|=
operator|-
name|diff
expr_stmt|;
if|if
condition|(
name|FLOAT_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|ix86_compare_op0
argument_list|)
argument_list|)
condition|)
block|{
comment|/* We may be reversing unordered compare to normal compare, that 		 is not valid in general (we may convert non-trapping condition 		 to trapping one), however on i386 we currently emit all 		 comparisons unordered.  */
name|compare_code
operator|=
name|reverse_condition_maybe_unordered
argument_list|(
name|compare_code
argument_list|)
expr_stmt|;
name|code
operator|=
name|reverse_condition_maybe_unordered
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|compare_code
operator|=
name|reverse_condition
argument_list|(
name|compare_code
argument_list|)
expr_stmt|;
name|code
operator|=
name|reverse_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
block|}
name|compare_code
operator|=
name|NIL
expr_stmt|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|ix86_compare_op0
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|GET_CODE
argument_list|(
name|ix86_compare_op1
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|ix86_compare_op1
operator|==
name|const0_rtx
operator|&&
operator|(
name|code
operator|==
name|LT
operator|||
name|code
operator|==
name|GE
operator|)
condition|)
name|compare_code
operator|=
name|code
expr_stmt|;
elseif|else
if|if
condition|(
name|ix86_compare_op1
operator|==
name|constm1_rtx
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|LE
condition|)
name|compare_code
operator|=
name|LT
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|GT
condition|)
name|compare_code
operator|=
name|GE
expr_stmt|;
block|}
block|}
comment|/* Optimize dest = (op0< 0) ? -1 : cf.  */
if|if
condition|(
name|compare_code
operator|!=
name|NIL
operator|&&
name|GET_MODE
argument_list|(
name|ix86_compare_op0
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|out
argument_list|)
operator|&&
operator|(
name|cf
operator|==
operator|-
literal|1
operator|||
name|ct
operator|==
operator|-
literal|1
operator|)
condition|)
block|{
comment|/* If lea code below could be used, only optimize 	     if it results in a 2 insn sequence.  */
if|if
condition|(
operator|!
operator|(
name|diff
operator|==
literal|1
operator|||
name|diff
operator|==
literal|2
operator|||
name|diff
operator|==
literal|4
operator|||
name|diff
operator|==
literal|8
operator|||
name|diff
operator|==
literal|3
operator|||
name|diff
operator|==
literal|5
operator|||
name|diff
operator|==
literal|9
operator|)
operator|||
operator|(
name|compare_code
operator|==
name|LT
operator|&&
name|ct
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|compare_code
operator|==
name|GE
operator|&&
name|cf
operator|==
operator|-
literal|1
operator|)
condition|)
block|{
comment|/* 	       * notl op1	(if necessary) 	       * sarl $31, op1 	       * orl cf, op1 	       */
if|if
condition|(
name|ct
operator|!=
operator|-
literal|1
condition|)
block|{
name|cf
operator|=
name|ct
expr_stmt|;
name|ct
operator|=
operator|-
literal|1
expr_stmt|;
name|code
operator|=
name|reverse_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
name|out
operator|=
name|emit_store_flag
argument_list|(
name|out
argument_list|,
name|code
argument_list|,
name|ix86_compare_op0
argument_list|,
name|ix86_compare_op1
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|out
operator|=
name|expand_simple_binop
argument_list|(
name|mode
argument_list|,
name|IOR
argument_list|,
name|out
argument_list|,
name|GEN_INT
argument_list|(
name|cf
argument_list|)
argument_list|,
name|out
argument_list|,
literal|1
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
operator|!=
name|operands
index|[
literal|0
index|]
condition|)
name|emit_move_insn
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|out
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
comment|/* DONE */
block|}
block|}
if|if
condition|(
operator|(
name|diff
operator|==
literal|1
operator|||
name|diff
operator|==
literal|2
operator|||
name|diff
operator|==
literal|4
operator|||
name|diff
operator|==
literal|8
operator|||
name|diff
operator|==
literal|3
operator|||
name|diff
operator|==
literal|5
operator|||
name|diff
operator|==
literal|9
operator|)
operator|&&
operator|(
operator|(
name|mode
operator|!=
name|QImode
operator|&&
name|mode
operator|!=
name|HImode
operator|)
operator|||
operator|!
name|TARGET_PARTIAL_REG_STALL
operator|)
operator|&&
operator|(
name|mode
operator|!=
name|DImode
operator|||
name|x86_64_sign_extended_value
argument_list|(
name|GEN_INT
argument_list|(
name|cf
argument_list|)
argument_list|)
operator|)
condition|)
block|{
comment|/* 	   * xorl dest,dest 	   * cmpl op1,op2 	   * setcc dest 	   * lea cf(dest*(ct-cf)),dest 	   * 	   * Size 14. 	   * 	   * This also catches the degenerate setcc-only case. 	   */
name|rtx
name|tmp
decl_stmt|;
name|int
name|nops
decl_stmt|;
name|out
operator|=
name|emit_store_flag
argument_list|(
name|out
argument_list|,
name|code
argument_list|,
name|ix86_compare_op0
argument_list|,
name|ix86_compare_op1
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|nops
operator|=
literal|0
expr_stmt|;
comment|/* On x86_64 the lea instruction operates on Pmode, so we need 	     to get arithmetics done in proper mode to match.  */
if|if
condition|(
name|diff
operator|==
literal|1
condition|)
name|tmp
operator|=
name|copy_rtx
argument_list|(
name|out
argument_list|)
expr_stmt|;
else|else
block|{
name|rtx
name|out1
decl_stmt|;
name|out1
operator|=
name|copy_rtx
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_MULT
argument_list|(
name|mode
argument_list|,
name|out1
argument_list|,
name|GEN_INT
argument_list|(
name|diff
operator|&
operator|~
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|nops
operator|++
expr_stmt|;
if|if
condition|(
name|diff
operator|&
literal|1
condition|)
block|{
name|tmp
operator|=
name|gen_rtx_PLUS
argument_list|(
name|mode
argument_list|,
name|tmp
argument_list|,
name|out1
argument_list|)
expr_stmt|;
name|nops
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cf
operator|!=
literal|0
condition|)
block|{
name|tmp
operator|=
name|gen_rtx_PLUS
argument_list|(
name|mode
argument_list|,
name|tmp
argument_list|,
name|GEN_INT
argument_list|(
name|cf
argument_list|)
argument_list|)
expr_stmt|;
name|nops
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|tmp
argument_list|,
name|out
argument_list|)
condition|)
block|{
if|if
condition|(
name|nops
operator|==
literal|1
condition|)
name|out
operator|=
name|force_operand
argument_list|(
name|tmp
argument_list|,
name|copy_rtx
argument_list|(
name|out
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|copy_rtx
argument_list|(
name|out
argument_list|)
argument_list|,
name|copy_rtx
argument_list|(
name|tmp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|out
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
name|emit_move_insn
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|copy_rtx
argument_list|(
name|out
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
comment|/* DONE */
block|}
comment|/*        * General case:			Jumpful:        *   xorl dest,dest		cmpl op1, op2        *   cmpl op1, op2		movl ct, dest        *   setcc dest			jcc 1f        *   decl dest			movl cf, dest        *   andl (cf-ct),dest		1:        *   addl ct,dest        *        * Size 20.			Size 14.        *        * This is reasonably steep, but branch mispredict costs are        * high on modern cpus, so consider failing only if optimizing        * for space.        */
if|if
condition|(
operator|(
operator|!
name|TARGET_CMOVE
operator|||
operator|(
name|mode
operator|==
name|QImode
operator|&&
name|TARGET_PARTIAL_REG_STALL
operator|)
operator|)
operator|&&
name|BRANCH_COST
operator|>=
literal|2
condition|)
block|{
if|if
condition|(
name|cf
operator|==
literal|0
condition|)
block|{
name|cf
operator|=
name|ct
expr_stmt|;
name|ct
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|FLOAT_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|ix86_compare_op0
argument_list|)
argument_list|)
condition|)
comment|/* We may be reversing unordered compare to normal compare, 		   that is not valid in general (we may convert non-trapping 		   condition to trapping one), however on i386 we currently 		   emit all comparisons unordered.  */
name|code
operator|=
name|reverse_condition_maybe_unordered
argument_list|(
name|code
argument_list|)
expr_stmt|;
else|else
block|{
name|code
operator|=
name|reverse_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare_code
operator|!=
name|NIL
condition|)
name|compare_code
operator|=
name|reverse_condition
argument_list|(
name|compare_code
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|compare_code
operator|!=
name|NIL
condition|)
block|{
comment|/* notl op1	(if needed) 		 sarl $31, op1 		 andl (cf-ct), op1 		 addl ct, op1  		 For x< 0 (resp. x<= -1) there will be no notl, 		 so if possible swap the constants to get rid of the 		 complement. 		 True/false will be -1/0 while code below (store flag 		 followed by decrement) is 0/-1, so the constants need 		 to be exchanged once more.  */
if|if
condition|(
name|compare_code
operator|==
name|GE
operator|||
operator|!
name|cf
condition|)
block|{
name|code
operator|=
name|reverse_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|compare_code
operator|=
name|LT
expr_stmt|;
block|}
else|else
block|{
name|HOST_WIDE_INT
name|tmp
init|=
name|cf
decl_stmt|;
name|cf
operator|=
name|ct
expr_stmt|;
name|ct
operator|=
name|tmp
expr_stmt|;
block|}
name|out
operator|=
name|emit_store_flag
argument_list|(
name|out
argument_list|,
name|code
argument_list|,
name|ix86_compare_op0
argument_list|,
name|ix86_compare_op1
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|out
operator|=
name|emit_store_flag
argument_list|(
name|out
argument_list|,
name|code
argument_list|,
name|ix86_compare_op0
argument_list|,
name|ix86_compare_op1
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|out
operator|=
name|expand_simple_binop
argument_list|(
name|mode
argument_list|,
name|PLUS
argument_list|,
name|copy_rtx
argument_list|(
name|out
argument_list|)
argument_list|,
name|constm1_rtx
argument_list|,
name|copy_rtx
argument_list|(
name|out
argument_list|)
argument_list|,
literal|1
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
block|}
name|out
operator|=
name|expand_simple_binop
argument_list|(
name|mode
argument_list|,
name|AND
argument_list|,
name|copy_rtx
argument_list|(
name|out
argument_list|)
argument_list|,
name|gen_int_mode
argument_list|(
name|cf
operator|-
name|ct
argument_list|,
name|mode
argument_list|)
argument_list|,
name|copy_rtx
argument_list|(
name|out
argument_list|)
argument_list|,
literal|1
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ct
condition|)
name|out
operator|=
name|expand_simple_binop
argument_list|(
name|mode
argument_list|,
name|PLUS
argument_list|,
name|copy_rtx
argument_list|(
name|out
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|ct
argument_list|)
argument_list|,
name|copy_rtx
argument_list|(
name|out
argument_list|)
argument_list|,
literal|1
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|out
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
name|emit_move_insn
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|copy_rtx
argument_list|(
name|out
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
comment|/* DONE */
block|}
block|}
if|if
condition|(
operator|!
name|TARGET_CMOVE
operator|||
operator|(
name|mode
operator|==
name|QImode
operator|&&
name|TARGET_PARTIAL_REG_STALL
operator|)
condition|)
block|{
comment|/* Try a few things more with specific constants and a variable.  */
name|optab
name|op
decl_stmt|;
name|rtx
name|var
decl_stmt|,
name|orig_out
decl_stmt|,
name|out
decl_stmt|,
name|tmp
decl_stmt|;
if|if
condition|(
name|BRANCH_COST
operator|<=
literal|2
condition|)
return|return
literal|0
return|;
comment|/* FAIL */
comment|/* If one of the two operands is an interesting constant, load a 	 constant with the above and mask it in with a logical operation.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|var
operator|=
name|operands
index|[
literal|3
index|]
expr_stmt|;
if|if
condition|(
name|INTVAL
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|==
literal|0
operator|&&
name|operands
index|[
literal|3
index|]
operator|!=
name|constm1_rtx
condition|)
name|operands
index|[
literal|3
index|]
operator|=
name|constm1_rtx
operator|,
name|op
operator|=
name|and_optab
expr_stmt|;
elseif|else
if|if
condition|(
name|INTVAL
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|operands
index|[
literal|3
index|]
operator|!=
name|const0_rtx
condition|)
name|operands
index|[
literal|3
index|]
operator|=
name|const0_rtx
operator|,
name|op
operator|=
name|ior_optab
expr_stmt|;
else|else
return|return
literal|0
return|;
comment|/* FAIL */
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|3
index|]
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|var
operator|=
name|operands
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|INTVAL
argument_list|(
name|operands
index|[
literal|3
index|]
argument_list|)
operator|==
literal|0
operator|&&
name|operands
index|[
literal|2
index|]
operator|!=
name|constm1_rtx
condition|)
name|operands
index|[
literal|2
index|]
operator|=
name|constm1_rtx
operator|,
name|op
operator|=
name|and_optab
expr_stmt|;
elseif|else
if|if
condition|(
name|INTVAL
argument_list|(
name|operands
index|[
literal|3
index|]
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|operands
index|[
literal|3
index|]
operator|!=
name|const0_rtx
condition|)
name|operands
index|[
literal|2
index|]
operator|=
name|const0_rtx
operator|,
name|op
operator|=
name|ior_optab
expr_stmt|;
else|else
return|return
literal|0
return|;
comment|/* FAIL */
block|}
else|else
return|return
literal|0
return|;
comment|/* FAIL */
name|orig_out
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
name|tmp
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|operands
index|[
literal|0
index|]
operator|=
name|tmp
expr_stmt|;
comment|/* Recurse to get the constant loaded.  */
if|if
condition|(
name|ix86_expand_int_movcc
argument_list|(
name|operands
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* FAIL */
comment|/* Mask in the interesting variable.  */
name|out
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|op
argument_list|,
name|var
argument_list|,
name|tmp
argument_list|,
name|orig_out
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|out
argument_list|,
name|orig_out
argument_list|)
condition|)
name|emit_move_insn
argument_list|(
name|copy_rtx
argument_list|(
name|orig_out
argument_list|)
argument_list|,
name|copy_rtx
argument_list|(
name|out
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
comment|/* DONE */
block|}
comment|/*    * For comparison with above,    *    * movl cf,dest    * movl ct,tmp    * cmpl op1,op2    * cmovcc tmp,dest    *    * Size 15.    */
if|if
condition|(
operator|!
name|nonimmediate_operand
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|,
name|mode
argument_list|)
condition|)
name|operands
index|[
literal|2
index|]
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nonimmediate_operand
argument_list|(
name|operands
index|[
literal|3
index|]
argument_list|,
name|mode
argument_list|)
condition|)
name|operands
index|[
literal|3
index|]
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|operands
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|bypass_test
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
name|rtx
name|tmp
init|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|tmp
argument_list|,
name|operands
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|operands
index|[
literal|3
index|]
operator|=
name|tmp
expr_stmt|;
block|}
if|if
condition|(
name|second_test
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
name|rtx
name|tmp
init|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|tmp
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|operands
index|[
literal|2
index|]
operator|=
name|tmp
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|register_operand
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|,
name|VOIDmode
argument_list|)
operator|&&
operator|(
name|mode
operator|==
name|QImode
operator|||
operator|!
name|register_operand
argument_list|(
name|operands
index|[
literal|3
index|]
argument_list|,
name|VOIDmode
argument_list|)
operator|)
condition|)
name|operands
index|[
literal|2
index|]
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|QImode
operator|&&
operator|!
name|register_operand
argument_list|(
name|operands
index|[
literal|3
index|]
argument_list|,
name|VOIDmode
argument_list|)
condition|)
name|operands
index|[
literal|3
index|]
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|operands
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|compare_seq
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|mode
argument_list|,
name|compare_op
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|,
name|operands
index|[
literal|3
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bypass_test
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|copy_rtx
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|mode
argument_list|,
name|bypass_test
argument_list|,
name|copy_rtx
argument_list|(
name|operands
index|[
literal|3
index|]
argument_list|)
argument_list|,
name|copy_rtx
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|second_test
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|copy_rtx
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|mode
argument_list|,
name|second_test
argument_list|,
name|copy_rtx
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
argument_list|,
name|copy_rtx
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
comment|/* DONE */
block|}
end_function

begin_function
name|int
name|ix86_expand_fp_movcc
parameter_list|(
name|rtx
name|operands
index|[]
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
decl_stmt|;
name|rtx
name|tmp
decl_stmt|;
name|rtx
name|compare_op
decl_stmt|,
name|second_test
decl_stmt|,
name|bypass_test
decl_stmt|;
comment|/* For SF/DFmode conditional moves based on comparisons      in same mode, we may want to use SSE min/max instructions.  */
if|if
condition|(
operator|(
operator|(
name|TARGET_SSE_MATH
operator|&&
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|SFmode
operator|)
operator|||
operator|(
name|TARGET_SSE2
operator|&&
name|TARGET_SSE_MATH
operator|&&
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|DFmode
operator|)
operator|)
operator|&&
name|GET_MODE
argument_list|(
name|ix86_compare_op0
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
comment|/* The SSE comparisons does not support the LTGT/UNEQ pair.  */
operator|&&
operator|(
operator|!
name|TARGET_IEEE_FP
operator|||
operator|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|!=
name|LTGT
operator|&&
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|!=
name|UNEQ
operator|)
operator|)
comment|/* We may be called from the post-reload splitter.  */
operator|&&
operator|(
operator|!
name|REG_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|||
name|SSE_REG_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|||
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
condition|)
block|{
name|rtx
name|op0
init|=
name|ix86_compare_op0
decl_stmt|,
name|op1
init|=
name|ix86_compare_op1
decl_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* See if we have (cross) match between comparison operands and          conditional move operands.  */
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|,
name|op1
argument_list|)
condition|)
block|{
name|rtx
name|tmp
init|=
name|op0
decl_stmt|;
name|op0
operator|=
name|op1
expr_stmt|;
name|op1
operator|=
name|tmp
expr_stmt|;
name|code
operator|=
name|reverse_condition_maybe_unordered
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|,
name|op0
argument_list|)
operator|&&
name|rtx_equal_p
argument_list|(
name|operands
index|[
literal|3
index|]
argument_list|,
name|op1
argument_list|)
condition|)
block|{
comment|/* Check for min operation.  */
if|if
condition|(
name|code
operator|==
name|LT
operator|||
name|code
operator|==
name|UNLE
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|UNLE
condition|)
block|{
name|rtx
name|tmp
init|=
name|op0
decl_stmt|;
name|op0
operator|=
name|op1
expr_stmt|;
name|op1
operator|=
name|tmp
expr_stmt|;
block|}
name|operands
index|[
literal|0
index|]
operator|=
name|force_reg
argument_list|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|memory_operand
argument_list|(
name|op0
argument_list|,
name|VOIDmode
argument_list|)
condition|)
name|op0
operator|=
name|force_reg
argument_list|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|SFmode
condition|)
name|emit_insn
argument_list|(
name|gen_minsf3
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_mindf3
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Check for max operation.  */
if|if
condition|(
name|code
operator|==
name|GT
operator|||
name|code
operator|==
name|UNGE
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|UNGE
condition|)
block|{
name|rtx
name|tmp
init|=
name|op0
decl_stmt|;
name|op0
operator|=
name|op1
expr_stmt|;
name|op1
operator|=
name|tmp
expr_stmt|;
block|}
name|operands
index|[
literal|0
index|]
operator|=
name|force_reg
argument_list|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|memory_operand
argument_list|(
name|op0
argument_list|,
name|VOIDmode
argument_list|)
condition|)
name|op0
operator|=
name|force_reg
argument_list|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|SFmode
condition|)
name|emit_insn
argument_list|(
name|gen_maxsf3
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_maxdf3
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
comment|/* Manage condition to be sse_comparison_operator.  In case we are 	 in non-ieee mode, try to canonicalize the destination operand 	 to be first in the comparison - this helps reload to avoid extra 	 moves.  */
if|if
condition|(
operator|!
name|sse_comparison_operator
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|VOIDmode
argument_list|)
operator|||
operator|(
name|rtx_equal_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|ix86_compare_op1
argument_list|)
operator|&&
operator|!
name|TARGET_IEEE_FP
operator|)
condition|)
block|{
name|rtx
name|tmp
init|=
name|ix86_compare_op0
decl_stmt|;
name|ix86_compare_op0
operator|=
name|ix86_compare_op1
expr_stmt|;
name|ix86_compare_op1
operator|=
name|tmp
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|swap_condition
argument_list|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
argument_list|,
name|VOIDmode
argument_list|,
name|ix86_compare_op0
argument_list|,
name|ix86_compare_op1
argument_list|)
expr_stmt|;
block|}
comment|/* Similarly try to manage result to be first operand of conditional 	 move. We also don't support the NE comparison on SSE, so try to 	 avoid it.  */
if|if
condition|(
operator|(
name|rtx_equal_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|3
index|]
argument_list|)
operator|&&
operator|(
operator|!
name|TARGET_IEEE_FP
operator|||
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|!=
name|EQ
operator|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|NE
operator|&&
name|TARGET_IEEE_FP
operator|)
condition|)
block|{
name|rtx
name|tmp
init|=
name|operands
index|[
literal|2
index|]
decl_stmt|;
name|operands
index|[
literal|2
index|]
operator|=
name|operands
index|[
literal|3
index|]
expr_stmt|;
name|operands
index|[
literal|3
index|]
operator|=
name|tmp
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|reverse_condition_maybe_unordered
argument_list|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
argument_list|,
name|VOIDmode
argument_list|,
name|ix86_compare_op0
argument_list|,
name|ix86_compare_op1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|SFmode
condition|)
name|emit_insn
argument_list|(
name|gen_sse_movsfcc
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|,
name|operands
index|[
literal|3
index|]
argument_list|,
name|ix86_compare_op0
argument_list|,
name|ix86_compare_op1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_sse_movdfcc
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|,
name|operands
index|[
literal|3
index|]
argument_list|,
name|ix86_compare_op0
argument_list|,
name|ix86_compare_op1
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* The floating point conditional move instructions don't directly      support conditions resulting from a signed integer comparison.  */
name|code
operator|=
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|compare_op
operator|=
name|ix86_expand_compare
argument_list|(
name|code
argument_list|,
operator|&
name|second_test
argument_list|,
operator|&
name|bypass_test
argument_list|)
expr_stmt|;
comment|/* The floating point conditional move instructions don't directly      support signed integer comparisons.  */
if|if
condition|(
operator|!
name|fcmov_comparison_operator
argument_list|(
name|compare_op
argument_list|,
name|VOIDmode
argument_list|)
condition|)
block|{
if|if
condition|(
name|second_test
operator|!=
name|NULL
operator|||
name|bypass_test
operator|!=
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|tmp
operator|=
name|gen_reg_rtx
argument_list|(
name|QImode
argument_list|)
expr_stmt|;
name|ix86_expand_setcc
argument_list|(
name|code
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|code
operator|=
name|NE
expr_stmt|;
name|ix86_compare_op0
operator|=
name|tmp
expr_stmt|;
name|ix86_compare_op1
operator|=
name|const0_rtx
expr_stmt|;
name|compare_op
operator|=
name|ix86_expand_compare
argument_list|(
name|code
argument_list|,
operator|&
name|second_test
argument_list|,
operator|&
name|bypass_test
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bypass_test
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
name|tmp
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|tmp
argument_list|,
name|operands
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|operands
index|[
literal|3
index|]
operator|=
name|tmp
expr_stmt|;
block|}
if|if
condition|(
name|second_test
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
name|tmp
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|tmp
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|operands
index|[
literal|2
index|]
operator|=
name|tmp
expr_stmt|;
block|}
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|compare_op
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|,
name|operands
index|[
literal|3
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bypass_test
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|bypass_test
argument_list|,
name|operands
index|[
literal|3
index|]
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|second_test
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|second_test
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Expand conditional increment or decrement using adb/sbb instructions.    The default case using setcc followed by the conditional move can be    done by generic code.  */
end_comment

begin_function
name|int
name|ix86_expand_int_addcc
parameter_list|(
name|rtx
name|operands
index|[]
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|rtx
name|compare_op
decl_stmt|;
name|rtx
name|val
init|=
name|const0_rtx
decl_stmt|;
name|bool
name|fpcmp
init|=
name|false
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|operands
index|[
literal|3
index|]
operator|!=
name|const1_rtx
operator|&&
name|operands
index|[
literal|3
index|]
operator|!=
name|constm1_rtx
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|ix86_expand_carry_flag_compare
argument_list|(
name|code
argument_list|,
name|ix86_compare_op0
argument_list|,
name|ix86_compare_op1
argument_list|,
operator|&
name|compare_op
argument_list|)
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|compare_op
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|compare_op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CCFPmode
operator|||
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|compare_op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CCFPUmode
condition|)
block|{
name|fpcmp
operator|=
name|true
expr_stmt|;
name|code
operator|=
name|ix86_fp_compare_code_to_integer
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|!=
name|LTU
condition|)
block|{
name|val
operator|=
name|constm1_rtx
expr_stmt|;
if|if
condition|(
name|fpcmp
condition|)
name|PUT_CODE
argument_list|(
name|compare_op
argument_list|,
name|reverse_condition_maybe_unordered
argument_list|(
name|GET_CODE
argument_list|(
name|compare_op
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|PUT_CODE
argument_list|(
name|compare_op
argument_list|,
name|reverse_condition
argument_list|(
name|GET_CODE
argument_list|(
name|compare_op
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|PUT_MODE
argument_list|(
name|compare_op
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/* Construct either adc or sbb insn.  */
if|if
condition|(
operator|(
name|code
operator|==
name|LTU
operator|)
operator|==
operator|(
name|operands
index|[
literal|3
index|]
operator|==
name|constm1_rtx
operator|)
condition|)
block|{
switch|switch
condition|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
case|case
name|QImode
case|:
name|emit_insn
argument_list|(
name|gen_subqi3_carry
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|,
name|val
argument_list|,
name|compare_op
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|HImode
case|:
name|emit_insn
argument_list|(
name|gen_subhi3_carry
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|,
name|val
argument_list|,
name|compare_op
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SImode
case|:
name|emit_insn
argument_list|(
name|gen_subsi3_carry
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|,
name|val
argument_list|,
name|compare_op
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DImode
case|:
name|emit_insn
argument_list|(
name|gen_subdi3_carry_rex64
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|,
name|val
argument_list|,
name|compare_op
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
case|case
name|QImode
case|:
name|emit_insn
argument_list|(
name|gen_addqi3_carry
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|,
name|val
argument_list|,
name|compare_op
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|HImode
case|:
name|emit_insn
argument_list|(
name|gen_addhi3_carry
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|,
name|val
argument_list|,
name|compare_op
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SImode
case|:
name|emit_insn
argument_list|(
name|gen_addsi3_carry
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|,
name|val
argument_list|,
name|compare_op
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DImode
case|:
name|emit_insn
argument_list|(
name|gen_adddi3_carry_rex64
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|,
name|val
argument_list|,
name|compare_op
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
comment|/* DONE */
block|}
end_function

begin_comment
comment|/* Split operands 0 and 1 into SImode parts.  Similar to split_di, but    works for floating pointer parameters and nonoffsetable memories.    For pushes, it returns just stack offsets; the values will be saved    in the right order.  Maximally three parts are generated.  */
end_comment

begin_function
specifier|static
name|int
name|ix86_split_to_parts
parameter_list|(
name|rtx
name|operand
parameter_list|,
name|rtx
modifier|*
name|parts
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|int
name|size
decl_stmt|;
if|if
condition|(
operator|!
name|TARGET_64BIT
condition|)
name|size
operator|=
name|mode
operator|==
name|XFmode
condition|?
literal|3
else|:
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|/
literal|4
expr_stmt|;
else|else
name|size
operator|=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|+
literal|4
operator|)
operator|/
literal|8
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|REG
operator|&&
name|MMX_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|operand
argument_list|)
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|2
operator|||
name|size
operator|>
literal|3
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Optimize constant pool reference to immediates.  This is used by fp      moves, that force all constants to memory to allow combining.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|MEM
operator|&&
name|RTX_UNCHANGING_P
argument_list|(
name|operand
argument_list|)
condition|)
block|{
name|rtx
name|tmp
init|=
name|maybe_get_pool_constant
argument_list|(
name|operand
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmp
condition|)
name|operand
operator|=
name|tmp
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|offsettable_memref_p
argument_list|(
name|operand
argument_list|)
condition|)
block|{
comment|/* The only non-offsetable memories we handle are pushes.  */
if|if
condition|(
operator|!
name|push_operand
argument_list|(
name|operand
argument_list|,
name|VOIDmode
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|operand
operator|=
name|copy_rtx
argument_list|(
name|operand
argument_list|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|operand
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
name|parts
index|[
literal|0
index|]
operator|=
name|parts
index|[
literal|1
index|]
operator|=
name|parts
index|[
literal|2
index|]
operator|=
name|operand
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|TARGET_64BIT
condition|)
block|{
if|if
condition|(
name|mode
operator|==
name|DImode
condition|)
name|split_di
argument_list|(
operator|&
name|operand
argument_list|,
literal|1
argument_list|,
operator|&
name|parts
index|[
literal|0
index|]
argument_list|,
operator|&
name|parts
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|REG_P
argument_list|(
name|operand
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|reload_completed
condition|)
name|abort
argument_list|()
expr_stmt|;
name|parts
index|[
literal|0
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|operand
argument_list|)
operator|+
literal|0
argument_list|)
expr_stmt|;
name|parts
index|[
literal|1
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|operand
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|3
condition|)
name|parts
index|[
literal|2
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|operand
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|offsettable_memref_p
argument_list|(
name|operand
argument_list|)
condition|)
block|{
name|operand
operator|=
name|adjust_address
argument_list|(
name|operand
argument_list|,
name|SImode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|parts
index|[
literal|0
index|]
operator|=
name|operand
expr_stmt|;
name|parts
index|[
literal|1
index|]
operator|=
name|adjust_address
argument_list|(
name|operand
argument_list|,
name|SImode
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|3
condition|)
name|parts
index|[
literal|2
index|]
operator|=
name|adjust_address
argument_list|(
name|operand
argument_list|,
name|SImode
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|long
name|l
index|[
literal|4
index|]
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|r
argument_list|,
name|operand
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|XFmode
case|:
name|REAL_VALUE_TO_TARGET_LONG_DOUBLE
argument_list|(
name|r
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|parts
index|[
literal|2
index|]
operator|=
name|gen_int_mode
argument_list|(
name|l
index|[
literal|2
index|]
argument_list|,
name|SImode
argument_list|)
expr_stmt|;
break|break;
case|case
name|DFmode
case|:
name|REAL_VALUE_TO_TARGET_DOUBLE
argument_list|(
name|r
argument_list|,
name|l
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|parts
index|[
literal|1
index|]
operator|=
name|gen_int_mode
argument_list|(
name|l
index|[
literal|1
index|]
argument_list|,
name|SImode
argument_list|)
expr_stmt|;
name|parts
index|[
literal|0
index|]
operator|=
name|gen_int_mode
argument_list|(
name|l
index|[
literal|0
index|]
argument_list|,
name|SImode
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|mode
operator|==
name|TImode
condition|)
name|split_ti
argument_list|(
operator|&
name|operand
argument_list|,
literal|1
argument_list|,
operator|&
name|parts
index|[
literal|0
index|]
argument_list|,
operator|&
name|parts
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|XFmode
operator|||
name|mode
operator|==
name|TFmode
condition|)
block|{
name|enum
name|machine_mode
name|upper_mode
init|=
name|mode
operator|==
name|XFmode
condition|?
name|SImode
else|:
name|DImode
decl_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|operand
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|reload_completed
condition|)
name|abort
argument_list|()
expr_stmt|;
name|parts
index|[
literal|0
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|REGNO
argument_list|(
name|operand
argument_list|)
operator|+
literal|0
argument_list|)
expr_stmt|;
name|parts
index|[
literal|1
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|upper_mode
argument_list|,
name|REGNO
argument_list|(
name|operand
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|offsettable_memref_p
argument_list|(
name|operand
argument_list|)
condition|)
block|{
name|operand
operator|=
name|adjust_address
argument_list|(
name|operand
argument_list|,
name|DImode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|parts
index|[
literal|0
index|]
operator|=
name|operand
expr_stmt|;
name|parts
index|[
literal|1
index|]
operator|=
name|adjust_address
argument_list|(
name|operand
argument_list|,
name|upper_mode
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|long
name|l
index|[
literal|3
index|]
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|r
argument_list|,
name|operand
argument_list|)
expr_stmt|;
name|real_to_target
argument_list|(
name|l
argument_list|,
operator|&
name|r
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/* Do not use shift by 32 to avoid warning on 32bit systems.  */
if|if
condition|(
name|HOST_BITS_PER_WIDE_INT
operator|>=
literal|64
condition|)
name|parts
index|[
literal|0
index|]
operator|=
name|gen_int_mode
argument_list|(
operator|(
name|l
index|[
literal|0
index|]
operator|&
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|2
operator|<<
literal|31
operator|)
operator|-
literal|1
operator|)
operator|)
operator|+
operator|(
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
name|l
index|[
literal|1
index|]
operator|)
operator|<<
literal|31
operator|)
operator|<<
literal|1
operator|)
argument_list|,
name|DImode
argument_list|)
expr_stmt|;
else|else
name|parts
index|[
literal|0
index|]
operator|=
name|immed_double_const
argument_list|(
name|l
index|[
literal|0
index|]
argument_list|,
name|l
index|[
literal|1
index|]
argument_list|,
name|DImode
argument_list|)
expr_stmt|;
if|if
condition|(
name|upper_mode
operator|==
name|SImode
condition|)
name|parts
index|[
literal|1
index|]
operator|=
name|gen_int_mode
argument_list|(
name|l
index|[
literal|2
index|]
argument_list|,
name|SImode
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|HOST_BITS_PER_WIDE_INT
operator|>=
literal|64
condition|)
name|parts
index|[
literal|1
index|]
operator|=
name|gen_int_mode
argument_list|(
operator|(
name|l
index|[
literal|2
index|]
operator|&
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|2
operator|<<
literal|31
operator|)
operator|-
literal|1
operator|)
operator|)
operator|+
operator|(
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
name|l
index|[
literal|3
index|]
operator|)
operator|<<
literal|31
operator|)
operator|<<
literal|1
operator|)
argument_list|,
name|DImode
argument_list|)
expr_stmt|;
else|else
name|parts
index|[
literal|1
index|]
operator|=
name|immed_double_const
argument_list|(
name|l
index|[
literal|2
index|]
argument_list|,
name|l
index|[
literal|3
index|]
argument_list|,
name|DImode
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|size
return|;
block|}
end_function

begin_comment
comment|/* Emit insns to perform a move or push of DI, DF, and XF values.    Return false when normal moves are needed; true when all required    insns have been emitted.  Operands 2-4 contain the input values    int the correct order; operands 5-7 contain the output values.  */
end_comment

begin_function
name|void
name|ix86_split_long_move
parameter_list|(
name|rtx
name|operands
index|[]
parameter_list|)
block|{
name|rtx
name|part
index|[
literal|2
index|]
index|[
literal|3
index|]
decl_stmt|;
name|int
name|nparts
decl_stmt|;
name|int
name|push
init|=
literal|0
decl_stmt|;
name|int
name|collisions
init|=
literal|0
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
comment|/* The DFmode expanders may ask us to move double.      For 64bit target this is single move.  By hiding the fact      here we simplify i386.md splitters.  */
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator|==
literal|8
operator|&&
name|TARGET_64BIT
condition|)
block|{
comment|/* Optimize constant pool reference to immediates.  This is used by 	 fp moves, that force all constants to memory to allow combining.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|operands
index|[
literal|1
index|]
operator|=
name|get_pool_constant
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|push_operand
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|VOIDmode
argument_list|)
condition|)
block|{
name|operands
index|[
literal|0
index|]
operator|=
name|copy_rtx
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
block|}
else|else
name|operands
index|[
literal|0
index|]
operator|=
name|gen_lowpart
argument_list|(
name|DImode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|gen_lowpart
argument_list|(
name|DImode
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* The only non-offsettable memory we handle is push.  */
if|if
condition|(
name|push_operand
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|VOIDmode
argument_list|)
condition|)
name|push
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|offsettable_memref_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|nparts
operator|=
name|ix86_split_to_parts
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|part
index|[
literal|1
index|]
argument_list|,
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ix86_split_to_parts
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|part
index|[
literal|0
index|]
argument_list|,
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* When emitting push, take care for source operands on the stack.  */
if|if
condition|(
name|push
operator|&&
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|MEM
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|nparts
operator|==
literal|3
condition|)
name|part
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|change_address
argument_list|(
name|part
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|,
name|GET_MODE
argument_list|(
name|part
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|part
index|[
literal|1
index|]
index|[
literal|2
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|part
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|change_address
argument_list|(
name|part
index|[
literal|1
index|]
index|[
literal|0
index|]
argument_list|,
name|GET_MODE
argument_list|(
name|part
index|[
literal|1
index|]
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|part
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* We need to do copy in the right order in case an address register      of the source overlaps the destination.  */
if|if
condition|(
name|REG_P
argument_list|(
name|part
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|part
index|[
literal|1
index|]
index|[
literal|0
index|]
argument_list|)
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|part
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|,
name|XEXP
argument_list|(
name|part
index|[
literal|1
index|]
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|collisions
operator|++
expr_stmt|;
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|part
index|[
literal|0
index|]
index|[
literal|1
index|]
argument_list|,
name|XEXP
argument_list|(
name|part
index|[
literal|1
index|]
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|collisions
operator|++
expr_stmt|;
if|if
condition|(
name|nparts
operator|==
literal|3
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|part
index|[
literal|0
index|]
index|[
literal|2
index|]
argument_list|,
name|XEXP
argument_list|(
name|part
index|[
literal|1
index|]
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|collisions
operator|++
expr_stmt|;
comment|/* Collision in the middle part can be handled by reordering.  */
if|if
condition|(
name|collisions
operator|==
literal|1
operator|&&
name|nparts
operator|==
literal|3
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|part
index|[
literal|0
index|]
index|[
literal|1
index|]
argument_list|,
name|XEXP
argument_list|(
name|part
index|[
literal|1
index|]
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|tmp
decl_stmt|;
name|tmp
operator|=
name|part
index|[
literal|0
index|]
index|[
literal|1
index|]
expr_stmt|;
name|part
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
name|part
index|[
literal|0
index|]
index|[
literal|2
index|]
expr_stmt|;
name|part
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|=
name|tmp
expr_stmt|;
name|tmp
operator|=
name|part
index|[
literal|1
index|]
index|[
literal|1
index|]
expr_stmt|;
name|part
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|part
index|[
literal|1
index|]
index|[
literal|2
index|]
expr_stmt|;
name|part
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|=
name|tmp
expr_stmt|;
block|}
comment|/* If there are more collisions, we can't handle it by reordering. 	 Do an lea to the last part and use only one colliding move.  */
elseif|else
if|if
condition|(
name|collisions
operator|>
literal|1
condition|)
block|{
name|rtx
name|base
decl_stmt|;
name|collisions
operator|=
literal|1
expr_stmt|;
name|base
operator|=
name|part
index|[
literal|0
index|]
index|[
name|nparts
operator|-
literal|1
index|]
expr_stmt|;
comment|/* Handle the case when the last part isn't valid for lea. 	     Happens in 64-bit mode storing the 12-byte XFmode.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|base
argument_list|)
operator|!=
name|Pmode
condition|)
name|base
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|REGNO
argument_list|(
name|base
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|base
argument_list|,
name|XEXP
argument_list|(
name|part
index|[
literal|1
index|]
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|part
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|replace_equiv_address
argument_list|(
name|part
index|[
literal|1
index|]
index|[
literal|0
index|]
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|part
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|replace_equiv_address
argument_list|(
name|part
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|,
name|plus_constant
argument_list|(
name|base
argument_list|,
name|UNITS_PER_WORD
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nparts
operator|==
literal|3
condition|)
name|part
index|[
literal|1
index|]
index|[
literal|2
index|]
operator|=
name|replace_equiv_address
argument_list|(
name|part
index|[
literal|1
index|]
index|[
literal|2
index|]
argument_list|,
name|plus_constant
argument_list|(
name|base
argument_list|,
literal|8
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|push
condition|)
block|{
if|if
condition|(
operator|!
name|TARGET_64BIT
condition|)
block|{
if|if
condition|(
name|nparts
operator|==
literal|3
condition|)
block|{
if|if
condition|(
name|TARGET_128BIT_LONG_DOUBLE
operator|&&
name|mode
operator|==
name|XFmode
condition|)
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
operator|-
literal|4
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|part
index|[
literal|0
index|]
index|[
literal|2
index|]
argument_list|,
name|part
index|[
literal|1
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* In 64bit mode we don't have 32bit push available.  In case this is 	     register, it is OK - we will just use larger counterpart.  We also 	     retype memory - these comes from attempt to avoid REX prefix on 	     moving of second half of TFmode value.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|part
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|)
operator|==
name|SImode
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|part
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|)
operator|==
name|MEM
condition|)
name|part
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|adjust_address
argument_list|(
name|part
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|,
name|DImode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|REG_P
argument_list|(
name|part
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|)
condition|)
name|part
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|REGNO
argument_list|(
name|part
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|part
index|[
literal|1
index|]
index|[
literal|0
index|]
argument_list|)
operator|==
name|SImode
condition|)
name|part
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|part
index|[
literal|1
index|]
index|[
literal|1
index|]
expr_stmt|;
block|}
block|}
name|emit_move_insn
argument_list|(
name|part
index|[
literal|0
index|]
index|[
literal|1
index|]
argument_list|,
name|part
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|part
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|,
name|part
index|[
literal|1
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Choose correct order to not overwrite the source before it is copied.  */
if|if
condition|(
operator|(
name|REG_P
argument_list|(
name|part
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|)
operator|&&
name|REG_P
argument_list|(
name|part
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|)
operator|&&
operator|(
name|REGNO
argument_list|(
name|part
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|)
operator|==
name|REGNO
argument_list|(
name|part
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|)
operator|||
operator|(
name|nparts
operator|==
literal|3
operator|&&
name|REGNO
argument_list|(
name|part
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|)
operator|==
name|REGNO
argument_list|(
name|part
index|[
literal|1
index|]
index|[
literal|2
index|]
argument_list|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|collisions
operator|>
literal|0
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|part
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|,
name|XEXP
argument_list|(
name|part
index|[
literal|1
index|]
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|nparts
operator|==
literal|3
condition|)
block|{
name|operands
index|[
literal|2
index|]
operator|=
name|part
index|[
literal|0
index|]
index|[
literal|2
index|]
expr_stmt|;
name|operands
index|[
literal|3
index|]
operator|=
name|part
index|[
literal|0
index|]
index|[
literal|1
index|]
expr_stmt|;
name|operands
index|[
literal|4
index|]
operator|=
name|part
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
name|operands
index|[
literal|5
index|]
operator|=
name|part
index|[
literal|1
index|]
index|[
literal|2
index|]
expr_stmt|;
name|operands
index|[
literal|6
index|]
operator|=
name|part
index|[
literal|1
index|]
index|[
literal|1
index|]
expr_stmt|;
name|operands
index|[
literal|7
index|]
operator|=
name|part
index|[
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
block|{
name|operands
index|[
literal|2
index|]
operator|=
name|part
index|[
literal|0
index|]
index|[
literal|1
index|]
expr_stmt|;
name|operands
index|[
literal|3
index|]
operator|=
name|part
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
name|operands
index|[
literal|5
index|]
operator|=
name|part
index|[
literal|1
index|]
index|[
literal|1
index|]
expr_stmt|;
name|operands
index|[
literal|6
index|]
operator|=
name|part
index|[
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|nparts
operator|==
literal|3
condition|)
block|{
name|operands
index|[
literal|2
index|]
operator|=
name|part
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
name|operands
index|[
literal|3
index|]
operator|=
name|part
index|[
literal|0
index|]
index|[
literal|1
index|]
expr_stmt|;
name|operands
index|[
literal|4
index|]
operator|=
name|part
index|[
literal|0
index|]
index|[
literal|2
index|]
expr_stmt|;
name|operands
index|[
literal|5
index|]
operator|=
name|part
index|[
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
name|operands
index|[
literal|6
index|]
operator|=
name|part
index|[
literal|1
index|]
index|[
literal|1
index|]
expr_stmt|;
name|operands
index|[
literal|7
index|]
operator|=
name|part
index|[
literal|1
index|]
index|[
literal|2
index|]
expr_stmt|;
block|}
else|else
block|{
name|operands
index|[
literal|2
index|]
operator|=
name|part
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
name|operands
index|[
literal|3
index|]
operator|=
name|part
index|[
literal|0
index|]
index|[
literal|1
index|]
expr_stmt|;
name|operands
index|[
literal|5
index|]
operator|=
name|part
index|[
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
name|operands
index|[
literal|6
index|]
operator|=
name|part
index|[
literal|1
index|]
index|[
literal|1
index|]
expr_stmt|;
block|}
block|}
name|emit_move_insn
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|,
name|operands
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|operands
index|[
literal|3
index|]
argument_list|,
name|operands
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|nparts
operator|==
literal|3
condition|)
name|emit_move_insn
argument_list|(
name|operands
index|[
literal|4
index|]
argument_list|,
name|operands
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|ix86_split_ashldi
parameter_list|(
name|rtx
modifier|*
name|operands
parameter_list|,
name|rtx
name|scratch
parameter_list|)
block|{
name|rtx
name|low
index|[
literal|2
index|]
decl_stmt|,
name|high
index|[
literal|2
index|]
decl_stmt|;
name|int
name|count
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|split_di
argument_list|(
name|operands
argument_list|,
literal|2
argument_list|,
name|low
argument_list|,
name|high
argument_list|)
expr_stmt|;
name|count
operator|=
name|INTVAL
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|&
literal|63
expr_stmt|;
if|if
condition|(
name|count
operator|>=
literal|32
condition|)
block|{
name|emit_move_insn
argument_list|(
name|high
index|[
literal|0
index|]
argument_list|,
name|low
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|low
index|[
literal|0
index|]
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|32
condition|)
name|emit_insn
argument_list|(
name|gen_ashlsi3
argument_list|(
name|high
index|[
literal|0
index|]
argument_list|,
name|high
index|[
literal|0
index|]
argument_list|,
name|GEN_INT
argument_list|(
name|count
operator|-
literal|32
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
name|emit_move_insn
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_x86_shld_1
argument_list|(
name|high
index|[
literal|0
index|]
argument_list|,
name|low
index|[
literal|0
index|]
argument_list|,
name|GEN_INT
argument_list|(
name|count
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_ashlsi3
argument_list|(
name|low
index|[
literal|0
index|]
argument_list|,
name|low
index|[
literal|0
index|]
argument_list|,
name|GEN_INT
argument_list|(
name|count
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
name|emit_move_insn
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|split_di
argument_list|(
name|operands
argument_list|,
literal|1
argument_list|,
name|low
argument_list|,
name|high
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_x86_shld_1
argument_list|(
name|high
index|[
literal|0
index|]
argument_list|,
name|low
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_ashlsi3
argument_list|(
name|low
index|[
literal|0
index|]
argument_list|,
name|low
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_CMOVE
operator|&&
operator|(
operator|!
name|no_new_pseudos
operator|||
name|scratch
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|no_new_pseudos
condition|)
name|scratch
operator|=
name|force_reg
argument_list|(
name|SImode
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
else|else
name|emit_move_insn
argument_list|(
name|scratch
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_x86_shift_adj_1
argument_list|(
name|high
index|[
literal|0
index|]
argument_list|,
name|low
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|,
name|scratch
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|emit_insn
argument_list|(
name|gen_x86_shift_adj_2
argument_list|(
name|high
index|[
literal|0
index|]
argument_list|,
name|low
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ix86_split_ashrdi
parameter_list|(
name|rtx
modifier|*
name|operands
parameter_list|,
name|rtx
name|scratch
parameter_list|)
block|{
name|rtx
name|low
index|[
literal|2
index|]
decl_stmt|,
name|high
index|[
literal|2
index|]
decl_stmt|;
name|int
name|count
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|split_di
argument_list|(
name|operands
argument_list|,
literal|2
argument_list|,
name|low
argument_list|,
name|high
argument_list|)
expr_stmt|;
name|count
operator|=
name|INTVAL
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|&
literal|63
expr_stmt|;
if|if
condition|(
name|count
operator|>=
literal|32
condition|)
block|{
name|emit_move_insn
argument_list|(
name|low
index|[
literal|0
index|]
argument_list|,
name|high
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reload_completed
condition|)
name|emit_insn
argument_list|(
name|gen_ashrsi3
argument_list|(
name|high
index|[
literal|0
index|]
argument_list|,
name|low
index|[
literal|0
index|]
argument_list|,
name|GEN_INT
argument_list|(
literal|31
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|emit_move_insn
argument_list|(
name|high
index|[
literal|0
index|]
argument_list|,
name|low
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_ashrsi3
argument_list|(
name|high
index|[
literal|0
index|]
argument_list|,
name|high
index|[
literal|0
index|]
argument_list|,
name|GEN_INT
argument_list|(
literal|31
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|>
literal|32
condition|)
name|emit_insn
argument_list|(
name|gen_ashrsi3
argument_list|(
name|low
index|[
literal|0
index|]
argument_list|,
name|low
index|[
literal|0
index|]
argument_list|,
name|GEN_INT
argument_list|(
name|count
operator|-
literal|32
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
name|emit_move_insn
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_x86_shrd_1
argument_list|(
name|low
index|[
literal|0
index|]
argument_list|,
name|high
index|[
literal|0
index|]
argument_list|,
name|GEN_INT
argument_list|(
name|count
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_ashrsi3
argument_list|(
name|high
index|[
literal|0
index|]
argument_list|,
name|high
index|[
literal|0
index|]
argument_list|,
name|GEN_INT
argument_list|(
name|count
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
name|emit_move_insn
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|split_di
argument_list|(
name|operands
argument_list|,
literal|1
argument_list|,
name|low
argument_list|,
name|high
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_x86_shrd_1
argument_list|(
name|low
index|[
literal|0
index|]
argument_list|,
name|high
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_ashrsi3
argument_list|(
name|high
index|[
literal|0
index|]
argument_list|,
name|high
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_CMOVE
operator|&&
operator|(
operator|!
name|no_new_pseudos
operator|||
name|scratch
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|no_new_pseudos
condition|)
name|scratch
operator|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|scratch
argument_list|,
name|high
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_ashrsi3
argument_list|(
name|scratch
argument_list|,
name|scratch
argument_list|,
name|GEN_INT
argument_list|(
literal|31
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_x86_shift_adj_1
argument_list|(
name|low
index|[
literal|0
index|]
argument_list|,
name|high
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|,
name|scratch
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|emit_insn
argument_list|(
name|gen_x86_shift_adj_3
argument_list|(
name|low
index|[
literal|0
index|]
argument_list|,
name|high
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ix86_split_lshrdi
parameter_list|(
name|rtx
modifier|*
name|operands
parameter_list|,
name|rtx
name|scratch
parameter_list|)
block|{
name|rtx
name|low
index|[
literal|2
index|]
decl_stmt|,
name|high
index|[
literal|2
index|]
decl_stmt|;
name|int
name|count
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|split_di
argument_list|(
name|operands
argument_list|,
literal|2
argument_list|,
name|low
argument_list|,
name|high
argument_list|)
expr_stmt|;
name|count
operator|=
name|INTVAL
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|&
literal|63
expr_stmt|;
if|if
condition|(
name|count
operator|>=
literal|32
condition|)
block|{
name|emit_move_insn
argument_list|(
name|low
index|[
literal|0
index|]
argument_list|,
name|high
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|high
index|[
literal|0
index|]
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|32
condition|)
name|emit_insn
argument_list|(
name|gen_lshrsi3
argument_list|(
name|low
index|[
literal|0
index|]
argument_list|,
name|low
index|[
literal|0
index|]
argument_list|,
name|GEN_INT
argument_list|(
name|count
operator|-
literal|32
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
name|emit_move_insn
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_x86_shrd_1
argument_list|(
name|low
index|[
literal|0
index|]
argument_list|,
name|high
index|[
literal|0
index|]
argument_list|,
name|GEN_INT
argument_list|(
name|count
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_lshrsi3
argument_list|(
name|high
index|[
literal|0
index|]
argument_list|,
name|high
index|[
literal|0
index|]
argument_list|,
name|GEN_INT
argument_list|(
name|count
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
name|emit_move_insn
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|split_di
argument_list|(
name|operands
argument_list|,
literal|1
argument_list|,
name|low
argument_list|,
name|high
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_x86_shrd_1
argument_list|(
name|low
index|[
literal|0
index|]
argument_list|,
name|high
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_lshrsi3
argument_list|(
name|high
index|[
literal|0
index|]
argument_list|,
name|high
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Heh.  By reversing the arguments, we can reuse this pattern.  */
if|if
condition|(
name|TARGET_CMOVE
operator|&&
operator|(
operator|!
name|no_new_pseudos
operator|||
name|scratch
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|no_new_pseudos
condition|)
name|scratch
operator|=
name|force_reg
argument_list|(
name|SImode
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
else|else
name|emit_move_insn
argument_list|(
name|scratch
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_x86_shift_adj_1
argument_list|(
name|low
index|[
literal|0
index|]
argument_list|,
name|high
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|,
name|scratch
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|emit_insn
argument_list|(
name|gen_x86_shift_adj_2
argument_list|(
name|low
index|[
literal|0
index|]
argument_list|,
name|high
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Helper function for the string operations below.  Dest VARIABLE whether    it is aligned to VALUE bytes.  If true, jump to the label.  */
end_comment

begin_function
specifier|static
name|rtx
name|ix86_expand_aligntest
parameter_list|(
name|rtx
name|variable
parameter_list|,
name|int
name|value
parameter_list|)
block|{
name|rtx
name|label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|rtx
name|tmpcount
init|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|variable
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|variable
argument_list|)
operator|==
name|DImode
condition|)
name|emit_insn
argument_list|(
name|gen_anddi3
argument_list|(
name|tmpcount
argument_list|,
name|variable
argument_list|,
name|GEN_INT
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_andsi3
argument_list|(
name|tmpcount
argument_list|,
name|variable
argument_list|,
name|GEN_INT
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|tmpcount
argument_list|,
name|const0_rtx
argument_list|,
name|EQ
argument_list|,
literal|0
argument_list|,
name|GET_MODE
argument_list|(
name|variable
argument_list|)
argument_list|,
literal|1
argument_list|,
name|label
argument_list|)
expr_stmt|;
return|return
name|label
return|;
block|}
end_function

begin_comment
comment|/* Adjust COUNTER by the VALUE.  */
end_comment

begin_function
specifier|static
name|void
name|ix86_adjust_counter
parameter_list|(
name|rtx
name|countreg
parameter_list|,
name|HOST_WIDE_INT
name|value
parameter_list|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|countreg
argument_list|)
operator|==
name|DImode
condition|)
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|countreg
argument_list|,
name|countreg
argument_list|,
name|GEN_INT
argument_list|(
operator|-
name|value
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|countreg
argument_list|,
name|countreg
argument_list|,
name|GEN_INT
argument_list|(
operator|-
name|value
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Zero extend possibly SImode EXP to Pmode register.  */
end_comment

begin_function
name|rtx
name|ix86_zero_extend_to_Pmode
parameter_list|(
name|rtx
name|exp
parameter_list|)
block|{
name|rtx
name|r
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|exp
argument_list|)
operator|==
name|VOIDmode
condition|)
return|return
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|exp
argument_list|)
return|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|exp
argument_list|)
operator|==
name|Pmode
condition|)
return|return
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|exp
argument_list|)
return|;
name|r
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_zero_extendsidi2
argument_list|(
name|r
argument_list|,
name|exp
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Expand string move (memcpy) operation.  Use i386 string operations when    profitable.  expand_clrstr contains similar code.  */
end_comment

begin_function
name|int
name|ix86_expand_movstr
parameter_list|(
name|rtx
name|dst
parameter_list|,
name|rtx
name|src
parameter_list|,
name|rtx
name|count_exp
parameter_list|,
name|rtx
name|align_exp
parameter_list|)
block|{
name|rtx
name|srcreg
decl_stmt|,
name|destreg
decl_stmt|,
name|countreg
decl_stmt|,
name|srcexp
decl_stmt|,
name|destexp
decl_stmt|;
name|enum
name|machine_mode
name|counter_mode
decl_stmt|;
name|HOST_WIDE_INT
name|align
init|=
literal|0
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|count
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|align_exp
argument_list|)
operator|==
name|CONST_INT
condition|)
name|align
operator|=
name|INTVAL
argument_list|(
name|align_exp
argument_list|)
expr_stmt|;
comment|/* Can't use any of this if the user has appropriated esi or edi.  */
if|if
condition|(
name|global_regs
index|[
literal|4
index|]
operator|||
name|global_regs
index|[
literal|5
index|]
condition|)
return|return
literal|0
return|;
comment|/* This simple hack avoids all inlining code and simplifies code below.  */
if|if
condition|(
operator|!
name|TARGET_ALIGN_STRINGOPS
condition|)
name|align
operator|=
literal|64
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|count_exp
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|count
operator|=
name|INTVAL
argument_list|(
name|count_exp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TARGET_INLINE_ALL_STRINGOPS
operator|&&
name|count
operator|>
literal|64
condition|)
return|return
literal|0
return|;
block|}
comment|/* Figure out proper mode for counter.  For 32bits it is always SImode,      for 64bits use SImode when possible, otherwise DImode.      Set count to number of bytes copied when known at compile time.  */
if|if
condition|(
operator|!
name|TARGET_64BIT
operator|||
name|GET_MODE
argument_list|(
name|count_exp
argument_list|)
operator|==
name|SImode
operator|||
name|x86_64_zero_extended_value
argument_list|(
name|count_exp
argument_list|)
condition|)
name|counter_mode
operator|=
name|SImode
expr_stmt|;
else|else
name|counter_mode
operator|=
name|DImode
expr_stmt|;
if|if
condition|(
name|counter_mode
operator|!=
name|SImode
operator|&&
name|counter_mode
operator|!=
name|DImode
condition|)
name|abort
argument_list|()
expr_stmt|;
name|destreg
operator|=
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|destreg
operator|!=
name|XEXP
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
condition|)
name|dst
operator|=
name|replace_equiv_address_nv
argument_list|(
name|dst
argument_list|,
name|destreg
argument_list|)
expr_stmt|;
name|srcreg
operator|=
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|srcreg
operator|!=
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
condition|)
name|src
operator|=
name|replace_equiv_address_nv
argument_list|(
name|src
argument_list|,
name|srcreg
argument_list|)
expr_stmt|;
comment|/* When optimizing for size emit simple rep ; movsb instruction for      counts not divisible by 4.  */
if|if
condition|(
operator|(
operator|!
name|optimize
operator|||
name|optimize_size
operator|)
operator|&&
operator|(
name|count
operator|==
literal|0
operator|||
operator|(
name|count
operator|&
literal|0x03
operator|)
operator|)
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_cld
argument_list|()
argument_list|)
expr_stmt|;
name|countreg
operator|=
name|ix86_zero_extend_to_Pmode
argument_list|(
name|count_exp
argument_list|)
expr_stmt|;
name|destexp
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|destreg
argument_list|,
name|countreg
argument_list|)
expr_stmt|;
name|srcexp
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|srcreg
argument_list|,
name|countreg
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rep_mov
argument_list|(
name|destreg
argument_list|,
name|dst
argument_list|,
name|srcreg
argument_list|,
name|src
argument_list|,
name|countreg
argument_list|,
name|destexp
argument_list|,
name|srcexp
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* For constant aligned (or small unaligned) copies use rep movsl      followed by code copying the rest.  For PentiumPro ensure 8 byte      alignment to allow rep movsl acceleration.  */
elseif|else
if|if
condition|(
name|count
operator|!=
literal|0
operator|&&
operator|(
name|align
operator|>=
literal|8
operator|||
operator|(
operator|!
name|TARGET_PENTIUMPRO
operator|&&
operator|!
name|TARGET_64BIT
operator|&&
name|align
operator|>=
literal|4
operator|)
operator|||
name|optimize_size
operator|||
name|count
operator|<
operator|(
name|unsigned
name|int
operator|)
literal|64
operator|)
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|offset
init|=
literal|0
decl_stmt|;
name|int
name|size
init|=
name|TARGET_64BIT
operator|&&
operator|!
name|optimize_size
condition|?
literal|8
else|:
literal|4
decl_stmt|;
name|rtx
name|srcmem
decl_stmt|,
name|dstmem
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_cld
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|&
operator|~
operator|(
name|size
operator|-
literal|1
operator|)
condition|)
block|{
name|countreg
operator|=
name|copy_to_mode_reg
argument_list|(
name|counter_mode
argument_list|,
name|GEN_INT
argument_list|(
operator|(
name|count
operator|>>
operator|(
name|size
operator|==
literal|4
condition|?
literal|2
else|:
literal|3
operator|)
operator|)
operator|&
operator|(
name|TARGET_64BIT
condition|?
operator|-
literal|1
else|:
literal|0x3fffffff
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|countreg
operator|=
name|ix86_zero_extend_to_Pmode
argument_list|(
name|countreg
argument_list|)
expr_stmt|;
name|destexp
operator|=
name|gen_rtx_ASHIFT
argument_list|(
name|Pmode
argument_list|,
name|countreg
argument_list|,
name|GEN_INT
argument_list|(
name|size
operator|==
literal|4
condition|?
literal|2
else|:
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|srcexp
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|destexp
argument_list|,
name|srcreg
argument_list|)
expr_stmt|;
name|destexp
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|destexp
argument_list|,
name|destreg
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rep_mov
argument_list|(
name|destreg
argument_list|,
name|dst
argument_list|,
name|srcreg
argument_list|,
name|src
argument_list|,
name|countreg
argument_list|,
name|destexp
argument_list|,
name|srcexp
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|=
name|count
operator|&
operator|~
operator|(
name|size
operator|-
literal|1
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|size
operator|==
literal|8
operator|&&
operator|(
name|count
operator|&
literal|0x04
operator|)
condition|)
block|{
name|srcmem
operator|=
name|adjust_automodify_address_nv
argument_list|(
name|src
argument_list|,
name|SImode
argument_list|,
name|srcreg
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|dstmem
operator|=
name|adjust_automodify_address_nv
argument_list|(
name|dst
argument_list|,
name|SImode
argument_list|,
name|destreg
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_strmov
argument_list|(
name|destreg
argument_list|,
name|dstmem
argument_list|,
name|srcreg
argument_list|,
name|srcmem
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|&
literal|0x02
condition|)
block|{
name|srcmem
operator|=
name|adjust_automodify_address_nv
argument_list|(
name|src
argument_list|,
name|HImode
argument_list|,
name|srcreg
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|dstmem
operator|=
name|adjust_automodify_address_nv
argument_list|(
name|dst
argument_list|,
name|HImode
argument_list|,
name|destreg
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_strmov
argument_list|(
name|destreg
argument_list|,
name|dstmem
argument_list|,
name|srcreg
argument_list|,
name|srcmem
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|&
literal|0x01
condition|)
block|{
name|srcmem
operator|=
name|adjust_automodify_address_nv
argument_list|(
name|src
argument_list|,
name|QImode
argument_list|,
name|srcreg
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|dstmem
operator|=
name|adjust_automodify_address_nv
argument_list|(
name|dst
argument_list|,
name|QImode
argument_list|,
name|destreg
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_strmov
argument_list|(
name|destreg
argument_list|,
name|dstmem
argument_list|,
name|srcreg
argument_list|,
name|srcmem
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* The generic code based on the glibc implementation:      - align destination to 4 bytes (8 byte alignment is used for PentiumPro      allowing accelerated copying there)      - copy the data using rep movsl      - copy the rest.  */
else|else
block|{
name|rtx
name|countreg2
decl_stmt|;
name|rtx
name|label
init|=
name|NULL
decl_stmt|;
name|rtx
name|srcmem
decl_stmt|,
name|dstmem
decl_stmt|;
name|int
name|desired_alignment
init|=
operator|(
name|TARGET_PENTIUMPRO
operator|&&
operator|(
name|count
operator|==
literal|0
operator|||
name|count
operator|>=
operator|(
name|unsigned
name|int
operator|)
literal|260
operator|)
condition|?
literal|8
else|:
name|UNITS_PER_WORD
operator|)
decl_stmt|;
comment|/* Get rid of MEM_OFFSETs, they won't be accurate.  */
name|dst
operator|=
name|change_address
argument_list|(
name|dst
argument_list|,
name|BLKmode
argument_list|,
name|destreg
argument_list|)
expr_stmt|;
name|src
operator|=
name|change_address
argument_list|(
name|src
argument_list|,
name|BLKmode
argument_list|,
name|srcreg
argument_list|)
expr_stmt|;
comment|/* In case we don't know anything about the alignment, default to          library version, since it is usually equally fast and result in          shorter code.  	 Also emit call when we know that the count is large and call overhead 	 will not be important.  */
if|if
condition|(
operator|!
name|TARGET_INLINE_ALL_STRINGOPS
operator|&&
operator|(
name|align
operator|<
name|UNITS_PER_WORD
operator|||
operator|!
name|TARGET_REP_MOVL_OPTIMAL
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TARGET_SINGLE_STRINGOP
condition|)
name|emit_insn
argument_list|(
name|gen_cld
argument_list|()
argument_list|)
expr_stmt|;
name|countreg2
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|countreg
operator|=
name|copy_to_mode_reg
argument_list|(
name|counter_mode
argument_list|,
name|count_exp
argument_list|)
expr_stmt|;
comment|/* We don't use loops to align destination and to copy parts smaller          than 4 bytes, because gcc is able to optimize such code better (in          the case the destination or the count really is aligned, gcc is often          able to predict the branches) and also it is friendlier to the          hardware branch prediction.           Using loops is beneficial for generic case, because we can          handle small counts using the loops.  Many CPUs (such as Athlon)          have large REP prefix setup costs.           This is quite costly.  Maybe we can revisit this decision later or          add some customizability to this code.  */
if|if
condition|(
name|count
operator|==
literal|0
operator|&&
name|align
operator|<
name|desired_alignment
condition|)
block|{
name|label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|countreg
argument_list|,
name|GEN_INT
argument_list|(
name|desired_alignment
operator|-
literal|1
argument_list|)
argument_list|,
name|LEU
argument_list|,
literal|0
argument_list|,
name|counter_mode
argument_list|,
literal|1
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|align
operator|<=
literal|1
condition|)
block|{
name|rtx
name|label
init|=
name|ix86_expand_aligntest
argument_list|(
name|destreg
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|srcmem
operator|=
name|change_address
argument_list|(
name|src
argument_list|,
name|QImode
argument_list|,
name|srcreg
argument_list|)
expr_stmt|;
name|dstmem
operator|=
name|change_address
argument_list|(
name|dst
argument_list|,
name|QImode
argument_list|,
name|destreg
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_strmov
argument_list|(
name|destreg
argument_list|,
name|dstmem
argument_list|,
name|srcreg
argument_list|,
name|srcmem
argument_list|)
argument_list|)
expr_stmt|;
name|ix86_adjust_counter
argument_list|(
name|countreg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|align
operator|<=
literal|2
condition|)
block|{
name|rtx
name|label
init|=
name|ix86_expand_aligntest
argument_list|(
name|destreg
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|srcmem
operator|=
name|change_address
argument_list|(
name|src
argument_list|,
name|HImode
argument_list|,
name|srcreg
argument_list|)
expr_stmt|;
name|dstmem
operator|=
name|change_address
argument_list|(
name|dst
argument_list|,
name|HImode
argument_list|,
name|destreg
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_strmov
argument_list|(
name|destreg
argument_list|,
name|dstmem
argument_list|,
name|srcreg
argument_list|,
name|srcmem
argument_list|)
argument_list|)
expr_stmt|;
name|ix86_adjust_counter
argument_list|(
name|countreg
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|align
operator|<=
literal|4
operator|&&
name|desired_alignment
operator|>
literal|4
condition|)
block|{
name|rtx
name|label
init|=
name|ix86_expand_aligntest
argument_list|(
name|destreg
argument_list|,
literal|4
argument_list|)
decl_stmt|;
name|srcmem
operator|=
name|change_address
argument_list|(
name|src
argument_list|,
name|SImode
argument_list|,
name|srcreg
argument_list|)
expr_stmt|;
name|dstmem
operator|=
name|change_address
argument_list|(
name|dst
argument_list|,
name|SImode
argument_list|,
name|destreg
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_strmov
argument_list|(
name|destreg
argument_list|,
name|dstmem
argument_list|,
name|srcreg
argument_list|,
name|srcmem
argument_list|)
argument_list|)
expr_stmt|;
name|ix86_adjust_counter
argument_list|(
name|countreg
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|label
operator|&&
name|desired_alignment
operator|>
literal|4
operator|&&
operator|!
name|TARGET_64BIT
condition|)
block|{
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|=
literal|1
expr_stmt|;
name|label
operator|=
name|NULL_RTX
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TARGET_SINGLE_STRINGOP
condition|)
name|emit_insn
argument_list|(
name|gen_cld
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_lshrdi3
argument_list|(
name|countreg2
argument_list|,
name|ix86_zero_extend_to_Pmode
argument_list|(
name|countreg
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
literal|3
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|destexp
operator|=
name|gen_rtx_ASHIFT
argument_list|(
name|Pmode
argument_list|,
name|countreg2
argument_list|,
name|GEN_INT
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|emit_insn
argument_list|(
name|gen_lshrsi3
argument_list|(
name|countreg2
argument_list|,
name|countreg
argument_list|,
name|const2_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|destexp
operator|=
name|gen_rtx_ASHIFT
argument_list|(
name|Pmode
argument_list|,
name|countreg2
argument_list|,
name|const2_rtx
argument_list|)
expr_stmt|;
block|}
name|srcexp
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|destexp
argument_list|,
name|srcreg
argument_list|)
expr_stmt|;
name|destexp
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|destexp
argument_list|,
name|destreg
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rep_mov
argument_list|(
name|destreg
argument_list|,
name|dst
argument_list|,
name|srcreg
argument_list|,
name|src
argument_list|,
name|countreg2
argument_list|,
name|destexp
argument_list|,
name|srcexp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|label
condition|)
block|{
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_64BIT
operator|&&
name|align
operator|>
literal|4
operator|&&
name|count
operator|!=
literal|0
operator|&&
operator|(
name|count
operator|&
literal|4
operator|)
condition|)
block|{
name|srcmem
operator|=
name|change_address
argument_list|(
name|src
argument_list|,
name|SImode
argument_list|,
name|srcreg
argument_list|)
expr_stmt|;
name|dstmem
operator|=
name|change_address
argument_list|(
name|dst
argument_list|,
name|SImode
argument_list|,
name|destreg
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_strmov
argument_list|(
name|destreg
argument_list|,
name|dstmem
argument_list|,
name|srcreg
argument_list|,
name|srcmem
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|align
operator|<=
literal|4
operator|||
name|count
operator|==
literal|0
operator|)
operator|&&
name|TARGET_64BIT
condition|)
block|{
name|rtx
name|label
init|=
name|ix86_expand_aligntest
argument_list|(
name|countreg
argument_list|,
literal|4
argument_list|)
decl_stmt|;
name|srcmem
operator|=
name|change_address
argument_list|(
name|src
argument_list|,
name|SImode
argument_list|,
name|srcreg
argument_list|)
expr_stmt|;
name|dstmem
operator|=
name|change_address
argument_list|(
name|dst
argument_list|,
name|SImode
argument_list|,
name|destreg
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_strmov
argument_list|(
name|destreg
argument_list|,
name|dstmem
argument_list|,
name|srcreg
argument_list|,
name|srcmem
argument_list|)
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|align
operator|>
literal|2
operator|&&
name|count
operator|!=
literal|0
operator|&&
operator|(
name|count
operator|&
literal|2
operator|)
condition|)
block|{
name|srcmem
operator|=
name|change_address
argument_list|(
name|src
argument_list|,
name|HImode
argument_list|,
name|srcreg
argument_list|)
expr_stmt|;
name|dstmem
operator|=
name|change_address
argument_list|(
name|dst
argument_list|,
name|HImode
argument_list|,
name|destreg
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_strmov
argument_list|(
name|destreg
argument_list|,
name|dstmem
argument_list|,
name|srcreg
argument_list|,
name|srcmem
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|align
operator|<=
literal|2
operator|||
name|count
operator|==
literal|0
condition|)
block|{
name|rtx
name|label
init|=
name|ix86_expand_aligntest
argument_list|(
name|countreg
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|srcmem
operator|=
name|change_address
argument_list|(
name|src
argument_list|,
name|HImode
argument_list|,
name|srcreg
argument_list|)
expr_stmt|;
name|dstmem
operator|=
name|change_address
argument_list|(
name|dst
argument_list|,
name|HImode
argument_list|,
name|destreg
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_strmov
argument_list|(
name|destreg
argument_list|,
name|dstmem
argument_list|,
name|srcreg
argument_list|,
name|srcmem
argument_list|)
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|align
operator|>
literal|1
operator|&&
name|count
operator|!=
literal|0
operator|&&
operator|(
name|count
operator|&
literal|1
operator|)
condition|)
block|{
name|srcmem
operator|=
name|change_address
argument_list|(
name|src
argument_list|,
name|QImode
argument_list|,
name|srcreg
argument_list|)
expr_stmt|;
name|dstmem
operator|=
name|change_address
argument_list|(
name|dst
argument_list|,
name|QImode
argument_list|,
name|destreg
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_strmov
argument_list|(
name|destreg
argument_list|,
name|dstmem
argument_list|,
name|srcreg
argument_list|,
name|srcmem
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|align
operator|<=
literal|1
operator|||
name|count
operator|==
literal|0
condition|)
block|{
name|rtx
name|label
init|=
name|ix86_expand_aligntest
argument_list|(
name|countreg
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|srcmem
operator|=
name|change_address
argument_list|(
name|src
argument_list|,
name|QImode
argument_list|,
name|srcreg
argument_list|)
expr_stmt|;
name|dstmem
operator|=
name|change_address
argument_list|(
name|dst
argument_list|,
name|QImode
argument_list|,
name|destreg
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_strmov
argument_list|(
name|destreg
argument_list|,
name|dstmem
argument_list|,
name|srcreg
argument_list|,
name|srcmem
argument_list|)
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Expand string clear operation (bzero).  Use i386 string operations when    profitable.  expand_movstr contains similar code.  */
end_comment

begin_function
name|int
name|ix86_expand_clrstr
parameter_list|(
name|rtx
name|dst
parameter_list|,
name|rtx
name|count_exp
parameter_list|,
name|rtx
name|align_exp
parameter_list|)
block|{
name|rtx
name|destreg
decl_stmt|,
name|zeroreg
decl_stmt|,
name|countreg
decl_stmt|,
name|destexp
decl_stmt|;
name|enum
name|machine_mode
name|counter_mode
decl_stmt|;
name|HOST_WIDE_INT
name|align
init|=
literal|0
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|count
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|align_exp
argument_list|)
operator|==
name|CONST_INT
condition|)
name|align
operator|=
name|INTVAL
argument_list|(
name|align_exp
argument_list|)
expr_stmt|;
comment|/* Can't use any of this if the user has appropriated esi.  */
if|if
condition|(
name|global_regs
index|[
literal|4
index|]
condition|)
return|return
literal|0
return|;
comment|/* This simple hack avoids all inlining code and simplifies code below.  */
if|if
condition|(
operator|!
name|TARGET_ALIGN_STRINGOPS
condition|)
name|align
operator|=
literal|32
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|count_exp
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|count
operator|=
name|INTVAL
argument_list|(
name|count_exp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TARGET_INLINE_ALL_STRINGOPS
operator|&&
name|count
operator|>
literal|64
condition|)
return|return
literal|0
return|;
block|}
comment|/* Figure out proper mode for counter.  For 32bits it is always SImode,      for 64bits use SImode when possible, otherwise DImode.      Set count to number of bytes copied when known at compile time.  */
if|if
condition|(
operator|!
name|TARGET_64BIT
operator|||
name|GET_MODE
argument_list|(
name|count_exp
argument_list|)
operator|==
name|SImode
operator|||
name|x86_64_zero_extended_value
argument_list|(
name|count_exp
argument_list|)
condition|)
name|counter_mode
operator|=
name|SImode
expr_stmt|;
else|else
name|counter_mode
operator|=
name|DImode
expr_stmt|;
name|destreg
operator|=
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|destreg
operator|!=
name|XEXP
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
condition|)
name|dst
operator|=
name|replace_equiv_address_nv
argument_list|(
name|dst
argument_list|,
name|destreg
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_cld
argument_list|()
argument_list|)
expr_stmt|;
comment|/* When optimizing for size emit simple rep ; movsb instruction for      counts not divisible by 4.  */
if|if
condition|(
operator|(
operator|!
name|optimize
operator|||
name|optimize_size
operator|)
operator|&&
operator|(
name|count
operator|==
literal|0
operator|||
operator|(
name|count
operator|&
literal|0x03
operator|)
operator|)
condition|)
block|{
name|countreg
operator|=
name|ix86_zero_extend_to_Pmode
argument_list|(
name|count_exp
argument_list|)
expr_stmt|;
name|zeroreg
operator|=
name|copy_to_mode_reg
argument_list|(
name|QImode
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|destexp
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|destreg
argument_list|,
name|countreg
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rep_stos
argument_list|(
name|destreg
argument_list|,
name|countreg
argument_list|,
name|dst
argument_list|,
name|zeroreg
argument_list|,
name|destexp
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|count
operator|!=
literal|0
operator|&&
operator|(
name|align
operator|>=
literal|8
operator|||
operator|(
operator|!
name|TARGET_PENTIUMPRO
operator|&&
operator|!
name|TARGET_64BIT
operator|&&
name|align
operator|>=
literal|4
operator|)
operator|||
name|optimize_size
operator|||
name|count
operator|<
operator|(
name|unsigned
name|int
operator|)
literal|64
operator|)
condition|)
block|{
name|int
name|size
init|=
name|TARGET_64BIT
operator|&&
operator|!
name|optimize_size
condition|?
literal|8
else|:
literal|4
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|offset
init|=
literal|0
decl_stmt|;
name|zeroreg
operator|=
name|copy_to_mode_reg
argument_list|(
name|size
operator|==
literal|4
condition|?
name|SImode
else|:
name|DImode
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|&
operator|~
operator|(
name|size
operator|-
literal|1
operator|)
condition|)
block|{
name|countreg
operator|=
name|copy_to_mode_reg
argument_list|(
name|counter_mode
argument_list|,
name|GEN_INT
argument_list|(
operator|(
name|count
operator|>>
operator|(
name|size
operator|==
literal|4
condition|?
literal|2
else|:
literal|3
operator|)
operator|)
operator|&
operator|(
name|TARGET_64BIT
condition|?
operator|-
literal|1
else|:
literal|0x3fffffff
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|countreg
operator|=
name|ix86_zero_extend_to_Pmode
argument_list|(
name|countreg
argument_list|)
expr_stmt|;
name|destexp
operator|=
name|gen_rtx_ASHIFT
argument_list|(
name|Pmode
argument_list|,
name|countreg
argument_list|,
name|GEN_INT
argument_list|(
name|size
operator|==
literal|4
condition|?
literal|2
else|:
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|destexp
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|destexp
argument_list|,
name|destreg
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rep_stos
argument_list|(
name|destreg
argument_list|,
name|countreg
argument_list|,
name|dst
argument_list|,
name|zeroreg
argument_list|,
name|destexp
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|=
name|count
operator|&
operator|~
operator|(
name|size
operator|-
literal|1
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|size
operator|==
literal|8
operator|&&
operator|(
name|count
operator|&
literal|0x04
operator|)
condition|)
block|{
name|rtx
name|mem
init|=
name|adjust_automodify_address_nv
argument_list|(
name|dst
argument_list|,
name|SImode
argument_list|,
name|destreg
argument_list|,
name|offset
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_strset
argument_list|(
name|destreg
argument_list|,
name|mem
argument_list|,
name|gen_rtx_SUBREG
argument_list|(
name|SImode
argument_list|,
name|zeroreg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|&
literal|0x02
condition|)
block|{
name|rtx
name|mem
init|=
name|adjust_automodify_address_nv
argument_list|(
name|dst
argument_list|,
name|HImode
argument_list|,
name|destreg
argument_list|,
name|offset
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_strset
argument_list|(
name|destreg
argument_list|,
name|mem
argument_list|,
name|gen_rtx_SUBREG
argument_list|(
name|HImode
argument_list|,
name|zeroreg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|&
literal|0x01
condition|)
block|{
name|rtx
name|mem
init|=
name|adjust_automodify_address_nv
argument_list|(
name|dst
argument_list|,
name|QImode
argument_list|,
name|destreg
argument_list|,
name|offset
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_strset
argument_list|(
name|destreg
argument_list|,
name|mem
argument_list|,
name|gen_rtx_SUBREG
argument_list|(
name|QImode
argument_list|,
name|zeroreg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|rtx
name|countreg2
decl_stmt|;
name|rtx
name|label
init|=
name|NULL
decl_stmt|;
comment|/* Compute desired alignment of the string operation.  */
name|int
name|desired_alignment
init|=
operator|(
name|TARGET_PENTIUMPRO
operator|&&
operator|(
name|count
operator|==
literal|0
operator|||
name|count
operator|>=
operator|(
name|unsigned
name|int
operator|)
literal|260
operator|)
condition|?
literal|8
else|:
name|UNITS_PER_WORD
operator|)
decl_stmt|;
comment|/* In case we don't know anything about the alignment, default to          library version, since it is usually equally fast and result in          shorter code.  	 Also emit call when we know that the count is large and call overhead 	 will not be important.  */
if|if
condition|(
operator|!
name|TARGET_INLINE_ALL_STRINGOPS
operator|&&
operator|(
name|align
operator|<
name|UNITS_PER_WORD
operator|||
operator|!
name|TARGET_REP_MOVL_OPTIMAL
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TARGET_SINGLE_STRINGOP
condition|)
name|emit_insn
argument_list|(
name|gen_cld
argument_list|()
argument_list|)
expr_stmt|;
name|countreg2
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|countreg
operator|=
name|copy_to_mode_reg
argument_list|(
name|counter_mode
argument_list|,
name|count_exp
argument_list|)
expr_stmt|;
name|zeroreg
operator|=
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
comment|/* Get rid of MEM_OFFSET, it won't be accurate.  */
name|dst
operator|=
name|change_address
argument_list|(
name|dst
argument_list|,
name|BLKmode
argument_list|,
name|destreg
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
operator|&&
name|align
operator|<
name|desired_alignment
condition|)
block|{
name|label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|countreg
argument_list|,
name|GEN_INT
argument_list|(
name|desired_alignment
operator|-
literal|1
argument_list|)
argument_list|,
name|LEU
argument_list|,
literal|0
argument_list|,
name|counter_mode
argument_list|,
literal|1
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|align
operator|<=
literal|1
condition|)
block|{
name|rtx
name|label
init|=
name|ix86_expand_aligntest
argument_list|(
name|destreg
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_strset
argument_list|(
name|destreg
argument_list|,
name|dst
argument_list|,
name|gen_rtx_SUBREG
argument_list|(
name|QImode
argument_list|,
name|zeroreg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ix86_adjust_counter
argument_list|(
name|countreg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|align
operator|<=
literal|2
condition|)
block|{
name|rtx
name|label
init|=
name|ix86_expand_aligntest
argument_list|(
name|destreg
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_strset
argument_list|(
name|destreg
argument_list|,
name|dst
argument_list|,
name|gen_rtx_SUBREG
argument_list|(
name|HImode
argument_list|,
name|zeroreg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ix86_adjust_counter
argument_list|(
name|countreg
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|align
operator|<=
literal|4
operator|&&
name|desired_alignment
operator|>
literal|4
condition|)
block|{
name|rtx
name|label
init|=
name|ix86_expand_aligntest
argument_list|(
name|destreg
argument_list|,
literal|4
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_strset
argument_list|(
name|destreg
argument_list|,
name|dst
argument_list|,
operator|(
name|TARGET_64BIT
condition|?
name|gen_rtx_SUBREG
argument_list|(
name|SImode
argument_list|,
name|zeroreg
argument_list|,
literal|0
argument_list|)
else|:
name|zeroreg
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|ix86_adjust_counter
argument_list|(
name|countreg
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|label
operator|&&
name|desired_alignment
operator|>
literal|4
operator|&&
operator|!
name|TARGET_64BIT
condition|)
block|{
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|=
literal|1
expr_stmt|;
name|label
operator|=
name|NULL_RTX
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TARGET_SINGLE_STRINGOP
condition|)
name|emit_insn
argument_list|(
name|gen_cld
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_lshrdi3
argument_list|(
name|countreg2
argument_list|,
name|ix86_zero_extend_to_Pmode
argument_list|(
name|countreg
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
literal|3
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|destexp
operator|=
name|gen_rtx_ASHIFT
argument_list|(
name|Pmode
argument_list|,
name|countreg2
argument_list|,
name|GEN_INT
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|emit_insn
argument_list|(
name|gen_lshrsi3
argument_list|(
name|countreg2
argument_list|,
name|countreg
argument_list|,
name|const2_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|destexp
operator|=
name|gen_rtx_ASHIFT
argument_list|(
name|Pmode
argument_list|,
name|countreg2
argument_list|,
name|const2_rtx
argument_list|)
expr_stmt|;
block|}
name|destexp
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|destexp
argument_list|,
name|destreg
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rep_stos
argument_list|(
name|destreg
argument_list|,
name|countreg2
argument_list|,
name|dst
argument_list|,
name|zeroreg
argument_list|,
name|destexp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|label
condition|)
block|{
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_64BIT
operator|&&
name|align
operator|>
literal|4
operator|&&
name|count
operator|!=
literal|0
operator|&&
operator|(
name|count
operator|&
literal|4
operator|)
condition|)
name|emit_insn
argument_list|(
name|gen_strset
argument_list|(
name|destreg
argument_list|,
name|dst
argument_list|,
name|gen_rtx_SUBREG
argument_list|(
name|SImode
argument_list|,
name|zeroreg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
operator|&&
operator|(
name|align
operator|<=
literal|4
operator|||
name|count
operator|==
literal|0
operator|)
condition|)
block|{
name|rtx
name|label
init|=
name|ix86_expand_aligntest
argument_list|(
name|countreg
argument_list|,
literal|4
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_strset
argument_list|(
name|destreg
argument_list|,
name|dst
argument_list|,
name|gen_rtx_SUBREG
argument_list|(
name|SImode
argument_list|,
name|zeroreg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|align
operator|>
literal|2
operator|&&
name|count
operator|!=
literal|0
operator|&&
operator|(
name|count
operator|&
literal|2
operator|)
condition|)
name|emit_insn
argument_list|(
name|gen_strset
argument_list|(
name|destreg
argument_list|,
name|dst
argument_list|,
name|gen_rtx_SUBREG
argument_list|(
name|HImode
argument_list|,
name|zeroreg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|align
operator|<=
literal|2
operator|||
name|count
operator|==
literal|0
condition|)
block|{
name|rtx
name|label
init|=
name|ix86_expand_aligntest
argument_list|(
name|countreg
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_strset
argument_list|(
name|destreg
argument_list|,
name|dst
argument_list|,
name|gen_rtx_SUBREG
argument_list|(
name|HImode
argument_list|,
name|zeroreg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|align
operator|>
literal|1
operator|&&
name|count
operator|!=
literal|0
operator|&&
operator|(
name|count
operator|&
literal|1
operator|)
condition|)
name|emit_insn
argument_list|(
name|gen_strset
argument_list|(
name|destreg
argument_list|,
name|dst
argument_list|,
name|gen_rtx_SUBREG
argument_list|(
name|QImode
argument_list|,
name|zeroreg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|align
operator|<=
literal|1
operator|||
name|count
operator|==
literal|0
condition|)
block|{
name|rtx
name|label
init|=
name|ix86_expand_aligntest
argument_list|(
name|countreg
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_strset
argument_list|(
name|destreg
argument_list|,
name|dst
argument_list|,
name|gen_rtx_SUBREG
argument_list|(
name|QImode
argument_list|,
name|zeroreg
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Expand strlen.  */
end_comment

begin_function
name|int
name|ix86_expand_strlen
parameter_list|(
name|rtx
name|out
parameter_list|,
name|rtx
name|src
parameter_list|,
name|rtx
name|eoschar
parameter_list|,
name|rtx
name|align
parameter_list|)
block|{
name|rtx
name|addr
decl_stmt|,
name|scratch1
decl_stmt|,
name|scratch2
decl_stmt|,
name|scratch3
decl_stmt|,
name|scratch4
decl_stmt|;
comment|/* The generic case of strlen expander is long.  Avoid it's      expanding unless TARGET_INLINE_ALL_STRINGOPS.  */
if|if
condition|(
name|TARGET_UNROLL_STRLEN
operator|&&
name|eoschar
operator|==
name|const0_rtx
operator|&&
name|optimize
operator|>
literal|1
operator|&&
operator|!
name|TARGET_INLINE_ALL_STRINGOPS
operator|&&
operator|!
name|optimize_size
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|align
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|INTVAL
argument_list|(
name|align
argument_list|)
operator|<
literal|4
operator|)
condition|)
return|return
literal|0
return|;
name|addr
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|scratch1
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_UNROLL_STRLEN
operator|&&
name|eoschar
operator|==
name|const0_rtx
operator|&&
name|optimize
operator|>
literal|1
operator|&&
operator|!
name|optimize_size
condition|)
block|{
comment|/* Well it seems that some optimizer does not combine a call like          foo(strlen(bar), strlen(bar));          when the move and the subtraction is done here.  It does calculate          the length just once when these instructions are done inside of          output_strlen_unroll().  But I think since&bar[strlen(bar)] is          often used and I use one fewer register for the lifetime of          output_strlen_unroll() this is better.  */
name|emit_move_insn
argument_list|(
name|out
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|ix86_expand_strlensi_unroll_1
argument_list|(
name|out
argument_list|,
name|src
argument_list|,
name|align
argument_list|)
expr_stmt|;
comment|/* strlensi_unroll_1 returns the address of the zero at the end of          the string, like memchr(), so compute the length by subtracting          the start address.  */
if|if
condition|(
name|TARGET_64BIT
condition|)
name|emit_insn
argument_list|(
name|gen_subdi3
argument_list|(
name|out
argument_list|,
name|out
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_subsi3
argument_list|(
name|out
argument_list|,
name|out
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|unspec
decl_stmt|;
name|scratch2
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|scratch3
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|scratch4
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|constm1_rtx
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|scratch3
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|eoschar
operator|=
name|force_reg
argument_list|(
name|QImode
argument_list|,
name|eoschar
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_cld
argument_list|()
argument_list|)
expr_stmt|;
name|src
operator|=
name|replace_equiv_address_nv
argument_list|(
name|src
argument_list|,
name|scratch3
argument_list|)
expr_stmt|;
comment|/* If .md starts supporting :P, this can be done in .md.  */
name|unspec
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|4
argument_list|,
name|src
argument_list|,
name|eoschar
argument_list|,
name|align
argument_list|,
name|scratch4
argument_list|)
argument_list|,
name|UNSPEC_SCAS
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_strlenqi_1
argument_list|(
name|scratch1
argument_list|,
name|scratch3
argument_list|,
name|unspec
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_one_cmpldi2
argument_list|(
name|scratch2
argument_list|,
name|scratch1
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|out
argument_list|,
name|scratch2
argument_list|,
name|constm1_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|emit_insn
argument_list|(
name|gen_one_cmplsi2
argument_list|(
name|scratch2
argument_list|,
name|scratch1
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|out
argument_list|,
name|scratch2
argument_list|,
name|constm1_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Expand the appropriate insns for doing strlen if not just doing    repnz; scasb     out = result, initialized with the start address    align_rtx = alignment of the address.    scratch = scratch register, initialized with the startaddress when 	not aligned, otherwise undefined     This is just the body. It needs the initializations mentioned above and    some address computing at the end.  These things are done in i386.md.  */
end_comment

begin_function
specifier|static
name|void
name|ix86_expand_strlensi_unroll_1
parameter_list|(
name|rtx
name|out
parameter_list|,
name|rtx
name|src
parameter_list|,
name|rtx
name|align_rtx
parameter_list|)
block|{
name|int
name|align
decl_stmt|;
name|rtx
name|tmp
decl_stmt|;
name|rtx
name|align_2_label
init|=
name|NULL_RTX
decl_stmt|;
name|rtx
name|align_3_label
init|=
name|NULL_RTX
decl_stmt|;
name|rtx
name|align_4_label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|rtx
name|end_0_label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|rtx
name|mem
decl_stmt|;
name|rtx
name|tmpreg
init|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
decl_stmt|;
name|rtx
name|scratch
init|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
decl_stmt|;
name|rtx
name|cmp
decl_stmt|;
name|align
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|align_rtx
argument_list|)
operator|==
name|CONST_INT
condition|)
name|align
operator|=
name|INTVAL
argument_list|(
name|align_rtx
argument_list|)
expr_stmt|;
comment|/* Loop to check 1..3 bytes for null to get an aligned pointer.  */
comment|/* Is there a known alignment and is it less than 4?  */
if|if
condition|(
name|align
operator|<
literal|4
condition|)
block|{
name|rtx
name|scratch1
init|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|scratch1
argument_list|,
name|out
argument_list|)
expr_stmt|;
comment|/* Is there a known alignment and is it not 2? */
if|if
condition|(
name|align
operator|!=
literal|2
condition|)
block|{
name|align_3_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
comment|/* Label when aligned to 3-byte */
name|align_2_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
comment|/* Label when aligned to 2-byte */
comment|/* Leave just the 3 lower bits.  */
name|align_rtx
operator|=
name|expand_binop
argument_list|(
name|Pmode
argument_list|,
name|and_optab
argument_list|,
name|scratch1
argument_list|,
name|GEN_INT
argument_list|(
literal|3
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|align_rtx
argument_list|,
name|const0_rtx
argument_list|,
name|EQ
argument_list|,
name|NULL
argument_list|,
name|Pmode
argument_list|,
literal|1
argument_list|,
name|align_4_label
argument_list|)
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|align_rtx
argument_list|,
name|GEN_INT
argument_list|(
literal|2
argument_list|)
argument_list|,
name|EQ
argument_list|,
name|NULL
argument_list|,
name|Pmode
argument_list|,
literal|1
argument_list|,
name|align_2_label
argument_list|)
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|align_rtx
argument_list|,
name|GEN_INT
argument_list|(
literal|2
argument_list|)
argument_list|,
name|GTU
argument_list|,
name|NULL
argument_list|,
name|Pmode
argument_list|,
literal|1
argument_list|,
name|align_3_label
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Since the alignment is 2, we have to check 2 or 0 bytes; 	     check if is aligned to 4 - byte.  */
name|align_rtx
operator|=
name|expand_binop
argument_list|(
name|Pmode
argument_list|,
name|and_optab
argument_list|,
name|scratch1
argument_list|,
name|GEN_INT
argument_list|(
literal|2
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|align_rtx
argument_list|,
name|const0_rtx
argument_list|,
name|EQ
argument_list|,
name|NULL
argument_list|,
name|Pmode
argument_list|,
literal|1
argument_list|,
name|align_4_label
argument_list|)
expr_stmt|;
block|}
name|mem
operator|=
name|change_address
argument_list|(
name|src
argument_list|,
name|QImode
argument_list|,
name|out
argument_list|)
expr_stmt|;
comment|/* Now compare the bytes.  */
comment|/* Compare the first n unaligned byte on a byte per byte basis.  */
name|emit_cmp_and_jump_insns
argument_list|(
name|mem
argument_list|,
name|const0_rtx
argument_list|,
name|EQ
argument_list|,
name|NULL
argument_list|,
name|QImode
argument_list|,
literal|1
argument_list|,
name|end_0_label
argument_list|)
expr_stmt|;
comment|/* Increment the address.  */
if|if
condition|(
name|TARGET_64BIT
condition|)
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|out
argument_list|,
name|out
argument_list|,
name|const1_rtx
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|out
argument_list|,
name|out
argument_list|,
name|const1_rtx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Not needed with an alignment of 2 */
if|if
condition|(
name|align
operator|!=
literal|2
condition|)
block|{
name|emit_label
argument_list|(
name|align_2_label
argument_list|)
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|mem
argument_list|,
name|const0_rtx
argument_list|,
name|EQ
argument_list|,
name|NULL
argument_list|,
name|QImode
argument_list|,
literal|1
argument_list|,
name|end_0_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|out
argument_list|,
name|out
argument_list|,
name|const1_rtx
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|out
argument_list|,
name|out
argument_list|,
name|const1_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|align_3_label
argument_list|)
expr_stmt|;
block|}
name|emit_cmp_and_jump_insns
argument_list|(
name|mem
argument_list|,
name|const0_rtx
argument_list|,
name|EQ
argument_list|,
name|NULL
argument_list|,
name|QImode
argument_list|,
literal|1
argument_list|,
name|end_0_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|out
argument_list|,
name|out
argument_list|,
name|const1_rtx
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|out
argument_list|,
name|out
argument_list|,
name|const1_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Generate loop to check 4 bytes at a time.  It is not a good idea to      align this loop.  It gives only huge programs, but does not help to      speed up.  */
name|emit_label
argument_list|(
name|align_4_label
argument_list|)
expr_stmt|;
name|mem
operator|=
name|change_address
argument_list|(
name|src
argument_list|,
name|SImode
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|scratch
argument_list|,
name|mem
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|out
argument_list|,
name|out
argument_list|,
name|GEN_INT
argument_list|(
literal|4
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|out
argument_list|,
name|out
argument_list|,
name|GEN_INT
argument_list|(
literal|4
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This formula yields a nonzero result iff one of the bytes is zero.      This saves three branches inside loop and many cycles.  */
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|tmpreg
argument_list|,
name|scratch
argument_list|,
name|GEN_INT
argument_list|(
operator|-
literal|0x01010101
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_one_cmplsi2
argument_list|(
name|scratch
argument_list|,
name|scratch
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_andsi3
argument_list|(
name|tmpreg
argument_list|,
name|tmpreg
argument_list|,
name|scratch
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_andsi3
argument_list|(
name|tmpreg
argument_list|,
name|tmpreg
argument_list|,
name|gen_int_mode
argument_list|(
literal|0x80808080
argument_list|,
name|SImode
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|tmpreg
argument_list|,
name|const0_rtx
argument_list|,
name|EQ
argument_list|,
literal|0
argument_list|,
name|SImode
argument_list|,
literal|1
argument_list|,
name|align_4_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_CMOVE
condition|)
block|{
name|rtx
name|reg
init|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
decl_stmt|;
name|rtx
name|reg2
init|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|tmpreg
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_lshrsi3
argument_list|(
name|reg
argument_list|,
name|reg
argument_list|,
name|GEN_INT
argument_list|(
literal|16
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If zero is not in the first two bytes, move two bytes forward.  */
name|emit_insn
argument_list|(
name|gen_testsi_ccno_1
argument_list|(
name|tmpreg
argument_list|,
name|GEN_INT
argument_list|(
literal|0x8080
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_REG
argument_list|(
name|CCNOmode
argument_list|,
name|FLAGS_REG
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_EQ
argument_list|(
name|VOIDmode
argument_list|,
name|tmp
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|tmpreg
argument_list|,
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|SImode
argument_list|,
name|tmp
argument_list|,
name|reg
argument_list|,
name|tmpreg
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Emit lea manually to avoid clobbering of flags.  */
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|SImode
argument_list|,
name|reg2
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|out
argument_list|,
name|GEN_INT
argument_list|(
literal|2
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_REG
argument_list|(
name|CCNOmode
argument_list|,
name|FLAGS_REG
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_EQ
argument_list|(
name|VOIDmode
argument_list|,
name|tmp
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|out
argument_list|,
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|Pmode
argument_list|,
name|tmp
argument_list|,
name|reg2
argument_list|,
name|out
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|end_2_label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
comment|/* Is zero in the first two bytes? */
name|emit_insn
argument_list|(
name|gen_testsi_ccno_1
argument_list|(
name|tmpreg
argument_list|,
name|GEN_INT
argument_list|(
literal|0x8080
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_REG
argument_list|(
name|CCNOmode
argument_list|,
name|FLAGS_REG
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_NE
argument_list|(
name|VOIDmode
argument_list|,
name|tmp
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|VOIDmode
argument_list|,
name|tmp
argument_list|,
name|gen_rtx_LABEL_REF
argument_list|(
name|VOIDmode
argument_list|,
name|end_2_label
argument_list|)
argument_list|,
name|pc_rtx
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|emit_jump_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|pc_rtx
argument_list|,
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|JUMP_LABEL
argument_list|(
name|tmp
argument_list|)
operator|=
name|end_2_label
expr_stmt|;
comment|/* Not in the first two.  Move two bytes forward.  */
name|emit_insn
argument_list|(
name|gen_lshrsi3
argument_list|(
name|tmpreg
argument_list|,
name|tmpreg
argument_list|,
name|GEN_INT
argument_list|(
literal|16
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|out
argument_list|,
name|out
argument_list|,
name|GEN_INT
argument_list|(
literal|2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|out
argument_list|,
name|out
argument_list|,
name|GEN_INT
argument_list|(
literal|2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|end_2_label
argument_list|)
expr_stmt|;
block|}
comment|/* Avoid branch in fixing the byte.  */
name|tmpreg
operator|=
name|gen_lowpart
argument_list|(
name|QImode
argument_list|,
name|tmpreg
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_addqi3_cc
argument_list|(
name|tmpreg
argument_list|,
name|tmpreg
argument_list|,
name|tmpreg
argument_list|)
argument_list|)
expr_stmt|;
name|cmp
operator|=
name|gen_rtx_LTU
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|CCmode
argument_list|,
literal|17
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
name|emit_insn
argument_list|(
name|gen_subdi3_carry_rex64
argument_list|(
name|out
argument_list|,
name|out
argument_list|,
name|GEN_INT
argument_list|(
literal|3
argument_list|)
argument_list|,
name|cmp
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_subsi3_carry
argument_list|(
name|out
argument_list|,
name|out
argument_list|,
name|GEN_INT
argument_list|(
literal|3
argument_list|)
argument_list|,
name|cmp
argument_list|)
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|end_0_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ix86_expand_call
parameter_list|(
name|rtx
name|retval
parameter_list|,
name|rtx
name|fnaddr
parameter_list|,
name|rtx
name|callarg1
parameter_list|,
name|rtx
name|callarg2
name|ATTRIBUTE_UNUSED
parameter_list|,
name|rtx
name|pop
parameter_list|,
name|int
name|sibcall
parameter_list|)
block|{
name|rtx
name|use
init|=
name|NULL
decl_stmt|,
name|call
decl_stmt|;
if|if
condition|(
name|pop
operator|==
name|const0_rtx
condition|)
name|pop
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
operator|&&
name|pop
condition|)
name|abort
argument_list|()
expr_stmt|;
if|#
directive|if
name|TARGET_MACHO
if|if
condition|(
name|flag_pic
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|fnaddr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
name|fnaddr
operator|=
name|machopic_indirect_call_target
argument_list|(
name|fnaddr
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Static functions and indirect calls don't need the pic register.  */
if|if
condition|(
operator|!
name|TARGET_64BIT
operator|&&
name|flag_pic
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|fnaddr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
operator|!
name|SYMBOL_REF_LOCAL_P
argument_list|(
name|XEXP
argument_list|(
name|fnaddr
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|use_reg
argument_list|(
operator|&
name|use
argument_list|,
name|pic_offset_table_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
operator|&&
name|INTVAL
argument_list|(
name|callarg2
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|rtx
name|al
init|=
name|gen_rtx_REG
argument_list|(
name|QImode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|al
argument_list|,
name|callarg2
argument_list|)
expr_stmt|;
name|use_reg
argument_list|(
operator|&
name|use
argument_list|,
name|al
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TARGET_MACHO */
if|if
condition|(
operator|!
name|call_insn_operand
argument_list|(
name|XEXP
argument_list|(
name|fnaddr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|)
condition|)
block|{
name|fnaddr
operator|=
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|fnaddr
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fnaddr
operator|=
name|gen_rtx_MEM
argument_list|(
name|QImode
argument_list|,
name|fnaddr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sibcall
operator|&&
name|TARGET_64BIT
operator|&&
operator|!
name|constant_call_address_operand
argument_list|(
name|XEXP
argument_list|(
name|fnaddr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|)
condition|)
block|{
name|rtx
name|addr
decl_stmt|;
name|addr
operator|=
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|fnaddr
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fnaddr
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|FIRST_REX_INT_REG
operator|+
literal|3
comment|/* R11 */
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|fnaddr
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|fnaddr
operator|=
name|gen_rtx_MEM
argument_list|(
name|QImode
argument_list|,
name|fnaddr
argument_list|)
expr_stmt|;
block|}
name|call
operator|=
name|gen_rtx_CALL
argument_list|(
name|VOIDmode
argument_list|,
name|fnaddr
argument_list|,
name|callarg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
condition|)
name|call
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|retval
argument_list|,
name|call
argument_list|)
expr_stmt|;
if|if
condition|(
name|pop
condition|)
block|{
name|pop
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|pop
argument_list|)
expr_stmt|;
name|pop
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|pop
argument_list|)
expr_stmt|;
name|call
operator|=
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|call
argument_list|,
name|pop
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|call
operator|=
name|emit_call_insn
argument_list|(
name|call
argument_list|)
expr_stmt|;
if|if
condition|(
name|use
condition|)
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|call
argument_list|)
operator|=
name|use
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Clear stack slot assignments remembered from previous functions.    This is called from INIT_EXPANDERS once before RTL is emitted for each    function.  */
end_comment

begin_function
specifier|static
name|struct
name|machine_function
modifier|*
name|ix86_init_machine_status
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|machine_function
modifier|*
name|f
decl_stmt|;
name|f
operator|=
name|ggc_alloc_cleared
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|machine_function
argument_list|)
argument_list|)
expr_stmt|;
name|f
operator|->
name|use_fast_prologue_epilogue_nregs
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|f
return|;
block|}
end_function

begin_comment
comment|/* Return a MEM corresponding to a stack slot with mode MODE.    Allocate a new slot if necessary.     The RTL for a function can have several slots available: N is    which slot to use.  */
end_comment

begin_function
name|rtx
name|assign_386_stack_local
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|struct
name|stack_local_entry
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
operator|||
name|n
operator|>=
name|MAX_386_STACK_LOCALS
condition|)
name|abort
argument_list|()
expr_stmt|;
for|for
control|(
name|s
operator|=
name|ix86_stack_locals
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
if|if
condition|(
name|s
operator|->
name|mode
operator|==
name|mode
operator|&&
name|s
operator|->
name|n
operator|==
name|n
condition|)
return|return
name|s
operator|->
name|rtl
return|;
name|s
operator|=
operator|(
expr|struct
name|stack_local_entry
operator|*
operator|)
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|stack_local_entry
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|n
operator|=
name|n
expr_stmt|;
name|s
operator|->
name|mode
operator|=
name|mode
expr_stmt|;
name|s
operator|->
name|rtl
operator|=
name|assign_stack_local
argument_list|(
name|mode
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|s
operator|->
name|next
operator|=
name|ix86_stack_locals
expr_stmt|;
name|ix86_stack_locals
operator|=
name|s
expr_stmt|;
return|return
name|s
operator|->
name|rtl
return|;
block|}
end_function

begin_comment
comment|/* Construct the SYMBOL_REF for the tls_get_addr function.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|rtx
name|ix86_tls_symbol
expr_stmt|;
end_expr_stmt

begin_function
name|rtx
name|ix86_tls_get_addr
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ix86_tls_symbol
condition|)
block|{
name|ix86_tls_symbol
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
operator|(
name|TARGET_GNU_TLS
operator|&&
operator|!
name|TARGET_64BIT
operator|)
condition|?
literal|"___tls_get_addr"
else|:
literal|"__tls_get_addr"
argument_list|)
expr_stmt|;
block|}
return|return
name|ix86_tls_symbol
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Calculate the length of the memory address in the instruction    encoding.  Does not include the one-byte modrm, opcode, or prefix.  */
end_comment

begin_function
specifier|static
name|int
name|memory_address_length
parameter_list|(
name|rtx
name|addr
parameter_list|)
block|{
name|struct
name|ix86_address
name|parts
decl_stmt|;
name|rtx
name|base
decl_stmt|,
name|index
decl_stmt|,
name|disp
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PRE_DEC
operator|||
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|POST_INC
operator|||
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PRE_MODIFY
operator|||
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|POST_MODIFY
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|ix86_decompose_address
argument_list|(
name|addr
argument_list|,
operator|&
name|parts
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|base
operator|=
name|parts
operator|.
name|base
expr_stmt|;
name|index
operator|=
name|parts
operator|.
name|index
expr_stmt|;
name|disp
operator|=
name|parts
operator|.
name|disp
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
comment|/* Rule of thumb:        - esp as the base always wants an index,        - ebp as the base always wants a displacement.  */
comment|/* Register Indirect.  */
if|if
condition|(
name|base
operator|&&
operator|!
name|index
operator|&&
operator|!
name|disp
condition|)
block|{
comment|/* esp (for its index) and ebp (for its displacement) need 	 the two-byte modrm form.  */
if|if
condition|(
name|addr
operator|==
name|stack_pointer_rtx
operator|||
name|addr
operator|==
name|arg_pointer_rtx
operator|||
name|addr
operator|==
name|frame_pointer_rtx
operator|||
name|addr
operator|==
name|hard_frame_pointer_rtx
condition|)
name|len
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Direct Addressing.  */
elseif|else
if|if
condition|(
name|disp
operator|&&
operator|!
name|base
operator|&&
operator|!
name|index
condition|)
name|len
operator|=
literal|4
expr_stmt|;
else|else
block|{
comment|/* Find the length of the displacement constant.  */
if|if
condition|(
name|disp
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|INTVAL
argument_list|(
name|disp
argument_list|)
argument_list|,
literal|'K'
argument_list|)
operator|&&
name|base
condition|)
name|len
operator|=
literal|1
expr_stmt|;
else|else
name|len
operator|=
literal|4
expr_stmt|;
block|}
comment|/* ebp always wants a displacement.  */
elseif|else
if|if
condition|(
name|base
operator|==
name|hard_frame_pointer_rtx
condition|)
name|len
operator|=
literal|1
expr_stmt|;
comment|/* An index requires the two-byte modrm form....  */
if|if
condition|(
name|index
comment|/* ...like esp, which always wants an index.  */
operator|||
name|base
operator|==
name|stack_pointer_rtx
operator|||
name|base
operator|==
name|arg_pointer_rtx
operator|||
name|base
operator|==
name|frame_pointer_rtx
condition|)
name|len
operator|+=
literal|1
expr_stmt|;
block|}
return|return
name|len
return|;
block|}
end_function

begin_comment
comment|/* Compute default value for "length_immediate" attribute.  When SHORTFORM    is set, expect that insn have 8bit immediate alternative.  */
end_comment

begin_function
name|int
name|ix86_attr_length_immediate_default
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|int
name|shortform
parameter_list|)
block|{
name|int
name|len
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|extract_insn_cached
argument_list|(
name|insn
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|recog_data
operator|.
name|n_operands
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|len
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|shortform
operator|&&
name|GET_CODE
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|CONST_OK_FOR_LETTER_P
argument_list|(
name|INTVAL
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
argument_list|,
literal|'K'
argument_list|)
condition|)
name|len
operator|=
literal|1
expr_stmt|;
else|else
block|{
switch|switch
condition|(
name|get_attr_mode
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|MODE_QI
case|:
name|len
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|MODE_HI
case|:
name|len
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|MODE_SI
case|:
name|len
operator|+=
literal|4
expr_stmt|;
break|break;
comment|/* Immediates for DImode instructions are encoded as 32bit sign extended values.  */
case|case
name|MODE_DI
case|:
name|len
operator|+=
literal|4
expr_stmt|;
break|break;
default|default:
name|fatal_insn
argument_list|(
literal|"unknown insn mode"
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|len
return|;
block|}
end_function

begin_comment
comment|/* Compute default value for "length_address" attribute.  */
end_comment

begin_function
name|int
name|ix86_attr_length_address_default
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|get_attr_type
argument_list|(
name|insn
argument_list|)
operator|==
name|TYPE_LEA
condition|)
block|{
name|rtx
name|set
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|set
argument_list|)
operator|==
name|SET
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|set
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|set
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
name|set
operator|=
name|XVECEXP
argument_list|(
name|set
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
return|return
name|memory_address_length
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
return|;
block|}
name|extract_insn_cached
argument_list|(
name|insn
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|recog_data
operator|.
name|n_operands
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
operator|==
name|MEM
condition|)
block|{
return|return
name|memory_address_length
argument_list|(
name|XEXP
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the maximum number of instructions a cpu can issue.  */
end_comment

begin_function
specifier|static
name|int
name|ix86_issue_rate
parameter_list|(
name|void
parameter_list|)
block|{
switch|switch
condition|(
name|ix86_tune
condition|)
block|{
case|case
name|PROCESSOR_PENTIUM
case|:
case|case
name|PROCESSOR_K6
case|:
return|return
literal|2
return|;
case|case
name|PROCESSOR_PENTIUMPRO
case|:
case|case
name|PROCESSOR_PENTIUM4
case|:
case|case
name|PROCESSOR_ATHLON
case|:
case|case
name|PROCESSOR_K8
case|:
return|return
literal|3
return|;
default|default:
return|return
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/* A subroutine of ix86_adjust_cost -- return true iff INSN reads flags set    by DEP_INSN and nothing set by DEP_INSN.  */
end_comment

begin_function
specifier|static
name|int
name|ix86_flags_dependant
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|dep_insn
parameter_list|,
name|enum
name|attr_type
name|insn_type
parameter_list|)
block|{
name|rtx
name|set
decl_stmt|,
name|set2
decl_stmt|;
comment|/* Simplify the test for uninteresting insns.  */
if|if
condition|(
name|insn_type
operator|!=
name|TYPE_SETCC
operator|&&
name|insn_type
operator|!=
name|TYPE_ICMOV
operator|&&
name|insn_type
operator|!=
name|TYPE_FCMOV
operator|&&
name|insn_type
operator|!=
name|TYPE_IBR
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|dep_insn
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|set
operator|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|set2
operator|=
name|NULL_RTX
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|dep_insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|dep_insn
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
literal|2
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|dep_insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|dep_insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
block|{
name|set
operator|=
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|dep_insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|set2
operator|=
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|dep_insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|set
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|set
argument_list|)
operator|!=
name|FLAGS_REG
condition|)
return|return
literal|0
return|;
comment|/* This test is true if the dependent insn reads the flags but      not any other potentially set register.  */
if|if
condition|(
operator|!
name|reg_overlap_mentioned_p
argument_list|(
name|set
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|set2
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|set2
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of ix86_adjust_cost -- return true iff INSN has a memory    address with operands set by DEP_INSN.  */
end_comment

begin_function
specifier|static
name|int
name|ix86_agi_dependant
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|dep_insn
parameter_list|,
name|enum
name|attr_type
name|insn_type
parameter_list|)
block|{
name|rtx
name|addr
decl_stmt|;
if|if
condition|(
name|insn_type
operator|==
name|TYPE_LEA
operator|&&
name|TARGET_PENTIUM
condition|)
block|{
name|addr
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|SET
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
name|addr
operator|=
name|XVECEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
name|addr
operator|=
name|SET_SRC
argument_list|(
name|addr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
name|extract_insn_cached
argument_list|(
name|insn
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|recog_data
operator|.
name|n_operands
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|addr
operator|=
name|XEXP
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|found
goto|;
block|}
return|return
literal|0
return|;
name|found
label|:
empty_stmt|;
block|}
return|return
name|modified_in_p
argument_list|(
name|addr
argument_list|,
name|dep_insn
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ix86_adjust_cost
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|link
parameter_list|,
name|rtx
name|dep_insn
parameter_list|,
name|int
name|cost
parameter_list|)
block|{
name|enum
name|attr_type
name|insn_type
decl_stmt|,
name|dep_insn_type
decl_stmt|;
name|enum
name|attr_memory
name|memory
decl_stmt|,
name|dep_memory
decl_stmt|;
name|rtx
name|set
decl_stmt|,
name|set2
decl_stmt|;
name|int
name|dep_insn_code_number
decl_stmt|;
comment|/* Anti and output dependencies have zero cost on all CPUs.  */
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
name|dep_insn_code_number
operator|=
name|recog_memoized
argument_list|(
name|dep_insn
argument_list|)
expr_stmt|;
comment|/* If we can't recognize the insns, we can't really do anything.  */
if|if
condition|(
name|dep_insn_code_number
operator|<
literal|0
operator|||
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|<
literal|0
condition|)
return|return
name|cost
return|;
name|insn_type
operator|=
name|get_attr_type
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|dep_insn_type
operator|=
name|get_attr_type
argument_list|(
name|dep_insn
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ix86_tune
condition|)
block|{
case|case
name|PROCESSOR_PENTIUM
case|:
comment|/* Address Generation Interlock adds a cycle of latency.  */
if|if
condition|(
name|ix86_agi_dependant
argument_list|(
name|insn
argument_list|,
name|dep_insn
argument_list|,
name|insn_type
argument_list|)
condition|)
name|cost
operator|+=
literal|1
expr_stmt|;
comment|/* ??? Compares pair with jump/setcc.  */
if|if
condition|(
name|ix86_flags_dependant
argument_list|(
name|insn
argument_list|,
name|dep_insn
argument_list|,
name|insn_type
argument_list|)
condition|)
name|cost
operator|=
literal|0
expr_stmt|;
comment|/* Floating point stores require value to be ready one cycle earlier.  */
if|if
condition|(
name|insn_type
operator|==
name|TYPE_FMOV
operator|&&
name|get_attr_memory
argument_list|(
name|insn
argument_list|)
operator|==
name|MEMORY_STORE
operator|&&
operator|!
name|ix86_agi_dependant
argument_list|(
name|insn
argument_list|,
name|dep_insn
argument_list|,
name|insn_type
argument_list|)
condition|)
name|cost
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|PROCESSOR_PENTIUMPRO
case|:
name|memory
operator|=
name|get_attr_memory
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|dep_memory
operator|=
name|get_attr_memory
argument_list|(
name|dep_insn
argument_list|)
expr_stmt|;
comment|/* Since we can't represent delayed latencies of load+operation, 	 increase the cost here for non-imov insns.  */
if|if
condition|(
name|dep_insn_type
operator|!=
name|TYPE_IMOV
operator|&&
name|dep_insn_type
operator|!=
name|TYPE_FMOV
operator|&&
operator|(
name|dep_memory
operator|==
name|MEMORY_LOAD
operator|||
name|dep_memory
operator|==
name|MEMORY_BOTH
operator|)
condition|)
name|cost
operator|+=
literal|1
expr_stmt|;
comment|/* INT->FP conversion is expensive.  */
if|if
condition|(
name|get_attr_fp_int_src
argument_list|(
name|dep_insn
argument_list|)
condition|)
name|cost
operator|+=
literal|5
expr_stmt|;
comment|/* There is one cycle extra latency between an FP op and a store.  */
if|if
condition|(
name|insn_type
operator|==
name|TYPE_FMOV
operator|&&
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|dep_insn
argument_list|)
operator|)
operator|!=
name|NULL_RTX
operator|&&
operator|(
name|set2
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
name|NULL_RTX
operator|&&
name|rtx_equal_p
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|set2
argument_list|)
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set2
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
name|cost
operator|+=
literal|1
expr_stmt|;
comment|/* Show ability of reorder buffer to hide latency of load by executing 	 in parallel with previous instruction in case 	 previous instruction is not needed to compute the address.  */
if|if
condition|(
operator|(
name|memory
operator|==
name|MEMORY_LOAD
operator|||
name|memory
operator|==
name|MEMORY_BOTH
operator|)
operator|&&
operator|!
name|ix86_agi_dependant
argument_list|(
name|insn
argument_list|,
name|dep_insn
argument_list|,
name|insn_type
argument_list|)
condition|)
block|{
comment|/* Claim moves to take one cycle, as core can issue one load 	     at time and the next load can start cycle later.  */
if|if
condition|(
name|dep_insn_type
operator|==
name|TYPE_IMOV
operator|||
name|dep_insn_type
operator|==
name|TYPE_FMOV
condition|)
name|cost
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|cost
operator|>
literal|1
condition|)
name|cost
operator|--
expr_stmt|;
block|}
break|break;
case|case
name|PROCESSOR_K6
case|:
name|memory
operator|=
name|get_attr_memory
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|dep_memory
operator|=
name|get_attr_memory
argument_list|(
name|dep_insn
argument_list|)
expr_stmt|;
comment|/* The esp dependency is resolved before the instruction is really          finished.  */
if|if
condition|(
operator|(
name|insn_type
operator|==
name|TYPE_PUSH
operator|||
name|insn_type
operator|==
name|TYPE_POP
operator|)
operator|&&
operator|(
name|dep_insn_type
operator|==
name|TYPE_PUSH
operator|||
name|dep_insn_type
operator|==
name|TYPE_POP
operator|)
condition|)
return|return
literal|1
return|;
comment|/* Since we can't represent delayed latencies of load+operation, 	 increase the cost here for non-imov insns.  */
if|if
condition|(
name|dep_memory
operator|==
name|MEMORY_LOAD
operator|||
name|dep_memory
operator|==
name|MEMORY_BOTH
condition|)
name|cost
operator|+=
operator|(
name|dep_insn_type
operator|!=
name|TYPE_IMOV
operator|)
condition|?
literal|2
else|:
literal|1
expr_stmt|;
comment|/* INT->FP conversion is expensive.  */
if|if
condition|(
name|get_attr_fp_int_src
argument_list|(
name|dep_insn
argument_list|)
condition|)
name|cost
operator|+=
literal|5
expr_stmt|;
comment|/* Show ability of reorder buffer to hide latency of load by executing 	 in parallel with previous instruction in case 	 previous instruction is not needed to compute the address.  */
if|if
condition|(
operator|(
name|memory
operator|==
name|MEMORY_LOAD
operator|||
name|memory
operator|==
name|MEMORY_BOTH
operator|)
operator|&&
operator|!
name|ix86_agi_dependant
argument_list|(
name|insn
argument_list|,
name|dep_insn
argument_list|,
name|insn_type
argument_list|)
condition|)
block|{
comment|/* Claim moves to take one cycle, as core can issue one load 	     at time and the next load can start cycle later.  */
if|if
condition|(
name|dep_insn_type
operator|==
name|TYPE_IMOV
operator|||
name|dep_insn_type
operator|==
name|TYPE_FMOV
condition|)
name|cost
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|cost
operator|>
literal|2
condition|)
name|cost
operator|-=
literal|2
expr_stmt|;
else|else
name|cost
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|PROCESSOR_ATHLON
case|:
case|case
name|PROCESSOR_K8
case|:
name|memory
operator|=
name|get_attr_memory
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|dep_memory
operator|=
name|get_attr_memory
argument_list|(
name|dep_insn
argument_list|)
expr_stmt|;
comment|/* Show ability of reorder buffer to hide latency of load by executing 	 in parallel with previous instruction in case 	 previous instruction is not needed to compute the address.  */
if|if
condition|(
operator|(
name|memory
operator|==
name|MEMORY_LOAD
operator|||
name|memory
operator|==
name|MEMORY_BOTH
operator|)
operator|&&
operator|!
name|ix86_agi_dependant
argument_list|(
name|insn
argument_list|,
name|dep_insn
argument_list|,
name|insn_type
argument_list|)
condition|)
block|{
name|enum
name|attr_unit
name|unit
init|=
name|get_attr_unit
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|int
name|loadcost
init|=
literal|3
decl_stmt|;
comment|/* Because of the difference between the length of integer and 	     floating unit pipeline preparation stages, the memory operands 	     for floating point are cheaper.  	     ??? For Athlon it the difference is most probably 2.  */
if|if
condition|(
name|unit
operator|==
name|UNIT_INTEGER
operator|||
name|unit
operator|==
name|UNIT_UNKNOWN
condition|)
name|loadcost
operator|=
literal|3
expr_stmt|;
else|else
name|loadcost
operator|=
name|TARGET_ATHLON
condition|?
literal|2
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|cost
operator|>=
name|loadcost
condition|)
name|cost
operator|-=
name|loadcost
expr_stmt|;
else|else
name|cost
operator|=
literal|0
expr_stmt|;
block|}
default|default:
break|break;
block|}
return|return
name|cost
return|;
block|}
end_function

begin_union
specifier|static
union|union
block|{
struct|struct
name|ppro_sched_data
block|{
name|rtx
name|decode
index|[
literal|3
index|]
decl_stmt|;
name|int
name|issued_this_cycle
decl_stmt|;
block|}
name|ppro
struct|;
block|}
name|ix86_sched_data
union|;
end_union

begin_function
specifier|static
name|enum
name|attr_ppro_uops
name|ix86_safe_ppro_uops
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
if|if
condition|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|>=
literal|0
condition|)
return|return
name|get_attr_ppro_uops
argument_list|(
name|insn
argument_list|)
return|;
else|else
return|return
name|PPRO_UOPS_MANY
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ix86_dump_ppro_packet
parameter_list|(
name|FILE
modifier|*
name|dump
parameter_list|)
block|{
if|if
condition|(
name|ix86_sched_data
operator|.
name|ppro
operator|.
name|decode
index|[
literal|0
index|]
condition|)
block|{
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"PPRO packet: %d"
argument_list|,
name|INSN_UID
argument_list|(
name|ix86_sched_data
operator|.
name|ppro
operator|.
name|decode
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ix86_sched_data
operator|.
name|ppro
operator|.
name|decode
index|[
literal|1
index|]
condition|)
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|" %d"
argument_list|,
name|INSN_UID
argument_list|(
name|ix86_sched_data
operator|.
name|ppro
operator|.
name|decode
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ix86_sched_data
operator|.
name|ppro
operator|.
name|decode
index|[
literal|2
index|]
condition|)
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|" %d"
argument_list|,
name|INSN_UID
argument_list|(
name|ix86_sched_data
operator|.
name|ppro
operator|.
name|decode
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|dump
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* We're beginning a new block.  Initialize data structures as necessary.  */
end_comment

begin_function
specifier|static
name|void
name|ix86_sched_init
parameter_list|(
name|FILE
modifier|*
name|dump
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|sched_verbose
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|veclen
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|memset
argument_list|(
operator|&
name|ix86_sched_data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ix86_sched_data
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Shift INSN to SLOT, and shift everything else down.  */
end_comment

begin_function
specifier|static
name|void
name|ix86_reorder_insn
parameter_list|(
name|rtx
modifier|*
name|insnp
parameter_list|,
name|rtx
modifier|*
name|slot
parameter_list|)
block|{
if|if
condition|(
name|insnp
operator|!=
name|slot
condition|)
block|{
name|rtx
name|insn
init|=
operator|*
name|insnp
decl_stmt|;
do|do
name|insnp
index|[
literal|0
index|]
operator|=
name|insnp
index|[
literal|1
index|]
expr_stmt|;
do|while
condition|(
operator|++
name|insnp
operator|!=
name|slot
condition|)
do|;
operator|*
name|insnp
operator|=
name|insn
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ix86_sched_reorder_ppro
parameter_list|(
name|rtx
modifier|*
name|ready
parameter_list|,
name|rtx
modifier|*
name|e_ready
parameter_list|)
block|{
name|rtx
name|decode
index|[
literal|3
index|]
decl_stmt|;
name|enum
name|attr_ppro_uops
name|cur_uops
decl_stmt|;
name|int
name|issued_this_cycle
decl_stmt|;
name|rtx
modifier|*
name|insnp
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* At this point .ppro.decode contains the state of the three      decoders from last "cycle".  That is, those insns that were      actually independent.  But here we're scheduling for the      decoder, and we may find things that are decodable in the      same cycle.  */
name|memcpy
argument_list|(
name|decode
argument_list|,
name|ix86_sched_data
operator|.
name|ppro
operator|.
name|decode
argument_list|,
sizeof|sizeof
argument_list|(
name|decode
argument_list|)
argument_list|)
expr_stmt|;
name|issued_this_cycle
operator|=
literal|0
expr_stmt|;
name|insnp
operator|=
name|e_ready
expr_stmt|;
name|cur_uops
operator|=
name|ix86_safe_ppro_uops
argument_list|(
operator|*
name|insnp
argument_list|)
expr_stmt|;
comment|/* If the decoders are empty, and we've a complex insn at the      head of the priority queue, let it issue without complaint.  */
if|if
condition|(
name|decode
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|cur_uops
operator|==
name|PPRO_UOPS_MANY
condition|)
block|{
name|decode
index|[
literal|0
index|]
operator|=
operator|*
name|insnp
expr_stmt|;
goto|goto
name|ppro_done
goto|;
block|}
comment|/* Otherwise, search for a 2-4 uop unsn to issue.  */
while|while
condition|(
name|cur_uops
operator|!=
name|PPRO_UOPS_FEW
condition|)
block|{
if|if
condition|(
name|insnp
operator|==
name|ready
condition|)
break|break;
name|cur_uops
operator|=
name|ix86_safe_ppro_uops
argument_list|(
operator|*
operator|--
name|insnp
argument_list|)
expr_stmt|;
block|}
comment|/* If so, move it to the head of the line.  */
if|if
condition|(
name|cur_uops
operator|==
name|PPRO_UOPS_FEW
condition|)
name|ix86_reorder_insn
argument_list|(
name|insnp
argument_list|,
name|e_ready
argument_list|)
expr_stmt|;
comment|/* Issue the head of the queue.  */
name|issued_this_cycle
operator|=
literal|1
expr_stmt|;
name|decode
index|[
literal|0
index|]
operator|=
operator|*
name|e_ready
operator|--
expr_stmt|;
block|}
comment|/* Look for simple insns to fill in the other two slots.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|3
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|decode
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|ready
operator|>
name|e_ready
condition|)
goto|goto
name|ppro_done
goto|;
name|insnp
operator|=
name|e_ready
expr_stmt|;
name|cur_uops
operator|=
name|ix86_safe_ppro_uops
argument_list|(
operator|*
name|insnp
argument_list|)
expr_stmt|;
while|while
condition|(
name|cur_uops
operator|!=
name|PPRO_UOPS_ONE
condition|)
block|{
if|if
condition|(
name|insnp
operator|==
name|ready
condition|)
break|break;
name|cur_uops
operator|=
name|ix86_safe_ppro_uops
argument_list|(
operator|*
operator|--
name|insnp
argument_list|)
expr_stmt|;
block|}
comment|/* Found one.  Move it to the head of the queue and issue it.  */
if|if
condition|(
name|cur_uops
operator|==
name|PPRO_UOPS_ONE
condition|)
block|{
name|ix86_reorder_insn
argument_list|(
name|insnp
argument_list|,
name|e_ready
argument_list|)
expr_stmt|;
name|decode
index|[
name|i
index|]
operator|=
operator|*
name|e_ready
operator|--
expr_stmt|;
name|issued_this_cycle
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* ??? Didn't find one.  Ideally, here we would do a lazy split 	   of 2-uop insns, issue one and queue the other.  */
block|}
name|ppro_done
label|:
if|if
condition|(
name|issued_this_cycle
operator|==
literal|0
condition|)
name|issued_this_cycle
operator|=
literal|1
expr_stmt|;
name|ix86_sched_data
operator|.
name|ppro
operator|.
name|issued_this_cycle
operator|=
name|issued_this_cycle
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We are about to being issuing insns for this clock cycle.    Override the default sort algorithm to better slot instructions.  */
end_comment

begin_function
specifier|static
name|int
name|ix86_sched_reorder
parameter_list|(
name|FILE
modifier|*
name|dump
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|sched_verbose
name|ATTRIBUTE_UNUSED
parameter_list|,
name|rtx
modifier|*
name|ready
parameter_list|,
name|int
modifier|*
name|n_readyp
parameter_list|,
name|int
name|clock_var
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
name|n_ready
init|=
operator|*
name|n_readyp
decl_stmt|;
name|rtx
modifier|*
name|e_ready
init|=
name|ready
operator|+
name|n_ready
operator|-
literal|1
decl_stmt|;
comment|/* Make sure to go ahead and initialize key items in      ix86_sched_data if we are not going to bother trying to      reorder the ready queue.  */
if|if
condition|(
name|n_ready
operator|<
literal|2
condition|)
block|{
name|ix86_sched_data
operator|.
name|ppro
operator|.
name|issued_this_cycle
operator|=
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
switch|switch
condition|(
name|ix86_tune
condition|)
block|{
default|default:
break|break;
case|case
name|PROCESSOR_PENTIUMPRO
case|:
name|ix86_sched_reorder_ppro
argument_list|(
name|ready
argument_list|,
name|e_ready
argument_list|)
expr_stmt|;
break|break;
block|}
name|out
label|:
return|return
name|ix86_issue_rate
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/* We are about to issue INSN.  Return the number of insns left on the    ready queue that can be issued this cycle.  */
end_comment

begin_function
specifier|static
name|int
name|ix86_variable_issue
parameter_list|(
name|FILE
modifier|*
name|dump
parameter_list|,
name|int
name|sched_verbose
parameter_list|,
name|rtx
name|insn
parameter_list|,
name|int
name|can_issue_more
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|ix86_tune
condition|)
block|{
default|default:
return|return
name|can_issue_more
operator|-
literal|1
return|;
case|case
name|PROCESSOR_PENTIUMPRO
case|:
block|{
name|enum
name|attr_ppro_uops
name|uops
init|=
name|ix86_safe_ppro_uops
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|uops
operator|==
name|PPRO_UOPS_MANY
condition|)
block|{
if|if
condition|(
name|sched_verbose
condition|)
name|ix86_dump_ppro_packet
argument_list|(
name|dump
argument_list|)
expr_stmt|;
name|ix86_sched_data
operator|.
name|ppro
operator|.
name|decode
index|[
literal|0
index|]
operator|=
name|insn
expr_stmt|;
name|ix86_sched_data
operator|.
name|ppro
operator|.
name|decode
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|ix86_sched_data
operator|.
name|ppro
operator|.
name|decode
index|[
literal|2
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|sched_verbose
condition|)
name|ix86_dump_ppro_packet
argument_list|(
name|dump
argument_list|)
expr_stmt|;
name|ix86_sched_data
operator|.
name|ppro
operator|.
name|decode
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|uops
operator|==
name|PPRO_UOPS_FEW
condition|)
block|{
if|if
condition|(
name|sched_verbose
condition|)
name|ix86_dump_ppro_packet
argument_list|(
name|dump
argument_list|)
expr_stmt|;
name|ix86_sched_data
operator|.
name|ppro
operator|.
name|decode
index|[
literal|0
index|]
operator|=
name|insn
expr_stmt|;
name|ix86_sched_data
operator|.
name|ppro
operator|.
name|decode
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|ix86_sched_data
operator|.
name|ppro
operator|.
name|decode
index|[
literal|2
index|]
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|ix86_sched_data
operator|.
name|ppro
operator|.
name|decode
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
name|ix86_sched_data
operator|.
name|ppro
operator|.
name|decode
index|[
name|i
index|]
operator|=
name|insn
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|==
literal|3
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|sched_verbose
condition|)
name|ix86_dump_ppro_packet
argument_list|(
name|dump
argument_list|)
expr_stmt|;
name|ix86_sched_data
operator|.
name|ppro
operator|.
name|decode
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
name|ix86_sched_data
operator|.
name|ppro
operator|.
name|decode
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|ix86_sched_data
operator|.
name|ppro
operator|.
name|decode
index|[
literal|2
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
return|return
operator|--
name|ix86_sched_data
operator|.
name|ppro
operator|.
name|issued_this_cycle
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ia32_use_dfa_pipeline_interface
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|TARGET_PENTIUM
operator|||
name|TARGET_ATHLON_K8
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* How many alternative schedules to try.  This should be as wide as the    scheduling freedom in the DFA, but no wider.  Making this value too    large results extra work for the scheduler.  */
end_comment

begin_function
specifier|static
name|int
name|ia32_multipass_dfa_lookahead
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|ix86_tune
operator|==
name|PROCESSOR_PENTIUM
condition|)
return|return
literal|2
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compute the alignment given to a constant that is being placed in memory.    EXP is the constant and ALIGN is the alignment that the object would    ordinarily have.    The value of this function is used instead of that alignment to align    the object.  */
end_comment

begin_function
name|int
name|ix86_constant_alignment
parameter_list|(
name|tree
name|exp
parameter_list|,
name|int
name|align
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|REAL_CST
condition|)
block|{
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|DFmode
operator|&&
name|align
operator|<
literal|64
condition|)
return|return
literal|64
return|;
elseif|else
if|if
condition|(
name|ALIGN_MODE_128
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|align
operator|<
literal|128
condition|)
return|return
literal|128
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|optimize_size
operator|&&
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|STRING_CST
operator|&&
operator|!
name|TARGET_NO_ALIGN_LONG_STRINGS
operator|&&
name|TREE_STRING_LENGTH
argument_list|(
name|exp
argument_list|)
operator|>=
literal|31
operator|&&
name|align
operator|<
name|BITS_PER_WORD
condition|)
return|return
name|BITS_PER_WORD
return|;
return|return
name|align
return|;
block|}
end_function

begin_comment
comment|/* Compute the alignment for a static variable.    TYPE is the data type, and ALIGN is the alignment that    the object would ordinarily have.  The value of this function is used    instead of that alignment to align the object.  */
end_comment

begin_function
name|int
name|ix86_data_alignment
parameter_list|(
name|tree
name|type
parameter_list|,
name|int
name|align
parameter_list|)
block|{
if|if
condition|(
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|>=
literal|256
operator|||
name|TREE_INT_CST_HIGH
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
operator|&&
name|align
operator|<
literal|256
condition|)
return|return
literal|256
return|;
comment|/* x86-64 ABI requires arrays greater than 16 bytes to be aligned      to 16byte boundary.  */
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
if|if
condition|(
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|>=
literal|128
operator|||
name|TREE_INT_CST_HIGH
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
operator|&&
name|align
operator|<
literal|128
condition|)
return|return
literal|128
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|DFmode
operator|&&
name|align
operator|<
literal|64
condition|)
return|return
literal|64
return|;
if|if
condition|(
name|ALIGN_MODE_128
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|align
operator|<
literal|128
condition|)
return|return
literal|128
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|COMPLEX_TYPE
condition|)
block|{
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|DCmode
operator|&&
name|align
operator|<
literal|64
condition|)
return|return
literal|64
return|;
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|XCmode
operator|&&
name|align
operator|<
literal|128
condition|)
return|return
literal|128
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|QUAL_UNION_TYPE
operator|)
operator|&&
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_MODE
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|DFmode
operator|&&
name|align
operator|<
literal|64
condition|)
return|return
literal|64
return|;
if|if
condition|(
name|ALIGN_MODE_128
argument_list|(
name|DECL_MODE
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|align
operator|<
literal|128
condition|)
return|return
literal|128
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REAL_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VECTOR_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
condition|)
block|{
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|DFmode
operator|&&
name|align
operator|<
literal|64
condition|)
return|return
literal|64
return|;
if|if
condition|(
name|ALIGN_MODE_128
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
name|align
operator|<
literal|128
condition|)
return|return
literal|128
return|;
block|}
return|return
name|align
return|;
block|}
end_function

begin_comment
comment|/* Compute the alignment for a local variable.    TYPE is the data type, and ALIGN is the alignment that    the object would ordinarily have.  The value of this macro is used    instead of that alignment to align the object.  */
end_comment

begin_function
name|int
name|ix86_local_alignment
parameter_list|(
name|tree
name|type
parameter_list|,
name|int
name|align
parameter_list|)
block|{
comment|/* x86-64 ABI requires arrays greater than 16 bytes to be aligned      to 16byte boundary.  */
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
if|if
condition|(
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|>=
literal|16
operator|||
name|TREE_INT_CST_HIGH
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
operator|&&
name|align
operator|<
literal|128
condition|)
return|return
literal|128
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|DFmode
operator|&&
name|align
operator|<
literal|64
condition|)
return|return
literal|64
return|;
if|if
condition|(
name|ALIGN_MODE_128
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|align
operator|<
literal|128
condition|)
return|return
literal|128
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|COMPLEX_TYPE
condition|)
block|{
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|DCmode
operator|&&
name|align
operator|<
literal|64
condition|)
return|return
literal|64
return|;
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|XCmode
operator|&&
name|align
operator|<
literal|128
condition|)
return|return
literal|128
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|QUAL_UNION_TYPE
operator|)
operator|&&
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_MODE
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|DFmode
operator|&&
name|align
operator|<
literal|64
condition|)
return|return
literal|64
return|;
if|if
condition|(
name|ALIGN_MODE_128
argument_list|(
name|DECL_MODE
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|align
operator|<
literal|128
condition|)
return|return
literal|128
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REAL_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VECTOR_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
condition|)
block|{
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|DFmode
operator|&&
name|align
operator|<
literal|64
condition|)
return|return
literal|64
return|;
if|if
condition|(
name|ALIGN_MODE_128
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
name|align
operator|<
literal|128
condition|)
return|return
literal|128
return|;
block|}
return|return
name|align
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit RTL insns to initialize the variable parts of a trampoline.    FNADDR is an RTX for the address of the function's pure code.    CXT is an RTX for the static chain value for the function.  */
end_comment

begin_function
name|void
name|x86_initialize_trampoline
parameter_list|(
name|rtx
name|tramp
parameter_list|,
name|rtx
name|fnaddr
parameter_list|,
name|rtx
name|cxt
parameter_list|)
block|{
if|if
condition|(
operator|!
name|TARGET_64BIT
condition|)
block|{
comment|/* Compute offset from the end of the jmp to the target function.  */
name|rtx
name|disp
init|=
name|expand_binop
argument_list|(
name|SImode
argument_list|,
name|sub_optab
argument_list|,
name|fnaddr
argument_list|,
name|plus_constant
argument_list|(
name|tramp
argument_list|,
literal|10
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_DIRECT
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|QImode
argument_list|,
name|tramp
argument_list|)
argument_list|,
name|gen_int_mode
argument_list|(
literal|0xb9
argument_list|,
name|QImode
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|tramp
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|cxt
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|QImode
argument_list|,
name|plus_constant
argument_list|(
name|tramp
argument_list|,
literal|5
argument_list|)
argument_list|)
argument_list|,
name|gen_int_mode
argument_list|(
literal|0xe9
argument_list|,
name|QImode
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|tramp
argument_list|,
literal|6
argument_list|)
argument_list|)
argument_list|,
name|disp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|offset
init|=
literal|0
decl_stmt|;
comment|/* Try to load address using shorter movl instead of movabs.          We may want to support movq for kernel mode, but kernel does not use          trampolines at the moment.  */
if|if
condition|(
name|x86_64_zero_extended_value
argument_list|(
name|fnaddr
argument_list|)
condition|)
block|{
name|fnaddr
operator|=
name|copy_to_mode_reg
argument_list|(
name|DImode
argument_list|,
name|fnaddr
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|HImode
argument_list|,
name|plus_constant
argument_list|(
name|tramp
argument_list|,
name|offset
argument_list|)
argument_list|)
argument_list|,
name|gen_int_mode
argument_list|(
literal|0xbb41
argument_list|,
name|HImode
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|tramp
argument_list|,
name|offset
operator|+
literal|2
argument_list|)
argument_list|)
argument_list|,
name|gen_lowpart
argument_list|(
name|SImode
argument_list|,
name|fnaddr
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|6
expr_stmt|;
block|}
else|else
block|{
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|HImode
argument_list|,
name|plus_constant
argument_list|(
name|tramp
argument_list|,
name|offset
argument_list|)
argument_list|)
argument_list|,
name|gen_int_mode
argument_list|(
literal|0xbb49
argument_list|,
name|HImode
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|DImode
argument_list|,
name|plus_constant
argument_list|(
name|tramp
argument_list|,
name|offset
operator|+
literal|2
argument_list|)
argument_list|)
argument_list|,
name|fnaddr
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|10
expr_stmt|;
block|}
comment|/* Load static chain using movabs to r10.  */
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|HImode
argument_list|,
name|plus_constant
argument_list|(
name|tramp
argument_list|,
name|offset
argument_list|)
argument_list|)
argument_list|,
name|gen_int_mode
argument_list|(
literal|0xba49
argument_list|,
name|HImode
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|DImode
argument_list|,
name|plus_constant
argument_list|(
name|tramp
argument_list|,
name|offset
operator|+
literal|2
argument_list|)
argument_list|)
argument_list|,
name|cxt
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|10
expr_stmt|;
comment|/* Jump to the r11 */
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|HImode
argument_list|,
name|plus_constant
argument_list|(
name|tramp
argument_list|,
name|offset
argument_list|)
argument_list|)
argument_list|,
name|gen_int_mode
argument_list|(
literal|0xff49
argument_list|,
name|HImode
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|QImode
argument_list|,
name|plus_constant
argument_list|(
name|tramp
argument_list|,
name|offset
operator|+
literal|2
argument_list|)
argument_list|)
argument_list|,
name|gen_int_mode
argument_list|(
literal|0xe3
argument_list|,
name|QImode
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
name|offset
operator|>
name|TRAMPOLINE_SIZE
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ENABLE_EXECUTE_STACK
name|emit_library_call
argument_list|(
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
literal|"__enable_execute_stack"
argument_list|)
argument_list|,
name|LCT_NORMAL
argument_list|,
name|VOIDmode
argument_list|,
literal|1
argument_list|,
name|tramp
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_define
define|#
directive|define
name|def_builtin
parameter_list|(
name|MASK
parameter_list|,
name|NAME
parameter_list|,
name|TYPE
parameter_list|,
name|CODE
parameter_list|)
define|\
value|do {								\   if ((MASK)& target_flags					\&& (!((MASK)& MASK_64BIT) || TARGET_64BIT))		\     builtin_function ((NAME), (TYPE), (CODE), BUILT_IN_MD,	\ 		      NULL, NULL_TREE);				\ } while (0)
end_define

begin_struct
struct|struct
name|builtin_description
block|{
specifier|const
name|unsigned
name|int
name|mask
decl_stmt|;
specifier|const
name|enum
name|insn_code
name|icode
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
specifier|const
name|enum
name|ix86_builtins
name|code
decl_stmt|;
specifier|const
name|enum
name|rtx_code
name|comparison
decl_stmt|;
specifier|const
name|unsigned
name|int
name|flag
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|builtin_description
name|bdesc_comi
index|[]
init|=
block|{
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_comi
block|,
literal|"__builtin_ia32_comieq"
block|,
name|IX86_BUILTIN_COMIEQSS
block|,
name|UNEQ
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_comi
block|,
literal|"__builtin_ia32_comilt"
block|,
name|IX86_BUILTIN_COMILTSS
block|,
name|UNLT
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_comi
block|,
literal|"__builtin_ia32_comile"
block|,
name|IX86_BUILTIN_COMILESS
block|,
name|UNLE
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_comi
block|,
literal|"__builtin_ia32_comigt"
block|,
name|IX86_BUILTIN_COMIGTSS
block|,
name|GT
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_comi
block|,
literal|"__builtin_ia32_comige"
block|,
name|IX86_BUILTIN_COMIGESS
block|,
name|GE
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_comi
block|,
literal|"__builtin_ia32_comineq"
block|,
name|IX86_BUILTIN_COMINEQSS
block|,
name|LTGT
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_ucomi
block|,
literal|"__builtin_ia32_ucomieq"
block|,
name|IX86_BUILTIN_UCOMIEQSS
block|,
name|UNEQ
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_ucomi
block|,
literal|"__builtin_ia32_ucomilt"
block|,
name|IX86_BUILTIN_UCOMILTSS
block|,
name|UNLT
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_ucomi
block|,
literal|"__builtin_ia32_ucomile"
block|,
name|IX86_BUILTIN_UCOMILESS
block|,
name|UNLE
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_ucomi
block|,
literal|"__builtin_ia32_ucomigt"
block|,
name|IX86_BUILTIN_UCOMIGTSS
block|,
name|GT
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_ucomi
block|,
literal|"__builtin_ia32_ucomige"
block|,
name|IX86_BUILTIN_UCOMIGESS
block|,
name|GE
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_ucomi
block|,
literal|"__builtin_ia32_ucomineq"
block|,
name|IX86_BUILTIN_UCOMINEQSS
block|,
name|LTGT
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_comi
block|,
literal|"__builtin_ia32_comisdeq"
block|,
name|IX86_BUILTIN_COMIEQSD
block|,
name|UNEQ
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_comi
block|,
literal|"__builtin_ia32_comisdlt"
block|,
name|IX86_BUILTIN_COMILTSD
block|,
name|UNLT
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_comi
block|,
literal|"__builtin_ia32_comisdle"
block|,
name|IX86_BUILTIN_COMILESD
block|,
name|UNLE
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_comi
block|,
literal|"__builtin_ia32_comisdgt"
block|,
name|IX86_BUILTIN_COMIGTSD
block|,
name|GT
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_comi
block|,
literal|"__builtin_ia32_comisdge"
block|,
name|IX86_BUILTIN_COMIGESD
block|,
name|GE
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_comi
block|,
literal|"__builtin_ia32_comisdneq"
block|,
name|IX86_BUILTIN_COMINEQSD
block|,
name|LTGT
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_ucomi
block|,
literal|"__builtin_ia32_ucomisdeq"
block|,
name|IX86_BUILTIN_UCOMIEQSD
block|,
name|UNEQ
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_ucomi
block|,
literal|"__builtin_ia32_ucomisdlt"
block|,
name|IX86_BUILTIN_UCOMILTSD
block|,
name|UNLT
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_ucomi
block|,
literal|"__builtin_ia32_ucomisdle"
block|,
name|IX86_BUILTIN_UCOMILESD
block|,
name|UNLE
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_ucomi
block|,
literal|"__builtin_ia32_ucomisdgt"
block|,
name|IX86_BUILTIN_UCOMIGTSD
block|,
name|GT
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_ucomi
block|,
literal|"__builtin_ia32_ucomisdge"
block|,
name|IX86_BUILTIN_UCOMIGESD
block|,
name|GE
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_ucomi
block|,
literal|"__builtin_ia32_ucomisdneq"
block|,
name|IX86_BUILTIN_UCOMINEQSD
block|,
name|LTGT
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|builtin_description
name|bdesc_2arg
index|[]
init|=
block|{
comment|/* SSE */
block|{
name|MASK_SSE
block|,
name|CODE_FOR_addv4sf3
block|,
literal|"__builtin_ia32_addps"
block|,
name|IX86_BUILTIN_ADDPS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_subv4sf3
block|,
literal|"__builtin_ia32_subps"
block|,
name|IX86_BUILTIN_SUBPS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_mulv4sf3
block|,
literal|"__builtin_ia32_mulps"
block|,
name|IX86_BUILTIN_MULPS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_divv4sf3
block|,
literal|"__builtin_ia32_divps"
block|,
name|IX86_BUILTIN_DIVPS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_vmaddv4sf3
block|,
literal|"__builtin_ia32_addss"
block|,
name|IX86_BUILTIN_ADDSS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_vmsubv4sf3
block|,
literal|"__builtin_ia32_subss"
block|,
name|IX86_BUILTIN_SUBSS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_vmmulv4sf3
block|,
literal|"__builtin_ia32_mulss"
block|,
name|IX86_BUILTIN_MULSS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_vmdivv4sf3
block|,
literal|"__builtin_ia32_divss"
block|,
name|IX86_BUILTIN_DIVSS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_maskcmpv4sf3
block|,
literal|"__builtin_ia32_cmpeqps"
block|,
name|IX86_BUILTIN_CMPEQPS
block|,
name|EQ
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_maskcmpv4sf3
block|,
literal|"__builtin_ia32_cmpltps"
block|,
name|IX86_BUILTIN_CMPLTPS
block|,
name|LT
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_maskcmpv4sf3
block|,
literal|"__builtin_ia32_cmpleps"
block|,
name|IX86_BUILTIN_CMPLEPS
block|,
name|LE
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_maskcmpv4sf3
block|,
literal|"__builtin_ia32_cmpgtps"
block|,
name|IX86_BUILTIN_CMPGTPS
block|,
name|LT
block|,
literal|1
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_maskcmpv4sf3
block|,
literal|"__builtin_ia32_cmpgeps"
block|,
name|IX86_BUILTIN_CMPGEPS
block|,
name|LE
block|,
literal|1
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_maskcmpv4sf3
block|,
literal|"__builtin_ia32_cmpunordps"
block|,
name|IX86_BUILTIN_CMPUNORDPS
block|,
name|UNORDERED
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_maskncmpv4sf3
block|,
literal|"__builtin_ia32_cmpneqps"
block|,
name|IX86_BUILTIN_CMPNEQPS
block|,
name|EQ
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_maskncmpv4sf3
block|,
literal|"__builtin_ia32_cmpnltps"
block|,
name|IX86_BUILTIN_CMPNLTPS
block|,
name|LT
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_maskncmpv4sf3
block|,
literal|"__builtin_ia32_cmpnleps"
block|,
name|IX86_BUILTIN_CMPNLEPS
block|,
name|LE
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_maskncmpv4sf3
block|,
literal|"__builtin_ia32_cmpngtps"
block|,
name|IX86_BUILTIN_CMPNGTPS
block|,
name|LT
block|,
literal|1
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_maskncmpv4sf3
block|,
literal|"__builtin_ia32_cmpngeps"
block|,
name|IX86_BUILTIN_CMPNGEPS
block|,
name|LE
block|,
literal|1
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_maskncmpv4sf3
block|,
literal|"__builtin_ia32_cmpordps"
block|,
name|IX86_BUILTIN_CMPORDPS
block|,
name|UNORDERED
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_vmmaskcmpv4sf3
block|,
literal|"__builtin_ia32_cmpeqss"
block|,
name|IX86_BUILTIN_CMPEQSS
block|,
name|EQ
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_vmmaskcmpv4sf3
block|,
literal|"__builtin_ia32_cmpltss"
block|,
name|IX86_BUILTIN_CMPLTSS
block|,
name|LT
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_vmmaskcmpv4sf3
block|,
literal|"__builtin_ia32_cmpless"
block|,
name|IX86_BUILTIN_CMPLESS
block|,
name|LE
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_vmmaskcmpv4sf3
block|,
literal|"__builtin_ia32_cmpunordss"
block|,
name|IX86_BUILTIN_CMPUNORDSS
block|,
name|UNORDERED
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_vmmaskncmpv4sf3
block|,
literal|"__builtin_ia32_cmpneqss"
block|,
name|IX86_BUILTIN_CMPNEQSS
block|,
name|EQ
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_vmmaskncmpv4sf3
block|,
literal|"__builtin_ia32_cmpnltss"
block|,
name|IX86_BUILTIN_CMPNLTSS
block|,
name|LT
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_vmmaskncmpv4sf3
block|,
literal|"__builtin_ia32_cmpnless"
block|,
name|IX86_BUILTIN_CMPNLESS
block|,
name|LE
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_vmmaskncmpv4sf3
block|,
literal|"__builtin_ia32_cmpordss"
block|,
name|IX86_BUILTIN_CMPORDSS
block|,
name|UNORDERED
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sminv4sf3
block|,
literal|"__builtin_ia32_minps"
block|,
name|IX86_BUILTIN_MINPS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_smaxv4sf3
block|,
literal|"__builtin_ia32_maxps"
block|,
name|IX86_BUILTIN_MAXPS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_vmsminv4sf3
block|,
literal|"__builtin_ia32_minss"
block|,
name|IX86_BUILTIN_MINSS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_vmsmaxv4sf3
block|,
literal|"__builtin_ia32_maxss"
block|,
name|IX86_BUILTIN_MAXSS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_andv4sf3
block|,
literal|"__builtin_ia32_andps"
block|,
name|IX86_BUILTIN_ANDPS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_nandv4sf3
block|,
literal|"__builtin_ia32_andnps"
block|,
name|IX86_BUILTIN_ANDNPS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_iorv4sf3
block|,
literal|"__builtin_ia32_orps"
block|,
name|IX86_BUILTIN_ORPS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_xorv4sf3
block|,
literal|"__builtin_ia32_xorps"
block|,
name|IX86_BUILTIN_XORPS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_movss
block|,
literal|"__builtin_ia32_movss"
block|,
name|IX86_BUILTIN_MOVSS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_movhlps
block|,
literal|"__builtin_ia32_movhlps"
block|,
name|IX86_BUILTIN_MOVHLPS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_movlhps
block|,
literal|"__builtin_ia32_movlhps"
block|,
name|IX86_BUILTIN_MOVLHPS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_unpckhps
block|,
literal|"__builtin_ia32_unpckhps"
block|,
name|IX86_BUILTIN_UNPCKHPS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_unpcklps
block|,
literal|"__builtin_ia32_unpcklps"
block|,
name|IX86_BUILTIN_UNPCKLPS
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* MMX */
block|{
name|MASK_MMX
block|,
name|CODE_FOR_addv8qi3
block|,
literal|"__builtin_ia32_paddb"
block|,
name|IX86_BUILTIN_PADDB
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_addv4hi3
block|,
literal|"__builtin_ia32_paddw"
block|,
name|IX86_BUILTIN_PADDW
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_addv2si3
block|,
literal|"__builtin_ia32_paddd"
block|,
name|IX86_BUILTIN_PADDD
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_adddi3
block|,
literal|"__builtin_ia32_paddq"
block|,
name|IX86_BUILTIN_PADDQ
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_subv8qi3
block|,
literal|"__builtin_ia32_psubb"
block|,
name|IX86_BUILTIN_PSUBB
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_subv4hi3
block|,
literal|"__builtin_ia32_psubw"
block|,
name|IX86_BUILTIN_PSUBW
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_subv2si3
block|,
literal|"__builtin_ia32_psubd"
block|,
name|IX86_BUILTIN_PSUBD
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_subdi3
block|,
literal|"__builtin_ia32_psubq"
block|,
name|IX86_BUILTIN_PSUBQ
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_ssaddv8qi3
block|,
literal|"__builtin_ia32_paddsb"
block|,
name|IX86_BUILTIN_PADDSB
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_ssaddv4hi3
block|,
literal|"__builtin_ia32_paddsw"
block|,
name|IX86_BUILTIN_PADDSW
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_sssubv8qi3
block|,
literal|"__builtin_ia32_psubsb"
block|,
name|IX86_BUILTIN_PSUBSB
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_sssubv4hi3
block|,
literal|"__builtin_ia32_psubsw"
block|,
name|IX86_BUILTIN_PSUBSW
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_usaddv8qi3
block|,
literal|"__builtin_ia32_paddusb"
block|,
name|IX86_BUILTIN_PADDUSB
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_usaddv4hi3
block|,
literal|"__builtin_ia32_paddusw"
block|,
name|IX86_BUILTIN_PADDUSW
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_ussubv8qi3
block|,
literal|"__builtin_ia32_psubusb"
block|,
name|IX86_BUILTIN_PSUBUSB
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_ussubv4hi3
block|,
literal|"__builtin_ia32_psubusw"
block|,
name|IX86_BUILTIN_PSUBUSW
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mulv4hi3
block|,
literal|"__builtin_ia32_pmullw"
block|,
name|IX86_BUILTIN_PMULLW
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_smulv4hi3_highpart
block|,
literal|"__builtin_ia32_pmulhw"
block|,
name|IX86_BUILTIN_PMULHW
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
operator||
name|MASK_3DNOW_A
block|,
name|CODE_FOR_umulv4hi3_highpart
block|,
literal|"__builtin_ia32_pmulhuw"
block|,
name|IX86_BUILTIN_PMULHUW
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_anddi3
block|,
literal|"__builtin_ia32_pand"
block|,
name|IX86_BUILTIN_PAND
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_nanddi3
block|,
literal|"__builtin_ia32_pandn"
block|,
name|IX86_BUILTIN_PANDN
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_iordi3
block|,
literal|"__builtin_ia32_por"
block|,
name|IX86_BUILTIN_POR
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_xordi3
block|,
literal|"__builtin_ia32_pxor"
block|,
name|IX86_BUILTIN_PXOR
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
operator||
name|MASK_3DNOW_A
block|,
name|CODE_FOR_mmx_uavgv8qi3
block|,
literal|"__builtin_ia32_pavgb"
block|,
name|IX86_BUILTIN_PAVGB
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
operator||
name|MASK_3DNOW_A
block|,
name|CODE_FOR_mmx_uavgv4hi3
block|,
literal|"__builtin_ia32_pavgw"
block|,
name|IX86_BUILTIN_PAVGW
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_eqv8qi3
block|,
literal|"__builtin_ia32_pcmpeqb"
block|,
name|IX86_BUILTIN_PCMPEQB
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_eqv4hi3
block|,
literal|"__builtin_ia32_pcmpeqw"
block|,
name|IX86_BUILTIN_PCMPEQW
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_eqv2si3
block|,
literal|"__builtin_ia32_pcmpeqd"
block|,
name|IX86_BUILTIN_PCMPEQD
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_gtv8qi3
block|,
literal|"__builtin_ia32_pcmpgtb"
block|,
name|IX86_BUILTIN_PCMPGTB
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_gtv4hi3
block|,
literal|"__builtin_ia32_pcmpgtw"
block|,
name|IX86_BUILTIN_PCMPGTW
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_gtv2si3
block|,
literal|"__builtin_ia32_pcmpgtd"
block|,
name|IX86_BUILTIN_PCMPGTD
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
operator||
name|MASK_3DNOW_A
block|,
name|CODE_FOR_umaxv8qi3
block|,
literal|"__builtin_ia32_pmaxub"
block|,
name|IX86_BUILTIN_PMAXUB
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
operator||
name|MASK_3DNOW_A
block|,
name|CODE_FOR_smaxv4hi3
block|,
literal|"__builtin_ia32_pmaxsw"
block|,
name|IX86_BUILTIN_PMAXSW
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
operator||
name|MASK_3DNOW_A
block|,
name|CODE_FOR_uminv8qi3
block|,
literal|"__builtin_ia32_pminub"
block|,
name|IX86_BUILTIN_PMINUB
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
operator||
name|MASK_3DNOW_A
block|,
name|CODE_FOR_sminv4hi3
block|,
literal|"__builtin_ia32_pminsw"
block|,
name|IX86_BUILTIN_PMINSW
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_punpckhbw
block|,
literal|"__builtin_ia32_punpckhbw"
block|,
name|IX86_BUILTIN_PUNPCKHBW
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_punpckhwd
block|,
literal|"__builtin_ia32_punpckhwd"
block|,
name|IX86_BUILTIN_PUNPCKHWD
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_punpckhdq
block|,
literal|"__builtin_ia32_punpckhdq"
block|,
name|IX86_BUILTIN_PUNPCKHDQ
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_punpcklbw
block|,
literal|"__builtin_ia32_punpcklbw"
block|,
name|IX86_BUILTIN_PUNPCKLBW
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_punpcklwd
block|,
literal|"__builtin_ia32_punpcklwd"
block|,
name|IX86_BUILTIN_PUNPCKLWD
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_punpckldq
block|,
literal|"__builtin_ia32_punpckldq"
block|,
name|IX86_BUILTIN_PUNPCKLDQ
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Special.  */
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_packsswb
block|,
literal|0
block|,
name|IX86_BUILTIN_PACKSSWB
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_packssdw
block|,
literal|0
block|,
name|IX86_BUILTIN_PACKSSDW
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_packuswb
block|,
literal|0
block|,
name|IX86_BUILTIN_PACKUSWB
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_cvtpi2ps
block|,
literal|0
block|,
name|IX86_BUILTIN_CVTPI2PS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_cvtsi2ss
block|,
literal|0
block|,
name|IX86_BUILTIN_CVTSI2SS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
operator||
name|MASK_64BIT
block|,
name|CODE_FOR_cvtsi2ssq
block|,
literal|0
block|,
name|IX86_BUILTIN_CVTSI642SS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_ashlv4hi3
block|,
literal|0
block|,
name|IX86_BUILTIN_PSLLW
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_ashlv4hi3
block|,
literal|0
block|,
name|IX86_BUILTIN_PSLLWI
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_ashlv2si3
block|,
literal|0
block|,
name|IX86_BUILTIN_PSLLD
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_ashlv2si3
block|,
literal|0
block|,
name|IX86_BUILTIN_PSLLDI
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_ashldi3
block|,
literal|0
block|,
name|IX86_BUILTIN_PSLLQ
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_ashldi3
block|,
literal|0
block|,
name|IX86_BUILTIN_PSLLQI
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_lshrv4hi3
block|,
literal|0
block|,
name|IX86_BUILTIN_PSRLW
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_lshrv4hi3
block|,
literal|0
block|,
name|IX86_BUILTIN_PSRLWI
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_lshrv2si3
block|,
literal|0
block|,
name|IX86_BUILTIN_PSRLD
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_lshrv2si3
block|,
literal|0
block|,
name|IX86_BUILTIN_PSRLDI
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_lshrdi3
block|,
literal|0
block|,
name|IX86_BUILTIN_PSRLQ
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_lshrdi3
block|,
literal|0
block|,
name|IX86_BUILTIN_PSRLQI
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_ashrv4hi3
block|,
literal|0
block|,
name|IX86_BUILTIN_PSRAW
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_ashrv4hi3
block|,
literal|0
block|,
name|IX86_BUILTIN_PSRAWI
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_ashrv2si3
block|,
literal|0
block|,
name|IX86_BUILTIN_PSRAD
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_ashrv2si3
block|,
literal|0
block|,
name|IX86_BUILTIN_PSRADI
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
operator||
name|MASK_3DNOW_A
block|,
name|CODE_FOR_mmx_psadbw
block|,
literal|0
block|,
name|IX86_BUILTIN_PSADBW
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_mmx_pmaddwd
block|,
literal|0
block|,
name|IX86_BUILTIN_PMADDWD
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* SSE2 */
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_addv2df3
block|,
literal|"__builtin_ia32_addpd"
block|,
name|IX86_BUILTIN_ADDPD
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_subv2df3
block|,
literal|"__builtin_ia32_subpd"
block|,
name|IX86_BUILTIN_SUBPD
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_mulv2df3
block|,
literal|"__builtin_ia32_mulpd"
block|,
name|IX86_BUILTIN_MULPD
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_divv2df3
block|,
literal|"__builtin_ia32_divpd"
block|,
name|IX86_BUILTIN_DIVPD
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_vmaddv2df3
block|,
literal|"__builtin_ia32_addsd"
block|,
name|IX86_BUILTIN_ADDSD
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_vmsubv2df3
block|,
literal|"__builtin_ia32_subsd"
block|,
name|IX86_BUILTIN_SUBSD
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_vmmulv2df3
block|,
literal|"__builtin_ia32_mulsd"
block|,
name|IX86_BUILTIN_MULSD
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_vmdivv2df3
block|,
literal|"__builtin_ia32_divsd"
block|,
name|IX86_BUILTIN_DIVSD
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_maskcmpv2df3
block|,
literal|"__builtin_ia32_cmpeqpd"
block|,
name|IX86_BUILTIN_CMPEQPD
block|,
name|EQ
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_maskcmpv2df3
block|,
literal|"__builtin_ia32_cmpltpd"
block|,
name|IX86_BUILTIN_CMPLTPD
block|,
name|LT
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_maskcmpv2df3
block|,
literal|"__builtin_ia32_cmplepd"
block|,
name|IX86_BUILTIN_CMPLEPD
block|,
name|LE
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_maskcmpv2df3
block|,
literal|"__builtin_ia32_cmpgtpd"
block|,
name|IX86_BUILTIN_CMPGTPD
block|,
name|LT
block|,
literal|1
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_maskcmpv2df3
block|,
literal|"__builtin_ia32_cmpgepd"
block|,
name|IX86_BUILTIN_CMPGEPD
block|,
name|LE
block|,
literal|1
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_maskcmpv2df3
block|,
literal|"__builtin_ia32_cmpunordpd"
block|,
name|IX86_BUILTIN_CMPUNORDPD
block|,
name|UNORDERED
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_maskncmpv2df3
block|,
literal|"__builtin_ia32_cmpneqpd"
block|,
name|IX86_BUILTIN_CMPNEQPD
block|,
name|EQ
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_maskncmpv2df3
block|,
literal|"__builtin_ia32_cmpnltpd"
block|,
name|IX86_BUILTIN_CMPNLTPD
block|,
name|LT
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_maskncmpv2df3
block|,
literal|"__builtin_ia32_cmpnlepd"
block|,
name|IX86_BUILTIN_CMPNLEPD
block|,
name|LE
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_maskncmpv2df3
block|,
literal|"__builtin_ia32_cmpngtpd"
block|,
name|IX86_BUILTIN_CMPNGTPD
block|,
name|LT
block|,
literal|1
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_maskncmpv2df3
block|,
literal|"__builtin_ia32_cmpngepd"
block|,
name|IX86_BUILTIN_CMPNGEPD
block|,
name|LE
block|,
literal|1
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_maskncmpv2df3
block|,
literal|"__builtin_ia32_cmpordpd"
block|,
name|IX86_BUILTIN_CMPORDPD
block|,
name|UNORDERED
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_vmmaskcmpv2df3
block|,
literal|"__builtin_ia32_cmpeqsd"
block|,
name|IX86_BUILTIN_CMPEQSD
block|,
name|EQ
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_vmmaskcmpv2df3
block|,
literal|"__builtin_ia32_cmpltsd"
block|,
name|IX86_BUILTIN_CMPLTSD
block|,
name|LT
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_vmmaskcmpv2df3
block|,
literal|"__builtin_ia32_cmplesd"
block|,
name|IX86_BUILTIN_CMPLESD
block|,
name|LE
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_vmmaskcmpv2df3
block|,
literal|"__builtin_ia32_cmpunordsd"
block|,
name|IX86_BUILTIN_CMPUNORDSD
block|,
name|UNORDERED
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_vmmaskncmpv2df3
block|,
literal|"__builtin_ia32_cmpneqsd"
block|,
name|IX86_BUILTIN_CMPNEQSD
block|,
name|EQ
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_vmmaskncmpv2df3
block|,
literal|"__builtin_ia32_cmpnltsd"
block|,
name|IX86_BUILTIN_CMPNLTSD
block|,
name|LT
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_vmmaskncmpv2df3
block|,
literal|"__builtin_ia32_cmpnlesd"
block|,
name|IX86_BUILTIN_CMPNLESD
block|,
name|LE
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_vmmaskncmpv2df3
block|,
literal|"__builtin_ia32_cmpordsd"
block|,
name|IX86_BUILTIN_CMPORDSD
block|,
name|UNORDERED
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sminv2df3
block|,
literal|"__builtin_ia32_minpd"
block|,
name|IX86_BUILTIN_MINPD
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_smaxv2df3
block|,
literal|"__builtin_ia32_maxpd"
block|,
name|IX86_BUILTIN_MAXPD
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_vmsminv2df3
block|,
literal|"__builtin_ia32_minsd"
block|,
name|IX86_BUILTIN_MINSD
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_vmsmaxv2df3
block|,
literal|"__builtin_ia32_maxsd"
block|,
name|IX86_BUILTIN_MAXSD
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_andv2df3
block|,
literal|"__builtin_ia32_andpd"
block|,
name|IX86_BUILTIN_ANDPD
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_nandv2df3
block|,
literal|"__builtin_ia32_andnpd"
block|,
name|IX86_BUILTIN_ANDNPD
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_iorv2df3
block|,
literal|"__builtin_ia32_orpd"
block|,
name|IX86_BUILTIN_ORPD
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_xorv2df3
block|,
literal|"__builtin_ia32_xorpd"
block|,
name|IX86_BUILTIN_XORPD
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_movsd
block|,
literal|"__builtin_ia32_movsd"
block|,
name|IX86_BUILTIN_MOVSD
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_unpckhpd
block|,
literal|"__builtin_ia32_unpckhpd"
block|,
name|IX86_BUILTIN_UNPCKHPD
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_unpcklpd
block|,
literal|"__builtin_ia32_unpcklpd"
block|,
name|IX86_BUILTIN_UNPCKLPD
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* SSE2 MMX */
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_addv16qi3
block|,
literal|"__builtin_ia32_paddb128"
block|,
name|IX86_BUILTIN_PADDB128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_addv8hi3
block|,
literal|"__builtin_ia32_paddw128"
block|,
name|IX86_BUILTIN_PADDW128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_addv4si3
block|,
literal|"__builtin_ia32_paddd128"
block|,
name|IX86_BUILTIN_PADDD128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_addv2di3
block|,
literal|"__builtin_ia32_paddq128"
block|,
name|IX86_BUILTIN_PADDQ128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_subv16qi3
block|,
literal|"__builtin_ia32_psubb128"
block|,
name|IX86_BUILTIN_PSUBB128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_subv8hi3
block|,
literal|"__builtin_ia32_psubw128"
block|,
name|IX86_BUILTIN_PSUBW128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_subv4si3
block|,
literal|"__builtin_ia32_psubd128"
block|,
name|IX86_BUILTIN_PSUBD128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_subv2di3
block|,
literal|"__builtin_ia32_psubq128"
block|,
name|IX86_BUILTIN_PSUBQ128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_ssaddv16qi3
block|,
literal|"__builtin_ia32_paddsb128"
block|,
name|IX86_BUILTIN_PADDSB128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_ssaddv8hi3
block|,
literal|"__builtin_ia32_paddsw128"
block|,
name|IX86_BUILTIN_PADDSW128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_sssubv16qi3
block|,
literal|"__builtin_ia32_psubsb128"
block|,
name|IX86_BUILTIN_PSUBSB128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_sssubv8hi3
block|,
literal|"__builtin_ia32_psubsw128"
block|,
name|IX86_BUILTIN_PSUBSW128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_usaddv16qi3
block|,
literal|"__builtin_ia32_paddusb128"
block|,
name|IX86_BUILTIN_PADDUSB128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_usaddv8hi3
block|,
literal|"__builtin_ia32_paddusw128"
block|,
name|IX86_BUILTIN_PADDUSW128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_ussubv16qi3
block|,
literal|"__builtin_ia32_psubusb128"
block|,
name|IX86_BUILTIN_PSUBUSB128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_MMX
block|,
name|CODE_FOR_ussubv8hi3
block|,
literal|"__builtin_ia32_psubusw128"
block|,
name|IX86_BUILTIN_PSUBUSW128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_mulv8hi3
block|,
literal|"__builtin_ia32_pmullw128"
block|,
name|IX86_BUILTIN_PMULLW128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_smulv8hi3_highpart
block|,
literal|"__builtin_ia32_pmulhw128"
block|,
name|IX86_BUILTIN_PMULHW128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_umulsidi3
block|,
literal|"__builtin_ia32_pmuludq"
block|,
name|IX86_BUILTIN_PMULUDQ
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_umulv2siv2di3
block|,
literal|"__builtin_ia32_pmuludq128"
block|,
name|IX86_BUILTIN_PMULUDQ128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_andv2di3
block|,
literal|"__builtin_ia32_pand128"
block|,
name|IX86_BUILTIN_PAND128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_nandv2di3
block|,
literal|"__builtin_ia32_pandn128"
block|,
name|IX86_BUILTIN_PANDN128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_iorv2di3
block|,
literal|"__builtin_ia32_por128"
block|,
name|IX86_BUILTIN_POR128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_xorv2di3
block|,
literal|"__builtin_ia32_pxor128"
block|,
name|IX86_BUILTIN_PXOR128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_uavgv16qi3
block|,
literal|"__builtin_ia32_pavgb128"
block|,
name|IX86_BUILTIN_PAVGB128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_uavgv8hi3
block|,
literal|"__builtin_ia32_pavgw128"
block|,
name|IX86_BUILTIN_PAVGW128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_eqv16qi3
block|,
literal|"__builtin_ia32_pcmpeqb128"
block|,
name|IX86_BUILTIN_PCMPEQB128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_eqv8hi3
block|,
literal|"__builtin_ia32_pcmpeqw128"
block|,
name|IX86_BUILTIN_PCMPEQW128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_eqv4si3
block|,
literal|"__builtin_ia32_pcmpeqd128"
block|,
name|IX86_BUILTIN_PCMPEQD128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_gtv16qi3
block|,
literal|"__builtin_ia32_pcmpgtb128"
block|,
name|IX86_BUILTIN_PCMPGTB128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_gtv8hi3
block|,
literal|"__builtin_ia32_pcmpgtw128"
block|,
name|IX86_BUILTIN_PCMPGTW128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_gtv4si3
block|,
literal|"__builtin_ia32_pcmpgtd128"
block|,
name|IX86_BUILTIN_PCMPGTD128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_umaxv16qi3
block|,
literal|"__builtin_ia32_pmaxub128"
block|,
name|IX86_BUILTIN_PMAXUB128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_smaxv8hi3
block|,
literal|"__builtin_ia32_pmaxsw128"
block|,
name|IX86_BUILTIN_PMAXSW128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_uminv16qi3
block|,
literal|"__builtin_ia32_pminub128"
block|,
name|IX86_BUILTIN_PMINUB128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sminv8hi3
block|,
literal|"__builtin_ia32_pminsw128"
block|,
name|IX86_BUILTIN_PMINSW128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_punpckhbw
block|,
literal|"__builtin_ia32_punpckhbw128"
block|,
name|IX86_BUILTIN_PUNPCKHBW128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_punpckhwd
block|,
literal|"__builtin_ia32_punpckhwd128"
block|,
name|IX86_BUILTIN_PUNPCKHWD128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_punpckhdq
block|,
literal|"__builtin_ia32_punpckhdq128"
block|,
name|IX86_BUILTIN_PUNPCKHDQ128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_punpckhqdq
block|,
literal|"__builtin_ia32_punpckhqdq128"
block|,
name|IX86_BUILTIN_PUNPCKHQDQ128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_punpcklbw
block|,
literal|"__builtin_ia32_punpcklbw128"
block|,
name|IX86_BUILTIN_PUNPCKLBW128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_punpcklwd
block|,
literal|"__builtin_ia32_punpcklwd128"
block|,
name|IX86_BUILTIN_PUNPCKLWD128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_punpckldq
block|,
literal|"__builtin_ia32_punpckldq128"
block|,
name|IX86_BUILTIN_PUNPCKLDQ128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_punpcklqdq
block|,
literal|"__builtin_ia32_punpcklqdq128"
block|,
name|IX86_BUILTIN_PUNPCKLQDQ128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_packsswb
block|,
literal|"__builtin_ia32_packsswb128"
block|,
name|IX86_BUILTIN_PACKSSWB128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_packssdw
block|,
literal|"__builtin_ia32_packssdw128"
block|,
name|IX86_BUILTIN_PACKSSDW128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_packuswb
block|,
literal|"__builtin_ia32_packuswb128"
block|,
name|IX86_BUILTIN_PACKUSWB128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_umulv8hi3_highpart
block|,
literal|"__builtin_ia32_pmulhuw128"
block|,
name|IX86_BUILTIN_PMULHUW128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_psadbw
block|,
literal|0
block|,
name|IX86_BUILTIN_PSADBW128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_ashlv8hi3_ti
block|,
literal|0
block|,
name|IX86_BUILTIN_PSLLW128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_ashlv8hi3
block|,
literal|0
block|,
name|IX86_BUILTIN_PSLLWI128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_ashlv4si3_ti
block|,
literal|0
block|,
name|IX86_BUILTIN_PSLLD128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_ashlv4si3
block|,
literal|0
block|,
name|IX86_BUILTIN_PSLLDI128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_ashlv2di3_ti
block|,
literal|0
block|,
name|IX86_BUILTIN_PSLLQ128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_ashlv2di3
block|,
literal|0
block|,
name|IX86_BUILTIN_PSLLQI128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_lshrv8hi3_ti
block|,
literal|0
block|,
name|IX86_BUILTIN_PSRLW128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_lshrv8hi3
block|,
literal|0
block|,
name|IX86_BUILTIN_PSRLWI128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_lshrv4si3_ti
block|,
literal|0
block|,
name|IX86_BUILTIN_PSRLD128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_lshrv4si3
block|,
literal|0
block|,
name|IX86_BUILTIN_PSRLDI128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_lshrv2di3_ti
block|,
literal|0
block|,
name|IX86_BUILTIN_PSRLQ128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_lshrv2di3
block|,
literal|0
block|,
name|IX86_BUILTIN_PSRLQI128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_ashrv8hi3_ti
block|,
literal|0
block|,
name|IX86_BUILTIN_PSRAW128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_ashrv8hi3
block|,
literal|0
block|,
name|IX86_BUILTIN_PSRAWI128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_ashrv4si3_ti
block|,
literal|0
block|,
name|IX86_BUILTIN_PSRAD128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_ashrv4si3
block|,
literal|0
block|,
name|IX86_BUILTIN_PSRADI128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_pmaddwd
block|,
literal|0
block|,
name|IX86_BUILTIN_PMADDWD128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_cvtsi2sd
block|,
literal|0
block|,
name|IX86_BUILTIN_CVTSI2SD
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
operator||
name|MASK_64BIT
block|,
name|CODE_FOR_cvtsi2sdq
block|,
literal|0
block|,
name|IX86_BUILTIN_CVTSI642SD
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_cvtsd2ss
block|,
literal|0
block|,
name|IX86_BUILTIN_CVTSD2SS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_cvtss2sd
block|,
literal|0
block|,
name|IX86_BUILTIN_CVTSS2SD
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* SSE3 MMX */
block|{
name|MASK_SSE3
block|,
name|CODE_FOR_addsubv4sf3
block|,
literal|"__builtin_ia32_addsubps"
block|,
name|IX86_BUILTIN_ADDSUBPS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE3
block|,
name|CODE_FOR_addsubv2df3
block|,
literal|"__builtin_ia32_addsubpd"
block|,
name|IX86_BUILTIN_ADDSUBPD
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE3
block|,
name|CODE_FOR_haddv4sf3
block|,
literal|"__builtin_ia32_haddps"
block|,
name|IX86_BUILTIN_HADDPS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE3
block|,
name|CODE_FOR_haddv2df3
block|,
literal|"__builtin_ia32_haddpd"
block|,
name|IX86_BUILTIN_HADDPD
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE3
block|,
name|CODE_FOR_hsubv4sf3
block|,
literal|"__builtin_ia32_hsubps"
block|,
name|IX86_BUILTIN_HSUBPS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE3
block|,
name|CODE_FOR_hsubv2df3
block|,
literal|"__builtin_ia32_hsubpd"
block|,
name|IX86_BUILTIN_HSUBPD
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|builtin_description
name|bdesc_1arg
index|[]
init|=
block|{
block|{
name|MASK_SSE
operator||
name|MASK_3DNOW_A
block|,
name|CODE_FOR_mmx_pmovmskb
block|,
literal|0
block|,
name|IX86_BUILTIN_PMOVMSKB
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sse_movmskps
block|,
literal|0
block|,
name|IX86_BUILTIN_MOVMSKPS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_sqrtv4sf2
block|,
literal|0
block|,
name|IX86_BUILTIN_SQRTPS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_rsqrtv4sf2
block|,
literal|0
block|,
name|IX86_BUILTIN_RSQRTPS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_rcpv4sf2
block|,
literal|0
block|,
name|IX86_BUILTIN_RCPPS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_cvtps2pi
block|,
literal|0
block|,
name|IX86_BUILTIN_CVTPS2PI
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_cvtss2si
block|,
literal|0
block|,
name|IX86_BUILTIN_CVTSS2SI
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
operator||
name|MASK_64BIT
block|,
name|CODE_FOR_cvtss2siq
block|,
literal|0
block|,
name|IX86_BUILTIN_CVTSS2SI64
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_cvttps2pi
block|,
literal|0
block|,
name|IX86_BUILTIN_CVTTPS2PI
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
block|,
name|CODE_FOR_cvttss2si
block|,
literal|0
block|,
name|IX86_BUILTIN_CVTTSS2SI
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE
operator||
name|MASK_64BIT
block|,
name|CODE_FOR_cvttss2siq
block|,
literal|0
block|,
name|IX86_BUILTIN_CVTTSS2SI64
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_pmovmskb
block|,
literal|0
block|,
name|IX86_BUILTIN_PMOVMSKB128
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_movmskpd
block|,
literal|0
block|,
name|IX86_BUILTIN_MOVMSKPD
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_movq2dq
block|,
literal|0
block|,
name|IX86_BUILTIN_MOVQ2DQ
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_movdq2q
block|,
literal|0
block|,
name|IX86_BUILTIN_MOVDQ2Q
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sqrtv2df2
block|,
literal|0
block|,
name|IX86_BUILTIN_SQRTPD
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_cvtdq2pd
block|,
literal|0
block|,
name|IX86_BUILTIN_CVTDQ2PD
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_cvtdq2ps
block|,
literal|0
block|,
name|IX86_BUILTIN_CVTDQ2PS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_cvtpd2dq
block|,
literal|0
block|,
name|IX86_BUILTIN_CVTPD2DQ
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_cvtpd2pi
block|,
literal|0
block|,
name|IX86_BUILTIN_CVTPD2PI
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_cvtpd2ps
block|,
literal|0
block|,
name|IX86_BUILTIN_CVTPD2PS
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_cvttpd2dq
block|,
literal|0
block|,
name|IX86_BUILTIN_CVTTPD2DQ
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_cvttpd2pi
block|,
literal|0
block|,
name|IX86_BUILTIN_CVTTPD2PI
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_cvtpi2pd
block|,
literal|0
block|,
name|IX86_BUILTIN_CVTPI2PD
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_cvtsd2si
block|,
literal|0
block|,
name|IX86_BUILTIN_CVTSD2SI
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_cvttsd2si
block|,
literal|0
block|,
name|IX86_BUILTIN_CVTTSD2SI
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
operator||
name|MASK_64BIT
block|,
name|CODE_FOR_cvtsd2siq
block|,
literal|0
block|,
name|IX86_BUILTIN_CVTSD2SI64
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
operator||
name|MASK_64BIT
block|,
name|CODE_FOR_cvttsd2siq
block|,
literal|0
block|,
name|IX86_BUILTIN_CVTTSD2SI64
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_cvtps2dq
block|,
literal|0
block|,
name|IX86_BUILTIN_CVTPS2DQ
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_cvtps2pd
block|,
literal|0
block|,
name|IX86_BUILTIN_CVTPS2PD
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_cvttps2dq
block|,
literal|0
block|,
name|IX86_BUILTIN_CVTTPS2DQ
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE2
block|,
name|CODE_FOR_sse2_movq
block|,
literal|0
block|,
name|IX86_BUILTIN_MOVQ
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* SSE3 */
block|{
name|MASK_SSE3
block|,
name|CODE_FOR_movshdup
block|,
literal|0
block|,
name|IX86_BUILTIN_MOVSHDUP
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE3
block|,
name|CODE_FOR_movsldup
block|,
literal|0
block|,
name|IX86_BUILTIN_MOVSLDUP
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|MASK_SSE3
block|,
name|CODE_FOR_movddup
block|,
literal|0
block|,
name|IX86_BUILTIN_MOVDDUP
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|ix86_init_builtins
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|TARGET_MMX
condition|)
name|ix86_init_mmx_sse_builtins
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set up all the MMX/SSE builtins.  This is not called if TARGET_MMX    is zero.  Otherwise, if TARGET_SSE is not set, only expand the MMX    builtins.  */
end_comment

begin_function
specifier|static
name|void
name|ix86_init_mmx_sse_builtins
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|struct
name|builtin_description
modifier|*
name|d
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|tree
name|pchar_type_node
init|=
name|build_pointer_type
argument_list|(
name|char_type_node
argument_list|)
decl_stmt|;
name|tree
name|pcchar_type_node
init|=
name|build_pointer_type
argument_list|(
name|build_type_variant
argument_list|(
name|char_type_node
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|pfloat_type_node
init|=
name|build_pointer_type
argument_list|(
name|float_type_node
argument_list|)
decl_stmt|;
name|tree
name|pcfloat_type_node
init|=
name|build_pointer_type
argument_list|(
name|build_type_variant
argument_list|(
name|float_type_node
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|pv2si_type_node
init|=
name|build_pointer_type
argument_list|(
name|V2SI_type_node
argument_list|)
decl_stmt|;
name|tree
name|pv2di_type_node
init|=
name|build_pointer_type
argument_list|(
name|V2DI_type_node
argument_list|)
decl_stmt|;
name|tree
name|pdi_type_node
init|=
name|build_pointer_type
argument_list|(
name|long_long_unsigned_type_node
argument_list|)
decl_stmt|;
comment|/* Comparisons.  */
name|tree
name|int_ftype_v4sf_v4sf
init|=
name|build_function_type_list
argument_list|(
name|integer_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4si_ftype_v4sf_v4sf
init|=
name|build_function_type_list
argument_list|(
name|V4SI_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
comment|/* MMX/SSE/integer conversions.  */
name|tree
name|int_ftype_v4sf
init|=
name|build_function_type_list
argument_list|(
name|integer_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|int64_ftype_v4sf
init|=
name|build_function_type_list
argument_list|(
name|long_long_integer_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|int_ftype_v8qi
init|=
name|build_function_type_list
argument_list|(
name|integer_type_node
argument_list|,
name|V8QI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4sf_ftype_v4sf_int
init|=
name|build_function_type_list
argument_list|(
name|V4SF_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4sf_ftype_v4sf_int64
init|=
name|build_function_type_list
argument_list|(
name|V4SF_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|long_long_integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4sf_ftype_v4sf_v2si
init|=
name|build_function_type_list
argument_list|(
name|V4SF_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|V2SI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|int_ftype_v4hi_int
init|=
name|build_function_type_list
argument_list|(
name|integer_type_node
argument_list|,
name|V4HI_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4hi_ftype_v4hi_int_int
init|=
name|build_function_type_list
argument_list|(
name|V4HI_type_node
argument_list|,
name|V4HI_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
comment|/* Miscellaneous.  */
name|tree
name|v8qi_ftype_v4hi_v4hi
init|=
name|build_function_type_list
argument_list|(
name|V8QI_type_node
argument_list|,
name|V4HI_type_node
argument_list|,
name|V4HI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4hi_ftype_v2si_v2si
init|=
name|build_function_type_list
argument_list|(
name|V4HI_type_node
argument_list|,
name|V2SI_type_node
argument_list|,
name|V2SI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4sf_ftype_v4sf_v4sf_int
init|=
name|build_function_type_list
argument_list|(
name|V4SF_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v2si_ftype_v4hi_v4hi
init|=
name|build_function_type_list
argument_list|(
name|V2SI_type_node
argument_list|,
name|V4HI_type_node
argument_list|,
name|V4HI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4hi_ftype_v4hi_int
init|=
name|build_function_type_list
argument_list|(
name|V4HI_type_node
argument_list|,
name|V4HI_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4hi_ftype_v4hi_di
init|=
name|build_function_type_list
argument_list|(
name|V4HI_type_node
argument_list|,
name|V4HI_type_node
argument_list|,
name|long_long_unsigned_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v2si_ftype_v2si_di
init|=
name|build_function_type_list
argument_list|(
name|V2SI_type_node
argument_list|,
name|V2SI_type_node
argument_list|,
name|long_long_unsigned_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|void_ftype_void
init|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|void_list_node
argument_list|)
decl_stmt|;
name|tree
name|void_ftype_unsigned
init|=
name|build_function_type_list
argument_list|(
name|void_type_node
argument_list|,
name|unsigned_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|void_ftype_unsigned_unsigned
init|=
name|build_function_type_list
argument_list|(
name|void_type_node
argument_list|,
name|unsigned_type_node
argument_list|,
name|unsigned_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|void_ftype_pcvoid_unsigned_unsigned
init|=
name|build_function_type_list
argument_list|(
name|void_type_node
argument_list|,
name|const_ptr_type_node
argument_list|,
name|unsigned_type_node
argument_list|,
name|unsigned_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|unsigned_ftype_void
init|=
name|build_function_type
argument_list|(
name|unsigned_type_node
argument_list|,
name|void_list_node
argument_list|)
decl_stmt|;
name|tree
name|di_ftype_void
init|=
name|build_function_type
argument_list|(
name|long_long_unsigned_type_node
argument_list|,
name|void_list_node
argument_list|)
decl_stmt|;
name|tree
name|v4sf_ftype_void
init|=
name|build_function_type
argument_list|(
name|V4SF_type_node
argument_list|,
name|void_list_node
argument_list|)
decl_stmt|;
name|tree
name|v2si_ftype_v4sf
init|=
name|build_function_type_list
argument_list|(
name|V2SI_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
comment|/* Loads/stores.  */
name|tree
name|void_ftype_v8qi_v8qi_pchar
init|=
name|build_function_type_list
argument_list|(
name|void_type_node
argument_list|,
name|V8QI_type_node
argument_list|,
name|V8QI_type_node
argument_list|,
name|pchar_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4sf_ftype_pcfloat
init|=
name|build_function_type_list
argument_list|(
name|V4SF_type_node
argument_list|,
name|pcfloat_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
comment|/* @@@ the type is bogus */
name|tree
name|v4sf_ftype_v4sf_pv2si
init|=
name|build_function_type_list
argument_list|(
name|V4SF_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|pv2si_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|void_ftype_pv2si_v4sf
init|=
name|build_function_type_list
argument_list|(
name|void_type_node
argument_list|,
name|pv2si_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|void_ftype_pfloat_v4sf
init|=
name|build_function_type_list
argument_list|(
name|void_type_node
argument_list|,
name|pfloat_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|void_ftype_pdi_di
init|=
name|build_function_type_list
argument_list|(
name|void_type_node
argument_list|,
name|pdi_type_node
argument_list|,
name|long_long_unsigned_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|void_ftype_pv2di_v2di
init|=
name|build_function_type_list
argument_list|(
name|void_type_node
argument_list|,
name|pv2di_type_node
argument_list|,
name|V2DI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
comment|/* Normal vector unops.  */
name|tree
name|v4sf_ftype_v4sf
init|=
name|build_function_type_list
argument_list|(
name|V4SF_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
comment|/* Normal vector binops.  */
name|tree
name|v4sf_ftype_v4sf_v4sf
init|=
name|build_function_type_list
argument_list|(
name|V4SF_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v8qi_ftype_v8qi_v8qi
init|=
name|build_function_type_list
argument_list|(
name|V8QI_type_node
argument_list|,
name|V8QI_type_node
argument_list|,
name|V8QI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4hi_ftype_v4hi_v4hi
init|=
name|build_function_type_list
argument_list|(
name|V4HI_type_node
argument_list|,
name|V4HI_type_node
argument_list|,
name|V4HI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v2si_ftype_v2si_v2si
init|=
name|build_function_type_list
argument_list|(
name|V2SI_type_node
argument_list|,
name|V2SI_type_node
argument_list|,
name|V2SI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|di_ftype_di_di
init|=
name|build_function_type_list
argument_list|(
name|long_long_unsigned_type_node
argument_list|,
name|long_long_unsigned_type_node
argument_list|,
name|long_long_unsigned_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v2si_ftype_v2sf
init|=
name|build_function_type_list
argument_list|(
name|V2SI_type_node
argument_list|,
name|V2SF_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v2sf_ftype_v2si
init|=
name|build_function_type_list
argument_list|(
name|V2SF_type_node
argument_list|,
name|V2SI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v2si_ftype_v2si
init|=
name|build_function_type_list
argument_list|(
name|V2SI_type_node
argument_list|,
name|V2SI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v2sf_ftype_v2sf
init|=
name|build_function_type_list
argument_list|(
name|V2SF_type_node
argument_list|,
name|V2SF_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v2sf_ftype_v2sf_v2sf
init|=
name|build_function_type_list
argument_list|(
name|V2SF_type_node
argument_list|,
name|V2SF_type_node
argument_list|,
name|V2SF_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v2si_ftype_v2sf_v2sf
init|=
name|build_function_type_list
argument_list|(
name|V2SI_type_node
argument_list|,
name|V2SF_type_node
argument_list|,
name|V2SF_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|pint_type_node
init|=
name|build_pointer_type
argument_list|(
name|integer_type_node
argument_list|)
decl_stmt|;
name|tree
name|pcint_type_node
init|=
name|build_pointer_type
argument_list|(
name|build_type_variant
argument_list|(
name|integer_type_node
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|pdouble_type_node
init|=
name|build_pointer_type
argument_list|(
name|double_type_node
argument_list|)
decl_stmt|;
name|tree
name|pcdouble_type_node
init|=
name|build_pointer_type
argument_list|(
name|build_type_variant
argument_list|(
name|double_type_node
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|int_ftype_v2df_v2df
init|=
name|build_function_type_list
argument_list|(
name|integer_type_node
argument_list|,
name|V2DF_type_node
argument_list|,
name|V2DF_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|ti_ftype_void
init|=
name|build_function_type
argument_list|(
name|intTI_type_node
argument_list|,
name|void_list_node
argument_list|)
decl_stmt|;
name|tree
name|v2di_ftype_void
init|=
name|build_function_type
argument_list|(
name|V2DI_type_node
argument_list|,
name|void_list_node
argument_list|)
decl_stmt|;
name|tree
name|ti_ftype_ti_ti
init|=
name|build_function_type_list
argument_list|(
name|intTI_type_node
argument_list|,
name|intTI_type_node
argument_list|,
name|intTI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|void_ftype_pcvoid
init|=
name|build_function_type_list
argument_list|(
name|void_type_node
argument_list|,
name|const_ptr_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v2di_ftype_di
init|=
name|build_function_type_list
argument_list|(
name|V2DI_type_node
argument_list|,
name|long_long_unsigned_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|di_ftype_v2di
init|=
name|build_function_type_list
argument_list|(
name|long_long_unsigned_type_node
argument_list|,
name|V2DI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4sf_ftype_v4si
init|=
name|build_function_type_list
argument_list|(
name|V4SF_type_node
argument_list|,
name|V4SI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4si_ftype_v4sf
init|=
name|build_function_type_list
argument_list|(
name|V4SI_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v2df_ftype_v4si
init|=
name|build_function_type_list
argument_list|(
name|V2DF_type_node
argument_list|,
name|V4SI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4si_ftype_v2df
init|=
name|build_function_type_list
argument_list|(
name|V4SI_type_node
argument_list|,
name|V2DF_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v2si_ftype_v2df
init|=
name|build_function_type_list
argument_list|(
name|V2SI_type_node
argument_list|,
name|V2DF_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4sf_ftype_v2df
init|=
name|build_function_type_list
argument_list|(
name|V4SF_type_node
argument_list|,
name|V2DF_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v2df_ftype_v2si
init|=
name|build_function_type_list
argument_list|(
name|V2DF_type_node
argument_list|,
name|V2SI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v2df_ftype_v4sf
init|=
name|build_function_type_list
argument_list|(
name|V2DF_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|int_ftype_v2df
init|=
name|build_function_type_list
argument_list|(
name|integer_type_node
argument_list|,
name|V2DF_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|int64_ftype_v2df
init|=
name|build_function_type_list
argument_list|(
name|long_long_integer_type_node
argument_list|,
name|V2DF_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v2df_ftype_v2df_int
init|=
name|build_function_type_list
argument_list|(
name|V2DF_type_node
argument_list|,
name|V2DF_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v2df_ftype_v2df_int64
init|=
name|build_function_type_list
argument_list|(
name|V2DF_type_node
argument_list|,
name|V2DF_type_node
argument_list|,
name|long_long_integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4sf_ftype_v4sf_v2df
init|=
name|build_function_type_list
argument_list|(
name|V4SF_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|V2DF_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v2df_ftype_v2df_v4sf
init|=
name|build_function_type_list
argument_list|(
name|V2DF_type_node
argument_list|,
name|V2DF_type_node
argument_list|,
name|V4SF_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v2df_ftype_v2df_v2df_int
init|=
name|build_function_type_list
argument_list|(
name|V2DF_type_node
argument_list|,
name|V2DF_type_node
argument_list|,
name|V2DF_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v2df_ftype_v2df_pv2si
init|=
name|build_function_type_list
argument_list|(
name|V2DF_type_node
argument_list|,
name|V2DF_type_node
argument_list|,
name|pv2si_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|void_ftype_pv2si_v2df
init|=
name|build_function_type_list
argument_list|(
name|void_type_node
argument_list|,
name|pv2si_type_node
argument_list|,
name|V2DF_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|void_ftype_pdouble_v2df
init|=
name|build_function_type_list
argument_list|(
name|void_type_node
argument_list|,
name|pdouble_type_node
argument_list|,
name|V2DF_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|void_ftype_pint_int
init|=
name|build_function_type_list
argument_list|(
name|void_type_node
argument_list|,
name|pint_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|void_ftype_v16qi_v16qi_pchar
init|=
name|build_function_type_list
argument_list|(
name|void_type_node
argument_list|,
name|V16QI_type_node
argument_list|,
name|V16QI_type_node
argument_list|,
name|pchar_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v2df_ftype_pcdouble
init|=
name|build_function_type_list
argument_list|(
name|V2DF_type_node
argument_list|,
name|pcdouble_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v2df_ftype_v2df_v2df
init|=
name|build_function_type_list
argument_list|(
name|V2DF_type_node
argument_list|,
name|V2DF_type_node
argument_list|,
name|V2DF_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v16qi_ftype_v16qi_v16qi
init|=
name|build_function_type_list
argument_list|(
name|V16QI_type_node
argument_list|,
name|V16QI_type_node
argument_list|,
name|V16QI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v8hi_ftype_v8hi_v8hi
init|=
name|build_function_type_list
argument_list|(
name|V8HI_type_node
argument_list|,
name|V8HI_type_node
argument_list|,
name|V8HI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4si_ftype_v4si_v4si
init|=
name|build_function_type_list
argument_list|(
name|V4SI_type_node
argument_list|,
name|V4SI_type_node
argument_list|,
name|V4SI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v2di_ftype_v2di_v2di
init|=
name|build_function_type_list
argument_list|(
name|V2DI_type_node
argument_list|,
name|V2DI_type_node
argument_list|,
name|V2DI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v2di_ftype_v2df_v2df
init|=
name|build_function_type_list
argument_list|(
name|V2DI_type_node
argument_list|,
name|V2DF_type_node
argument_list|,
name|V2DF_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v2df_ftype_v2df
init|=
name|build_function_type_list
argument_list|(
name|V2DF_type_node
argument_list|,
name|V2DF_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v2df_ftype_double
init|=
name|build_function_type_list
argument_list|(
name|V2DF_type_node
argument_list|,
name|double_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v2df_ftype_double_double
init|=
name|build_function_type_list
argument_list|(
name|V2DF_type_node
argument_list|,
name|double_type_node
argument_list|,
name|double_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|int_ftype_v8hi_int
init|=
name|build_function_type_list
argument_list|(
name|integer_type_node
argument_list|,
name|V8HI_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v8hi_ftype_v8hi_int_int
init|=
name|build_function_type_list
argument_list|(
name|V8HI_type_node
argument_list|,
name|V8HI_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v2di_ftype_v2di_int
init|=
name|build_function_type_list
argument_list|(
name|V2DI_type_node
argument_list|,
name|V2DI_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4si_ftype_v4si_int
init|=
name|build_function_type_list
argument_list|(
name|V4SI_type_node
argument_list|,
name|V4SI_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v8hi_ftype_v8hi_int
init|=
name|build_function_type_list
argument_list|(
name|V8HI_type_node
argument_list|,
name|V8HI_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v8hi_ftype_v8hi_v2di
init|=
name|build_function_type_list
argument_list|(
name|V8HI_type_node
argument_list|,
name|V8HI_type_node
argument_list|,
name|V2DI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4si_ftype_v4si_v2di
init|=
name|build_function_type_list
argument_list|(
name|V4SI_type_node
argument_list|,
name|V4SI_type_node
argument_list|,
name|V2DI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4si_ftype_v8hi_v8hi
init|=
name|build_function_type_list
argument_list|(
name|V4SI_type_node
argument_list|,
name|V8HI_type_node
argument_list|,
name|V8HI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|di_ftype_v8qi_v8qi
init|=
name|build_function_type_list
argument_list|(
name|long_long_unsigned_type_node
argument_list|,
name|V8QI_type_node
argument_list|,
name|V8QI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v2di_ftype_v16qi_v16qi
init|=
name|build_function_type_list
argument_list|(
name|V2DI_type_node
argument_list|,
name|V16QI_type_node
argument_list|,
name|V16QI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|int_ftype_v16qi
init|=
name|build_function_type_list
argument_list|(
name|integer_type_node
argument_list|,
name|V16QI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v16qi_ftype_pcchar
init|=
name|build_function_type_list
argument_list|(
name|V16QI_type_node
argument_list|,
name|pcchar_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|void_ftype_pchar_v16qi
init|=
name|build_function_type_list
argument_list|(
name|void_type_node
argument_list|,
name|pchar_type_node
argument_list|,
name|V16QI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v4si_ftype_pcint
init|=
name|build_function_type_list
argument_list|(
name|V4SI_type_node
argument_list|,
name|pcint_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|void_ftype_pcint_v4si
init|=
name|build_function_type_list
argument_list|(
name|void_type_node
argument_list|,
name|pcint_type_node
argument_list|,
name|V4SI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|v2di_ftype_v2di
init|=
name|build_function_type_list
argument_list|(
name|V2DI_type_node
argument_list|,
name|V2DI_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|float80_type
decl_stmt|;
name|tree
name|float128_type
decl_stmt|;
comment|/* The __float80 type.  */
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|long_double_type_node
argument_list|)
operator|==
name|XFmode
condition|)
call|(
modifier|*
name|lang_hooks
operator|.
name|types
operator|.
name|register_builtin_type
call|)
argument_list|(
name|long_double_type_node
argument_list|,
literal|"__float80"
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* The __float80 type.  */
name|float80_type
operator|=
name|make_node
argument_list|(
name|REAL_TYPE
argument_list|)
expr_stmt|;
name|TYPE_PRECISION
argument_list|(
name|float80_type
argument_list|)
operator|=
literal|96
expr_stmt|;
name|layout_type
argument_list|(
name|float80_type
argument_list|)
expr_stmt|;
call|(
modifier|*
name|lang_hooks
operator|.
name|types
operator|.
name|register_builtin_type
call|)
argument_list|(
name|float80_type
argument_list|,
literal|"__float80"
argument_list|)
expr_stmt|;
block|}
name|float128_type
operator|=
name|make_node
argument_list|(
name|REAL_TYPE
argument_list|)
expr_stmt|;
name|TYPE_PRECISION
argument_list|(
name|float128_type
argument_list|)
operator|=
literal|128
expr_stmt|;
name|layout_type
argument_list|(
name|float128_type
argument_list|)
expr_stmt|;
call|(
modifier|*
name|lang_hooks
operator|.
name|types
operator|.
name|register_builtin_type
call|)
argument_list|(
name|float128_type
argument_list|,
literal|"__float128"
argument_list|)
expr_stmt|;
comment|/* Add all builtins that are more or less simple operations on two      operands.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|d
operator|=
name|bdesc_2arg
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|bdesc_2arg
argument_list|)
condition|;
name|i
operator|++
operator|,
name|d
operator|++
control|)
block|{
comment|/* Use one of the operands; the target can have a different mode for 	 mask-generating compares.  */
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|name
operator|==
literal|0
condition|)
continue|continue;
name|mode
operator|=
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|V16QImode
case|:
name|type
operator|=
name|v16qi_ftype_v16qi_v16qi
expr_stmt|;
break|break;
case|case
name|V8HImode
case|:
name|type
operator|=
name|v8hi_ftype_v8hi_v8hi
expr_stmt|;
break|break;
case|case
name|V4SImode
case|:
name|type
operator|=
name|v4si_ftype_v4si_v4si
expr_stmt|;
break|break;
case|case
name|V2DImode
case|:
name|type
operator|=
name|v2di_ftype_v2di_v2di
expr_stmt|;
break|break;
case|case
name|V2DFmode
case|:
name|type
operator|=
name|v2df_ftype_v2df_v2df
expr_stmt|;
break|break;
case|case
name|TImode
case|:
name|type
operator|=
name|ti_ftype_ti_ti
expr_stmt|;
break|break;
case|case
name|V4SFmode
case|:
name|type
operator|=
name|v4sf_ftype_v4sf_v4sf
expr_stmt|;
break|break;
case|case
name|V8QImode
case|:
name|type
operator|=
name|v8qi_ftype_v8qi_v8qi
expr_stmt|;
break|break;
case|case
name|V4HImode
case|:
name|type
operator|=
name|v4hi_ftype_v4hi_v4hi
expr_stmt|;
break|break;
case|case
name|V2SImode
case|:
name|type
operator|=
name|v2si_ftype_v2si_v2si
expr_stmt|;
break|break;
case|case
name|DImode
case|:
name|type
operator|=
name|di_ftype_di_di
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Override for comparisons.  */
if|if
condition|(
name|d
operator|->
name|icode
operator|==
name|CODE_FOR_maskcmpv4sf3
operator|||
name|d
operator|->
name|icode
operator|==
name|CODE_FOR_maskncmpv4sf3
operator|||
name|d
operator|->
name|icode
operator|==
name|CODE_FOR_vmmaskcmpv4sf3
operator|||
name|d
operator|->
name|icode
operator|==
name|CODE_FOR_vmmaskncmpv4sf3
condition|)
name|type
operator|=
name|v4si_ftype_v4sf_v4sf
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|icode
operator|==
name|CODE_FOR_maskcmpv2df3
operator|||
name|d
operator|->
name|icode
operator|==
name|CODE_FOR_maskncmpv2df3
operator|||
name|d
operator|->
name|icode
operator|==
name|CODE_FOR_vmmaskcmpv2df3
operator|||
name|d
operator|->
name|icode
operator|==
name|CODE_FOR_vmmaskncmpv2df3
condition|)
name|type
operator|=
name|v2di_ftype_v2df_v2df
expr_stmt|;
name|def_builtin
argument_list|(
name|d
operator|->
name|mask
argument_list|,
name|d
operator|->
name|name
argument_list|,
name|type
argument_list|,
name|d
operator|->
name|code
argument_list|)
expr_stmt|;
block|}
comment|/* Add the remaining MMX insns with somewhat more complicated types.  */
name|def_builtin
argument_list|(
name|MASK_MMX
argument_list|,
literal|"__builtin_ia32_mmx_zero"
argument_list|,
name|di_ftype_void
argument_list|,
name|IX86_BUILTIN_MMX_ZERO
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_MMX
argument_list|,
literal|"__builtin_ia32_emms"
argument_list|,
name|void_ftype_void
argument_list|,
name|IX86_BUILTIN_EMMS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_MMX
argument_list|,
literal|"__builtin_ia32_psllw"
argument_list|,
name|v4hi_ftype_v4hi_di
argument_list|,
name|IX86_BUILTIN_PSLLW
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_MMX
argument_list|,
literal|"__builtin_ia32_pslld"
argument_list|,
name|v2si_ftype_v2si_di
argument_list|,
name|IX86_BUILTIN_PSLLD
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_MMX
argument_list|,
literal|"__builtin_ia32_psllq"
argument_list|,
name|di_ftype_di_di
argument_list|,
name|IX86_BUILTIN_PSLLQ
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_MMX
argument_list|,
literal|"__builtin_ia32_psrlw"
argument_list|,
name|v4hi_ftype_v4hi_di
argument_list|,
name|IX86_BUILTIN_PSRLW
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_MMX
argument_list|,
literal|"__builtin_ia32_psrld"
argument_list|,
name|v2si_ftype_v2si_di
argument_list|,
name|IX86_BUILTIN_PSRLD
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_MMX
argument_list|,
literal|"__builtin_ia32_psrlq"
argument_list|,
name|di_ftype_di_di
argument_list|,
name|IX86_BUILTIN_PSRLQ
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_MMX
argument_list|,
literal|"__builtin_ia32_psraw"
argument_list|,
name|v4hi_ftype_v4hi_di
argument_list|,
name|IX86_BUILTIN_PSRAW
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_MMX
argument_list|,
literal|"__builtin_ia32_psrad"
argument_list|,
name|v2si_ftype_v2si_di
argument_list|,
name|IX86_BUILTIN_PSRAD
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_MMX
argument_list|,
literal|"__builtin_ia32_pshufw"
argument_list|,
name|v4hi_ftype_v4hi_int
argument_list|,
name|IX86_BUILTIN_PSHUFW
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_MMX
argument_list|,
literal|"__builtin_ia32_pmaddwd"
argument_list|,
name|v2si_ftype_v4hi_v4hi
argument_list|,
name|IX86_BUILTIN_PMADDWD
argument_list|)
expr_stmt|;
comment|/* comi/ucomi insns.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|d
operator|=
name|bdesc_comi
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|bdesc_comi
argument_list|)
condition|;
name|i
operator|++
operator|,
name|d
operator|++
control|)
if|if
condition|(
name|d
operator|->
name|mask
operator|==
name|MASK_SSE2
condition|)
name|def_builtin
argument_list|(
name|d
operator|->
name|mask
argument_list|,
name|d
operator|->
name|name
argument_list|,
name|int_ftype_v2df_v2df
argument_list|,
name|d
operator|->
name|code
argument_list|)
expr_stmt|;
else|else
name|def_builtin
argument_list|(
name|d
operator|->
name|mask
argument_list|,
name|d
operator|->
name|name
argument_list|,
name|int_ftype_v4sf_v4sf
argument_list|,
name|d
operator|->
name|code
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_MMX
argument_list|,
literal|"__builtin_ia32_packsswb"
argument_list|,
name|v8qi_ftype_v4hi_v4hi
argument_list|,
name|IX86_BUILTIN_PACKSSWB
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_MMX
argument_list|,
literal|"__builtin_ia32_packssdw"
argument_list|,
name|v4hi_ftype_v2si_v2si
argument_list|,
name|IX86_BUILTIN_PACKSSDW
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_MMX
argument_list|,
literal|"__builtin_ia32_packuswb"
argument_list|,
name|v8qi_ftype_v4hi_v4hi
argument_list|,
name|IX86_BUILTIN_PACKUSWB
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
argument_list|,
literal|"__builtin_ia32_ldmxcsr"
argument_list|,
name|void_ftype_unsigned
argument_list|,
name|IX86_BUILTIN_LDMXCSR
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
argument_list|,
literal|"__builtin_ia32_stmxcsr"
argument_list|,
name|unsigned_ftype_void
argument_list|,
name|IX86_BUILTIN_STMXCSR
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
argument_list|,
literal|"__builtin_ia32_cvtpi2ps"
argument_list|,
name|v4sf_ftype_v4sf_v2si
argument_list|,
name|IX86_BUILTIN_CVTPI2PS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
argument_list|,
literal|"__builtin_ia32_cvtps2pi"
argument_list|,
name|v2si_ftype_v4sf
argument_list|,
name|IX86_BUILTIN_CVTPS2PI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
argument_list|,
literal|"__builtin_ia32_cvtsi2ss"
argument_list|,
name|v4sf_ftype_v4sf_int
argument_list|,
name|IX86_BUILTIN_CVTSI2SS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
operator||
name|MASK_64BIT
argument_list|,
literal|"__builtin_ia32_cvtsi642ss"
argument_list|,
name|v4sf_ftype_v4sf_int64
argument_list|,
name|IX86_BUILTIN_CVTSI642SS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
argument_list|,
literal|"__builtin_ia32_cvtss2si"
argument_list|,
name|int_ftype_v4sf
argument_list|,
name|IX86_BUILTIN_CVTSS2SI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
operator||
name|MASK_64BIT
argument_list|,
literal|"__builtin_ia32_cvtss2si64"
argument_list|,
name|int64_ftype_v4sf
argument_list|,
name|IX86_BUILTIN_CVTSS2SI64
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
argument_list|,
literal|"__builtin_ia32_cvttps2pi"
argument_list|,
name|v2si_ftype_v4sf
argument_list|,
name|IX86_BUILTIN_CVTTPS2PI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
argument_list|,
literal|"__builtin_ia32_cvttss2si"
argument_list|,
name|int_ftype_v4sf
argument_list|,
name|IX86_BUILTIN_CVTTSS2SI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
operator||
name|MASK_64BIT
argument_list|,
literal|"__builtin_ia32_cvttss2si64"
argument_list|,
name|int64_ftype_v4sf
argument_list|,
name|IX86_BUILTIN_CVTTSS2SI64
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
operator||
name|MASK_3DNOW_A
argument_list|,
literal|"__builtin_ia32_pextrw"
argument_list|,
name|int_ftype_v4hi_int
argument_list|,
name|IX86_BUILTIN_PEXTRW
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
operator||
name|MASK_3DNOW_A
argument_list|,
literal|"__builtin_ia32_pinsrw"
argument_list|,
name|v4hi_ftype_v4hi_int_int
argument_list|,
name|IX86_BUILTIN_PINSRW
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
operator||
name|MASK_3DNOW_A
argument_list|,
literal|"__builtin_ia32_maskmovq"
argument_list|,
name|void_ftype_v8qi_v8qi_pchar
argument_list|,
name|IX86_BUILTIN_MASKMOVQ
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
argument_list|,
literal|"__builtin_ia32_loadaps"
argument_list|,
name|v4sf_ftype_pcfloat
argument_list|,
name|IX86_BUILTIN_LOADAPS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
argument_list|,
literal|"__builtin_ia32_loadups"
argument_list|,
name|v4sf_ftype_pcfloat
argument_list|,
name|IX86_BUILTIN_LOADUPS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
argument_list|,
literal|"__builtin_ia32_loadss"
argument_list|,
name|v4sf_ftype_pcfloat
argument_list|,
name|IX86_BUILTIN_LOADSS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
argument_list|,
literal|"__builtin_ia32_storeaps"
argument_list|,
name|void_ftype_pfloat_v4sf
argument_list|,
name|IX86_BUILTIN_STOREAPS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
argument_list|,
literal|"__builtin_ia32_storeups"
argument_list|,
name|void_ftype_pfloat_v4sf
argument_list|,
name|IX86_BUILTIN_STOREUPS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
argument_list|,
literal|"__builtin_ia32_storess"
argument_list|,
name|void_ftype_pfloat_v4sf
argument_list|,
name|IX86_BUILTIN_STORESS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
argument_list|,
literal|"__builtin_ia32_loadhps"
argument_list|,
name|v4sf_ftype_v4sf_pv2si
argument_list|,
name|IX86_BUILTIN_LOADHPS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
argument_list|,
literal|"__builtin_ia32_loadlps"
argument_list|,
name|v4sf_ftype_v4sf_pv2si
argument_list|,
name|IX86_BUILTIN_LOADLPS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
argument_list|,
literal|"__builtin_ia32_storehps"
argument_list|,
name|void_ftype_pv2si_v4sf
argument_list|,
name|IX86_BUILTIN_STOREHPS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
argument_list|,
literal|"__builtin_ia32_storelps"
argument_list|,
name|void_ftype_pv2si_v4sf
argument_list|,
name|IX86_BUILTIN_STORELPS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
argument_list|,
literal|"__builtin_ia32_movmskps"
argument_list|,
name|int_ftype_v4sf
argument_list|,
name|IX86_BUILTIN_MOVMSKPS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
operator||
name|MASK_3DNOW_A
argument_list|,
literal|"__builtin_ia32_pmovmskb"
argument_list|,
name|int_ftype_v8qi
argument_list|,
name|IX86_BUILTIN_PMOVMSKB
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
argument_list|,
literal|"__builtin_ia32_movntps"
argument_list|,
name|void_ftype_pfloat_v4sf
argument_list|,
name|IX86_BUILTIN_MOVNTPS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
operator||
name|MASK_3DNOW_A
argument_list|,
literal|"__builtin_ia32_movntq"
argument_list|,
name|void_ftype_pdi_di
argument_list|,
name|IX86_BUILTIN_MOVNTQ
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
operator||
name|MASK_3DNOW_A
argument_list|,
literal|"__builtin_ia32_sfence"
argument_list|,
name|void_ftype_void
argument_list|,
name|IX86_BUILTIN_SFENCE
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
operator||
name|MASK_3DNOW_A
argument_list|,
literal|"__builtin_ia32_psadbw"
argument_list|,
name|di_ftype_v8qi_v8qi
argument_list|,
name|IX86_BUILTIN_PSADBW
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
argument_list|,
literal|"__builtin_ia32_rcpps"
argument_list|,
name|v4sf_ftype_v4sf
argument_list|,
name|IX86_BUILTIN_RCPPS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
argument_list|,
literal|"__builtin_ia32_rcpss"
argument_list|,
name|v4sf_ftype_v4sf
argument_list|,
name|IX86_BUILTIN_RCPSS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
argument_list|,
literal|"__builtin_ia32_rsqrtps"
argument_list|,
name|v4sf_ftype_v4sf
argument_list|,
name|IX86_BUILTIN_RSQRTPS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
argument_list|,
literal|"__builtin_ia32_rsqrtss"
argument_list|,
name|v4sf_ftype_v4sf
argument_list|,
name|IX86_BUILTIN_RSQRTSS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
argument_list|,
literal|"__builtin_ia32_sqrtps"
argument_list|,
name|v4sf_ftype_v4sf
argument_list|,
name|IX86_BUILTIN_SQRTPS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
argument_list|,
literal|"__builtin_ia32_sqrtss"
argument_list|,
name|v4sf_ftype_v4sf
argument_list|,
name|IX86_BUILTIN_SQRTSS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
argument_list|,
literal|"__builtin_ia32_shufps"
argument_list|,
name|v4sf_ftype_v4sf_v4sf_int
argument_list|,
name|IX86_BUILTIN_SHUFPS
argument_list|)
expr_stmt|;
comment|/* Original 3DNow!  */
name|def_builtin
argument_list|(
name|MASK_3DNOW
argument_list|,
literal|"__builtin_ia32_femms"
argument_list|,
name|void_ftype_void
argument_list|,
name|IX86_BUILTIN_FEMMS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_3DNOW
argument_list|,
literal|"__builtin_ia32_pavgusb"
argument_list|,
name|v8qi_ftype_v8qi_v8qi
argument_list|,
name|IX86_BUILTIN_PAVGUSB
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_3DNOW
argument_list|,
literal|"__builtin_ia32_pf2id"
argument_list|,
name|v2si_ftype_v2sf
argument_list|,
name|IX86_BUILTIN_PF2ID
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_3DNOW
argument_list|,
literal|"__builtin_ia32_pfacc"
argument_list|,
name|v2sf_ftype_v2sf_v2sf
argument_list|,
name|IX86_BUILTIN_PFACC
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_3DNOW
argument_list|,
literal|"__builtin_ia32_pfadd"
argument_list|,
name|v2sf_ftype_v2sf_v2sf
argument_list|,
name|IX86_BUILTIN_PFADD
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_3DNOW
argument_list|,
literal|"__builtin_ia32_pfcmpeq"
argument_list|,
name|v2si_ftype_v2sf_v2sf
argument_list|,
name|IX86_BUILTIN_PFCMPEQ
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_3DNOW
argument_list|,
literal|"__builtin_ia32_pfcmpge"
argument_list|,
name|v2si_ftype_v2sf_v2sf
argument_list|,
name|IX86_BUILTIN_PFCMPGE
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_3DNOW
argument_list|,
literal|"__builtin_ia32_pfcmpgt"
argument_list|,
name|v2si_ftype_v2sf_v2sf
argument_list|,
name|IX86_BUILTIN_PFCMPGT
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_3DNOW
argument_list|,
literal|"__builtin_ia32_pfmax"
argument_list|,
name|v2sf_ftype_v2sf_v2sf
argument_list|,
name|IX86_BUILTIN_PFMAX
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_3DNOW
argument_list|,
literal|"__builtin_ia32_pfmin"
argument_list|,
name|v2sf_ftype_v2sf_v2sf
argument_list|,
name|IX86_BUILTIN_PFMIN
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_3DNOW
argument_list|,
literal|"__builtin_ia32_pfmul"
argument_list|,
name|v2sf_ftype_v2sf_v2sf
argument_list|,
name|IX86_BUILTIN_PFMUL
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_3DNOW
argument_list|,
literal|"__builtin_ia32_pfrcp"
argument_list|,
name|v2sf_ftype_v2sf
argument_list|,
name|IX86_BUILTIN_PFRCP
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_3DNOW
argument_list|,
literal|"__builtin_ia32_pfrcpit1"
argument_list|,
name|v2sf_ftype_v2sf_v2sf
argument_list|,
name|IX86_BUILTIN_PFRCPIT1
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_3DNOW
argument_list|,
literal|"__builtin_ia32_pfrcpit2"
argument_list|,
name|v2sf_ftype_v2sf_v2sf
argument_list|,
name|IX86_BUILTIN_PFRCPIT2
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_3DNOW
argument_list|,
literal|"__builtin_ia32_pfrsqrt"
argument_list|,
name|v2sf_ftype_v2sf
argument_list|,
name|IX86_BUILTIN_PFRSQRT
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_3DNOW
argument_list|,
literal|"__builtin_ia32_pfrsqit1"
argument_list|,
name|v2sf_ftype_v2sf_v2sf
argument_list|,
name|IX86_BUILTIN_PFRSQIT1
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_3DNOW
argument_list|,
literal|"__builtin_ia32_pfsub"
argument_list|,
name|v2sf_ftype_v2sf_v2sf
argument_list|,
name|IX86_BUILTIN_PFSUB
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_3DNOW
argument_list|,
literal|"__builtin_ia32_pfsubr"
argument_list|,
name|v2sf_ftype_v2sf_v2sf
argument_list|,
name|IX86_BUILTIN_PFSUBR
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_3DNOW
argument_list|,
literal|"__builtin_ia32_pi2fd"
argument_list|,
name|v2sf_ftype_v2si
argument_list|,
name|IX86_BUILTIN_PI2FD
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_3DNOW
argument_list|,
literal|"__builtin_ia32_pmulhrw"
argument_list|,
name|v4hi_ftype_v4hi_v4hi
argument_list|,
name|IX86_BUILTIN_PMULHRW
argument_list|)
expr_stmt|;
comment|/* 3DNow! extension as used in the Athlon CPU.  */
name|def_builtin
argument_list|(
name|MASK_3DNOW_A
argument_list|,
literal|"__builtin_ia32_pf2iw"
argument_list|,
name|v2si_ftype_v2sf
argument_list|,
name|IX86_BUILTIN_PF2IW
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_3DNOW_A
argument_list|,
literal|"__builtin_ia32_pfnacc"
argument_list|,
name|v2sf_ftype_v2sf_v2sf
argument_list|,
name|IX86_BUILTIN_PFNACC
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_3DNOW_A
argument_list|,
literal|"__builtin_ia32_pfpnacc"
argument_list|,
name|v2sf_ftype_v2sf_v2sf
argument_list|,
name|IX86_BUILTIN_PFPNACC
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_3DNOW_A
argument_list|,
literal|"__builtin_ia32_pi2fw"
argument_list|,
name|v2sf_ftype_v2si
argument_list|,
name|IX86_BUILTIN_PI2FW
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_3DNOW_A
argument_list|,
literal|"__builtin_ia32_pswapdsf"
argument_list|,
name|v2sf_ftype_v2sf
argument_list|,
name|IX86_BUILTIN_PSWAPDSF
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_3DNOW_A
argument_list|,
literal|"__builtin_ia32_pswapdsi"
argument_list|,
name|v2si_ftype_v2si
argument_list|,
name|IX86_BUILTIN_PSWAPDSI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
argument_list|,
literal|"__builtin_ia32_setzerops"
argument_list|,
name|v4sf_ftype_void
argument_list|,
name|IX86_BUILTIN_SSE_ZERO
argument_list|)
expr_stmt|;
comment|/* SSE2 */
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_pextrw128"
argument_list|,
name|int_ftype_v8hi_int
argument_list|,
name|IX86_BUILTIN_PEXTRW128
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_pinsrw128"
argument_list|,
name|v8hi_ftype_v8hi_int_int
argument_list|,
name|IX86_BUILTIN_PINSRW128
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_maskmovdqu"
argument_list|,
name|void_ftype_v16qi_v16qi_pchar
argument_list|,
name|IX86_BUILTIN_MASKMOVDQU
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_movq2dq"
argument_list|,
name|v2di_ftype_di
argument_list|,
name|IX86_BUILTIN_MOVQ2DQ
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_movdq2q"
argument_list|,
name|di_ftype_v2di
argument_list|,
name|IX86_BUILTIN_MOVDQ2Q
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_loadapd"
argument_list|,
name|v2df_ftype_pcdouble
argument_list|,
name|IX86_BUILTIN_LOADAPD
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_loadupd"
argument_list|,
name|v2df_ftype_pcdouble
argument_list|,
name|IX86_BUILTIN_LOADUPD
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_loadsd"
argument_list|,
name|v2df_ftype_pcdouble
argument_list|,
name|IX86_BUILTIN_LOADSD
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_storeapd"
argument_list|,
name|void_ftype_pdouble_v2df
argument_list|,
name|IX86_BUILTIN_STOREAPD
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_storeupd"
argument_list|,
name|void_ftype_pdouble_v2df
argument_list|,
name|IX86_BUILTIN_STOREUPD
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_storesd"
argument_list|,
name|void_ftype_pdouble_v2df
argument_list|,
name|IX86_BUILTIN_STORESD
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_loadhpd"
argument_list|,
name|v2df_ftype_v2df_pv2si
argument_list|,
name|IX86_BUILTIN_LOADHPD
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_loadlpd"
argument_list|,
name|v2df_ftype_v2df_pv2si
argument_list|,
name|IX86_BUILTIN_LOADLPD
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_storehpd"
argument_list|,
name|void_ftype_pv2si_v2df
argument_list|,
name|IX86_BUILTIN_STOREHPD
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_storelpd"
argument_list|,
name|void_ftype_pv2si_v2df
argument_list|,
name|IX86_BUILTIN_STORELPD
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_movmskpd"
argument_list|,
name|int_ftype_v2df
argument_list|,
name|IX86_BUILTIN_MOVMSKPD
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_pmovmskb128"
argument_list|,
name|int_ftype_v16qi
argument_list|,
name|IX86_BUILTIN_PMOVMSKB128
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_movnti"
argument_list|,
name|void_ftype_pint_int
argument_list|,
name|IX86_BUILTIN_MOVNTI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_movntpd"
argument_list|,
name|void_ftype_pdouble_v2df
argument_list|,
name|IX86_BUILTIN_MOVNTPD
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_movntdq"
argument_list|,
name|void_ftype_pv2di_v2di
argument_list|,
name|IX86_BUILTIN_MOVNTDQ
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_pshufd"
argument_list|,
name|v4si_ftype_v4si_int
argument_list|,
name|IX86_BUILTIN_PSHUFD
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_pshuflw"
argument_list|,
name|v8hi_ftype_v8hi_int
argument_list|,
name|IX86_BUILTIN_PSHUFLW
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_pshufhw"
argument_list|,
name|v8hi_ftype_v8hi_int
argument_list|,
name|IX86_BUILTIN_PSHUFHW
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_psadbw128"
argument_list|,
name|v2di_ftype_v16qi_v16qi
argument_list|,
name|IX86_BUILTIN_PSADBW128
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_sqrtpd"
argument_list|,
name|v2df_ftype_v2df
argument_list|,
name|IX86_BUILTIN_SQRTPD
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_sqrtsd"
argument_list|,
name|v2df_ftype_v2df
argument_list|,
name|IX86_BUILTIN_SQRTSD
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_shufpd"
argument_list|,
name|v2df_ftype_v2df_v2df_int
argument_list|,
name|IX86_BUILTIN_SHUFPD
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_cvtdq2pd"
argument_list|,
name|v2df_ftype_v4si
argument_list|,
name|IX86_BUILTIN_CVTDQ2PD
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_cvtdq2ps"
argument_list|,
name|v4sf_ftype_v4si
argument_list|,
name|IX86_BUILTIN_CVTDQ2PS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_cvtpd2dq"
argument_list|,
name|v4si_ftype_v2df
argument_list|,
name|IX86_BUILTIN_CVTPD2DQ
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_cvtpd2pi"
argument_list|,
name|v2si_ftype_v2df
argument_list|,
name|IX86_BUILTIN_CVTPD2PI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_cvtpd2ps"
argument_list|,
name|v4sf_ftype_v2df
argument_list|,
name|IX86_BUILTIN_CVTPD2PS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_cvttpd2dq"
argument_list|,
name|v4si_ftype_v2df
argument_list|,
name|IX86_BUILTIN_CVTTPD2DQ
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_cvttpd2pi"
argument_list|,
name|v2si_ftype_v2df
argument_list|,
name|IX86_BUILTIN_CVTTPD2PI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_cvtpi2pd"
argument_list|,
name|v2df_ftype_v2si
argument_list|,
name|IX86_BUILTIN_CVTPI2PD
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_cvtsd2si"
argument_list|,
name|int_ftype_v2df
argument_list|,
name|IX86_BUILTIN_CVTSD2SI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_cvttsd2si"
argument_list|,
name|int_ftype_v2df
argument_list|,
name|IX86_BUILTIN_CVTTSD2SI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
operator||
name|MASK_64BIT
argument_list|,
literal|"__builtin_ia32_cvtsd2si64"
argument_list|,
name|int64_ftype_v2df
argument_list|,
name|IX86_BUILTIN_CVTSD2SI64
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
operator||
name|MASK_64BIT
argument_list|,
literal|"__builtin_ia32_cvttsd2si64"
argument_list|,
name|int64_ftype_v2df
argument_list|,
name|IX86_BUILTIN_CVTTSD2SI64
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_cvtps2dq"
argument_list|,
name|v4si_ftype_v4sf
argument_list|,
name|IX86_BUILTIN_CVTPS2DQ
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_cvtps2pd"
argument_list|,
name|v2df_ftype_v4sf
argument_list|,
name|IX86_BUILTIN_CVTPS2PD
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_cvttps2dq"
argument_list|,
name|v4si_ftype_v4sf
argument_list|,
name|IX86_BUILTIN_CVTTPS2DQ
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_cvtsi2sd"
argument_list|,
name|v2df_ftype_v2df_int
argument_list|,
name|IX86_BUILTIN_CVTSI2SD
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
operator||
name|MASK_64BIT
argument_list|,
literal|"__builtin_ia32_cvtsi642sd"
argument_list|,
name|v2df_ftype_v2df_int64
argument_list|,
name|IX86_BUILTIN_CVTSI642SD
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_cvtsd2ss"
argument_list|,
name|v4sf_ftype_v4sf_v2df
argument_list|,
name|IX86_BUILTIN_CVTSD2SS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_cvtss2sd"
argument_list|,
name|v2df_ftype_v2df_v4sf
argument_list|,
name|IX86_BUILTIN_CVTSS2SD
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_setpd1"
argument_list|,
name|v2df_ftype_double
argument_list|,
name|IX86_BUILTIN_SETPD1
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_setpd"
argument_list|,
name|v2df_ftype_double_double
argument_list|,
name|IX86_BUILTIN_SETPD
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_setzeropd"
argument_list|,
name|ti_ftype_void
argument_list|,
name|IX86_BUILTIN_CLRPD
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_loadpd1"
argument_list|,
name|v2df_ftype_pcdouble
argument_list|,
name|IX86_BUILTIN_LOADPD1
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_loadrpd"
argument_list|,
name|v2df_ftype_pcdouble
argument_list|,
name|IX86_BUILTIN_LOADRPD
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_storepd1"
argument_list|,
name|void_ftype_pdouble_v2df
argument_list|,
name|IX86_BUILTIN_STOREPD1
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_storerpd"
argument_list|,
name|void_ftype_pdouble_v2df
argument_list|,
name|IX86_BUILTIN_STORERPD
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_clflush"
argument_list|,
name|void_ftype_pcvoid
argument_list|,
name|IX86_BUILTIN_CLFLUSH
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_lfence"
argument_list|,
name|void_ftype_void
argument_list|,
name|IX86_BUILTIN_LFENCE
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_mfence"
argument_list|,
name|void_ftype_void
argument_list|,
name|IX86_BUILTIN_MFENCE
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_loaddqa"
argument_list|,
name|v16qi_ftype_pcchar
argument_list|,
name|IX86_BUILTIN_LOADDQA
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_loaddqu"
argument_list|,
name|v16qi_ftype_pcchar
argument_list|,
name|IX86_BUILTIN_LOADDQU
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_loadd"
argument_list|,
name|v4si_ftype_pcint
argument_list|,
name|IX86_BUILTIN_LOADD
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_storedqa"
argument_list|,
name|void_ftype_pchar_v16qi
argument_list|,
name|IX86_BUILTIN_STOREDQA
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_storedqu"
argument_list|,
name|void_ftype_pchar_v16qi
argument_list|,
name|IX86_BUILTIN_STOREDQU
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_stored"
argument_list|,
name|void_ftype_pcint_v4si
argument_list|,
name|IX86_BUILTIN_STORED
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_movq"
argument_list|,
name|v2di_ftype_v2di
argument_list|,
name|IX86_BUILTIN_MOVQ
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE
argument_list|,
literal|"__builtin_ia32_setzero128"
argument_list|,
name|v2di_ftype_void
argument_list|,
name|IX86_BUILTIN_CLRTI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_psllw128"
argument_list|,
name|v8hi_ftype_v8hi_v2di
argument_list|,
name|IX86_BUILTIN_PSLLW128
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_pslld128"
argument_list|,
name|v4si_ftype_v4si_v2di
argument_list|,
name|IX86_BUILTIN_PSLLD128
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_psllq128"
argument_list|,
name|v2di_ftype_v2di_v2di
argument_list|,
name|IX86_BUILTIN_PSLLQ128
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_psrlw128"
argument_list|,
name|v8hi_ftype_v8hi_v2di
argument_list|,
name|IX86_BUILTIN_PSRLW128
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_psrld128"
argument_list|,
name|v4si_ftype_v4si_v2di
argument_list|,
name|IX86_BUILTIN_PSRLD128
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_psrlq128"
argument_list|,
name|v2di_ftype_v2di_v2di
argument_list|,
name|IX86_BUILTIN_PSRLQ128
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_psraw128"
argument_list|,
name|v8hi_ftype_v8hi_v2di
argument_list|,
name|IX86_BUILTIN_PSRAW128
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_psrad128"
argument_list|,
name|v4si_ftype_v4si_v2di
argument_list|,
name|IX86_BUILTIN_PSRAD128
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_pslldqi128"
argument_list|,
name|v2di_ftype_v2di_int
argument_list|,
name|IX86_BUILTIN_PSLLDQI128
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_psllwi128"
argument_list|,
name|v8hi_ftype_v8hi_int
argument_list|,
name|IX86_BUILTIN_PSLLWI128
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_pslldi128"
argument_list|,
name|v4si_ftype_v4si_int
argument_list|,
name|IX86_BUILTIN_PSLLDI128
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_psllqi128"
argument_list|,
name|v2di_ftype_v2di_int
argument_list|,
name|IX86_BUILTIN_PSLLQI128
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_psrldqi128"
argument_list|,
name|v2di_ftype_v2di_int
argument_list|,
name|IX86_BUILTIN_PSRLDQI128
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_psrlwi128"
argument_list|,
name|v8hi_ftype_v8hi_int
argument_list|,
name|IX86_BUILTIN_PSRLWI128
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_psrldi128"
argument_list|,
name|v4si_ftype_v4si_int
argument_list|,
name|IX86_BUILTIN_PSRLDI128
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_psrlqi128"
argument_list|,
name|v2di_ftype_v2di_int
argument_list|,
name|IX86_BUILTIN_PSRLQI128
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_psrawi128"
argument_list|,
name|v8hi_ftype_v8hi_int
argument_list|,
name|IX86_BUILTIN_PSRAWI128
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_psradi128"
argument_list|,
name|v4si_ftype_v4si_int
argument_list|,
name|IX86_BUILTIN_PSRADI128
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE2
argument_list|,
literal|"__builtin_ia32_pmaddwd128"
argument_list|,
name|v4si_ftype_v8hi_v8hi
argument_list|,
name|IX86_BUILTIN_PMADDWD128
argument_list|)
expr_stmt|;
comment|/* Prescott New Instructions.  */
name|def_builtin
argument_list|(
name|MASK_SSE3
argument_list|,
literal|"__builtin_ia32_monitor"
argument_list|,
name|void_ftype_pcvoid_unsigned_unsigned
argument_list|,
name|IX86_BUILTIN_MONITOR
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE3
argument_list|,
literal|"__builtin_ia32_mwait"
argument_list|,
name|void_ftype_unsigned_unsigned
argument_list|,
name|IX86_BUILTIN_MWAIT
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE3
argument_list|,
literal|"__builtin_ia32_movshdup"
argument_list|,
name|v4sf_ftype_v4sf
argument_list|,
name|IX86_BUILTIN_MOVSHDUP
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE3
argument_list|,
literal|"__builtin_ia32_movsldup"
argument_list|,
name|v4sf_ftype_v4sf
argument_list|,
name|IX86_BUILTIN_MOVSLDUP
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE3
argument_list|,
literal|"__builtin_ia32_lddqu"
argument_list|,
name|v16qi_ftype_pcchar
argument_list|,
name|IX86_BUILTIN_LDDQU
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE3
argument_list|,
literal|"__builtin_ia32_loadddup"
argument_list|,
name|v2df_ftype_pcdouble
argument_list|,
name|IX86_BUILTIN_LOADDDUP
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
name|MASK_SSE3
argument_list|,
literal|"__builtin_ia32_movddup"
argument_list|,
name|v2df_ftype_v2df
argument_list|,
name|IX86_BUILTIN_MOVDDUP
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Errors in the source file can cause expand_expr to return const0_rtx    where we expect a vector.  To avoid crashing, use one of the vector    clear instructions.  */
end_comment

begin_function
specifier|static
name|rtx
name|safe_vector_operand
parameter_list|(
name|rtx
name|x
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|x
operator|!=
name|const0_rtx
condition|)
return|return
name|x
return|;
name|x
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|VALID_MMX_REG_MODE
argument_list|(
name|mode
argument_list|)
operator|||
name|VALID_MMX_REG_MODE_3DNOW
argument_list|(
name|mode
argument_list|)
condition|)
name|emit_insn
argument_list|(
name|gen_mmx_clrdi
argument_list|(
name|mode
operator|==
name|DImode
condition|?
name|x
else|:
name|gen_rtx_SUBREG
argument_list|(
name|DImode
argument_list|,
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_sse_clrv4sf
argument_list|(
name|mode
operator|==
name|V4SFmode
condition|?
name|x
else|:
name|gen_rtx_SUBREG
argument_list|(
name|V4SFmode
argument_list|,
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|CONST0_RTX
argument_list|(
name|V4SFmode
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of ix86_expand_builtin to take care of binop insns.  */
end_comment

begin_function
specifier|static
name|rtx
name|ix86_expand_binop_builtin
parameter_list|(
name|enum
name|insn_code
name|icode
parameter_list|,
name|tree
name|arglist
parameter_list|,
name|rtx
name|target
parameter_list|)
block|{
name|rtx
name|pat
decl_stmt|;
name|tree
name|arg0
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|tree
name|arg1
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|op0
init|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|expand_expr
argument_list|(
name|arg1
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|tmode
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|mode0
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|mode1
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
decl_stmt|;
if|if
condition|(
name|VECTOR_MODE_P
argument_list|(
name|mode0
argument_list|)
condition|)
name|op0
operator|=
name|safe_vector_operand
argument_list|(
name|op0
argument_list|,
name|mode0
argument_list|)
expr_stmt|;
if|if
condition|(
name|VECTOR_MODE_P
argument_list|(
name|mode1
argument_list|)
condition|)
name|op1
operator|=
name|safe_vector_operand
argument_list|(
name|op1
argument_list|,
name|mode1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|tmode
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|target
operator|,
name|tmode
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op1
argument_list|)
operator|==
name|SImode
operator|&&
name|mode1
operator|==
name|TImode
condition|)
block|{
name|rtx
name|x
init|=
name|gen_reg_rtx
argument_list|(
name|V4SImode
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_sse2_loadd
argument_list|(
name|x
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
name|op1
operator|=
name|gen_lowpart
argument_list|(
name|TImode
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
comment|/* In case the insn wants input operands in modes different from      the result, abort.  */
if|if
condition|(
operator|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|mode0
operator|&&
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|VOIDmode
operator|)
operator|||
operator|(
name|GET_MODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|mode1
operator|&&
name|GET_MODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|VOIDmode
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode0
operator|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
operator|)
operator|(
name|op1
operator|,
name|mode1
operator|)
condition|)
name|op1
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode1
argument_list|,
name|op1
argument_list|)
expr_stmt|;
comment|/* In the commutative cases, both op0 and op1 are nonimmediate_operand,      yet one of the two must not be a memory.  This is normally enforced      by expanders, but we didn't bother to create one here.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|MEM
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of ix86_expand_builtin to take care of stores.  */
end_comment

begin_function
specifier|static
name|rtx
name|ix86_expand_store_builtin
parameter_list|(
name|enum
name|insn_code
name|icode
parameter_list|,
name|tree
name|arglist
parameter_list|)
block|{
name|rtx
name|pat
decl_stmt|;
name|tree
name|arg0
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|tree
name|arg1
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|op0
init|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|expand_expr
argument_list|(
name|arg1
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode0
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|mode1
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
decl_stmt|;
if|if
condition|(
name|VECTOR_MODE_P
argument_list|(
name|mode1
argument_list|)
condition|)
name|op1
operator|=
name|safe_vector_operand
argument_list|(
name|op1
argument_list|,
name|mode1
argument_list|)
expr_stmt|;
name|op0
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode0
argument_list|,
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|op0
argument_list|)
argument_list|)
expr_stmt|;
name|op1
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode1
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
condition|)
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of ix86_expand_builtin to take care of unop insns.  */
end_comment

begin_function
specifier|static
name|rtx
name|ix86_expand_unop_builtin
parameter_list|(
name|enum
name|insn_code
name|icode
parameter_list|,
name|tree
name|arglist
parameter_list|,
name|rtx
name|target
parameter_list|,
name|int
name|do_load
parameter_list|)
block|{
name|rtx
name|pat
decl_stmt|;
name|tree
name|arg0
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|rtx
name|op0
init|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|tmode
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|mode0
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
decl_stmt|;
if|if
condition|(
operator|!
name|target
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|tmode
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|target
operator|,
name|tmode
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_load
condition|)
name|op0
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode0
argument_list|,
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|op0
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|VECTOR_MODE_P
argument_list|(
name|mode0
argument_list|)
condition|)
name|op0
operator|=
name|safe_vector_operand
argument_list|(
name|op0
argument_list|,
name|mode0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode0
operator|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
block|}
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of ix86_expand_builtin to take care of three special unop insns:    sqrtss, rsqrtss, rcpss.  */
end_comment

begin_function
specifier|static
name|rtx
name|ix86_expand_unop1_builtin
parameter_list|(
name|enum
name|insn_code
name|icode
parameter_list|,
name|tree
name|arglist
parameter_list|,
name|rtx
name|target
parameter_list|)
block|{
name|rtx
name|pat
decl_stmt|;
name|tree
name|arg0
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|rtx
name|op1
decl_stmt|,
name|op0
init|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|tmode
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|mode0
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
decl_stmt|;
if|if
condition|(
operator|!
name|target
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|tmode
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|target
operator|,
name|tmode
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|VECTOR_MODE_P
argument_list|(
name|mode0
argument_list|)
condition|)
name|op0
operator|=
name|safe_vector_operand
argument_list|(
name|op0
argument_list|,
name|mode0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode0
operator|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|op0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
operator|)
operator|(
name|op1
operator|,
name|mode0
operator|)
condition|)
name|op1
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of ix86_expand_builtin to take care of comparison insns.  */
end_comment

begin_function
specifier|static
name|rtx
name|ix86_expand_sse_compare
parameter_list|(
specifier|const
name|struct
name|builtin_description
modifier|*
name|d
parameter_list|,
name|tree
name|arglist
parameter_list|,
name|rtx
name|target
parameter_list|)
block|{
name|rtx
name|pat
decl_stmt|;
name|tree
name|arg0
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|tree
name|arg1
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|op0
init|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|expand_expr
argument_list|(
name|arg1
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|op2
decl_stmt|;
name|enum
name|machine_mode
name|tmode
init|=
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|mode0
init|=
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|mode1
init|=
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
decl_stmt|;
name|enum
name|rtx_code
name|comparison
init|=
name|d
operator|->
name|comparison
decl_stmt|;
if|if
condition|(
name|VECTOR_MODE_P
argument_list|(
name|mode0
argument_list|)
condition|)
name|op0
operator|=
name|safe_vector_operand
argument_list|(
name|op0
argument_list|,
name|mode0
argument_list|)
expr_stmt|;
if|if
condition|(
name|VECTOR_MODE_P
argument_list|(
name|mode1
argument_list|)
condition|)
name|op1
operator|=
name|safe_vector_operand
argument_list|(
name|op1
argument_list|,
name|mode1
argument_list|)
expr_stmt|;
comment|/* Swap operands if we have a comparison that isn't available in      hardware.  */
if|if
condition|(
name|d
operator|->
name|flag
condition|)
block|{
name|rtx
name|tmp
init|=
name|gen_reg_rtx
argument_list|(
name|mode1
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|tmp
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|op1
operator|=
name|op0
expr_stmt|;
name|op0
operator|=
name|tmp
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|target
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|tmode
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|target
operator|,
name|tmode
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode0
operator|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
operator|)
operator|(
name|op1
operator|,
name|mode1
operator|)
condition|)
name|op1
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode1
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|op2
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|comparison
argument_list|,
name|mode0
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|d
operator|->
name|icode
argument_list|)
argument_list|(
name|target
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of ix86_expand_builtin to take care of comi insns.  */
end_comment

begin_function
specifier|static
name|rtx
name|ix86_expand_sse_comi
parameter_list|(
specifier|const
name|struct
name|builtin_description
modifier|*
name|d
parameter_list|,
name|tree
name|arglist
parameter_list|,
name|rtx
name|target
parameter_list|)
block|{
name|rtx
name|pat
decl_stmt|;
name|tree
name|arg0
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|tree
name|arg1
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|op0
init|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|expand_expr
argument_list|(
name|arg1
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|op2
decl_stmt|;
name|enum
name|machine_mode
name|mode0
init|=
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|mode1
init|=
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
decl_stmt|;
name|enum
name|rtx_code
name|comparison
init|=
name|d
operator|->
name|comparison
decl_stmt|;
if|if
condition|(
name|VECTOR_MODE_P
argument_list|(
name|mode0
argument_list|)
condition|)
name|op0
operator|=
name|safe_vector_operand
argument_list|(
name|op0
argument_list|,
name|mode0
argument_list|)
expr_stmt|;
if|if
condition|(
name|VECTOR_MODE_P
argument_list|(
name|mode1
argument_list|)
condition|)
name|op1
operator|=
name|safe_vector_operand
argument_list|(
name|op1
argument_list|,
name|mode1
argument_list|)
expr_stmt|;
comment|/* Swap operands if we have a comparison that isn't available in      hardware.  */
if|if
condition|(
name|d
operator|->
name|flag
condition|)
block|{
name|rtx
name|tmp
init|=
name|op1
decl_stmt|;
name|op1
operator|=
name|op0
expr_stmt|;
name|op0
operator|=
name|tmp
expr_stmt|;
block|}
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|target
operator|=
name|gen_rtx_SUBREG
argument_list|(
name|QImode
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode0
operator|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op1
operator|,
name|mode1
operator|)
condition|)
name|op1
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode1
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|op2
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|comparison
argument_list|,
name|mode0
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|d
operator|->
name|icode
argument_list|)
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_STRICT_LOW_PART
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|)
argument_list|,
name|gen_rtx_fmt_ee
argument_list|(
name|comparison
argument_list|,
name|QImode
argument_list|,
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SUBREG_REG
argument_list|(
name|target
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Expand an expression EXP that calls a built-in function,    with result going to TARGET if that's convenient    (and in mode MODE if that's convenient).    SUBTARGET may be used as the target for computing one of EXP's operands.    IGNORE is nonzero if the value is to be ignored.  */
end_comment

begin_function
name|rtx
name|ix86_expand_builtin
parameter_list|(
name|tree
name|exp
parameter_list|,
name|rtx
name|target
parameter_list|,
name|rtx
name|subtarget
name|ATTRIBUTE_UNUSED
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
specifier|const
name|struct
name|builtin_description
modifier|*
name|d
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|enum
name|insn_code
name|icode
decl_stmt|;
name|tree
name|fndecl
init|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|arg0
decl_stmt|,
name|arg1
decl_stmt|,
name|arg2
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|,
name|op2
decl_stmt|,
name|pat
decl_stmt|;
name|enum
name|machine_mode
name|tmode
decl_stmt|,
name|mode0
decl_stmt|,
name|mode1
decl_stmt|,
name|mode2
decl_stmt|;
name|unsigned
name|int
name|fcode
init|=
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|fcode
condition|)
block|{
case|case
name|IX86_BUILTIN_EMMS
case|:
name|emit_insn
argument_list|(
name|gen_emms
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|IX86_BUILTIN_SFENCE
case|:
name|emit_insn
argument_list|(
name|gen_sfence
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|IX86_BUILTIN_PEXTRW
case|:
case|case
name|IX86_BUILTIN_PEXTRW128
case|:
name|icode
operator|=
operator|(
name|fcode
operator|==
name|IX86_BUILTIN_PEXTRW
condition|?
name|CODE_FOR_mmx_pextrw
else|:
name|CODE_FOR_sse2_pextrw
operator|)
expr_stmt|;
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_expr
argument_list|(
name|arg1
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tmode
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
expr_stmt|;
name|mode0
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
expr_stmt|;
name|mode1
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode0
operator|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
operator|)
operator|(
name|op1
operator|,
name|mode1
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"selector must be an integer constant in the range 0..%i"
argument_list|,
name|fcode
operator|==
name|IX86_BUILTIN_PEXTRW
condition|?
literal|3
else|:
literal|7
argument_list|)
expr_stmt|;
return|return
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
return|;
block|}
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|tmode
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|target
operator|,
name|tmode
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|target
return|;
case|case
name|IX86_BUILTIN_PINSRW
case|:
case|case
name|IX86_BUILTIN_PINSRW128
case|:
name|icode
operator|=
operator|(
name|fcode
operator|==
name|IX86_BUILTIN_PINSRW
condition|?
name|CODE_FOR_mmx_pinsrw
else|:
name|CODE_FOR_sse2_pinsrw
operator|)
expr_stmt|;
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_expr
argument_list|(
name|arg1
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op2
operator|=
name|expand_expr
argument_list|(
name|arg2
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tmode
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
expr_stmt|;
name|mode0
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
expr_stmt|;
name|mode1
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
expr_stmt|;
name|mode2
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|3
index|]
operator|.
name|mode
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode0
operator|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
operator|)
operator|(
name|op1
operator|,
name|mode1
operator|)
condition|)
name|op1
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode1
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|3
index|]
operator|.
name|predicate
operator|)
operator|(
name|op2
operator|,
name|mode2
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"selector must be an integer constant in the range 0..%i"
argument_list|,
name|fcode
operator|==
name|IX86_BUILTIN_PINSRW
condition|?
literal|15
else|:
literal|255
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|tmode
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|target
operator|,
name|tmode
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|target
return|;
case|case
name|IX86_BUILTIN_MASKMOVQ
case|:
case|case
name|IX86_BUILTIN_MASKMOVDQU
case|:
name|icode
operator|=
operator|(
name|fcode
operator|==
name|IX86_BUILTIN_MASKMOVQ
condition|?
operator|(
name|TARGET_64BIT
condition|?
name|CODE_FOR_mmx_maskmovq_rex
else|:
name|CODE_FOR_mmx_maskmovq
operator|)
else|:
operator|(
name|TARGET_64BIT
condition|?
name|CODE_FOR_sse2_maskmovdqu_rex64
else|:
name|CODE_FOR_sse2_maskmovdqu
operator|)
operator|)
expr_stmt|;
comment|/* Note the arg order is different from the operand order.  */
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_expr
argument_list|(
name|arg1
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op2
operator|=
name|expand_expr
argument_list|(
name|arg2
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mode0
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
expr_stmt|;
name|mode1
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
expr_stmt|;
name|mode2
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode0
operator|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op1
operator|,
name|mode1
operator|)
condition|)
name|op1
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode1
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
operator|)
operator|(
name|op2
operator|,
name|mode2
operator|)
condition|)
name|op2
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode2
argument_list|,
name|op2
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|IX86_BUILTIN_SQRTSS
case|:
return|return
name|ix86_expand_unop1_builtin
argument_list|(
name|CODE_FOR_vmsqrtv4sf2
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IX86_BUILTIN_RSQRTSS
case|:
return|return
name|ix86_expand_unop1_builtin
argument_list|(
name|CODE_FOR_vmrsqrtv4sf2
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IX86_BUILTIN_RCPSS
case|:
return|return
name|ix86_expand_unop1_builtin
argument_list|(
name|CODE_FOR_vmrcpv4sf2
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IX86_BUILTIN_LOADAPS
case|:
return|return
name|ix86_expand_unop_builtin
argument_list|(
name|CODE_FOR_sse_movaps
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|,
literal|1
argument_list|)
return|;
case|case
name|IX86_BUILTIN_LOADUPS
case|:
return|return
name|ix86_expand_unop_builtin
argument_list|(
name|CODE_FOR_sse_movups
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|,
literal|1
argument_list|)
return|;
case|case
name|IX86_BUILTIN_STOREAPS
case|:
return|return
name|ix86_expand_store_builtin
argument_list|(
name|CODE_FOR_sse_movaps
argument_list|,
name|arglist
argument_list|)
return|;
case|case
name|IX86_BUILTIN_STOREUPS
case|:
return|return
name|ix86_expand_store_builtin
argument_list|(
name|CODE_FOR_sse_movups
argument_list|,
name|arglist
argument_list|)
return|;
case|case
name|IX86_BUILTIN_LOADSS
case|:
return|return
name|ix86_expand_unop_builtin
argument_list|(
name|CODE_FOR_sse_loadss
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|,
literal|1
argument_list|)
return|;
case|case
name|IX86_BUILTIN_STORESS
case|:
return|return
name|ix86_expand_store_builtin
argument_list|(
name|CODE_FOR_sse_storess
argument_list|,
name|arglist
argument_list|)
return|;
case|case
name|IX86_BUILTIN_LOADHPS
case|:
case|case
name|IX86_BUILTIN_LOADLPS
case|:
case|case
name|IX86_BUILTIN_LOADHPD
case|:
case|case
name|IX86_BUILTIN_LOADLPD
case|:
name|icode
operator|=
operator|(
name|fcode
operator|==
name|IX86_BUILTIN_LOADHPS
condition|?
name|CODE_FOR_sse_movhps
else|:
name|fcode
operator|==
name|IX86_BUILTIN_LOADLPS
condition|?
name|CODE_FOR_sse_movlps
else|:
name|fcode
operator|==
name|IX86_BUILTIN_LOADHPD
condition|?
name|CODE_FOR_sse2_movhpd
else|:
name|CODE_FOR_sse2_movsd
operator|)
expr_stmt|;
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_expr
argument_list|(
name|arg1
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tmode
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
expr_stmt|;
name|mode0
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
expr_stmt|;
name|mode1
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode0
operator|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode1
argument_list|,
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|tmode
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|target
operator|,
name|tmode
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|target
return|;
case|case
name|IX86_BUILTIN_STOREHPS
case|:
case|case
name|IX86_BUILTIN_STORELPS
case|:
case|case
name|IX86_BUILTIN_STOREHPD
case|:
case|case
name|IX86_BUILTIN_STORELPD
case|:
name|icode
operator|=
operator|(
name|fcode
operator|==
name|IX86_BUILTIN_STOREHPS
condition|?
name|CODE_FOR_sse_movhps
else|:
name|fcode
operator|==
name|IX86_BUILTIN_STORELPS
condition|?
name|CODE_FOR_sse_movlps
else|:
name|fcode
operator|==
name|IX86_BUILTIN_STOREHPD
condition|?
name|CODE_FOR_sse2_movhpd
else|:
name|CODE_FOR_sse2_movsd
operator|)
expr_stmt|;
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_expr
argument_list|(
name|arg1
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mode0
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
expr_stmt|;
name|mode1
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
expr_stmt|;
name|op0
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode0
argument_list|,
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|op0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
operator|)
operator|(
name|op1
operator|,
name|mode1
operator|)
condition|)
name|op1
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode1
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|op0
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|IX86_BUILTIN_MOVNTPS
case|:
return|return
name|ix86_expand_store_builtin
argument_list|(
name|CODE_FOR_sse_movntv4sf
argument_list|,
name|arglist
argument_list|)
return|;
case|case
name|IX86_BUILTIN_MOVNTQ
case|:
return|return
name|ix86_expand_store_builtin
argument_list|(
name|CODE_FOR_sse_movntdi
argument_list|,
name|arglist
argument_list|)
return|;
case|case
name|IX86_BUILTIN_LDMXCSR
case|:
name|op0
operator|=
name|expand_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|target
operator|=
name|assign_386_stack_local
argument_list|(
name|SImode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_ldmxcsr
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|IX86_BUILTIN_STMXCSR
case|:
name|target
operator|=
name|assign_386_stack_local
argument_list|(
name|SImode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_stmxcsr
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|copy_to_mode_reg
argument_list|(
name|SImode
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IX86_BUILTIN_SHUFPS
case|:
case|case
name|IX86_BUILTIN_SHUFPD
case|:
name|icode
operator|=
operator|(
name|fcode
operator|==
name|IX86_BUILTIN_SHUFPS
condition|?
name|CODE_FOR_sse_shufps
else|:
name|CODE_FOR_sse2_shufpd
operator|)
expr_stmt|;
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_expr
argument_list|(
name|arg1
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op2
operator|=
name|expand_expr
argument_list|(
name|arg2
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tmode
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
expr_stmt|;
name|mode0
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
expr_stmt|;
name|mode1
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
expr_stmt|;
name|mode2
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|3
index|]
operator|.
name|mode
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode0
operator|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
operator|)
operator|(
name|op1
operator|,
name|mode1
operator|)
condition|)
name|op1
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode1
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|3
index|]
operator|.
name|predicate
operator|)
operator|(
name|op2
operator|,
name|mode2
operator|)
condition|)
block|{
comment|/* @@@ better error message */
name|error
argument_list|(
literal|"mask must be an immediate"
argument_list|)
expr_stmt|;
return|return
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
return|;
block|}
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|tmode
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|target
operator|,
name|tmode
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|target
return|;
case|case
name|IX86_BUILTIN_PSHUFW
case|:
case|case
name|IX86_BUILTIN_PSHUFD
case|:
case|case
name|IX86_BUILTIN_PSHUFHW
case|:
case|case
name|IX86_BUILTIN_PSHUFLW
case|:
name|icode
operator|=
operator|(
name|fcode
operator|==
name|IX86_BUILTIN_PSHUFHW
condition|?
name|CODE_FOR_sse2_pshufhw
else|:
name|fcode
operator|==
name|IX86_BUILTIN_PSHUFLW
condition|?
name|CODE_FOR_sse2_pshuflw
else|:
name|fcode
operator|==
name|IX86_BUILTIN_PSHUFD
condition|?
name|CODE_FOR_sse2_pshufd
else|:
name|CODE_FOR_mmx_pshufw
operator|)
expr_stmt|;
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_expr
argument_list|(
name|arg1
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tmode
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
expr_stmt|;
name|mode1
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
expr_stmt|;
name|mode2
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode1
operator|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode1
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
operator|)
operator|(
name|op1
operator|,
name|mode2
operator|)
condition|)
block|{
comment|/* @@@ better error message */
name|error
argument_list|(
literal|"mask must be an immediate"
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|tmode
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|target
operator|,
name|tmode
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|target
return|;
case|case
name|IX86_BUILTIN_PSLLDQI128
case|:
case|case
name|IX86_BUILTIN_PSRLDQI128
case|:
name|icode
operator|=
operator|(
name|fcode
operator|==
name|IX86_BUILTIN_PSLLDQI128
condition|?
name|CODE_FOR_sse2_ashlti3
else|:
name|CODE_FOR_sse2_lshrti3
operator|)
expr_stmt|;
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_expr
argument_list|(
name|arg1
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tmode
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
expr_stmt|;
name|mode1
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
expr_stmt|;
name|mode2
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode1
operator|)
condition|)
block|{
name|op0
operator|=
name|copy_to_reg
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|op0
operator|=
name|simplify_gen_subreg
argument_list|(
name|mode1
argument_list|,
name|op0
argument_list|,
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
operator|)
operator|(
name|op1
operator|,
name|mode2
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"shift must be an immediate"
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|V2DImode
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|simplify_gen_subreg
argument_list|(
name|tmode
argument_list|,
name|target
argument_list|,
name|V2DImode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|target
return|;
case|case
name|IX86_BUILTIN_FEMMS
case|:
name|emit_insn
argument_list|(
name|gen_femms
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|NULL_RTX
return|;
case|case
name|IX86_BUILTIN_PAVGUSB
case|:
return|return
name|ix86_expand_binop_builtin
argument_list|(
name|CODE_FOR_pavgusb
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IX86_BUILTIN_PF2ID
case|:
return|return
name|ix86_expand_unop_builtin
argument_list|(
name|CODE_FOR_pf2id
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|IX86_BUILTIN_PFACC
case|:
return|return
name|ix86_expand_binop_builtin
argument_list|(
name|CODE_FOR_pfacc
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IX86_BUILTIN_PFADD
case|:
return|return
name|ix86_expand_binop_builtin
argument_list|(
name|CODE_FOR_addv2sf3
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IX86_BUILTIN_PFCMPEQ
case|:
return|return
name|ix86_expand_binop_builtin
argument_list|(
name|CODE_FOR_eqv2sf3
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IX86_BUILTIN_PFCMPGE
case|:
return|return
name|ix86_expand_binop_builtin
argument_list|(
name|CODE_FOR_gev2sf3
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IX86_BUILTIN_PFCMPGT
case|:
return|return
name|ix86_expand_binop_builtin
argument_list|(
name|CODE_FOR_gtv2sf3
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IX86_BUILTIN_PFMAX
case|:
return|return
name|ix86_expand_binop_builtin
argument_list|(
name|CODE_FOR_pfmaxv2sf3
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IX86_BUILTIN_PFMIN
case|:
return|return
name|ix86_expand_binop_builtin
argument_list|(
name|CODE_FOR_pfminv2sf3
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IX86_BUILTIN_PFMUL
case|:
return|return
name|ix86_expand_binop_builtin
argument_list|(
name|CODE_FOR_mulv2sf3
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IX86_BUILTIN_PFRCP
case|:
return|return
name|ix86_expand_unop_builtin
argument_list|(
name|CODE_FOR_pfrcpv2sf2
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|IX86_BUILTIN_PFRCPIT1
case|:
return|return
name|ix86_expand_binop_builtin
argument_list|(
name|CODE_FOR_pfrcpit1v2sf3
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IX86_BUILTIN_PFRCPIT2
case|:
return|return
name|ix86_expand_binop_builtin
argument_list|(
name|CODE_FOR_pfrcpit2v2sf3
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IX86_BUILTIN_PFRSQIT1
case|:
return|return
name|ix86_expand_binop_builtin
argument_list|(
name|CODE_FOR_pfrsqit1v2sf3
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IX86_BUILTIN_PFRSQRT
case|:
return|return
name|ix86_expand_unop_builtin
argument_list|(
name|CODE_FOR_pfrsqrtv2sf2
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|IX86_BUILTIN_PFSUB
case|:
return|return
name|ix86_expand_binop_builtin
argument_list|(
name|CODE_FOR_subv2sf3
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IX86_BUILTIN_PFSUBR
case|:
return|return
name|ix86_expand_binop_builtin
argument_list|(
name|CODE_FOR_subrv2sf3
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IX86_BUILTIN_PI2FD
case|:
return|return
name|ix86_expand_unop_builtin
argument_list|(
name|CODE_FOR_floatv2si2
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|IX86_BUILTIN_PMULHRW
case|:
return|return
name|ix86_expand_binop_builtin
argument_list|(
name|CODE_FOR_pmulhrwv4hi3
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IX86_BUILTIN_PF2IW
case|:
return|return
name|ix86_expand_unop_builtin
argument_list|(
name|CODE_FOR_pf2iw
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|IX86_BUILTIN_PFNACC
case|:
return|return
name|ix86_expand_binop_builtin
argument_list|(
name|CODE_FOR_pfnacc
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IX86_BUILTIN_PFPNACC
case|:
return|return
name|ix86_expand_binop_builtin
argument_list|(
name|CODE_FOR_pfpnacc
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IX86_BUILTIN_PI2FW
case|:
return|return
name|ix86_expand_unop_builtin
argument_list|(
name|CODE_FOR_pi2fw
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|IX86_BUILTIN_PSWAPDSI
case|:
return|return
name|ix86_expand_unop_builtin
argument_list|(
name|CODE_FOR_pswapdv2si2
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|IX86_BUILTIN_PSWAPDSF
case|:
return|return
name|ix86_expand_unop_builtin
argument_list|(
name|CODE_FOR_pswapdv2sf2
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|IX86_BUILTIN_SSE_ZERO
case|:
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|V4SFmode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_sse_clrv4sf
argument_list|(
name|target
argument_list|,
name|CONST0_RTX
argument_list|(
name|V4SFmode
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|target
return|;
case|case
name|IX86_BUILTIN_MMX_ZERO
case|:
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_mmx_clrdi
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|target
return|;
case|case
name|IX86_BUILTIN_CLRTI
case|:
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|V2DImode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_sse2_clrti
argument_list|(
name|simplify_gen_subreg
argument_list|(
name|TImode
argument_list|,
name|target
argument_list|,
name|V2DImode
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|target
return|;
case|case
name|IX86_BUILTIN_SQRTSD
case|:
return|return
name|ix86_expand_unop1_builtin
argument_list|(
name|CODE_FOR_vmsqrtv2df2
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IX86_BUILTIN_LOADAPD
case|:
return|return
name|ix86_expand_unop_builtin
argument_list|(
name|CODE_FOR_sse2_movapd
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|,
literal|1
argument_list|)
return|;
case|case
name|IX86_BUILTIN_LOADUPD
case|:
return|return
name|ix86_expand_unop_builtin
argument_list|(
name|CODE_FOR_sse2_movupd
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|,
literal|1
argument_list|)
return|;
case|case
name|IX86_BUILTIN_STOREAPD
case|:
return|return
name|ix86_expand_store_builtin
argument_list|(
name|CODE_FOR_sse2_movapd
argument_list|,
name|arglist
argument_list|)
return|;
case|case
name|IX86_BUILTIN_STOREUPD
case|:
return|return
name|ix86_expand_store_builtin
argument_list|(
name|CODE_FOR_sse2_movupd
argument_list|,
name|arglist
argument_list|)
return|;
case|case
name|IX86_BUILTIN_LOADSD
case|:
return|return
name|ix86_expand_unop_builtin
argument_list|(
name|CODE_FOR_sse2_loadsd
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|,
literal|1
argument_list|)
return|;
case|case
name|IX86_BUILTIN_STORESD
case|:
return|return
name|ix86_expand_store_builtin
argument_list|(
name|CODE_FOR_sse2_storesd
argument_list|,
name|arglist
argument_list|)
return|;
case|case
name|IX86_BUILTIN_SETPD1
case|:
name|target
operator|=
name|assign_386_stack_local
argument_list|(
name|DFmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|adjust_address
argument_list|(
name|target
argument_list|,
name|DFmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|gen_reg_rtx
argument_list|(
name|V2DFmode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_sse2_loadsd
argument_list|(
name|op0
argument_list|,
name|adjust_address
argument_list|(
name|target
argument_list|,
name|V2DFmode
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_sse2_shufpd
argument_list|(
name|op0
argument_list|,
name|op0
argument_list|,
name|op0
argument_list|,
name|GEN_INT
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|op0
return|;
case|case
name|IX86_BUILTIN_SETPD
case|:
name|target
operator|=
name|assign_386_stack_local
argument_list|(
name|V2DFmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|adjust_address
argument_list|(
name|target
argument_list|,
name|DFmode
argument_list|,
literal|0
argument_list|)
argument_list|,
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|adjust_address
argument_list|(
name|target
argument_list|,
name|DFmode
argument_list|,
literal|8
argument_list|)
argument_list|,
name|expand_expr
argument_list|(
name|arg1
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|gen_reg_rtx
argument_list|(
name|V2DFmode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_sse2_movapd
argument_list|(
name|op0
argument_list|,
name|target
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|op0
return|;
case|case
name|IX86_BUILTIN_LOADRPD
case|:
name|target
operator|=
name|ix86_expand_unop_builtin
argument_list|(
name|CODE_FOR_sse2_movapd
argument_list|,
name|arglist
argument_list|,
name|gen_reg_rtx
argument_list|(
name|V2DFmode
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_sse2_shufpd
argument_list|(
name|target
argument_list|,
name|target
argument_list|,
name|target
argument_list|,
name|GEN_INT
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|target
return|;
case|case
name|IX86_BUILTIN_LOADPD1
case|:
name|target
operator|=
name|ix86_expand_unop_builtin
argument_list|(
name|CODE_FOR_sse2_loadsd
argument_list|,
name|arglist
argument_list|,
name|gen_reg_rtx
argument_list|(
name|V2DFmode
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_sse2_shufpd
argument_list|(
name|target
argument_list|,
name|target
argument_list|,
name|target
argument_list|,
name|const0_rtx
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|target
return|;
case|case
name|IX86_BUILTIN_STOREPD1
case|:
return|return
name|ix86_expand_store_builtin
argument_list|(
name|CODE_FOR_sse2_movapd
argument_list|,
name|arglist
argument_list|)
return|;
case|case
name|IX86_BUILTIN_STORERPD
case|:
return|return
name|ix86_expand_store_builtin
argument_list|(
name|CODE_FOR_sse2_movapd
argument_list|,
name|arglist
argument_list|)
return|;
case|case
name|IX86_BUILTIN_CLRPD
case|:
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|V2DFmode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_sse_clrv2df
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|target
return|;
case|case
name|IX86_BUILTIN_MFENCE
case|:
name|emit_insn
argument_list|(
name|gen_sse2_mfence
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|IX86_BUILTIN_LFENCE
case|:
name|emit_insn
argument_list|(
name|gen_sse2_lfence
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|IX86_BUILTIN_CLFLUSH
case|:
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|icode
operator|=
name|CODE_FOR_sse2_clflush
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|Pmode
operator|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_sse2_clflush
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|IX86_BUILTIN_MOVNTPD
case|:
return|return
name|ix86_expand_store_builtin
argument_list|(
name|CODE_FOR_sse2_movntv2df
argument_list|,
name|arglist
argument_list|)
return|;
case|case
name|IX86_BUILTIN_MOVNTDQ
case|:
return|return
name|ix86_expand_store_builtin
argument_list|(
name|CODE_FOR_sse2_movntv2di
argument_list|,
name|arglist
argument_list|)
return|;
case|case
name|IX86_BUILTIN_MOVNTI
case|:
return|return
name|ix86_expand_store_builtin
argument_list|(
name|CODE_FOR_sse2_movntsi
argument_list|,
name|arglist
argument_list|)
return|;
case|case
name|IX86_BUILTIN_LOADDQA
case|:
return|return
name|ix86_expand_unop_builtin
argument_list|(
name|CODE_FOR_sse2_movdqa
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|,
literal|1
argument_list|)
return|;
case|case
name|IX86_BUILTIN_LOADDQU
case|:
return|return
name|ix86_expand_unop_builtin
argument_list|(
name|CODE_FOR_sse2_movdqu
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|,
literal|1
argument_list|)
return|;
case|case
name|IX86_BUILTIN_LOADD
case|:
return|return
name|ix86_expand_unop_builtin
argument_list|(
name|CODE_FOR_sse2_loadd
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|,
literal|1
argument_list|)
return|;
case|case
name|IX86_BUILTIN_STOREDQA
case|:
return|return
name|ix86_expand_store_builtin
argument_list|(
name|CODE_FOR_sse2_movdqa
argument_list|,
name|arglist
argument_list|)
return|;
case|case
name|IX86_BUILTIN_STOREDQU
case|:
return|return
name|ix86_expand_store_builtin
argument_list|(
name|CODE_FOR_sse2_movdqu
argument_list|,
name|arglist
argument_list|)
return|;
case|case
name|IX86_BUILTIN_STORED
case|:
return|return
name|ix86_expand_store_builtin
argument_list|(
name|CODE_FOR_sse2_stored
argument_list|,
name|arglist
argument_list|)
return|;
case|case
name|IX86_BUILTIN_MONITOR
case|:
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_expr
argument_list|(
name|arg1
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op2
operator|=
name|expand_expr
argument_list|(
name|arg2
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|op0
argument_list|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|SImode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|op1
argument_list|)
condition|)
name|op1
operator|=
name|copy_to_mode_reg
argument_list|(
name|SImode
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|op2
argument_list|)
condition|)
name|op2
operator|=
name|copy_to_mode_reg
argument_list|(
name|SImode
argument_list|,
name|op2
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_monitor
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|IX86_BUILTIN_MWAIT
case|:
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_expr
argument_list|(
name|arg1
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|op0
argument_list|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|SImode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|op1
argument_list|)
condition|)
name|op1
operator|=
name|copy_to_mode_reg
argument_list|(
name|SImode
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_mwait
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|IX86_BUILTIN_LOADDDUP
case|:
return|return
name|ix86_expand_unop_builtin
argument_list|(
name|CODE_FOR_loadddup
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|,
literal|1
argument_list|)
return|;
case|case
name|IX86_BUILTIN_LDDQU
case|:
return|return
name|ix86_expand_unop_builtin
argument_list|(
name|CODE_FOR_lddqu
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|,
literal|1
argument_list|)
return|;
default|default:
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|d
operator|=
name|bdesc_2arg
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|bdesc_2arg
argument_list|)
condition|;
name|i
operator|++
operator|,
name|d
operator|++
control|)
if|if
condition|(
name|d
operator|->
name|code
operator|==
name|fcode
condition|)
block|{
comment|/* Compares are treated specially.  */
if|if
condition|(
name|d
operator|->
name|icode
operator|==
name|CODE_FOR_maskcmpv4sf3
operator|||
name|d
operator|->
name|icode
operator|==
name|CODE_FOR_vmmaskcmpv4sf3
operator|||
name|d
operator|->
name|icode
operator|==
name|CODE_FOR_maskncmpv4sf3
operator|||
name|d
operator|->
name|icode
operator|==
name|CODE_FOR_vmmaskncmpv4sf3
operator|||
name|d
operator|->
name|icode
operator|==
name|CODE_FOR_maskcmpv2df3
operator|||
name|d
operator|->
name|icode
operator|==
name|CODE_FOR_vmmaskcmpv2df3
operator|||
name|d
operator|->
name|icode
operator|==
name|CODE_FOR_maskncmpv2df3
operator|||
name|d
operator|->
name|icode
operator|==
name|CODE_FOR_vmmaskncmpv2df3
condition|)
return|return
name|ix86_expand_sse_compare
argument_list|(
name|d
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
return|return
name|ix86_expand_binop_builtin
argument_list|(
name|d
operator|->
name|icode
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|d
operator|=
name|bdesc_1arg
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|bdesc_1arg
argument_list|)
condition|;
name|i
operator|++
operator|,
name|d
operator|++
control|)
if|if
condition|(
name|d
operator|->
name|code
operator|==
name|fcode
condition|)
return|return
name|ix86_expand_unop_builtin
argument_list|(
name|d
operator|->
name|icode
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
return|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|d
operator|=
name|bdesc_comi
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|bdesc_comi
argument_list|)
condition|;
name|i
operator|++
operator|,
name|d
operator|++
control|)
if|if
condition|(
name|d
operator|->
name|code
operator|==
name|fcode
condition|)
return|return
name|ix86_expand_sse_comi
argument_list|(
name|d
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
comment|/* @@@ Should really do something sensible here.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Store OPERAND to the memory after reload is completed.  This means    that we can't easily use assign_stack_local.  */
end_comment

begin_function
name|rtx
name|ix86_force_to_memory
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|operand
parameter_list|)
block|{
name|rtx
name|result
decl_stmt|;
if|if
condition|(
operator|!
name|reload_completed
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|TARGET_RED_ZONE
condition|)
block|{
name|result
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
operator|-
name|RED_ZONE_SIZE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|result
argument_list|,
name|operand
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|TARGET_RED_ZONE
operator|&&
name|TARGET_64BIT
condition|)
block|{
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|HImode
case|:
case|case
name|SImode
case|:
name|operand
operator|=
name|gen_lowpart
argument_list|(
name|DImode
argument_list|,
name|operand
argument_list|)
expr_stmt|;
comment|/* FALLTHRU */
case|case
name|DImode
case|:
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|DImode
argument_list|,
name|gen_rtx_PRE_DEC
argument_list|(
name|DImode
argument_list|,
name|stack_pointer_rtx
argument_list|)
argument_list|)
argument_list|,
name|operand
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|result
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode
argument_list|,
name|stack_pointer_rtx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|DImode
case|:
block|{
name|rtx
name|operands
index|[
literal|2
index|]
decl_stmt|;
name|split_di
argument_list|(
operator|&
name|operand
argument_list|,
literal|1
argument_list|,
name|operands
argument_list|,
name|operands
operator|+
literal|1
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|gen_rtx_PRE_DEC
argument_list|(
name|Pmode
argument_list|,
name|stack_pointer_rtx
argument_list|)
argument_list|)
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|gen_rtx_PRE_DEC
argument_list|(
name|Pmode
argument_list|,
name|stack_pointer_rtx
argument_list|)
argument_list|)
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|HImode
case|:
comment|/* It is better to store HImodes as SImodes.  */
if|if
condition|(
operator|!
name|TARGET_PARTIAL_REG_STALL
condition|)
name|operand
operator|=
name|gen_lowpart
argument_list|(
name|SImode
argument_list|,
name|operand
argument_list|)
expr_stmt|;
comment|/* FALLTHRU */
case|case
name|SImode
case|:
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|GET_MODE
argument_list|(
name|operand
argument_list|)
argument_list|,
name|gen_rtx_PRE_DEC
argument_list|(
name|SImode
argument_list|,
name|stack_pointer_rtx
argument_list|)
argument_list|)
argument_list|,
name|operand
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|result
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode
argument_list|,
name|stack_pointer_rtx
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Free operand from the memory.  */
end_comment

begin_function
name|void
name|ix86_free_from_memory
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|TARGET_RED_ZONE
condition|)
block|{
name|int
name|size
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|DImode
operator|||
name|TARGET_64BIT
condition|)
name|size
operator|=
literal|8
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|HImode
operator|&&
name|TARGET_PARTIAL_REG_STALL
condition|)
name|size
operator|=
literal|2
expr_stmt|;
else|else
name|size
operator|=
literal|4
expr_stmt|;
comment|/* Use LEA to deallocate stack space.  In peephole2 it will be converted          to pop or add instruction if registers are available.  */
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|size
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Put float CONST_DOUBLE in the constant pool instead of fp regs.    QImode must go into class Q_REGS.    Narrow ALL_REGS to GENERAL_REGS.  This supports allowing movsf and    movdf to do mem-to-mem moves through integer regs.  */
end_comment

begin_function
name|enum
name|reg_class
name|ix86_preferred_reload_class
parameter_list|(
name|rtx
name|x
parameter_list|,
name|enum
name|reg_class
name|class
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_VECTOR
operator|&&
name|x
operator|!=
name|CONST0_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
return|return
name|NO_REGS
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|VOIDmode
condition|)
block|{
comment|/* SSE can't load any constant directly yet.  */
if|if
condition|(
name|SSE_CLASS_P
argument_list|(
name|class
argument_list|)
condition|)
return|return
name|NO_REGS
return|;
comment|/* Floats can load 0 and 1.  */
if|if
condition|(
name|MAYBE_FLOAT_CLASS_P
argument_list|(
name|class
argument_list|)
operator|&&
name|standard_80387_constant_p
argument_list|(
name|x
argument_list|)
condition|)
block|{
comment|/* Limit class to non-SSE.  Use GENERAL_REGS if possible.  */
if|if
condition|(
name|MAYBE_SSE_CLASS_P
argument_list|(
name|class
argument_list|)
condition|)
return|return
operator|(
name|reg_class_subset_p
argument_list|(
name|class
argument_list|,
name|GENERAL_REGS
argument_list|)
condition|?
name|GENERAL_REGS
else|:
name|FLOAT_REGS
operator|)
return|;
else|else
return|return
name|class
return|;
block|}
comment|/* General regs can load everything.  */
if|if
condition|(
name|reg_class_subset_p
argument_list|(
name|class
argument_list|,
name|GENERAL_REGS
argument_list|)
condition|)
return|return
name|GENERAL_REGS
return|;
comment|/* In case we haven't resolved FLOAT or SSE yet, give up.  */
if|if
condition|(
name|MAYBE_FLOAT_CLASS_P
argument_list|(
name|class
argument_list|)
operator|||
name|MAYBE_SSE_CLASS_P
argument_list|(
name|class
argument_list|)
condition|)
return|return
name|NO_REGS
return|;
block|}
if|if
condition|(
name|MAYBE_MMX_CLASS_P
argument_list|(
name|class
argument_list|)
operator|&&
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|NO_REGS
return|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|QImode
operator|&&
operator|!
name|reg_class_subset_p
argument_list|(
name|class
argument_list|,
name|Q_REGS
argument_list|)
condition|)
return|return
name|Q_REGS
return|;
return|return
name|class
return|;
block|}
end_function

begin_comment
comment|/* If we are copying between general and FP registers, we need a memory    location. The same is true for SSE and MMX registers.     The macro can't work reliably when one of the CLASSES is class containing    registers from multiple units (SSE, MMX, integer).  We avoid this by never    combining those units in single alternative in the machine description.    Ensure that this constraint holds to avoid unexpected surprises.     When STRICT is false, we are being called from REGISTER_MOVE_COST, so do not    enforce these sanity checks.  */
end_comment

begin_function
name|int
name|ix86_secondary_memory_needed
parameter_list|(
name|enum
name|reg_class
name|class1
parameter_list|,
name|enum
name|reg_class
name|class2
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|int
name|strict
parameter_list|)
block|{
if|if
condition|(
name|MAYBE_FLOAT_CLASS_P
argument_list|(
name|class1
argument_list|)
operator|!=
name|FLOAT_CLASS_P
argument_list|(
name|class1
argument_list|)
operator|||
name|MAYBE_FLOAT_CLASS_P
argument_list|(
name|class2
argument_list|)
operator|!=
name|FLOAT_CLASS_P
argument_list|(
name|class2
argument_list|)
operator|||
name|MAYBE_SSE_CLASS_P
argument_list|(
name|class1
argument_list|)
operator|!=
name|SSE_CLASS_P
argument_list|(
name|class1
argument_list|)
operator|||
name|MAYBE_SSE_CLASS_P
argument_list|(
name|class2
argument_list|)
operator|!=
name|SSE_CLASS_P
argument_list|(
name|class2
argument_list|)
operator|||
name|MAYBE_MMX_CLASS_P
argument_list|(
name|class1
argument_list|)
operator|!=
name|MMX_CLASS_P
argument_list|(
name|class1
argument_list|)
operator|||
name|MAYBE_MMX_CLASS_P
argument_list|(
name|class2
argument_list|)
operator|!=
name|MMX_CLASS_P
argument_list|(
name|class2
argument_list|)
condition|)
block|{
if|if
condition|(
name|strict
condition|)
name|abort
argument_list|()
expr_stmt|;
else|else
return|return
literal|1
return|;
block|}
return|return
operator|(
name|FLOAT_CLASS_P
argument_list|(
name|class1
argument_list|)
operator|!=
name|FLOAT_CLASS_P
argument_list|(
name|class2
argument_list|)
operator|||
operator|(
operator|(
name|SSE_CLASS_P
argument_list|(
name|class1
argument_list|)
operator|!=
name|SSE_CLASS_P
argument_list|(
name|class2
argument_list|)
operator|||
name|MMX_CLASS_P
argument_list|(
name|class1
argument_list|)
operator|!=
name|MMX_CLASS_P
argument_list|(
name|class2
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|mode
operator|!=
name|SImode
operator|&&
operator|(
name|mode
operator|!=
name|DImode
operator|||
operator|!
name|TARGET_64BIT
operator|)
operator|)
operator|||
operator|(
operator|!
name|TARGET_INTER_UNIT_MOVES
operator|&&
operator|!
name|optimize_size
operator|)
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the cost of moving data from a register in class CLASS1 to    one in class CLASS2.     It is not required that the cost always equal 2 when FROM is the same as TO;    on some machines it is expensive to move between registers if they are not    general registers.  */
end_comment

begin_function
name|int
name|ix86_register_move_cost
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|enum
name|reg_class
name|class1
parameter_list|,
name|enum
name|reg_class
name|class2
parameter_list|)
block|{
comment|/* In case we require secondary memory, compute cost of the store followed      by load.  In order to avoid bad register allocation choices, we need      for this to be *at least* as high as the symmetric MEMORY_MOVE_COST.  */
if|if
condition|(
name|ix86_secondary_memory_needed
argument_list|(
name|class1
argument_list|,
name|class2
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|int
name|cost
init|=
literal|1
decl_stmt|;
name|cost
operator|+=
name|MAX
argument_list|(
name|MEMORY_MOVE_COST
argument_list|(
name|mode
argument_list|,
name|class1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|MEMORY_MOVE_COST
argument_list|(
name|mode
argument_list|,
name|class1
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|cost
operator|+=
name|MAX
argument_list|(
name|MEMORY_MOVE_COST
argument_list|(
name|mode
argument_list|,
name|class2
argument_list|,
literal|0
argument_list|)
argument_list|,
name|MEMORY_MOVE_COST
argument_list|(
name|mode
argument_list|,
name|class2
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* In case of copying from general_purpose_register we may emit multiple          stores followed by single load causing memory size mismatch stall.          Count this as arbitrarily high cost of 20.  */
if|if
condition|(
name|CLASS_MAX_NREGS
argument_list|(
name|class1
argument_list|,
name|mode
argument_list|)
operator|>
name|CLASS_MAX_NREGS
argument_list|(
name|class2
argument_list|,
name|mode
argument_list|)
condition|)
name|cost
operator|+=
literal|20
expr_stmt|;
comment|/* In the case of FP/MMX moves, the registers actually overlap, and we 	 have to switch modes in order to treat them differently.  */
if|if
condition|(
operator|(
name|MMX_CLASS_P
argument_list|(
name|class1
argument_list|)
operator|&&
name|MAYBE_FLOAT_CLASS_P
argument_list|(
name|class2
argument_list|)
operator|)
operator|||
operator|(
name|MMX_CLASS_P
argument_list|(
name|class2
argument_list|)
operator|&&
name|MAYBE_FLOAT_CLASS_P
argument_list|(
name|class1
argument_list|)
operator|)
condition|)
name|cost
operator|+=
literal|20
expr_stmt|;
return|return
name|cost
return|;
block|}
comment|/* Moves between SSE/MMX and integer unit are expensive.  */
if|if
condition|(
name|MMX_CLASS_P
argument_list|(
name|class1
argument_list|)
operator|!=
name|MMX_CLASS_P
argument_list|(
name|class2
argument_list|)
operator|||
name|SSE_CLASS_P
argument_list|(
name|class1
argument_list|)
operator|!=
name|SSE_CLASS_P
argument_list|(
name|class2
argument_list|)
condition|)
return|return
name|ix86_cost
operator|->
name|mmxsse_to_integer
return|;
if|if
condition|(
name|MAYBE_FLOAT_CLASS_P
argument_list|(
name|class1
argument_list|)
condition|)
return|return
name|ix86_cost
operator|->
name|fp_move
return|;
if|if
condition|(
name|MAYBE_SSE_CLASS_P
argument_list|(
name|class1
argument_list|)
condition|)
return|return
name|ix86_cost
operator|->
name|sse_move
return|;
if|if
condition|(
name|MAYBE_MMX_CLASS_P
argument_list|(
name|class1
argument_list|)
condition|)
return|return
name|ix86_cost
operator|->
name|mmx_move
return|;
return|return
literal|2
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if hard register REGNO can hold a value of machine-mode MODE.  */
end_comment

begin_function
name|int
name|ix86_hard_regno_mode_ok
parameter_list|(
name|int
name|regno
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
comment|/* Flags and only flags can only hold CCmode values.  */
if|if
condition|(
name|CC_REGNO_P
argument_list|(
name|regno
argument_list|)
condition|)
return|return
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_CC
return|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_CC
operator|||
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_RANDOM
operator|||
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_PARTIAL_INT
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|FP_REGNO_P
argument_list|(
name|regno
argument_list|)
condition|)
return|return
name|VALID_FP_MODE_P
argument_list|(
name|mode
argument_list|)
return|;
if|if
condition|(
name|SSE_REGNO_P
argument_list|(
name|regno
argument_list|)
condition|)
return|return
operator|(
name|TARGET_SSE
condition|?
name|VALID_SSE_REG_MODE
argument_list|(
name|mode
argument_list|)
else|:
literal|0
operator|)
return|;
if|if
condition|(
name|MMX_REGNO_P
argument_list|(
name|regno
argument_list|)
condition|)
return|return
operator|(
name|TARGET_MMX
condition|?
name|VALID_MMX_REG_MODE
argument_list|(
name|mode
argument_list|)
operator|||
name|VALID_MMX_REG_MODE_3DNOW
argument_list|(
name|mode
argument_list|)
else|:
literal|0
operator|)
return|;
comment|/* We handle both integer and floats in the general purpose registers.      In future we should be able to handle vector modes as well.  */
if|if
condition|(
operator|!
name|VALID_INT_MODE_P
argument_list|(
name|mode
argument_list|)
operator|&&
operator|!
name|VALID_FP_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Take care for QImode values - they can be in non-QI regs, but then      they do cause partial register stalls.  */
if|if
condition|(
name|regno
operator|<
literal|4
operator|||
name|mode
operator|!=
name|QImode
operator|||
name|TARGET_64BIT
condition|)
return|return
literal|1
return|;
return|return
name|reload_in_progress
operator|||
name|reload_completed
operator|||
operator|!
name|TARGET_PARTIAL_REG_STALL
return|;
block|}
end_function

begin_comment
comment|/* Return the cost of moving data of mode M between a    register and memory.  A value of 2 is the default; this cost is    relative to those in `REGISTER_MOVE_COST'.     If moving between registers and memory is more expensive than    between two registers, you should define this macro to express the    relative cost.     Model also increased moving costs of QImode registers in non    Q_REGS classes.  */
end_comment

begin_function
name|int
name|ix86_memory_move_cost
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|enum
name|reg_class
name|class
parameter_list|,
name|int
name|in
parameter_list|)
block|{
if|if
condition|(
name|FLOAT_CLASS_P
argument_list|(
name|class
argument_list|)
condition|)
block|{
name|int
name|index
decl_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|SFmode
case|:
name|index
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|DFmode
case|:
name|index
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|XFmode
case|:
name|index
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
return|return
literal|100
return|;
block|}
return|return
name|in
condition|?
name|ix86_cost
operator|->
name|fp_load
index|[
name|index
index|]
else|:
name|ix86_cost
operator|->
name|fp_store
index|[
name|index
index|]
return|;
block|}
if|if
condition|(
name|SSE_CLASS_P
argument_list|(
name|class
argument_list|)
condition|)
block|{
name|int
name|index
decl_stmt|;
switch|switch
condition|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
condition|)
block|{
case|case
literal|4
case|:
name|index
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|index
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|index
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
return|return
literal|100
return|;
block|}
return|return
name|in
condition|?
name|ix86_cost
operator|->
name|sse_load
index|[
name|index
index|]
else|:
name|ix86_cost
operator|->
name|sse_store
index|[
name|index
index|]
return|;
block|}
if|if
condition|(
name|MMX_CLASS_P
argument_list|(
name|class
argument_list|)
condition|)
block|{
name|int
name|index
decl_stmt|;
switch|switch
condition|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
condition|)
block|{
case|case
literal|4
case|:
name|index
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|index
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
return|return
literal|100
return|;
block|}
return|return
name|in
condition|?
name|ix86_cost
operator|->
name|mmx_load
index|[
name|index
index|]
else|:
name|ix86_cost
operator|->
name|mmx_store
index|[
name|index
index|]
return|;
block|}
switch|switch
condition|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
if|if
condition|(
name|in
condition|)
return|return
operator|(
name|Q_CLASS_P
argument_list|(
name|class
argument_list|)
condition|?
name|ix86_cost
operator|->
name|int_load
index|[
literal|0
index|]
else|:
name|ix86_cost
operator|->
name|movzbl_load
operator|)
return|;
else|else
return|return
operator|(
name|Q_CLASS_P
argument_list|(
name|class
argument_list|)
condition|?
name|ix86_cost
operator|->
name|int_store
index|[
literal|0
index|]
else|:
name|ix86_cost
operator|->
name|int_store
index|[
literal|0
index|]
operator|+
literal|4
operator|)
return|;
break|break;
case|case
literal|2
case|:
return|return
name|in
condition|?
name|ix86_cost
operator|->
name|int_load
index|[
literal|1
index|]
else|:
name|ix86_cost
operator|->
name|int_store
index|[
literal|1
index|]
return|;
default|default:
comment|/* Compute number of 32bit moves needed.  TFmode is moved as XFmode.  */
if|if
condition|(
name|mode
operator|==
name|TFmode
condition|)
name|mode
operator|=
name|XFmode
expr_stmt|;
return|return
operator|(
operator|(
name|in
condition|?
name|ix86_cost
operator|->
name|int_load
index|[
literal|2
index|]
else|:
name|ix86_cost
operator|->
name|int_store
index|[
literal|2
index|]
operator|)
operator|*
operator|(
operator|(
operator|(
name|int
operator|)
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Compute a (partial) cost for rtx X.  Return true if the complete    cost has been computed, and false if subexpressions should be    scanned.  In either case, *TOTAL contains the cost result.  */
end_comment

begin_function
specifier|static
name|bool
name|ix86_rtx_costs
parameter_list|(
name|rtx
name|x
parameter_list|,
name|int
name|code
parameter_list|,
name|int
name|outer_code
parameter_list|,
name|int
modifier|*
name|total
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONST_INT
case|:
case|case
name|CONST
case|:
case|case
name|LABEL_REF
case|:
case|case
name|SYMBOL_REF
case|:
if|if
condition|(
name|TARGET_64BIT
operator|&&
operator|!
name|x86_64_sign_extended_value
argument_list|(
name|x
argument_list|)
condition|)
operator|*
name|total
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|TARGET_64BIT
operator|&&
operator|!
name|x86_64_zero_extended_value
argument_list|(
name|x
argument_list|)
condition|)
operator|*
name|total
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|flag_pic
operator|&&
name|SYMBOLIC_CONST
argument_list|(
name|x
argument_list|)
operator|&&
operator|(
operator|!
name|TARGET_64BIT
operator|||
operator|(
operator|!
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|LABEL_REF
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|SYMBOL_REF
operator|||
operator|!
name|SYMBOL_REF_LOCAL_P
argument_list|(
name|x
argument_list|)
operator|)
operator|)
operator|)
condition|)
operator|*
name|total
operator|=
literal|1
expr_stmt|;
else|else
operator|*
name|total
operator|=
literal|0
expr_stmt|;
return|return
name|true
return|;
case|case
name|CONST_DOUBLE
case|:
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
operator|*
name|total
operator|=
literal|0
expr_stmt|;
else|else
switch|switch
condition|(
name|standard_80387_constant_p
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
comment|/* 0.0 */
operator|*
name|total
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
comment|/* Other constants */
operator|*
name|total
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|0
case|:
case|case
operator|-
literal|1
case|:
comment|/* Start with (MEM (SYMBOL_REF)), since that's where 	       it'll probably end up.  Add a penalty for size.  */
operator|*
name|total
operator|=
operator|(
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
operator|+
operator|(
name|flag_pic
operator|!=
literal|0
operator|&&
operator|!
name|TARGET_64BIT
operator|)
operator|+
operator|(
name|mode
operator|==
name|SFmode
condition|?
literal|0
else|:
name|mode
operator|==
name|DFmode
condition|?
literal|1
else|:
literal|2
operator|)
operator|)
expr_stmt|;
break|break;
block|}
return|return
name|true
return|;
case|case
name|ZERO_EXTEND
case|:
comment|/* The zero extensions is often completely free on x86_64, so make 	 it as cheap as possible.  */
if|if
condition|(
name|TARGET_64BIT
operator|&&
name|mode
operator|==
name|DImode
operator|&&
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SImode
condition|)
operator|*
name|total
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|TARGET_ZERO_EXTEND_WITH_AND
condition|)
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
name|ix86_cost
operator|->
name|add
argument_list|)
expr_stmt|;
else|else
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
name|ix86_cost
operator|->
name|movzx
argument_list|)
expr_stmt|;
return|return
name|false
return|;
case|case
name|SIGN_EXTEND
case|:
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
name|ix86_cost
operator|->
name|movsx
argument_list|)
expr_stmt|;
return|return
name|false
return|;
case|case
name|ASHIFT
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|DImode
operator|||
name|TARGET_64BIT
operator|)
condition|)
block|{
name|HOST_WIDE_INT
name|value
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|1
condition|)
block|{
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
name|ix86_cost
operator|->
name|add
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
operator|(
name|value
operator|==
literal|2
operator|||
name|value
operator|==
literal|3
operator|)
operator|&&
operator|!
name|TARGET_DECOMPOSE_LEA
operator|&&
name|ix86_cost
operator|->
name|lea
operator|<=
name|ix86_cost
operator|->
name|shift_const
condition|)
block|{
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
name|ix86_cost
operator|->
name|lea
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
comment|/* FALLTHRU */
case|case
name|ROTATE
case|:
case|case
name|ASHIFTRT
case|:
case|case
name|LSHIFTRT
case|:
case|case
name|ROTATERT
case|:
if|if
condition|(
operator|!
name|TARGET_64BIT
operator|&&
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|DImode
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>
literal|32
condition|)
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
name|ix86_cost
operator|->
name|shift_const
operator|+
literal|2
argument_list|)
expr_stmt|;
else|else
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
name|ix86_cost
operator|->
name|shift_const
operator|*
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|AND
condition|)
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
name|ix86_cost
operator|->
name|shift_var
operator|*
literal|2
argument_list|)
expr_stmt|;
else|else
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
name|ix86_cost
operator|->
name|shift_var
operator|*
literal|6
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
name|ix86_cost
operator|->
name|shift_const
argument_list|)
expr_stmt|;
else|else
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
name|ix86_cost
operator|->
name|shift_var
argument_list|)
expr_stmt|;
block|}
return|return
name|false
return|;
case|case
name|MULT
case|:
if|if
condition|(
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
name|ix86_cost
operator|->
name|fmul
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|value
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|nbits
decl_stmt|;
for|for
control|(
name|nbits
operator|=
literal|0
init|;
name|value
operator|!=
literal|0
condition|;
name|value
operator|>>=
literal|1
control|)
name|nbits
operator|++
expr_stmt|;
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
name|ix86_cost
operator|->
name|mult_init
index|[
name|MODE_INDEX
argument_list|(
name|mode
argument_list|)
index|]
operator|+
name|nbits
operator|*
name|ix86_cost
operator|->
name|mult_bit
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This is arbitrary */
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
name|ix86_cost
operator|->
name|mult_init
index|[
name|MODE_INDEX
argument_list|(
name|mode
argument_list|)
index|]
operator|+
literal|7
operator|*
name|ix86_cost
operator|->
name|mult_bit
argument_list|)
expr_stmt|;
block|}
return|return
name|false
return|;
case|case
name|DIV
case|:
case|case
name|UDIV
case|:
case|case
name|MOD
case|:
case|case
name|UMOD
case|:
if|if
condition|(
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
name|ix86_cost
operator|->
name|fdiv
argument_list|)
expr_stmt|;
else|else
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
name|ix86_cost
operator|->
name|divide
index|[
name|MODE_INDEX
argument_list|(
name|mode
argument_list|)
index|]
argument_list|)
expr_stmt|;
return|return
name|false
return|;
case|case
name|PLUS
case|:
if|if
condition|(
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
name|ix86_cost
operator|->
name|fadd
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|TARGET_DECOMPOSE_LEA
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|GET_MODE_BITSIZE
argument_list|(
name|Pmode
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MULT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|HOST_WIDE_INT
name|val
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|==
literal|2
operator|||
name|val
operator|==
literal|4
operator|||
name|val
operator|==
literal|8
condition|)
block|{
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
name|ix86_cost
operator|->
name|lea
argument_list|)
expr_stmt|;
operator|*
name|total
operator|+=
name|rtx_cost
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|outer_code
argument_list|)
expr_stmt|;
operator|*
name|total
operator|+=
name|rtx_cost
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|outer_code
argument_list|)
expr_stmt|;
operator|*
name|total
operator|+=
name|rtx_cost
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|outer_code
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MULT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|HOST_WIDE_INT
name|val
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|==
literal|2
operator|||
name|val
operator|==
literal|4
operator|||
name|val
operator|==
literal|8
condition|)
block|{
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
name|ix86_cost
operator|->
name|lea
argument_list|)
expr_stmt|;
operator|*
name|total
operator|+=
name|rtx_cost
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|outer_code
argument_list|)
expr_stmt|;
operator|*
name|total
operator|+=
name|rtx_cost
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|outer_code
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|)
block|{
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
name|ix86_cost
operator|->
name|lea
argument_list|)
expr_stmt|;
operator|*
name|total
operator|+=
name|rtx_cost
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|outer_code
argument_list|)
expr_stmt|;
operator|*
name|total
operator|+=
name|rtx_cost
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|outer_code
argument_list|)
expr_stmt|;
operator|*
name|total
operator|+=
name|rtx_cost
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|outer_code
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
comment|/* FALLTHRU */
case|case
name|MINUS
case|:
if|if
condition|(
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
block|{
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
name|ix86_cost
operator|->
name|fadd
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* FALLTHRU */
case|case
name|AND
case|:
case|case
name|IOR
case|:
case|case
name|XOR
case|:
if|if
condition|(
operator|!
name|TARGET_64BIT
operator|&&
name|mode
operator|==
name|DImode
condition|)
block|{
operator|*
name|total
operator|=
operator|(
name|COSTS_N_INSNS
argument_list|(
name|ix86_cost
operator|->
name|add
argument_list|)
operator|*
literal|2
operator|+
operator|(
name|rtx_cost
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|outer_code
argument_list|)
operator|<<
operator|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|DImode
operator|)
operator|)
operator|+
operator|(
name|rtx_cost
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|outer_code
argument_list|)
operator|<<
operator|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|DImode
operator|)
operator|)
operator|)
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* FALLTHRU */
case|case
name|NEG
case|:
if|if
condition|(
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
block|{
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
name|ix86_cost
operator|->
name|fchs
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* FALLTHRU */
case|case
name|NOT
case|:
if|if
condition|(
operator|!
name|TARGET_64BIT
operator|&&
name|mode
operator|==
name|DImode
condition|)
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
name|ix86_cost
operator|->
name|add
operator|*
literal|2
argument_list|)
expr_stmt|;
else|else
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
name|ix86_cost
operator|->
name|add
argument_list|)
expr_stmt|;
return|return
name|false
return|;
case|case
name|FLOAT_EXTEND
case|:
if|if
condition|(
operator|!
name|TARGET_SSE_MATH
operator|||
operator|!
name|VALID_SSE_REG_MODE
argument_list|(
name|mode
argument_list|)
condition|)
operator|*
name|total
operator|=
literal|0
expr_stmt|;
return|return
name|false
return|;
case|case
name|ABS
case|:
if|if
condition|(
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
name|ix86_cost
operator|->
name|fabs
argument_list|)
expr_stmt|;
return|return
name|false
return|;
case|case
name|SQRT
case|:
if|if
condition|(
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
name|ix86_cost
operator|->
name|fsqrt
argument_list|)
expr_stmt|;
return|return
name|false
return|;
case|case
name|UNSPEC
case|:
if|if
condition|(
name|XINT
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPEC_TP
condition|)
operator|*
name|total
operator|=
literal|0
expr_stmt|;
return|return
name|false
return|;
default|default:
return|return
name|false
return|;
block|}
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DO_GLOBAL_CTORS_BODY
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAS_INIT_SECTION
argument_list|)
end_if

begin_function
specifier|static
name|void
name|ix86_svr3_asm_out_constructor
parameter_list|(
name|rtx
name|symbol
parameter_list|,
name|int
name|priority
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|init_section
argument_list|()
expr_stmt|;
name|fputs
argument_list|(
literal|"\tpushl $"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|asm_out_file
argument_list|,
name|XSTR
argument_list|(
name|symbol
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|TARGET_MACHO
end_if

begin_decl_stmt
specifier|static
name|int
name|current_machopic_label_num
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Given a symbol name and its associated stub, write out the    definition of the stub.  */
end_comment

begin_function
name|void
name|machopic_output_stub
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
specifier|const
name|char
modifier|*
name|symb
parameter_list|,
specifier|const
name|char
modifier|*
name|stub
parameter_list|)
block|{
name|unsigned
name|int
name|length
decl_stmt|;
name|char
modifier|*
name|binder_name
decl_stmt|,
modifier|*
name|symbol_name
decl_stmt|,
name|lazy_ptr_name
index|[
literal|32
index|]
decl_stmt|;
name|int
name|label
init|=
operator|++
name|current_machopic_label_num
decl_stmt|;
comment|/* Lose our funky encoding stuff so it doesn't contaminate the stub.  */
name|symb
operator|=
call|(
modifier|*
name|targetm
operator|.
name|strip_name_encoding
call|)
argument_list|(
name|symb
argument_list|)
expr_stmt|;
name|length
operator|=
name|strlen
argument_list|(
name|stub
argument_list|)
expr_stmt|;
name|binder_name
operator|=
name|alloca
argument_list|(
name|length
operator|+
literal|32
argument_list|)
expr_stmt|;
name|GEN_BINDER_NAME_FOR_STUB
argument_list|(
name|binder_name
argument_list|,
name|stub
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|length
operator|=
name|strlen
argument_list|(
name|symb
argument_list|)
expr_stmt|;
name|symbol_name
operator|=
name|alloca
argument_list|(
name|length
operator|+
literal|32
argument_list|)
expr_stmt|;
name|GEN_SYMBOL_NAME_FOR_SYMBOL
argument_list|(
name|symbol_name
argument_list|,
name|symb
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|lazy_ptr_name
argument_list|,
literal|"L%d$lz"
argument_list|,
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
name|MACHOPIC_PURE
condition|)
name|machopic_picsymbol_stub_section
argument_list|()
expr_stmt|;
else|else
name|machopic_symbol_stub_section
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s:\n"
argument_list|,
name|stub
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.indirect_symbol %s\n"
argument_list|,
name|symbol_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|MACHOPIC_PURE
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tcall LPC$%d\nLPC$%d:\tpopl %%eax\n"
argument_list|,
name|label
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tmovl %s-LPC$%d(%%eax),%%edx\n"
argument_list|,
name|lazy_ptr_name
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tjmp %%edx\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tjmp *%s\n"
argument_list|,
name|lazy_ptr_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s:\n"
argument_list|,
name|binder_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|MACHOPIC_PURE
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tlea %s-LPC$%d(%%eax),%%eax\n"
argument_list|,
name|lazy_ptr_name
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tpushl %%eax\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t pushl $%s\n"
argument_list|,
name|lazy_ptr_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tjmp dyld_stub_binding_helper\n"
argument_list|)
expr_stmt|;
name|machopic_lazy_symbol_ptr_section
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s:\n"
argument_list|,
name|lazy_ptr_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.indirect_symbol %s\n"
argument_list|,
name|symbol_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.long %s\n"
argument_list|,
name|binder_name
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TARGET_MACHO */
end_comment

begin_comment
comment|/* Order the registers for register allocator.  */
end_comment

begin_function
name|void
name|x86_order_regs_for_local_alloc
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|pos
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* First allocate the local general purpose registers.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|GENERAL_REGNO_P
argument_list|(
name|i
argument_list|)
operator|&&
name|call_used_regs
index|[
name|i
index|]
condition|)
name|reg_alloc_order
index|[
name|pos
operator|++
index|]
operator|=
name|i
expr_stmt|;
comment|/* Global general purpose registers.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|GENERAL_REGNO_P
argument_list|(
name|i
argument_list|)
operator|&&
operator|!
name|call_used_regs
index|[
name|i
index|]
condition|)
name|reg_alloc_order
index|[
name|pos
operator|++
index|]
operator|=
name|i
expr_stmt|;
comment|/* x87 registers come first in case we are doing FP math       using them.  */
if|if
condition|(
operator|!
name|TARGET_SSE_MATH
condition|)
for|for
control|(
name|i
operator|=
name|FIRST_STACK_REG
init|;
name|i
operator|<=
name|LAST_STACK_REG
condition|;
name|i
operator|++
control|)
name|reg_alloc_order
index|[
name|pos
operator|++
index|]
operator|=
name|i
expr_stmt|;
comment|/* SSE registers.  */
for|for
control|(
name|i
operator|=
name|FIRST_SSE_REG
init|;
name|i
operator|<=
name|LAST_SSE_REG
condition|;
name|i
operator|++
control|)
name|reg_alloc_order
index|[
name|pos
operator|++
index|]
operator|=
name|i
expr_stmt|;
for|for
control|(
name|i
operator|=
name|FIRST_REX_SSE_REG
init|;
name|i
operator|<=
name|LAST_REX_SSE_REG
condition|;
name|i
operator|++
control|)
name|reg_alloc_order
index|[
name|pos
operator|++
index|]
operator|=
name|i
expr_stmt|;
comment|/* x87 registers.  */
if|if
condition|(
name|TARGET_SSE_MATH
condition|)
for|for
control|(
name|i
operator|=
name|FIRST_STACK_REG
init|;
name|i
operator|<=
name|LAST_STACK_REG
condition|;
name|i
operator|++
control|)
name|reg_alloc_order
index|[
name|pos
operator|++
index|]
operator|=
name|i
expr_stmt|;
for|for
control|(
name|i
operator|=
name|FIRST_MMX_REG
init|;
name|i
operator|<=
name|LAST_MMX_REG
condition|;
name|i
operator|++
control|)
name|reg_alloc_order
index|[
name|pos
operator|++
index|]
operator|=
name|i
expr_stmt|;
comment|/* Initialize the rest of array as we do not allocate some registers       at all.  */
while|while
condition|(
name|pos
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|reg_alloc_order
index|[
name|pos
operator|++
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|TARGET_USE_MS_BITFIELD_LAYOUT
end_ifndef

begin_define
define|#
directive|define
name|TARGET_USE_MS_BITFIELD_LAYOUT
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Handle a "ms_struct" or "gcc_struct" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|ix86_handle_struct_attribute
parameter_list|(
name|tree
modifier|*
name|node
parameter_list|,
name|tree
name|name
parameter_list|,
name|tree
name|args
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|flags
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bool
modifier|*
name|no_add_attrs
parameter_list|)
block|{
name|tree
modifier|*
name|type
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|DECL_P
argument_list|(
operator|*
name|node
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|type
operator|=
operator|&
name|TREE_TYPE
argument_list|(
operator|*
name|node
argument_list|)
expr_stmt|;
block|}
else|else
name|type
operator|=
name|node
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|type
operator|&&
operator|(
name|TREE_CODE
argument_list|(
operator|*
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
operator|*
name|type
argument_list|)
operator|==
name|UNION_TYPE
operator|)
operator|)
condition|)
block|{
name|warning
argument_list|(
literal|"`%s' attribute ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|is_attribute_p
argument_list|(
literal|"ms_struct"
argument_list|,
name|name
argument_list|)
operator|&&
name|lookup_attribute
argument_list|(
literal|"gcc_struct"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
operator|*
name|type
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|is_attribute_p
argument_list|(
literal|"gcc_struct"
argument_list|,
name|name
argument_list|)
operator|&&
name|lookup_attribute
argument_list|(
literal|"ms_struct"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
operator|*
name|type
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
block|{
name|warning
argument_list|(
literal|"`%s' incompatible attribute ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|ix86_ms_bitfield_layout_p
parameter_list|(
name|tree
name|record_type
parameter_list|)
block|{
return|return
operator|(
name|TARGET_USE_MS_BITFIELD_LAYOUT
operator|&&
operator|!
name|lookup_attribute
argument_list|(
literal|"gcc_struct"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|record_type
argument_list|)
argument_list|)
operator|)
operator|||
name|lookup_attribute
argument_list|(
literal|"ms_struct"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|record_type
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns an expression indicating where the this parameter is    located on entry to the FUNCTION.  */
end_comment

begin_function
specifier|static
name|rtx
name|x86_this_parameter
parameter_list|(
name|tree
name|function
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
decl_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
name|int
name|n
init|=
name|aggregate_value_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|type
argument_list|)
operator|!=
literal|0
decl_stmt|;
return|return
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|x86_64_int_parameter_registers
index|[
name|n
index|]
argument_list|)
return|;
block|}
if|if
condition|(
name|ix86_function_regparm
argument_list|(
name|type
argument_list|,
name|function
argument_list|)
operator|>
literal|0
condition|)
block|{
name|tree
name|parm
decl_stmt|;
name|parm
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Figure out whether or not the function has a variable number of 	 arguments.  */
for|for
control|(
init|;
name|parm
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
control|)
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
operator|==
name|void_type_node
condition|)
break|break;
comment|/* If not, the this parameter is in the first argument.  */
if|if
condition|(
name|parm
condition|)
block|{
name|int
name|regno
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"fastcall"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
name|regno
operator|=
literal|2
expr_stmt|;
return|return
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|regno
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|aggregate_value_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|type
argument_list|)
condition|)
return|return
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|stack_pointer_rtx
argument_list|,
literal|8
argument_list|)
argument_list|)
return|;
else|else
return|return
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|stack_pointer_rtx
argument_list|,
literal|4
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Determine whether x86_output_mi_thunk can succeed.  */
end_comment

begin_function
specifier|static
name|bool
name|x86_can_output_mi_thunk
parameter_list|(
name|tree
name|thunk
name|ATTRIBUTE_UNUSED
parameter_list|,
name|HOST_WIDE_INT
name|delta
name|ATTRIBUTE_UNUSED
parameter_list|,
name|HOST_WIDE_INT
name|vcall_offset
parameter_list|,
name|tree
name|function
parameter_list|)
block|{
comment|/* 64-bit can handle anything.  */
if|if
condition|(
name|TARGET_64BIT
condition|)
return|return
name|true
return|;
comment|/* For 32-bit, everything's fine if we have one free register.  */
if|if
condition|(
name|ix86_function_regparm
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|,
name|function
argument_list|)
operator|<
literal|3
condition|)
return|return
name|true
return|;
comment|/* Need a free register for vcall_offset.  */
if|if
condition|(
name|vcall_offset
condition|)
return|return
name|false
return|;
comment|/* Need a free register for GOT references.  */
if|if
condition|(
name|flag_pic
operator|&&
operator|!
call|(
modifier|*
name|targetm
operator|.
name|binds_local_p
call|)
argument_list|(
name|function
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Otherwise ok.  */
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Output the assembler code for a thunk function.  THUNK_DECL is the    declaration for the thunk function itself, FUNCTION is the decl for    the target function.  DELTA is an immediate constant offset to be    added to THIS.  If VCALL_OFFSET is nonzero, the word at    *(*this + vcall_offset) should be added to THIS.  */
end_comment

begin_function
specifier|static
name|void
name|x86_output_mi_thunk
parameter_list|(
name|FILE
modifier|*
name|file
name|ATTRIBUTE_UNUSED
parameter_list|,
name|tree
name|thunk
name|ATTRIBUTE_UNUSED
parameter_list|,
name|HOST_WIDE_INT
name|delta
parameter_list|,
name|HOST_WIDE_INT
name|vcall_offset
parameter_list|,
name|tree
name|function
parameter_list|)
block|{
name|rtx
name|xops
index|[
literal|3
index|]
decl_stmt|;
name|rtx
name|this
init|=
name|x86_this_parameter
argument_list|(
name|function
argument_list|)
decl_stmt|;
name|rtx
name|this_reg
decl_stmt|,
name|tmp
decl_stmt|;
comment|/* If VCALL_OFFSET, we'll need THIS in a register.  Might as well      pull it in now and let DELTA benefit.  */
if|if
condition|(
name|REG_P
argument_list|(
name|this
argument_list|)
condition|)
name|this_reg
operator|=
name|this
expr_stmt|;
elseif|else
if|if
condition|(
name|vcall_offset
condition|)
block|{
comment|/* Put the this parameter into %eax.  */
name|xops
index|[
literal|0
index|]
operator|=
name|this
expr_stmt|;
name|xops
index|[
literal|1
index|]
operator|=
name|this_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"mov{l}\t{%0, %1|%1, %0}"
argument_list|,
name|xops
argument_list|)
expr_stmt|;
block|}
else|else
name|this_reg
operator|=
name|NULL_RTX
expr_stmt|;
comment|/* Adjust the this parameter by a fixed constant.  */
if|if
condition|(
name|delta
condition|)
block|{
name|xops
index|[
literal|0
index|]
operator|=
name|GEN_INT
argument_list|(
name|delta
argument_list|)
expr_stmt|;
name|xops
index|[
literal|1
index|]
operator|=
name|this_reg
condition|?
name|this_reg
else|:
name|this
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
if|if
condition|(
operator|!
name|x86_64_general_operand
argument_list|(
name|xops
index|[
literal|0
index|]
argument_list|,
name|DImode
argument_list|)
condition|)
block|{
name|tmp
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|FIRST_REX_INT_REG
operator|+
literal|2
comment|/* R10 */
argument_list|)
expr_stmt|;
name|xops
index|[
literal|1
index|]
operator|=
name|tmp
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"mov{q}\t{%1, %0|%0, %1}"
argument_list|,
name|xops
argument_list|)
expr_stmt|;
name|xops
index|[
literal|0
index|]
operator|=
name|tmp
expr_stmt|;
name|xops
index|[
literal|1
index|]
operator|=
name|this
expr_stmt|;
block|}
name|output_asm_insn
argument_list|(
literal|"add{q}\t{%0, %1|%1, %0}"
argument_list|,
name|xops
argument_list|)
expr_stmt|;
block|}
else|else
name|output_asm_insn
argument_list|(
literal|"add{l}\t{%0, %1|%1, %0}"
argument_list|,
name|xops
argument_list|)
expr_stmt|;
block|}
comment|/* Adjust the this parameter by a value stored in the vtable.  */
if|if
condition|(
name|vcall_offset
condition|)
block|{
if|if
condition|(
name|TARGET_64BIT
condition|)
name|tmp
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|FIRST_REX_INT_REG
operator|+
literal|2
comment|/* R10 */
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|tmp_regno
init|=
literal|2
comment|/* ECX */
decl_stmt|;
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"fastcall"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
argument_list|)
condition|)
name|tmp_regno
operator|=
literal|0
comment|/* EAX */
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|tmp_regno
argument_list|)
expr_stmt|;
block|}
name|xops
index|[
literal|0
index|]
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|this_reg
argument_list|)
expr_stmt|;
name|xops
index|[
literal|1
index|]
operator|=
name|tmp
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
name|output_asm_insn
argument_list|(
literal|"mov{q}\t{%0, %1|%1, %0}"
argument_list|,
name|xops
argument_list|)
expr_stmt|;
else|else
name|output_asm_insn
argument_list|(
literal|"mov{l}\t{%0, %1|%1, %0}"
argument_list|,
name|xops
argument_list|)
expr_stmt|;
comment|/* Adjust the this parameter.  */
name|xops
index|[
literal|0
index|]
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|plus_constant
argument_list|(
name|tmp
argument_list|,
name|vcall_offset
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
operator|&&
operator|!
name|memory_operand
argument_list|(
name|xops
index|[
literal|0
index|]
argument_list|,
name|Pmode
argument_list|)
condition|)
block|{
name|rtx
name|tmp2
init|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|FIRST_REX_INT_REG
operator|+
literal|3
comment|/* R11 */
argument_list|)
decl_stmt|;
name|xops
index|[
literal|0
index|]
operator|=
name|GEN_INT
argument_list|(
name|vcall_offset
argument_list|)
expr_stmt|;
name|xops
index|[
literal|1
index|]
operator|=
name|tmp2
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"mov{q}\t{%0, %1|%1, %0}"
argument_list|,
name|xops
argument_list|)
expr_stmt|;
name|xops
index|[
literal|0
index|]
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|tmp
argument_list|,
name|tmp2
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|xops
index|[
literal|1
index|]
operator|=
name|this_reg
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
name|output_asm_insn
argument_list|(
literal|"add{q}\t{%0, %1|%1, %0}"
argument_list|,
name|xops
argument_list|)
expr_stmt|;
else|else
name|output_asm_insn
argument_list|(
literal|"add{l}\t{%0, %1|%1, %0}"
argument_list|,
name|xops
argument_list|)
expr_stmt|;
block|}
comment|/* If necessary, drop THIS back to its stack slot.  */
if|if
condition|(
name|this_reg
operator|&&
name|this_reg
operator|!=
name|this
condition|)
block|{
name|xops
index|[
literal|0
index|]
operator|=
name|this_reg
expr_stmt|;
name|xops
index|[
literal|1
index|]
operator|=
name|this
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"mov{l}\t{%0, %1|%1, %0}"
argument_list|,
name|xops
argument_list|)
expr_stmt|;
block|}
name|xops
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|function
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_64BIT
condition|)
block|{
if|if
condition|(
operator|!
name|flag_pic
operator|||
call|(
modifier|*
name|targetm
operator|.
name|binds_local_p
call|)
argument_list|(
name|function
argument_list|)
condition|)
name|output_asm_insn
argument_list|(
literal|"jmp\t%P0"
argument_list|,
name|xops
argument_list|)
expr_stmt|;
else|else
block|{
name|tmp
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|xops
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|UNSPEC_GOTPCREL
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_MEM
argument_list|(
name|QImode
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|xops
index|[
literal|0
index|]
operator|=
name|tmp
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"jmp\t%A0"
argument_list|,
name|xops
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|flag_pic
operator|||
call|(
modifier|*
name|targetm
operator|.
name|binds_local_p
call|)
argument_list|(
name|function
argument_list|)
condition|)
name|output_asm_insn
argument_list|(
literal|"jmp\t%P0"
argument_list|,
name|xops
argument_list|)
expr_stmt|;
elseif|else
if|#
directive|if
name|TARGET_MACHO
if|if
condition|(
name|TARGET_MACHO
condition|)
block|{
specifier|const
name|char
modifier|*
name|ip
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|function
argument_list|)
argument_list|)
decl_stmt|;
name|tmp
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|machopic_stub_name
argument_list|(
name|ip
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_MEM
argument_list|(
name|QImode
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|xops
index|[
literal|0
index|]
operator|=
name|tmp
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"jmp\t%0"
argument_list|,
name|xops
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* TARGET_MACHO */
block|{
name|tmp
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
literal|2
comment|/* ECX */
argument_list|)
expr_stmt|;
name|output_set_got
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|xops
index|[
literal|1
index|]
operator|=
name|tmp
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"mov{l}\t{%0@GOT(%1), %1|%1, %0@GOT[%1]}"
argument_list|,
name|xops
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"jmp\t{*}%1"
argument_list|,
name|xops
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|x86_file_start
parameter_list|(
name|void
parameter_list|)
block|{
name|default_file_start
argument_list|()
expr_stmt|;
if|if
condition|(
name|X86_FILE_START_VERSION_DIRECTIVE
condition|)
name|fputs
argument_list|(
literal|"\t.version\t\"01.01\"\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|X86_FILE_START_FLTUSED
condition|)
name|fputs
argument_list|(
literal|"\t.global\t__fltused\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|ix86_asm_dialect
operator|==
name|ASM_INTEL
condition|)
name|fputs
argument_list|(
literal|"\t.intel_syntax\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|x86_field_alignment
parameter_list|(
name|tree
name|field
parameter_list|,
name|int
name|computed
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|TARGET_64BIT
operator|||
name|TARGET_ALIGN_DOUBLE
condition|)
return|return
name|computed
return|;
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|?
name|get_inner_array_type
argument_list|(
name|type
argument_list|)
else|:
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|DFmode
operator|||
name|mode
operator|==
name|DCmode
operator|||
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|||
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_COMPLEX_INT
condition|)
return|return
name|MIN
argument_list|(
literal|32
argument_list|,
name|computed
argument_list|)
return|;
return|return
name|computed
return|;
block|}
end_function

begin_comment
comment|/* Output assembler code to FILE to increment profiler label # LABELNO    for profiling a function entry.  */
end_comment

begin_function
name|void
name|x86_function_profiler
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|int
name|labelno
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|TARGET_64BIT
condition|)
if|if
condition|(
name|flag_pic
condition|)
block|{
ifndef|#
directive|ifndef
name|NO_PROFILE_COUNTERS
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tleaq\t%sP%d@(%%rip),%%r11\n"
argument_list|,
name|LPREFIX
argument_list|,
name|labelno
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tcall\t*%s@GOTPCREL(%%rip)\n"
argument_list|,
name|MCOUNT_NAME
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifndef|#
directive|ifndef
name|NO_PROFILE_COUNTERS
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tmovq\t$%sP%d,%%r11\n"
argument_list|,
name|LPREFIX
argument_list|,
name|labelno
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tcall\t%s\n"
argument_list|,
name|MCOUNT_NAME
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flag_pic
condition|)
block|{
ifndef|#
directive|ifndef
name|NO_PROFILE_COUNTERS
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tleal\t%sP%d@GOTOFF(%%ebx),%%%s\n"
argument_list|,
name|LPREFIX
argument_list|,
name|labelno
argument_list|,
name|PROFILE_COUNT_REGISTER
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tcall\t*%s@GOT(%%ebx)\n"
argument_list|,
name|MCOUNT_NAME
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifndef|#
directive|ifndef
name|NO_PROFILE_COUNTERS
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tmovl\t$%sP%d,%%%s\n"
argument_list|,
name|LPREFIX
argument_list|,
name|labelno
argument_list|,
name|PROFILE_COUNT_REGISTER
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tcall\t%s\n"
argument_list|,
name|MCOUNT_NAME
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* We don't have exact information about the insn sizes, but we may assume    quite safely that we are informed about all 1 byte insns and memory    address sizes.  This is enough to eliminate unnecessary padding in    99% of cases.  */
end_comment

begin_function
specifier|static
name|int
name|min_insn_size
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|int
name|l
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|||
operator|!
name|active_insn_p
argument_list|(
name|insn
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Discard alignments we've emit and jump instructions.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|UNSPEC_VOLATILE
operator|&&
name|XINT
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPECV_ALIGN
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ADDR_VEC
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
operator|)
condition|)
return|return
literal|0
return|;
comment|/* Important case - calls are always 5 bytes.      It is common to have many calls in the row.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|&&
name|symbolic_reference_mentioned_p
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|&&
operator|!
name|SIBLING_CALL_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return
literal|5
return|;
if|if
condition|(
name|get_attr_length
argument_list|(
name|insn
argument_list|)
operator|<=
literal|1
condition|)
return|return
literal|1
return|;
comment|/* For normal instructions we may rely on the sizes of addresses      and the presence of symbol to require 4 bytes of encoding.      This is not the case for jumps where references are PC relative.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|JUMP_INSN
condition|)
block|{
name|l
operator|=
name|get_attr_length_address
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|<
literal|4
operator|&&
name|symbolic_reference_mentioned_p
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
name|l
operator|=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|l
condition|)
return|return
literal|1
operator|+
name|l
return|;
else|else
return|return
literal|2
return|;
block|}
end_function

begin_comment
comment|/* AMD K8 core mispredicts jumps when there are more than 3 jumps in 16 byte    window.  */
end_comment

begin_function
specifier|static
name|void
name|k8_avoid_jump_misspredicts
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|,
name|start
init|=
name|get_insns
argument_list|()
decl_stmt|;
name|int
name|nbytes
init|=
literal|0
decl_stmt|,
name|njumps
init|=
literal|0
decl_stmt|;
name|int
name|isjump
init|=
literal|0
decl_stmt|;
comment|/* Look for all minimal intervals of instructions containing 4 jumps.      The intervals are bounded by START and INSN.  NBYTES is the total      size of instructions in the interval including INSN and not including      START.  When the NBYTES is smaller than 16 bytes, it is possible      that the end of START and INSN ends up in the same 16byte page.       The smallest offset in the page INSN can start is the case where START      ends on the offset 0.  Offset of INSN is then NBYTES - sizeof (INSN).      We add p2align to 16byte window with maxskip 17 - NBYTES + sizeof (INSN).      */
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|nbytes
operator|+=
name|min_insn_size
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Insn %i estimated to %i bytes\n"
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|,
name|min_insn_size
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|ADDR_VEC
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|ADDR_DIFF_VEC
operator|)
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
name|njumps
operator|++
expr_stmt|;
else|else
continue|continue;
while|while
condition|(
name|njumps
operator|>
literal|3
condition|)
block|{
name|start
operator|=
name|NEXT_INSN
argument_list|(
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|start
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|start
argument_list|)
argument_list|)
operator|!=
name|ADDR_VEC
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|start
argument_list|)
argument_list|)
operator|!=
name|ADDR_DIFF_VEC
operator|)
operator|||
name|GET_CODE
argument_list|(
name|start
argument_list|)
operator|==
name|CALL_INSN
condition|)
name|njumps
operator|--
operator|,
name|isjump
operator|=
literal|1
expr_stmt|;
else|else
name|isjump
operator|=
literal|0
expr_stmt|;
name|nbytes
operator|-=
name|min_insn_size
argument_list|(
name|start
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|njumps
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Interval %i to %i has %i bytes\n"
argument_list|,
name|INSN_UID
argument_list|(
name|start
argument_list|)
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|njumps
operator|==
literal|3
operator|&&
name|isjump
operator|&&
name|nbytes
operator|<
literal|16
condition|)
block|{
name|int
name|padsize
init|=
literal|15
operator|-
name|nbytes
operator|+
name|min_insn_size
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Padding insn %i by %i bytes!\n"
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|,
name|padsize
argument_list|)
expr_stmt|;
name|emit_insn_before
argument_list|(
name|gen_align
argument_list|(
name|GEN_INT
argument_list|(
name|padsize
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Implement machine specific optimizations.    At the moment we implement single transformation: AMD Athlon works faster    when RET is not destination of conditional jump or directly preceded    by other jump instruction.  We avoid the penalty by inserting NOP just    before the RET instructions in such cases.  */
end_comment

begin_function
specifier|static
name|void
name|ix86_reorg
parameter_list|(
name|void
parameter_list|)
block|{
name|edge
name|e
decl_stmt|;
if|if
condition|(
operator|!
name|TARGET_ATHLON_K8
operator|||
operator|!
name|optimize
operator|||
name|optimize_size
condition|)
return|return;
for|for
control|(
name|e
operator|=
name|EXIT_BLOCK_PTR
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
block|{
name|basic_block
name|bb
init|=
name|e
operator|->
name|src
decl_stmt|;
name|rtx
name|ret
init|=
name|BB_END
argument_list|(
name|bb
argument_list|)
decl_stmt|;
name|rtx
name|prev
decl_stmt|;
name|bool
name|replace
init|=
name|false
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|ret
argument_list|)
operator|!=
name|JUMP_INSN
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|ret
argument_list|)
argument_list|)
operator|!=
name|RETURN
operator|||
operator|!
name|maybe_hot_bb_p
argument_list|(
name|bb
argument_list|)
condition|)
continue|continue;
for|for
control|(
name|prev
operator|=
name|PREV_INSN
argument_list|(
name|ret
argument_list|)
init|;
name|prev
condition|;
name|prev
operator|=
name|PREV_INSN
argument_list|(
name|prev
argument_list|)
control|)
if|if
condition|(
name|active_insn_p
argument_list|(
name|prev
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|prev
argument_list|)
operator|==
name|CODE_LABEL
condition|)
break|break;
if|if
condition|(
name|prev
operator|&&
name|GET_CODE
argument_list|(
name|prev
argument_list|)
operator|==
name|CODE_LABEL
condition|)
block|{
name|edge
name|e
decl_stmt|;
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
if|if
condition|(
name|EDGE_FREQUENCY
argument_list|(
name|e
argument_list|)
operator|&&
name|e
operator|->
name|src
operator|->
name|index
operator|>=
literal|0
operator|&&
operator|!
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
operator|)
condition|)
name|replace
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|replace
condition|)
block|{
name|prev
operator|=
name|prev_active_insn
argument_list|(
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|prev
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|any_condjump_p
argument_list|(
name|prev
argument_list|)
operator|)
operator|||
name|GET_CODE
argument_list|(
name|prev
argument_list|)
operator|==
name|CALL_INSN
operator|)
condition|)
name|replace
operator|=
name|true
expr_stmt|;
comment|/* Empty functions get branch mispredict even when the jump destination 	   is not visible to us.  */
if|if
condition|(
operator|!
name|prev
operator|&&
name|cfun
operator|->
name|function_frequency
operator|>
name|FUNCTION_FREQUENCY_UNLIKELY_EXECUTED
condition|)
name|replace
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|replace
condition|)
block|{
name|emit_insn_before
argument_list|(
name|gen_return_internal_long
argument_list|()
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|ret
argument_list|)
expr_stmt|;
block|}
block|}
name|k8_avoid_jump_misspredicts
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return nonzero when QImode register that must be represented via REX prefix    is used.  */
end_comment

begin_function
name|bool
name|x86_extended_QIreg_mentioned_p
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|extract_insn_cached
argument_list|(
name|insn
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|recog_data
operator|.
name|n_operands
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|REG_P
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|i
index|]
argument_list|)
operator|>=
literal|4
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero when P points to register encoded via REX prefix.    Called via for_each_rtx.  */
end_comment

begin_function
specifier|static
name|int
name|extended_reg_mentioned_1
parameter_list|(
name|rtx
modifier|*
name|p
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|unsigned
name|int
name|regno
decl_stmt|;
if|if
condition|(
operator|!
name|REG_P
argument_list|(
operator|*
name|p
argument_list|)
condition|)
return|return
literal|0
return|;
name|regno
operator|=
name|REGNO
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
return|return
name|REX_INT_REGNO_P
argument_list|(
name|regno
argument_list|)
operator|||
name|REX_SSE_REGNO_P
argument_list|(
name|regno
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true when INSN mentions register that must be encoded using REX    prefix.  */
end_comment

begin_function
name|bool
name|x86_extended_reg_mentioned_p
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
return|return
name|for_each_rtx
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|extended_reg_mentioned_1
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Generate an unsigned DImode/SImode to FP conversion.  This is the same code    optabs would emit if we didn't have TFmode patterns.  */
end_comment

begin_function
name|void
name|x86_emit_floatuns
parameter_list|(
name|rtx
name|operands
index|[
literal|2
index|]
parameter_list|)
block|{
name|rtx
name|neglab
decl_stmt|,
name|donelab
decl_stmt|,
name|i0
decl_stmt|,
name|i1
decl_stmt|,
name|f0
decl_stmt|,
name|in
decl_stmt|,
name|out
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|,
name|inmode
decl_stmt|;
name|inmode
operator|=
name|GET_MODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|inmode
operator|!=
name|SImode
operator|&&
name|inmode
operator|!=
name|DImode
condition|)
name|abort
argument_list|()
expr_stmt|;
name|out
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
name|in
operator|=
name|force_reg
argument_list|(
name|inmode
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|neglab
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|donelab
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|i1
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|f0
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|in
argument_list|,
name|const0_rtx
argument_list|,
name|LT
argument_list|,
name|const0_rtx
argument_list|,
name|Pmode
argument_list|,
literal|0
argument_list|,
name|neglab
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|out
argument_list|,
name|gen_rtx_FLOAT
argument_list|(
name|mode
argument_list|,
name|in
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_jump
argument_list|(
name|donelab
argument_list|)
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|neglab
argument_list|)
expr_stmt|;
name|i0
operator|=
name|expand_simple_binop
argument_list|(
name|Pmode
argument_list|,
name|LSHIFTRT
argument_list|,
name|in
argument_list|,
name|const1_rtx
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
name|i1
operator|=
name|expand_simple_binop
argument_list|(
name|Pmode
argument_list|,
name|AND
argument_list|,
name|in
argument_list|,
name|const1_rtx
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
name|i0
operator|=
name|expand_simple_binop
argument_list|(
name|Pmode
argument_list|,
name|IOR
argument_list|,
name|i0
argument_list|,
name|i1
argument_list|,
name|i0
argument_list|,
literal|1
argument_list|,
name|OPTAB_DIRECT
argument_list|)
expr_stmt|;
name|expand_float
argument_list|(
name|f0
argument_list|,
name|i0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|out
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|mode
argument_list|,
name|f0
argument_list|,
name|f0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|donelab
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return if we do not know how to pass TYPE solely in registers.  */
end_comment

begin_function
name|bool
name|ix86_must_pass_in_stack
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
if|if
condition|(
name|default_must_pass_in_stack
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
condition|)
return|return
name|true
return|;
return|return
operator|(
operator|!
name|TARGET_64BIT
operator|&&
name|type
operator|&&
name|mode
operator|==
name|TImode
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Initialize vector TARGET via VALS.  */
end_comment

begin_function
name|void
name|ix86_expand_vector_init
parameter_list|(
name|rtx
name|target
parameter_list|,
name|rtx
name|vals
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|target
argument_list|)
decl_stmt|;
name|int
name|elt_size
init|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE_INNER
argument_list|(
name|mode
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|n_elts
init|=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|/
name|elt_size
operator|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|n_elts
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|vals
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|vals
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|!=
name|CONST_DOUBLE
condition|)
break|break;
comment|/* Few special cases first...        ... constants are best loaded from constant pool.  */
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|gen_rtx_CONST_VECTOR
argument_list|(
name|mode
argument_list|,
name|XVEC
argument_list|(
name|vals
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* ... values where only first field is non-constant are best loaded      from the pool and overwriten via move later.  */
if|if
condition|(
operator|!
name|i
condition|)
block|{
name|rtx
name|op
init|=
name|simplify_gen_subreg
argument_list|(
name|mode
argument_list|,
name|XVECEXP
argument_list|(
name|vals
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_MODE_INNER
argument_list|(
name|mode
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|op
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|XVECEXP
argument_list|(
name|vals
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|=
name|CONST0_RTX
argument_list|(
name|GET_MODE_INNER
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|gen_rtx_CONST_VECTOR
argument_list|(
name|mode
argument_list|,
name|XVEC
argument_list|(
name|vals
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
condition|)
block|{
case|case
name|V2DFmode
case|:
name|emit_insn
argument_list|(
name|gen_sse2_movsd
argument_list|(
name|target
argument_list|,
name|target
argument_list|,
name|op
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|V4SFmode
case|:
name|emit_insn
argument_list|(
name|gen_sse_movss
argument_list|(
name|target
argument_list|,
name|target
argument_list|,
name|op
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return;
block|}
comment|/* And the busy sequence doing rotations.  */
switch|switch
condition|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
condition|)
block|{
case|case
name|V2DFmode
case|:
block|{
name|rtx
name|vecop0
init|=
name|simplify_gen_subreg
argument_list|(
name|V2DFmode
argument_list|,
name|XVECEXP
argument_list|(
name|vals
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|DFmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|vecop1
init|=
name|simplify_gen_subreg
argument_list|(
name|V2DFmode
argument_list|,
name|XVECEXP
argument_list|(
name|vals
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|DFmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|vecop0
operator|=
name|force_reg
argument_list|(
name|V2DFmode
argument_list|,
name|vecop0
argument_list|)
expr_stmt|;
name|vecop1
operator|=
name|force_reg
argument_list|(
name|V2DFmode
argument_list|,
name|vecop1
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_sse2_unpcklpd
argument_list|(
name|target
argument_list|,
name|vecop0
argument_list|,
name|vecop1
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|V4SFmode
case|:
block|{
name|rtx
name|vecop0
init|=
name|simplify_gen_subreg
argument_list|(
name|V4SFmode
argument_list|,
name|XVECEXP
argument_list|(
name|vals
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|SFmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|vecop1
init|=
name|simplify_gen_subreg
argument_list|(
name|V4SFmode
argument_list|,
name|XVECEXP
argument_list|(
name|vals
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|SFmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|vecop2
init|=
name|simplify_gen_subreg
argument_list|(
name|V4SFmode
argument_list|,
name|XVECEXP
argument_list|(
name|vals
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
argument_list|,
name|SFmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|vecop3
init|=
name|simplify_gen_subreg
argument_list|(
name|V4SFmode
argument_list|,
name|XVECEXP
argument_list|(
name|vals
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
argument_list|,
name|SFmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|tmp1
init|=
name|gen_reg_rtx
argument_list|(
name|V4SFmode
argument_list|)
decl_stmt|;
name|rtx
name|tmp2
init|=
name|gen_reg_rtx
argument_list|(
name|V4SFmode
argument_list|)
decl_stmt|;
name|vecop0
operator|=
name|force_reg
argument_list|(
name|V4SFmode
argument_list|,
name|vecop0
argument_list|)
expr_stmt|;
name|vecop1
operator|=
name|force_reg
argument_list|(
name|V4SFmode
argument_list|,
name|vecop1
argument_list|)
expr_stmt|;
name|vecop2
operator|=
name|force_reg
argument_list|(
name|V4SFmode
argument_list|,
name|vecop2
argument_list|)
expr_stmt|;
name|vecop3
operator|=
name|force_reg
argument_list|(
name|V4SFmode
argument_list|,
name|vecop3
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_sse_unpcklps
argument_list|(
name|tmp1
argument_list|,
name|vecop1
argument_list|,
name|vecop3
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_sse_unpcklps
argument_list|(
name|tmp2
argument_list|,
name|vecop0
argument_list|,
name|vecop2
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_sse_unpcklps
argument_list|(
name|target
argument_list|,
name|tmp2
argument_list|,
name|tmp1
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_include
include|#
directive|include
file|"gt-i386.h"
end_include

end_unit

