begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Subroutines for insn-output.c for Intel X86.    Copyright (C) 1988, 1992, 1994, 1995 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"conditions.h"
end_include

begin_include
include|#
directive|include
file|"insn-flags.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|EXTRA_CONSTRAINT
end_ifdef

begin_comment
comment|/* If EXTRA_CONSTRAINT is defined, then the 'S'    constraint in REG_CLASS_FROM_LETTER will no longer work, and various    asm statements that need 'S' for class SIREG will break.  */
end_comment

begin_decl_stmt
name|error
name|EXTRA_CONSTRAINT
name|conflicts
name|with
name|S
name|constraint
name|letter
comment|/* The previous line used to be #error, but some compilers barf    even if the conditional was untrue.  */
endif|#
directive|endif
define|#
directive|define
name|AT_BP
parameter_list|(
name|mode
parameter_list|)
value|(gen_rtx (MEM, (mode), frame_pointer_rtx))
specifier|extern
name|FILE
modifier|*
name|asm_out_file
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|char
modifier|*
name|strcat
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|singlemove_string
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|output_move_const_single
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|output_fp_cc0_set
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|char
modifier|*
name|hi_reg_name
index|[]
init|=
name|HI_REGISTER_NAMES
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|qi_reg_name
index|[]
init|=
name|QI_REGISTER_NAMES
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|qi_high_reg_name
index|[]
init|=
name|QI_HIGH_REGISTER_NAMES
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Array of the smallest class containing reg number REGNO, indexed by    REGNO.  Used by REGNO_REG_CLASS in i386.h. */
end_comment

begin_decl_stmt
name|enum
name|reg_class
name|regclass_map
index|[
name|FIRST_PSEUDO_REGISTER
index|]
init|=
block|{
comment|/* ax, dx, cx, bx */
name|AREG
block|,
name|DREG
block|,
name|CREG
block|,
name|BREG
block|,
comment|/* si, di, bp, sp */
name|SIREG
block|,
name|DIREG
block|,
name|INDEX_REGS
block|,
name|GENERAL_REGS
block|,
comment|/* FP registers */
name|FP_TOP_REG
block|,
name|FP_SECOND_REG
block|,
name|FLOAT_REGS
block|,
name|FLOAT_REGS
block|,
name|FLOAT_REGS
block|,
name|FLOAT_REGS
block|,
name|FLOAT_REGS
block|,
name|FLOAT_REGS
block|,
comment|/* arg pointer */
name|INDEX_REGS
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Test and compare insns in i386.md store the information needed to    generate branch and scc insns here.  */
end_comment

begin_decl_stmt
name|struct
name|rtx_def
modifier|*
name|i386_compare_op0
init|=
name|NULL_RTX
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rtx_def
modifier|*
name|i386_compare_op1
init|=
name|NULL_RTX
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rtx_def
modifier|*
argument_list|(
operator|*
name|i386_compare_gen
argument_list|)
argument_list|()
decl_stmt|,
modifier|*
argument_list|(
operator|*
name|i386_compare_gen_eq
argument_list|)
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Register allocation order */
end_comment

begin_decl_stmt
name|char
modifier|*
name|i386_reg_alloc_order
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|regs_allocated
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # of registers to use to pass arguments. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|i386_regparm_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # registers to use to pass args */
end_comment

begin_decl_stmt
name|int
name|i386_regparm
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* i386_regparm_string as a number */
end_comment

begin_comment
comment|/* Alignment to use for loops and jumps */
end_comment

begin_decl_stmt
name|char
modifier|*
name|i386_align_loops_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* power of two alignment for loops */
end_comment

begin_decl_stmt
name|char
modifier|*
name|i386_align_jumps_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* power of two alignment for non-loop jumps */
end_comment

begin_decl_stmt
name|char
modifier|*
name|i386_align_funcs_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* power of two alignment for functions */
end_comment

begin_decl_stmt
name|int
name|i386_align_loops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* power of two alignment for loops */
end_comment

begin_decl_stmt
name|int
name|i386_align_jumps
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* power of two alignment for non-loop jumps */
end_comment

begin_decl_stmt
name|int
name|i386_align_funcs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* power of two alignment for functions */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Sometimes certain combinations of command options do not make    sense on a particular target machine.  You can define a macro    `OVERRIDE_OPTIONS' to take account of this.  This macro, if    defined, is executed once just after all the command options have    been parsed.     Don't use this macro to turn on various extra optimizations for    `-O'.  That is what `OPTIMIZATION_OPTIONS' is for.  */
end_comment

begin_function
name|void
name|override_options
parameter_list|()
block|{
name|int
name|ch
decl_stmt|,
name|i
decl_stmt|,
name|regno
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|def_align
decl_stmt|;
ifdef|#
directive|ifdef
name|SUBTARGET_OVERRIDE_OPTIONS
name|SUBTARGET_OVERRIDE_OPTIONS
expr_stmt|;
endif|#
directive|endif
comment|/* Validate registers in register allocation order */
if|if
condition|(
name|i386_reg_alloc_order
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|ch
operator|=
name|i386_reg_alloc_order
index|[
name|i
index|]
operator|)
operator|!=
literal|'\0'
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'a'
case|:
name|regno
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|regno
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|regno
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|regno
operator|=
literal|3
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|regno
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|regno
operator|=
literal|5
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
name|regno
operator|=
literal|6
expr_stmt|;
break|break;
default|default:
name|fatal
argument_list|(
literal|"Register '%c' is unknown"
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|regs_allocated
index|[
name|regno
index|]
condition|)
name|fatal
argument_list|(
literal|"Register '%c' was already specified in the allocation order"
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|regs_allocated
index|[
name|regno
index|]
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Validate -mregparm= value */
if|if
condition|(
name|i386_regparm_string
condition|)
block|{
name|i386_regparm
operator|=
name|atoi
argument_list|(
name|i386_regparm_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|i386_regparm
operator|<
literal|0
operator|||
name|i386_regparm
operator|>
name|REGPARM_MAX
condition|)
name|fatal
argument_list|(
literal|"-mregparm=%d is not between 0 and %d"
argument_list|,
name|i386_regparm
argument_list|,
name|REGPARM_MAX
argument_list|)
expr_stmt|;
block|}
name|def_align
operator|=
operator|(
name|TARGET_386
operator|)
condition|?
literal|2
else|:
literal|4
expr_stmt|;
comment|/* Validate -malign-loops= value, or provide default */
if|if
condition|(
name|i386_align_loops_string
condition|)
block|{
name|i386_align_loops
operator|=
name|atoi
argument_list|(
name|i386_align_loops_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|i386_align_loops
operator|<
literal|0
operator|||
name|i386_align_loops
operator|>
name|MAX_CODE_ALIGN
condition|)
name|fatal
argument_list|(
literal|"-malign-loops=%d is not between 0 and %d"
argument_list|,
name|i386_align_loops
argument_list|,
name|MAX_CODE_ALIGN
argument_list|)
expr_stmt|;
block|}
else|else
name|i386_align_loops
operator|=
literal|2
expr_stmt|;
comment|/* Validate -malign-jumps= value, or provide default */
if|if
condition|(
name|i386_align_jumps_string
condition|)
block|{
name|i386_align_jumps
operator|=
name|atoi
argument_list|(
name|i386_align_jumps_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|i386_align_jumps
operator|<
literal|0
operator|||
name|i386_align_jumps
operator|>
name|MAX_CODE_ALIGN
condition|)
name|fatal
argument_list|(
literal|"-malign-jumps=%d is not between 0 and %d"
argument_list|,
name|i386_align_jumps
argument_list|,
name|MAX_CODE_ALIGN
argument_list|)
expr_stmt|;
block|}
else|else
name|i386_align_jumps
operator|=
name|def_align
expr_stmt|;
comment|/* Validate -malign-functions= value, or provide default */
if|if
condition|(
name|i386_align_funcs_string
condition|)
block|{
name|i386_align_funcs
operator|=
name|atoi
argument_list|(
name|i386_align_funcs_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|i386_align_funcs
operator|<
literal|0
operator|||
name|i386_align_funcs
operator|>
name|MAX_CODE_ALIGN
condition|)
name|fatal
argument_list|(
literal|"-malign-functions=%d is not between 0 and %d"
argument_list|,
name|i386_align_funcs
argument_list|,
name|MAX_CODE_ALIGN
argument_list|)
expr_stmt|;
block|}
else|else
name|i386_align_funcs
operator|=
name|def_align
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A C statement (sans semicolon) to choose the order in which to    allocate hard registers for pseudo-registers local to a basic    block.     Store the desired register order in the array `reg_alloc_order'.    Element 0 should be the register to allocate first; element 1, the    next register; and so on.     The macro body should not assume anything about the contents of    `reg_alloc_order' before execution of the macro.     On most machines, it is not necessary to define this macro.  */
end_comment

begin_function
name|void
name|order_regs_for_local_alloc
parameter_list|()
block|{
name|int
name|i
decl_stmt|,
name|ch
decl_stmt|,
name|order
decl_stmt|,
name|regno
decl_stmt|;
comment|/* User specified the register allocation order */
if|if
condition|(
name|i386_reg_alloc_order
condition|)
block|{
for|for
control|(
name|i
operator|=
name|order
operator|=
literal|0
init|;
operator|(
name|ch
operator|=
name|i386_reg_alloc_order
index|[
name|i
index|]
operator|)
operator|!=
literal|'\0'
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'a'
case|:
name|regno
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|regno
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|regno
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|regno
operator|=
literal|3
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|regno
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|regno
operator|=
literal|5
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
name|regno
operator|=
literal|6
expr_stmt|;
break|break;
block|}
name|reg_alloc_order
index|[
name|order
operator|++
index|]
operator|=
name|regno
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|regs_allocated
index|[
name|i
index|]
condition|)
name|reg_alloc_order
index|[
name|order
operator|++
index|]
operator|=
name|i
expr_stmt|;
block|}
block|}
comment|/* If users did not specify a register allocation order, favor eax      normally except if DImode variables are used, in which case      favor edx before eax, which seems to cause less spill register      not found messages.  */
else|else
block|{
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
name|reg_alloc_order
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|optimize
condition|)
block|{
name|int
name|use_dca
init|=
name|FALSE
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
condition|)
block|{
name|rtx
name|set
init|=
name|NULL_RTX
decl_stmt|;
name|rtx
name|pattern
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
operator|==
name|SET
condition|)
name|set
operator|=
name|pattern
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
operator|==
name|PARALLEL
operator|||
name|GET_CODE
argument_list|(
name|pattern
argument_list|)
operator|==
name|SEQUENCE
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
name|set
operator|=
name|XVECEXP
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
operator|&&
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|DImode
condition|)
block|{
name|use_dca
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|use_dca
condition|)
block|{
name|reg_alloc_order
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
comment|/* edx */
name|reg_alloc_order
index|[
literal|1
index|]
operator|=
literal|2
expr_stmt|;
comment|/* ecx */
name|reg_alloc_order
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
comment|/* eax */
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if IDENTIFIER with arguments ARGS is a valid machine specific    attribute for DECL.  The attributes in ATTRIBUTES have previously been    assigned to DECL.  */
end_comment

begin_function
name|int
name|i386_valid_decl_attribute_p
parameter_list|(
name|decl
parameter_list|,
name|attributes
parameter_list|,
name|identifier
parameter_list|,
name|args
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|tree
name|attributes
decl_stmt|;
name|tree
name|identifier
decl_stmt|;
name|tree
name|args
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if IDENTIFIER with arguments ARGS is a valid machine specific    attribute for TYPE.  The attributes in ATTRIBUTES have previously been    assigned to TYPE.  */
end_comment

begin_function
name|int
name|i386_valid_type_attribute_p
parameter_list|(
name|type
parameter_list|,
name|attributes
parameter_list|,
name|identifier
parameter_list|,
name|args
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
name|attributes
decl_stmt|;
name|tree
name|identifier
decl_stmt|;
name|tree
name|args
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|FUNCTION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|FIELD_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
return|return
literal|0
return|;
comment|/* Stdcall attribute says callee is responsible for popping arguments      if they are not variable.  */
if|if
condition|(
name|is_attribute_p
argument_list|(
literal|"stdcall"
argument_list|,
name|identifier
argument_list|)
condition|)
return|return
operator|(
name|args
operator|==
name|NULL_TREE
operator|)
return|;
comment|/* Cdecl attribute says the callee is a normal C declaration */
if|if
condition|(
name|is_attribute_p
argument_list|(
literal|"cdecl"
argument_list|,
name|identifier
argument_list|)
condition|)
return|return
operator|(
name|args
operator|==
name|NULL_TREE
operator|)
return|;
comment|/* Regparm attribute specifies how many integer arguments are to be      passed in registers */
if|if
condition|(
name|is_attribute_p
argument_list|(
literal|"regparm"
argument_list|,
name|identifier
argument_list|)
condition|)
block|{
name|tree
name|cst
decl_stmt|;
if|if
condition|(
operator|!
name|args
operator|||
name|TREE_CODE
argument_list|(
name|args
argument_list|)
operator|!=
name|TREE_LIST
operator|||
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
operator|!=
name|NULL_TREE
operator|||
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
operator|==
name|NULL_TREE
condition|)
return|return
literal|0
return|;
name|cst
operator|=
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cst
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_INT_CST_HIGH
argument_list|(
name|cst
argument_list|)
operator|!=
literal|0
operator|||
name|TREE_INT_CST_LOW
argument_list|(
name|cst
argument_list|)
operator|<
literal|0
operator|||
name|TREE_INT_CST_LOW
argument_list|(
name|cst
argument_list|)
operator|>
name|REGPARM_MAX
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 0 if the attributes for two types are incompatible, 1 if they    are compatible, and 2 if they are nearly compatible (which causes a    warning to be generated).  */
end_comment

begin_function
name|int
name|i386_comp_type_attributes
parameter_list|(
name|type1
parameter_list|,
name|type2
parameter_list|)
name|tree
name|type1
decl_stmt|;
name|tree
name|type2
decl_stmt|;
block|{
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Value is the number of bytes of arguments automatically    popped when returning from a subroutine call.    FUNDECL is the declaration node of the function (as a tree),    FUNTYPE is the data type of the function (as a tree),    or for a library call it is an identifier node for the subroutine name.    SIZE is the number of bytes of arguments passed on the stack.     On the 80386, the RTD insn may be used to pop them if the number      of args is fixed, but if the number is variable then the caller      must pop them all.  RTD can't be used for library calls now      because the library is compiled with the Unix compiler.    Use of RTD is a selectable option, since it is incompatible with    standard Unix calling sequences.  If the option is not selected,    the caller must always pop the args.     The attribute stdcall is equivalent to RTD on a per module basis.  */
end_comment

begin_function
name|int
name|i386_return_pops_args
parameter_list|(
name|fundecl
parameter_list|,
name|funtype
parameter_list|,
name|size
parameter_list|)
name|tree
name|fundecl
decl_stmt|;
name|tree
name|funtype
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|int
name|rtd
init|=
name|TARGET_RTD
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|funtype
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
return|return
literal|0
return|;
comment|/* Cdecl functions override -mrtd, and never pop the stack */
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"cdecl"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|funtype
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Stdcall functions will pop the stack if not variable args */
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"stdcall"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|funtype
argument_list|)
argument_list|)
condition|)
name|rtd
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|rtd
condition|)
block|{
if|if
condition|(
name|TYPE_ARG_TYPES
argument_list|(
name|funtype
argument_list|)
operator|==
name|NULL_TREE
operator|||
operator|(
name|TREE_VALUE
argument_list|(
name|tree_last
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|funtype
argument_list|)
argument_list|)
argument_list|)
operator|==
name|void_type_node
operator|)
condition|)
return|return
name|size
return|;
if|if
condition|(
name|aggregate_value_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|funtype
argument_list|)
argument_list|)
condition|)
return|return
name|GET_MODE_SIZE
argument_list|(
name|Pmode
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Argument support functions.  */
end_comment

begin_comment
comment|/* Initialize a variable CUM of type CUMULATIVE_ARGS    for a call to a function whose data type is FNTYPE.    For a library call, FNTYPE is 0.  */
end_comment

begin_function
name|void
name|init_cumulative_args
parameter_list|(
name|cum
parameter_list|,
name|fntype
parameter_list|,
name|libname
parameter_list|)
name|CUMULATIVE_ARGS
modifier|*
name|cum
decl_stmt|;
comment|/* argument info to initialize */
name|tree
name|fntype
decl_stmt|;
comment|/* tree ptr for function decl */
name|rtx
name|libname
decl_stmt|;
comment|/* SYMBOL_REF of library name or 0 */
block|{
specifier|static
name|CUMULATIVE_ARGS
name|zero_cum
decl_stmt|;
name|tree
name|param
decl_stmt|,
name|next_param
decl_stmt|;
if|if
condition|(
name|TARGET_DEBUG_ARG
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ninit_cumulative_args ("
argument_list|)
expr_stmt|;
if|if
condition|(
name|fntype
condition|)
block|{
name|tree
name|ret_type
init|=
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"fntype code = %s, ret code = %s"
argument_list|,
name|tree_code_name
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|fntype
argument_list|)
index|]
argument_list|,
name|tree_code_name
index|[
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|ret_type
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"no fntype"
argument_list|)
expr_stmt|;
if|if
condition|(
name|libname
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|", libname = %s"
argument_list|,
name|XSTR
argument_list|(
name|libname
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|cum
operator|=
name|zero_cum
expr_stmt|;
comment|/* Set up the number of registers to use for passing arguments.  */
name|cum
operator|->
name|nregs
operator|=
name|i386_regparm
expr_stmt|;
if|if
condition|(
name|fntype
condition|)
block|{
name|tree
name|attr
init|=
name|lookup_attribute
argument_list|(
literal|"regparm"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|fntype
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|attr
condition|)
name|cum
operator|->
name|nregs
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_VALUE
argument_list|(
name|attr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Determine if this function has variable arguments.  This is      indicated by the last argument being 'void_type_mode' if there      are no variable arguments.  If there are variable arguments, then      we won't pass anything in registers */
if|if
condition|(
name|cum
operator|->
name|nregs
condition|)
block|{
for|for
control|(
name|param
operator|=
operator|(
name|fntype
operator|)
condition|?
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
else|:
literal|0
init|;
name|param
operator|!=
operator|(
name|tree
operator|)
literal|0
condition|;
name|param
operator|=
name|next_param
control|)
block|{
name|next_param
operator|=
name|TREE_CHAIN
argument_list|(
name|param
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_param
operator|==
operator|(
name|tree
operator|)
literal|0
operator|&&
name|TREE_VALUE
argument_list|(
name|param
argument_list|)
operator|!=
name|void_type_node
condition|)
name|cum
operator|->
name|nregs
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TARGET_DEBUG_ARG
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|", nregs=%d )\n"
argument_list|,
name|cum
operator|->
name|nregs
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Update the data in CUM to advance over an argument    of mode MODE and data type TYPE.    (TYPE is null for libcalls where that information may not be available.)  */
end_comment

begin_function
name|void
name|function_arg_advance
parameter_list|(
name|cum
parameter_list|,
name|mode
parameter_list|,
name|type
parameter_list|,
name|named
parameter_list|)
name|CUMULATIVE_ARGS
modifier|*
name|cum
decl_stmt|;
comment|/* current arg information */
name|enum
name|machine_mode
name|mode
decl_stmt|;
comment|/* current arg mode */
name|tree
name|type
decl_stmt|;
comment|/* type of the argument or 0 if lib support */
name|int
name|named
decl_stmt|;
comment|/* whether or not the argument was named */
block|{
name|int
name|bytes
init|=
operator|(
name|mode
operator|==
name|BLKmode
operator|)
condition|?
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
else|:
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|int
name|words
init|=
operator|(
name|bytes
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
decl_stmt|;
if|if
condition|(
name|TARGET_DEBUG_ARG
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"function_adv( size=%d, words=%2d, nregs=%d, mode=%4s, named=%d )\n\n"
argument_list|,
name|words
argument_list|,
name|cum
operator|->
name|words
argument_list|,
name|cum
operator|->
name|nregs
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|mode
argument_list|)
argument_list|,
name|named
argument_list|)
expr_stmt|;
name|cum
operator|->
name|words
operator|+=
name|words
expr_stmt|;
name|cum
operator|->
name|nregs
operator|-=
name|words
expr_stmt|;
name|cum
operator|->
name|regno
operator|+=
name|words
expr_stmt|;
if|if
condition|(
name|cum
operator|->
name|nregs
operator|<=
literal|0
condition|)
block|{
name|cum
operator|->
name|nregs
operator|=
literal|0
expr_stmt|;
name|cum
operator|->
name|regno
operator|=
literal|0
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* Define where to put the arguments to a function.    Value is zero to push the argument on the stack,    or a hard register in which to store the argument.     MODE is the argument's machine mode.    TYPE is the data type of the argument (as a tree).     This is null for libcalls where that information may     not be available.    CUM is a variable of type CUMULATIVE_ARGS which gives info about     the preceding args and about the function being called.    NAMED is nonzero if this argument is a named parameter     (otherwise it is an extra parameter matching an ellipsis).  */
end_comment

begin_function
name|struct
name|rtx_def
modifier|*
name|function_arg
parameter_list|(
name|cum
parameter_list|,
name|mode
parameter_list|,
name|type
parameter_list|,
name|named
parameter_list|)
name|CUMULATIVE_ARGS
modifier|*
name|cum
decl_stmt|;
comment|/* current arg information */
name|enum
name|machine_mode
name|mode
decl_stmt|;
comment|/* current arg mode */
name|tree
name|type
decl_stmt|;
comment|/* type of the argument or 0 if lib support */
name|int
name|named
decl_stmt|;
comment|/* != 0 for normal args, == 0 for ... args */
block|{
name|rtx
name|ret
init|=
name|NULL_RTX
decl_stmt|;
name|int
name|bytes
init|=
operator|(
name|mode
operator|==
name|BLKmode
operator|)
condition|?
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
else|:
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|int
name|words
init|=
operator|(
name|bytes
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
decl_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
default|default:
comment|/* for now, pass fp/complex values on the stack */
break|break;
case|case
name|BLKmode
case|:
case|case
name|DImode
case|:
case|case
name|SImode
case|:
case|case
name|HImode
case|:
case|case
name|QImode
case|:
if|if
condition|(
name|words
operator|<=
name|cum
operator|->
name|nregs
condition|)
name|ret
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|mode
argument_list|,
name|cum
operator|->
name|regno
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|TARGET_DEBUG_ARG
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"function_arg( size=%d, words=%2d, nregs=%d, mode=%4s, named=%d"
argument_list|,
name|words
argument_list|,
name|cum
operator|->
name|words
argument_list|,
name|cum
operator|->
name|nregs
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|mode
argument_list|)
argument_list|,
name|named
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|", reg=%%e%s"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|ret
argument_list|)
index|]
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|", stack"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" )\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* For an arg passed partly in registers and partly in memory,    this is the number of registers used.    For args passed entirely in registers or entirely in memory, zero.  */
end_comment

begin_function
name|int
name|function_arg_partial_nregs
parameter_list|(
name|cum
parameter_list|,
name|mode
parameter_list|,
name|type
parameter_list|,
name|named
parameter_list|)
name|CUMULATIVE_ARGS
modifier|*
name|cum
decl_stmt|;
comment|/* current arg information */
name|enum
name|machine_mode
name|mode
decl_stmt|;
comment|/* current arg mode */
name|tree
name|type
decl_stmt|;
comment|/* type of the argument or 0 if lib support */
name|int
name|named
decl_stmt|;
comment|/* != 0 for normal args, == 0 for ... args */
block|{
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output an insn whose source is a 386 integer register.  SRC is the    rtx for the register, and TEMPLATE is the op-code template.  SRC may    be either SImode or DImode.     The template will be output with operands[0] as SRC, and operands[1]    as a pointer to the top of the 386 stack.  So a call from floatsidf2    would look like this:        output_op_from_reg (operands[1], AS1 (fild%z0,%1));     where %z0 corresponds to the caller's operands[1], and is used to    emit the proper size suffix.     ??? Extend this to handle HImode - a 387 can load and store HImode    values directly. */
end_comment

begin_function
name|void
name|output_op_from_reg
parameter_list|(
name|src
parameter_list|,
name|template
parameter_list|)
name|rtx
name|src
decl_stmt|;
name|char
modifier|*
name|template
decl_stmt|;
block|{
name|rtx
name|xops
index|[
literal|4
index|]
decl_stmt|;
name|int
name|size
init|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|)
decl_stmt|;
name|xops
index|[
literal|0
index|]
operator|=
name|src
expr_stmt|;
name|xops
index|[
literal|1
index|]
operator|=
name|AT_SP
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|xops
index|[
literal|2
index|]
operator|=
name|GEN_INT
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|xops
index|[
literal|3
index|]
operator|=
name|stack_pointer_rtx
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|UNITS_PER_WORD
condition|)
block|{
name|rtx
name|high
decl_stmt|;
if|if
condition|(
name|size
operator|>
literal|2
operator|*
name|UNITS_PER_WORD
condition|)
block|{
name|high
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|src
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS1
argument_list|(
name|push
operator|%
name|L0
argument_list|,
operator|%
literal|0
argument_list|)
argument_list|,
operator|&
name|high
argument_list|)
expr_stmt|;
block|}
name|high
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|src
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS1
argument_list|(
name|push
operator|%
name|L0
argument_list|,
operator|%
literal|0
argument_list|)
argument_list|,
operator|&
name|high
argument_list|)
expr_stmt|;
block|}
name|output_asm_insn
argument_list|(
name|AS1
argument_list|(
name|push
operator|%
name|L0
argument_list|,
operator|%
literal|0
argument_list|)
argument_list|,
operator|&
name|src
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|template
argument_list|,
name|xops
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|add
operator|%
name|L3
argument_list|,
operator|%
literal|2
argument_list|,
operator|%
literal|3
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output an insn to pop an value from the 387 top-of-stack to 386    register DEST. The 387 register stack is popped if DIES is true.  If    the mode of DEST is an integer mode, a `fist' integer store is done,    otherwise a `fst' float store is done. */
end_comment

begin_function
name|void
name|output_to_reg
parameter_list|(
name|dest
parameter_list|,
name|dies
parameter_list|)
name|rtx
name|dest
decl_stmt|;
name|int
name|dies
decl_stmt|;
block|{
name|rtx
name|xops
index|[
literal|4
index|]
decl_stmt|;
name|int
name|size
init|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
decl_stmt|;
name|xops
index|[
literal|0
index|]
operator|=
name|AT_SP
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|xops
index|[
literal|1
index|]
operator|=
name|stack_pointer_rtx
expr_stmt|;
name|xops
index|[
literal|2
index|]
operator|=
name|GEN_INT
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|xops
index|[
literal|3
index|]
operator|=
name|dest
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|sub
operator|%
name|L1
argument_list|,
operator|%
literal|2
argument_list|,
operator|%
literal|1
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|==
name|MODE_INT
condition|)
block|{
if|if
condition|(
name|dies
condition|)
name|output_asm_insn
argument_list|(
name|AS1
argument_list|(
name|fistp
operator|%
name|z3
argument_list|,
operator|%
name|y0
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
else|else
name|output_asm_insn
argument_list|(
name|AS1
argument_list|(
name|fist
operator|%
name|z3
argument_list|,
operator|%
name|y0
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
block|{
if|if
condition|(
name|dies
condition|)
name|output_asm_insn
argument_list|(
name|AS1
argument_list|(
name|fstp
operator|%
name|z3
argument_list|,
operator|%
name|y0
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
operator|==
name|XFmode
condition|)
block|{
name|output_asm_insn
argument_list|(
name|AS1
argument_list|(
name|fstp
operator|%
name|z3
argument_list|,
operator|%
name|y0
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS1
argument_list|(
name|fld
operator|%
name|z3
argument_list|,
operator|%
name|y0
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
block|}
else|else
name|output_asm_insn
argument_list|(
name|AS1
argument_list|(
name|fst
operator|%
name|z3
argument_list|,
operator|%
name|y0
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS1
argument_list|(
name|pop
operator|%
name|L0
argument_list|,
operator|%
literal|0
argument_list|)
argument_list|,
operator|&
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|UNITS_PER_WORD
condition|)
block|{
name|dest
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|dest
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS1
argument_list|(
name|pop
operator|%
name|L0
argument_list|,
operator|%
literal|0
argument_list|)
argument_list|,
operator|&
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>
literal|2
operator|*
name|UNITS_PER_WORD
condition|)
block|{
name|dest
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|dest
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS1
argument_list|(
name|pop
operator|%
name|L0
argument_list|,
operator|%
literal|0
argument_list|)
argument_list|,
operator|&
name|dest
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_function
name|char
modifier|*
name|singlemove_string
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
name|rtx
name|x
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|x
operator|=
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_DEC
condition|)
block|{
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|!=
name|stack_pointer_rtx
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
literal|"push%L1 %1"
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
return|return
name|output_move_const_single
argument_list|(
name|operands
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|REG
condition|)
return|return
name|AS2
argument_list|(
name|mov
operator|%
name|L0
argument_list|,
operator|%
literal|1
argument_list|,
operator|%
literal|0
argument_list|)
return|;
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
return|return
name|AS2
argument_list|(
name|mov
operator|%
name|L0
argument_list|,
operator|%
literal|1
argument_list|,
operator|%
literal|0
argument_list|)
return|;
else|else
block|{
name|output_asm_insn
argument_list|(
literal|"push%L1 %1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return
literal|"pop%L0 %0"
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a REG that occurs in ADDR with coefficient 1.    ADDR can be effectively incremented by incrementing REG.  */
end_comment

begin_function
specifier|static
name|rtx
name|find_addr_reg
parameter_list|(
name|addr
parameter_list|)
name|rtx
name|addr
decl_stmt|;
block|{
while|while
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|REG
condition|)
return|return
name|addr
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output an insn to add the constant N to the register X.  */
end_comment

begin_function
specifier|static
name|void
name|asm_add
parameter_list|(
name|n
parameter_list|,
name|x
parameter_list|)
name|int
name|n
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
name|rtx
name|xops
index|[
literal|2
index|]
decl_stmt|;
name|xops
index|[
literal|0
index|]
operator|=
name|x
expr_stmt|;
if|if
condition|(
name|n
operator|==
operator|-
literal|1
condition|)
name|output_asm_insn
argument_list|(
name|AS1
argument_list|(
name|dec
operator|%
name|L0
argument_list|,
operator|%
literal|0
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|n
operator|==
literal|1
condition|)
name|output_asm_insn
argument_list|(
name|AS1
argument_list|(
name|inc
operator|%
name|L0
argument_list|,
operator|%
literal|0
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|xops
index|[
literal|1
index|]
operator|=
name|GEN_INT
argument_list|(
operator|-
name|n
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|sub
operator|%
name|L0
argument_list|,
operator|%
literal|1
argument_list|,
operator|%
literal|0
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|xops
index|[
literal|1
index|]
operator|=
name|GEN_INT
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|add
operator|%
name|L0
argument_list|,
operator|%
literal|1
argument_list|,
operator|%
literal|0
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output assembler code to perform a doubleword move insn    with operands OPERANDS.  */
end_comment

begin_function
name|char
modifier|*
name|output_move_double
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
enum|enum
block|{
name|REGOP
block|,
name|OFFSOP
block|,
name|MEMOP
block|,
name|PUSHOP
block|,
name|POPOP
block|,
name|CNSTOP
block|,
name|RNDOP
block|}
name|optype0
enum|,
name|optype1
expr_stmt|;
name|rtx
name|latehalf
index|[
literal|2
index|]
decl_stmt|;
name|rtx
name|middlehalf
index|[
literal|2
index|]
decl_stmt|;
name|rtx
name|xops
index|[
literal|2
index|]
decl_stmt|;
name|rtx
name|addreg0
init|=
literal|0
decl_stmt|,
name|addreg1
init|=
literal|0
decl_stmt|;
name|int
name|dest_overlapped_low
init|=
literal|0
decl_stmt|;
name|int
name|size
init|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|)
decl_stmt|;
name|middlehalf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|middlehalf
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* First classify both operands.  */
if|if
condition|(
name|REG_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
name|optype0
operator|=
name|REGOP
expr_stmt|;
elseif|else
if|if
condition|(
name|offsettable_memref_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
name|optype0
operator|=
name|OFFSOP
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|POST_INC
condition|)
name|optype0
operator|=
name|POPOP
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_DEC
condition|)
name|optype0
operator|=
name|PUSHOP
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|MEM
condition|)
name|optype0
operator|=
name|MEMOP
expr_stmt|;
else|else
name|optype0
operator|=
name|RNDOP
expr_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
name|optype1
operator|=
name|REGOP
expr_stmt|;
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
name|optype1
operator|=
name|CNSTOP
expr_stmt|;
elseif|else
if|if
condition|(
name|offsettable_memref_p
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
name|optype1
operator|=
name|OFFSOP
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|POST_INC
condition|)
name|optype1
operator|=
name|POPOP
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_DEC
condition|)
name|optype1
operator|=
name|PUSHOP
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|MEM
condition|)
name|optype1
operator|=
name|MEMOP
expr_stmt|;
else|else
name|optype1
operator|=
name|RNDOP
expr_stmt|;
comment|/* Check for the cases that the operand constraints are not      supposed to allow to happen.  Abort if we get one,      because generating code for these cases is painful.  */
if|if
condition|(
name|optype0
operator|==
name|RNDOP
operator|||
name|optype1
operator|==
name|RNDOP
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If one operand is decrementing and one is incrementing      decrement the former register explicitly      and change that operand into ordinary indexing.  */
if|if
condition|(
name|optype0
operator|==
name|PUSHOP
operator|&&
name|optype1
operator|==
name|POPOP
condition|)
block|{
comment|/* ??? Can this ever happen on i386? */
name|operands
index|[
literal|0
index|]
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|asm_add
argument_list|(
operator|-
name|size
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|XFmode
condition|)
name|operands
index|[
literal|0
index|]
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|XFmode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|DFmode
condition|)
name|operands
index|[
literal|0
index|]
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|DFmode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
else|else
name|operands
index|[
literal|0
index|]
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|DImode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|optype0
operator|=
name|OFFSOP
expr_stmt|;
block|}
if|if
condition|(
name|optype0
operator|==
name|POPOP
operator|&&
name|optype1
operator|==
name|PUSHOP
condition|)
block|{
comment|/* ??? Can this ever happen on i386? */
name|operands
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|asm_add
argument_list|(
operator|-
name|size
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|XFmode
condition|)
name|operands
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|XFmode
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|DFmode
condition|)
name|operands
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|DFmode
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
name|operands
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|DImode
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|optype1
operator|=
name|OFFSOP
expr_stmt|;
block|}
comment|/* If an operand is an unoffsettable memory ref, find a register      we can increment temporarily to make it refer to the second word.  */
if|if
condition|(
name|optype0
operator|==
name|MEMOP
condition|)
name|addreg0
operator|=
name|find_addr_reg
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|optype1
operator|==
name|MEMOP
condition|)
name|addreg1
operator|=
name|find_addr_reg
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Ok, we can do one word at a time.      Normally we do the low-numbered word first,      but if either operand is autodecrementing then we      do the high-numbered word first.       In either case, set up in LATEHALF the operands to use      for the high-numbered word and in some cases alter the      operands in OPERANDS to be suitable for the low-numbered word.  */
if|if
condition|(
name|size
operator|==
literal|12
condition|)
block|{
if|if
condition|(
name|optype0
operator|==
name|REGOP
condition|)
block|{
name|middlehalf
index|[
literal|0
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|latehalf
index|[
literal|0
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|optype0
operator|==
name|OFFSOP
condition|)
block|{
name|middlehalf
index|[
literal|0
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|latehalf
index|[
literal|0
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|middlehalf
index|[
literal|0
index|]
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
name|latehalf
index|[
literal|0
index|]
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
block|}
if|if
condition|(
name|optype1
operator|==
name|REGOP
condition|)
block|{
name|middlehalf
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|latehalf
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|optype1
operator|==
name|OFFSOP
condition|)
block|{
name|middlehalf
index|[
literal|1
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|latehalf
index|[
literal|1
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|optype1
operator|==
name|CNSTOP
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|long
name|l
index|[
literal|3
index|]
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|r
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|REAL_VALUE_TO_TARGET_LONG_DOUBLE
argument_list|(
name|r
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|GEN_INT
argument_list|(
name|l
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|middlehalf
index|[
literal|1
index|]
operator|=
name|GEN_INT
argument_list|(
name|l
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|latehalf
index|[
literal|1
index|]
operator|=
name|GEN_INT
argument_list|(
name|l
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
comment|/* No non-CONST_DOUBLE constant should ever appear here.  */
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|middlehalf
index|[
literal|1
index|]
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
name|latehalf
index|[
literal|1
index|]
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
block|}
block|}
else|else
comment|/* size is not 12: */
block|{
if|if
condition|(
name|optype0
operator|==
name|REGOP
condition|)
name|latehalf
index|[
literal|0
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|optype0
operator|==
name|OFFSOP
condition|)
name|latehalf
index|[
literal|0
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
else|else
name|latehalf
index|[
literal|0
index|]
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|optype1
operator|==
name|REGOP
condition|)
name|latehalf
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|optype1
operator|==
name|OFFSOP
condition|)
name|latehalf
index|[
literal|1
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|optype1
operator|==
name|CNSTOP
condition|)
name|split_double
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
operator|&
name|operands
index|[
literal|1
index|]
argument_list|,
operator|&
name|latehalf
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
name|latehalf
index|[
literal|1
index|]
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
block|}
comment|/* If insn is effectively movd N (sp),-(sp) then we will do the      high word first.  We should use the adjusted operand 1      (which is N+4 (sp) or N+8 (sp))      for the low word and middle word as well,      to compensate for the first decrement of sp.  */
if|if
condition|(
name|optype0
operator|==
name|PUSHOP
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|STACK_POINTER_REGNUM
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
name|middlehalf
index|[
literal|1
index|]
operator|=
name|operands
index|[
literal|1
index|]
operator|=
name|latehalf
index|[
literal|1
index|]
expr_stmt|;
comment|/* For (set (reg:DI N) (mem:DI ... (reg:SI N) ...)),      if the upper part of reg N does not appear in the MEM, arrange to      emit the move late-half first.  Otherwise, compute the MEM address      into the upper part of N and use that as a pointer to the memory      operand.  */
if|if
condition|(
name|optype0
operator|==
name|REGOP
operator|&&
operator|(
name|optype1
operator|==
name|OFFSOP
operator|||
name|optype1
operator|==
name|MEMOP
operator|)
condition|)
block|{
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|reg_mentioned_p
argument_list|(
name|latehalf
index|[
literal|0
index|]
argument_list|,
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
comment|/* If both halves of dest are used in the src memory address, 	     compute the address into latehalf of dest.  */
name|compadr
label|:
name|xops
index|[
literal|0
index|]
operator|=
name|latehalf
index|[
literal|0
index|]
expr_stmt|;
name|xops
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|lea
operator|%
name|L0
argument_list|,
operator|%
name|a1
argument_list|,
operator|%
literal|0
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|XFmode
condition|)
block|{
comment|/*	    abort (); */
name|operands
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|XFmode
argument_list|,
name|latehalf
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|middlehalf
index|[
literal|1
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|size
operator|-
literal|8
argument_list|)
expr_stmt|;
name|latehalf
index|[
literal|1
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|size
operator|-
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|operands
index|[
literal|1
index|]
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|DImode
argument_list|,
name|latehalf
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|latehalf
index|[
literal|1
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|size
operator|-
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|size
operator|==
literal|12
operator|&&
name|reg_mentioned_p
argument_list|(
name|middlehalf
index|[
literal|0
index|]
argument_list|,
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Check for two regs used by both source and dest. */
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
name|reg_mentioned_p
argument_list|(
name|latehalf
index|[
literal|0
index|]
argument_list|,
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
goto|goto
name|compadr
goto|;
comment|/* JRV says this can't happen: */
if|if
condition|(
name|addreg0
operator|||
name|addreg1
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Only the middle reg conflicts; simply put it last. */
name|output_asm_insn
argument_list|(
name|singlemove_string
argument_list|(
name|operands
argument_list|)
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|singlemove_string
argument_list|(
name|latehalf
argument_list|)
argument_list|,
name|latehalf
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|singlemove_string
argument_list|(
name|middlehalf
argument_list|)
argument_list|,
name|middlehalf
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
elseif|else
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
comment|/* If the low half of dest is mentioned in the source memory 	   address, the arrange to emit the move late half first.  */
name|dest_overlapped_low
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If one or both operands autodecrementing,      do the two words, high-numbered first.  */
comment|/* Likewise,  the first move would clobber the source of the second one,      do them in the other order.  This happens only for registers;      such overlap can't happen in memory unless the user explicitly      sets it up, and that is an undefined circumstance.  */
comment|/*   if (optype0 == PUSHOP || optype1 == PUSHOP       || (optype0 == REGOP&& optype1 == REGOP&& REGNO (operands[0]) == REGNO (latehalf[1]))       || dest_overlapped_low) */
if|if
condition|(
name|optype0
operator|==
name|PUSHOP
operator|||
name|optype1
operator|==
name|PUSHOP
operator|||
operator|(
name|optype0
operator|==
name|REGOP
operator|&&
name|optype1
operator|==
name|REGOP
operator|&&
operator|(
operator|(
name|middlehalf
index|[
literal|1
index|]
operator|&&
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|REGNO
argument_list|(
name|middlehalf
index|[
literal|1
index|]
argument_list|)
operator|)
operator|||
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|REGNO
argument_list|(
name|latehalf
index|[
literal|1
index|]
argument_list|)
operator|)
operator|)
operator|||
name|dest_overlapped_low
condition|)
block|{
comment|/* Make any unoffsettable addresses point at high-numbered word.  */
if|if
condition|(
name|addreg0
condition|)
name|asm_add
argument_list|(
name|size
operator|-
literal|4
argument_list|,
name|addreg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|addreg1
condition|)
name|asm_add
argument_list|(
name|size
operator|-
literal|4
argument_list|,
name|addreg1
argument_list|)
expr_stmt|;
comment|/* Do that word.  */
name|output_asm_insn
argument_list|(
name|singlemove_string
argument_list|(
name|latehalf
argument_list|)
argument_list|,
name|latehalf
argument_list|)
expr_stmt|;
comment|/* Undo the adds we just did.  */
if|if
condition|(
name|addreg0
condition|)
name|asm_add
argument_list|(
operator|-
literal|4
argument_list|,
name|addreg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|addreg1
condition|)
name|asm_add
argument_list|(
operator|-
literal|4
argument_list|,
name|addreg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|12
condition|)
block|{
name|output_asm_insn
argument_list|(
name|singlemove_string
argument_list|(
name|middlehalf
argument_list|)
argument_list|,
name|middlehalf
argument_list|)
expr_stmt|;
if|if
condition|(
name|addreg0
condition|)
name|asm_add
argument_list|(
operator|-
literal|4
argument_list|,
name|addreg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|addreg1
condition|)
name|asm_add
argument_list|(
operator|-
literal|4
argument_list|,
name|addreg1
argument_list|)
expr_stmt|;
block|}
comment|/* Do low-numbered word.  */
return|return
name|singlemove_string
argument_list|(
name|operands
argument_list|)
return|;
block|}
comment|/* Normal case: do the two words, low-numbered first.  */
name|output_asm_insn
argument_list|(
name|singlemove_string
argument_list|(
name|operands
argument_list|)
argument_list|,
name|operands
argument_list|)
expr_stmt|;
comment|/* Do the middle one of the three words for long double */
if|if
condition|(
name|size
operator|==
literal|12
condition|)
block|{
if|if
condition|(
name|addreg0
condition|)
name|asm_add
argument_list|(
literal|4
argument_list|,
name|addreg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|addreg1
condition|)
name|asm_add
argument_list|(
literal|4
argument_list|,
name|addreg1
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|singlemove_string
argument_list|(
name|middlehalf
argument_list|)
argument_list|,
name|middlehalf
argument_list|)
expr_stmt|;
block|}
comment|/* Make any unoffsettable addresses point at high-numbered word.  */
if|if
condition|(
name|addreg0
condition|)
name|asm_add
argument_list|(
literal|4
argument_list|,
name|addreg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|addreg1
condition|)
name|asm_add
argument_list|(
literal|4
argument_list|,
name|addreg1
argument_list|)
expr_stmt|;
comment|/* Do that word.  */
name|output_asm_insn
argument_list|(
name|singlemove_string
argument_list|(
name|latehalf
argument_list|)
argument_list|,
name|latehalf
argument_list|)
expr_stmt|;
comment|/* Undo the adds we just did.  */
if|if
condition|(
name|addreg0
condition|)
name|asm_add
argument_list|(
literal|4
operator|-
name|size
argument_list|,
name|addreg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|addreg1
condition|)
name|asm_add
argument_list|(
literal|4
operator|-
name|size
argument_list|,
name|addreg1
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
end_function

begin_escape
end_escape

begin_define
define|#
directive|define
name|MAX_TMPS
value|2
end_define

begin_comment
comment|/* max temporary registers used */
end_comment

begin_comment
comment|/* Output the appropriate code to move push memory on the stack */
end_comment

begin_function
name|char
modifier|*
name|output_move_pushmem
parameter_list|(
name|operands
parameter_list|,
name|insn
parameter_list|,
name|length
parameter_list|,
name|tmp_start
parameter_list|,
name|n_operands
parameter_list|)
name|rtx
name|operands
index|[]
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|length
decl_stmt|;
name|int
name|tmp_start
decl_stmt|;
name|int
name|n_operands
decl_stmt|;
block|{
struct|struct
block|{
name|char
modifier|*
name|load
decl_stmt|;
name|char
modifier|*
name|push
decl_stmt|;
name|rtx
name|xops
index|[
literal|2
index|]
decl_stmt|;
block|}
name|tmp_info
index|[
name|MAX_TMPS
index|]
struct|;
name|rtx
name|src
init|=
name|operands
index|[
literal|1
index|]
decl_stmt|;
name|int
name|max_tmps
init|=
literal|0
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|int
name|stack_p
init|=
name|reg_overlap_mentioned_p
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|src
argument_list|)
decl_stmt|;
name|int
name|stack_offset
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|num_tmps
decl_stmt|;
name|rtx
name|xops
index|[
literal|1
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|offsettable_memref_p
argument_list|(
name|src
argument_list|)
condition|)
name|fatal_insn
argument_list|(
literal|"Source is not offsettable"
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|length
operator|&
literal|3
operator|)
operator|!=
literal|0
condition|)
name|fatal_insn
argument_list|(
literal|"Pushing non-word aligned size"
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* Figure out which temporary registers we have available */
for|for
control|(
name|i
operator|=
name|tmp_start
init|;
name|i
operator|<
name|n_operands
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|)
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|,
name|src
argument_list|)
condition|)
continue|continue;
name|tmp_info
index|[
name|max_tmps
operator|++
index|]
operator|.
name|xops
index|[
literal|1
index|]
operator|=
name|operands
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|max_tmps
operator|==
name|MAX_TMPS
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|max_tmps
operator|==
literal|0
condition|)
for|for
control|(
name|offset
operator|=
name|length
operator|-
literal|4
init|;
name|offset
operator|>=
literal|0
condition|;
name|offset
operator|-=
literal|4
control|)
block|{
name|xops
index|[
literal|0
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|src
argument_list|,
name|offset
operator|+
name|stack_offset
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS1
argument_list|(
name|push
operator|%
name|L0
argument_list|,
operator|%
literal|0
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
if|if
condition|(
name|stack_p
condition|)
name|stack_offset
operator|+=
literal|4
expr_stmt|;
block|}
else|else
for|for
control|(
name|offset
operator|=
name|length
operator|-
literal|4
init|;
name|offset
operator|>=
literal|0
condition|;
control|)
block|{
for|for
control|(
name|num_tmps
operator|=
literal|0
init|;
name|num_tmps
operator|<
name|max_tmps
operator|&&
name|offset
operator|>=
literal|0
condition|;
name|num_tmps
operator|++
control|)
block|{
name|tmp_info
index|[
name|num_tmps
index|]
operator|.
name|load
operator|=
name|AS2
argument_list|(
name|mov
operator|%
name|L0
argument_list|,
operator|%
literal|0
argument_list|,
operator|%
literal|1
argument_list|)
expr_stmt|;
name|tmp_info
index|[
name|num_tmps
index|]
operator|.
name|push
operator|=
name|AS1
argument_list|(
name|push
operator|%
name|L0
argument_list|,
operator|%
literal|1
argument_list|)
expr_stmt|;
name|tmp_info
index|[
name|num_tmps
index|]
operator|.
name|xops
index|[
literal|0
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|src
argument_list|,
name|offset
operator|+
name|stack_offset
argument_list|)
expr_stmt|;
name|offset
operator|-=
literal|4
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_tmps
condition|;
name|i
operator|++
control|)
name|output_asm_insn
argument_list|(
name|tmp_info
index|[
name|i
index|]
operator|.
name|load
argument_list|,
name|tmp_info
index|[
name|i
index|]
operator|.
name|xops
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_tmps
condition|;
name|i
operator|++
control|)
name|output_asm_insn
argument_list|(
name|tmp_info
index|[
name|i
index|]
operator|.
name|push
argument_list|,
name|tmp_info
index|[
name|i
index|]
operator|.
name|xops
argument_list|)
expr_stmt|;
if|if
condition|(
name|stack_p
condition|)
name|stack_offset
operator|+=
literal|4
operator|*
name|num_tmps
expr_stmt|;
block|}
return|return
literal|""
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output the appropriate code to move data between two memory locations */
end_comment

begin_function
name|char
modifier|*
name|output_move_memory
parameter_list|(
name|operands
parameter_list|,
name|insn
parameter_list|,
name|length
parameter_list|,
name|tmp_start
parameter_list|,
name|n_operands
parameter_list|)
name|rtx
name|operands
index|[]
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|length
decl_stmt|;
name|int
name|tmp_start
decl_stmt|;
name|int
name|n_operands
decl_stmt|;
block|{
struct|struct
block|{
name|char
modifier|*
name|load
decl_stmt|;
name|char
modifier|*
name|store
decl_stmt|;
name|rtx
name|xops
index|[
literal|3
index|]
decl_stmt|;
block|}
name|tmp_info
index|[
name|MAX_TMPS
index|]
struct|;
name|rtx
name|dest
init|=
name|operands
index|[
literal|0
index|]
decl_stmt|;
name|rtx
name|src
init|=
name|operands
index|[
literal|1
index|]
decl_stmt|;
name|rtx
name|qi_tmp
init|=
name|NULL_RTX
decl_stmt|;
name|int
name|max_tmps
init|=
literal|0
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|num_tmps
decl_stmt|;
name|rtx
name|xops
index|[
literal|3
index|]
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_INC
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|stack_pointer_rtx
condition|)
return|return
name|output_move_pushmem
argument_list|(
name|operands
argument_list|,
name|insn
argument_list|,
name|length
argument_list|,
name|tmp_start
argument_list|,
name|n_operands
argument_list|)
return|;
if|if
condition|(
operator|!
name|offsettable_memref_p
argument_list|(
name|src
argument_list|)
condition|)
name|fatal_insn
argument_list|(
literal|"Source is not offsettable"
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|offsettable_memref_p
argument_list|(
name|dest
argument_list|)
condition|)
name|fatal_insn
argument_list|(
literal|"Destination is not offsettable"
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* Figure out which temporary registers we have available */
for|for
control|(
name|i
operator|=
name|tmp_start
init|;
name|i
operator|<
name|n_operands
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|)
operator|==
name|REG
condition|)
block|{
if|if
condition|(
operator|(
name|length
operator|&
literal|1
operator|)
operator|!=
literal|0
operator|&&
operator|!
name|qi_tmp
operator|&&
name|QI_REG_P
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|)
condition|)
name|qi_tmp
operator|=
name|operands
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|,
name|dest
argument_list|)
condition|)
name|fatal_insn
argument_list|(
literal|"Temporary register overlaps the destination"
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|,
name|src
argument_list|)
condition|)
name|fatal_insn
argument_list|(
literal|"Temporary register overlaps the source"
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|tmp_info
index|[
name|max_tmps
operator|++
index|]
operator|.
name|xops
index|[
literal|2
index|]
operator|=
name|operands
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|max_tmps
operator|==
name|MAX_TMPS
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|max_tmps
operator|==
literal|0
condition|)
name|fatal_insn
argument_list|(
literal|"No scratch registers were found to do memory->memory moves"
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|length
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|qi_tmp
condition|)
name|fatal_insn
argument_list|(
literal|"No byte register found when moving odd # of bytes."
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|length
operator|>
literal|1
condition|)
block|{
for|for
control|(
name|num_tmps
operator|=
literal|0
init|;
name|num_tmps
operator|<
name|max_tmps
condition|;
name|num_tmps
operator|++
control|)
block|{
if|if
condition|(
name|length
operator|>=
literal|4
condition|)
block|{
name|tmp_info
index|[
name|num_tmps
index|]
operator|.
name|load
operator|=
name|AS2
argument_list|(
name|mov
operator|%
name|L0
argument_list|,
operator|%
literal|1
argument_list|,
operator|%
literal|2
argument_list|)
expr_stmt|;
name|tmp_info
index|[
name|num_tmps
index|]
operator|.
name|store
operator|=
name|AS2
argument_list|(
name|mov
operator|%
name|L0
argument_list|,
operator|%
literal|2
argument_list|,
operator|%
literal|0
argument_list|)
expr_stmt|;
name|tmp_info
index|[
name|num_tmps
index|]
operator|.
name|xops
index|[
literal|0
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|dest
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|tmp_info
index|[
name|num_tmps
index|]
operator|.
name|xops
index|[
literal|1
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|src
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|4
expr_stmt|;
name|length
operator|-=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|length
operator|>=
literal|2
condition|)
block|{
name|tmp_info
index|[
name|num_tmps
index|]
operator|.
name|load
operator|=
name|AS2
argument_list|(
name|mov
operator|%
name|W0
argument_list|,
operator|%
literal|1
argument_list|,
operator|%
literal|2
argument_list|)
expr_stmt|;
name|tmp_info
index|[
name|num_tmps
index|]
operator|.
name|store
operator|=
name|AS2
argument_list|(
name|mov
operator|%
name|W0
argument_list|,
operator|%
literal|2
argument_list|,
operator|%
literal|0
argument_list|)
expr_stmt|;
name|tmp_info
index|[
name|num_tmps
index|]
operator|.
name|xops
index|[
literal|0
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|dest
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|tmp_info
index|[
name|num_tmps
index|]
operator|.
name|xops
index|[
literal|1
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|src
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|2
expr_stmt|;
name|length
operator|-=
literal|2
expr_stmt|;
block|}
else|else
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_tmps
condition|;
name|i
operator|++
control|)
name|output_asm_insn
argument_list|(
name|tmp_info
index|[
name|i
index|]
operator|.
name|load
argument_list|,
name|tmp_info
index|[
name|i
index|]
operator|.
name|xops
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_tmps
condition|;
name|i
operator|++
control|)
name|output_asm_insn
argument_list|(
name|tmp_info
index|[
name|i
index|]
operator|.
name|store
argument_list|,
name|tmp_info
index|[
name|i
index|]
operator|.
name|xops
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|length
operator|==
literal|1
condition|)
block|{
name|xops
index|[
literal|0
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|dest
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|xops
index|[
literal|1
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|src
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|xops
index|[
literal|2
index|]
operator|=
name|qi_tmp
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|mov
operator|%
name|B0
argument_list|,
operator|%
literal|1
argument_list|,
operator|%
literal|2
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|mov
operator|%
name|B0
argument_list|,
operator|%
literal|2
argument_list|,
operator|%
literal|0
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
block|}
return|return
literal|""
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|int
name|standard_80387_constant_p
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|REAL_IS_NOT_DOUBLE
argument_list|)
operator|||
name|defined
argument_list|(
name|REAL_ARITHMETIC
argument_list|)
name|REAL_VALUE_TYPE
name|d
decl_stmt|;
name|jmp_buf
name|handler
decl_stmt|;
name|int
name|is0
decl_stmt|,
name|is1
decl_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|handler
argument_list|)
condition|)
return|return
literal|0
return|;
name|set_float_handler
argument_list|(
name|handler
argument_list|)
expr_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|d
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|is0
operator|=
name|REAL_VALUES_EQUAL
argument_list|(
name|d
argument_list|,
name|dconst0
argument_list|)
expr_stmt|;
name|is1
operator|=
name|REAL_VALUES_EQUAL
argument_list|(
name|d
argument_list|,
name|dconst1
argument_list|)
expr_stmt|;
name|set_float_handler
argument_list|(
name|NULL_PTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|is0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|is1
condition|)
return|return
literal|2
return|;
comment|/* Note that on the 80387, other constants, such as pi,      are much slower to load as standard constants      than to load from doubles in memory!  */
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|output_move_const_single
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
if|if
condition|(
name|FP_REG_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|int
name|conval
init|=
name|standard_80387_constant_p
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|conval
operator|==
literal|1
condition|)
return|return
literal|"fldz"
return|;
if|if
condition|(
name|conval
operator|==
literal|2
condition|)
return|return
literal|"fld1"
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|long
name|l
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|XFmode
condition|)
name|abort
argument_list|()
expr_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|r
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|REAL_VALUE_TO_TARGET_SINGLE
argument_list|(
name|r
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|GEN_INT
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
return|return
name|singlemove_string
argument_list|(
name|operands
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Returns 1 if OP is either a symbol reference or a sum of a symbol    reference and a constant.  */
end_comment

begin_function
name|int
name|symbolic_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
return|return
literal|1
return|;
case|case
name|CONST
case|:
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|)
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Test for a valid operand for a call instruction.    Don't allow the arg pointer register or virtual regs    since they may change into reg + const, which the patterns    can't handle yet.  */
end_comment

begin_function
name|int
name|call_insn_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
operator|(
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
comment|/* This makes a difference for PIC.  */
operator|&&
name|general_operand
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
operator|!=
name|arg_pointer_rtx
operator|&&
operator|!
operator|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<=
name|LAST_VIRTUAL_REGISTER
operator|)
operator|)
operator|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Like call_insn_operand but allow (mem (symbol_ref ...))    even if pic.  */
end_comment

begin_function
name|int
name|expander_call_insn_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
operator|!=
name|arg_pointer_rtx
operator|&&
operator|!
operator|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<=
name|LAST_VIRTUAL_REGISTER
operator|)
operator|)
operator|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a comparison operator that can use the condition code    generated by an arithmetic operation. */
end_comment

begin_function
name|int
name|arithmetic_comparison_operator
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
decl_stmt|;
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|!=
literal|'<'
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|code
operator|!=
name|GT
operator|&&
name|code
operator|!=
name|LE
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Returns 1 if OP contains a symbol reference */
end_comment

begin_function
name|int
name|symbolic_reference_mentioned_p
parameter_list|(
name|op
parameter_list|)
name|rtx
name|op
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|LABEL_REF
condition|)
return|return
literal|1
return|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|op
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|symbolic_reference_mentioned_p
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|&&
name|symbolic_reference_mentioned_p
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This function generates the assembly code for function entry.    FILE is an stdio stream to output the code to.    SIZE is an int: how many units of temporary storage to allocate. */
end_comment

begin_function
name|void
name|function_prologue
parameter_list|(
name|file
parameter_list|,
name|size
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
specifier|register
name|int
name|regno
decl_stmt|;
name|int
name|limit
decl_stmt|;
name|rtx
name|xops
index|[
literal|4
index|]
decl_stmt|;
name|int
name|pic_reg_used
init|=
name|flag_pic
operator|&&
operator|(
name|current_function_uses_pic_offset_table
operator|||
name|current_function_uses_const_pool
operator|||
name|profile_flag
operator|||
name|profile_block_flag
operator|)
decl_stmt|;
name|xops
index|[
literal|0
index|]
operator|=
name|stack_pointer_rtx
expr_stmt|;
name|xops
index|[
literal|1
index|]
operator|=
name|frame_pointer_rtx
expr_stmt|;
name|xops
index|[
literal|2
index|]
operator|=
name|GEN_INT
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
name|output_asm_insn
argument_list|(
literal|"push%L1 %1"
argument_list|,
name|xops
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|mov
operator|%
name|L0
argument_list|,
operator|%
literal|0
argument_list|,
operator|%
literal|1
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|size
condition|)
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|sub
operator|%
name|L0
argument_list|,
operator|%
literal|2
argument_list|,
operator|%
literal|0
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
comment|/* Note If use enter it is NOT reversed args.      This one is not reversed from intel!!      I think enter is slower.  Also sdb doesn't like it.      But if you want it the code is:      {      xops[3] = const0_rtx;      output_asm_insn ("enter %2,%3", xops);      }      */
name|limit
operator|=
operator|(
name|frame_pointer_needed
condition|?
name|FRAME_POINTER_REGNUM
else|:
name|STACK_POINTER_REGNUM
operator|)
expr_stmt|;
for|for
control|(
name|regno
operator|=
name|limit
operator|-
literal|1
init|;
name|regno
operator|>=
literal|0
condition|;
name|regno
operator|--
control|)
if|if
condition|(
operator|(
name|regs_ever_live
index|[
name|regno
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|regno
index|]
operator|)
operator|||
operator|(
name|regno
operator|==
name|PIC_OFFSET_TABLE_REGNUM
operator|&&
name|pic_reg_used
operator|)
condition|)
block|{
name|xops
index|[
literal|0
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"push%L0 %0"
argument_list|,
name|xops
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pic_reg_used
condition|)
block|{
name|xops
index|[
literal|0
index|]
operator|=
name|pic_offset_table_rtx
expr_stmt|;
name|xops
index|[
literal|1
index|]
operator|=
operator|(
name|rtx
operator|)
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS1
argument_list|(
name|call
argument_list|,
operator|%
name|P1
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|file
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|xops
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS1
argument_list|(
name|pop
operator|%
name|L0
argument_list|,
operator|%
literal|0
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"addl $_GLOBAL_OFFSET_TABLE_+[.-%P1],%0"
argument_list|,
name|xops
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return 1 if it is appropriate to emit `ret' instructions in the    body of a function.  Do this only if the epilogue is simple, needing a    couple of insns.  Prior to reloading, we can't tell how many registers    must be saved, so return 0 then.     If NON_SAVING_SETJMP is defined and true, then it is not possible    for the epilogue to be simple, so return 0.  This is a special case    since NON_SAVING_SETJMP will not cause regs_ever_live to change until    final, but jump_optimize may need to know sooner if a `return' is OK.  */
end_comment

begin_function
name|int
name|simple_386_epilogue
parameter_list|()
block|{
name|int
name|regno
decl_stmt|;
name|int
name|nregs
init|=
literal|0
decl_stmt|;
name|int
name|reglimit
init|=
operator|(
name|frame_pointer_needed
condition|?
name|FRAME_POINTER_REGNUM
else|:
name|STACK_POINTER_REGNUM
operator|)
decl_stmt|;
ifdef|#
directive|ifdef
name|FUNCTION_PROFILER_EPILOGUE
if|if
condition|(
name|profile_flag
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
if|if
condition|(
name|flag_pic
operator|&&
operator|(
name|current_function_uses_pic_offset_table
operator|||
name|current_function_uses_const_pool
operator|||
name|profile_flag
operator|||
name|profile_block_flag
operator|)
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|NON_SAVING_SETJMP
if|if
condition|(
name|NON_SAVING_SETJMP
operator|&&
name|current_function_calls_setjmp
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|reload_completed
condition|)
return|return
literal|0
return|;
for|for
control|(
name|regno
operator|=
name|reglimit
operator|-
literal|1
init|;
name|regno
operator|>=
literal|0
condition|;
name|regno
operator|--
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|regno
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|regno
index|]
condition|)
name|nregs
operator|++
expr_stmt|;
return|return
name|nregs
operator|==
literal|0
operator|||
operator|!
name|frame_pointer_needed
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This function generates the assembly code for function exit.    FILE is an stdio stream to output the code to.    SIZE is an int: how many units of temporary storage to deallocate. */
end_comment

begin_function
name|void
name|function_epilogue
parameter_list|(
name|file
parameter_list|,
name|size
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
specifier|register
name|int
name|regno
decl_stmt|;
specifier|register
name|int
name|nregs
decl_stmt|,
name|limit
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|rtx
name|xops
index|[
literal|3
index|]
decl_stmt|;
name|int
name|pic_reg_used
init|=
name|flag_pic
operator|&&
operator|(
name|current_function_uses_pic_offset_table
operator|||
name|current_function_uses_const_pool
operator|)
decl_stmt|;
ifdef|#
directive|ifdef
name|FUNCTION_PROFILER_EPILOGUE
if|if
condition|(
name|profile_flag
condition|)
name|FUNCTION_PROFILER_EPILOGUE
argument_list|(
name|file
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Compute the number of registers to pop */
name|limit
operator|=
operator|(
name|frame_pointer_needed
condition|?
name|FRAME_POINTER_REGNUM
else|:
name|STACK_POINTER_REGNUM
operator|)
expr_stmt|;
name|nregs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|regno
operator|=
name|limit
operator|-
literal|1
init|;
name|regno
operator|>=
literal|0
condition|;
name|regno
operator|--
control|)
if|if
condition|(
operator|(
name|regs_ever_live
index|[
name|regno
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|regno
index|]
operator|)
operator|||
operator|(
name|regno
operator|==
name|PIC_OFFSET_TABLE_REGNUM
operator|&&
name|pic_reg_used
operator|)
condition|)
name|nregs
operator|++
expr_stmt|;
comment|/* sp is often  unreliable so we must go off the frame pointer,    */
comment|/* In reality, we may not care if sp is unreliable, because we can      restore the register relative to the frame pointer.  In theory,      since each move is the same speed as a pop, and we don't need the      leal, this is faster.  For now restore multiple registers the old      way. */
name|offset
operator|=
operator|-
name|size
operator|-
operator|(
name|nregs
operator|*
name|UNITS_PER_WORD
operator|)
expr_stmt|;
name|xops
index|[
literal|2
index|]
operator|=
name|stack_pointer_rtx
expr_stmt|;
if|if
condition|(
name|nregs
operator|>
literal|1
operator|||
operator|!
name|frame_pointer_needed
condition|)
block|{
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
name|xops
index|[
literal|0
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|AT_BP
argument_list|(
name|Pmode
argument_list|)
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|lea
operator|%
name|L2
argument_list|,
operator|%
literal|0
argument_list|,
operator|%
literal|2
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|limit
condition|;
name|regno
operator|++
control|)
if|if
condition|(
operator|(
name|regs_ever_live
index|[
name|regno
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|regno
index|]
operator|)
operator|||
operator|(
name|regno
operator|==
name|PIC_OFFSET_TABLE_REGNUM
operator|&&
name|pic_reg_used
operator|)
condition|)
block|{
name|xops
index|[
literal|0
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"pop%L0 %0"
argument_list|,
name|xops
argument_list|)
expr_stmt|;
block|}
block|}
else|else
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|limit
condition|;
name|regno
operator|++
control|)
if|if
condition|(
operator|(
name|regs_ever_live
index|[
name|regno
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|regno
index|]
operator|)
operator|||
operator|(
name|regno
operator|==
name|PIC_OFFSET_TABLE_REGNUM
operator|&&
name|pic_reg_used
operator|)
condition|)
block|{
name|xops
index|[
literal|0
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|xops
index|[
literal|1
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|AT_BP
argument_list|(
name|Pmode
argument_list|)
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|mov
operator|%
name|L0
argument_list|,
operator|%
literal|1
argument_list|,
operator|%
literal|0
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
comment|/* On i486, mov& pop is faster than "leave". */
if|if
condition|(
operator|!
name|TARGET_386
condition|)
block|{
name|xops
index|[
literal|0
index|]
operator|=
name|frame_pointer_rtx
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|mov
operator|%
name|L2
argument_list|,
operator|%
literal|0
argument_list|,
operator|%
literal|2
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"pop%L0 %0"
argument_list|,
name|xops
argument_list|)
expr_stmt|;
block|}
else|else
name|output_asm_insn
argument_list|(
literal|"leave"
argument_list|,
name|xops
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
condition|)
block|{
comment|/* If there is no frame pointer, we must still release the frame. */
name|xops
index|[
literal|0
index|]
operator|=
name|GEN_INT
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|add
operator|%
name|L2
argument_list|,
operator|%
literal|0
argument_list|,
operator|%
literal|2
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|current_function_pops_args
operator|&&
name|current_function_args_size
condition|)
block|{
name|xops
index|[
literal|1
index|]
operator|=
name|GEN_INT
argument_list|(
name|current_function_pops_args
argument_list|)
expr_stmt|;
comment|/* i386 can only pop 32K bytes (maybe 64K?  Is it signed?).  If 	 asked to pop more, pop return address, do explicit add, and jump 	 indirectly to the caller. */
if|if
condition|(
name|current_function_pops_args
operator|>=
literal|32768
condition|)
block|{
comment|/* ??? Which register to use here? */
name|xops
index|[
literal|0
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"pop%L0 %0"
argument_list|,
name|xops
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|add
operator|%
name|L2
argument_list|,
operator|%
literal|1
argument_list|,
operator|%
literal|2
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"jmp %*%0"
argument_list|,
name|xops
argument_list|)
expr_stmt|;
block|}
else|else
name|output_asm_insn
argument_list|(
literal|"ret %1"
argument_list|,
name|xops
argument_list|)
expr_stmt|;
block|}
else|else
name|output_asm_insn
argument_list|(
literal|"ret"
argument_list|,
name|xops
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression    that is a valid memory address for an instruction.    The MODE argument is the machine mode for the MEM expression    that wants to use this address.     On x86, legitimate addresses are: 	base				movl (base),reg 	displacement			movl disp,reg 	base + displacement		movl disp(base),reg 	index + base			movl (base,index),reg 	(index + base) + displacement	movl disp(base,index),reg 	index*scale			movl (,index,scale),reg 	index*scale + disp		movl disp(,index,scale),reg 	index*scale + base 		movl (base,index,scale),reg 	(index*scale + base) + disp	movl disp(base,index,scale),reg  	In each case, scale can be 1, 2, 4, 8.  */
end_comment

begin_comment
comment|/* This is exactly the same as print_operand_addr, except that    it recognizes addresses instead of printing them.     It only recognizes address in canonical form.  LEGITIMIZE_ADDRESS should    convert common non-canonical forms to canonical form so that they will    be recognized.  */
end_comment

begin_define
define|#
directive|define
name|ADDR_INVALID
parameter_list|(
name|msg
parameter_list|,
name|insn
parameter_list|)
define|\
value|do {									\   if (TARGET_DEBUG_ADDR)						\     {									\       fprintf (stderr, msg);						\       debug_rtx (insn);							\     }									\ } while (0)
end_define

begin_function
name|int
name|legitimate_address_p
parameter_list|(
name|mode
parameter_list|,
name|addr
parameter_list|,
name|strict
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
specifier|register
name|rtx
name|addr
decl_stmt|;
name|int
name|strict
decl_stmt|;
block|{
name|rtx
name|base
init|=
name|NULL_RTX
decl_stmt|;
name|rtx
name|indx
init|=
name|NULL_RTX
decl_stmt|;
name|rtx
name|scale
init|=
name|NULL_RTX
decl_stmt|;
name|rtx
name|disp
init|=
name|NULL_RTX
decl_stmt|;
if|if
condition|(
name|TARGET_DEBUG_ADDR
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n==========\nGO_IF_LEGITIMATE_ADDRESS, mode = %s, strict = %d\n"
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|mode
argument_list|)
argument_list|,
name|strict
argument_list|)
expr_stmt|;
name|debug_rtx
argument_list|(
name|addr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|SUBREG
condition|)
name|base
operator|=
name|addr
expr_stmt|;
comment|/* base reg */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|rtx
name|op0
init|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|enum
name|rtx_code
name|code0
init|=
name|GET_CODE
argument_list|(
name|op0
argument_list|)
decl_stmt|;
name|enum
name|rtx_code
name|code1
init|=
name|GET_CODE
argument_list|(
name|op1
argument_list|)
decl_stmt|;
if|if
condition|(
name|code0
operator|==
name|REG
operator|||
name|code0
operator|==
name|SUBREG
condition|)
block|{
if|if
condition|(
name|code1
operator|==
name|REG
operator|||
name|code1
operator|==
name|SUBREG
condition|)
block|{
name|indx
operator|=
name|op0
expr_stmt|;
comment|/* index + base */
name|base
operator|=
name|op1
expr_stmt|;
block|}
else|else
block|{
name|base
operator|=
name|op0
expr_stmt|;
comment|/* base + displacement */
name|disp
operator|=
name|op1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|code0
operator|==
name|MULT
condition|)
block|{
name|indx
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|scale
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|code1
operator|==
name|REG
operator|||
name|code1
operator|==
name|SUBREG
condition|)
name|base
operator|=
name|op1
expr_stmt|;
comment|/* index*scale + base */
else|else
name|disp
operator|=
name|op1
expr_stmt|;
comment|/* index*scale + disp */
block|}
elseif|else
if|if
condition|(
name|code0
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MULT
condition|)
block|{
name|indx
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* index*scale + base + disp */
name|scale
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|base
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|disp
operator|=
name|op1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code0
operator|==
name|PLUS
condition|)
block|{
name|indx
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* index + base + disp */
name|base
operator|=
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|disp
operator|=
name|op1
expr_stmt|;
block|}
else|else
block|{
name|ADDR_INVALID
argument_list|(
literal|"PLUS subcode is not valid.\n"
argument_list|,
name|op0
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|MULT
condition|)
block|{
name|indx
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* index*scale */
name|scale
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|disp
operator|=
name|addr
expr_stmt|;
comment|/* displacement */
comment|/* Allow arg pointer and stack pointer as index if there is not scaling */
if|if
condition|(
name|base
operator|&&
name|indx
operator|&&
operator|!
name|scale
operator|&&
operator|(
name|indx
operator|==
name|arg_pointer_rtx
operator|||
name|indx
operator|==
name|stack_pointer_rtx
operator|)
condition|)
block|{
name|rtx
name|tmp
init|=
name|base
decl_stmt|;
name|base
operator|=
name|indx
expr_stmt|;
name|indx
operator|=
name|tmp
expr_stmt|;
block|}
comment|/* Validate base register */
comment|/* Don't allow SUBREG's here, it can lead to spill failures when the base      is one word out of a two word structure, which is represented internally      as a DImode int.  */
if|if
condition|(
name|base
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|!=
name|REG
condition|)
block|{
name|ADDR_INVALID
argument_list|(
literal|"Base is not a register.\n"
argument_list|,
name|base
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|(
name|strict
operator|&&
operator|!
name|REG_OK_FOR_BASE_STRICT_P
argument_list|(
name|base
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|strict
operator|&&
operator|!
name|REG_OK_FOR_BASE_NONSTRICT_P
argument_list|(
name|base
argument_list|)
operator|)
condition|)
block|{
name|ADDR_INVALID
argument_list|(
literal|"Base is not valid.\n"
argument_list|,
name|base
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
comment|/* Validate index register */
comment|/* Don't allow SUBREG's here, it can lead to spill failures when the index      is one word out of a two word structure, which is represented internally      as a DImode int.  */
if|if
condition|(
name|indx
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|indx
argument_list|)
operator|!=
name|REG
condition|)
block|{
name|ADDR_INVALID
argument_list|(
literal|"Index is not a register.\n"
argument_list|,
name|indx
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|(
name|strict
operator|&&
operator|!
name|REG_OK_FOR_INDEX_STRICT_P
argument_list|(
name|indx
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|strict
operator|&&
operator|!
name|REG_OK_FOR_INDEX_NONSTRICT_P
argument_list|(
name|indx
argument_list|)
operator|)
condition|)
block|{
name|ADDR_INVALID
argument_list|(
literal|"Index is not valid.\n"
argument_list|,
name|indx
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|scale
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* scale w/o index invalid */
comment|/* Validate scale factor */
if|if
condition|(
name|scale
condition|)
block|{
name|HOST_WIDE_INT
name|value
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|scale
argument_list|)
operator|!=
name|CONST_INT
condition|)
block|{
name|ADDR_INVALID
argument_list|(
literal|"Scale is not valid.\n"
argument_list|,
name|scale
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|value
operator|=
name|INTVAL
argument_list|(
name|scale
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|1
operator|&&
name|value
operator|!=
literal|2
operator|&&
name|value
operator|!=
literal|4
operator|&&
name|value
operator|!=
literal|8
condition|)
block|{
name|ADDR_INVALID
argument_list|(
literal|"Scale is not a good multiplier.\n"
argument_list|,
name|scale
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
comment|/* Validate displacement */
if|if
condition|(
name|disp
condition|)
block|{
if|if
condition|(
operator|!
name|CONSTANT_ADDRESS_P
argument_list|(
name|disp
argument_list|)
condition|)
block|{
name|ADDR_INVALID
argument_list|(
literal|"Displacement is not valid.\n"
argument_list|,
name|disp
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|disp
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
name|ADDR_INVALID
argument_list|(
literal|"Displacement is a const_double.\n"
argument_list|,
name|disp
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|flag_pic
operator|&&
name|SYMBOLIC_CONST
argument_list|(
name|disp
argument_list|)
operator|&&
name|base
operator|!=
name|pic_offset_table_rtx
operator|&&
operator|(
name|indx
operator|!=
name|pic_offset_table_rtx
operator|||
name|scale
operator|!=
name|NULL_RTX
operator|)
condition|)
block|{
name|ADDR_INVALID
argument_list|(
literal|"Displacement is an invalid pic reference.\n"
argument_list|,
name|disp
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|HALF_PIC_P
argument_list|()
operator|&&
name|HALF_PIC_ADDRESS_P
argument_list|(
name|disp
argument_list|)
operator|&&
operator|(
name|base
operator|!=
name|NULL_RTX
operator|||
name|indx
operator|!=
name|NULL_RTX
operator|)
condition|)
block|{
name|ADDR_INVALID
argument_list|(
literal|"Displacement is an invalid half-pic reference.\n"
argument_list|,
name|disp
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
if|if
condition|(
name|TARGET_DEBUG_ADDR
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Address is valid.\n"
argument_list|)
expr_stmt|;
comment|/* Everything looks valid, return true */
return|return
name|TRUE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a legitimate reference for ORIG (an address) using the    register REG.  If REG is 0, a new pseudo is generated.     There are three types of references that must be handled:     1. Global data references must load the address from the GOT, via       the PIC reg.  An insn is emitted to do this load, and the reg is       returned.     2. Static data references must compute the address as an offset       from the GOT, whose base is in the PIC reg.  An insn is emitted to       compute the address into a reg, and the reg is returned.  Static       data objects have SYMBOL_REF_FLAG set to differentiate them from       global data objects.     3. Constant pool addresses must be handled special.  They are       considered legitimate addresses, but only if not used with regs.       When printed, the output routines know to print the reference with the       PIC reg, even though the PIC reg doesn't appear in the RTL.     GO_IF_LEGITIMATE_ADDRESS rejects symbolic references unless the PIC    reg also appears in the address (except for constant pool references,    noted above).     "switch" statements also require special handling when generating    PIC code.  See comments by the `casesi' insn in i386.md for details.  */
end_comment

begin_function
name|rtx
name|legitimize_pic_address
parameter_list|(
name|orig
parameter_list|,
name|reg
parameter_list|)
name|rtx
name|orig
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
block|{
name|rtx
name|addr
init|=
name|orig
decl_stmt|;
name|rtx
name|new
init|=
name|orig
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|LABEL_REF
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|addr
argument_list|)
condition|)
name|reg
operator|=
name|new
operator|=
name|orig
expr_stmt|;
else|else
block|{
if|if
condition|(
name|reg
operator|==
literal|0
condition|)
name|reg
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|SYMBOL_REF_FLAG
argument_list|(
name|addr
argument_list|)
operator|)
operator|||
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|LABEL_REF
condition|)
name|new
operator|=
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|orig
argument_list|)
expr_stmt|;
else|else
name|new
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|Pmode
argument_list|,
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|orig
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|new
argument_list|)
expr_stmt|;
block|}
name|current_function_uses_pic_offset_table
operator|=
literal|1
expr_stmt|;
return|return
name|reg
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|CONST
operator|||
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|rtx
name|base
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|CONST
condition|)
block|{
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|!=
name|PLUS
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
operator|==
name|pic_offset_table_rtx
condition|)
return|return
name|orig
return|;
if|if
condition|(
name|reg
operator|==
literal|0
condition|)
name|reg
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|base
operator|=
name|legitimize_pic_address
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|addr
operator|=
name|legitimize_pic_address
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|,
name|base
operator|==
name|reg
condition|?
name|NULL_RTX
else|:
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|plus_constant
argument_list|(
name|base
argument_list|,
name|INTVAL
argument_list|(
name|addr
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|base
operator|=
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|base
argument_list|,
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|base
argument_list|,
name|addr
argument_list|)
return|;
block|}
return|return
name|new
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit insns to move operands[1] into operands[0].  */
end_comment

begin_function
name|void
name|emit_pic_move
parameter_list|(
name|operands
parameter_list|,
name|mode
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|rtx
name|temp
init|=
name|reload_in_progress
condition|?
name|operands
index|[
literal|0
index|]
else|:
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|MEM
operator|&&
name|SYMBOLIC_CONST
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
name|operands
index|[
literal|1
index|]
operator|=
operator|(
name|rtx
operator|)
name|force_reg
argument_list|(
name|SImode
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
name|operands
index|[
literal|1
index|]
operator|=
name|legitimize_pic_address
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Try machine-dependent ways of modifying an illegitimate address    to be legitimate.  If we find one, return the new, valid address.    This macro is used in only one place: `memory_address' in explow.c.     OLDX is the address as it was before break_out_memory_refs was called.    In some cases it is useful to look at this to decide what needs to be done.     MODE and WIN are passed so that this macro can use    GO_IF_LEGITIMATE_ADDRESS.     It is always safe for this macro to do nothing.  It exists to recognize    opportunities to optimize the output.     For the 80386, we handle X+REG by loading X into a register R and    using R+REG.  R will go in a general reg and indexing will be used.    However, if REG is a broken-out memory address or multiplication,    nothing needs to be done because REG can certainly go in a general reg.     When -fpic is used, special handling is needed for symbolic references.    See comments by legitimize_pic_address in i386.c for details.  */
end_comment

begin_function
name|rtx
name|legitimize_address
parameter_list|(
name|x
parameter_list|,
name|oldx
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|x
decl_stmt|;
specifier|register
name|rtx
name|oldx
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|int
name|changed
init|=
literal|0
decl_stmt|;
name|unsigned
name|log
decl_stmt|;
if|if
condition|(
name|TARGET_DEBUG_ADDR
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n==========\nLEGITIMIZE_ADDRESS, mode = %s\n"
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
name|debug_rtx
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_pic
operator|&&
name|SYMBOLIC_CONST
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|legitimize_pic_address
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
return|;
comment|/* Canonicalize shifts by 0, 1, 2, 3 into multiply */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|ASHIFT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|log
operator|=
operator|(
name|unsigned
operator|)
name|exact_log2
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|<
literal|4
condition|)
block|{
name|changed
operator|=
literal|1
expr_stmt|;
name|x
operator|=
name|gen_rtx
argument_list|(
name|MULT
argument_list|,
name|Pmode
argument_list|,
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
literal|1
operator|<<
name|log
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
condition|)
block|{
comment|/* Canonicalize shifts by 0, 1, 2, 3 into multiply */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ASHIFT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|log
operator|=
operator|(
name|unsigned
operator|)
name|exact_log2
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|<
literal|4
condition|)
block|{
name|changed
operator|=
literal|1
expr_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|MULT
argument_list|,
name|Pmode
argument_list|,
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
literal|1
operator|<<
name|log
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|ASHIFT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|log
operator|=
operator|(
name|unsigned
operator|)
name|exact_log2
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|<
literal|4
condition|)
block|{
name|changed
operator|=
literal|1
expr_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|MULT
argument_list|,
name|Pmode
argument_list|,
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
literal|1
operator|<<
name|log
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Put multiply first if it isn't already */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|MULT
condition|)
block|{
name|rtx
name|tmp
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|=
name|tmp
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Canonicalize (plus (mult (reg) (const)) (plus (reg) (const))) 	 into (plus (plus (mult (reg) (const)) (reg)) (const)).  This can be 	 created by virtual register instantiation, register elimination, and 	 similar optimizations.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MULT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|changed
operator|=
literal|1
expr_stmt|;
name|x
operator|=
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Canonicalize (plus (plus (mult (reg) (const)) (plus (reg) (const))) const) 	 into (plus (plus (mult (reg) (const)) (reg)) (const)).  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MULT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|constant
decl_stmt|,
name|other
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|constant
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|other
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|constant
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|other
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|constant
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|constant
condition|)
block|{
name|changed
operator|=
literal|1
expr_stmt|;
name|x
operator|=
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|Pmode
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|plus_constant
argument_list|(
name|other
argument_list|,
name|INTVAL
argument_list|(
name|constant
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|changed
operator|&&
name|legitimate_address_p
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
name|FALSE
argument_list|)
condition|)
return|return
name|x
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MULT
condition|)
block|{
name|changed
operator|=
literal|1
expr_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|MULT
condition|)
block|{
name|changed
operator|=
literal|1
expr_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|=
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|changed
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
return|return
name|x
return|;
if|if
condition|(
name|flag_pic
operator|&&
name|SYMBOLIC_CONST
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|changed
operator|=
literal|1
expr_stmt|;
name|x
operator|=
name|legitimize_pic_address
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|changed
operator|&&
name|legitimate_address_p
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
name|FALSE
argument_list|)
condition|)
return|return
name|x
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
specifier|register
name|rtx
name|temp
init|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
specifier|register
name|rtx
name|val
init|=
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|temp
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|!=
name|temp
condition|)
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|=
name|temp
expr_stmt|;
return|return
name|x
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
specifier|register
name|rtx
name|temp
init|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
specifier|register
name|rtx
name|val
init|=
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|temp
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|!=
name|temp
condition|)
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|temp
expr_stmt|;
return|return
name|x
return|;
block|}
block|}
return|return
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print an integer constant expression in assembler syntax.  Addition    and subtraction are the only arithmetic that may appear in these    expressions.  FILE is the stdio stream to write to, X is the rtx, and    CODE is the operand print code from the output string.  */
end_comment

begin_function
specifier|static
name|void
name|output_pic_addr_const
parameter_list|(
name|file
parameter_list|,
name|x
parameter_list|,
name|code
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|int
name|code
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|PC
case|:
if|if
condition|(
name|flag_pic
condition|)
name|putc
argument_list|(
literal|'.'
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
break|break;
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
name|assemble_name
argument_list|(
name|file
argument_list|,
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|asm_out_file
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|x
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"@GOTOFF(%%ebx)"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
literal|'P'
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"@PLT"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LABEL_REF
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"@GOTOFF"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|SYMBOL_REF_FLAG
argument_list|(
name|x
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"@GOT"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"@GOTOFF"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CODE_LABEL
case|:
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|asm_out_file
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST_INT
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST
case|:
comment|/* This used to output parentheses around the expression, 	 but that does not work on the 386 (either ATT or BSD assembler).  */
name|output_pic_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|code
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST_DOUBLE
case|:
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|VOIDmode
condition|)
block|{
comment|/* We can use %d if the number is<32 bits and positive.  */
if|if
condition|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
operator|||
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0x%x%08x"
argument_list|,
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
argument_list|,
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* We can't handle floating point constants; 	   PRINT_OPERAND must handle them.  */
name|output_operand_lossage
argument_list|(
literal|"floating constant misused"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PLUS
case|:
comment|/* Some assemblers need integer constants to appear last (eg masm).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|output_pic_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"+"
argument_list|)
expr_stmt|;
name|output_pic_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|code
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|output_pic_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"+"
argument_list|)
expr_stmt|;
name|output_pic_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|code
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|MINUS
case|:
name|output_pic_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
name|output_pic_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|code
argument_list|)
expr_stmt|;
break|break;
default|default:
name|output_operand_lossage
argument_list|(
literal|"invalid expression as operand"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Meaning of CODE:    f -- float insn (print a CONST_DOUBLE as a float rather than in hex).    D,L,W,B,Q,S -- print the opcode suffix for specified size of operand.    R -- print the prefix for register names.    z -- print the opcode suffix for the size of the current operand.    * -- print a star (in certain assembler syntax)    w -- print the operand as if it's a "word" (HImode) even if it isn't.    c -- don't print special prefixes before constant operands.    J -- print the appropriate jump operand. */
end_comment

begin_function
name|void
name|print_operand
parameter_list|(
name|file
parameter_list|,
name|x
parameter_list|,
name|code
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|int
name|code
decl_stmt|;
block|{
if|if
condition|(
name|code
condition|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
literal|'*'
case|:
if|if
condition|(
name|USE_STAR
condition|)
name|putc
argument_list|(
literal|'*'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'L'
case|:
name|PUT_OP_SIZE
argument_list|(
name|code
argument_list|,
literal|'l'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'W'
case|:
name|PUT_OP_SIZE
argument_list|(
name|code
argument_list|,
literal|'w'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'B'
case|:
name|PUT_OP_SIZE
argument_list|(
name|code
argument_list|,
literal|'b'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'Q'
case|:
name|PUT_OP_SIZE
argument_list|(
name|code
argument_list|,
literal|'l'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'S'
case|:
name|PUT_OP_SIZE
argument_list|(
name|code
argument_list|,
literal|'s'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'T'
case|:
name|PUT_OP_SIZE
argument_list|(
name|code
argument_list|,
literal|'t'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'z'
case|:
comment|/* 387 opcodes don't get size suffixes if the operands are 	     registers. */
if|if
condition|(
name|STACK_REG_P
argument_list|(
name|x
argument_list|)
condition|)
return|return;
comment|/* this is the size of op from size of operand */
switch|switch
condition|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
name|PUT_OP_SIZE
argument_list|(
literal|'B'
argument_list|,
literal|'b'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|2
case|:
name|PUT_OP_SIZE
argument_list|(
literal|'W'
argument_list|,
literal|'w'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|4
case|:
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|SFmode
condition|)
block|{
name|PUT_OP_SIZE
argument_list|(
literal|'S'
argument_list|,
literal|'s'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|PUT_OP_SIZE
argument_list|(
literal|'L'
argument_list|,
literal|'l'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|12
case|:
name|PUT_OP_SIZE
argument_list|(
literal|'T'
argument_list|,
literal|'t'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|8
case|:
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MODE_INT
condition|)
block|{
ifdef|#
directive|ifdef
name|GAS_MNEMONICS
name|PUT_OP_SIZE
argument_list|(
literal|'Q'
argument_list|,
literal|'q'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
else|#
directive|else
name|PUT_OP_SIZE
argument_list|(
literal|'Q'
argument_list|,
literal|'l'
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* Fall through */
endif|#
directive|endif
block|}
name|PUT_OP_SIZE
argument_list|(
literal|'Q'
argument_list|,
literal|'l'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
literal|'b'
case|:
case|case
literal|'w'
case|:
case|case
literal|'k'
case|:
case|case
literal|'h'
case|:
case|case
literal|'y'
case|:
case|case
literal|'P'
case|:
break|break;
case|case
literal|'J'
case|:
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
comment|/* These conditions are appropriate for testing the result 		 of an arithmetic operation, not for a compare operation. 	         Cases GE, LT assume CC_NO_OVERFLOW true. All cases assume 		 CC_Z_IN_NOT_C false and not floating point.  */
case|case
name|NE
case|:
name|fputs
argument_list|(
literal|"jne"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
name|EQ
case|:
name|fputs
argument_list|(
literal|"je"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
name|GE
case|:
name|fputs
argument_list|(
literal|"jns"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
name|LT
case|:
name|fputs
argument_list|(
literal|"js"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
name|GEU
case|:
name|fputs
argument_list|(
literal|"jmp"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
name|GTU
case|:
name|fputs
argument_list|(
literal|"jne"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
name|LEU
case|:
name|fputs
argument_list|(
literal|"je"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
name|LTU
case|:
name|fputs
argument_list|(
literal|"#branch never"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
comment|/* no matching branches for GT nor LE */
block|}
name|abort
argument_list|()
expr_stmt|;
default|default:
block|{
name|char
name|str
index|[
literal|50
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|str
argument_list|,
literal|"invalid operand code `%c'"
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|output_operand_lossage
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
block|{
name|PRINT_REG
argument_list|(
name|x
argument_list|,
name|code
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|PRINT_PTR
argument_list|(
name|x
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|flag_pic
condition|)
name|output_pic_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|code
argument_list|)
expr_stmt|;
else|else
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|output_address
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|SFmode
condition|)
block|{
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|long
name|l
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|r
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|REAL_VALUE_TO_TARGET_SINGLE
argument_list|(
name|r
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|PRINT_IMMED_PREFIX
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0x%x"
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
comment|/* These float cases don't actually occur as immediate operands. */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|DFmode
condition|)
block|{
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|char
name|dstr
index|[
literal|30
index|]
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|r
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|REAL_VALUE_TO_DECIMAL
argument_list|(
name|r
argument_list|,
literal|"%.22e"
argument_list|,
name|dstr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|dstr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|XFmode
condition|)
block|{
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|char
name|dstr
index|[
literal|30
index|]
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|r
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|REAL_VALUE_TO_DECIMAL
argument_list|(
name|r
argument_list|,
literal|"%.22e"
argument_list|,
name|dstr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|dstr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|code
operator|!=
literal|'P'
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
name|PRINT_IMMED_PREFIX
argument_list|(
name|file
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LABEL_REF
condition|)
name|PRINT_OFFSET_PREFIX
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_pic
condition|)
name|output_pic_addr_const
argument_list|(
name|file
argument_list|,
name|x
argument_list|,
name|code
argument_list|)
expr_stmt|;
else|else
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print a memory operand whose address is ADDR.  */
end_comment

begin_function
name|void
name|print_operand_address
parameter_list|(
name|file
parameter_list|,
name|addr
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
specifier|register
name|rtx
name|addr
decl_stmt|;
block|{
specifier|register
name|rtx
name|reg1
decl_stmt|,
name|reg2
decl_stmt|,
name|breg
decl_stmt|,
name|ireg
decl_stmt|;
name|rtx
name|offset
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
condition|)
block|{
case|case
name|REG
case|:
name|ADDR_BEG
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%se"
argument_list|,
name|RP
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|hi_reg_name
index|[
name|REGNO
argument_list|(
name|addr
argument_list|)
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|ADDR_END
argument_list|(
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|PLUS
case|:
name|reg1
operator|=
literal|0
expr_stmt|;
name|reg2
operator|=
literal|0
expr_stmt|;
name|ireg
operator|=
literal|0
expr_stmt|;
name|breg
operator|=
literal|0
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|offset
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CONSTANT_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|offset
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|!=
name|PLUS
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MULT
condition|)
block|{
name|reg1
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|MULT
condition|)
block|{
name|reg1
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|reg1
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|reg1
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|MULT
condition|)
block|{
if|if
condition|(
name|reg1
operator|==
literal|0
condition|)
name|reg1
operator|=
name|addr
expr_stmt|;
else|else
name|reg2
operator|=
name|addr
expr_stmt|;
name|addr
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|offset
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|addr
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|addr
operator|=
name|offset
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|reg1
operator|&&
name|GET_CODE
argument_list|(
name|reg1
argument_list|)
operator|==
name|MULT
operator|)
operator|||
operator|(
name|reg2
operator|!=
literal|0
operator|&&
name|REGNO_OK_FOR_BASE_P
argument_list|(
name|REGNO
argument_list|(
name|reg2
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|breg
operator|=
name|reg2
expr_stmt|;
name|ireg
operator|=
name|reg1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reg1
operator|!=
literal|0
operator|&&
name|REGNO_OK_FOR_BASE_P
argument_list|(
name|REGNO
argument_list|(
name|reg1
argument_list|)
argument_list|)
condition|)
block|{
name|breg
operator|=
name|reg1
expr_stmt|;
name|ireg
operator|=
name|reg2
expr_stmt|;
block|}
if|if
condition|(
name|ireg
operator|!=
literal|0
operator|||
name|breg
operator|!=
literal|0
condition|)
block|{
name|int
name|scale
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|addr
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|flag_pic
condition|)
name|output_pic_addr_const
argument_list|(
name|file
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|LABEL_REF
condition|)
name|output_asm_label
argument_list|(
name|addr
argument_list|)
expr_stmt|;
else|else
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ireg
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|ireg
argument_list|)
operator|==
name|MULT
condition|)
block|{
name|scale
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|ireg
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|ireg
operator|=
name|XEXP
argument_list|(
name|ireg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* The stack pointer can only appear as a base register, 	     never an index register, so exchange the regs if it is wrong. */
if|if
condition|(
name|scale
operator|==
literal|1
operator|&&
name|ireg
operator|&&
name|REGNO
argument_list|(
name|ireg
argument_list|)
operator|==
name|STACK_POINTER_REGNUM
condition|)
block|{
name|rtx
name|tmp
decl_stmt|;
name|tmp
operator|=
name|breg
expr_stmt|;
name|breg
operator|=
name|ireg
expr_stmt|;
name|ireg
operator|=
name|tmp
expr_stmt|;
block|}
comment|/* output breg+ireg*scale */
name|PRINT_B_I_S
argument_list|(
name|breg
argument_list|,
name|ireg
argument_list|,
name|scale
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|MULT
case|:
block|{
name|int
name|scale
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|scale
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|ireg
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|scale
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|ireg
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|PRINT_B_I_S
argument_list|(
operator|(
name|rtx
operator|)
literal|0
argument_list|,
name|ireg
argument_list|,
name|scale
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|addr
argument_list|)
operator|<
literal|0x8000
operator|&&
name|INTVAL
argument_list|(
name|addr
argument_list|)
operator|>=
operator|-
literal|0x8000
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|INTVAL
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|flag_pic
condition|)
name|output_pic_addr_const
argument_list|(
name|file
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Set the cc_status for the results of an insn whose pattern is EXP.    On the 80386, we assume that only test and compare insns, as well    as SI, HI,& DI mode ADD, SUB, NEG, AND, IOR, XOR, ASHIFT,    ASHIFTRT, and LSHIFTRT instructions set the condition codes usefully.    Also, we assume that jumps, moves and sCOND don't affect the condition    codes.  All else clobbers the condition codes, by assumption.     We assume that ALL integer add, minus, etc. instructions effect the    condition codes.  This MUST be consistent with i386.md.     We don't record any float test or compare - the redundant test&    compare check in final.c does not handle stack-like regs correctly. */
end_comment

begin_function
name|void
name|notice_update_cc
parameter_list|(
name|exp
parameter_list|)
name|rtx
name|exp
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|SET
condition|)
block|{
comment|/* Jumps do not alter the cc's.  */
if|if
condition|(
name|SET_DEST
argument_list|(
name|exp
argument_list|)
operator|==
name|pc_rtx
condition|)
return|return;
comment|/* Moving register or memory into a register: 	 it doesn't alter the cc's, but it might invalidate 	 the RTX's which we remember the cc's came from. 	 (Note that moving a constant 0 or 1 MAY set the cc's).  */
if|if
condition|(
name|REG_P
argument_list|(
name|SET_DEST
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|&&
operator|(
name|REG_P
argument_list|(
name|SET_SRC
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|MEM
operator|||
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'<'
operator|)
condition|)
block|{
if|if
condition|(
name|cc_status
operator|.
name|value1
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|SET_DEST
argument_list|(
name|exp
argument_list|)
argument_list|,
name|cc_status
operator|.
name|value1
argument_list|)
condition|)
name|cc_status
operator|.
name|value1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cc_status
operator|.
name|value2
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|SET_DEST
argument_list|(
name|exp
argument_list|)
argument_list|,
name|cc_status
operator|.
name|value2
argument_list|)
condition|)
name|cc_status
operator|.
name|value2
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* Moving register into memory doesn't alter the cc's. 	 It may invalidate the RTX's which we remember the cc's came from.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
name|REG_P
argument_list|(
name|SET_SRC
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|||
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'<'
operator|)
condition|)
block|{
if|if
condition|(
name|cc_status
operator|.
name|value1
operator|&&
name|GET_CODE
argument_list|(
name|cc_status
operator|.
name|value1
argument_list|)
operator|==
name|MEM
condition|)
name|cc_status
operator|.
name|value1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cc_status
operator|.
name|value2
operator|&&
name|GET_CODE
argument_list|(
name|cc_status
operator|.
name|value2
argument_list|)
operator|==
name|MEM
condition|)
name|cc_status
operator|.
name|value2
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* Function calls clobber the cc's.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|CALL
condition|)
block|{
name|CC_STATUS_INIT
expr_stmt|;
return|return;
block|}
comment|/* Tests and compares set the cc's in predictable ways.  */
elseif|else
if|if
condition|(
name|SET_DEST
argument_list|(
name|exp
argument_list|)
operator|==
name|cc0_rtx
condition|)
block|{
name|CC_STATUS_INIT
expr_stmt|;
name|cc_status
operator|.
name|value1
operator|=
name|SET_SRC
argument_list|(
name|exp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Certain instructions effect the condition codes. */
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|SImode
operator|||
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|HImode
operator|||
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|QImode
condition|)
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|ASHIFTRT
case|:
case|case
name|LSHIFTRT
case|:
case|case
name|ASHIFT
case|:
comment|/* Shifts on the 386 don't set the condition codes if the 	       shift count is zero. */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|exp
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
block|{
name|CC_STATUS_INIT
expr_stmt|;
break|break;
block|}
comment|/* We assume that the CONST_INT is non-zero (this rtx would 	       have been deleted if it were zero. */
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
case|case
name|NEG
case|:
case|case
name|AND
case|:
case|case
name|IOR
case|:
case|case
name|XOR
case|:
name|cc_status
operator|.
name|flags
operator|=
name|CC_NO_OVERFLOW
expr_stmt|;
name|cc_status
operator|.
name|value1
operator|=
name|SET_SRC
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|cc_status
operator|.
name|value2
operator|=
name|SET_DEST
argument_list|(
name|exp
argument_list|)
expr_stmt|;
break|break;
default|default:
name|CC_STATUS_INIT
expr_stmt|;
block|}
else|else
block|{
name|CC_STATUS_INIT
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
block|{
if|if
condition|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|pc_rtx
condition|)
return|return;
if|if
condition|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|cc0_rtx
condition|)
block|{
name|CC_STATUS_INIT
expr_stmt|;
if|if
condition|(
name|stack_regs_mentioned_p
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
name|cc_status
operator|.
name|flags
operator||=
name|CC_IN_80387
expr_stmt|;
else|else
name|cc_status
operator|.
name|value1
operator|=
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|CC_STATUS_INIT
expr_stmt|;
block|}
else|else
block|{
name|CC_STATUS_INIT
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Split one or more DImode RTL references into pairs of SImode    references.  The RTL can be REG, offsettable MEM, integer constant, or    CONST_DOUBLE.  "operands" is a pointer to an array of DImode RTL to    split and "num" is its length.  lo_half and hi_half are output arrays    that parallel "operands". */
end_comment

begin_decl_stmt
name|void
name|split_di
argument_list|(
name|operands
argument_list|,
name|num
argument_list|,
name|lo_half
argument_list|,
name|hi_half
argument_list|)
name|rtx
name|operands
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|num
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|lo_half
index|[]
decl_stmt|,
name|hi_half
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
name|num
operator|--
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
name|num
index|]
argument_list|)
operator|==
name|REG
condition|)
block|{
name|lo_half
index|[
name|num
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
name|num
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|hi_half
index|[
name|num
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
name|num
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|operands
index|[
name|num
index|]
argument_list|)
condition|)
block|{
name|split_double
argument_list|(
name|operands
index|[
name|num
index|]
argument_list|,
operator|&
name|lo_half
index|[
name|num
index|]
argument_list|,
operator|&
name|hi_half
index|[
name|num
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|offsettable_memref_p
argument_list|(
name|operands
index|[
name|num
index|]
argument_list|)
condition|)
block|{
name|lo_half
index|[
name|num
index|]
operator|=
name|operands
index|[
name|num
index|]
expr_stmt|;
name|hi_half
index|[
name|num
index|]
operator|=
name|adj_offsettable_operand
argument_list|(
name|operands
index|[
name|num
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Return 1 if this is a valid binary operation on a 387.    OP is the expression matched, and MODE is its mode. */
end_comment

begin_function
name|int
name|binary_387_op
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
case|case
name|MULT
case|:
case|case
name|DIV
case|:
return|return
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if this is a valid shift or rotate operation on a 386.    OP is the expression matched, and MODE is its mode. */
end_comment

begin_function
name|int
name|shift_op
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|rtx
name|operand
init|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|operand
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|||
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|!=
name|MODE_INT
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|ASHIFT
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|ASHIFTRT
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|LSHIFTRT
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|ROTATE
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|ROTATERT
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is COMPARE rtx with mode VOIDmode.    MODE is not used.  */
end_comment

begin_function
name|int
name|VOIDmode_compare_op
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|COMPARE
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|VOIDmode
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output code to perform a 387 binary operation in INSN, one of PLUS,    MINUS, MULT or DIV.  OPERANDS are the insn operands, where operands[3]    is the expression of the binary operation.  The output may either be    emitted here, or returned to the caller, like all output_* functions.     There is no guarantee that the operands are the same mode, as they    might be within FLOAT or FLOAT_EXTEND expressions. */
end_comment

begin_function
name|char
modifier|*
name|output_387_binary_op
parameter_list|(
name|insn
parameter_list|,
name|operands
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
name|rtx
name|temp
decl_stmt|;
name|char
modifier|*
name|base_op
decl_stmt|;
specifier|static
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
case|case
name|PLUS
case|:
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|||
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
argument_list|)
operator|==
name|MODE_INT
condition|)
name|base_op
operator|=
literal|"fiadd"
expr_stmt|;
else|else
name|base_op
operator|=
literal|"fadd"
expr_stmt|;
break|break;
case|case
name|MINUS
case|:
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|||
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
argument_list|)
operator|==
name|MODE_INT
condition|)
name|base_op
operator|=
literal|"fisub"
expr_stmt|;
else|else
name|base_op
operator|=
literal|"fsub"
expr_stmt|;
break|break;
case|case
name|MULT
case|:
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|||
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
argument_list|)
operator|==
name|MODE_INT
condition|)
name|base_op
operator|=
literal|"fimul"
expr_stmt|;
else|else
name|base_op
operator|=
literal|"fmul"
expr_stmt|;
break|break;
case|case
name|DIV
case|:
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|||
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
argument_list|)
operator|==
name|MODE_INT
condition|)
name|base_op
operator|=
literal|"fidiv"
expr_stmt|;
else|else
name|base_op
operator|=
literal|"fdiv"
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|buf
argument_list|,
name|base_op
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
case|case
name|MULT
case|:
case|case
name|PLUS
case|:
if|if
condition|(
name|REG_P
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|REGNO
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
name|temp
operator|=
name|operands
index|[
literal|2
index|]
expr_stmt|;
name|operands
index|[
literal|2
index|]
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|temp
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|==
name|MEM
condition|)
return|return
name|strcat
argument_list|(
name|buf
argument_list|,
name|AS1
argument_list|(
operator|%
name|z2
argument_list|,
operator|%
literal|2
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|NON_STACK_REG_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|output_op_from_reg
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|strcat
argument_list|(
name|buf
argument_list|,
name|AS1
argument_list|(
operator|%
name|z0
argument_list|,
operator|%
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|RET
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|NON_STACK_REG_P
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
name|output_op_from_reg
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|,
name|strcat
argument_list|(
name|buf
argument_list|,
name|AS1
argument_list|(
operator|%
name|z0
argument_list|,
operator|%
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|RET
expr_stmt|;
block|}
if|if
condition|(
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
argument_list|)
condition|)
return|return
name|strcat
argument_list|(
name|buf
argument_list|,
name|AS2
argument_list|(
name|p
argument_list|,
operator|%
literal|2
argument_list|,
operator|%
literal|0
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|STACK_TOP_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
name|strcat
argument_list|(
name|buf
argument_list|,
name|AS2C
argument_list|(
operator|%
name|y2
argument_list|,
operator|%
literal|0
argument_list|)
argument_list|)
return|;
else|else
return|return
name|strcat
argument_list|(
name|buf
argument_list|,
name|AS2C
argument_list|(
operator|%
literal|2
argument_list|,
operator|%
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|MINUS
case|:
case|case
name|DIV
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|MEM
condition|)
return|return
name|strcat
argument_list|(
name|buf
argument_list|,
name|AS1
argument_list|(
name|r
operator|%
name|z1
argument_list|,
operator|%
literal|1
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|==
name|MEM
condition|)
return|return
name|strcat
argument_list|(
name|buf
argument_list|,
name|AS1
argument_list|(
operator|%
name|z2
argument_list|,
operator|%
literal|2
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|NON_STACK_REG_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|output_op_from_reg
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|strcat
argument_list|(
name|buf
argument_list|,
name|AS1
argument_list|(
name|r
operator|%
name|z0
argument_list|,
operator|%
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|RET
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|NON_STACK_REG_P
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
name|output_op_from_reg
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|,
name|strcat
argument_list|(
name|buf
argument_list|,
name|AS1
argument_list|(
operator|%
name|z0
argument_list|,
operator|%
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|RET
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|STACK_REG_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|||
operator|!
name|STACK_REG_P
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
argument_list|)
condition|)
return|return
name|strcat
argument_list|(
name|buf
argument_list|,
name|AS2
argument_list|(
name|rp
argument_list|,
operator|%
literal|2
argument_list|,
operator|%
literal|0
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
condition|)
return|return
name|strcat
argument_list|(
name|buf
argument_list|,
name|AS2
argument_list|(
name|p
argument_list|,
operator|%
literal|1
argument_list|,
operator|%
literal|0
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|STACK_TOP_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|STACK_TOP_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
return|return
name|strcat
argument_list|(
name|buf
argument_list|,
name|AS2C
argument_list|(
operator|%
name|y2
argument_list|,
operator|%
literal|0
argument_list|)
argument_list|)
return|;
else|else
return|return
name|strcat
argument_list|(
name|buf
argument_list|,
name|AS2
argument_list|(
name|r
argument_list|,
operator|%
name|y1
argument_list|,
operator|%
literal|0
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|STACK_TOP_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
return|return
name|strcat
argument_list|(
name|buf
argument_list|,
name|AS2C
argument_list|(
operator|%
literal|1
argument_list|,
operator|%
literal|0
argument_list|)
argument_list|)
return|;
else|else
return|return
name|strcat
argument_list|(
name|buf
argument_list|,
name|AS2
argument_list|(
name|r
argument_list|,
operator|%
literal|2
argument_list|,
operator|%
literal|0
argument_list|)
argument_list|)
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output code for INSN to convert a float to a signed int.  OPERANDS    are the insn operands.  The output may be SFmode or DFmode and the    input operand may be SImode or DImode.  As a special case, make sure    that the 387 stack top dies if the output mode is DImode, because the    hardware requires this.  */
end_comment

begin_function
name|char
modifier|*
name|output_fix_trunc
parameter_list|(
name|insn
parameter_list|,
name|operands
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
name|int
name|stack_top_dies
init|=
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|FIRST_STACK_REG
argument_list|)
operator|!=
literal|0
decl_stmt|;
name|rtx
name|xops
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|STACK_TOP_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|||
operator|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|DImode
operator|&&
operator|!
name|stack_top_dies
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|xops
index|[
literal|0
index|]
operator|=
name|GEN_INT
argument_list|(
literal|12
argument_list|)
expr_stmt|;
name|xops
index|[
literal|1
index|]
operator|=
name|operands
index|[
literal|4
index|]
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS1
argument_list|(
name|fnstc
operator|%
name|W2
argument_list|,
operator|%
literal|2
argument_list|)
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|mov
operator|%
name|L2
argument_list|,
operator|%
literal|2
argument_list|,
operator|%
literal|4
argument_list|)
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|mov
operator|%
name|B1
argument_list|,
operator|%
literal|0
argument_list|,
operator|%
name|h1
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|mov
operator|%
name|L4
argument_list|,
operator|%
literal|4
argument_list|,
operator|%
literal|3
argument_list|)
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS1
argument_list|(
name|fldc
operator|%
name|W3
argument_list|,
operator|%
literal|3
argument_list|)
argument_list|,
name|operands
argument_list|)
expr_stmt|;
if|if
condition|(
name|NON_STACK_REG_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
name|output_to_reg
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|stack_top_dies
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
name|stack_top_dies
condition|)
name|output_asm_insn
argument_list|(
name|AS1
argument_list|(
name|fistp
operator|%
name|z0
argument_list|,
operator|%
literal|0
argument_list|)
argument_list|,
name|operands
argument_list|)
expr_stmt|;
else|else
name|output_asm_insn
argument_list|(
name|AS1
argument_list|(
name|fist
operator|%
name|z0
argument_list|,
operator|%
literal|0
argument_list|)
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
return|return
name|AS1
argument_list|(
name|fldc
operator|%
name|W2
argument_list|,
operator|%
literal|2
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output code for INSN to compare OPERANDS.  The two operands might    not have the same mode: one might be within a FLOAT or FLOAT_EXTEND    expression.  If the compare is in mode CCFPEQmode, use an opcode that    will not fault if a qNaN is present. */
end_comment

begin_function
name|char
modifier|*
name|output_float_compare
parameter_list|(
name|insn
parameter_list|,
name|operands
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
name|int
name|stack_top_dies
decl_stmt|;
name|rtx
name|body
init|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|unordered_compare
init|=
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|CCFPEQmode
decl_stmt|;
if|if
condition|(
operator|!
name|STACK_TOP_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|stack_top_dies
operator|=
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|FIRST_STACK_REG
argument_list|)
operator|!=
literal|0
expr_stmt|;
if|if
condition|(
name|STACK_REG_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|&&
name|stack_top_dies
operator|&&
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|!=
name|FIRST_STACK_REG
condition|)
block|{
comment|/* If both the top of the 387 stack dies, and the other operand 	 is also a stack register that dies, then this must be a 	 `fcompp' float compare */
if|if
condition|(
name|unordered_compare
condition|)
name|output_asm_insn
argument_list|(
literal|"fucompp"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
else|else
name|output_asm_insn
argument_list|(
literal|"fcompp"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|static
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
comment|/* Decide if this is the integer or float compare opcode, or the 	 unordered float compare. */
if|if
condition|(
name|unordered_compare
condition|)
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"fucom"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"fcom"
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"ficom"
argument_list|)
expr_stmt|;
comment|/* Modify the opcode if the 387 stack is to be popped. */
if|if
condition|(
name|stack_top_dies
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"p"
argument_list|)
expr_stmt|;
if|if
condition|(
name|NON_STACK_REG_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
name|output_op_from_reg
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|strcat
argument_list|(
name|buf
argument_list|,
name|AS1
argument_list|(
operator|%
name|z0
argument_list|,
operator|%
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|output_asm_insn
argument_list|(
name|strcat
argument_list|(
name|buf
argument_list|,
name|AS1
argument_list|(
operator|%
name|z1
argument_list|,
operator|%
name|y1
argument_list|)
argument_list|)
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
comment|/* Now retrieve the condition code. */
return|return
name|output_fp_cc0_set
argument_list|(
name|insn
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output opcodes to transfer the results of FP compare or test INSN    from the FPU to the CPU flags.  If TARGET_IEEE_FP, ensure that if the    result of the compare or test is unordered, no comparison operator    succeeds except NE.  Return an output template, if any.  */
end_comment

begin_function
name|char
modifier|*
name|output_fp_cc0_set
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|xops
index|[
literal|3
index|]
decl_stmt|;
name|rtx
name|unordered_label
decl_stmt|;
name|rtx
name|next
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
name|xops
index|[
literal|0
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|HImode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS1
argument_list|(
name|fnsts
operator|%
name|W0
argument_list|,
operator|%
literal|0
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TARGET_IEEE_FP
condition|)
return|return
literal|"sahf"
return|;
name|next
operator|=
name|next_cc0_user
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|==
name|NULL_RTX
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|)
operator|==
name|pc_rtx
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|)
argument_list|)
operator|==
name|IF_THEN_ELSE
condition|)
block|{
name|code
operator|=
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
block|{
name|code
operator|=
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
name|xops
index|[
literal|0
index|]
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|QImode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|GT
case|:
name|xops
index|[
literal|1
index|]
operator|=
name|GEN_INT
argument_list|(
literal|0x45
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|and
operator|%
name|B0
argument_list|,
operator|%
literal|1
argument_list|,
operator|%
name|h0
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
comment|/* je label */
break|break;
case|case
name|LT
case|:
name|xops
index|[
literal|1
index|]
operator|=
name|GEN_INT
argument_list|(
literal|0x45
argument_list|)
expr_stmt|;
name|xops
index|[
literal|2
index|]
operator|=
name|GEN_INT
argument_list|(
literal|0x01
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|and
operator|%
name|B0
argument_list|,
operator|%
literal|1
argument_list|,
operator|%
name|h0
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|cmp
operator|%
name|B0
argument_list|,
operator|%
literal|2
argument_list|,
operator|%
name|h0
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
comment|/* je label */
break|break;
case|case
name|GE
case|:
name|xops
index|[
literal|1
index|]
operator|=
name|GEN_INT
argument_list|(
literal|0x05
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|and
operator|%
name|B0
argument_list|,
operator|%
literal|1
argument_list|,
operator|%
name|h0
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
comment|/* je label */
break|break;
case|case
name|LE
case|:
name|xops
index|[
literal|1
index|]
operator|=
name|GEN_INT
argument_list|(
literal|0x45
argument_list|)
expr_stmt|;
name|xops
index|[
literal|2
index|]
operator|=
name|GEN_INT
argument_list|(
literal|0x40
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|and
operator|%
name|B0
argument_list|,
operator|%
literal|1
argument_list|,
operator|%
name|h0
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS1
argument_list|(
name|dec
operator|%
name|B0
argument_list|,
operator|%
name|h0
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|cmp
operator|%
name|B0
argument_list|,
operator|%
literal|2
argument_list|,
operator|%
name|h0
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
comment|/* jb label */
break|break;
case|case
name|EQ
case|:
name|xops
index|[
literal|1
index|]
operator|=
name|GEN_INT
argument_list|(
literal|0x45
argument_list|)
expr_stmt|;
name|xops
index|[
literal|2
index|]
operator|=
name|GEN_INT
argument_list|(
literal|0x40
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|and
operator|%
name|B0
argument_list|,
operator|%
literal|1
argument_list|,
operator|%
name|h0
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|cmp
operator|%
name|B0
argument_list|,
operator|%
literal|2
argument_list|,
operator|%
name|h0
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
comment|/* je label */
break|break;
case|case
name|NE
case|:
name|xops
index|[
literal|1
index|]
operator|=
name|GEN_INT
argument_list|(
literal|0x44
argument_list|)
expr_stmt|;
name|xops
index|[
literal|2
index|]
operator|=
name|GEN_INT
argument_list|(
literal|0x40
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|and
operator|%
name|B0
argument_list|,
operator|%
literal|1
argument_list|,
operator|%
name|h0
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|AS2
argument_list|(
name|xor
operator|%
name|B0
argument_list|,
operator|%
literal|2
argument_list|,
operator|%
name|h0
argument_list|)
argument_list|,
name|xops
argument_list|)
expr_stmt|;
comment|/* jne label */
break|break;
case|case
name|GTU
case|:
case|case
name|LTU
case|:
case|case
name|GEU
case|:
case|case
name|LEU
case|:
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|RET
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_define
define|#
directive|define
name|MAX_386_STACK_LOCALS
value|2
end_define

begin_decl_stmt
specifier|static
name|rtx
name|i386_stack_locals
index|[
operator|(
name|int
operator|)
name|MAX_MACHINE_MODE
index|]
index|[
name|MAX_386_STACK_LOCALS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Define the structure for the machine field in struct function.  */
end_comment

begin_struct
struct|struct
name|machine_function
block|{
name|rtx
name|i386_stack_locals
index|[
operator|(
name|int
operator|)
name|MAX_MACHINE_MODE
index|]
index|[
name|MAX_386_STACK_LOCALS
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Functions to save and restore i386_stack_locals.    These will be called, via pointer variables,    from push_function_context and pop_function_context.  */
end_comment

begin_function
name|void
name|save_386_machine_status
parameter_list|(
name|p
parameter_list|)
name|struct
name|function
modifier|*
name|p
decl_stmt|;
block|{
name|p
operator|->
name|machine
operator|=
operator|(
expr|struct
name|machine_function
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
name|i386_stack_locals
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|i386_stack_locals
argument_list|,
operator|(
name|char
operator|*
operator|)
name|p
operator|->
name|machine
operator|->
name|i386_stack_locals
argument_list|,
sizeof|sizeof
name|i386_stack_locals
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|restore_386_machine_status
parameter_list|(
name|p
parameter_list|)
name|struct
name|function
modifier|*
name|p
decl_stmt|;
block|{
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
operator|->
name|machine
operator|->
name|i386_stack_locals
argument_list|,
operator|(
name|char
operator|*
operator|)
name|i386_stack_locals
argument_list|,
sizeof|sizeof
name|i386_stack_locals
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
operator|->
name|machine
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clear stack slot assignments remembered from previous functions.    This is called from INIT_EXPANDERS once before RTL is emitted for each    function.  */
end_comment

begin_function
name|void
name|clear_386_stack_locals
parameter_list|()
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|n
decl_stmt|;
for|for
control|(
name|mode
operator|=
name|VOIDmode
init|;
operator|(
name|int
operator|)
name|mode
operator|<
operator|(
name|int
operator|)
name|MAX_MACHINE_MODE
condition|;
name|mode
operator|=
operator|(
expr|enum
name|machine_mode
operator|)
operator|(
operator|(
name|int
operator|)
name|mode
operator|+
literal|1
operator|)
control|)
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|MAX_386_STACK_LOCALS
condition|;
name|n
operator|++
control|)
name|i386_stack_locals
index|[
operator|(
name|int
operator|)
name|mode
index|]
index|[
name|n
index|]
operator|=
name|NULL_RTX
expr_stmt|;
comment|/* Arrange to save and restore i386_stack_locals around nested functions.  */
name|save_machine_status
operator|=
name|save_386_machine_status
expr_stmt|;
name|restore_machine_status
operator|=
name|restore_386_machine_status
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a MEM corresponding to a stack slot with mode MODE.    Allocate a new slot if necessary.     The RTL for a function can have several slots available: N is    which slot to use.  */
end_comment

begin_function
name|rtx
name|assign_386_stack_local
parameter_list|(
name|mode
parameter_list|,
name|n
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
if|if
condition|(
name|n
operator|<
literal|0
operator|||
name|n
operator|>=
name|MAX_386_STACK_LOCALS
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|i386_stack_locals
index|[
operator|(
name|int
operator|)
name|mode
index|]
index|[
name|n
index|]
operator|==
name|NULL_RTX
condition|)
name|i386_stack_locals
index|[
operator|(
name|int
operator|)
name|mode
index|]
index|[
name|n
index|]
operator|=
name|assign_stack_local
argument_list|(
name|mode
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|i386_stack_locals
index|[
operator|(
name|int
operator|)
name|mode
index|]
index|[
name|n
index|]
return|;
block|}
end_function

end_unit

