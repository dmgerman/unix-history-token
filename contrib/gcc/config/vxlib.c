begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 2002, 2003, 2004, 2005 Free Software Foundation, Inc.    Contributed by Zack Weinberg<zack@codesourcery.com>  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* As a special exception, if you link this library with other files,    some of which are compiled with GCC, to produce an executable,    this library does not by itself cause the resulting executable    to be covered by the GNU General Public License.    This exception does not however invalidate any other reasons why    the executable file might be covered by the GNU General Public License.  */
end_comment

begin_comment
comment|/* Threads compatibility routines for libgcc2 for VxWorks.    These are out-of-line routines called from gthr-vxworks.h.  */
end_comment

begin_include
include|#
directive|include
file|"tconfig.h"
end_include

begin_include
include|#
directive|include
file|"tsystem.h"
end_include

begin_include
include|#
directive|include
file|"gthr.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__GTHREADS
argument_list|)
end_if

begin_include
include|#
directive|include
file|<vxWorks.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|__RTP__
end_ifndef

begin_include
include|#
directive|include
file|<vxLib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<taskLib.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|__RTP__
end_ifndef

begin_include
include|#
directive|include
file|<taskHookLib.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Init-once operation.     This would be a clone of the implementation from gthr-solaris.h,    except that we have a bootstrap problem - the whole point of this    exercise is to prevent double initialization, but if two threads    are racing with each other, once->mutex is liable to be initialized    by both.  Then each thread will lock its own mutex, and proceed to    call the initialization routine.     So instead we use a bare atomic primitive (vxTas()) to handle    mutual exclusion.  Threads losing the race then busy-wait, calling    taskDelay() to yield the processor, until the initialization is    completed.  Inefficient, but reliable.  */
end_comment

begin_function
name|int
name|__gthread_once
parameter_list|(
name|__gthread_once_t
modifier|*
name|guard
parameter_list|,
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|void
parameter_list|)
parameter_list|)
block|{
if|if
condition|(
name|guard
operator|->
name|done
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|__RTP__
name|__gthread_lock_library
argument_list|()
expr_stmt|;
else|#
directive|else
while|while
condition|(
operator|!
name|vxTas
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|guard
operator|->
name|busy
argument_list|)
condition|)
name|taskDelay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Only one thread at a time gets here.  Check ->done again, then      go ahead and call func() if no one has done it yet.  */
if|if
condition|(
operator|!
name|guard
operator|->
name|done
condition|)
block|{
name|func
argument_list|()
expr_stmt|;
name|guard
operator|->
name|done
operator|=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|__RTP__
name|__gthread_unlock_library
argument_list|()
expr_stmt|;
else|#
directive|else
name|guard
operator|->
name|busy
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Thread-local storage.     We reserve a field in the TCB to point to a dynamically allocated    array which is used to store TLS values.  A TLS key is simply an    offset in this array.  The exact location of the TCB field is not    known to this code nor to vxlib.c -- all access to it indirects    through the routines __gthread_get_tls_data and    __gthread_set_tls_data, which are provided by the VxWorks kernel.     There is also a global array which records which keys are valid and    which have destructors.     A task delete hook is installed to execute key destructors.  The    routines __gthread_enter_tls_dtor_context and    __gthread_leave_tls_dtor_context, which are also provided by the    kernel, ensure that it is safe to call free() on memory allocated    by the task being deleted.  (This is a no-op on VxWorks 5, but    a major undertaking on AE.)     The task delete hook is only installed when at least one thread    has TLS data.  This is a necessary precaution, to allow this module    to be unloaded - a module with a hook can not be removed.     Since this interface is used to allocate only a small number of    keys, the table size is small and static, which simplifies the    code quite a bit.  Revisit this if and when it becomes necessary.  */
end_comment

begin_define
define|#
directive|define
name|MAX_KEYS
value|4
end_define

begin_comment
comment|/* This is the structure pointed to by the pointer returned    by __gthread_get_tls_data.  */
end_comment

begin_struct
struct|struct
name|tls_data
block|{
name|int
modifier|*
name|owner
decl_stmt|;
name|void
modifier|*
name|values
index|[
name|MAX_KEYS
index|]
decl_stmt|;
name|unsigned
name|int
name|generation
index|[
name|MAX_KEYS
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* To make sure we only delete TLS data associated with this object,    include a pointer to a local variable in the TLS data object.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|self_owner
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of threads for this module which have active TLS data.    This is protected by tls_lock.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|active_tls_threads
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* kernel provided routines */
end_comment

begin_function_decl
specifier|extern
name|void
modifier|*
name|__gthread_get_tls_data
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|__gthread_set_tls_data
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|__gthread_enter_tls_dtor_context
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|__gthread_leave_tls_dtor_context
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* This is a global structure which records all of the active keys.     A key is potentially valid (i.e. has been handed out by    __gthread_key_create) iff its generation count in this structure is    even.  In that case, the matching entry in the dtors array is a    routine to be called when a thread terminates with a valid,    non-NULL specific value for that key.     A key is actually valid in a thread T iff the generation count    stored in this structure is equal to the generation count stored in    T's specific-value structure.  */
end_comment

begin_typedef
typedef|typedef
name|void
function_decl|(
modifier|*
name|tls_dtor
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_struct
struct|struct
name|tls_keys
block|{
name|tls_dtor
name|dtor
index|[
name|MAX_KEYS
index|]
decl_stmt|;
name|unsigned
name|int
name|generation
index|[
name|MAX_KEYS
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|KEY_VALID_P
parameter_list|(
name|key
parameter_list|)
value|!(tls_keys.generation[key]& 1)
end_define

begin_comment
comment|/* Note: if MAX_KEYS is increased, this initializer must be updated    to match.  All the generation counts begin at 1, which means no    key is valid.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|tls_keys
name|tls_keys
init|=
block|{
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This lock protects the tls_keys structure.  */
end_comment

begin_decl_stmt
specifier|static
name|__gthread_mutex_t
name|tls_lock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|__gthread_once_t
name|tls_init_guard
init|=
name|__GTHREAD_ONCE_INIT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Internal routines.  */
end_comment

begin_comment
comment|/* The task TCB has just been deleted.  Call the destructor    function for each TLS key that has both a destructor and    a non-NULL specific value in this thread.     This routine does not need to take tls_lock; the generation    count protects us from calling a stale destructor.  It does    need to read tls_keys.dtor[key] atomically.  */
end_comment

begin_function
specifier|static
name|void
name|tls_delete_hook
parameter_list|(
name|void
modifier|*
name|tcb
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|struct
name|tls_data
modifier|*
name|data
init|=
name|__gthread_get_tls_data
argument_list|()
decl_stmt|;
name|__gthread_key_t
name|key
decl_stmt|;
if|if
condition|(
name|data
operator|&&
name|data
operator|->
name|owner
operator|==
operator|&
name|self_owner
condition|)
block|{
name|__gthread_enter_tls_dtor_context
argument_list|()
expr_stmt|;
for|for
control|(
name|key
operator|=
literal|0
init|;
name|key
operator|<
name|MAX_KEYS
condition|;
name|key
operator|++
control|)
block|{
if|if
condition|(
name|data
operator|->
name|generation
index|[
name|key
index|]
operator|==
name|tls_keys
operator|.
name|generation
index|[
name|key
index|]
condition|)
block|{
name|tls_dtor
name|dtor
init|=
name|tls_keys
operator|.
name|dtor
index|[
name|key
index|]
decl_stmt|;
if|if
condition|(
name|dtor
condition|)
name|dtor
argument_list|(
name|data
operator|->
name|values
index|[
name|key
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|data
argument_list|)
expr_stmt|;
comment|/* We can't handle an error here, so just leave the thread 	 marked as loaded if one occurs.  */
if|if
condition|(
name|__gthread_mutex_lock
argument_list|(
operator|&
name|tls_lock
argument_list|)
operator|!=
name|ERROR
condition|)
block|{
name|active_tls_threads
operator|--
expr_stmt|;
if|if
condition|(
name|active_tls_threads
operator|==
literal|0
condition|)
name|taskDeleteHookDelete
argument_list|(
operator|(
name|FUNCPTR
operator|)
name|tls_delete_hook
argument_list|)
expr_stmt|;
name|__gthread_mutex_unlock
argument_list|(
operator|&
name|tls_lock
argument_list|)
expr_stmt|;
block|}
name|__gthread_set_tls_data
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|__gthread_leave_tls_dtor_context
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Initialize global data used by the TLS system.  */
end_comment

begin_function
specifier|static
name|void
name|tls_init
parameter_list|(
name|void
parameter_list|)
block|{
name|__GTHREAD_MUTEX_INIT_FUNCTION
argument_list|(
operator|&
name|tls_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
specifier|static
name|void
name|tls_destructor
parameter_list|(
name|void
parameter_list|)
function_decl|__attribute__
parameter_list|(
function_decl|(destructor
end_function_decl

begin_empty_stmt
unit|))
empty_stmt|;
end_empty_stmt

begin_function
specifier|static
name|void
name|tls_destructor
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|__RTP__
comment|/* All threads but this one should have exited by now.  */
name|tls_delete_hook
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Unregister the hook forcibly.  The counter of active threads may      be incorrect, because constructors (like the C++ library's) and      destructors (like this one) run in the context of the shell rather      than in a task spawned from this module.  */
name|taskDeleteHookDelete
argument_list|(
operator|(
name|FUNCPTR
operator|)
name|tls_delete_hook
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|tls_init_guard
operator|.
name|done
operator|&&
name|__gthread_mutex_lock
argument_list|(
operator|&
name|tls_lock
argument_list|)
operator|!=
name|ERROR
condition|)
name|semDelete
argument_list|(
name|tls_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* External interface */
end_comment

begin_comment
comment|/* Store in KEYP a value which can be passed to __gthread_setspecific/    __gthread_getspecific to store and retrieve a value which is    specific to each calling thread.  If DTOR is not NULL, it will be    called when a thread terminates with a non-NULL specific value for    this key, with the value as its sole argument.  */
end_comment

begin_function
name|int
name|__gthread_key_create
parameter_list|(
name|__gthread_key_t
modifier|*
name|keyp
parameter_list|,
name|tls_dtor
name|dtor
parameter_list|)
block|{
name|__gthread_key_t
name|key
decl_stmt|;
name|__gthread_once
argument_list|(
operator|&
name|tls_init_guard
argument_list|,
name|tls_init
argument_list|)
expr_stmt|;
if|if
condition|(
name|__gthread_mutex_lock
argument_list|(
operator|&
name|tls_lock
argument_list|)
operator|==
name|ERROR
condition|)
return|return
name|errno
return|;
for|for
control|(
name|key
operator|=
literal|0
init|;
name|key
operator|<
name|MAX_KEYS
condition|;
name|key
operator|++
control|)
if|if
condition|(
operator|!
name|KEY_VALID_P
argument_list|(
name|key
argument_list|)
condition|)
goto|goto
name|found_slot
goto|;
comment|/* no room */
name|__gthread_mutex_unlock
argument_list|(
operator|&
name|tls_lock
argument_list|)
expr_stmt|;
return|return
name|EAGAIN
return|;
name|found_slot
label|:
name|tls_keys
operator|.
name|generation
index|[
name|key
index|]
operator|++
expr_stmt|;
comment|/* making it even */
name|tls_keys
operator|.
name|dtor
index|[
name|key
index|]
operator|=
name|dtor
expr_stmt|;
operator|*
name|keyp
operator|=
name|key
expr_stmt|;
name|__gthread_mutex_unlock
argument_list|(
operator|&
name|tls_lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Invalidate KEY; it can no longer be used as an argument to    setspecific/getspecific.  Note that this does NOT call destructor    functions for any live values for this key.  */
end_comment

begin_function
name|int
name|__gthread_key_delete
parameter_list|(
name|__gthread_key_t
name|key
parameter_list|)
block|{
if|if
condition|(
name|key
operator|>=
name|MAX_KEYS
condition|)
return|return
name|EINVAL
return|;
name|__gthread_once
argument_list|(
operator|&
name|tls_init_guard
argument_list|,
name|tls_init
argument_list|)
expr_stmt|;
if|if
condition|(
name|__gthread_mutex_lock
argument_list|(
operator|&
name|tls_lock
argument_list|)
operator|==
name|ERROR
condition|)
return|return
name|errno
return|;
if|if
condition|(
operator|!
name|KEY_VALID_P
argument_list|(
name|key
argument_list|)
condition|)
block|{
name|__gthread_mutex_unlock
argument_list|(
operator|&
name|tls_lock
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|tls_keys
operator|.
name|generation
index|[
name|key
index|]
operator|++
expr_stmt|;
comment|/* making it odd */
name|tls_keys
operator|.
name|dtor
index|[
name|key
index|]
operator|=
literal|0
expr_stmt|;
name|__gthread_mutex_unlock
argument_list|(
operator|&
name|tls_lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Retrieve the thread-specific value for KEY.  If it has never been    set in this thread, or KEY is invalid, returns NULL.     It does not matter if this function races with key_create or    key_delete; the worst that can happen is you get a value other than    the one that a serialized implementation would have provided.  */
end_comment

begin_function
name|void
modifier|*
name|__gthread_getspecific
parameter_list|(
name|__gthread_key_t
name|key
parameter_list|)
block|{
name|struct
name|tls_data
modifier|*
name|data
decl_stmt|;
if|if
condition|(
name|key
operator|>=
name|MAX_KEYS
condition|)
return|return
literal|0
return|;
name|data
operator|=
name|__gthread_get_tls_data
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|data
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|data
operator|->
name|generation
index|[
name|key
index|]
operator|!=
name|tls_keys
operator|.
name|generation
index|[
name|key
index|]
condition|)
return|return
literal|0
return|;
return|return
name|data
operator|->
name|values
index|[
name|key
index|]
return|;
block|}
end_function

begin_comment
comment|/* Set the thread-specific value for KEY.  If KEY is invalid, or    memory allocation fails, returns -1, otherwise 0.     The generation count protects this function against races with    key_create/key_delete; the worst thing that can happen is that a    value is successfully stored into a dead generation (and then    immediately becomes invalid).  However, we do have to make sure    to read tls_keys.generation[key] atomically.  */
end_comment

begin_function
name|int
name|__gthread_setspecific
parameter_list|(
name|__gthread_key_t
name|key
parameter_list|,
name|void
modifier|*
name|value
parameter_list|)
block|{
name|struct
name|tls_data
modifier|*
name|data
decl_stmt|;
name|unsigned
name|int
name|generation
decl_stmt|;
if|if
condition|(
name|key
operator|>=
name|MAX_KEYS
condition|)
return|return
name|EINVAL
return|;
name|data
operator|=
name|__gthread_get_tls_data
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|data
condition|)
block|{
if|if
condition|(
name|__gthread_mutex_lock
argument_list|(
operator|&
name|tls_lock
argument_list|)
operator|==
name|ERROR
condition|)
return|return
name|ENOMEM
return|;
if|if
condition|(
name|active_tls_threads
operator|==
literal|0
condition|)
name|taskDeleteHookAdd
argument_list|(
operator|(
name|FUNCPTR
operator|)
name|tls_delete_hook
argument_list|)
expr_stmt|;
name|active_tls_threads
operator|++
expr_stmt|;
name|__gthread_mutex_unlock
argument_list|(
operator|&
name|tls_lock
argument_list|)
expr_stmt|;
name|data
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|tls_data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|data
condition|)
return|return
name|ENOMEM
return|;
name|memset
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tls_data
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|->
name|owner
operator|=
operator|&
name|self_owner
expr_stmt|;
name|__gthread_set_tls_data
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
name|generation
operator|=
name|tls_keys
operator|.
name|generation
index|[
name|key
index|]
expr_stmt|;
if|if
condition|(
name|generation
operator|&
literal|1
condition|)
return|return
name|EINVAL
return|;
name|data
operator|->
name|generation
index|[
name|key
index|]
operator|=
name|generation
expr_stmt|;
name|data
operator|->
name|values
index|[
name|key
index|]
operator|=
name|value
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __GTHREADS */
end_comment

end_unit

