begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 2002 Free Software Foundation, Inc.    Contributed by Zack Weinberg<zack@codesourcery.com>  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* Threads compatibility routines for libgcc2 for VxWorks.    These are out-of-line routines called from gthr-vxworks.h.  */
end_comment

begin_comment
comment|/* As a special exception, if you link this library with other files,    some of which are compiled with GCC, to produce an executable,    this library does not by itself cause the resulting executable    to be covered by the GNU General Public License.    This exception does not however invalidate any other reasons why    the executable file might be covered by the GNU General Public License.  */
end_comment

begin_include
include|#
directive|include
file|"tconfig.h"
end_include

begin_include
include|#
directive|include
file|"tsystem.h"
end_include

begin_include
include|#
directive|include
file|"gthr.h"
end_include

begin_include
include|#
directive|include
file|<vxWorks.h>
end_include

begin_include
include|#
directive|include
file|<vxLib.h>
end_include

begin_include
include|#
directive|include
file|<taskLib.h>
end_include

begin_include
include|#
directive|include
file|<taskHookLib.h>
end_include

begin_comment
comment|/* Init-once operation.     This would be a clone of the implementation from gthr-solaris.h,    except that we have a bootstrap problem - the whole point of this    exercise is to prevent double initialization, but if two threads    are racing with each other, once->mutex is liable to be initialized    by both.  Then each thread will lock its own mutex, and proceed to    call the initialization routine.     So instead we use a bare atomic primitive (vxTas()) to handle    mutual exclusion.  Threads losing the race then busy-wait, calling    taskDelay() to yield the processor, until the initialization is    completed.  Inefficient, but reliable.  */
end_comment

begin_function
name|int
name|__gthread_once
parameter_list|(
name|__gthread_once_t
modifier|*
name|guard
parameter_list|,
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|void
parameter_list|)
parameter_list|)
block|{
if|if
condition|(
name|guard
operator|->
name|done
condition|)
return|return
literal|0
return|;
while|while
condition|(
operator|!
name|vxTas
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|guard
operator|->
name|busy
argument_list|)
condition|)
name|taskDelay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Only one thread at a time gets here.  Check ->done again, then      go ahead and call func() if no one has done it yet.  */
if|if
condition|(
operator|!
name|guard
operator|->
name|done
condition|)
block|{
name|func
argument_list|()
expr_stmt|;
name|guard
operator|->
name|done
operator|=
literal|1
expr_stmt|;
block|}
name|guard
operator|->
name|busy
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Thread-specific data.     We reserve a field in the TCB to point to a dynamically allocated    array which is used to store TSD values.  A TSD key is simply an    offset in this array.  The exact location of the TCB field is not    known to this code nor to vxlib.c -- all access to it indirects    through the routines __gthread_get_tsd_data and    __gthread_set_tsd_data, which are provided by the VxWorks kernel.     There is also a global array which records which keys are valid and    which have destructors.     A task delete hook is installed to execute key destructors.  The    routines __gthread_enter_tsd_dtor_context and    __gthread_leave_tsd_dtor_context, which are also provided by the    kernel, ensure that it is safe to call free() on memory allocated    by the task being deleted.  (This is a no-op on VxWorks 5, but    a major undertaking on AE.)     Since this interface is used to allocate only a small number of    keys, the table size is small and static, which simplifies the    code quite a bit.  Revisit this if and when it becomes necessary.  */
end_comment

begin_define
define|#
directive|define
name|MAX_KEYS
value|4
end_define

begin_comment
comment|/* This is the structure pointed to by the pointer returned    by __gthread_get_tsd_data.  */
end_comment

begin_struct
struct|struct
name|tsd_data
block|{
name|void
modifier|*
name|values
index|[
name|MAX_KEYS
index|]
decl_stmt|;
name|unsigned
name|int
name|generation
index|[
name|MAX_KEYS
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* kernel provided routines */
end_comment

begin_function_decl
specifier|extern
name|void
modifier|*
name|__gthread_get_tsd_data
parameter_list|(
name|WIND_TCB
modifier|*
name|tcb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|__gthread_set_tsd_data
parameter_list|(
name|WIND_TCB
modifier|*
name|tcb
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|__gthread_enter_tsd_dtor_context
parameter_list|(
name|WIND_TCB
modifier|*
name|tcb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|__gthread_leave_tsd_dtor_context
parameter_list|(
name|WIND_TCB
modifier|*
name|tcb
parameter_list|)
function_decl|;
end_function_decl

begin_typedef
typedef|typedef
name|void
function_decl|(
modifier|*
name|fet_callback_t
function_decl|)
parameter_list|(
name|WIND_TCB
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_typedef

begin_function_decl
specifier|extern
name|void
name|__gthread_for_all_tasks
parameter_list|(
name|fet_callback_t
name|fun
parameter_list|,
name|unsigned
name|int
name|number
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* This is a global structure which records all of the active keys.     A key is potentially valid (i.e. has been handed out by    __gthread_key_create) iff its generation count in this structure is    even.  In that case, the matching entry in the dtors array is a    routine to be called when a thread terminates with a valid,    non-NULL specific value for that key.     A key is actually valid in a thread T iff the generation count    stored in this structure is equal to the generation count stored in    T's specific-value structure.  */
end_comment

begin_typedef
typedef|typedef
name|void
function_decl|(
modifier|*
name|tsd_dtor
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_struct
struct|struct
name|tsd_keys
block|{
name|tsd_dtor
name|dtor
index|[
name|MAX_KEYS
index|]
decl_stmt|;
name|unsigned
name|int
name|generation
index|[
name|MAX_KEYS
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|KEY_VALID_P
parameter_list|(
name|key
parameter_list|)
value|!(tsd_keys.generation[key]& 1)
end_define

begin_comment
comment|/* Note: if MAX_KEYS is increased, this initializer must be updated    to match.  All the generation counts begin at 1, which means no    key is valid.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|tsd_keys
name|tsd_keys
init|=
block|{
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This lock protects the tsd_keys structure.  */
end_comment

begin_decl_stmt
specifier|static
name|__gthread_mutex_t
name|tsd_lock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|__gthread_once_t
name|tsd_init_guard
init|=
name|__GTHREAD_ONCE_INIT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Internal routines.  */
end_comment

begin_comment
comment|/* The task TCB has just been deleted.  Call the destructor    function for each TSD key that has both a destructor and    a non-NULL specific value in this thread.     This routine does not need to take tsd_lock; the generation    count protects us from calling a stale destructor.  It does    need to read tsd_keys.dtor[key] atomically.  */
end_comment

begin_function
specifier|static
name|void
name|tsd_delete_hook
parameter_list|(
name|WIND_TCB
modifier|*
name|tcb
parameter_list|)
block|{
name|struct
name|tsd_data
modifier|*
name|data
init|=
name|__gthread_get_tsd_data
argument_list|(
name|tcb
argument_list|)
decl_stmt|;
name|__gthread_key_t
name|key
decl_stmt|;
if|if
condition|(
name|data
condition|)
block|{
name|__gthread_enter_tsd_dtor_context
argument_list|(
name|tcb
argument_list|)
expr_stmt|;
for|for
control|(
name|key
operator|=
literal|0
init|;
name|key
operator|<
name|MAX_KEYS
condition|;
name|key
operator|++
control|)
block|{
if|if
condition|(
name|data
operator|->
name|generation
index|[
name|key
index|]
operator|==
name|tsd_keys
operator|.
name|generation
index|[
name|key
index|]
condition|)
block|{
name|tsd_dtor
name|dtor
init|=
name|tsd_keys
operator|.
name|dtor
index|[
name|key
index|]
decl_stmt|;
if|if
condition|(
name|dtor
condition|)
name|dtor
argument_list|(
name|data
operator|->
name|values
index|[
name|key
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|__gthread_set_tsd_data
argument_list|(
name|tcb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|__gthread_leave_tsd_dtor_context
argument_list|(
name|tcb
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Initialize global data used by the TSD system.  */
end_comment

begin_function
specifier|static
name|void
name|tsd_init
parameter_list|(
name|void
parameter_list|)
block|{
name|taskDeleteHookAdd
argument_list|(
operator|(
name|FUNCPTR
operator|)
name|tsd_delete_hook
argument_list|)
expr_stmt|;
name|__GTHREAD_MUTEX_INIT_FUNCTION
argument_list|(
operator|&
name|tsd_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* External interface */
end_comment

begin_comment
comment|/* Store in KEYP a value which can be passed to __gthread_setspecific/    __gthread_getspecific to store and retrieve a value which is    specific to each calling thread.  If DTOR is not NULL, it will be    called when a thread terminates with a non-NULL specific value for    this key, with the value as its sole argument.  */
end_comment

begin_function
name|int
name|__gthread_key_create
parameter_list|(
name|__gthread_key_t
modifier|*
name|keyp
parameter_list|,
name|tsd_dtor
name|dtor
parameter_list|)
block|{
name|__gthread_key_t
name|key
decl_stmt|;
name|__gthread_once
argument_list|(
operator|&
name|tsd_init_guard
argument_list|,
name|tsd_init
argument_list|)
expr_stmt|;
if|if
condition|(
name|__gthread_mutex_lock
argument_list|(
operator|&
name|tsd_lock
argument_list|)
operator|==
name|ERROR
condition|)
return|return
name|errno
return|;
for|for
control|(
name|key
operator|=
literal|0
init|;
name|key
operator|<
name|MAX_KEYS
condition|;
name|key
operator|++
control|)
if|if
condition|(
operator|!
name|KEY_VALID_P
argument_list|(
name|key
argument_list|)
condition|)
goto|goto
name|found_slot
goto|;
comment|/* no room */
name|__gthread_mutex_unlock
argument_list|(
operator|&
name|tsd_lock
argument_list|)
expr_stmt|;
return|return
name|EAGAIN
return|;
name|found_slot
label|:
name|tsd_keys
operator|.
name|generation
index|[
name|key
index|]
operator|++
expr_stmt|;
comment|/* making it even */
name|tsd_keys
operator|.
name|dtor
index|[
name|key
index|]
operator|=
name|dtor
expr_stmt|;
operator|*
name|keyp
operator|=
name|key
expr_stmt|;
name|__gthread_mutex_unlock
argument_list|(
operator|&
name|tsd_lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Invalidate KEY; it can no longer be used as an argument to    setspecific/getspecific.  Note that this does NOT call destructor    functions for any live values for this key.  */
end_comment

begin_function
name|int
name|__gthread_key_delete
parameter_list|(
name|__gthread_key_t
name|key
parameter_list|)
block|{
if|if
condition|(
name|key
operator|>=
name|MAX_KEYS
condition|)
return|return
name|EINVAL
return|;
name|__gthread_once
argument_list|(
operator|&
name|tsd_init_guard
argument_list|,
name|tsd_init
argument_list|)
expr_stmt|;
if|if
condition|(
name|__gthread_mutex_lock
argument_list|(
operator|&
name|tsd_lock
argument_list|)
operator|==
name|ERROR
condition|)
return|return
name|errno
return|;
if|if
condition|(
operator|!
name|KEY_VALID_P
argument_list|(
name|key
argument_list|)
condition|)
block|{
name|__gthread_mutex_unlock
argument_list|(
operator|&
name|tsd_lock
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|tsd_keys
operator|.
name|generation
index|[
name|key
index|]
operator|++
expr_stmt|;
comment|/* making it odd */
name|tsd_keys
operator|.
name|dtor
index|[
name|key
index|]
operator|=
literal|0
expr_stmt|;
name|__gthread_mutex_unlock
argument_list|(
operator|&
name|tsd_lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Retrieve the thread-specific value for KEY.  If it has never been    set in this thread, or KEY is invalid, returns NULL.     It does not matter if this function races with key_create or    key_delete; the worst that can happen is you get a value other than    the one that a serialized implementation would have provided.  */
end_comment

begin_function
name|void
modifier|*
name|__gthread_getspecific
parameter_list|(
name|__gthread_key_t
name|key
parameter_list|)
block|{
name|struct
name|tsd_data
modifier|*
name|data
decl_stmt|;
if|if
condition|(
name|key
operator|>=
name|MAX_KEYS
condition|)
return|return
literal|0
return|;
name|data
operator|=
name|__gthread_get_tsd_data
argument_list|(
name|taskTcb
argument_list|(
name|taskIdSelf
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|data
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|data
operator|->
name|generation
index|[
name|key
index|]
operator|!=
name|tsd_keys
operator|.
name|generation
index|[
name|key
index|]
condition|)
return|return
literal|0
return|;
return|return
name|data
operator|->
name|values
index|[
name|key
index|]
return|;
block|}
end_function

begin_comment
comment|/* Set the thread-specific value for KEY.  If KEY is invalid, or    memory allocation fails, returns -1, otherwise 0.     The generation count protects this function against races with    key_create/key_delete; the worst thing that can happen is that a    value is successfully stored into a dead generation (and then    immediately becomes invalid).  However, we do have to make sure    to read tsd_keys.generation[key] atomically.  */
end_comment

begin_function
name|int
name|__gthread_setspecific
parameter_list|(
name|__gthread_key_t
name|key
parameter_list|,
name|void
modifier|*
name|value
parameter_list|)
block|{
name|struct
name|tsd_data
modifier|*
name|data
decl_stmt|;
name|WIND_TCB
modifier|*
name|tcb
decl_stmt|;
name|unsigned
name|int
name|generation
decl_stmt|;
if|if
condition|(
name|key
operator|>=
name|MAX_KEYS
condition|)
return|return
name|EINVAL
return|;
name|tcb
operator|=
name|taskTcb
argument_list|(
name|taskIdSelf
argument_list|()
argument_list|)
expr_stmt|;
name|data
operator|=
name|__gthread_get_tsd_data
argument_list|(
name|tcb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|data
condition|)
block|{
name|data
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|tsd_data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|data
condition|)
return|return
name|ENOMEM
return|;
name|memset
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tsd_data
argument_list|)
argument_list|)
expr_stmt|;
name|__gthread_set_tsd_data
argument_list|(
name|tcb
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
name|generation
operator|=
name|tsd_keys
operator|.
name|generation
index|[
name|key
index|]
expr_stmt|;
if|if
condition|(
name|generation
operator|&
literal|1
condition|)
return|return
name|EINVAL
return|;
name|data
operator|->
name|generation
index|[
name|key
index|]
operator|=
name|generation
expr_stmt|;
name|data
operator|->
name|values
index|[
name|key
index|]
operator|=
name|value
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

