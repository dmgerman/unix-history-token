begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Definitions of target machine for GNU compiler.    Copyright (C) 1999, 2000, 2001, 2002 Free Software Foundation, Inc.    Contributed by James E. Wilson<wilson@cygnus.com> and    		  David Mosberger<davidm@hpl.hp.com>.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"conditions.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"optabs.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"sched-int.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"target-def.h"
end_include

begin_comment
comment|/* This is used for communication between ASM_OUTPUT_LABEL and    ASM_OUTPUT_LABELREF.  */
end_comment

begin_decl_stmt
name|int
name|ia64_asm_output_label
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Define the information needed to generate branch and scc insns.  This is    stored from the compare operation.  */
end_comment

begin_decl_stmt
name|struct
name|rtx_def
modifier|*
name|ia64_compare_op0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rtx_def
modifier|*
name|ia64_compare_op1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Register names for ia64_expand_prologue.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|ia64_reg_numbers
index|[
literal|96
index|]
init|=
block|{
literal|"r32"
block|,
literal|"r33"
block|,
literal|"r34"
block|,
literal|"r35"
block|,
literal|"r36"
block|,
literal|"r37"
block|,
literal|"r38"
block|,
literal|"r39"
block|,
literal|"r40"
block|,
literal|"r41"
block|,
literal|"r42"
block|,
literal|"r43"
block|,
literal|"r44"
block|,
literal|"r45"
block|,
literal|"r46"
block|,
literal|"r47"
block|,
literal|"r48"
block|,
literal|"r49"
block|,
literal|"r50"
block|,
literal|"r51"
block|,
literal|"r52"
block|,
literal|"r53"
block|,
literal|"r54"
block|,
literal|"r55"
block|,
literal|"r56"
block|,
literal|"r57"
block|,
literal|"r58"
block|,
literal|"r59"
block|,
literal|"r60"
block|,
literal|"r61"
block|,
literal|"r62"
block|,
literal|"r63"
block|,
literal|"r64"
block|,
literal|"r65"
block|,
literal|"r66"
block|,
literal|"r67"
block|,
literal|"r68"
block|,
literal|"r69"
block|,
literal|"r70"
block|,
literal|"r71"
block|,
literal|"r72"
block|,
literal|"r73"
block|,
literal|"r74"
block|,
literal|"r75"
block|,
literal|"r76"
block|,
literal|"r77"
block|,
literal|"r78"
block|,
literal|"r79"
block|,
literal|"r80"
block|,
literal|"r81"
block|,
literal|"r82"
block|,
literal|"r83"
block|,
literal|"r84"
block|,
literal|"r85"
block|,
literal|"r86"
block|,
literal|"r87"
block|,
literal|"r88"
block|,
literal|"r89"
block|,
literal|"r90"
block|,
literal|"r91"
block|,
literal|"r92"
block|,
literal|"r93"
block|,
literal|"r94"
block|,
literal|"r95"
block|,
literal|"r96"
block|,
literal|"r97"
block|,
literal|"r98"
block|,
literal|"r99"
block|,
literal|"r100"
block|,
literal|"r101"
block|,
literal|"r102"
block|,
literal|"r103"
block|,
literal|"r104"
block|,
literal|"r105"
block|,
literal|"r106"
block|,
literal|"r107"
block|,
literal|"r108"
block|,
literal|"r109"
block|,
literal|"r110"
block|,
literal|"r111"
block|,
literal|"r112"
block|,
literal|"r113"
block|,
literal|"r114"
block|,
literal|"r115"
block|,
literal|"r116"
block|,
literal|"r117"
block|,
literal|"r118"
block|,
literal|"r119"
block|,
literal|"r120"
block|,
literal|"r121"
block|,
literal|"r122"
block|,
literal|"r123"
block|,
literal|"r124"
block|,
literal|"r125"
block|,
literal|"r126"
block|,
literal|"r127"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ??? These strings could be shared with REGISTER_NAMES.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|ia64_input_reg_names
index|[
literal|8
index|]
init|=
block|{
literal|"in0"
block|,
literal|"in1"
block|,
literal|"in2"
block|,
literal|"in3"
block|,
literal|"in4"
block|,
literal|"in5"
block|,
literal|"in6"
block|,
literal|"in7"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ??? These strings could be shared with REGISTER_NAMES.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|ia64_local_reg_names
index|[
literal|80
index|]
init|=
block|{
literal|"loc0"
block|,
literal|"loc1"
block|,
literal|"loc2"
block|,
literal|"loc3"
block|,
literal|"loc4"
block|,
literal|"loc5"
block|,
literal|"loc6"
block|,
literal|"loc7"
block|,
literal|"loc8"
block|,
literal|"loc9"
block|,
literal|"loc10"
block|,
literal|"loc11"
block|,
literal|"loc12"
block|,
literal|"loc13"
block|,
literal|"loc14"
block|,
literal|"loc15"
block|,
literal|"loc16"
block|,
literal|"loc17"
block|,
literal|"loc18"
block|,
literal|"loc19"
block|,
literal|"loc20"
block|,
literal|"loc21"
block|,
literal|"loc22"
block|,
literal|"loc23"
block|,
literal|"loc24"
block|,
literal|"loc25"
block|,
literal|"loc26"
block|,
literal|"loc27"
block|,
literal|"loc28"
block|,
literal|"loc29"
block|,
literal|"loc30"
block|,
literal|"loc31"
block|,
literal|"loc32"
block|,
literal|"loc33"
block|,
literal|"loc34"
block|,
literal|"loc35"
block|,
literal|"loc36"
block|,
literal|"loc37"
block|,
literal|"loc38"
block|,
literal|"loc39"
block|,
literal|"loc40"
block|,
literal|"loc41"
block|,
literal|"loc42"
block|,
literal|"loc43"
block|,
literal|"loc44"
block|,
literal|"loc45"
block|,
literal|"loc46"
block|,
literal|"loc47"
block|,
literal|"loc48"
block|,
literal|"loc49"
block|,
literal|"loc50"
block|,
literal|"loc51"
block|,
literal|"loc52"
block|,
literal|"loc53"
block|,
literal|"loc54"
block|,
literal|"loc55"
block|,
literal|"loc56"
block|,
literal|"loc57"
block|,
literal|"loc58"
block|,
literal|"loc59"
block|,
literal|"loc60"
block|,
literal|"loc61"
block|,
literal|"loc62"
block|,
literal|"loc63"
block|,
literal|"loc64"
block|,
literal|"loc65"
block|,
literal|"loc66"
block|,
literal|"loc67"
block|,
literal|"loc68"
block|,
literal|"loc69"
block|,
literal|"loc70"
block|,
literal|"loc71"
block|,
literal|"loc72"
block|,
literal|"loc73"
block|,
literal|"loc74"
block|,
literal|"loc75"
block|,
literal|"loc76"
block|,
literal|"loc77"
block|,
literal|"loc78"
block|,
literal|"loc79"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ??? These strings could be shared with REGISTER_NAMES.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|ia64_output_reg_names
index|[
literal|8
index|]
init|=
block|{
literal|"out0"
block|,
literal|"out1"
block|,
literal|"out2"
block|,
literal|"out3"
block|,
literal|"out4"
block|,
literal|"out5"
block|,
literal|"out6"
block|,
literal|"out7"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* String used with the -mfixed-range= option.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|ia64_fixed_range_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Determines whether we run our final scheduling pass or not.  We always    avoid the normal second scheduling pass.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ia64_flag_schedule_insns2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Variables which are this size or smaller are put in the sdata/sbss    sections.  */
end_comment

begin_decl_stmt
name|unsigned
name|int
name|ia64_section_threshold
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|int
name|find_gr_spill
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|next_scratch_gr_reg
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_reg_gr_used_mask
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ia64_compute_frame_size
name|PARAMS
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|setup_spill_pointers
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|rtx
operator|,
name|HOST_WIDE_INT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|finish_spill_pointers
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|spill_restore_mem
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|HOST_WIDE_INT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_spill
name|PARAMS
argument_list|(
operator|(
name|rtx
argument_list|(
operator|*
argument_list|)
argument_list|(
name|rtx
argument_list|,
name|rtx
argument_list|,
name|rtx
argument_list|)
operator|,
name|rtx
operator|,
name|HOST_WIDE_INT
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_restore
name|PARAMS
argument_list|(
operator|(
name|rtx
argument_list|(
operator|*
argument_list|)
argument_list|(
name|rtx
argument_list|,
name|rtx
argument_list|,
name|rtx
argument_list|)
operator|,
name|rtx
operator|,
name|HOST_WIDE_INT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|gen_movdi_x
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|gen_fr_spill_x
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|gen_fr_restore_x
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|machine_mode
name|hfa_element_mode
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fix_range
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ia64_add_gc_roots
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ia64_init_machine_status
name|PARAMS
argument_list|(
operator|(
expr|struct
name|function
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ia64_mark_machine_status
name|PARAMS
argument_list|(
operator|(
expr|struct
name|function
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ia64_free_machine_status
name|PARAMS
argument_list|(
operator|(
expr|struct
name|function
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|emit_insn_group_barriers
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|emit_all_insn_group_barriers
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|emit_predicate_relation_info
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|process_epilogue
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|process_set
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|ia64_expand_fetch_and_op
name|PARAMS
argument_list|(
operator|(
name|optab
operator|,
expr|enum
name|machine_mode
operator|,
name|tree
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|ia64_expand_op_and_fetch
name|PARAMS
argument_list|(
operator|(
name|optab
operator|,
expr|enum
name|machine_mode
operator|,
name|tree
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|ia64_expand_compare_and_swap
name|PARAMS
argument_list|(
operator|(
expr|enum
name|machine_mode
operator|,
name|int
operator|,
name|tree
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|ia64_expand_lock_test_and_set
name|PARAMS
argument_list|(
operator|(
expr|enum
name|machine_mode
operator|,
name|tree
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|ia64_expand_lock_release
name|PARAMS
argument_list|(
operator|(
expr|enum
name|machine_mode
operator|,
name|tree
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|attribute_spec
name|ia64_attribute_table
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|ia64_assemble_integer
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|unsigned
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ia64_output_function_prologue
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|HOST_WIDE_INT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ia64_output_function_epilogue
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|HOST_WIDE_INT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ia64_output_function_end_prologue
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ia64_issue_rate
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ia64_adjust_cost
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ia64_sched_init
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ia64_sched_finish
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ia64_internal_sched_reorder
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|int
operator|,
name|rtx
operator|*
operator|,
name|int
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ia64_sched_reorder
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|int
operator|,
name|rtx
operator|*
operator|,
name|int
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ia64_sched_reorder2
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|int
operator|,
name|rtx
operator|*
operator|,
name|int
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ia64_variable_issue
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|int
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|ia64_cycle_display
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Initialize the GCC target structure.  */
end_comment

begin_undef
undef|#
directive|undef
name|TARGET_ATTRIBUTE_TABLE
end_undef

begin_define
define|#
directive|define
name|TARGET_ATTRIBUTE_TABLE
value|ia64_attribute_table
end_define

begin_undef
undef|#
directive|undef
name|TARGET_INIT_BUILTINS
end_undef

begin_define
define|#
directive|define
name|TARGET_INIT_BUILTINS
value|ia64_init_builtins
end_define

begin_undef
undef|#
directive|undef
name|TARGET_EXPAND_BUILTIN
end_undef

begin_define
define|#
directive|define
name|TARGET_EXPAND_BUILTIN
value|ia64_expand_builtin
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_BYTE_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_BYTE_OP
value|"\tdata1\t"
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_ALIGNED_HI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_ALIGNED_HI_OP
value|"\tdata2\t"
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_ALIGNED_SI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_ALIGNED_SI_OP
value|"\tdata4\t"
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_ALIGNED_DI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_ALIGNED_DI_OP
value|"\tdata8\t"
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_UNALIGNED_HI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_UNALIGNED_HI_OP
value|"\tdata2.ua\t"
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_UNALIGNED_SI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_UNALIGNED_SI_OP
value|"\tdata4.ua\t"
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_UNALIGNED_DI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_UNALIGNED_DI_OP
value|"\tdata8.ua\t"
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_INTEGER
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_INTEGER
value|ia64_assemble_integer
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_FUNCTION_PROLOGUE
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_FUNCTION_PROLOGUE
value|ia64_output_function_prologue
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_FUNCTION_END_PROLOGUE
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_FUNCTION_END_PROLOGUE
value|ia64_output_function_end_prologue
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_FUNCTION_EPILOGUE
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_FUNCTION_EPILOGUE
value|ia64_output_function_epilogue
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_ADJUST_COST
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_ADJUST_COST
value|ia64_adjust_cost
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_ISSUE_RATE
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_ISSUE_RATE
value|ia64_issue_rate
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_VARIABLE_ISSUE
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_VARIABLE_ISSUE
value|ia64_variable_issue
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_INIT
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_INIT
value|ia64_sched_init
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_FINISH
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_FINISH
value|ia64_sched_finish
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_REORDER
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_REORDER
value|ia64_sched_reorder
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_REORDER2
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_REORDER2
value|ia64_sched_reorder2
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_CYCLE_DISPLAY
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_CYCLE_DISPLAY
value|ia64_cycle_display
end_define

begin_decl_stmt
name|struct
name|gcc_target
name|targetm
init|=
name|TARGET_INITIALIZER
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Return 1 if OP is a valid operand for the MEM of a CALL insn.  */
end_comment

begin_function
name|int
name|call_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP refers to a symbol in the sdata section.  */
end_comment

begin_function
name|int
name|sdata_symbolic_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|CONST
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|SYMBOL_REF
condition|)
break|break;
name|op
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* FALLTHRU */
case|case
name|SYMBOL_REF
case|:
if|if
condition|(
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|op
argument_list|)
condition|)
return|return
name|GET_MODE_SIZE
argument_list|(
name|get_pool_mode
argument_list|(
name|op
argument_list|)
argument_list|)
operator|<=
name|ia64_section_threshold
return|;
else|else
return|return
name|XSTR
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
index|[
literal|0
index|]
operator|==
name|SDATA_NAME_FLAG_CHAR
return|;
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP refers to a symbol, and is appropriate for a GOT load.  */
end_comment

begin_function
name|int
name|got_symbolic_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|CONST
case|:
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|PLUS
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|SYMBOL_REF
condition|)
return|return
literal|0
return|;
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
comment|/* Ok if we're not using GOT entries at all.  */
if|if
condition|(
name|TARGET_NO_PIC
operator|||
name|TARGET_AUTO_PIC
condition|)
return|return
literal|1
return|;
comment|/* "Ok" while emitting rtl, since otherwise we won't be provided 	 with the entire offset during emission, which makes it very 	 hard to split the offset into high and low parts.  */
if|if
condition|(
name|rtx_equal_function_value_matters
condition|)
return|return
literal|1
return|;
comment|/* Force the low 14 bits of the constant to zero so that we do not 	 use up so many GOT entries.  */
return|return
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|&
literal|0x3fff
operator|)
operator|==
literal|0
return|;
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
return|return
literal|1
return|;
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP refers to a symbol.  */
end_comment

begin_function
name|int
name|symbolic_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|CONST
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
return|return
literal|1
return|;
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP refers to a function.  */
end_comment

begin_function
name|int
name|function_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|SYMBOL_REF_FLAG
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is setjmp or a similar function.  */
end_comment

begin_comment
comment|/* ??? This is an unsatisfying solution.  Should rethink.  */
end_comment

begin_function
name|int
name|setjmp_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|SYMBOL_REF
condition|)
return|return
literal|0
return|;
name|name
operator|=
name|XSTR
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* The following code is borrowed from special_function_p in calls.c.  */
comment|/* Disregard prefix _, __ or __x.  */
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'_'
condition|)
block|{
if|if
condition|(
name|name
index|[
literal|1
index|]
operator|==
literal|'_'
operator|&&
name|name
index|[
literal|2
index|]
operator|==
literal|'x'
condition|)
name|name
operator|+=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|name
index|[
literal|1
index|]
operator|==
literal|'_'
condition|)
name|name
operator|+=
literal|2
expr_stmt|;
else|else
name|name
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'s'
condition|)
block|{
name|retval
operator|=
operator|(
operator|(
name|name
index|[
literal|1
index|]
operator|==
literal|'e'
operator|&&
operator|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"setjmp"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"setjmp_syscall"
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|name
index|[
literal|1
index|]
operator|==
literal|'i'
operator|&&
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"sigsetjmp"
argument_list|)
operator|)
operator|||
operator|(
name|name
index|[
literal|1
index|]
operator|==
literal|'a'
operator|&&
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"savectx"
argument_list|)
operator|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|name
index|[
literal|0
index|]
operator|==
literal|'q'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'s'
operator|&&
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"qsetjmp"
argument_list|)
operator|)
operator|||
operator|(
name|name
index|[
literal|0
index|]
operator|==
literal|'v'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'f'
operator|&&
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"vfork"
argument_list|)
operator|)
condition|)
name|retval
operator|=
literal|1
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a general operand, but when pic exclude symbolic    operands.  */
end_comment

begin_comment
comment|/* ??? If we drop no-pic support, can delete SYMBOL_REF, CONST, and LABEL_REF    from PREDICATE_CODES.  */
end_comment

begin_function
name|int
name|move_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|TARGET_NO_PIC
operator|&&
name|symbolic_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|general_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a register operand that is (or could be) a GR reg.  */
end_comment

begin_function
name|int
name|gr_register_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
condition|)
block|{
name|unsigned
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
return|return
name|GENERAL_REGNO_P
argument_list|(
name|regno
argument_list|)
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a register operand that is (or could be) an FR reg.  */
end_comment

begin_function
name|int
name|fr_register_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
condition|)
block|{
name|unsigned
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
return|return
name|FR_REGNO_P
argument_list|(
name|regno
argument_list|)
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a register operand that is (or could be) a GR/FR reg.  */
end_comment

begin_function
name|int
name|grfr_register_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
condition|)
block|{
name|unsigned
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
return|return
name|GENERAL_REGNO_P
argument_list|(
name|regno
argument_list|)
operator|||
name|FR_REGNO_P
argument_list|(
name|regno
argument_list|)
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a nonimmediate operand that is (or could be) a GR reg.  */
end_comment

begin_function
name|int
name|gr_nonimmediate_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|nonimmediate_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
condition|)
block|{
name|unsigned
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
return|return
name|GENERAL_REGNO_P
argument_list|(
name|regno
argument_list|)
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a nonimmediate operand that is (or could be) a FR reg.  */
end_comment

begin_function
name|int
name|fr_nonimmediate_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|nonimmediate_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
condition|)
block|{
name|unsigned
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
return|return
name|FR_REGNO_P
argument_list|(
name|regno
argument_list|)
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a nonimmediate operand that is a GR/FR reg.  */
end_comment

begin_function
name|int
name|grfr_nonimmediate_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|nonimmediate_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
condition|)
block|{
name|unsigned
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
return|return
name|GENERAL_REGNO_P
argument_list|(
name|regno
argument_list|)
operator|||
name|FR_REGNO_P
argument_list|(
name|regno
argument_list|)
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a GR register operand, or zero.  */
end_comment

begin_function
name|int
name|gr_reg_or_0_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|op
operator|==
name|const0_rtx
operator|||
name|gr_register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a GR register operand, or a 5 bit immediate operand.  */
end_comment

begin_function
name|int
name|gr_reg_or_5bit_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|>=
literal|0
operator|&&
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<
literal|32
operator|)
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONSTANT_P_RTX
operator|||
name|gr_register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a GR register operand, or a 6 bit immediate operand.  */
end_comment

begin_function
name|int
name|gr_reg_or_6bit_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|CONST_OK_FOR_M
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|)
operator|)
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONSTANT_P_RTX
operator|||
name|gr_register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a GR register operand, or an 8 bit immediate operand.  */
end_comment

begin_function
name|int
name|gr_reg_or_8bit_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|CONST_OK_FOR_K
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|)
operator|)
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONSTANT_P_RTX
operator|||
name|gr_register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a GR/FR register operand, or an 8 bit immediate.  */
end_comment

begin_function
name|int
name|grfr_reg_or_8bit_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|CONST_OK_FOR_K
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|)
operator|)
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONSTANT_P_RTX
operator|||
name|grfr_register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a register operand, or an 8 bit adjusted immediate    operand.  */
end_comment

begin_function
name|int
name|gr_reg_or_8bit_adjusted_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|CONST_OK_FOR_L
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|)
operator|)
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONSTANT_P_RTX
operator|||
name|gr_register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a register operand, or is valid for both an 8 bit    immediate and an 8 bit adjusted immediate operand.  This is necessary    because when we emit a compare, we don't know what the condition will be,    so we need the union of the immediates accepted by GT and LT.  */
end_comment

begin_function
name|int
name|gr_reg_or_8bit_and_adjusted_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|CONST_OK_FOR_K
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|)
operator|&&
name|CONST_OK_FOR_L
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|)
operator|)
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONSTANT_P_RTX
operator|||
name|gr_register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a register operand, or a 14 bit immediate operand.  */
end_comment

begin_function
name|int
name|gr_reg_or_14bit_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|CONST_OK_FOR_I
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|)
operator|)
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONSTANT_P_RTX
operator|||
name|gr_register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a register operand, or a 22 bit immediate operand.  */
end_comment

begin_function
name|int
name|gr_reg_or_22bit_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|CONST_OK_FOR_J
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|)
operator|)
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONSTANT_P_RTX
operator|||
name|gr_register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a 6 bit immediate operand.  */
end_comment

begin_function
name|int
name|shift_count_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|CONST_OK_FOR_M
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|)
operator|)
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONSTANT_P_RTX
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a 5 bit immediate operand.  */
end_comment

begin_function
name|int
name|shift_32bit_count_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|>=
literal|0
operator|&&
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<
literal|32
operator|)
operator|)
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONSTANT_P_RTX
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a 2, 4, 8, or 16 immediate operand.  */
end_comment

begin_function
name|int
name|shladd_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|==
literal|2
operator|||
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|==
literal|4
operator|||
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|==
literal|8
operator|||
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|==
literal|16
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a -16, -8, -4, -1, 1, 4, 8, or 16 immediate operand.  */
end_comment

begin_function
name|int
name|fetchadd_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|==
operator|-
literal|16
operator|||
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|==
operator|-
literal|8
operator|||
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|==
operator|-
literal|4
operator|||
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|==
literal|1
operator|||
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|==
literal|4
operator|||
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|==
literal|8
operator|||
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|==
literal|16
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a floating-point constant zero, one, or a register.  */
end_comment

begin_function
name|int
name|fr_reg_or_fp01_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|CONST_DOUBLE_OK_FOR_G
argument_list|(
name|op
argument_list|)
operator|)
operator|||
name|fr_register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Like nonimmediate_operand, but don't allow MEMs that try to use a    POST_MODIFY with a REG as displacement.  */
end_comment

begin_function
name|int
name|destination_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|nonimmediate_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|POST_MODIFY
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Like memory_operand, but don't allow post-increments.  */
end_comment

begin_function
name|int
name|not_postinc_memory_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|memory_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
literal|'a'
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if this is a comparison operator, which accepts an normal 8-bit    signed immediate operand.  */
end_comment

begin_function
name|int
name|normal_comparison_operator
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
return|return
operator|(
operator|(
name|mode
operator|==
name|VOIDmode
operator|||
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|mode
operator|)
operator|&&
operator|(
name|code
operator|==
name|EQ
operator|||
name|code
operator|==
name|NE
operator|||
name|code
operator|==
name|GT
operator|||
name|code
operator|==
name|LE
operator|||
name|code
operator|==
name|GTU
operator|||
name|code
operator|==
name|LEU
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if this is a comparison operator, which accepts an adjusted 8-bit    signed immediate operand.  */
end_comment

begin_function
name|int
name|adjusted_comparison_operator
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
return|return
operator|(
operator|(
name|mode
operator|==
name|VOIDmode
operator|||
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|mode
operator|)
operator|&&
operator|(
name|code
operator|==
name|LT
operator|||
name|code
operator|==
name|GE
operator|||
name|code
operator|==
name|LTU
operator|||
name|code
operator|==
name|GEU
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if this is a signed inequality operator.  */
end_comment

begin_function
name|int
name|signed_inequality_operator
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
return|return
operator|(
operator|(
name|mode
operator|==
name|VOIDmode
operator|||
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|mode
operator|)
operator|&&
operator|(
name|code
operator|==
name|GE
operator|||
name|code
operator|==
name|GT
operator|||
name|code
operator|==
name|LE
operator|||
name|code
operator|==
name|LT
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if this operator is valid for predication.  */
end_comment

begin_function
name|int
name|predicate_operator
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
return|return
operator|(
operator|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|mode
operator|||
name|mode
operator|==
name|VOIDmode
operator|)
operator|&&
operator|(
name|code
operator|==
name|EQ
operator|||
name|code
operator|==
name|NE
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if this operator can be used in a conditional operation.  */
end_comment

begin_function
name|int
name|condop_operator
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
return|return
operator|(
operator|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|mode
operator|||
name|mode
operator|==
name|VOIDmode
operator|)
operator|&&
operator|(
name|code
operator|==
name|PLUS
operator|||
name|code
operator|==
name|MINUS
operator|||
name|code
operator|==
name|AND
operator|||
name|code
operator|==
name|IOR
operator|||
name|code
operator|==
name|XOR
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if this is the ar.lc register.  */
end_comment

begin_function
name|int
name|ar_lc_reg_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|DImode
operator|&&
operator|(
name|mode
operator|==
name|DImode
operator|||
name|mode
operator|==
name|VOIDmode
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|==
name|AR_LC_REGNUM
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if this is the ar.ccv register.  */
end_comment

begin_function
name|int
name|ar_ccv_reg_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|mode
operator|||
name|mode
operator|==
name|VOIDmode
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|==
name|AR_CCV_REGNUM
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if this is the ar.pfs register.  */
end_comment

begin_function
name|int
name|ar_pfs_reg_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|mode
operator|||
name|mode
operator|==
name|VOIDmode
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|==
name|AR_PFS_REGNUM
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Like general_operand, but don't allow (mem (addressof)).  */
end_comment

begin_function
name|int
name|general_tfmode_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|general_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ADDRESSOF
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Similarly.  */
end_comment

begin_function
name|int
name|destination_tfmode_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|destination_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ADDRESSOF
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Similarly.  */
end_comment

begin_function
name|int
name|tfreg_or_fp01_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
return|return
literal|0
return|;
return|return
name|fr_reg_or_fp01_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if the operands of a move are ok.  */
end_comment

begin_function
name|int
name|ia64_move_ok
parameter_list|(
name|dst
parameter_list|,
name|src
parameter_list|)
name|rtx
name|dst
decl_stmt|,
name|src
decl_stmt|;
block|{
comment|/* If we're under init_recog_no_volatile, we'll not be able to use      memory_operand.  So check the code directly and don't worry about      the validity of the underlying address, which should have been      checked elsewhere anyway.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|!=
name|MEM
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|MEM
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|register_operand
argument_list|(
name|src
argument_list|,
name|VOIDmode
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Otherwise, this must be a constant, and that either 0 or 0.0 or 1.0.  */
if|if
condition|(
name|INTEGRAL_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|dst
argument_list|)
argument_list|)
condition|)
return|return
name|src
operator|==
name|const0_rtx
return|;
else|else
return|return
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|CONST_DOUBLE_OK_FOR_G
argument_list|(
name|src
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Check if OP is a mask suitible for use with SHIFT in a dep.z instruction.    Return the length of the field, or<= 0 on failure.  */
end_comment

begin_function
name|int
name|ia64_depz_field_mask
parameter_list|(
name|rop
parameter_list|,
name|rshift
parameter_list|)
name|rtx
name|rop
decl_stmt|,
name|rshift
decl_stmt|;
block|{
name|unsigned
name|HOST_WIDE_INT
name|op
init|=
name|INTVAL
argument_list|(
name|rop
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|shift
init|=
name|INTVAL
argument_list|(
name|rshift
argument_list|)
decl_stmt|;
comment|/* Get rid of the zero bits we're shifting in.  */
name|op
operator|>>=
name|shift
expr_stmt|;
comment|/* We must now have a solid block of 1's at bit 0.  */
return|return
name|exact_log2
argument_list|(
name|op
operator|+
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Expand a symbolic constant load.  */
end_comment

begin_comment
comment|/* ??? Should generalize this, so that we can also support 32 bit pointers.  */
end_comment

begin_function
name|void
name|ia64_expand_load_address
parameter_list|(
name|dest
parameter_list|,
name|src
parameter_list|,
name|scratch
parameter_list|)
name|rtx
name|dest
decl_stmt|,
name|src
decl_stmt|,
name|scratch
decl_stmt|;
block|{
name|rtx
name|temp
decl_stmt|;
comment|/* The destination could be a MEM during initial rtl generation,      which isn't a valid destination for the PIC load address patterns.  */
if|if
condition|(
operator|!
name|register_operand
argument_list|(
name|dest
argument_list|,
name|DImode
argument_list|)
condition|)
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
else|else
name|temp
operator|=
name|dest
expr_stmt|;
if|if
condition|(
name|TARGET_AUTO_PIC
condition|)
name|emit_insn
argument_list|(
name|gen_load_gprel64
argument_list|(
name|temp
argument_list|,
name|src
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|SYMBOL_REF_FLAG
argument_list|(
name|src
argument_list|)
condition|)
name|emit_insn
argument_list|(
name|gen_load_fptr
argument_list|(
name|temp
argument_list|,
name|src
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sdata_symbolic_operand
argument_list|(
name|src
argument_list|,
name|DImode
argument_list|)
condition|)
name|emit_insn
argument_list|(
name|gen_load_gprel
argument_list|(
name|temp
argument_list|,
name|src
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&
literal|0x1fff
operator|)
operator|!=
literal|0
condition|)
block|{
name|rtx
name|subtarget
init|=
name|no_new_pseudos
condition|?
name|temp
else|:
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
decl_stmt|;
name|rtx
name|sym
init|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|ofs
decl_stmt|,
name|hi
decl_stmt|,
name|lo
decl_stmt|;
comment|/* Split the offset into a sign extended 14-bit low part 	 and a complementary high part.  */
name|ofs
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|lo
operator|=
operator|(
operator|(
name|ofs
operator|&
literal|0x3fff
operator|)
operator|^
literal|0x2000
operator|)
operator|-
literal|0x2000
expr_stmt|;
name|hi
operator|=
name|ofs
operator|-
name|lo
expr_stmt|;
if|if
condition|(
operator|!
name|scratch
condition|)
name|scratch
operator|=
name|no_new_pseudos
condition|?
name|subtarget
else|:
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_load_symptr
argument_list|(
name|subtarget
argument_list|,
name|plus_constant
argument_list|(
name|sym
argument_list|,
name|hi
argument_list|)
argument_list|,
name|scratch
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|temp
argument_list|,
name|subtarget
argument_list|,
name|GEN_INT
argument_list|(
name|lo
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
operator|!
name|scratch
condition|)
name|scratch
operator|=
name|no_new_pseudos
condition|?
name|temp
else|:
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_load_symptr
argument_list|(
name|temp
argument_list|,
name|src
argument_list|,
name|scratch
argument_list|)
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_EQUAL
argument_list|,
name|src
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|temp
operator|!=
name|dest
condition|)
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|rtx
name|ia64_gp_save_reg
parameter_list|(
name|setjmp_p
parameter_list|)
name|int
name|setjmp_p
decl_stmt|;
block|{
name|rtx
name|save
init|=
name|cfun
operator|->
name|machine
operator|->
name|ia64_gp_save
decl_stmt|;
if|if
condition|(
name|save
operator|!=
name|NULL
condition|)
block|{
comment|/* We can't save GP in a pseudo if we are calling setjmp, because 	 pseudos won't be restored by longjmp.  For now, we save it in r4.  */
comment|/* ??? It would be more efficient to save this directly into a stack 	 slot.  Unfortunately, the stack slot address gets cse'd across 	 the setjmp call because the NOTE_INSN_SETJMP note is in the wrong 	 place.  */
comment|/* ??? Get the barf bag, Virginia.  We've got to replace this thing          in place, since this rtx is used in exception handling receivers.          Moreover, we must get this rtx out of regno_reg_rtx or reload          will do the wrong thing.  */
name|unsigned
name|int
name|old_regno
init|=
name|REGNO
argument_list|(
name|save
argument_list|)
decl_stmt|;
if|if
condition|(
name|setjmp_p
operator|&&
name|old_regno
operator|!=
name|GR_REG
argument_list|(
literal|4
argument_list|)
condition|)
block|{
name|REGNO
argument_list|(
name|save
argument_list|)
operator|=
name|GR_REG
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|regno_reg_rtx
index|[
name|old_regno
index|]
operator|=
name|gen_rtx_raw_REG
argument_list|(
name|DImode
argument_list|,
name|old_regno
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|setjmp_p
condition|)
name|save
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|GR_REG
argument_list|(
literal|4
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|optimize
condition|)
name|save
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|LOC_REG
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|save
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
name|cfun
operator|->
name|machine
operator|->
name|ia64_gp_save
operator|=
name|save
expr_stmt|;
block|}
return|return
name|save
return|;
block|}
end_function

begin_comment
comment|/* Split a post-reload TImode reference into two DImode components.  */
end_comment

begin_function
name|rtx
name|ia64_split_timode
parameter_list|(
name|out
parameter_list|,
name|in
parameter_list|,
name|scratch
parameter_list|)
name|rtx
name|out
index|[
literal|2
index|]
decl_stmt|;
name|rtx
name|in
decl_stmt|,
name|scratch
decl_stmt|;
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|in
argument_list|)
condition|)
block|{
case|case
name|REG
case|:
name|out
index|[
literal|0
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|REGNO
argument_list|(
name|in
argument_list|)
argument_list|)
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|REGNO
argument_list|(
name|in
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|NULL_RTX
return|;
case|case
name|MEM
case|:
block|{
name|rtx
name|base
init|=
name|XEXP
argument_list|(
name|in
argument_list|,
literal|0
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
condition|)
block|{
case|case
name|REG
case|:
name|out
index|[
literal|0
index|]
operator|=
name|adjust_address
argument_list|(
name|in
argument_list|,
name|DImode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|POST_MODIFY
case|:
name|base
operator|=
name|XEXP
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|out
index|[
literal|0
index|]
operator|=
name|adjust_address
argument_list|(
name|in
argument_list|,
name|DImode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
comment|/* Since we're changing the mode, we need to change to POST_MODIFY 	     as well to preserve the size of the increment.  Either that or 	     do the update in two steps, but we've already got this scratch 	     register handy so let's use it.  */
case|case
name|POST_INC
case|:
name|base
operator|=
name|XEXP
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|out
index|[
literal|0
index|]
operator|=
name|change_address
argument_list|(
name|in
argument_list|,
name|DImode
argument_list|,
name|gen_rtx_POST_MODIFY
argument_list|(
name|Pmode
argument_list|,
name|base
argument_list|,
name|plus_constant
argument_list|(
name|base
argument_list|,
literal|16
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|POST_DEC
case|:
name|base
operator|=
name|XEXP
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|out
index|[
literal|0
index|]
operator|=
name|change_address
argument_list|(
name|in
argument_list|,
name|DImode
argument_list|,
name|gen_rtx_POST_MODIFY
argument_list|(
name|Pmode
argument_list|,
name|base
argument_list|,
name|plus_constant
argument_list|(
name|base
argument_list|,
operator|-
literal|16
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|scratch
operator|==
name|NULL_RTX
condition|)
name|abort
argument_list|()
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|=
name|change_address
argument_list|(
name|in
argument_list|,
name|DImode
argument_list|,
name|scratch
argument_list|)
expr_stmt|;
return|return
name|gen_adddi3
argument_list|(
name|scratch
argument_list|,
name|base
argument_list|,
name|GEN_INT
argument_list|(
literal|8
argument_list|)
argument_list|)
return|;
block|}
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
name|split_double
argument_list|(
name|in
argument_list|,
operator|&
name|out
index|[
literal|0
index|]
argument_list|,
operator|&
name|out
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
name|NULL_RTX
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ??? Fixing GR->FR TFmode moves during reload is hard.  You need to go    through memory plus an extra GR scratch register.  Except that you can    either get the first from SECONDARY_MEMORY_NEEDED or the second from    SECONDARY_RELOAD_CLASS, but not both.     We got into problems in the first place by allowing a construct like    (subreg:TF (reg:TI)), which we got from a union containing a long double.      This solution attempts to prevent this situation from occurring.  When    we see something like the above, we spill the inner register to memory.  */
end_comment

begin_function
name|rtx
name|spill_tfmode_operand
parameter_list|(
name|in
parameter_list|,
name|force
parameter_list|)
name|rtx
name|in
decl_stmt|;
name|int
name|force
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|in
argument_list|)
argument_list|)
operator|==
name|TImode
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|in
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|rtx
name|mem
init|=
name|gen_mem_addressof
argument_list|(
name|SUBREG_REG
argument_list|(
name|in
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
return|return
name|gen_rtx_MEM
argument_list|(
name|TFmode
argument_list|,
name|copy_to_reg
argument_list|(
name|XEXP
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|force
operator|&&
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|REG
condition|)
block|{
name|rtx
name|mem
init|=
name|gen_mem_addressof
argument_list|(
name|in
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
return|return
name|gen_rtx_MEM
argument_list|(
name|TFmode
argument_list|,
name|copy_to_reg
argument_list|(
name|XEXP
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|in
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ADDRESSOF
condition|)
return|return
name|change_address
argument_list|(
name|in
argument_list|,
name|TFmode
argument_list|,
name|copy_to_reg
argument_list|(
name|XEXP
argument_list|(
name|in
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
else|else
return|return
name|in
return|;
block|}
end_function

begin_comment
comment|/* Emit comparison instruction if necessary, returning the expression    that holds the compare result in the proper mode.  */
end_comment

begin_function
name|rtx
name|ia64_expand_compare
parameter_list|(
name|code
parameter_list|,
name|mode
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|rtx
name|op0
init|=
name|ia64_compare_op0
decl_stmt|,
name|op1
init|=
name|ia64_compare_op1
decl_stmt|;
name|rtx
name|cmp
decl_stmt|;
comment|/* If we have a BImode input, then we already have a compare result, and      do not need to emit another comparison.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
name|BImode
condition|)
block|{
if|if
condition|(
operator|(
name|code
operator|==
name|NE
operator|||
name|code
operator|==
name|EQ
operator|)
operator|&&
name|op1
operator|==
name|const0_rtx
condition|)
name|cmp
operator|=
name|op0
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|cmp
operator|=
name|gen_reg_rtx
argument_list|(
name|BImode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|cmp
argument_list|,
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|BImode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|=
name|NE
expr_stmt|;
block|}
return|return
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|cmp
argument_list|,
name|const0_rtx
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Emit the appropriate sequence for a call.  */
end_comment

begin_function
name|void
name|ia64_expand_call
parameter_list|(
name|retval
parameter_list|,
name|addr
parameter_list|,
name|nextarg
parameter_list|,
name|sibcall_p
parameter_list|)
name|rtx
name|retval
decl_stmt|;
name|rtx
name|addr
decl_stmt|;
name|rtx
name|nextarg
decl_stmt|;
name|int
name|sibcall_p
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|,
name|b0
decl_stmt|,
name|pfs
decl_stmt|,
name|gp_save
decl_stmt|,
name|narg_rtx
decl_stmt|;
name|int
name|narg
decl_stmt|;
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|b0
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|R_BR
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|pfs
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|AR_PFS_REGNUM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nextarg
condition|)
name|narg
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|IN_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|nextarg
argument_list|)
argument_list|)
condition|)
name|narg
operator|=
name|REGNO
argument_list|(
name|nextarg
argument_list|)
operator|-
name|IN_REG
argument_list|(
literal|0
argument_list|)
expr_stmt|;
else|else
name|narg
operator|=
name|REGNO
argument_list|(
name|nextarg
argument_list|)
operator|-
name|OUT_REG
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|narg_rtx
operator|=
name|GEN_INT
argument_list|(
name|narg
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_NO_PIC
operator|||
name|TARGET_AUTO_PIC
condition|)
block|{
if|if
condition|(
name|sibcall_p
condition|)
name|insn
operator|=
name|gen_sibcall_nopic
argument_list|(
name|addr
argument_list|,
name|narg_rtx
argument_list|,
name|b0
argument_list|,
name|pfs
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|retval
condition|)
name|insn
operator|=
name|gen_call_nopic
argument_list|(
name|addr
argument_list|,
name|narg_rtx
argument_list|,
name|b0
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|gen_call_value_nopic
argument_list|(
name|retval
argument_list|,
name|addr
argument_list|,
name|narg_rtx
argument_list|,
name|b0
argument_list|)
expr_stmt|;
name|emit_call_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sibcall_p
condition|)
name|gp_save
operator|=
name|NULL_RTX
expr_stmt|;
else|else
name|gp_save
operator|=
name|ia64_gp_save_reg
argument_list|(
name|setjmp_operand
argument_list|(
name|addr
argument_list|,
name|VOIDmode
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If this is an indirect call, then we have the address of a descriptor.  */
if|if
condition|(
operator|!
name|symbolic_operand
argument_list|(
name|addr
argument_list|,
name|VOIDmode
argument_list|)
condition|)
block|{
name|rtx
name|dest
decl_stmt|;
if|if
condition|(
operator|!
name|sibcall_p
condition|)
name|emit_move_insn
argument_list|(
name|gp_save
argument_list|,
name|pic_offset_table_rtx
argument_list|)
expr_stmt|;
name|dest
operator|=
name|force_reg
argument_list|(
name|DImode
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|DImode
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|pic_offset_table_rtx
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|DImode
argument_list|,
name|plus_constant
argument_list|(
name|addr
argument_list|,
literal|8
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sibcall_p
condition|)
name|insn
operator|=
name|gen_sibcall_pic
argument_list|(
name|dest
argument_list|,
name|narg_rtx
argument_list|,
name|b0
argument_list|,
name|pfs
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|retval
condition|)
name|insn
operator|=
name|gen_call_pic
argument_list|(
name|dest
argument_list|,
name|narg_rtx
argument_list|,
name|b0
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|gen_call_value_pic
argument_list|(
name|retval
argument_list|,
name|dest
argument_list|,
name|narg_rtx
argument_list|,
name|b0
argument_list|)
expr_stmt|;
name|emit_call_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sibcall_p
condition|)
name|emit_move_insn
argument_list|(
name|pic_offset_table_rtx
argument_list|,
name|gp_save
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TARGET_CONST_GP
condition|)
block|{
if|if
condition|(
name|sibcall_p
condition|)
name|insn
operator|=
name|gen_sibcall_nopic
argument_list|(
name|addr
argument_list|,
name|narg_rtx
argument_list|,
name|b0
argument_list|,
name|pfs
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|retval
condition|)
name|insn
operator|=
name|gen_call_nopic
argument_list|(
name|addr
argument_list|,
name|narg_rtx
argument_list|,
name|b0
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|gen_call_value_nopic
argument_list|(
name|retval
argument_list|,
name|addr
argument_list|,
name|narg_rtx
argument_list|,
name|b0
argument_list|)
expr_stmt|;
name|emit_call_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sibcall_p
condition|)
name|emit_call_insn
argument_list|(
name|gen_sibcall_pic
argument_list|(
name|addr
argument_list|,
name|narg_rtx
argument_list|,
name|b0
argument_list|,
name|pfs
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|emit_move_insn
argument_list|(
name|gp_save
argument_list|,
name|pic_offset_table_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|retval
condition|)
name|insn
operator|=
name|gen_call_pic
argument_list|(
name|addr
argument_list|,
name|narg_rtx
argument_list|,
name|b0
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|gen_call_value_pic
argument_list|(
name|retval
argument_list|,
name|addr
argument_list|,
name|narg_rtx
argument_list|,
name|b0
argument_list|)
expr_stmt|;
name|emit_call_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|pic_offset_table_rtx
argument_list|,
name|gp_save
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Begin the assembly file.  */
end_comment

begin_function
name|void
name|emit_safe_across_calls
parameter_list|(
name|f
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
block|{
name|unsigned
name|int
name|rs
decl_stmt|,
name|re
decl_stmt|;
name|int
name|out_state
decl_stmt|;
name|rs
operator|=
literal|1
expr_stmt|;
name|out_state
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
while|while
condition|(
name|rs
operator|<
literal|64
operator|&&
name|call_used_regs
index|[
name|PR_REG
argument_list|(
name|rs
argument_list|)
index|]
condition|)
name|rs
operator|++
expr_stmt|;
if|if
condition|(
name|rs
operator|>=
literal|64
condition|)
break|break;
for|for
control|(
name|re
operator|=
name|rs
operator|+
literal|1
init|;
name|re
operator|<
literal|64
operator|&&
operator|!
name|call_used_regs
index|[
name|PR_REG
argument_list|(
name|re
argument_list|)
index|]
condition|;
name|re
operator|++
control|)
continue|continue;
if|if
condition|(
name|out_state
operator|==
literal|0
condition|)
block|{
name|fputs
argument_list|(
literal|"\t.pred.safe_across_calls "
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|out_state
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|fputc
argument_list|(
literal|','
argument_list|,
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|re
operator|==
name|rs
operator|+
literal|1
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"p%u"
argument_list|,
name|rs
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"p%u-p%u"
argument_list|,
name|rs
argument_list|,
name|re
operator|-
literal|1
argument_list|)
expr_stmt|;
name|rs
operator|=
name|re
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|out_state
condition|)
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Structure to be filled in by ia64_compute_frame_size with register    save masks and offsets for the current function.  */
end_comment

begin_struct
struct|struct
name|ia64_frame_info
block|{
name|HOST_WIDE_INT
name|total_size
decl_stmt|;
comment|/* size of the stack frame, not including 				   the caller's scratch area.  */
name|HOST_WIDE_INT
name|spill_cfa_off
decl_stmt|;
comment|/* top of the reg spill area from the cfa.  */
name|HOST_WIDE_INT
name|spill_size
decl_stmt|;
comment|/* size of the gr/br/fr spill area.  */
name|HOST_WIDE_INT
name|extra_spill_size
decl_stmt|;
comment|/* size of spill area for others.  */
name|HARD_REG_SET
name|mask
decl_stmt|;
comment|/* mask of saved registers.  */
name|unsigned
name|int
name|gr_used_mask
decl_stmt|;
comment|/* mask of registers in use as gr spill  				   registers or long-term scratches.  */
name|int
name|n_spilled
decl_stmt|;
comment|/* number of spilled registers.  */
name|int
name|reg_fp
decl_stmt|;
comment|/* register for fp.  */
name|int
name|reg_save_b0
decl_stmt|;
comment|/* save register for b0.  */
name|int
name|reg_save_pr
decl_stmt|;
comment|/* save register for prs.  */
name|int
name|reg_save_ar_pfs
decl_stmt|;
comment|/* save register for ar.pfs.  */
name|int
name|reg_save_ar_unat
decl_stmt|;
comment|/* save register for ar.unat.  */
name|int
name|reg_save_ar_lc
decl_stmt|;
comment|/* save register for ar.lc.  */
name|int
name|n_input_regs
decl_stmt|;
comment|/* number of input registers used.  */
name|int
name|n_local_regs
decl_stmt|;
comment|/* number of local registers used.  */
name|int
name|n_output_regs
decl_stmt|;
comment|/* number of output registers used.  */
name|int
name|n_rotate_regs
decl_stmt|;
comment|/* number of rotating registers used.  */
name|char
name|need_regstk
decl_stmt|;
comment|/* true if a .regstk directive needed.  */
name|char
name|initialized
decl_stmt|;
comment|/* true if the data is finalized.  */
block|}
struct|;
end_struct

begin_comment
comment|/* Current frame information calculated by ia64_compute_frame_size.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ia64_frame_info
name|current_frame_info
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Helper function for ia64_compute_frame_size: find an appropriate general    register to spill some special register to.  SPECIAL_SPILL_MASK contains    bits in GR0 to GR31 that have already been allocated by this routine.    TRY_LOCALS is true if we should attempt to locate a local regnum.  */
end_comment

begin_function
specifier|static
name|int
name|find_gr_spill
parameter_list|(
name|try_locals
parameter_list|)
name|int
name|try_locals
decl_stmt|;
block|{
name|int
name|regno
decl_stmt|;
comment|/* If this is a leaf function, first try an otherwise unused      call-clobbered register.  */
if|if
condition|(
name|current_function_is_leaf
condition|)
block|{
for|for
control|(
name|regno
operator|=
name|GR_REG
argument_list|(
literal|1
argument_list|)
init|;
name|regno
operator|<=
name|GR_REG
argument_list|(
literal|31
argument_list|)
condition|;
name|regno
operator|++
control|)
if|if
condition|(
operator|!
name|regs_ever_live
index|[
name|regno
index|]
operator|&&
name|call_used_regs
index|[
name|regno
index|]
operator|&&
operator|!
name|fixed_regs
index|[
name|regno
index|]
operator|&&
operator|!
name|global_regs
index|[
name|regno
index|]
operator|&&
operator|(
operator|(
name|current_frame_info
operator|.
name|gr_used_mask
operator|>>
name|regno
operator|)
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
name|current_frame_info
operator|.
name|gr_used_mask
operator||=
literal|1
operator|<<
name|regno
expr_stmt|;
return|return
name|regno
return|;
block|}
block|}
if|if
condition|(
name|try_locals
condition|)
block|{
name|regno
operator|=
name|current_frame_info
operator|.
name|n_local_regs
expr_stmt|;
comment|/* If there is a frame pointer, then we can't use loc79, because 	 that is HARD_FRAME_POINTER_REGNUM.  In particular, see the 	 reg_name switching code in ia64_expand_prologue.  */
if|if
condition|(
name|regno
operator|<
operator|(
literal|80
operator|-
name|frame_pointer_needed
operator|)
condition|)
block|{
name|current_frame_info
operator|.
name|n_local_regs
operator|=
name|regno
operator|+
literal|1
expr_stmt|;
return|return
name|LOC_REG
argument_list|(
literal|0
argument_list|)
operator|+
name|regno
return|;
block|}
block|}
comment|/* Failed to find a general register to spill to.  Must use stack.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* In order to make for nice schedules, we try to allocate every temporary    to a different register.  We must of course stay away from call-saved,    fixed, and global registers.  We must also stay away from registers    allocated in current_frame_info.gr_used_mask, since those include regs    used all through the prologue.     Any register allocated here must be used immediately.  The idea is to    aid scheduling, not to solve data flow problems.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|last_scratch_gr_reg
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|next_scratch_gr_reg
parameter_list|()
block|{
name|int
name|i
decl_stmt|,
name|regno
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
operator|++
name|i
control|)
block|{
name|regno
operator|=
operator|(
name|last_scratch_gr_reg
operator|+
name|i
operator|+
literal|1
operator|)
operator|&
literal|31
expr_stmt|;
if|if
condition|(
name|call_used_regs
index|[
name|regno
index|]
operator|&&
operator|!
name|fixed_regs
index|[
name|regno
index|]
operator|&&
operator|!
name|global_regs
index|[
name|regno
index|]
operator|&&
operator|(
operator|(
name|current_frame_info
operator|.
name|gr_used_mask
operator|>>
name|regno
operator|)
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
name|last_scratch_gr_reg
operator|=
name|regno
expr_stmt|;
return|return
name|regno
return|;
block|}
block|}
comment|/* There must be _something_ available.  */
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Helper function for ia64_compute_frame_size, called through    diddle_return_value.  Mark REG in current_frame_info.gr_used_mask.  */
end_comment

begin_function
specifier|static
name|void
name|mark_reg_gr_used_mask
parameter_list|(
name|reg
parameter_list|,
name|data
parameter_list|)
name|rtx
name|reg
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|unsigned
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|reg
argument_list|)
decl_stmt|;
if|if
condition|(
name|regno
operator|<
literal|32
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|n
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
name|current_frame_info
operator|.
name|gr_used_mask
operator||=
literal|1
operator|<<
operator|(
name|regno
operator|+
name|i
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Returns the number of bytes offset between the frame pointer and the stack    pointer for the current function.  SIZE is the number of bytes of space    needed for local variables.  */
end_comment

begin_function
specifier|static
name|void
name|ia64_compute_frame_size
parameter_list|(
name|size
parameter_list|)
name|HOST_WIDE_INT
name|size
decl_stmt|;
block|{
name|HOST_WIDE_INT
name|total_size
decl_stmt|;
name|HOST_WIDE_INT
name|spill_size
init|=
literal|0
decl_stmt|;
name|HOST_WIDE_INT
name|extra_spill_size
init|=
literal|0
decl_stmt|;
name|HOST_WIDE_INT
name|pretend_args_size
decl_stmt|;
name|HARD_REG_SET
name|mask
decl_stmt|;
name|int
name|n_spilled
init|=
literal|0
decl_stmt|;
name|int
name|spilled_gr_p
init|=
literal|0
decl_stmt|;
name|int
name|spilled_fr_p
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|regno
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|current_frame_info
operator|.
name|initialized
condition|)
return|return;
name|memset
argument_list|(
operator|&
name|current_frame_info
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|current_frame_info
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|mask
argument_list|)
expr_stmt|;
comment|/* Don't allocate scratches to the return register.  */
name|diddle_return_value
argument_list|(
name|mark_reg_gr_used_mask
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Don't allocate scratches to the EH scratch registers.  */
if|if
condition|(
name|cfun
operator|->
name|machine
operator|->
name|ia64_eh_epilogue_sp
condition|)
name|mark_reg_gr_used_mask
argument_list|(
name|cfun
operator|->
name|machine
operator|->
name|ia64_eh_epilogue_sp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfun
operator|->
name|machine
operator|->
name|ia64_eh_epilogue_bsp
condition|)
name|mark_reg_gr_used_mask
argument_list|(
name|cfun
operator|->
name|machine
operator|->
name|ia64_eh_epilogue_bsp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Find the size of the register stack frame.  We have only 80 local      registers, because we reserve 8 for the inputs and 8 for the      outputs.  */
comment|/* Skip HARD_FRAME_POINTER_REGNUM (loc79) when frame_pointer_needed,      since we'll be adjusting that down later.  */
name|regno
operator|=
name|LOC_REG
argument_list|(
literal|78
argument_list|)
operator|+
operator|!
name|frame_pointer_needed
expr_stmt|;
for|for
control|(
init|;
name|regno
operator|>=
name|LOC_REG
argument_list|(
literal|0
argument_list|)
condition|;
name|regno
operator|--
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|regno
index|]
condition|)
break|break;
name|current_frame_info
operator|.
name|n_local_regs
operator|=
name|regno
operator|-
name|LOC_REG
argument_list|(
literal|0
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* For functions marked with the syscall_linkage attribute, we must mark      all eight input registers as in use, so that locals aren't visible to      the caller.  */
if|if
condition|(
name|cfun
operator|->
name|machine
operator|->
name|n_varargs
operator|>
literal|0
operator|||
name|lookup_attribute
argument_list|(
literal|"syscall_linkage"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
argument_list|)
condition|)
name|current_frame_info
operator|.
name|n_input_regs
operator|=
literal|8
expr_stmt|;
else|else
block|{
for|for
control|(
name|regno
operator|=
name|IN_REG
argument_list|(
literal|7
argument_list|)
init|;
name|regno
operator|>=
name|IN_REG
argument_list|(
literal|0
argument_list|)
condition|;
name|regno
operator|--
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|regno
index|]
condition|)
break|break;
name|current_frame_info
operator|.
name|n_input_regs
operator|=
name|regno
operator|-
name|IN_REG
argument_list|(
literal|0
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
for|for
control|(
name|regno
operator|=
name|OUT_REG
argument_list|(
literal|7
argument_list|)
init|;
name|regno
operator|>=
name|OUT_REG
argument_list|(
literal|0
argument_list|)
condition|;
name|regno
operator|--
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|regno
index|]
condition|)
break|break;
name|i
operator|=
name|regno
operator|-
name|OUT_REG
argument_list|(
literal|0
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* When -p profiling, we need one output register for the mcount argument.      Likwise for -a profiling for the bb_init_func argument.  For -ax      profiling, we need two output registers for the two bb_init_trace_func      arguments.  */
if|if
condition|(
name|current_function_profile
condition|)
name|i
operator|=
name|MAX
argument_list|(
name|i
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|current_frame_info
operator|.
name|n_output_regs
operator|=
name|i
expr_stmt|;
comment|/* ??? No rotating register support yet.  */
name|current_frame_info
operator|.
name|n_rotate_regs
operator|=
literal|0
expr_stmt|;
comment|/* Discover which registers need spilling, and how much room that      will take.  Begin with floating point and general registers,       which will always wind up on the stack.  */
for|for
control|(
name|regno
operator|=
name|FR_REG
argument_list|(
literal|2
argument_list|)
init|;
name|regno
operator|<=
name|FR_REG
argument_list|(
literal|127
argument_list|)
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|regno
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|regno
index|]
condition|)
block|{
name|SET_HARD_REG_BIT
argument_list|(
name|mask
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|spill_size
operator|+=
literal|16
expr_stmt|;
name|n_spilled
operator|+=
literal|1
expr_stmt|;
name|spilled_fr_p
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|regno
operator|=
name|GR_REG
argument_list|(
literal|1
argument_list|)
init|;
name|regno
operator|<=
name|GR_REG
argument_list|(
literal|31
argument_list|)
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|regno
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|regno
index|]
condition|)
block|{
name|SET_HARD_REG_BIT
argument_list|(
name|mask
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|spill_size
operator|+=
literal|8
expr_stmt|;
name|n_spilled
operator|+=
literal|1
expr_stmt|;
name|spilled_gr_p
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|regno
operator|=
name|BR_REG
argument_list|(
literal|1
argument_list|)
init|;
name|regno
operator|<=
name|BR_REG
argument_list|(
literal|7
argument_list|)
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|regno
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|regno
index|]
condition|)
block|{
name|SET_HARD_REG_BIT
argument_list|(
name|mask
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|spill_size
operator|+=
literal|8
expr_stmt|;
name|n_spilled
operator|+=
literal|1
expr_stmt|;
block|}
comment|/* Now come all special registers that might get saved in other      general registers.  */
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
name|current_frame_info
operator|.
name|reg_fp
operator|=
name|find_gr_spill
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* If we did not get a register, then we take LOC79.  This is guaranteed 	 to be free, even if regs_ever_live is already set, because this is 	 HARD_FRAME_POINTER_REGNUM.  This requires incrementing n_local_regs, 	 as we don't count loc79 above.  */
if|if
condition|(
name|current_frame_info
operator|.
name|reg_fp
operator|==
literal|0
condition|)
block|{
name|current_frame_info
operator|.
name|reg_fp
operator|=
name|LOC_REG
argument_list|(
literal|79
argument_list|)
expr_stmt|;
name|current_frame_info
operator|.
name|n_local_regs
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|current_function_is_leaf
condition|)
block|{
comment|/* Emit a save of BR0 if we call other functions.  Do this even 	 if this function doesn't return, as EH depends on this to be 	 able to unwind the stack.  */
name|SET_HARD_REG_BIT
argument_list|(
name|mask
argument_list|,
name|BR_REG
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|current_frame_info
operator|.
name|reg_save_b0
operator|=
name|find_gr_spill
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_b0
operator|==
literal|0
condition|)
block|{
name|spill_size
operator|+=
literal|8
expr_stmt|;
name|n_spilled
operator|+=
literal|1
expr_stmt|;
block|}
comment|/* Similarly for ar.pfs.  */
name|SET_HARD_REG_BIT
argument_list|(
name|mask
argument_list|,
name|AR_PFS_REGNUM
argument_list|)
expr_stmt|;
name|current_frame_info
operator|.
name|reg_save_ar_pfs
operator|=
name|find_gr_spill
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_ar_pfs
operator|==
literal|0
condition|)
block|{
name|extra_spill_size
operator|+=
literal|8
expr_stmt|;
name|n_spilled
operator|+=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|regs_ever_live
index|[
name|BR_REG
argument_list|(
literal|0
argument_list|)
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|BR_REG
argument_list|(
literal|0
argument_list|)
index|]
condition|)
block|{
name|SET_HARD_REG_BIT
argument_list|(
name|mask
argument_list|,
name|BR_REG
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|spill_size
operator|+=
literal|8
expr_stmt|;
name|n_spilled
operator|+=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Unwind descriptor hackery: things are most efficient if we allocate      consecutive GR save registers for RP, PFS, FP in that order. However,      it is absolutely critical that FP get the only hard register that's      guaranteed to be free, so we allocated it first.  If all three did      happen to be allocated hard regs, and are consecutive, rearrange them      into the preferred order now.  */
if|if
condition|(
name|current_frame_info
operator|.
name|reg_fp
operator|!=
literal|0
operator|&&
name|current_frame_info
operator|.
name|reg_save_b0
operator|==
name|current_frame_info
operator|.
name|reg_fp
operator|+
literal|1
operator|&&
name|current_frame_info
operator|.
name|reg_save_ar_pfs
operator|==
name|current_frame_info
operator|.
name|reg_fp
operator|+
literal|2
condition|)
block|{
name|current_frame_info
operator|.
name|reg_save_b0
operator|=
name|current_frame_info
operator|.
name|reg_fp
expr_stmt|;
name|current_frame_info
operator|.
name|reg_save_ar_pfs
operator|=
name|current_frame_info
operator|.
name|reg_fp
operator|+
literal|1
expr_stmt|;
name|current_frame_info
operator|.
name|reg_fp
operator|=
name|current_frame_info
operator|.
name|reg_fp
operator|+
literal|2
expr_stmt|;
block|}
comment|/* See if we need to store the predicate register block.  */
for|for
control|(
name|regno
operator|=
name|PR_REG
argument_list|(
literal|0
argument_list|)
init|;
name|regno
operator|<=
name|PR_REG
argument_list|(
literal|63
argument_list|)
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|regno
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|regno
index|]
condition|)
break|break;
if|if
condition|(
name|regno
operator|<=
name|PR_REG
argument_list|(
literal|63
argument_list|)
condition|)
block|{
name|SET_HARD_REG_BIT
argument_list|(
name|mask
argument_list|,
name|PR_REG
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|current_frame_info
operator|.
name|reg_save_pr
operator|=
name|find_gr_spill
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_pr
operator|==
literal|0
condition|)
block|{
name|extra_spill_size
operator|+=
literal|8
expr_stmt|;
name|n_spilled
operator|+=
literal|1
expr_stmt|;
block|}
comment|/* ??? Mark them all as used so that register renaming and such 	 are free to use them.  */
for|for
control|(
name|regno
operator|=
name|PR_REG
argument_list|(
literal|0
argument_list|)
init|;
name|regno
operator|<=
name|PR_REG
argument_list|(
literal|63
argument_list|)
condition|;
name|regno
operator|++
control|)
name|regs_ever_live
index|[
name|regno
index|]
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If we're forced to use st8.spill, we're forced to save and restore      ar.unat as well.  */
if|if
condition|(
name|spilled_gr_p
operator|||
name|cfun
operator|->
name|machine
operator|->
name|n_varargs
condition|)
block|{
name|regs_ever_live
index|[
name|AR_UNAT_REGNUM
index|]
operator|=
literal|1
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|mask
argument_list|,
name|AR_UNAT_REGNUM
argument_list|)
expr_stmt|;
name|current_frame_info
operator|.
name|reg_save_ar_unat
operator|=
name|find_gr_spill
argument_list|(
name|spill_size
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_ar_unat
operator|==
literal|0
condition|)
block|{
name|extra_spill_size
operator|+=
literal|8
expr_stmt|;
name|n_spilled
operator|+=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|regs_ever_live
index|[
name|AR_LC_REGNUM
index|]
condition|)
block|{
name|SET_HARD_REG_BIT
argument_list|(
name|mask
argument_list|,
name|AR_LC_REGNUM
argument_list|)
expr_stmt|;
name|current_frame_info
operator|.
name|reg_save_ar_lc
operator|=
name|find_gr_spill
argument_list|(
name|spill_size
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_ar_lc
operator|==
literal|0
condition|)
block|{
name|extra_spill_size
operator|+=
literal|8
expr_stmt|;
name|n_spilled
operator|+=
literal|1
expr_stmt|;
block|}
block|}
comment|/* If we have an odd number of words of pretend arguments written to      the stack, then the FR save area will be unaligned.  We round the      size of this area up to keep things 16 byte aligned.  */
if|if
condition|(
name|spilled_fr_p
condition|)
name|pretend_args_size
operator|=
name|IA64_STACK_ALIGN
argument_list|(
name|current_function_pretend_args_size
argument_list|)
expr_stmt|;
else|else
name|pretend_args_size
operator|=
name|current_function_pretend_args_size
expr_stmt|;
name|total_size
operator|=
operator|(
name|spill_size
operator|+
name|extra_spill_size
operator|+
name|size
operator|+
name|pretend_args_size
operator|+
name|current_function_outgoing_args_size
operator|)
expr_stmt|;
name|total_size
operator|=
name|IA64_STACK_ALIGN
argument_list|(
name|total_size
argument_list|)
expr_stmt|;
comment|/* We always use the 16-byte scratch area provided by the caller, but      if we are a leaf function, there's no one to which we need to provide      a scratch area.  */
if|if
condition|(
name|current_function_is_leaf
condition|)
name|total_size
operator|=
name|MAX
argument_list|(
literal|0
argument_list|,
name|total_size
operator|-
literal|16
argument_list|)
expr_stmt|;
name|current_frame_info
operator|.
name|total_size
operator|=
name|total_size
expr_stmt|;
name|current_frame_info
operator|.
name|spill_cfa_off
operator|=
name|pretend_args_size
operator|-
literal|16
expr_stmt|;
name|current_frame_info
operator|.
name|spill_size
operator|=
name|spill_size
expr_stmt|;
name|current_frame_info
operator|.
name|extra_spill_size
operator|=
name|extra_spill_size
expr_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|current_frame_info
operator|.
name|mask
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|current_frame_info
operator|.
name|n_spilled
operator|=
name|n_spilled
expr_stmt|;
name|current_frame_info
operator|.
name|initialized
operator|=
name|reload_completed
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute the initial difference between the specified pair of registers.  */
end_comment

begin_function
name|HOST_WIDE_INT
name|ia64_initial_elimination_offset
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|)
name|int
name|from
decl_stmt|,
name|to
decl_stmt|;
block|{
name|HOST_WIDE_INT
name|offset
decl_stmt|;
name|ia64_compute_frame_size
argument_list|(
name|get_frame_size
argument_list|()
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|from
condition|)
block|{
case|case
name|FRAME_POINTER_REGNUM
case|:
if|if
condition|(
name|to
operator|==
name|HARD_FRAME_POINTER_REGNUM
condition|)
block|{
if|if
condition|(
name|current_function_is_leaf
condition|)
name|offset
operator|=
operator|-
name|current_frame_info
operator|.
name|total_size
expr_stmt|;
else|else
name|offset
operator|=
operator|-
operator|(
name|current_frame_info
operator|.
name|total_size
operator|-
name|current_function_outgoing_args_size
operator|-
literal|16
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|to
operator|==
name|STACK_POINTER_REGNUM
condition|)
block|{
if|if
condition|(
name|current_function_is_leaf
condition|)
name|offset
operator|=
literal|0
expr_stmt|;
else|else
name|offset
operator|=
literal|16
operator|+
name|current_function_outgoing_args_size
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
break|break;
case|case
name|ARG_POINTER_REGNUM
case|:
comment|/* Arguments start above the 16 byte save area, unless stdarg 	 in which case we store through the 16 byte save area.  */
if|if
condition|(
name|to
operator|==
name|HARD_FRAME_POINTER_REGNUM
condition|)
name|offset
operator|=
literal|16
operator|-
name|current_function_pretend_args_size
expr_stmt|;
elseif|else
if|if
condition|(
name|to
operator|==
name|STACK_POINTER_REGNUM
condition|)
name|offset
operator|=
operator|(
name|current_frame_info
operator|.
name|total_size
operator|+
literal|16
operator|-
name|current_function_pretend_args_size
operator|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
break|break;
case|case
name|RETURN_ADDRESS_POINTER_REGNUM
case|:
name|offset
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|offset
return|;
block|}
end_function

begin_comment
comment|/* If there are more than a trivial number of register spills, we use    two interleaved iterators so that we can get two memory references    per insn group.     In order to simplify things in the prologue and epilogue expanders,    we use helper functions to fix up the memory references after the    fact with the appropriate offsets to a POST_MODIFY memory mode.    The following data structure tracks the state of the two iterators    while insns are being emitted.  */
end_comment

begin_struct
struct|struct
name|spill_fill_data
block|{
name|rtx
name|init_after
decl_stmt|;
comment|/* point at which to emit initializations */
name|rtx
name|init_reg
index|[
literal|2
index|]
decl_stmt|;
comment|/* initial base register */
name|rtx
name|iter_reg
index|[
literal|2
index|]
decl_stmt|;
comment|/* the iterator registers */
name|rtx
modifier|*
name|prev_addr
index|[
literal|2
index|]
decl_stmt|;
comment|/* address of last memory use */
name|rtx
name|prev_insn
index|[
literal|2
index|]
decl_stmt|;
comment|/* the insn corresponding to prev_addr */
name|HOST_WIDE_INT
name|prev_off
index|[
literal|2
index|]
decl_stmt|;
comment|/* last offset */
name|int
name|n_iter
decl_stmt|;
comment|/* number of iterators in use */
name|int
name|next_iter
decl_stmt|;
comment|/* next iterator to use */
name|unsigned
name|int
name|save_gr_used_mask
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|spill_fill_data
name|spill_fill_data
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|setup_spill_pointers
parameter_list|(
name|n_spills
parameter_list|,
name|init_reg
parameter_list|,
name|cfa_off
parameter_list|)
name|int
name|n_spills
decl_stmt|;
name|rtx
name|init_reg
decl_stmt|;
name|HOST_WIDE_INT
name|cfa_off
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|spill_fill_data
operator|.
name|init_after
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|spill_fill_data
operator|.
name|init_reg
index|[
literal|0
index|]
operator|=
name|init_reg
expr_stmt|;
name|spill_fill_data
operator|.
name|init_reg
index|[
literal|1
index|]
operator|=
name|init_reg
expr_stmt|;
name|spill_fill_data
operator|.
name|prev_addr
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
name|spill_fill_data
operator|.
name|prev_addr
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|spill_fill_data
operator|.
name|prev_insn
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
name|spill_fill_data
operator|.
name|prev_insn
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|spill_fill_data
operator|.
name|prev_off
index|[
literal|0
index|]
operator|=
name|cfa_off
expr_stmt|;
name|spill_fill_data
operator|.
name|prev_off
index|[
literal|1
index|]
operator|=
name|cfa_off
expr_stmt|;
name|spill_fill_data
operator|.
name|next_iter
operator|=
literal|0
expr_stmt|;
name|spill_fill_data
operator|.
name|save_gr_used_mask
operator|=
name|current_frame_info
operator|.
name|gr_used_mask
expr_stmt|;
name|spill_fill_data
operator|.
name|n_iter
operator|=
literal|1
operator|+
operator|(
name|n_spills
operator|>
literal|2
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|spill_fill_data
operator|.
name|n_iter
condition|;
operator|++
name|i
control|)
block|{
name|int
name|regno
init|=
name|next_scratch_gr_reg
argument_list|()
decl_stmt|;
name|spill_fill_data
operator|.
name|iter_reg
index|[
name|i
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|current_frame_info
operator|.
name|gr_used_mask
operator||=
literal|1
operator|<<
name|regno
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|finish_spill_pointers
parameter_list|()
block|{
name|current_frame_info
operator|.
name|gr_used_mask
operator|=
name|spill_fill_data
operator|.
name|save_gr_used_mask
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|spill_restore_mem
parameter_list|(
name|reg
parameter_list|,
name|cfa_off
parameter_list|)
name|rtx
name|reg
decl_stmt|;
name|HOST_WIDE_INT
name|cfa_off
decl_stmt|;
block|{
name|int
name|iter
init|=
name|spill_fill_data
operator|.
name|next_iter
decl_stmt|;
name|HOST_WIDE_INT
name|disp
init|=
name|spill_fill_data
operator|.
name|prev_off
index|[
name|iter
index|]
operator|-
name|cfa_off
decl_stmt|;
name|rtx
name|disp_rtx
init|=
name|GEN_INT
argument_list|(
name|disp
argument_list|)
decl_stmt|;
name|rtx
name|mem
decl_stmt|;
if|if
condition|(
name|spill_fill_data
operator|.
name|prev_addr
index|[
name|iter
index|]
condition|)
block|{
if|if
condition|(
name|CONST_OK_FOR_N
argument_list|(
name|disp
argument_list|)
condition|)
block|{
operator|*
name|spill_fill_data
operator|.
name|prev_addr
index|[
name|iter
index|]
operator|=
name|gen_rtx_POST_MODIFY
argument_list|(
name|DImode
argument_list|,
name|spill_fill_data
operator|.
name|iter_reg
index|[
name|iter
index|]
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|DImode
argument_list|,
name|spill_fill_data
operator|.
name|iter_reg
index|[
name|iter
index|]
argument_list|,
name|disp_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|spill_fill_data
operator|.
name|prev_insn
index|[
name|iter
index|]
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_INC
argument_list|,
name|spill_fill_data
operator|.
name|iter_reg
index|[
name|iter
index|]
argument_list|,
name|REG_NOTES
argument_list|(
name|spill_fill_data
operator|.
name|prev_insn
index|[
name|iter
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* ??? Could use register post_modify for loads.  */
if|if
condition|(
operator|!
name|CONST_OK_FOR_I
argument_list|(
name|disp
argument_list|)
condition|)
block|{
name|rtx
name|tmp
init|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|next_scratch_gr_reg
argument_list|()
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|tmp
argument_list|,
name|disp_rtx
argument_list|)
expr_stmt|;
name|disp_rtx
operator|=
name|tmp
expr_stmt|;
block|}
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|spill_fill_data
operator|.
name|iter_reg
index|[
name|iter
index|]
argument_list|,
name|spill_fill_data
operator|.
name|iter_reg
index|[
name|iter
index|]
argument_list|,
name|disp_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Micro-optimization: if we've created a frame pointer, it's at      CFA 0, which may allow the real iterator to be initialized lower,      slightly increasing parallelism.  Also, if there are few saves      it may eliminate the iterator entirely.  */
elseif|else
if|if
condition|(
name|disp
operator|==
literal|0
operator|&&
name|spill_fill_data
operator|.
name|init_reg
index|[
name|iter
index|]
operator|==
name|stack_pointer_rtx
operator|&&
name|frame_pointer_needed
condition|)
block|{
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|hard_frame_pointer_rtx
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|get_varargs_alias_set
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|mem
return|;
block|}
else|else
block|{
name|rtx
name|seq
decl_stmt|,
name|insn
decl_stmt|;
if|if
condition|(
name|disp
operator|==
literal|0
condition|)
name|seq
operator|=
name|gen_movdi
argument_list|(
name|spill_fill_data
operator|.
name|iter_reg
index|[
name|iter
index|]
argument_list|,
name|spill_fill_data
operator|.
name|init_reg
index|[
name|iter
index|]
argument_list|)
expr_stmt|;
else|else
block|{
name|start_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|CONST_OK_FOR_I
argument_list|(
name|disp
argument_list|)
condition|)
block|{
name|rtx
name|tmp
init|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|next_scratch_gr_reg
argument_list|()
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|tmp
argument_list|,
name|disp_rtx
argument_list|)
expr_stmt|;
name|disp_rtx
operator|=
name|tmp
expr_stmt|;
block|}
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|spill_fill_data
operator|.
name|iter_reg
index|[
name|iter
index|]
argument_list|,
name|spill_fill_data
operator|.
name|init_reg
index|[
name|iter
index|]
argument_list|,
name|disp_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|seq
operator|=
name|gen_sequence
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
block|}
comment|/* Careful for being the first insn in a sequence.  */
if|if
condition|(
name|spill_fill_data
operator|.
name|init_after
condition|)
name|insn
operator|=
name|emit_insn_after
argument_list|(
name|seq
argument_list|,
name|spill_fill_data
operator|.
name|init_after
argument_list|)
expr_stmt|;
else|else
block|{
name|rtx
name|first
init|=
name|get_insns
argument_list|()
decl_stmt|;
if|if
condition|(
name|first
condition|)
name|insn
operator|=
name|emit_insn_before
argument_list|(
name|seq
argument_list|,
name|first
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|emit_insn
argument_list|(
name|seq
argument_list|)
expr_stmt|;
block|}
name|spill_fill_data
operator|.
name|init_after
operator|=
name|insn
expr_stmt|;
comment|/* If DISP is 0, we may or may not have a further adjustment 	 afterward.  If we do, then the load/store insn may be modified 	 to be a post-modify.  If we don't, then this copy may be 	 eliminated by copyprop_hardreg_forward, which makes this 	 insn garbage, which runs afoul of the sanity check in 	 propagate_one_insn.  So mark this insn as legal to delete.  */
if|if
condition|(
name|disp
operator|==
literal|0
condition|)
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_MAYBE_DEAD
argument_list|,
name|const0_rtx
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|spill_fill_data
operator|.
name|iter_reg
index|[
name|iter
index|]
argument_list|)
expr_stmt|;
comment|/* ??? Not all of the spills are for varargs, but some of them are.      The rest of the spills belong in an alias set of their own.  But      it doesn't actually hurt to include them here.  */
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|get_varargs_alias_set
argument_list|()
argument_list|)
expr_stmt|;
name|spill_fill_data
operator|.
name|prev_addr
index|[
name|iter
index|]
operator|=
operator|&
name|XEXP
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|spill_fill_data
operator|.
name|prev_off
index|[
name|iter
index|]
operator|=
name|cfa_off
expr_stmt|;
if|if
condition|(
operator|++
name|iter
operator|>=
name|spill_fill_data
operator|.
name|n_iter
condition|)
name|iter
operator|=
literal|0
expr_stmt|;
name|spill_fill_data
operator|.
name|next_iter
operator|=
name|iter
expr_stmt|;
return|return
name|mem
return|;
block|}
end_function

begin_function_decl
specifier|static
name|void
name|do_spill
parameter_list|(
name|move_fn
parameter_list|,
name|reg
parameter_list|,
name|cfa_off
parameter_list|,
name|frame_reg
parameter_list|)
function_decl|rtx
parameter_list|(
function_decl|*move_fn
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|rtx
name|reg
decl_stmt|,
name|frame_reg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|HOST_WIDE_INT
name|cfa_off
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|iter
init|=
name|spill_fill_data
operator|.
name|next_iter
decl_stmt|;
name|rtx
name|mem
decl_stmt|,
name|insn
decl_stmt|;
name|mem
operator|=
name|spill_restore_mem
argument_list|(
name|reg
argument_list|,
name|cfa_off
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
call|(
modifier|*
name|move_fn
call|)
argument_list|(
name|mem
argument_list|,
name|reg
argument_list|,
name|GEN_INT
argument_list|(
name|cfa_off
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|spill_fill_data
operator|.
name|prev_insn
index|[
name|iter
index|]
operator|=
name|insn
expr_stmt|;
if|if
condition|(
name|frame_reg
condition|)
block|{
name|rtx
name|base
decl_stmt|;
name|HOST_WIDE_INT
name|off
decl_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Don't even pretend that the unwind code can intuit its way  	 through a pair of interleaved post_modify iterators.  Just 	 provide the correct answer.  */
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
name|base
operator|=
name|hard_frame_pointer_rtx
expr_stmt|;
name|off
operator|=
operator|-
name|cfa_off
expr_stmt|;
block|}
else|else
block|{
name|base
operator|=
name|stack_pointer_rtx
expr_stmt|;
name|off
operator|=
name|current_frame_info
operator|.
name|total_size
operator|-
name|cfa_off
expr_stmt|;
block|}
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_FRAME_RELATED_EXPR
argument_list|,
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|plus_constant
argument_list|(
name|base
argument_list|,
name|off
argument_list|)
argument_list|)
argument_list|,
name|frame_reg
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_function_decl
specifier|static
name|void
name|do_restore
parameter_list|(
name|move_fn
parameter_list|,
name|reg
parameter_list|,
name|cfa_off
parameter_list|)
function_decl|rtx
parameter_list|(
function_decl|*move_fn
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|rtx
name|reg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|HOST_WIDE_INT
name|cfa_off
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|iter
init|=
name|spill_fill_data
operator|.
name|next_iter
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
call|(
modifier|*
name|move_fn
call|)
argument_list|(
name|reg
argument_list|,
name|spill_restore_mem
argument_list|(
name|reg
argument_list|,
name|cfa_off
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|cfa_off
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|spill_fill_data
operator|.
name|prev_insn
index|[
name|iter
index|]
operator|=
name|insn
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Wrapper functions that discards the CONST_INT spill offset.  These    exist so that we can give gr_spill/gr_fill the offset they need and    use a consistant function interface.  */
end_comment

begin_function
specifier|static
name|rtx
name|gen_movdi_x
parameter_list|(
name|dest
parameter_list|,
name|src
parameter_list|,
name|offset
parameter_list|)
name|rtx
name|dest
decl_stmt|,
name|src
decl_stmt|;
name|rtx
name|offset
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
name|gen_movdi
argument_list|(
name|dest
argument_list|,
name|src
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|gen_fr_spill_x
parameter_list|(
name|dest
parameter_list|,
name|src
parameter_list|,
name|offset
parameter_list|)
name|rtx
name|dest
decl_stmt|,
name|src
decl_stmt|;
name|rtx
name|offset
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
name|gen_fr_spill
argument_list|(
name|dest
argument_list|,
name|src
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|gen_fr_restore_x
parameter_list|(
name|dest
parameter_list|,
name|src
parameter_list|,
name|offset
parameter_list|)
name|rtx
name|dest
decl_stmt|,
name|src
decl_stmt|;
name|rtx
name|offset
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
name|gen_fr_restore
argument_list|(
name|dest
argument_list|,
name|src
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Called after register allocation to add any instructions needed for the    prologue.  Using a prologue insn is favored compared to putting all of the    instructions in output_function_prologue(), since it allows the scheduler    to intermix instructions with the saves of the caller saved registers.  In    some cases, it might be necessary to emit a barrier instruction as the last    insn to prevent such scheduling.     Also any insns generated here should have RTX_FRAME_RELATED_P(insn) = 1    so that the debug info generation code can handle them properly.     The register save area is layed out like so:    cfa+16 	[ varargs spill area ] 	[ fr register spill area ] 	[ br register spill area ] 	[ ar register spill area ] 	[ pr register spill area ] 	[ gr register spill area ] */
end_comment

begin_comment
comment|/* ??? Get inefficient code when the frame size is larger than can fit in an    adds instruction.  */
end_comment

begin_function
name|void
name|ia64_expand_prologue
parameter_list|()
block|{
name|rtx
name|insn
decl_stmt|,
name|ar_pfs_save_reg
decl_stmt|,
name|ar_unat_save_reg
decl_stmt|;
name|int
name|i
decl_stmt|,
name|epilogue_p
decl_stmt|,
name|regno
decl_stmt|,
name|alt_regno
decl_stmt|,
name|cfa_off
decl_stmt|,
name|n_varargs
decl_stmt|;
name|rtx
name|reg
decl_stmt|,
name|alt_reg
decl_stmt|;
name|ia64_compute_frame_size
argument_list|(
name|get_frame_size
argument_list|()
argument_list|)
expr_stmt|;
name|last_scratch_gr_reg
operator|=
literal|15
expr_stmt|;
comment|/* If there is no epilogue, then we don't need some prologue insns.      We need to avoid emitting the dead prologue insns, because flow      will complain about them.  */
if|if
condition|(
name|optimize
condition|)
block|{
name|edge
name|e
decl_stmt|;
for|for
control|(
name|e
operator|=
name|EXIT_BLOCK_PTR
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
if|if
condition|(
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FAKE
operator|)
operator|==
literal|0
operator|&&
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
operator|)
operator|!=
literal|0
condition|)
break|break;
name|epilogue_p
operator|=
operator|(
name|e
operator|!=
name|NULL
operator|)
expr_stmt|;
block|}
else|else
name|epilogue_p
operator|=
literal|1
expr_stmt|;
comment|/* Set the local, input, and output register names.  We need to do this      for GNU libc, which creates crti.S/crtn.S by splitting initfini.c in      half.  If we use in/loc/out register names, then we get assembler errors      in crtn.S because there is no alloc insn or regstk directive in there.  */
if|if
condition|(
operator|!
name|TARGET_REG_NAMES
condition|)
block|{
name|int
name|inputs
init|=
name|current_frame_info
operator|.
name|n_input_regs
decl_stmt|;
name|int
name|locals
init|=
name|current_frame_info
operator|.
name|n_local_regs
decl_stmt|;
name|int
name|outputs
init|=
name|current_frame_info
operator|.
name|n_output_regs
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|inputs
condition|;
name|i
operator|++
control|)
name|reg_names
index|[
name|IN_REG
argument_list|(
name|i
argument_list|)
index|]
operator|=
name|ia64_reg_numbers
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|locals
condition|;
name|i
operator|++
control|)
name|reg_names
index|[
name|LOC_REG
argument_list|(
name|i
argument_list|)
index|]
operator|=
name|ia64_reg_numbers
index|[
name|inputs
operator|+
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|outputs
condition|;
name|i
operator|++
control|)
name|reg_names
index|[
name|OUT_REG
argument_list|(
name|i
argument_list|)
index|]
operator|=
name|ia64_reg_numbers
index|[
name|inputs
operator|+
name|locals
operator|+
name|i
index|]
expr_stmt|;
block|}
comment|/* Set the frame pointer register name.  The regnum is logically loc79,      but of course we'll not have allocated that many locals.  Rather than      worrying about renumbering the existing rtxs, we adjust the name.  */
comment|/* ??? This code means that we can never use one local register when      there is a frame pointer.  loc79 gets wasted in this case, as it is      renamed to a register that will never be used.  See also the try_locals      code in find_gr_spill.  */
if|if
condition|(
name|current_frame_info
operator|.
name|reg_fp
condition|)
block|{
specifier|const
name|char
modifier|*
name|tmp
init|=
name|reg_names
index|[
name|HARD_FRAME_POINTER_REGNUM
index|]
decl_stmt|;
name|reg_names
index|[
name|HARD_FRAME_POINTER_REGNUM
index|]
operator|=
name|reg_names
index|[
name|current_frame_info
operator|.
name|reg_fp
index|]
expr_stmt|;
name|reg_names
index|[
name|current_frame_info
operator|.
name|reg_fp
index|]
operator|=
name|tmp
expr_stmt|;
block|}
comment|/* Fix up the return address placeholder.  */
comment|/* ??? We can fail if __builtin_return_address is used, and we didn't      allocate a register in which to save b0.  I can't think of a way to      eliminate RETURN_ADDRESS_POINTER_REGNUM to a local register and      then be sure that I got the right one.  Further, reload doesn't seem      to care if an eliminable register isn't used, and "eliminates" it      anyway.  */
if|if
condition|(
name|regs_ever_live
index|[
name|RETURN_ADDRESS_POINTER_REGNUM
index|]
operator|&&
name|current_frame_info
operator|.
name|reg_save_b0
operator|!=
literal|0
condition|)
name|XINT
argument_list|(
name|return_address_pointer_rtx
argument_list|,
literal|0
argument_list|)
operator|=
name|current_frame_info
operator|.
name|reg_save_b0
expr_stmt|;
comment|/* We don't need an alloc instruction if we've used no outputs or locals.  */
if|if
condition|(
name|current_frame_info
operator|.
name|n_local_regs
operator|==
literal|0
operator|&&
name|current_frame_info
operator|.
name|n_output_regs
operator|==
literal|0
operator|&&
name|current_frame_info
operator|.
name|n_input_regs
operator|<=
name|current_function_args_info
operator|.
name|words
condition|)
block|{
comment|/* If there is no alloc, but there are input registers used, then we 	 need a .regstk directive.  */
name|current_frame_info
operator|.
name|need_regstk
operator|=
operator|(
name|TARGET_REG_NAMES
operator|!=
literal|0
operator|)
expr_stmt|;
name|ar_pfs_save_reg
operator|=
name|NULL_RTX
expr_stmt|;
block|}
else|else
block|{
name|current_frame_info
operator|.
name|need_regstk
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_ar_pfs
condition|)
name|regno
operator|=
name|current_frame_info
operator|.
name|reg_save_ar_pfs
expr_stmt|;
else|else
name|regno
operator|=
name|next_scratch_gr_reg
argument_list|()
expr_stmt|;
name|ar_pfs_save_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_alloc
argument_list|(
name|ar_pfs_save_reg
argument_list|,
name|GEN_INT
argument_list|(
name|current_frame_info
operator|.
name|n_input_regs
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|current_frame_info
operator|.
name|n_local_regs
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|current_frame_info
operator|.
name|n_output_regs
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|current_frame_info
operator|.
name|n_rotate_regs
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
operator|(
name|current_frame_info
operator|.
name|reg_save_ar_pfs
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
comment|/* Set up frame pointer, stack pointer, and spill iterators.  */
name|n_varargs
operator|=
name|cfun
operator|->
name|machine
operator|->
name|n_varargs
expr_stmt|;
name|setup_spill_pointers
argument_list|(
name|current_frame_info
operator|.
name|n_spilled
operator|+
name|n_varargs
argument_list|,
name|stack_pointer_rtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|current_frame_info
operator|.
name|total_size
operator|!=
literal|0
condition|)
block|{
name|rtx
name|frame_size_rtx
init|=
name|GEN_INT
argument_list|(
operator|-
name|current_frame_info
operator|.
name|total_size
argument_list|)
decl_stmt|;
name|rtx
name|offset
decl_stmt|;
if|if
condition|(
name|CONST_OK_FOR_I
argument_list|(
operator|-
name|current_frame_info
operator|.
name|total_size
argument_list|)
condition|)
name|offset
operator|=
name|frame_size_rtx
expr_stmt|;
else|else
block|{
name|regno
operator|=
name|next_scratch_gr_reg
argument_list|()
expr_stmt|;
name|offset
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|offset
argument_list|,
name|frame_size_rtx
argument_list|)
expr_stmt|;
block|}
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|frame_pointer_needed
condition|)
block|{
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|offset
argument_list|)
operator|!=
name|CONST_INT
condition|)
block|{
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_FRAME_RELATED_EXPR
argument_list|,
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|DImode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|frame_size_rtx
argument_list|)
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* ??? At this point we must generate a magic insn that appears to 	 modify the stack pointer, the frame pointer, and all spill 	 iterators.  This would allow the most scheduling freedom.  For 	 now, just hard stop.  */
name|emit_insn
argument_list|(
name|gen_blockage
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/* Must copy out ar.unat before doing any integer spills.  */
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|current_frame_info
operator|.
name|mask
argument_list|,
name|AR_UNAT_REGNUM
argument_list|)
condition|)
block|{
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_ar_unat
condition|)
name|ar_unat_save_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|current_frame_info
operator|.
name|reg_save_ar_unat
argument_list|)
expr_stmt|;
else|else
block|{
name|alt_regno
operator|=
name|next_scratch_gr_reg
argument_list|()
expr_stmt|;
name|ar_unat_save_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|alt_regno
argument_list|)
expr_stmt|;
name|current_frame_info
operator|.
name|gr_used_mask
operator||=
literal|1
operator|<<
name|alt_regno
expr_stmt|;
block|}
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|AR_UNAT_REGNUM
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|ar_unat_save_reg
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
operator|(
name|current_frame_info
operator|.
name|reg_save_ar_unat
operator|!=
literal|0
operator|)
expr_stmt|;
comment|/* Even if we're not going to generate an epilogue, we still 	 need to save the register so that EH works.  */
if|if
condition|(
operator|!
name|epilogue_p
operator|&&
name|current_frame_info
operator|.
name|reg_save_ar_unat
condition|)
name|emit_insn
argument_list|(
name|gen_prologue_use
argument_list|(
name|ar_unat_save_reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|ar_unat_save_reg
operator|=
name|NULL_RTX
expr_stmt|;
comment|/* Spill all varargs registers.  Do this before spilling any GR registers,      since we want the UNAT bits for the GR registers to override the UNAT      bits from varargs, which we don't care about.  */
name|cfa_off
operator|=
operator|-
literal|16
expr_stmt|;
for|for
control|(
name|regno
operator|=
name|GR_ARG_FIRST
operator|+
literal|7
init|;
name|n_varargs
operator|>
literal|0
condition|;
operator|--
name|n_varargs
operator|,
operator|--
name|regno
control|)
block|{
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|do_spill
argument_list|(
name|gen_gr_spill
argument_list|,
name|reg
argument_list|,
name|cfa_off
operator|+=
literal|8
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
comment|/* Locate the bottom of the register save area.  */
name|cfa_off
operator|=
operator|(
name|current_frame_info
operator|.
name|spill_cfa_off
operator|+
name|current_frame_info
operator|.
name|spill_size
operator|+
name|current_frame_info
operator|.
name|extra_spill_size
operator|)
expr_stmt|;
comment|/* Save the predicate register block either in a register or in memory.  */
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|current_frame_info
operator|.
name|mask
argument_list|,
name|PR_REG
argument_list|(
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|PR_REG
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_pr
operator|!=
literal|0
condition|)
block|{
name|alt_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|current_frame_info
operator|.
name|reg_save_pr
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|alt_reg
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* ??? Denote pr spill/fill by a DImode move that modifies all 	     64 hard registers.  */
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_FRAME_RELATED_EXPR
argument_list|,
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|alt_reg
argument_list|,
name|reg
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Even if we're not going to generate an epilogue, we still 	     need to save the register so that EH works.  */
if|if
condition|(
operator|!
name|epilogue_p
condition|)
name|emit_insn
argument_list|(
name|gen_prologue_use
argument_list|(
name|alt_reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|alt_regno
operator|=
name|next_scratch_gr_reg
argument_list|()
expr_stmt|;
name|alt_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|alt_regno
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|alt_reg
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|do_spill
argument_list|(
name|gen_movdi_x
argument_list|,
name|alt_reg
argument_list|,
name|cfa_off
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|cfa_off
operator|-=
literal|8
expr_stmt|;
block|}
block|}
comment|/* Handle AR regs in numerical order.  All of them get special handling.  */
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|current_frame_info
operator|.
name|mask
argument_list|,
name|AR_UNAT_REGNUM
argument_list|)
operator|&&
name|current_frame_info
operator|.
name|reg_save_ar_unat
operator|==
literal|0
condition|)
block|{
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|AR_UNAT_REGNUM
argument_list|)
expr_stmt|;
name|do_spill
argument_list|(
name|gen_movdi_x
argument_list|,
name|ar_unat_save_reg
argument_list|,
name|cfa_off
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|cfa_off
operator|-=
literal|8
expr_stmt|;
block|}
comment|/* The alloc insn already copied ar.pfs into a general register.  The      only thing we have to do now is copy that register to a stack slot      if we'd not allocated a local register for the job.  */
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_ar_pfs
operator|==
literal|0
operator|&&
operator|!
name|current_function_is_leaf
condition|)
block|{
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|AR_PFS_REGNUM
argument_list|)
expr_stmt|;
name|do_spill
argument_list|(
name|gen_movdi_x
argument_list|,
name|ar_pfs_save_reg
argument_list|,
name|cfa_off
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|cfa_off
operator|-=
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|current_frame_info
operator|.
name|mask
argument_list|,
name|AR_LC_REGNUM
argument_list|)
condition|)
block|{
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|AR_LC_REGNUM
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_ar_lc
operator|!=
literal|0
condition|)
block|{
name|alt_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|current_frame_info
operator|.
name|reg_save_ar_lc
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|alt_reg
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Even if we're not going to generate an epilogue, we still 	     need to save the register so that EH works.  */
if|if
condition|(
operator|!
name|epilogue_p
condition|)
name|emit_insn
argument_list|(
name|gen_prologue_use
argument_list|(
name|alt_reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|alt_regno
operator|=
name|next_scratch_gr_reg
argument_list|()
expr_stmt|;
name|alt_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|alt_regno
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|alt_reg
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|do_spill
argument_list|(
name|gen_movdi_x
argument_list|,
name|alt_reg
argument_list|,
name|cfa_off
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|cfa_off
operator|-=
literal|8
expr_stmt|;
block|}
block|}
comment|/* We should now be at the base of the gr/br/fr spill area.  */
if|if
condition|(
name|cfa_off
operator|!=
operator|(
name|current_frame_info
operator|.
name|spill_cfa_off
operator|+
name|current_frame_info
operator|.
name|spill_size
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Spill all general registers.  */
for|for
control|(
name|regno
operator|=
name|GR_REG
argument_list|(
literal|1
argument_list|)
init|;
name|regno
operator|<=
name|GR_REG
argument_list|(
literal|31
argument_list|)
condition|;
operator|++
name|regno
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|current_frame_info
operator|.
name|mask
argument_list|,
name|regno
argument_list|)
condition|)
block|{
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|do_spill
argument_list|(
name|gen_gr_spill
argument_list|,
name|reg
argument_list|,
name|cfa_off
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|cfa_off
operator|-=
literal|8
expr_stmt|;
block|}
comment|/* Handle BR0 specially -- it may be getting stored permanently in      some GR register.  */
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|current_frame_info
operator|.
name|mask
argument_list|,
name|BR_REG
argument_list|(
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|BR_REG
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_b0
operator|!=
literal|0
condition|)
block|{
name|alt_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|current_frame_info
operator|.
name|reg_save_b0
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|alt_reg
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Even if we're not going to generate an epilogue, we still 	     need to save the register so that EH works.  */
if|if
condition|(
operator|!
name|epilogue_p
condition|)
name|emit_insn
argument_list|(
name|gen_prologue_use
argument_list|(
name|alt_reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|alt_regno
operator|=
name|next_scratch_gr_reg
argument_list|()
expr_stmt|;
name|alt_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|alt_regno
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|alt_reg
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|do_spill
argument_list|(
name|gen_movdi_x
argument_list|,
name|alt_reg
argument_list|,
name|cfa_off
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|cfa_off
operator|-=
literal|8
expr_stmt|;
block|}
block|}
comment|/* Spill the rest of the BR registers.  */
for|for
control|(
name|regno
operator|=
name|BR_REG
argument_list|(
literal|1
argument_list|)
init|;
name|regno
operator|<=
name|BR_REG
argument_list|(
literal|7
argument_list|)
condition|;
operator|++
name|regno
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|current_frame_info
operator|.
name|mask
argument_list|,
name|regno
argument_list|)
condition|)
block|{
name|alt_regno
operator|=
name|next_scratch_gr_reg
argument_list|()
expr_stmt|;
name|alt_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|alt_regno
argument_list|)
expr_stmt|;
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|alt_reg
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|do_spill
argument_list|(
name|gen_movdi_x
argument_list|,
name|alt_reg
argument_list|,
name|cfa_off
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|cfa_off
operator|-=
literal|8
expr_stmt|;
block|}
comment|/* Align the frame and spill all FR registers.  */
for|for
control|(
name|regno
operator|=
name|FR_REG
argument_list|(
literal|2
argument_list|)
init|;
name|regno
operator|<=
name|FR_REG
argument_list|(
literal|127
argument_list|)
condition|;
operator|++
name|regno
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|current_frame_info
operator|.
name|mask
argument_list|,
name|regno
argument_list|)
condition|)
block|{
if|if
condition|(
name|cfa_off
operator|&
literal|15
condition|)
name|abort
argument_list|()
expr_stmt|;
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|TFmode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|do_spill
argument_list|(
name|gen_fr_spill_x
argument_list|,
name|reg
argument_list|,
name|cfa_off
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|cfa_off
operator|-=
literal|16
expr_stmt|;
block|}
if|if
condition|(
name|cfa_off
operator|!=
name|current_frame_info
operator|.
name|spill_cfa_off
condition|)
name|abort
argument_list|()
expr_stmt|;
name|finish_spill_pointers
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called after register allocation to add any instructions needed for the    epilogue.  Using an epilogue insn is favored compared to putting all of the    instructions in output_function_prologue(), since it allows the scheduler    to intermix instructions with the saves of the caller saved registers.  In    some cases, it might be necessary to emit a barrier instruction as the last    insn to prevent such scheduling.  */
end_comment

begin_function
name|void
name|ia64_expand_epilogue
parameter_list|(
name|sibcall_p
parameter_list|)
name|int
name|sibcall_p
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|,
name|reg
decl_stmt|,
name|alt_reg
decl_stmt|,
name|ar_unat_save_reg
decl_stmt|;
name|int
name|regno
decl_stmt|,
name|alt_regno
decl_stmt|,
name|cfa_off
decl_stmt|;
name|ia64_compute_frame_size
argument_list|(
name|get_frame_size
argument_list|()
argument_list|)
expr_stmt|;
comment|/* If there is a frame pointer, then we use it instead of the stack      pointer, so that the stack pointer does not need to be valid when      the epilogue starts.  See EXIT_IGNORE_STACK.  */
if|if
condition|(
name|frame_pointer_needed
condition|)
name|setup_spill_pointers
argument_list|(
name|current_frame_info
operator|.
name|n_spilled
argument_list|,
name|hard_frame_pointer_rtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|setup_spill_pointers
argument_list|(
name|current_frame_info
operator|.
name|n_spilled
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|current_frame_info
operator|.
name|total_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_frame_info
operator|.
name|total_size
operator|!=
literal|0
condition|)
block|{
comment|/* ??? At this point we must generate a magic insn that appears to          modify the spill iterators and the frame pointer.  This would 	 allow the most scheduling freedom.  For now, just hard stop.  */
name|emit_insn
argument_list|(
name|gen_blockage
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/* Locate the bottom of the register save area.  */
name|cfa_off
operator|=
operator|(
name|current_frame_info
operator|.
name|spill_cfa_off
operator|+
name|current_frame_info
operator|.
name|spill_size
operator|+
name|current_frame_info
operator|.
name|extra_spill_size
operator|)
expr_stmt|;
comment|/* Restore the predicate registers.  */
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|current_frame_info
operator|.
name|mask
argument_list|,
name|PR_REG
argument_list|(
literal|0
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_pr
operator|!=
literal|0
condition|)
name|alt_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|current_frame_info
operator|.
name|reg_save_pr
argument_list|)
expr_stmt|;
else|else
block|{
name|alt_regno
operator|=
name|next_scratch_gr_reg
argument_list|()
expr_stmt|;
name|alt_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|alt_regno
argument_list|)
expr_stmt|;
name|do_restore
argument_list|(
name|gen_movdi_x
argument_list|,
name|alt_reg
argument_list|,
name|cfa_off
argument_list|)
expr_stmt|;
name|cfa_off
operator|-=
literal|8
expr_stmt|;
block|}
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|PR_REG
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|alt_reg
argument_list|)
expr_stmt|;
block|}
comment|/* Restore the application registers.  */
comment|/* Load the saved unat from the stack, but do not restore it until      after the GRs have been restored.  */
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|current_frame_info
operator|.
name|mask
argument_list|,
name|AR_UNAT_REGNUM
argument_list|)
condition|)
block|{
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_ar_unat
operator|!=
literal|0
condition|)
name|ar_unat_save_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|current_frame_info
operator|.
name|reg_save_ar_unat
argument_list|)
expr_stmt|;
else|else
block|{
name|alt_regno
operator|=
name|next_scratch_gr_reg
argument_list|()
expr_stmt|;
name|ar_unat_save_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|alt_regno
argument_list|)
expr_stmt|;
name|current_frame_info
operator|.
name|gr_used_mask
operator||=
literal|1
operator|<<
name|alt_regno
expr_stmt|;
name|do_restore
argument_list|(
name|gen_movdi_x
argument_list|,
name|ar_unat_save_reg
argument_list|,
name|cfa_off
argument_list|)
expr_stmt|;
name|cfa_off
operator|-=
literal|8
expr_stmt|;
block|}
block|}
else|else
name|ar_unat_save_reg
operator|=
name|NULL_RTX
expr_stmt|;
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_ar_pfs
operator|!=
literal|0
condition|)
block|{
name|alt_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|current_frame_info
operator|.
name|reg_save_ar_pfs
argument_list|)
expr_stmt|;
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|AR_PFS_REGNUM
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|alt_reg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|current_function_is_leaf
condition|)
block|{
name|alt_regno
operator|=
name|next_scratch_gr_reg
argument_list|()
expr_stmt|;
name|alt_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|alt_regno
argument_list|)
expr_stmt|;
name|do_restore
argument_list|(
name|gen_movdi_x
argument_list|,
name|alt_reg
argument_list|,
name|cfa_off
argument_list|)
expr_stmt|;
name|cfa_off
operator|-=
literal|8
expr_stmt|;
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|AR_PFS_REGNUM
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|alt_reg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|current_frame_info
operator|.
name|mask
argument_list|,
name|AR_LC_REGNUM
argument_list|)
condition|)
block|{
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_ar_lc
operator|!=
literal|0
condition|)
name|alt_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|current_frame_info
operator|.
name|reg_save_ar_lc
argument_list|)
expr_stmt|;
else|else
block|{
name|alt_regno
operator|=
name|next_scratch_gr_reg
argument_list|()
expr_stmt|;
name|alt_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|alt_regno
argument_list|)
expr_stmt|;
name|do_restore
argument_list|(
name|gen_movdi_x
argument_list|,
name|alt_reg
argument_list|,
name|cfa_off
argument_list|)
expr_stmt|;
name|cfa_off
operator|-=
literal|8
expr_stmt|;
block|}
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|AR_LC_REGNUM
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|alt_reg
argument_list|)
expr_stmt|;
block|}
comment|/* We should now be at the base of the gr/br/fr spill area.  */
if|if
condition|(
name|cfa_off
operator|!=
operator|(
name|current_frame_info
operator|.
name|spill_cfa_off
operator|+
name|current_frame_info
operator|.
name|spill_size
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Restore all general registers.  */
for|for
control|(
name|regno
operator|=
name|GR_REG
argument_list|(
literal|1
argument_list|)
init|;
name|regno
operator|<=
name|GR_REG
argument_list|(
literal|31
argument_list|)
condition|;
operator|++
name|regno
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|current_frame_info
operator|.
name|mask
argument_list|,
name|regno
argument_list|)
condition|)
block|{
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|do_restore
argument_list|(
name|gen_gr_restore
argument_list|,
name|reg
argument_list|,
name|cfa_off
argument_list|)
expr_stmt|;
name|cfa_off
operator|-=
literal|8
expr_stmt|;
block|}
comment|/* Restore the branch registers.  Handle B0 specially, as it may      have gotten stored in some GR register.  */
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|current_frame_info
operator|.
name|mask
argument_list|,
name|BR_REG
argument_list|(
literal|0
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_b0
operator|!=
literal|0
condition|)
name|alt_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|current_frame_info
operator|.
name|reg_save_b0
argument_list|)
expr_stmt|;
else|else
block|{
name|alt_regno
operator|=
name|next_scratch_gr_reg
argument_list|()
expr_stmt|;
name|alt_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|alt_regno
argument_list|)
expr_stmt|;
name|do_restore
argument_list|(
name|gen_movdi_x
argument_list|,
name|alt_reg
argument_list|,
name|cfa_off
argument_list|)
expr_stmt|;
name|cfa_off
operator|-=
literal|8
expr_stmt|;
block|}
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|BR_REG
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|alt_reg
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|regno
operator|=
name|BR_REG
argument_list|(
literal|1
argument_list|)
init|;
name|regno
operator|<=
name|BR_REG
argument_list|(
literal|7
argument_list|)
condition|;
operator|++
name|regno
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|current_frame_info
operator|.
name|mask
argument_list|,
name|regno
argument_list|)
condition|)
block|{
name|alt_regno
operator|=
name|next_scratch_gr_reg
argument_list|()
expr_stmt|;
name|alt_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|alt_regno
argument_list|)
expr_stmt|;
name|do_restore
argument_list|(
name|gen_movdi_x
argument_list|,
name|alt_reg
argument_list|,
name|cfa_off
argument_list|)
expr_stmt|;
name|cfa_off
operator|-=
literal|8
expr_stmt|;
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|alt_reg
argument_list|)
expr_stmt|;
block|}
comment|/* Restore floating point registers.  */
for|for
control|(
name|regno
operator|=
name|FR_REG
argument_list|(
literal|2
argument_list|)
init|;
name|regno
operator|<=
name|FR_REG
argument_list|(
literal|127
argument_list|)
condition|;
operator|++
name|regno
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|current_frame_info
operator|.
name|mask
argument_list|,
name|regno
argument_list|)
condition|)
block|{
if|if
condition|(
name|cfa_off
operator|&
literal|15
condition|)
name|abort
argument_list|()
expr_stmt|;
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|TFmode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|do_restore
argument_list|(
name|gen_fr_restore_x
argument_list|,
name|reg
argument_list|,
name|cfa_off
argument_list|)
expr_stmt|;
name|cfa_off
operator|-=
literal|16
expr_stmt|;
block|}
comment|/* Restore ar.unat for real.  */
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|current_frame_info
operator|.
name|mask
argument_list|,
name|AR_UNAT_REGNUM
argument_list|)
condition|)
block|{
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|AR_UNAT_REGNUM
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|ar_unat_save_reg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cfa_off
operator|!=
name|current_frame_info
operator|.
name|spill_cfa_off
condition|)
name|abort
argument_list|()
expr_stmt|;
name|finish_spill_pointers
argument_list|()
expr_stmt|;
if|if
condition|(
name|current_frame_info
operator|.
name|total_size
operator|||
name|cfun
operator|->
name|machine
operator|->
name|ia64_eh_epilogue_sp
condition|)
block|{
comment|/* ??? At this point we must generate a magic insn that appears to          modify the spill iterators, the stack pointer, and the frame 	 pointer.  This would allow the most scheduling freedom.  For now, 	 just hard stop.  */
name|emit_insn
argument_list|(
name|gen_blockage
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cfun
operator|->
name|machine
operator|->
name|ia64_eh_epilogue_sp
condition|)
name|emit_move_insn
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|cfun
operator|->
name|machine
operator|->
name|ia64_eh_epilogue_sp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|hard_frame_pointer_rtx
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|current_frame_info
operator|.
name|total_size
condition|)
block|{
name|rtx
name|offset
decl_stmt|,
name|frame_size_rtx
decl_stmt|;
name|frame_size_rtx
operator|=
name|GEN_INT
argument_list|(
name|current_frame_info
operator|.
name|total_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONST_OK_FOR_I
argument_list|(
name|current_frame_info
operator|.
name|total_size
argument_list|)
condition|)
name|offset
operator|=
name|frame_size_rtx
expr_stmt|;
else|else
block|{
name|regno
operator|=
name|next_scratch_gr_reg
argument_list|()
expr_stmt|;
name|offset
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|offset
argument_list|,
name|frame_size_rtx
argument_list|)
expr_stmt|;
block|}
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|offset
argument_list|)
operator|!=
name|CONST_INT
condition|)
block|{
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_FRAME_RELATED_EXPR
argument_list|,
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|DImode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|frame_size_rtx
argument_list|)
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cfun
operator|->
name|machine
operator|->
name|ia64_eh_epilogue_bsp
condition|)
name|emit_insn
argument_list|(
name|gen_set_bsp
argument_list|(
name|cfun
operator|->
name|machine
operator|->
name|ia64_eh_epilogue_bsp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sibcall_p
condition|)
name|emit_jump_insn
argument_list|(
name|gen_return_internal
argument_list|(
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|BR_REG
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|fp
init|=
name|GR_REG
argument_list|(
literal|2
argument_list|)
decl_stmt|;
comment|/* We need a throw away register here, r0 and r1 are reserved, so r2 is the 	 first available call clobbered register.  If there was a frame_pointer  	 register, we may have swapped the names of r2 and HARD_FRAME_POINTER_REGNUM,  	 so we have to make sure we're using the string "r2" when emitting 	 the register name for the assmbler.  */
if|if
condition|(
name|current_frame_info
operator|.
name|reg_fp
operator|&&
name|current_frame_info
operator|.
name|reg_fp
operator|==
name|GR_REG
argument_list|(
literal|2
argument_list|)
condition|)
name|fp
operator|=
name|HARD_FRAME_POINTER_REGNUM
expr_stmt|;
comment|/* We must emit an alloc to force the input registers to become output 	 registers.  Otherwise, if the callee tries to pass its parameters 	 through to another call without an intervening alloc, then these 	 values get lost.  */
comment|/* ??? We don't need to preserve all input registers.  We only need to 	 preserve those input registers used as arguments to the sibling call. 	 It is unclear how to compute that number here.  */
if|if
condition|(
name|current_frame_info
operator|.
name|n_input_regs
operator|!=
literal|0
condition|)
name|emit_insn
argument_list|(
name|gen_alloc
argument_list|(
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|fp
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
literal|0
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
literal|0
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|current_frame_info
operator|.
name|n_input_regs
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return 1 if br.ret can do all the work required to return from a    function.  */
end_comment

begin_function
name|int
name|ia64_direct_return
parameter_list|()
block|{
if|if
condition|(
name|reload_completed
operator|&&
operator|!
name|frame_pointer_needed
condition|)
block|{
name|ia64_compute_frame_size
argument_list|(
name|get_frame_size
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|(
name|current_frame_info
operator|.
name|total_size
operator|==
literal|0
operator|&&
name|current_frame_info
operator|.
name|n_spilled
operator|==
literal|0
operator|&&
name|current_frame_info
operator|.
name|reg_save_b0
operator|==
literal|0
operator|&&
name|current_frame_info
operator|.
name|reg_save_pr
operator|==
literal|0
operator|&&
name|current_frame_info
operator|.
name|reg_save_ar_pfs
operator|==
literal|0
operator|&&
name|current_frame_info
operator|.
name|reg_save_ar_unat
operator|==
literal|0
operator|&&
name|current_frame_info
operator|.
name|reg_save_ar_lc
operator|==
literal|0
operator|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|ia64_hard_regno_rename_ok
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|)
name|int
name|from
decl_stmt|;
name|int
name|to
decl_stmt|;
block|{
comment|/* Don't clobber any of the registers we reserved for the prologue.  */
if|if
condition|(
name|to
operator|==
name|current_frame_info
operator|.
name|reg_fp
operator|||
name|to
operator|==
name|current_frame_info
operator|.
name|reg_save_b0
operator|||
name|to
operator|==
name|current_frame_info
operator|.
name|reg_save_pr
operator|||
name|to
operator|==
name|current_frame_info
operator|.
name|reg_save_ar_pfs
operator|||
name|to
operator|==
name|current_frame_info
operator|.
name|reg_save_ar_unat
operator|||
name|to
operator|==
name|current_frame_info
operator|.
name|reg_save_ar_lc
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|from
operator|==
name|current_frame_info
operator|.
name|reg_fp
operator|||
name|from
operator|==
name|current_frame_info
operator|.
name|reg_save_b0
operator|||
name|from
operator|==
name|current_frame_info
operator|.
name|reg_save_pr
operator|||
name|from
operator|==
name|current_frame_info
operator|.
name|reg_save_ar_pfs
operator|||
name|from
operator|==
name|current_frame_info
operator|.
name|reg_save_ar_unat
operator|||
name|from
operator|==
name|current_frame_info
operator|.
name|reg_save_ar_lc
condition|)
return|return
literal|0
return|;
comment|/* Don't use output registers outside the register frame.  */
if|if
condition|(
name|OUT_REGNO_P
argument_list|(
name|to
argument_list|)
operator|&&
name|to
operator|>=
name|OUT_REG
argument_list|(
name|current_frame_info
operator|.
name|n_output_regs
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Retain even/oddness on predicate register pairs.  */
if|if
condition|(
name|PR_REGNO_P
argument_list|(
name|from
argument_list|)
operator|&&
name|PR_REGNO_P
argument_list|(
name|to
argument_list|)
condition|)
return|return
operator|(
name|from
operator|&
literal|1
operator|)
operator|==
operator|(
name|to
operator|&
literal|1
operator|)
return|;
comment|/* Reg 4 contains the saved gp; we can't reliably rename this.  */
if|if
condition|(
name|from
operator|==
name|GR_REG
argument_list|(
literal|4
argument_list|)
operator|&&
name|current_function_calls_setjmp
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Target hook for assembling integer objects.  Handle word-sized    aligned objects and detect the cases when @fptr is needed.  */
end_comment

begin_function
specifier|static
name|bool
name|ia64_assemble_integer
parameter_list|(
name|x
parameter_list|,
name|size
parameter_list|,
name|aligned_p
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
name|int
name|aligned_p
decl_stmt|;
block|{
if|if
condition|(
name|size
operator|==
name|UNITS_PER_WORD
operator|&&
name|aligned_p
operator|&&
operator|!
operator|(
name|TARGET_NO_PIC
operator|||
name|TARGET_AUTO_PIC
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|SYMBOL_REF_FLAG
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|fputs
argument_list|(
literal|"\tdata8\t@fptr("
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|asm_out_file
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|")\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|default_assemble_integer
argument_list|(
name|x
argument_list|,
name|size
argument_list|,
name|aligned_p
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Emit the function prologue.  */
end_comment

begin_function
specifier|static
name|void
name|ia64_output_function_prologue
parameter_list|(
name|file
parameter_list|,
name|size
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|HOST_WIDE_INT
name|size
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|int
name|mask
decl_stmt|,
name|grsave
decl_stmt|,
name|grsave_prev
decl_stmt|;
if|if
condition|(
name|current_frame_info
operator|.
name|need_regstk
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.regstk %d, %d, %d, %d\n"
argument_list|,
name|current_frame_info
operator|.
name|n_input_regs
argument_list|,
name|current_frame_info
operator|.
name|n_local_regs
argument_list|,
name|current_frame_info
operator|.
name|n_output_regs
argument_list|,
name|current_frame_info
operator|.
name|n_rotate_regs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flag_unwind_tables
operator|&&
operator|(
operator|!
name|flag_exceptions
operator|||
name|USING_SJLJ_EXCEPTIONS
operator|)
condition|)
return|return;
comment|/* Emit the .prologue directive.  */
name|mask
operator|=
literal|0
expr_stmt|;
name|grsave
operator|=
name|grsave_prev
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_b0
operator|!=
literal|0
condition|)
block|{
name|mask
operator||=
literal|8
expr_stmt|;
name|grsave
operator|=
name|grsave_prev
operator|=
name|current_frame_info
operator|.
name|reg_save_b0
expr_stmt|;
block|}
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_ar_pfs
operator|!=
literal|0
operator|&&
operator|(
name|grsave_prev
operator|==
literal|0
operator|||
name|current_frame_info
operator|.
name|reg_save_ar_pfs
operator|==
name|grsave_prev
operator|+
literal|1
operator|)
condition|)
block|{
name|mask
operator||=
literal|4
expr_stmt|;
if|if
condition|(
name|grsave_prev
operator|==
literal|0
condition|)
name|grsave
operator|=
name|current_frame_info
operator|.
name|reg_save_ar_pfs
expr_stmt|;
name|grsave_prev
operator|=
name|current_frame_info
operator|.
name|reg_save_ar_pfs
expr_stmt|;
block|}
if|if
condition|(
name|current_frame_info
operator|.
name|reg_fp
operator|!=
literal|0
operator|&&
operator|(
name|grsave_prev
operator|==
literal|0
operator|||
name|current_frame_info
operator|.
name|reg_fp
operator|==
name|grsave_prev
operator|+
literal|1
operator|)
condition|)
block|{
name|mask
operator||=
literal|2
expr_stmt|;
if|if
condition|(
name|grsave_prev
operator|==
literal|0
condition|)
name|grsave
operator|=
name|HARD_FRAME_POINTER_REGNUM
expr_stmt|;
name|grsave_prev
operator|=
name|current_frame_info
operator|.
name|reg_fp
expr_stmt|;
block|}
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_pr
operator|!=
literal|0
operator|&&
operator|(
name|grsave_prev
operator|==
literal|0
operator|||
name|current_frame_info
operator|.
name|reg_save_pr
operator|==
name|grsave_prev
operator|+
literal|1
operator|)
condition|)
block|{
name|mask
operator||=
literal|1
expr_stmt|;
if|if
condition|(
name|grsave_prev
operator|==
literal|0
condition|)
name|grsave
operator|=
name|current_frame_info
operator|.
name|reg_save_pr
expr_stmt|;
block|}
if|if
condition|(
name|mask
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.prologue %d, %d\n"
argument_list|,
name|mask
argument_list|,
name|ia64_dbx_register_number
argument_list|(
name|grsave
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
literal|"\t.prologue\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* Emit a .spill directive, if necessary, to relocate the base of      the register spill area.  */
if|if
condition|(
name|current_frame_info
operator|.
name|spill_cfa_off
operator|!=
operator|-
literal|16
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.spill %ld\n"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|current_frame_info
operator|.
name|spill_cfa_off
operator|+
name|current_frame_info
operator|.
name|spill_size
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit the .body directive at the scheduled end of the prologue.  */
end_comment

begin_function
specifier|static
name|void
name|ia64_output_function_end_prologue
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|flag_unwind_tables
operator|&&
operator|(
operator|!
name|flag_exceptions
operator|||
name|USING_SJLJ_EXCEPTIONS
operator|)
condition|)
return|return;
name|fputs
argument_list|(
literal|"\t.body\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit the function epilogue.  */
end_comment

begin_function
specifier|static
name|void
name|ia64_output_function_epilogue
parameter_list|(
name|file
parameter_list|,
name|size
parameter_list|)
name|FILE
modifier|*
name|file
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|HOST_WIDE_INT
name|size
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
comment|/* Reset from the function's potential modifications.  */
name|XINT
argument_list|(
name|return_address_pointer_rtx
argument_list|,
literal|0
argument_list|)
operator|=
name|RETURN_ADDRESS_POINTER_REGNUM
expr_stmt|;
if|if
condition|(
name|current_frame_info
operator|.
name|reg_fp
condition|)
block|{
specifier|const
name|char
modifier|*
name|tmp
init|=
name|reg_names
index|[
name|HARD_FRAME_POINTER_REGNUM
index|]
decl_stmt|;
name|reg_names
index|[
name|HARD_FRAME_POINTER_REGNUM
index|]
operator|=
name|reg_names
index|[
name|current_frame_info
operator|.
name|reg_fp
index|]
expr_stmt|;
name|reg_names
index|[
name|current_frame_info
operator|.
name|reg_fp
index|]
operator|=
name|tmp
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TARGET_REG_NAMES
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|current_frame_info
operator|.
name|n_input_regs
condition|;
name|i
operator|++
control|)
name|reg_names
index|[
name|IN_REG
argument_list|(
name|i
argument_list|)
index|]
operator|=
name|ia64_input_reg_names
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|current_frame_info
operator|.
name|n_local_regs
condition|;
name|i
operator|++
control|)
name|reg_names
index|[
name|LOC_REG
argument_list|(
name|i
argument_list|)
index|]
operator|=
name|ia64_local_reg_names
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|current_frame_info
operator|.
name|n_output_regs
condition|;
name|i
operator|++
control|)
name|reg_names
index|[
name|OUT_REG
argument_list|(
name|i
argument_list|)
index|]
operator|=
name|ia64_output_reg_names
index|[
name|i
index|]
expr_stmt|;
block|}
name|current_frame_info
operator|.
name|initialized
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ia64_dbx_register_number
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
comment|/* In ia64_expand_prologue we quite literally renamed the frame pointer      from its home at loc79 to something inside the register frame.  We      must perform the same renumbering here for the debug info.  */
if|if
condition|(
name|current_frame_info
operator|.
name|reg_fp
condition|)
block|{
if|if
condition|(
name|regno
operator|==
name|HARD_FRAME_POINTER_REGNUM
condition|)
name|regno
operator|=
name|current_frame_info
operator|.
name|reg_fp
expr_stmt|;
elseif|else
if|if
condition|(
name|regno
operator|==
name|current_frame_info
operator|.
name|reg_fp
condition|)
name|regno
operator|=
name|HARD_FRAME_POINTER_REGNUM
expr_stmt|;
block|}
if|if
condition|(
name|IN_REGNO_P
argument_list|(
name|regno
argument_list|)
condition|)
return|return
literal|32
operator|+
name|regno
operator|-
name|IN_REG
argument_list|(
literal|0
argument_list|)
return|;
elseif|else
if|if
condition|(
name|LOC_REGNO_P
argument_list|(
name|regno
argument_list|)
condition|)
return|return
literal|32
operator|+
name|current_frame_info
operator|.
name|n_input_regs
operator|+
name|regno
operator|-
name|LOC_REG
argument_list|(
literal|0
argument_list|)
return|;
elseif|else
if|if
condition|(
name|OUT_REGNO_P
argument_list|(
name|regno
argument_list|)
condition|)
return|return
operator|(
literal|32
operator|+
name|current_frame_info
operator|.
name|n_input_regs
operator|+
name|current_frame_info
operator|.
name|n_local_regs
operator|+
name|regno
operator|-
name|OUT_REG
argument_list|(
literal|0
argument_list|)
operator|)
return|;
else|else
return|return
name|regno
return|;
block|}
end_function

begin_function
name|void
name|ia64_initialize_trampoline
parameter_list|(
name|addr
parameter_list|,
name|fnaddr
parameter_list|,
name|static_chain
parameter_list|)
name|rtx
name|addr
decl_stmt|,
name|fnaddr
decl_stmt|,
name|static_chain
decl_stmt|;
block|{
name|rtx
name|addr_reg
decl_stmt|,
name|eight
init|=
name|GEN_INT
argument_list|(
literal|8
argument_list|)
decl_stmt|;
comment|/* Load up our iterator.  */
name|addr_reg
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|addr_reg
argument_list|,
name|addr
argument_list|)
expr_stmt|;
comment|/* The first two words are the fake descriptor:      __ia64_trampoline, ADDR+16.  */
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|addr_reg
argument_list|)
argument_list|,
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
literal|"__ia64_trampoline"
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|addr_reg
argument_list|,
name|addr_reg
argument_list|,
name|eight
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|addr_reg
argument_list|)
argument_list|,
name|copy_to_reg
argument_list|(
name|plus_constant
argument_list|(
name|addr
argument_list|,
literal|16
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|addr_reg
argument_list|,
name|addr_reg
argument_list|,
name|eight
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The third word is the target descriptor.  */
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|addr_reg
argument_list|)
argument_list|,
name|fnaddr
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|addr_reg
argument_list|,
name|addr_reg
argument_list|,
name|eight
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The fourth word is the static chain.  */
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|addr_reg
argument_list|)
argument_list|,
name|static_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Do any needed setup for a variadic function.  CUM has not been updated    for the last named argument which has type TYPE and mode MODE.     We generate the actual spill instructions during prologue generation.  */
end_comment

begin_function
name|void
name|ia64_setup_incoming_varargs
parameter_list|(
name|cum
parameter_list|,
name|int_mode
parameter_list|,
name|type
parameter_list|,
name|pretend_size
parameter_list|,
name|second_time
parameter_list|)
name|CUMULATIVE_ARGS
name|cum
decl_stmt|;
name|int
name|int_mode
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|int
modifier|*
name|pretend_size
decl_stmt|;
name|int
name|second_time
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
comment|/* If this is a stdarg function, then skip the current argument.  */
if|if
condition|(
operator|!
name|current_function_varargs
condition|)
name|ia64_function_arg_advance
argument_list|(
operator|&
name|cum
argument_list|,
name|int_mode
argument_list|,
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cum
operator|.
name|words
operator|<
name|MAX_ARGUMENT_SLOTS
condition|)
block|{
name|int
name|n
init|=
name|MAX_ARGUMENT_SLOTS
operator|-
name|cum
operator|.
name|words
decl_stmt|;
operator|*
name|pretend_size
operator|=
name|n
operator|*
name|UNITS_PER_WORD
expr_stmt|;
name|cfun
operator|->
name|machine
operator|->
name|n_varargs
operator|=
name|n
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Check whether TYPE is a homogeneous floating point aggregate.  If    it is, return the mode of the floating point type that appears    in all leafs.  If it is not, return VOIDmode.     An aggregate is a homogeneous floating point aggregate is if all    fields/elements in it have the same floating point type (e.g,    SFmode).  128-bit quad-precision floats are excluded.  */
end_comment

begin_function
specifier|static
name|enum
name|machine_mode
name|hfa_element_mode
parameter_list|(
name|type
parameter_list|,
name|nested
parameter_list|)
name|tree
name|type
decl_stmt|;
name|int
name|nested
decl_stmt|;
block|{
name|enum
name|machine_mode
name|element_mode
init|=
name|VOIDmode
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|know_element_mode
init|=
literal|0
decl_stmt|;
name|tree
name|t
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|VOID_TYPE
case|:
case|case
name|INTEGER_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
case|case
name|BOOLEAN_TYPE
case|:
case|case
name|CHAR_TYPE
case|:
case|case
name|POINTER_TYPE
case|:
case|case
name|OFFSET_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
case|case
name|METHOD_TYPE
case|:
case|case
name|FILE_TYPE
case|:
case|case
name|SET_TYPE
case|:
case|case
name|LANG_TYPE
case|:
case|case
name|FUNCTION_TYPE
case|:
return|return
name|VOIDmode
return|;
comment|/* Fortran complex types are supposed to be HFAs, so we need to handle 	 gcc's COMPLEX_TYPEs as HFAs.  We need to exclude the integral complex 	 types though.  */
case|case
name|COMPLEX_TYPE
case|:
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|MODE_COMPLEX_FLOAT
condition|)
return|return
name|mode_for_size
argument_list|(
name|GET_MODE_UNIT_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|*
name|BITS_PER_UNIT
argument_list|,
name|MODE_FLOAT
argument_list|,
literal|0
argument_list|)
return|;
else|else
return|return
name|VOIDmode
return|;
case|case
name|REAL_TYPE
case|:
comment|/* ??? Should exclude 128-bit long double here.  */
comment|/* We want to return VOIDmode for raw REAL_TYPEs, but the actual 	 mode if this is contained within an aggregate.  */
if|if
condition|(
name|nested
condition|)
return|return
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
return|;
else|else
return|return
name|VOIDmode
return|;
case|case
name|ARRAY_TYPE
case|:
return|return
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|QUAL_UNION_TYPE
case|:
for|for
control|(
name|t
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
continue|continue;
name|mode
operator|=
name|hfa_element_mode
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|know_element_mode
condition|)
block|{
if|if
condition|(
name|mode
operator|!=
name|element_mode
condition|)
return|return
name|VOIDmode
return|;
block|}
elseif|else
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_FLOAT
condition|)
return|return
name|VOIDmode
return|;
else|else
block|{
name|know_element_mode
operator|=
literal|1
expr_stmt|;
name|element_mode
operator|=
name|mode
expr_stmt|;
block|}
block|}
return|return
name|element_mode
return|;
default|default:
comment|/* If we reach here, we probably have some front-end specific type 	 that the backend doesn't know about.  This can happen via the 	 aggregate_value_p call in init_function_start.  All we can do is 	 ignore unknown tree types.  */
return|return
name|VOIDmode
return|;
block|}
return|return
name|VOIDmode
return|;
block|}
end_function

begin_comment
comment|/* Return rtx for register where argument is passed, or zero if it is passed    on the stack.  */
end_comment

begin_comment
comment|/* ??? 128-bit quad-precision floats are always passed in general    registers.  */
end_comment

begin_function
name|rtx
name|ia64_function_arg
parameter_list|(
name|cum
parameter_list|,
name|mode
parameter_list|,
name|type
parameter_list|,
name|named
parameter_list|,
name|incoming
parameter_list|)
name|CUMULATIVE_ARGS
modifier|*
name|cum
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|int
name|named
decl_stmt|;
name|int
name|incoming
decl_stmt|;
block|{
name|int
name|basereg
init|=
operator|(
name|incoming
condition|?
name|GR_ARG_FIRST
else|:
name|AR_ARG_FIRST
operator|)
decl_stmt|;
name|int
name|words
init|=
operator|(
operator|(
operator|(
name|mode
operator|==
name|BLKmode
condition|?
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
else|:
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|)
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|enum
name|machine_mode
name|hfa_mode
init|=
name|VOIDmode
decl_stmt|;
comment|/* Integer and float arguments larger than 8 bytes start at the next even      boundary.  Aggregates larger than 8 bytes start at the next even boundary      if the aggregate has 16 byte alignment.  Net effect is that types with      alignment greater than 8 start at the next even boundary.  */
comment|/* ??? The ABI does not specify how to handle aggregates with alignment from      9 to 15 bytes, or greater than 16.   We handle them all as if they had      16 byte alignment.  Such aggregates can occur only if gcc extensions are      used.  */
if|if
condition|(
operator|(
name|type
condition|?
operator|(
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|>
literal|8
operator|*
name|BITS_PER_UNIT
operator|)
else|:
operator|(
name|words
operator|>
literal|1
operator|)
operator|)
operator|&&
operator|(
name|cum
operator|->
name|words
operator|&
literal|1
operator|)
condition|)
name|offset
operator|=
literal|1
expr_stmt|;
comment|/* If all argument slots are used, then it must go on the stack.  */
if|if
condition|(
name|cum
operator|->
name|words
operator|+
name|offset
operator|>=
name|MAX_ARGUMENT_SLOTS
condition|)
return|return
literal|0
return|;
comment|/* Check for and handle homogeneous FP aggregates.  */
if|if
condition|(
name|type
condition|)
name|hfa_mode
operator|=
name|hfa_element_mode
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Unnamed prototyped hfas are passed as usual.  Named prototyped hfas      and unprototyped hfas are passed specially.  */
if|if
condition|(
name|hfa_mode
operator|!=
name|VOIDmode
operator|&&
operator|(
operator|!
name|cum
operator|->
name|prototype
operator|||
name|named
operator|)
condition|)
block|{
name|rtx
name|loc
index|[
literal|16
index|]
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|fp_regs
init|=
name|cum
operator|->
name|fp_regs
decl_stmt|;
name|int
name|int_regs
init|=
name|cum
operator|->
name|words
operator|+
name|offset
decl_stmt|;
name|int
name|hfa_size
init|=
name|GET_MODE_SIZE
argument_list|(
name|hfa_mode
argument_list|)
decl_stmt|;
name|int
name|byte_size
decl_stmt|;
name|int
name|args_byte_size
decl_stmt|;
comment|/* If prototyped, pass it in FR regs then GR regs. 	 If not prototyped, pass it in both FR and GR regs.  	 If this is an SFmode aggregate, then it is possible to run out of 	 FR regs while GR regs are still left.  In that case, we pass the 	 remaining part in the GR regs.  */
comment|/* Fill the FP regs.  We do this always.  We stop if we reach the end 	 of the argument, the last FP register, or the last argument slot.  */
name|byte_size
operator|=
operator|(
operator|(
name|mode
operator|==
name|BLKmode
operator|)
condition|?
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
else|:
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|)
expr_stmt|;
name|args_byte_size
operator|=
name|int_regs
operator|*
name|UNITS_PER_WORD
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
operator|(
name|offset
operator|<
name|byte_size
operator|&&
name|fp_regs
operator|<
name|MAX_ARGUMENT_SLOTS
operator|&&
name|args_byte_size
operator|<
operator|(
name|MAX_ARGUMENT_SLOTS
operator|*
name|UNITS_PER_WORD
operator|)
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|loc
index|[
name|i
index|]
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|hfa_mode
argument_list|,
operator|(
name|FR_ARG_FIRST
operator|+
name|fp_regs
operator|)
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|hfa_size
expr_stmt|;
name|args_byte_size
operator|+=
name|hfa_size
expr_stmt|;
name|fp_regs
operator|++
expr_stmt|;
block|}
comment|/* If no prototype, then the whole thing must go in GR regs.  */
if|if
condition|(
operator|!
name|cum
operator|->
name|prototype
condition|)
name|offset
operator|=
literal|0
expr_stmt|;
comment|/* If this is an SFmode aggregate, then we might have some left over 	 that needs to go in GR regs.  */
elseif|else
if|if
condition|(
name|byte_size
operator|!=
name|offset
condition|)
name|int_regs
operator|+=
name|offset
operator|/
name|UNITS_PER_WORD
expr_stmt|;
comment|/* Fill in the GR regs.  We must use DImode here, not the hfa mode.  */
for|for
control|(
init|;
name|offset
operator|<
name|byte_size
operator|&&
name|int_regs
operator|<
name|MAX_ARGUMENT_SLOTS
condition|;
name|i
operator|++
control|)
block|{
name|enum
name|machine_mode
name|gr_mode
init|=
name|DImode
decl_stmt|;
comment|/* If we have an odd 4 byte hunk because we ran out of FR regs, 	     then this goes in a GR reg left adjusted/little endian, right 	     adjusted/big endian.  */
comment|/* ??? Currently this is handled wrong, because 4-byte hunks are 	     always right adjusted/little endian.  */
if|if
condition|(
name|offset
operator|&
literal|0x4
condition|)
name|gr_mode
operator|=
name|SImode
expr_stmt|;
comment|/* If we have an even 4 byte hunk because the aggregate is a 	     multiple of 4 bytes in size, then this goes in a GR reg right 	     adjusted/little endian.  */
elseif|else
if|if
condition|(
name|byte_size
operator|-
name|offset
operator|==
literal|4
condition|)
name|gr_mode
operator|=
name|SImode
expr_stmt|;
comment|/* Complex floats need to have float mode.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_COMPLEX_FLOAT
condition|)
name|gr_mode
operator|=
name|hfa_mode
expr_stmt|;
name|loc
index|[
name|i
index|]
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|gr_mode
argument_list|,
operator|(
name|basereg
operator|+
name|int_regs
operator|)
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|GET_MODE_SIZE
argument_list|(
name|gr_mode
argument_list|)
expr_stmt|;
name|int_regs
operator|+=
name|GET_MODE_SIZE
argument_list|(
name|gr_mode
argument_list|)
operator|<=
name|UNITS_PER_WORD
condition|?
literal|1
else|:
name|GET_MODE_SIZE
argument_list|(
name|gr_mode
argument_list|)
operator|/
name|UNITS_PER_WORD
expr_stmt|;
block|}
comment|/* If we ended up using just one location, just return that one loc.  */
if|if
condition|(
name|i
operator|==
literal|1
condition|)
return|return
name|XEXP
argument_list|(
name|loc
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
return|;
else|else
return|return
name|gen_rtx_PARALLEL
argument_list|(
name|mode
argument_list|,
name|gen_rtvec_v
argument_list|(
name|i
argument_list|,
name|loc
argument_list|)
argument_list|)
return|;
block|}
comment|/* Integral and aggregates go in general registers.  If we have run out of      FR registers, then FP values must also go in general registers.  This can      happen when we have a SFmode HFA.  */
elseif|else
if|if
condition|(
operator|(
operator|(
name|mode
operator|==
name|TFmode
operator|)
operator|&&
operator|!
name|INTEL_EXTENDED_IEEE_FORMAT
operator|)
operator|||
operator|(
operator|!
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
operator|||
name|cum
operator|->
name|fp_regs
operator|==
name|MAX_ARGUMENT_SLOTS
operator|)
condition|)
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|basereg
operator|+
name|cum
operator|->
name|words
operator|+
name|offset
argument_list|)
return|;
comment|/* If there is a prototype, then FP values go in a FR register when      named, and in a GR registeer when unnamed.  */
elseif|else
if|if
condition|(
name|cum
operator|->
name|prototype
condition|)
block|{
if|if
condition|(
operator|!
name|named
condition|)
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|basereg
operator|+
name|cum
operator|->
name|words
operator|+
name|offset
argument_list|)
return|;
else|else
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|FR_ARG_FIRST
operator|+
name|cum
operator|->
name|fp_regs
argument_list|)
return|;
block|}
comment|/* If there is no prototype, then FP values go in both FR and GR      registers.  */
else|else
block|{
name|rtx
name|fp_reg
init|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
operator|(
name|FR_ARG_FIRST
operator|+
name|cum
operator|->
name|fp_regs
operator|)
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
decl_stmt|;
name|rtx
name|gr_reg
init|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
operator|(
name|basereg
operator|+
name|cum
operator|->
name|words
operator|+
name|offset
operator|)
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
decl_stmt|;
return|return
name|gen_rtx_PARALLEL
argument_list|(
name|mode
argument_list|,
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|fp_reg
argument_list|,
name|gr_reg
argument_list|)
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return number of words, at the beginning of the argument, that must be    put in registers.  0 is the argument is entirely in registers or entirely    in memory.  */
end_comment

begin_function
name|int
name|ia64_function_arg_partial_nregs
parameter_list|(
name|cum
parameter_list|,
name|mode
parameter_list|,
name|type
parameter_list|,
name|named
parameter_list|)
name|CUMULATIVE_ARGS
modifier|*
name|cum
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|int
name|named
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|int
name|words
init|=
operator|(
operator|(
operator|(
name|mode
operator|==
name|BLKmode
condition|?
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
else|:
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|)
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
comment|/* Arguments with alignment larger than 8 bytes start at the next even      boundary.  */
if|if
condition|(
operator|(
name|type
condition|?
operator|(
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|>
literal|8
operator|*
name|BITS_PER_UNIT
operator|)
else|:
operator|(
name|words
operator|>
literal|1
operator|)
operator|)
operator|&&
operator|(
name|cum
operator|->
name|words
operator|&
literal|1
operator|)
condition|)
name|offset
operator|=
literal|1
expr_stmt|;
comment|/* If all argument slots are used, then it must go on the stack.  */
if|if
condition|(
name|cum
operator|->
name|words
operator|+
name|offset
operator|>=
name|MAX_ARGUMENT_SLOTS
condition|)
return|return
literal|0
return|;
comment|/* It doesn't matter whether the argument goes in FR or GR regs.  If      it fits within the 8 argument slots, then it goes entirely in      registers.  If it extends past the last argument slot, then the rest      goes on the stack.  */
if|if
condition|(
name|words
operator|+
name|cum
operator|->
name|words
operator|+
name|offset
operator|<=
name|MAX_ARGUMENT_SLOTS
condition|)
return|return
literal|0
return|;
return|return
name|MAX_ARGUMENT_SLOTS
operator|-
name|cum
operator|->
name|words
operator|-
name|offset
return|;
block|}
end_function

begin_comment
comment|/* Update CUM to point after this argument.  This is patterned after    ia64_function_arg.  */
end_comment

begin_function
name|void
name|ia64_function_arg_advance
parameter_list|(
name|cum
parameter_list|,
name|mode
parameter_list|,
name|type
parameter_list|,
name|named
parameter_list|)
name|CUMULATIVE_ARGS
modifier|*
name|cum
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|int
name|named
decl_stmt|;
block|{
name|int
name|words
init|=
operator|(
operator|(
operator|(
name|mode
operator|==
name|BLKmode
condition|?
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
else|:
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|)
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|enum
name|machine_mode
name|hfa_mode
init|=
name|VOIDmode
decl_stmt|;
comment|/* If all arg slots are already full, then there is nothing to do.  */
if|if
condition|(
name|cum
operator|->
name|words
operator|>=
name|MAX_ARGUMENT_SLOTS
condition|)
return|return;
comment|/* Arguments with alignment larger than 8 bytes start at the next even      boundary.  */
if|if
condition|(
operator|(
name|type
condition|?
operator|(
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|>
literal|8
operator|*
name|BITS_PER_UNIT
operator|)
else|:
operator|(
name|words
operator|>
literal|1
operator|)
operator|)
operator|&&
operator|(
name|cum
operator|->
name|words
operator|&
literal|1
operator|)
condition|)
name|offset
operator|=
literal|1
expr_stmt|;
name|cum
operator|->
name|words
operator|+=
name|words
operator|+
name|offset
expr_stmt|;
comment|/* Check for and handle homogeneous FP aggregates.  */
if|if
condition|(
name|type
condition|)
name|hfa_mode
operator|=
name|hfa_element_mode
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Unnamed prototyped hfas are passed as usual.  Named prototyped hfas      and unprototyped hfas are passed specially.  */
if|if
condition|(
name|hfa_mode
operator|!=
name|VOIDmode
operator|&&
operator|(
operator|!
name|cum
operator|->
name|prototype
operator|||
name|named
operator|)
condition|)
block|{
name|int
name|fp_regs
init|=
name|cum
operator|->
name|fp_regs
decl_stmt|;
comment|/* This is the original value of cum->words + offset.  */
name|int
name|int_regs
init|=
name|cum
operator|->
name|words
operator|-
name|words
decl_stmt|;
name|int
name|hfa_size
init|=
name|GET_MODE_SIZE
argument_list|(
name|hfa_mode
argument_list|)
decl_stmt|;
name|int
name|byte_size
decl_stmt|;
name|int
name|args_byte_size
decl_stmt|;
comment|/* If prototyped, pass it in FR regs then GR regs. 	 If not prototyped, pass it in both FR and GR regs.  	 If this is an SFmode aggregate, then it is possible to run out of 	 FR regs while GR regs are still left.  In that case, we pass the 	 remaining part in the GR regs.  */
comment|/* Fill the FP regs.  We do this always.  We stop if we reach the end 	 of the argument, the last FP register, or the last argument slot.  */
name|byte_size
operator|=
operator|(
operator|(
name|mode
operator|==
name|BLKmode
operator|)
condition|?
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
else|:
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|)
expr_stmt|;
name|args_byte_size
operator|=
name|int_regs
operator|*
name|UNITS_PER_WORD
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
operator|(
name|offset
operator|<
name|byte_size
operator|&&
name|fp_regs
operator|<
name|MAX_ARGUMENT_SLOTS
operator|&&
name|args_byte_size
operator|<
operator|(
name|MAX_ARGUMENT_SLOTS
operator|*
name|UNITS_PER_WORD
operator|)
operator|)
condition|;
control|)
block|{
name|offset
operator|+=
name|hfa_size
expr_stmt|;
name|args_byte_size
operator|+=
name|hfa_size
expr_stmt|;
name|fp_regs
operator|++
expr_stmt|;
block|}
name|cum
operator|->
name|fp_regs
operator|=
name|fp_regs
expr_stmt|;
block|}
comment|/* Integral and aggregates go in general registers.  If we have run out of      FR registers, then FP values must also go in general registers.  This can      happen when we have a SFmode HFA.  */
elseif|else
if|if
condition|(
operator|!
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
operator|||
name|cum
operator|->
name|fp_regs
operator|==
name|MAX_ARGUMENT_SLOTS
condition|)
return|return;
comment|/* If there is a prototype, then FP values go in a FR register when      named, and in a GR registeer when unnamed.  */
elseif|else
if|if
condition|(
name|cum
operator|->
name|prototype
condition|)
block|{
if|if
condition|(
operator|!
name|named
condition|)
return|return;
else|else
comment|/* ??? Complex types should not reach here.  */
name|cum
operator|->
name|fp_regs
operator|+=
operator|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_COMPLEX_FLOAT
condition|?
literal|2
else|:
literal|1
operator|)
expr_stmt|;
block|}
comment|/* If there is no prototype, then FP values go in both FR and GR      registers.  */
else|else
comment|/* ??? Complex types should not reach here.  */
name|cum
operator|->
name|fp_regs
operator|+=
operator|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_COMPLEX_FLOAT
condition|?
literal|2
else|:
literal|1
operator|)
expr_stmt|;
return|return;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Implement va_start.  */
end_comment

begin_function
name|void
name|ia64_va_start
parameter_list|(
name|stdarg_p
parameter_list|,
name|valist
parameter_list|,
name|nextarg
parameter_list|)
name|int
name|stdarg_p
decl_stmt|;
name|tree
name|valist
decl_stmt|;
name|rtx
name|nextarg
decl_stmt|;
block|{
name|int
name|arg_words
decl_stmt|;
name|int
name|ofs
decl_stmt|;
name|arg_words
operator|=
name|current_function_args_info
operator|.
name|words
expr_stmt|;
if|if
condition|(
name|stdarg_p
condition|)
name|ofs
operator|=
literal|0
expr_stmt|;
else|else
name|ofs
operator|=
operator|(
name|arg_words
operator|>=
name|MAX_ARGUMENT_SLOTS
condition|?
operator|-
name|UNITS_PER_WORD
else|:
literal|0
operator|)
expr_stmt|;
name|nextarg
operator|=
name|plus_constant
argument_list|(
name|nextarg
argument_list|,
name|ofs
argument_list|)
expr_stmt|;
name|std_expand_builtin_va_start
argument_list|(
literal|1
argument_list|,
name|valist
argument_list|,
name|nextarg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Implement va_arg.  */
end_comment

begin_function
name|rtx
name|ia64_va_arg
parameter_list|(
name|valist
parameter_list|,
name|type
parameter_list|)
name|tree
name|valist
decl_stmt|,
name|type
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
comment|/* Arguments with alignment larger than 8 bytes start at the next even      boundary.  */
if|if
condition|(
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|>
literal|8
operator|*
name|BITS_PER_UNIT
condition|)
block|{
name|t
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|valist
argument_list|)
argument_list|,
name|valist
argument_list|,
name|build_int_2
argument_list|(
literal|2
operator|*
name|UNITS_PER_WORD
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|t
argument_list|,
name|build_int_2
argument_list|(
operator|-
literal|2
operator|*
name|UNITS_PER_WORD
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|valist
argument_list|)
argument_list|,
name|valist
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
block|}
return|return
name|std_expand_builtin_va_arg
argument_list|(
name|valist
argument_list|,
name|type
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if function return value returned in memory.  Return 0 if it is    in a register.  */
end_comment

begin_function
name|int
name|ia64_return_in_memory
parameter_list|(
name|valtype
parameter_list|)
name|tree
name|valtype
decl_stmt|;
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|hfa_mode
decl_stmt|;
name|HOST_WIDE_INT
name|byte_size
decl_stmt|;
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|valtype
argument_list|)
expr_stmt|;
name|byte_size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|BLKmode
condition|)
block|{
name|byte_size
operator|=
name|int_size_in_bytes
argument_list|(
name|valtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|byte_size
operator|<
literal|0
condition|)
return|return
literal|1
return|;
block|}
comment|/* Hfa's with up to 8 elements are returned in the FP argument registers.  */
name|hfa_mode
operator|=
name|hfa_element_mode
argument_list|(
name|valtype
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|hfa_mode
operator|!=
name|VOIDmode
condition|)
block|{
name|int
name|hfa_size
init|=
name|GET_MODE_SIZE
argument_list|(
name|hfa_mode
argument_list|)
decl_stmt|;
if|if
condition|(
name|byte_size
operator|/
name|hfa_size
operator|>
name|MAX_ARGUMENT_SLOTS
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|byte_size
operator|>
name|UNITS_PER_WORD
operator|*
name|MAX_INT_RETURN_SLOTS
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return rtx for register that holds the function return value.  */
end_comment

begin_function
name|rtx
name|ia64_function_value
parameter_list|(
name|valtype
parameter_list|,
name|func
parameter_list|)
name|tree
name|valtype
decl_stmt|;
name|tree
name|func
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|hfa_mode
decl_stmt|;
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|valtype
argument_list|)
expr_stmt|;
name|hfa_mode
operator|=
name|hfa_element_mode
argument_list|(
name|valtype
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|hfa_mode
operator|!=
name|VOIDmode
condition|)
block|{
name|rtx
name|loc
index|[
literal|8
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|hfa_size
decl_stmt|;
name|int
name|byte_size
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|hfa_size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|hfa_mode
argument_list|)
expr_stmt|;
name|byte_size
operator|=
operator|(
operator|(
name|mode
operator|==
name|BLKmode
operator|)
condition|?
name|int_size_in_bytes
argument_list|(
name|valtype
argument_list|)
else|:
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|)
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|offset
operator|<
name|byte_size
condition|;
name|i
operator|++
control|)
block|{
name|loc
index|[
name|i
index|]
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|hfa_mode
argument_list|,
name|FR_ARG_FIRST
operator|+
name|i
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|hfa_size
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|1
condition|)
return|return
name|XEXP
argument_list|(
name|loc
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
return|;
else|else
return|return
name|gen_rtx_PARALLEL
argument_list|(
name|mode
argument_list|,
name|gen_rtvec_v
argument_list|(
name|i
argument_list|,
name|loc
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|FLOAT_TYPE_P
argument_list|(
name|valtype
argument_list|)
operator|&&
operator|(
operator|(
name|mode
operator|!=
name|TFmode
operator|)
operator|||
name|INTEL_EXTENDED_IEEE_FORMAT
operator|)
condition|)
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|FR_ARG_FIRST
argument_list|)
return|;
else|else
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|GR_RET_FIRST
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Print a memory address as an operand to reference that memory location.  */
end_comment

begin_comment
comment|/* ??? Do we need this?  It gets used only for 'a' operands.  We could perhaps    also call this from ia64_print_operand for memory addresses.  */
end_comment

begin_function
name|void
name|ia64_print_operand_address
parameter_list|(
name|stream
parameter_list|,
name|address
parameter_list|)
name|FILE
modifier|*
name|stream
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|rtx
name|address
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{ }
end_function

begin_comment
comment|/* Print an operand to an assembler instruction.    C	Swap and print a comparison operator.    D	Print an FP comparison operator.    E    Print 32 - constant, for SImode shifts as extract.    e    Print 64 - constant, for DImode rotates.    F	A floating point constant 0.0 emitted as f0, or 1.0 emitted as f1, or         a floating point register emitted normally.    I	Invert a predicate register by adding 1.    J    Select the proper predicate register for a condition.    j    Select the inverse predicate register for a condition.    O	Append .acq for volatile load.    P	Postincrement of a MEM.    Q	Append .rel for volatile store.    S	Shift amount for shladd instruction.    T	Print an 8-bit sign extended number (K) as a 32-bit unsigned number 	for Intel assembler.    U	Print an 8-bit sign extended number (K) as a 64-bit unsigned number 	for Intel assembler.    r	Print register name, or constant 0 as r0.  HP compatibility for 	Linux kernel.  */
end_comment

begin_function
name|void
name|ia64_print_operand
parameter_list|(
name|file
parameter_list|,
name|x
parameter_list|,
name|code
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|int
name|code
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
literal|0
case|:
comment|/* Handled below.  */
break|break;
case|case
literal|'C'
case|:
block|{
name|enum
name|rtx_code
name|c
init|=
name|swap_condition
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
name|fputs
argument_list|(
name|GET_RTX_NAME
argument_list|(
name|c
argument_list|)
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
literal|'D'
case|:
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|NE
case|:
name|str
operator|=
literal|"neq"
expr_stmt|;
break|break;
case|case
name|UNORDERED
case|:
name|str
operator|=
literal|"unord"
expr_stmt|;
break|break;
case|case
name|ORDERED
case|:
name|str
operator|=
literal|"ord"
expr_stmt|;
break|break;
default|default:
name|str
operator|=
name|GET_RTX_NAME
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|fputs
argument_list|(
name|str
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'E'
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
literal|32
operator|-
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'e'
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
literal|64
operator|-
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'F'
case|:
if|if
condition|(
name|x
operator|==
name|CONST0_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|str
operator|=
name|reg_names
index|[
name|FR_REG
argument_list|(
literal|0
argument_list|)
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|x
operator|==
name|CONST1_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|str
operator|=
name|reg_names
index|[
name|FR_REG
argument_list|(
literal|1
argument_list|)
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
name|str
operator|=
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
name|fputs
argument_list|(
name|str
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'I'
case|:
name|fputs
argument_list|(
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
operator|+
literal|1
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'J'
case|:
case|case
literal|'j'
case|:
block|{
name|unsigned
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|EQ
condition|)
name|regno
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|code
operator|==
literal|'j'
condition|)
name|regno
operator|^=
literal|1
expr_stmt|;
name|fputs
argument_list|(
name|reg_names
index|[
name|regno
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
literal|'O'
case|:
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
condition|)
name|fputs
argument_list|(
literal|".acq"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'P'
case|:
block|{
name|HOST_WIDE_INT
name|value
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
default|default:
return|return;
case|case
name|POST_MODIFY
case|:
name|x
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
condition|)
name|value
operator|=
name|INTVAL
argument_list|(
name|x
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|", %s"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
break|break;
case|case
name|POST_INC
case|:
name|value
operator|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|POST_DEC
case|:
name|value
operator|=
operator|-
operator|(
name|HOST_WIDE_INT
operator|)
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|putc
argument_list|(
literal|','
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|' '
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
literal|'Q'
case|:
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
condition|)
name|fputs
argument_list|(
literal|".rel"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'S'
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|exact_log2
argument_list|(
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'T'
case|:
if|if
condition|(
operator|!
name|TARGET_GNU_AS
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0x%x"
argument_list|,
operator|(
name|int
operator|)
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
literal|'U'
case|:
if|if
condition|(
operator|!
name|TARGET_GNU_AS
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
specifier|const
name|char
modifier|*
name|prefix
init|=
literal|"0x"
decl_stmt|;
if|if
condition|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
literal|0x80000000
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0xffffffff"
argument_list|)
expr_stmt|;
name|prefix
operator|=
literal|""
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s%x"
argument_list|,
name|prefix
argument_list|,
operator|(
name|int
operator|)
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
literal|'r'
case|:
comment|/* If this operand is the constant zero, write it as register zero. 	 Any register, zero, or CONST_INT value is OK here.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
name|fputs
argument_list|(
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|x
operator|==
name|CONST0_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|fputs
argument_list|(
literal|"r0"
argument_list|,
name|file
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
condition|)
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
else|else
name|output_operand_lossage
argument_list|(
literal|"invalid %%r value"
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'+'
case|:
block|{
specifier|const
name|char
modifier|*
name|which
decl_stmt|;
comment|/* For conditional branches, returns or calls, substitute 	   sptk, dptk, dpnt, or spnt for %s.  */
name|x
operator|=
name|find_reg_note
argument_list|(
name|current_output_insn
argument_list|,
name|REG_BR_PROB
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
condition|)
block|{
name|int
name|pred_val
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Guess top and bottom 10% statically predicted.  */
if|if
condition|(
name|pred_val
operator|<
name|REG_BR_PROB_BASE
operator|/
literal|50
condition|)
name|which
operator|=
literal|".spnt"
expr_stmt|;
elseif|else
if|if
condition|(
name|pred_val
operator|<
name|REG_BR_PROB_BASE
operator|/
literal|2
condition|)
name|which
operator|=
literal|".dpnt"
expr_stmt|;
elseif|else
if|if
condition|(
name|pred_val
operator|<
name|REG_BR_PROB_BASE
operator|/
literal|100
operator|*
literal|98
condition|)
name|which
operator|=
literal|".dptk"
expr_stmt|;
else|else
name|which
operator|=
literal|".sptk"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|current_output_insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
name|which
operator|=
literal|".sptk"
expr_stmt|;
else|else
name|which
operator|=
literal|".dptk"
expr_stmt|;
name|fputs
argument_list|(
name|which
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
literal|','
case|:
name|x
operator|=
name|current_insn_predicate
expr_stmt|;
if|if
condition|(
name|x
condition|)
block|{
name|unsigned
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|EQ
condition|)
name|regno
operator|+=
literal|1
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"(%s) "
argument_list|,
name|reg_names
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
block|}
return|return;
default|default:
name|output_operand_lossage
argument_list|(
literal|"ia64_print_operand: unknown code"
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
comment|/* This happens for the spill/restore instructions.  */
case|case
name|POST_INC
case|:
case|case
name|POST_DEC
case|:
case|case
name|POST_MODIFY
case|:
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* ... fall through ...  */
case|case
name|REG
case|:
name|fputs
argument_list|(
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEM
case|:
block|{
name|rtx
name|addr
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
argument_list|)
operator|==
literal|'a'
condition|)
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"[%s]"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|addr
argument_list|)
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
break|break;
block|}
return|return;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Calulate the cost of moving data from a register in class FROM to    one in class TO, using MODE.  */
end_comment

begin_function
name|int
name|ia64_register_move_cost
parameter_list|(
name|mode
parameter_list|,
name|from
parameter_list|,
name|to
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|enum
name|reg_class
name|from
decl_stmt|,
name|to
decl_stmt|;
block|{
comment|/* ADDL_REGS is the same as GR_REGS for movement purposes.  */
if|if
condition|(
name|to
operator|==
name|ADDL_REGS
condition|)
name|to
operator|=
name|GR_REGS
expr_stmt|;
if|if
condition|(
name|from
operator|==
name|ADDL_REGS
condition|)
name|from
operator|=
name|GR_REGS
expr_stmt|;
comment|/* All costs are symmetric, so reduce cases by putting the      lower number class as the destination.  */
if|if
condition|(
name|from
operator|<
name|to
condition|)
block|{
name|enum
name|reg_class
name|tmp
init|=
name|to
decl_stmt|;
name|to
operator|=
name|from
operator|,
name|from
operator|=
name|tmp
expr_stmt|;
block|}
comment|/* Moving from FR<->GR in TFmode must be more expensive than 2,      so that we get secondary memory reloads.  Between FR_REGS,      we have to make this at least as expensive as MEMORY_MOVE_COST      to avoid spectacularly poor register class preferencing.  */
if|if
condition|(
name|mode
operator|==
name|TFmode
condition|)
block|{
if|if
condition|(
name|to
operator|!=
name|GR_REGS
operator|||
name|from
operator|!=
name|GR_REGS
condition|)
return|return
name|MEMORY_MOVE_COST
argument_list|(
name|mode
argument_list|,
name|to
argument_list|,
literal|0
argument_list|)
return|;
else|else
return|return
literal|3
return|;
block|}
switch|switch
condition|(
name|to
condition|)
block|{
case|case
name|PR_REGS
case|:
comment|/* Moving between PR registers takes two insns.  */
if|if
condition|(
name|from
operator|==
name|PR_REGS
condition|)
return|return
literal|3
return|;
comment|/* Moving between PR and anything but GR is impossible.  */
if|if
condition|(
name|from
operator|!=
name|GR_REGS
condition|)
return|return
name|MEMORY_MOVE_COST
argument_list|(
name|mode
argument_list|,
name|to
argument_list|,
literal|0
argument_list|)
return|;
break|break;
case|case
name|BR_REGS
case|:
comment|/* Moving between BR and anything but GR is impossible.  */
if|if
condition|(
name|from
operator|!=
name|GR_REGS
operator|&&
name|from
operator|!=
name|GR_AND_BR_REGS
condition|)
return|return
name|MEMORY_MOVE_COST
argument_list|(
name|mode
argument_list|,
name|to
argument_list|,
literal|0
argument_list|)
return|;
break|break;
case|case
name|AR_I_REGS
case|:
case|case
name|AR_M_REGS
case|:
comment|/* Moving between AR and anything but GR is impossible.  */
if|if
condition|(
name|from
operator|!=
name|GR_REGS
condition|)
return|return
name|MEMORY_MOVE_COST
argument_list|(
name|mode
argument_list|,
name|to
argument_list|,
literal|0
argument_list|)
return|;
break|break;
case|case
name|GR_REGS
case|:
case|case
name|FR_REGS
case|:
case|case
name|GR_AND_FR_REGS
case|:
case|case
name|GR_AND_BR_REGS
case|:
case|case
name|ALL_REGS
case|:
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
literal|2
return|;
block|}
end_function

begin_comment
comment|/* This function returns the register class required for a secondary    register when copying between one of the registers in CLASS, and X,    using MODE.  A return value of NO_REGS means that no secondary register    is required.  */
end_comment

begin_function
name|enum
name|reg_class
name|ia64_secondary_reload_class
parameter_list|(
name|class
parameter_list|,
name|mode
parameter_list|,
name|x
parameter_list|)
name|enum
name|reg_class
name|class
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
name|int
name|regno
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
condition|)
name|regno
operator|=
name|true_regnum
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|class
condition|)
block|{
case|case
name|BR_REGS
case|:
case|case
name|AR_M_REGS
case|:
case|case
name|AR_I_REGS
case|:
comment|/* ??? BR<->BR register copies can happen due to a bad gcse/cse/global 	 interaction.  We end up with two pseudos with overlapping lifetimes 	 both of which are equiv to the same constant, and both which need 	 to be in BR_REGS.  This seems to be a cse bug.  cse_basic_block_end 	 changes depending on the path length, which means the qty_first_reg 	 check in make_regs_eqv can give different answers at different times. 	 At some point I'll probably need a reload_indi pattern to handle 	 this.  	 We can also get GR_AND_FR_REGS to BR_REGS/AR_REGS copies, where we 	 wound up with a FP register from GR_AND_FR_REGS.  Extend that to all 	 non-general registers for good measure.  */
if|if
condition|(
name|regno
operator|>=
literal|0
operator|&&
operator|!
name|GENERAL_REGNO_P
argument_list|(
name|regno
argument_list|)
condition|)
return|return
name|GR_REGS
return|;
comment|/* This is needed if a pseudo used as a call_operand gets spilled to a 	 stack slot.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
return|return
name|GR_REGS
return|;
break|break;
case|case
name|FR_REGS
case|:
comment|/* Need to go through general regsters to get to other class regs.  */
if|if
condition|(
name|regno
operator|>=
literal|0
operator|&&
operator|!
operator|(
name|FR_REGNO_P
argument_list|(
name|regno
argument_list|)
operator|||
name|GENERAL_REGNO_P
argument_list|(
name|regno
argument_list|)
operator|)
condition|)
return|return
name|GR_REGS
return|;
comment|/* This can happen when a paradoxical subreg is an operand to the 	 muldi3 pattern.  */
comment|/* ??? This shouldn't be necessary after instruction scheduling is 	 enabled, because paradoxical subregs are not accepted by 	 register_operand when INSN_SCHEDULING is defined.  Or alternatively, 	 stop the paradoxical subreg stupidity in the *_operand functions 	 in recog.c.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|SImode
operator|||
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|HImode
operator|||
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|QImode
operator|)
condition|)
return|return
name|GR_REGS
return|;
comment|/* This can happen because of the ior/and/etc patterns that accept FP 	 registers as operands.  If the third operand is a constant, then it 	 needs to be reloaded into a FP register.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|GR_REGS
return|;
comment|/* This can happen because of register elimination in a muldi3 insn. 	 E.g. `26107 * (unsigned long)&u'.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
condition|)
return|return
name|GR_REGS
return|;
break|break;
case|case
name|PR_REGS
case|:
comment|/* ??? This happens if we cse/gcse a BImode value across a call, 	 and the function has a nonlocal goto.  This is because global 	 does not allocate call crossing pseudos to hard registers when 	 current_function_has_nonlocal_goto is true.  This is relatively 	 common for C++ programs that use exceptions.  To reproduce, 	 return NO_REGS and compile libstdc++.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
return|return
name|GR_REGS
return|;
comment|/* This can happen when we take a BImode subreg of a DImode value, 	 and that DImode value winds up in some non-GR register.  */
if|if
condition|(
name|regno
operator|>=
literal|0
operator|&&
operator|!
name|GENERAL_REGNO_P
argument_list|(
name|regno
argument_list|)
operator|&&
operator|!
name|PR_REGNO_P
argument_list|(
name|regno
argument_list|)
condition|)
return|return
name|GR_REGS
return|;
break|break;
case|case
name|GR_REGS
case|:
comment|/* Since we have no offsettable memory addresses, we need a temporary 	 to hold the address of the second word.  */
if|if
condition|(
name|mode
operator|==
name|TImode
condition|)
return|return
name|GR_REGS
return|;
break|break;
default|default:
break|break;
block|}
return|return
name|NO_REGS
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit text to declare externally defined variables and functions, because    the Intel assembler does not support undefined externals.  */
end_comment

begin_function
name|void
name|ia64_asm_output_external
parameter_list|(
name|file
parameter_list|,
name|decl
parameter_list|,
name|name
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|tree
name|decl
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|save_referenced
decl_stmt|;
comment|/* GNU as does not need anything here.  */
if|if
condition|(
name|TARGET_GNU_AS
condition|)
return|return;
comment|/* ??? The Intel assembler creates a reference that needs to be satisfied by      the linker when we do this, so we need to be careful not to do this for      builtin functions which have no library equivalent.  Unfortunately, we      can't tell here whether or not a function will actually be called by      expand_expr, so we pull in library functions even if we may not need      them later.  */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"__builtin_next_arg"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"alloca"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"__builtin_constant_p"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"__builtin_args_info"
argument_list|)
condition|)
return|return;
comment|/* assemble_name will set TREE_SYMBOL_REFERENCED, so we must save and      restore it.  */
name|save_referenced
operator|=
name|TREE_SYMBOL_REFERENCED
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|TYPE_ASM_OP
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|','
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|TYPE_OPERAND_FMT
argument_list|,
literal|"function"
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
name|ASM_GLOBALIZE_LABEL
argument_list|(
name|file
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|TREE_SYMBOL_REFERENCED
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
name|save_referenced
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Parse the -mfixed-range= option string.  */
end_comment

begin_function
specifier|static
name|void
name|fix_range
parameter_list|(
name|const_str
parameter_list|)
specifier|const
name|char
modifier|*
name|const_str
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|first
decl_stmt|,
name|last
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|,
modifier|*
name|dash
decl_stmt|,
modifier|*
name|comma
decl_stmt|;
comment|/* str must be of the form REG1'-'REG2{,REG1'-'REG} where REG1 and      REG2 are either register names or register numbers.  The effect      of this option is to mark the registers in the range from REG1 to      REG2 as ``fixed'' so they won't be used by the compiler.  This is      used, e.g., to ensure that kernel mode code doesn't use f32-f127.  */
name|i
operator|=
name|strlen
argument_list|(
name|const_str
argument_list|)
expr_stmt|;
name|str
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|str
argument_list|,
name|const_str
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|dash
operator|=
name|strchr
argument_list|(
name|str
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dash
condition|)
block|{
name|warning
argument_list|(
literal|"value of -mfixed-range must have form REG1-REG2"
argument_list|)
expr_stmt|;
return|return;
block|}
operator|*
name|dash
operator|=
literal|'\0'
expr_stmt|;
name|comma
operator|=
name|strchr
argument_list|(
name|dash
operator|+
literal|1
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|comma
condition|)
operator|*
name|comma
operator|=
literal|'\0'
expr_stmt|;
name|first
operator|=
name|decode_reg_name
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|first
operator|<
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"unknown register name: %s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
name|last
operator|=
name|decode_reg_name
argument_list|(
name|dash
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|last
operator|<
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"unknown register name: %s"
argument_list|,
name|dash
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
operator|*
name|dash
operator|=
literal|'-'
expr_stmt|;
if|if
condition|(
name|first
operator|>
name|last
condition|)
block|{
name|warning
argument_list|(
literal|"%s-%s is an empty range"
argument_list|,
name|str
argument_list|,
name|dash
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
name|first
init|;
name|i
operator|<=
name|last
condition|;
operator|++
name|i
control|)
name|fixed_regs
index|[
name|i
index|]
operator|=
name|call_used_regs
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|comma
condition|)
break|break;
operator|*
name|comma
operator|=
literal|','
expr_stmt|;
name|str
operator|=
name|comma
operator|+
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Called to register all of our global variables with the garbage    collector.  */
end_comment

begin_function
specifier|static
name|void
name|ia64_add_gc_roots
parameter_list|()
block|{
name|ggc_add_rtx_root
argument_list|(
operator|&
name|ia64_compare_op0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ggc_add_rtx_root
argument_list|(
operator|&
name|ia64_compare_op1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ia64_init_machine_status
parameter_list|(
name|p
parameter_list|)
name|struct
name|function
modifier|*
name|p
decl_stmt|;
block|{
name|p
operator|->
name|machine
operator|=
operator|(
expr|struct
name|machine_function
operator|*
operator|)
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|machine_function
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ia64_mark_machine_status
parameter_list|(
name|p
parameter_list|)
name|struct
name|function
modifier|*
name|p
decl_stmt|;
block|{
name|struct
name|machine_function
modifier|*
name|machine
init|=
name|p
operator|->
name|machine
decl_stmt|;
if|if
condition|(
name|machine
condition|)
block|{
name|ggc_mark_rtx
argument_list|(
name|machine
operator|->
name|ia64_eh_epilogue_sp
argument_list|)
expr_stmt|;
name|ggc_mark_rtx
argument_list|(
name|machine
operator|->
name|ia64_eh_epilogue_bsp
argument_list|)
expr_stmt|;
name|ggc_mark_rtx
argument_list|(
name|machine
operator|->
name|ia64_gp_save
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ia64_free_machine_status
parameter_list|(
name|p
parameter_list|)
name|struct
name|function
modifier|*
name|p
decl_stmt|;
block|{
name|free
argument_list|(
name|p
operator|->
name|machine
argument_list|)
expr_stmt|;
name|p
operator|->
name|machine
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle TARGET_OPTIONS switches.  */
end_comment

begin_function
name|void
name|ia64_override_options
parameter_list|()
block|{
if|if
condition|(
name|TARGET_AUTO_PIC
condition|)
name|target_flags
operator||=
name|MASK_CONST_GP
expr_stmt|;
if|if
condition|(
name|TARGET_INLINE_DIV_LAT
operator|&&
name|TARGET_INLINE_DIV_THR
condition|)
block|{
name|warning
argument_list|(
literal|"cannot optimize division for both latency and throughput"
argument_list|)
expr_stmt|;
name|target_flags
operator|&=
operator|~
name|MASK_INLINE_DIV_THR
expr_stmt|;
block|}
if|if
condition|(
name|ia64_fixed_range_string
condition|)
name|fix_range
argument_list|(
name|ia64_fixed_range_string
argument_list|)
expr_stmt|;
name|ia64_flag_schedule_insns2
operator|=
name|flag_schedule_insns_after_reload
expr_stmt|;
name|flag_schedule_insns_after_reload
operator|=
literal|0
expr_stmt|;
name|ia64_section_threshold
operator|=
name|g_switch_set
condition|?
name|g_switch_value
else|:
name|IA64_DEFAULT_GVALUE
expr_stmt|;
name|init_machine_status
operator|=
name|ia64_init_machine_status
expr_stmt|;
name|mark_machine_status
operator|=
name|ia64_mark_machine_status
expr_stmt|;
name|free_machine_status
operator|=
name|ia64_free_machine_status
expr_stmt|;
name|ia64_add_gc_roots
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|enum
name|attr_itanium_requires_unit0
name|ia64_safe_itanium_requires_unit0
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|attr_itanium_class
name|ia64_safe_itanium_class
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|attr_type
name|ia64_safe_type
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|enum
name|attr_itanium_requires_unit0
name|ia64_safe_itanium_requires_unit0
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
if|if
condition|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|>=
literal|0
condition|)
return|return
name|get_attr_itanium_requires_unit0
argument_list|(
name|insn
argument_list|)
return|;
else|else
return|return
name|ITANIUM_REQUIRES_UNIT0_NO
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|attr_itanium_class
name|ia64_safe_itanium_class
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
if|if
condition|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|>=
literal|0
condition|)
return|return
name|get_attr_itanium_class
argument_list|(
name|insn
argument_list|)
return|;
else|else
return|return
name|ITANIUM_CLASS_UNKNOWN
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|attr_type
name|ia64_safe_type
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
if|if
condition|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|>=
literal|0
condition|)
return|return
name|get_attr_type
argument_list|(
name|insn
argument_list|)
return|;
else|else
return|return
name|TYPE_UNKNOWN
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The following collection of routines emit instruction group stop bits as    necessary to avoid dependencies.  */
end_comment

begin_comment
comment|/* Need to track some additional registers as far as serialization is    concerned so we can properly handle br.call and br.ret.  We could    make these registers visible to gcc, but since these registers are    never explicitly used in gcc generated code, it seems wasteful to    do so (plus it would make the call and return patterns needlessly    complex).  */
end_comment

begin_define
define|#
directive|define
name|REG_GP
value|(GR_REG (1))
end_define

begin_define
define|#
directive|define
name|REG_RP
value|(BR_REG (0))
end_define

begin_define
define|#
directive|define
name|REG_AR_CFM
value|(FIRST_PSEUDO_REGISTER + 1)
end_define

begin_comment
comment|/* This is used for volatile asms which may require a stop bit immediately    before and after them.  */
end_comment

begin_define
define|#
directive|define
name|REG_VOLATILE
value|(FIRST_PSEUDO_REGISTER + 2)
end_define

begin_define
define|#
directive|define
name|AR_UNAT_BIT_0
value|(FIRST_PSEUDO_REGISTER + 3)
end_define

begin_define
define|#
directive|define
name|NUM_REGS
value|(AR_UNAT_BIT_0 + 64)
end_define

begin_comment
comment|/* For each register, we keep track of how it has been written in the    current instruction group.     If a register is written unconditionally (no qualifying predicate),    WRITE_COUNT is set to 2 and FIRST_PRED is ignored.     If a register is written if its qualifying predicate P is true, we    set WRITE_COUNT to 1 and FIRST_PRED to P.  Later on, the same register    may be written again by the complement of P (P^1) and when this happens,    WRITE_COUNT gets set to 2.     The result of this is that whenever an insn attempts to write a register    whose WRITE_COUNT is two, we need to issue an insn group barrier first.     If a predicate register is written by a floating-point insn, we set    WRITTEN_BY_FP to true.     If a predicate register is written by an AND.ORCM we set WRITTEN_BY_AND    to true; if it was written by an OR.ANDCM we set WRITTEN_BY_OR to true.  */
end_comment

begin_struct
struct|struct
name|reg_write_state
block|{
name|unsigned
name|int
name|write_count
range|:
literal|2
decl_stmt|;
name|unsigned
name|int
name|first_pred
range|:
literal|16
decl_stmt|;
name|unsigned
name|int
name|written_by_fp
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|written_by_and
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|written_by_or
range|:
literal|1
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Cumulative info for the current instruction group.  */
end_comment

begin_decl_stmt
name|struct
name|reg_write_state
name|rws_sum
index|[
name|NUM_REGS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Info for the current instruction.  This gets copied to rws_sum after a    stop bit is emitted.  */
end_comment

begin_decl_stmt
name|struct
name|reg_write_state
name|rws_insn
index|[
name|NUM_REGS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indicates whether this is the first instruction after a stop bit,    in which case we don't need another stop bit.  Without this, we hit    the abort in ia64_variable_issue when scheduling an alloc.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|first_instruction
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Misc flags needed to compute RAW/WAW dependencies while we are traversing    RTL for one instruction.  */
end_comment

begin_struct
struct|struct
name|reg_flags
block|{
name|unsigned
name|int
name|is_write
range|:
literal|1
decl_stmt|;
comment|/* Is register being written?  */
name|unsigned
name|int
name|is_fp
range|:
literal|1
decl_stmt|;
comment|/* Is register used as part of an fp op?  */
name|unsigned
name|int
name|is_branch
range|:
literal|1
decl_stmt|;
comment|/* Is register used as part of a branch?  */
name|unsigned
name|int
name|is_and
range|:
literal|1
decl_stmt|;
comment|/* Is register used as part of and.orcm?  */
name|unsigned
name|int
name|is_or
range|:
literal|1
decl_stmt|;
comment|/* Is register used as part of or.andcm?  */
name|unsigned
name|int
name|is_sibcall
range|:
literal|1
decl_stmt|;
comment|/* Is this a sibling or normal call?  */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|void
name|rws_update
name|PARAMS
argument_list|(
operator|(
expr|struct
name|reg_write_state
operator|*
operator|,
name|int
operator|,
expr|struct
name|reg_flags
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rws_access_regno
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|reg_flags
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rws_access_reg
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
expr|struct
name|reg_flags
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|update_set_flags
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
expr|struct
name|reg_flags
operator|*
operator|,
name|int
operator|*
operator|,
name|rtx
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|set_src_needs_barrier
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
expr|struct
name|reg_flags
operator|,
name|int
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rtx_needs_barrier
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
expr|struct
name|reg_flags
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_insn_group_barriers
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|group_barrier_needed_p
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|safe_group_barrier_needed_p
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Update *RWS for REGNO, which is being written by the current instruction,    with predicate PRED, and associated register flags in FLAGS.  */
end_comment

begin_function
specifier|static
name|void
name|rws_update
parameter_list|(
name|rws
parameter_list|,
name|regno
parameter_list|,
name|flags
parameter_list|,
name|pred
parameter_list|)
name|struct
name|reg_write_state
modifier|*
name|rws
decl_stmt|;
name|int
name|regno
decl_stmt|;
name|struct
name|reg_flags
name|flags
decl_stmt|;
name|int
name|pred
decl_stmt|;
block|{
if|if
condition|(
name|pred
condition|)
name|rws
index|[
name|regno
index|]
operator|.
name|write_count
operator|++
expr_stmt|;
else|else
name|rws
index|[
name|regno
index|]
operator|.
name|write_count
operator|=
literal|2
expr_stmt|;
name|rws
index|[
name|regno
index|]
operator|.
name|written_by_fp
operator||=
name|flags
operator|.
name|is_fp
expr_stmt|;
comment|/* ??? Not tracking and/or across differing predicates.  */
name|rws
index|[
name|regno
index|]
operator|.
name|written_by_and
operator|=
name|flags
operator|.
name|is_and
expr_stmt|;
name|rws
index|[
name|regno
index|]
operator|.
name|written_by_or
operator|=
name|flags
operator|.
name|is_or
expr_stmt|;
name|rws
index|[
name|regno
index|]
operator|.
name|first_pred
operator|=
name|pred
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle an access to register REGNO of type FLAGS using predicate register    PRED.  Update rws_insn and rws_sum arrays.  Return 1 if this access creates    a dependency with an earlier instruction in the same group.  */
end_comment

begin_function
specifier|static
name|int
name|rws_access_regno
parameter_list|(
name|regno
parameter_list|,
name|flags
parameter_list|,
name|pred
parameter_list|)
name|int
name|regno
decl_stmt|;
name|struct
name|reg_flags
name|flags
decl_stmt|;
name|int
name|pred
decl_stmt|;
block|{
name|int
name|need_barrier
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|regno
operator|>=
name|NUM_REGS
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|PR_REGNO_P
argument_list|(
name|regno
argument_list|)
condition|)
name|flags
operator|.
name|is_and
operator|=
name|flags
operator|.
name|is_or
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flags
operator|.
name|is_write
condition|)
block|{
name|int
name|write_count
decl_stmt|;
comment|/* One insn writes same reg multiple times?  */
if|if
condition|(
name|rws_insn
index|[
name|regno
index|]
operator|.
name|write_count
operator|>
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Update info for current instruction.  */
name|rws_update
argument_list|(
name|rws_insn
argument_list|,
name|regno
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
name|write_count
operator|=
name|rws_sum
index|[
name|regno
index|]
operator|.
name|write_count
expr_stmt|;
switch|switch
condition|(
name|write_count
condition|)
block|{
case|case
literal|0
case|:
comment|/* The register has not been written yet.  */
name|rws_update
argument_list|(
name|rws_sum
argument_list|,
name|regno
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* The register has been written via a predicate.  If this is 	     not a complementary predicate, then we need a barrier.  */
comment|/* ??? This assumes that P and P+1 are always complementary 	     predicates for P even.  */
if|if
condition|(
name|flags
operator|.
name|is_and
operator|&&
name|rws_sum
index|[
name|regno
index|]
operator|.
name|written_by_and
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|.
name|is_or
operator|&&
name|rws_sum
index|[
name|regno
index|]
operator|.
name|written_by_or
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|(
name|rws_sum
index|[
name|regno
index|]
operator|.
name|first_pred
operator|^
literal|1
operator|)
operator|!=
name|pred
condition|)
name|need_barrier
operator|=
literal|1
expr_stmt|;
name|rws_update
argument_list|(
name|rws_sum
argument_list|,
name|regno
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* The register has been unconditionally written already.  We 	     need a barrier.  */
if|if
condition|(
name|flags
operator|.
name|is_and
operator|&&
name|rws_sum
index|[
name|regno
index|]
operator|.
name|written_by_and
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|.
name|is_or
operator|&&
name|rws_sum
index|[
name|regno
index|]
operator|.
name|written_by_or
condition|)
empty_stmt|;
else|else
name|need_barrier
operator|=
literal|1
expr_stmt|;
name|rws_sum
index|[
name|regno
index|]
operator|.
name|written_by_and
operator|=
name|flags
operator|.
name|is_and
expr_stmt|;
name|rws_sum
index|[
name|regno
index|]
operator|.
name|written_by_or
operator|=
name|flags
operator|.
name|is_or
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|flags
operator|.
name|is_branch
condition|)
block|{
comment|/* Branches have several RAW exceptions that allow to avoid 	     barriers.  */
if|if
condition|(
name|REGNO_REG_CLASS
argument_list|(
name|regno
argument_list|)
operator|==
name|BR_REGS
operator|||
name|regno
operator|==
name|AR_PFS_REGNUM
condition|)
comment|/* RAW dependencies on branch regs are permissible as long 	       as the writer is a non-branch instruction.  Since we 	       never generate code that uses a branch register written 	       by a branch instruction, handling this case is 	       easy.  */
return|return
literal|0
return|;
if|if
condition|(
name|REGNO_REG_CLASS
argument_list|(
name|regno
argument_list|)
operator|==
name|PR_REGS
operator|&&
operator|!
name|rws_sum
index|[
name|regno
index|]
operator|.
name|written_by_fp
condition|)
comment|/* The predicates of a branch are available within the 	       same insn group as long as the predicate was written by 	       something other than a floating-point instruction.  */
return|return
literal|0
return|;
block|}
if|if
condition|(
name|flags
operator|.
name|is_and
operator|&&
name|rws_sum
index|[
name|regno
index|]
operator|.
name|written_by_and
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|flags
operator|.
name|is_or
operator|&&
name|rws_sum
index|[
name|regno
index|]
operator|.
name|written_by_or
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|rws_sum
index|[
name|regno
index|]
operator|.
name|write_count
condition|)
block|{
case|case
literal|0
case|:
comment|/* The register has not been written yet.  */
break|break;
case|case
literal|1
case|:
comment|/* The register has been written via a predicate.  If this is 	     not a complementary predicate, then we need a barrier.  */
comment|/* ??? This assumes that P and P+1 are always complementary 	     predicates for P even.  */
if|if
condition|(
operator|(
name|rws_sum
index|[
name|regno
index|]
operator|.
name|first_pred
operator|^
literal|1
operator|)
operator|!=
name|pred
condition|)
name|need_barrier
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* The register has been unconditionally written already.  We 	     need a barrier.  */
name|need_barrier
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|need_barrier
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|rws_access_reg
parameter_list|(
name|reg
parameter_list|,
name|flags
parameter_list|,
name|pred
parameter_list|)
name|rtx
name|reg
decl_stmt|;
name|struct
name|reg_flags
name|flags
decl_stmt|;
name|int
name|pred
decl_stmt|;
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|reg
argument_list|)
decl_stmt|;
name|int
name|n
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|==
literal|1
condition|)
return|return
name|rws_access_regno
argument_list|(
name|regno
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
return|;
else|else
block|{
name|int
name|need_barrier
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
name|need_barrier
operator||=
name|rws_access_regno
argument_list|(
name|regno
operator|+
name|n
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
return|return
name|need_barrier
return|;
block|}
block|}
end_function

begin_comment
comment|/* Examine X, which is a SET rtx, and update the flags, the predicate, and    the condition, stored in *PFLAGS, *PPRED and *PCOND.  */
end_comment

begin_function
specifier|static
name|void
name|update_set_flags
parameter_list|(
name|x
parameter_list|,
name|pflags
parameter_list|,
name|ppred
parameter_list|,
name|pcond
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|struct
name|reg_flags
modifier|*
name|pflags
decl_stmt|;
name|int
modifier|*
name|ppred
decl_stmt|;
name|rtx
modifier|*
name|pcond
decl_stmt|;
block|{
name|rtx
name|src
init|=
name|SET_SRC
argument_list|(
name|x
argument_list|)
decl_stmt|;
operator|*
name|pcond
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
condition|)
block|{
case|case
name|CALL
case|:
return|return;
case|case
name|IF_THEN_ELSE
case|:
if|if
condition|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|==
name|pc_rtx
condition|)
comment|/* X is a conditional branch.  */
return|return;
else|else
block|{
name|int
name|is_complemented
init|=
literal|0
decl_stmt|;
comment|/* X is a conditional move.  */
name|rtx
name|cond
init|=
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|EQ
condition|)
name|is_complemented
operator|=
literal|1
expr_stmt|;
name|cond
operator|=
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|cond
argument_list|)
operator|!=
name|REG
operator|&&
name|REGNO_REG_CLASS
argument_list|(
name|REGNO
argument_list|(
name|cond
argument_list|)
argument_list|)
operator|!=
name|PR_REGS
condition|)
name|abort
argument_list|()
expr_stmt|;
operator|*
name|pcond
operator|=
name|cond
expr_stmt|;
if|if
condition|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
operator|==
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|||
name|XEXP
argument_list|(
name|src
argument_list|,
literal|2
argument_list|)
operator|==
name|SET_DEST
argument_list|(
name|x
argument_list|)
condition|)
block|{
comment|/* X is a conditional move that conditionally writes the 		 destination.  */
comment|/* We need another complement in this case.  */
if|if
condition|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
operator|==
name|SET_DEST
argument_list|(
name|x
argument_list|)
condition|)
name|is_complemented
operator|=
operator|!
name|is_complemented
expr_stmt|;
operator|*
name|ppred
operator|=
name|REGNO
argument_list|(
name|cond
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_complemented
condition|)
operator|++
operator|*
name|ppred
expr_stmt|;
block|}
comment|/* ??? If this is a conditional write to the dest, then this 	     instruction does not actually read one source.  This probably 	     doesn't matter, because that source is also the dest.  */
comment|/* ??? Multiple writes to predicate registers are allowed 	     if they are all AND type compares, or if they are all OR 	     type compares.  We do not generate such instructions 	     currently.  */
block|}
comment|/* ... fall through ...  */
default|default:
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
argument_list|)
operator|==
literal|'<'
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
comment|/* Set pflags->is_fp to 1 so that we know we're dealing 	   with a floating point comparison when processing the 	   destination of the SET.  */
name|pflags
operator|->
name|is_fp
operator|=
literal|1
expr_stmt|;
comment|/* Discover if this is a parallel comparison.  We only handle 	 and.orcm and or.andcm at present, since we must retain a 	 strict inverse on the predicate pair.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|AND
condition|)
name|pflags
operator|->
name|is_and
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|IOR
condition|)
name|pflags
operator|->
name|is_or
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Subroutine of rtx_needs_barrier; this function determines whether the    source of a given SET rtx found in X needs a barrier.  FLAGS and PRED    are as in rtx_needs_barrier.  COND is an rtx that holds the condition    for this insn.  */
end_comment

begin_function
specifier|static
name|int
name|set_src_needs_barrier
parameter_list|(
name|x
parameter_list|,
name|flags
parameter_list|,
name|pred
parameter_list|,
name|cond
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|struct
name|reg_flags
name|flags
decl_stmt|;
name|int
name|pred
decl_stmt|;
name|rtx
name|cond
decl_stmt|;
block|{
name|int
name|need_barrier
init|=
literal|0
decl_stmt|;
name|rtx
name|dst
decl_stmt|;
name|rtx
name|src
init|=
name|SET_SRC
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|CALL
condition|)
comment|/* We don't need to worry about the result registers that        get written by subroutine call.  */
return|return
name|rtx_needs_barrier
argument_list|(
name|src
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
return|;
elseif|else
if|if
condition|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|==
name|pc_rtx
condition|)
block|{
comment|/* X is a conditional branch.  */
comment|/* ??? This seems redundant, as the caller sets this bit for 	 all JUMP_INSNs.  */
name|flags
operator|.
name|is_branch
operator|=
literal|1
expr_stmt|;
return|return
name|rtx_needs_barrier
argument_list|(
name|src
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
return|;
block|}
name|need_barrier
operator|=
name|rtx_needs_barrier
argument_list|(
name|src
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
comment|/* This instruction unconditionally uses a predicate register.  */
if|if
condition|(
name|cond
condition|)
name|need_barrier
operator||=
name|rws_access_reg
argument_list|(
name|cond
argument_list|,
name|flags
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dst
operator|=
name|SET_DEST
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|==
name|ZERO_EXTRACT
condition|)
block|{
name|need_barrier
operator||=
name|rtx_needs_barrier
argument_list|(
name|XEXP
argument_list|(
name|dst
argument_list|,
literal|1
argument_list|)
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
name|need_barrier
operator||=
name|rtx_needs_barrier
argument_list|(
name|XEXP
argument_list|(
name|dst
argument_list|,
literal|2
argument_list|)
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
name|dst
operator|=
name|XEXP
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|need_barrier
return|;
block|}
end_function

begin_comment
comment|/* Handle an access to rtx X of type FLAGS using predicate register PRED.    Return 1 is this access creates a dependency with an earlier instruction    in the same group.  */
end_comment

begin_function
specifier|static
name|int
name|rtx_needs_barrier
parameter_list|(
name|x
parameter_list|,
name|flags
parameter_list|,
name|pred
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|struct
name|reg_flags
name|flags
decl_stmt|;
name|int
name|pred
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|is_complemented
init|=
literal|0
decl_stmt|;
name|int
name|need_barrier
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|format_ptr
decl_stmt|;
name|struct
name|reg_flags
name|new_flags
decl_stmt|;
name|rtx
name|cond
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|x
condition|)
return|return
literal|0
return|;
name|new_flags
operator|=
name|flags
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|SET
case|:
name|update_set_flags
argument_list|(
name|x
argument_list|,
operator|&
name|new_flags
argument_list|,
operator|&
name|pred
argument_list|,
operator|&
name|cond
argument_list|)
expr_stmt|;
name|need_barrier
operator|=
name|set_src_needs_barrier
argument_list|(
name|x
argument_list|,
name|new_flags
argument_list|,
name|pred
argument_list|,
name|cond
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|CALL
condition|)
block|{
name|new_flags
operator|.
name|is_write
operator|=
literal|1
expr_stmt|;
name|need_barrier
operator||=
name|rtx_needs_barrier
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|new_flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CALL
case|:
name|new_flags
operator|.
name|is_write
operator|=
literal|0
expr_stmt|;
name|need_barrier
operator||=
name|rws_access_regno
argument_list|(
name|AR_EC_REGNUM
argument_list|,
name|new_flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
comment|/* Avoid multiple register writes, in case this is a pattern with 	 multiple CALL rtx.  This avoids an abort in rws_access_reg.  */
if|if
condition|(
operator|!
name|flags
operator|.
name|is_sibcall
operator|&&
operator|!
name|rws_insn
index|[
name|REG_AR_CFM
index|]
operator|.
name|write_count
condition|)
block|{
name|new_flags
operator|.
name|is_write
operator|=
literal|1
expr_stmt|;
name|need_barrier
operator||=
name|rws_access_regno
argument_list|(
name|REG_RP
argument_list|,
name|new_flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
name|need_barrier
operator||=
name|rws_access_regno
argument_list|(
name|AR_PFS_REGNUM
argument_list|,
name|new_flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
name|need_barrier
operator||=
name|rws_access_regno
argument_list|(
name|REG_AR_CFM
argument_list|,
name|new_flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|COND_EXEC
case|:
comment|/* X is a predicated instruction.  */
name|cond
operator|=
name|COND_EXEC_TEST
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|pred
condition|)
name|abort
argument_list|()
expr_stmt|;
name|need_barrier
operator|=
name|rtx_needs_barrier
argument_list|(
name|cond
argument_list|,
name|flags
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|EQ
condition|)
name|is_complemented
operator|=
literal|1
expr_stmt|;
name|cond
operator|=
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|cond
argument_list|)
operator|!=
name|REG
operator|&&
name|REGNO_REG_CLASS
argument_list|(
name|REGNO
argument_list|(
name|cond
argument_list|)
argument_list|)
operator|!=
name|PR_REGS
condition|)
name|abort
argument_list|()
expr_stmt|;
name|pred
operator|=
name|REGNO
argument_list|(
name|cond
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_complemented
condition|)
operator|++
name|pred
expr_stmt|;
name|need_barrier
operator||=
name|rtx_needs_barrier
argument_list|(
name|COND_EXEC_CODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
return|return
name|need_barrier
return|;
case|case
name|CLOBBER
case|:
case|case
name|USE
case|:
comment|/* Clobber& use are for earlier compiler-phases only.  */
break|break;
case|case
name|ASM_OPERANDS
case|:
case|case
name|ASM_INPUT
case|:
comment|/* We always emit stop bits for traditional asms.  We emit stop bits 	 for volatile extended asms if TARGET_VOL_ASM_STOP is true.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|ASM_OPERANDS
operator|||
operator|(
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
operator|&&
name|TARGET_VOL_ASM_STOP
operator|)
condition|)
block|{
comment|/* Avoid writing the register multiple times if we have multiple 	     asm outputs.  This avoids an abort in rws_access_reg.  */
if|if
condition|(
operator|!
name|rws_insn
index|[
name|REG_VOLATILE
index|]
operator|.
name|write_count
condition|)
block|{
name|new_flags
operator|.
name|is_write
operator|=
literal|1
expr_stmt|;
name|rws_access_regno
argument_list|(
name|REG_VOLATILE
argument_list|,
name|new_flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
comment|/* For all ASM_OPERANDS, we must traverse the vector of input operands. 	 We can not just fall through here since then we would be confused 	 by the ASM_INPUT rtx inside ASM_OPERANDS, which do not indicate 	 traditional asms unlike their normal usage.  */
for|for
control|(
name|i
operator|=
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|x
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
if|if
condition|(
name|rtx_needs_barrier
argument_list|(
name|ASM_OPERANDS_INPUT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
condition|)
name|need_barrier
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|PARALLEL
case|:
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|rtx
name|pat
init|=
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SET
condition|)
block|{
name|update_set_flags
argument_list|(
name|pat
argument_list|,
operator|&
name|new_flags
argument_list|,
operator|&
name|pred
argument_list|,
operator|&
name|cond
argument_list|)
expr_stmt|;
name|need_barrier
operator||=
name|set_src_needs_barrier
argument_list|(
name|pat
argument_list|,
name|new_flags
argument_list|,
name|pred
argument_list|,
name|cond
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|CALL
operator|||
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|ASM_OPERANDS
condition|)
name|need_barrier
operator||=
name|rtx_needs_barrier
argument_list|(
name|pat
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|!=
name|CLOBBER
operator|&&
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|!=
name|RETURN
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|rtx
name|pat
init|=
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SET
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|!=
name|CALL
condition|)
block|{
name|new_flags
operator|.
name|is_write
operator|=
literal|1
expr_stmt|;
name|need_barrier
operator||=
name|rtx_needs_barrier
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|,
name|new_flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|CLOBBER
operator|||
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|RETURN
condition|)
name|need_barrier
operator||=
name|rtx_needs_barrier
argument_list|(
name|pat
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SUBREG
case|:
name|x
operator|=
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* FALLTHRU */
case|case
name|REG
case|:
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|==
name|AR_UNAT_REGNUM
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
operator|++
name|i
control|)
name|need_barrier
operator||=
name|rws_access_regno
argument_list|(
name|AR_UNAT_BIT_0
operator|+
name|i
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
block|}
else|else
name|need_barrier
operator|=
name|rws_access_reg
argument_list|(
name|x
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEM
case|:
comment|/* Find the regs used in memory address computation.  */
name|new_flags
operator|.
name|is_write
operator|=
literal|0
expr_stmt|;
name|need_barrier
operator|=
name|rtx_needs_barrier
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|new_flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|CONST
case|:
break|break;
comment|/* Operators with side-effects.  */
case|case
name|POST_INC
case|:
case|case
name|POST_DEC
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
name|abort
argument_list|()
expr_stmt|;
name|new_flags
operator|.
name|is_write
operator|=
literal|0
expr_stmt|;
name|need_barrier
operator|=
name|rws_access_reg
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|new_flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
name|new_flags
operator|.
name|is_write
operator|=
literal|1
expr_stmt|;
name|need_barrier
operator||=
name|rws_access_reg
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|new_flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
break|break;
case|case
name|POST_MODIFY
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
name|abort
argument_list|()
expr_stmt|;
name|new_flags
operator|.
name|is_write
operator|=
literal|0
expr_stmt|;
name|need_barrier
operator|=
name|rws_access_reg
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|new_flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
name|need_barrier
operator||=
name|rtx_needs_barrier
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|new_flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
name|new_flags
operator|.
name|is_write
operator|=
literal|1
expr_stmt|;
name|need_barrier
operator||=
name|rws_access_reg
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|new_flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
break|break;
comment|/* Handle common unary and binary ops for efficiency.  */
case|case
name|COMPARE
case|:
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
case|case
name|MULT
case|:
case|case
name|DIV
case|:
case|case
name|MOD
case|:
case|case
name|UDIV
case|:
case|case
name|UMOD
case|:
case|case
name|AND
case|:
case|case
name|IOR
case|:
case|case
name|XOR
case|:
case|case
name|ASHIFT
case|:
case|case
name|ROTATE
case|:
case|case
name|ASHIFTRT
case|:
case|case
name|LSHIFTRT
case|:
case|case
name|ROTATERT
case|:
case|case
name|SMIN
case|:
case|case
name|SMAX
case|:
case|case
name|UMIN
case|:
case|case
name|UMAX
case|:
case|case
name|NE
case|:
case|case
name|EQ
case|:
case|case
name|GE
case|:
case|case
name|GT
case|:
case|case
name|LE
case|:
case|case
name|LT
case|:
case|case
name|GEU
case|:
case|case
name|GTU
case|:
case|case
name|LEU
case|:
case|case
name|LTU
case|:
name|need_barrier
operator|=
name|rtx_needs_barrier
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|new_flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
name|need_barrier
operator||=
name|rtx_needs_barrier
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|new_flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
break|break;
case|case
name|NEG
case|:
case|case
name|NOT
case|:
case|case
name|SIGN_EXTEND
case|:
case|case
name|ZERO_EXTEND
case|:
case|case
name|TRUNCATE
case|:
case|case
name|FLOAT_EXTEND
case|:
case|case
name|FLOAT_TRUNCATE
case|:
case|case
name|FLOAT
case|:
case|case
name|FIX
case|:
case|case
name|UNSIGNED_FLOAT
case|:
case|case
name|UNSIGNED_FIX
case|:
case|case
name|ABS
case|:
case|case
name|SQRT
case|:
case|case
name|FFS
case|:
name|need_barrier
operator|=
name|rtx_needs_barrier
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSPEC
case|:
switch|switch
condition|(
name|XINT
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
comment|/* st8.spill */
case|case
literal|2
case|:
comment|/* ld8.fill */
block|{
name|HOST_WIDE_INT
name|offset
init|=
name|INTVAL
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|bit
init|=
operator|(
name|offset
operator|>>
literal|3
operator|)
operator|&
literal|63
decl_stmt|;
name|need_barrier
operator|=
name|rtx_needs_barrier
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
name|new_flags
operator|.
name|is_write
operator|=
operator|(
name|XINT
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|==
literal|1
operator|)
expr_stmt|;
name|need_barrier
operator||=
name|rws_access_regno
argument_list|(
name|AR_UNAT_BIT_0
operator|+
name|bit
argument_list|,
name|new_flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|3
case|:
comment|/* stf.spill */
case|case
literal|4
case|:
comment|/* ldf.spill */
case|case
literal|8
case|:
comment|/* popcnt */
name|need_barrier
operator|=
name|rtx_needs_barrier
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
break|break;
case|case
literal|7
case|:
comment|/* pred_rel_mutex */
case|case
literal|9
case|:
comment|/* pic call */
case|case
literal|12
case|:
comment|/* mf */
case|case
literal|19
case|:
comment|/* fetchadd_acq */
case|case
literal|20
case|:
comment|/* mov = ar.bsp */
case|case
literal|21
case|:
comment|/* flushrs */
case|case
literal|22
case|:
comment|/* bundle selector */
case|case
literal|23
case|:
comment|/* cycle display */
break|break;
case|case
literal|24
case|:
comment|/* addp4 */
name|need_barrier
operator|=
name|rtx_needs_barrier
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
comment|/* recip_approx */
name|need_barrier
operator|=
name|rtx_needs_barrier
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
name|need_barrier
operator||=
name|rtx_needs_barrier
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
break|break;
case|case
literal|13
case|:
comment|/* cmpxchg_acq */
name|need_barrier
operator|=
name|rtx_needs_barrier
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
name|need_barrier
operator||=
name|rtx_needs_barrier
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|UNSPEC_VOLATILE
case|:
switch|switch
condition|(
name|XINT
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
comment|/* alloc */
comment|/* Alloc must always be the first instruction of a group. 	     We force this by always returning true.  */
comment|/* ??? We might get better scheduling if we explicitly check for 	     input/local/output register dependencies, and modify the 	     scheduler so that alloc is always reordered to the start of 	     the current group.  We could then eliminate all of the 	     first_instruction code.  */
name|rws_access_regno
argument_list|(
name|AR_PFS_REGNUM
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
name|new_flags
operator|.
name|is_write
operator|=
literal|1
expr_stmt|;
name|rws_access_regno
argument_list|(
name|REG_AR_CFM
argument_list|,
name|new_flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
literal|1
case|:
comment|/* blockage */
case|case
literal|2
case|:
comment|/* insn group barrier */
return|return
literal|0
return|;
case|case
literal|5
case|:
comment|/* set_bsp  */
name|need_barrier
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|7
case|:
comment|/* pred.rel.mutex */
case|case
literal|8
case|:
comment|/* safe_across_calls all */
case|case
literal|9
case|:
comment|/* safe_across_calls normal */
return|return
literal|0
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|RETURN
case|:
name|new_flags
operator|.
name|is_write
operator|=
literal|0
expr_stmt|;
name|need_barrier
operator|=
name|rws_access_regno
argument_list|(
name|REG_RP
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
name|need_barrier
operator||=
name|rws_access_regno
argument_list|(
name|AR_PFS_REGNUM
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
name|new_flags
operator|.
name|is_write
operator|=
literal|1
expr_stmt|;
name|need_barrier
operator||=
name|rws_access_regno
argument_list|(
name|AR_EC_REGNUM
argument_list|,
name|new_flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
name|need_barrier
operator||=
name|rws_access_regno
argument_list|(
name|REG_AR_CFM
argument_list|,
name|new_flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
break|break;
default|default:
name|format_ptr
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
switch|switch
condition|(
name|format_ptr
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'0'
case|:
comment|/* unused field */
case|case
literal|'i'
case|:
comment|/* integer */
case|case
literal|'n'
case|:
comment|/* note */
case|case
literal|'w'
case|:
comment|/* wide integer */
case|case
literal|'s'
case|:
comment|/* pointer to string */
case|case
literal|'S'
case|:
comment|/* optional pointer to string */
break|break;
case|case
literal|'e'
case|:
if|if
condition|(
name|rtx_needs_barrier
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
condition|)
name|need_barrier
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
operator|--
name|j
control|)
if|if
condition|(
name|rtx_needs_barrier
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
condition|)
name|need_barrier
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
block|}
return|return
name|need_barrier
return|;
block|}
end_function

begin_comment
comment|/* Clear out the state for group_barrier_needed_p at the start of a    sequence of insns.  */
end_comment

begin_function
specifier|static
name|void
name|init_insn_group_barriers
parameter_list|()
block|{
name|memset
argument_list|(
name|rws_sum
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|rws_sum
argument_list|)
argument_list|)
expr_stmt|;
name|first_instruction
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given the current state, recorded by previous calls to this function,    determine whether a group barrier (a stop bit) is necessary before INSN.    Return nonzero if so.  */
end_comment

begin_function
specifier|static
name|int
name|group_barrier_needed_p
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|pat
decl_stmt|;
name|int
name|need_barrier
init|=
literal|0
decl_stmt|;
name|struct
name|reg_flags
name|flags
decl_stmt|;
name|memset
argument_list|(
operator|&
name|flags
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|flags
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|NOTE
case|:
break|break;
case|case
name|BARRIER
case|:
comment|/* A barrier doesn't imply an instruction group boundary.  */
break|break;
case|case
name|CODE_LABEL
case|:
name|memset
argument_list|(
name|rws_insn
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|rws_insn
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|CALL_INSN
case|:
name|flags
operator|.
name|is_branch
operator|=
literal|1
expr_stmt|;
name|flags
operator|.
name|is_sibcall
operator|=
name|SIBLING_CALL_P
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|rws_insn
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|rws_insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Don't bundle a call following another call.  */
if|if
condition|(
operator|(
name|pat
operator|=
name|prev_active_insn
argument_list|(
name|insn
argument_list|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|need_barrier
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|need_barrier
operator|=
name|rtx_needs_barrier
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|flags
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|JUMP_INSN
case|:
name|flags
operator|.
name|is_branch
operator|=
literal|1
expr_stmt|;
comment|/* Don't bundle a jump following a call.  */
if|if
condition|(
operator|(
name|pat
operator|=
name|prev_active_insn
argument_list|(
name|insn
argument_list|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|need_barrier
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* FALLTHRU */
case|case
name|INSN
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
comment|/* Don't care about USE and CLOBBER "insns"---those are used to 	   indicate to the optimizer that it shouldn't get rid of 	   certain operations.  */
break|break;
name|pat
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Ug.  Hack hacks hacked elsewhere.  */
switch|switch
condition|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
condition|)
block|{
comment|/* We play dependency tricks with the epilogue in order 	     to get proper schedules.  Undo this for dv analysis.  */
case|case
name|CODE_FOR_epilogue_deallocate_stack
case|:
name|pat
operator|=
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
comment|/* The pattern we use for br.cloop confuses the code above. 	     The second element of the vector is representative.  */
case|case
name|CODE_FOR_doloop_end_internal
case|:
name|pat
operator|=
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
comment|/* Doesn't generate code.  */
case|case
name|CODE_FOR_pred_rel_mutex
case|:
case|case
name|CODE_FOR_prologue_use
case|:
return|return
literal|0
return|;
default|default:
break|break;
block|}
name|memset
argument_list|(
name|rws_insn
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|rws_insn
argument_list|)
argument_list|)
expr_stmt|;
name|need_barrier
operator|=
name|rtx_needs_barrier
argument_list|(
name|pat
argument_list|,
name|flags
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Check to see if the previous instruction was a volatile 	 asm.  */
if|if
condition|(
operator|!
name|need_barrier
condition|)
name|need_barrier
operator|=
name|rws_access_regno
argument_list|(
name|REG_VOLATILE
argument_list|,
name|flags
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|first_instruction
condition|)
block|{
name|need_barrier
operator|=
literal|0
expr_stmt|;
name|first_instruction
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|need_barrier
return|;
block|}
end_function

begin_comment
comment|/* Like group_barrier_needed_p, but do not clobber the current state.  */
end_comment

begin_function
specifier|static
name|int
name|safe_group_barrier_needed_p
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|struct
name|reg_write_state
name|rws_saved
index|[
name|NUM_REGS
index|]
decl_stmt|;
name|int
name|saved_first_instruction
decl_stmt|;
name|int
name|t
decl_stmt|;
name|memcpy
argument_list|(
name|rws_saved
argument_list|,
name|rws_sum
argument_list|,
name|NUM_REGS
operator|*
sizeof|sizeof
expr|*
name|rws_saved
argument_list|)
expr_stmt|;
name|saved_first_instruction
operator|=
name|first_instruction
expr_stmt|;
name|t
operator|=
name|group_barrier_needed_p
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|rws_sum
argument_list|,
name|rws_saved
argument_list|,
name|NUM_REGS
operator|*
sizeof|sizeof
expr|*
name|rws_saved
argument_list|)
expr_stmt|;
name|first_instruction
operator|=
name|saved_first_instruction
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* INSNS is an chain of instructions.  Scan the chain, and insert stop bits    as necessary to eliminate dependendencies.  This function assumes that    a final instruction scheduling pass has been run which has already    inserted most of the necessary stop bits.  This function only inserts    new ones at basic block boundaries, since these are invisible to the    scheduler.  */
end_comment

begin_function
specifier|static
name|void
name|emit_insn_group_barriers
parameter_list|(
name|dump
parameter_list|,
name|insns
parameter_list|)
name|FILE
modifier|*
name|dump
decl_stmt|;
name|rtx
name|insns
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
name|rtx
name|last_label
init|=
literal|0
decl_stmt|;
name|int
name|insns_since_last_label
init|=
literal|0
decl_stmt|;
name|init_insn_group_barriers
argument_list|()
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|insns
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
block|{
if|if
condition|(
name|insns_since_last_label
condition|)
name|last_label
operator|=
name|insn
expr_stmt|;
name|insns_since_last_label
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_BASIC_BLOCK
condition|)
block|{
if|if
condition|(
name|insns_since_last_label
condition|)
name|last_label
operator|=
name|insn
expr_stmt|;
name|insns_since_last_label
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|UNSPEC_VOLATILE
operator|&&
name|XINT
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
literal|2
condition|)
block|{
name|init_insn_group_barriers
argument_list|()
expr_stmt|;
name|last_label
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|insns_since_last_label
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|group_barrier_needed_p
argument_list|(
name|insn
argument_list|)
condition|)
block|{
if|if
condition|(
name|last_label
condition|)
block|{
if|if
condition|(
name|dump
condition|)
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"Emitting stop before label %d\n"
argument_list|,
name|INSN_UID
argument_list|(
name|last_label
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn_before
argument_list|(
name|gen_insn_group_barrier
argument_list|(
name|GEN_INT
argument_list|(
literal|3
argument_list|)
argument_list|)
argument_list|,
name|last_label
argument_list|)
expr_stmt|;
name|insn
operator|=
name|last_label
expr_stmt|;
name|init_insn_group_barriers
argument_list|()
expr_stmt|;
name|last_label
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Like emit_insn_group_barriers, but run if no final scheduling pass was run.    This function has to emit all necessary group barriers.  */
end_comment

begin_function
specifier|static
name|void
name|emit_all_insn_group_barriers
parameter_list|(
name|dump
parameter_list|,
name|insns
parameter_list|)
name|FILE
modifier|*
name|dump
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|rtx
name|insns
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
name|init_insn_group_barriers
argument_list|()
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|insns
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|BARRIER
condition|)
block|{
name|rtx
name|last
init|=
name|prev_active_insn
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|last
condition|)
continue|continue;
if|if
condition|(
name|GET_CODE
argument_list|(
name|last
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|last
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
condition|)
name|last
operator|=
name|prev_active_insn
argument_list|(
name|last
argument_list|)
expr_stmt|;
if|if
condition|(
name|recog_memoized
argument_list|(
name|last
argument_list|)
operator|!=
name|CODE_FOR_insn_group_barrier
condition|)
name|emit_insn_after
argument_list|(
name|gen_insn_group_barrier
argument_list|(
name|GEN_INT
argument_list|(
literal|3
argument_list|)
argument_list|)
argument_list|,
name|last
argument_list|)
expr_stmt|;
name|init_insn_group_barriers
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
if|if
condition|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_FOR_insn_group_barrier
condition|)
name|init_insn_group_barriers
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|group_barrier_needed_p
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|emit_insn_before
argument_list|(
name|gen_insn_group_barrier
argument_list|(
name|GEN_INT
argument_list|(
literal|3
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|init_insn_group_barriers
argument_list|()
expr_stmt|;
name|group_barrier_needed_p
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|int
name|errata_find_address_regs
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|errata_emit_nops
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fixup_errata
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This structure is used to track some details about the previous insns    groups so we can determine if it may be necessary to insert NOPs to    workaround hardware errata.  */
end_comment

begin_struct
specifier|static
struct|struct
name|group
block|{
name|HARD_REG_SET
name|p_reg_set
decl_stmt|;
name|HARD_REG_SET
name|gr_reg_conditionally_set
decl_stmt|;
block|}
name|last_group
index|[
literal|2
index|]
struct|;
end_struct

begin_comment
comment|/* Index into the last_group array.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|group_idx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Called through for_each_rtx; determines if a hard register that was    conditionally set in the previous group is used as an address register.    It ensures that for_each_rtx returns 1 in that case.  */
end_comment

begin_function
specifier|static
name|int
name|errata_find_address_regs
parameter_list|(
name|xp
parameter_list|,
name|data
parameter_list|)
name|rtx
modifier|*
name|xp
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|rtx
name|x
init|=
operator|*
name|xp
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM
condition|)
return|return
literal|0
return|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|POST_MODIFY
condition|)
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
block|{
name|struct
name|group
modifier|*
name|prev_group
init|=
name|last_group
operator|+
operator|(
name|group_idx
operator|^
literal|1
operator|)
decl_stmt|;
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|prev_group
operator|->
name|gr_reg_conditionally_set
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Called for each insn; this function keeps track of the state in    last_group and emits additional NOPs if necessary to work around    an Itanium A/B step erratum.  */
end_comment

begin_function
specifier|static
name|void
name|errata_emit_nops
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|struct
name|group
modifier|*
name|this_group
init|=
name|last_group
operator|+
name|group_idx
decl_stmt|;
name|struct
name|group
modifier|*
name|prev_group
init|=
name|last_group
operator|+
operator|(
name|group_idx
operator|^
literal|1
operator|)
decl_stmt|;
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|cond
init|=
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|COND_EXEC
condition|?
name|COND_EXEC_TEST
argument_list|(
name|pat
argument_list|)
else|:
literal|0
decl_stmt|;
name|rtx
name|real_pat
init|=
name|cond
condition|?
name|COND_EXEC_CODE
argument_list|(
name|pat
argument_list|)
else|:
name|pat
decl_stmt|;
name|enum
name|attr_type
name|type
decl_stmt|;
name|rtx
name|set
init|=
name|real_pat
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|real_pat
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|real_pat
argument_list|)
operator|==
name|CLOBBER
operator|||
name|GET_CODE
argument_list|(
name|real_pat
argument_list|)
operator|==
name|ASM_INPUT
operator|||
name|GET_CODE
argument_list|(
name|real_pat
argument_list|)
operator|==
name|ADDR_VEC
operator|||
name|GET_CODE
argument_list|(
name|real_pat
argument_list|)
operator|==
name|ADDR_DIFF_VEC
operator|||
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
return|return;
comment|/* single_set doesn't work for COND_EXEC insns, so we have to duplicate      parts of it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|set
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|i
decl_stmt|;
name|set
operator|=
name|XVECEXP
argument_list|(
name|real_pat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|real_pat
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|real_pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|!=
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|real_pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|!=
name|CLOBBER
condition|)
block|{
name|set
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|set
operator|&&
name|GET_CODE
argument_list|(
name|set
argument_list|)
operator|!=
name|SET
condition|)
name|set
operator|=
literal|0
expr_stmt|;
name|type
operator|=
name|get_attr_type
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|TYPE_F
operator|&&
name|set
operator|&&
name|REG_P
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|&&
name|PR_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|)
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|this_group
operator|->
name|p_reg_set
argument_list|,
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|==
name|TYPE_M
operator|||
name|type
operator|==
name|TYPE_A
operator|)
operator|&&
name|cond
operator|&&
name|set
operator|&&
name|REG_P
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|!=
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|!=
name|MINUS
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|!=
name|ASHIFT
operator|||
operator|!
name|shladd_operand
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|VOIDmode
argument_list|)
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|!=
name|MEM
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|POST_MODIFY
operator|)
operator|&&
name|GENERAL_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|cond
argument_list|)
argument_list|)
operator|!=
literal|'<'
operator|||
operator|!
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|prev_group
operator|->
name|p_reg_set
argument_list|,
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|this_group
operator|->
name|gr_reg_conditionally_set
argument_list|,
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|for_each_rtx
argument_list|(
operator|&
name|real_pat
argument_list|,
name|errata_find_address_regs
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|emit_insn_before
argument_list|(
name|gen_insn_group_barrier
argument_list|(
name|GEN_INT
argument_list|(
literal|3
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|emit_insn_before
argument_list|(
name|gen_nop
argument_list|()
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|emit_insn_before
argument_list|(
name|gen_insn_group_barrier
argument_list|(
name|GEN_INT
argument_list|(
literal|3
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|group_idx
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|last_group
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|last_group
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Emit extra nops if they are required to work around hardware errata.  */
end_comment

begin_function
specifier|static
name|void
name|fixup_errata
parameter_list|()
block|{
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
operator|!
name|TARGET_B_STEP
condition|)
return|return;
name|group_idx
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|last_group
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|last_group
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|ia64_safe_type
argument_list|(
name|insn
argument_list|)
operator|==
name|TYPE_S
condition|)
block|{
name|group_idx
operator|^=
literal|1
expr_stmt|;
name|memset
argument_list|(
name|last_group
operator|+
name|group_idx
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|last_group
index|[
name|group_idx
index|]
argument_list|)
expr_stmt|;
block|}
else|else
name|errata_emit_nops
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Instruction scheduling support.  */
end_comment

begin_comment
comment|/* Describe one bundle.  */
end_comment

begin_struct
struct|struct
name|bundle
block|{
comment|/* Zero if there's no possibility of a stop in this bundle other than      at the end, otherwise the position of the optional stop bit.  */
name|int
name|possible_stop
decl_stmt|;
comment|/* The types of the three slots.  */
name|enum
name|attr_type
name|t
index|[
literal|3
index|]
decl_stmt|;
comment|/* The pseudo op to be emitted into the assembler output.  */
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|NR_BUNDLES
value|10
end_define

begin_comment
comment|/* A list of all available bundles.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|bundle
name|bundle
index|[
name|NR_BUNDLES
index|]
init|=
block|{
block|{
literal|2
block|,
block|{
name|TYPE_M
block|,
name|TYPE_I
block|,
name|TYPE_I
block|}
block|,
literal|".mii"
block|}
block|,
block|{
literal|1
block|,
block|{
name|TYPE_M
block|,
name|TYPE_M
block|,
name|TYPE_I
block|}
block|,
literal|".mmi"
block|}
block|,
block|{
literal|0
block|,
block|{
name|TYPE_M
block|,
name|TYPE_F
block|,
name|TYPE_I
block|}
block|,
literal|".mfi"
block|}
block|,
block|{
literal|0
block|,
block|{
name|TYPE_M
block|,
name|TYPE_M
block|,
name|TYPE_F
block|}
block|,
literal|".mmf"
block|}
block|,
if|#
directive|if
name|NR_BUNDLES
operator|==
literal|10
block|{
literal|0
block|,
block|{
name|TYPE_B
block|,
name|TYPE_B
block|,
name|TYPE_B
block|}
block|,
literal|".bbb"
block|}
block|,
block|{
literal|0
block|,
block|{
name|TYPE_M
block|,
name|TYPE_B
block|,
name|TYPE_B
block|}
block|,
literal|".mbb"
block|}
block|,
endif|#
directive|endif
block|{
literal|0
block|,
block|{
name|TYPE_M
block|,
name|TYPE_I
block|,
name|TYPE_B
block|}
block|,
literal|".mib"
block|}
block|,
block|{
literal|0
block|,
block|{
name|TYPE_M
block|,
name|TYPE_M
block|,
name|TYPE_B
block|}
block|,
literal|".mmb"
block|}
block|,
block|{
literal|0
block|,
block|{
name|TYPE_M
block|,
name|TYPE_F
block|,
name|TYPE_B
block|}
block|,
literal|".mfb"
block|}
block|,
comment|/* .mfi needs to occur earlier than .mlx, so that we only generate it if      it matches an L type insn.  Otherwise we'll try to generate L type      nops.  */
block|{
literal|0
block|,
block|{
name|TYPE_M
block|,
name|TYPE_L
block|,
name|TYPE_X
block|}
block|,
literal|".mlx"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Describe a packet of instructions.  Packets consist of two bundles that    are visible to the hardware in one scheduling window.  */
end_comment

begin_struct
struct|struct
name|ia64_packet
block|{
specifier|const
name|struct
name|bundle
modifier|*
name|t1
decl_stmt|,
modifier|*
name|t2
decl_stmt|;
comment|/* Precomputed value of the first split issue in this packet if a cycle      starts at its beginning.  */
name|int
name|first_split
decl_stmt|;
comment|/* For convenience, the insn types are replicated here so we don't have      to go through T1 and T2 all the time.  */
name|enum
name|attr_type
name|t
index|[
literal|6
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* An array containing all possible packets.  */
end_comment

begin_define
define|#
directive|define
name|NR_PACKETS
value|(NR_BUNDLES * NR_BUNDLES)
end_define

begin_decl_stmt
specifier|static
name|struct
name|ia64_packet
name|packets
index|[
name|NR_PACKETS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Map attr_type to a string with the name.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|type_names
index|[]
init|=
block|{
literal|"UNKNOWN"
block|,
literal|"A"
block|,
literal|"I"
block|,
literal|"M"
block|,
literal|"F"
block|,
literal|"B"
block|,
literal|"L"
block|,
literal|"X"
block|,
literal|"S"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we should insert stop bits into the schedule.  */
end_comment

begin_decl_stmt
name|int
name|ia64_final_schedule
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|itanium_split_issue
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|ia64_packet
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|ia64_single_set
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|insn_matches_slot
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|ia64_packet
operator|*
operator|,
expr|enum
name|attr_type
operator|,
name|int
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ia64_emit_insn_before
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|maybe_rotate
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|finish_last_head
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|rotate_one_bundle
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|rotate_two_bundles
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|nop_cycles_until
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cycle_end_fill_slots
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|packet_matches_p
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|ia64_packet
operator|*
operator|,
name|int
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_split
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|ia64_packet
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|find_best_insn
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|*
operator|,
expr|enum
name|attr_type
operator|*
operator|,
name|int
operator|,
specifier|const
expr|struct
name|ia64_packet
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|find_best_packet
name|PARAMS
argument_list|(
operator|(
name|int
operator|*
operator|,
specifier|const
expr|struct
name|ia64_packet
operator|*
operator|*
operator|,
name|rtx
operator|*
operator|,
expr|enum
name|attr_type
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|itanium_reorder
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|rtx
operator|*
operator|,
name|rtx
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_current_packet
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|schedule_stop
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|gen_nop_type
name|PARAMS
argument_list|(
operator|(
expr|enum
name|attr_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ia64_emit_nops
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Map a bundle number to its pseudo-op.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|get_bundle_name
parameter_list|(
name|b
parameter_list|)
name|int
name|b
decl_stmt|;
block|{
return|return
name|bundle
index|[
name|b
index|]
operator|.
name|name
return|;
block|}
end_function

begin_comment
comment|/* Compute the slot which will cause a split issue in packet P if the    current cycle begins at slot BEGIN.  */
end_comment

begin_function
specifier|static
name|int
name|itanium_split_issue
parameter_list|(
name|p
parameter_list|,
name|begin
parameter_list|)
specifier|const
name|struct
name|ia64_packet
modifier|*
name|p
decl_stmt|;
name|int
name|begin
decl_stmt|;
block|{
name|int
name|type_count
index|[
name|TYPE_S
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|split
init|=
literal|6
decl_stmt|;
if|if
condition|(
name|begin
operator|<
literal|3
condition|)
block|{
comment|/* Always split before and after MMF.  */
if|if
condition|(
name|p
operator|->
name|t
index|[
literal|0
index|]
operator|==
name|TYPE_M
operator|&&
name|p
operator|->
name|t
index|[
literal|1
index|]
operator|==
name|TYPE_M
operator|&&
name|p
operator|->
name|t
index|[
literal|2
index|]
operator|==
name|TYPE_F
condition|)
return|return
literal|3
return|;
if|if
condition|(
name|p
operator|->
name|t
index|[
literal|3
index|]
operator|==
name|TYPE_M
operator|&&
name|p
operator|->
name|t
index|[
literal|4
index|]
operator|==
name|TYPE_M
operator|&&
name|p
operator|->
name|t
index|[
literal|5
index|]
operator|==
name|TYPE_F
condition|)
return|return
literal|3
return|;
comment|/* Always split after MBB and BBB.  */
if|if
condition|(
name|p
operator|->
name|t
index|[
literal|1
index|]
operator|==
name|TYPE_B
condition|)
return|return
literal|3
return|;
comment|/* Split after first bundle in MIB BBB combination.  */
if|if
condition|(
name|p
operator|->
name|t
index|[
literal|2
index|]
operator|==
name|TYPE_B
operator|&&
name|p
operator|->
name|t
index|[
literal|3
index|]
operator|==
name|TYPE_B
condition|)
return|return
literal|3
return|;
block|}
name|memset
argument_list|(
name|type_count
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|type_count
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|begin
init|;
name|i
operator|<
name|split
condition|;
name|i
operator|++
control|)
block|{
name|enum
name|attr_type
name|t0
init|=
name|p
operator|->
name|t
index|[
name|i
index|]
decl_stmt|;
comment|/* An MLX bundle reserves the same units as an MFI bundle.  */
name|enum
name|attr_type
name|t
init|=
operator|(
name|t0
operator|==
name|TYPE_L
condition|?
name|TYPE_F
else|:
name|t0
operator|==
name|TYPE_X
condition|?
name|TYPE_I
else|:
name|t0
operator|)
decl_stmt|;
comment|/* Itanium can execute up to 3 branches, 2 floating point, 2 memory, and 	 2 integer per cycle.  */
name|int
name|max
init|=
operator|(
name|t
operator|==
name|TYPE_B
condition|?
literal|3
else|:
literal|2
operator|)
decl_stmt|;
if|if
condition|(
name|type_count
index|[
name|t
index|]
operator|==
name|max
condition|)
return|return
name|i
return|;
name|type_count
index|[
name|t
index|]
operator|++
expr_stmt|;
block|}
return|return
name|split
return|;
block|}
end_function

begin_comment
comment|/* Return the maximum number of instructions a cpu can issue.  */
end_comment

begin_function
specifier|static
name|int
name|ia64_issue_rate
parameter_list|()
block|{
return|return
literal|6
return|;
block|}
end_function

begin_comment
comment|/* Helper function - like single_set, but look inside COND_EXEC.  */
end_comment

begin_function
specifier|static
name|rtx
name|ia64_single_set
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|x
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|,
name|ret
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|COND_EXEC
condition|)
name|x
operator|=
name|COND_EXEC_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SET
condition|)
return|return
name|x
return|;
name|ret
operator|=
name|single_set_2
argument_list|(
name|insn
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
comment|/* Special case here prologue_allocate_stack and 	 epilogue_deallocate_stack.  Although it is not a classical 	 single set, the second set is there just to protect it 	 from moving past FP-relative stack accesses.  */
if|if
condition|(
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
literal|2
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|ia64_safe_itanium_class
argument_list|(
name|insn
argument_list|)
operator|==
name|ITANIUM_CLASS_IALU
condition|)
name|ret
operator|=
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Adjust the cost of a scheduling dependency.  Return the new cost of    a dependency LINK or INSN on DEP_INSN.  COST is the current cost.  */
end_comment

begin_function
specifier|static
name|int
name|ia64_adjust_cost
parameter_list|(
name|insn
parameter_list|,
name|link
parameter_list|,
name|dep_insn
parameter_list|,
name|cost
parameter_list|)
name|rtx
name|insn
decl_stmt|,
name|link
decl_stmt|,
name|dep_insn
decl_stmt|;
name|int
name|cost
decl_stmt|;
block|{
name|enum
name|attr_type
name|dep_type
decl_stmt|;
name|enum
name|attr_itanium_class
name|dep_class
decl_stmt|;
name|enum
name|attr_itanium_class
name|insn_class
decl_stmt|;
name|rtx
name|dep_set
decl_stmt|,
name|set
decl_stmt|,
name|src
decl_stmt|,
name|addr
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|dep_insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|dep_insn
argument_list|)
argument_list|)
operator|==
name|USE
comment|/* @@@ Not accurate for indirect calls.  */
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|||
name|ia64_safe_type
argument_list|(
name|insn
argument_list|)
operator|==
name|TYPE_S
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_DEP_OUTPUT
operator|||
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_DEP_ANTI
condition|)
return|return
literal|0
return|;
name|dep_type
operator|=
name|ia64_safe_type
argument_list|(
name|dep_insn
argument_list|)
expr_stmt|;
name|dep_class
operator|=
name|ia64_safe_itanium_class
argument_list|(
name|dep_insn
argument_list|)
expr_stmt|;
name|insn_class
operator|=
name|ia64_safe_itanium_class
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Compares that feed a conditional branch can execute in the same      cycle.  */
name|dep_set
operator|=
name|ia64_single_set
argument_list|(
name|dep_insn
argument_list|)
expr_stmt|;
name|set
operator|=
name|ia64_single_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|dep_type
operator|!=
name|TYPE_F
operator|&&
name|dep_set
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|dep_set
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|PR_REG
argument_list|(
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|dep_set
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|dep_set
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|dep_set
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
block|{
comment|/* ??? Can't find any information in the documenation about whether 	 a sequence 	   st [rx] = ra 	   ld rb = [ry] 	 splits issue.  Assume it doesn't.  */
return|return
literal|0
return|;
block|}
name|src
operator|=
name|set
condition|?
name|SET_SRC
argument_list|(
name|set
argument_list|)
else|:
literal|0
expr_stmt|;
name|addr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|set
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
name|addr
operator|=
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
name|addr
operator|=
name|XEXP
argument_list|(
name|SUBREG_REG
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|addr
operator|=
name|src
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|UNSPEC
operator|&&
name|XVECLEN
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
operator|>
literal|0
condition|)
name|addr
operator|=
name|XVECEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|ZERO_EXTEND
condition|)
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|MEM
condition|)
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|addr
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|addr
operator|&&
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|POST_MODIFY
condition|)
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set
operator|=
name|ia64_single_set
argument_list|(
name|dep_insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dep_class
operator|==
name|ITANIUM_CLASS_IALU
operator|||
name|dep_class
operator|==
name|ITANIUM_CLASS_ILOG
operator|||
name|dep_class
operator|==
name|ITANIUM_CLASS_LD
operator|)
operator|&&
operator|(
name|insn_class
operator|==
name|ITANIUM_CLASS_LD
operator|||
name|insn_class
operator|==
name|ITANIUM_CLASS_ST
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|addr
operator|||
operator|!
name|set
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* This isn't completely correct - an IALU that feeds an address has 	 a latency of 1 cycle if it's issued in an M slot, but 2 cycles 	 otherwise.  Unfortunately there's no good way to describe this.  */
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
name|addr
argument_list|)
condition|)
return|return
name|cost
operator|+
literal|1
return|;
block|}
if|if
condition|(
operator|(
name|dep_class
operator|==
name|ITANIUM_CLASS_IALU
operator|||
name|dep_class
operator|==
name|ITANIUM_CLASS_ILOG
operator|||
name|dep_class
operator|==
name|ITANIUM_CLASS_LD
operator|)
operator|&&
operator|(
name|insn_class
operator|==
name|ITANIUM_CLASS_MMMUL
operator|||
name|insn_class
operator|==
name|ITANIUM_CLASS_MMSHF
operator|||
name|insn_class
operator|==
name|ITANIUM_CLASS_MMSHFI
operator|)
condition|)
return|return
literal|3
return|;
if|if
condition|(
name|dep_class
operator|==
name|ITANIUM_CLASS_FMAC
operator|&&
operator|(
name|insn_class
operator|==
name|ITANIUM_CLASS_FMISC
operator|||
name|insn_class
operator|==
name|ITANIUM_CLASS_FCVTFX
operator|||
name|insn_class
operator|==
name|ITANIUM_CLASS_XMPY
operator|)
condition|)
return|return
literal|7
return|;
if|if
condition|(
operator|(
name|dep_class
operator|==
name|ITANIUM_CLASS_FMAC
operator|||
name|dep_class
operator|==
name|ITANIUM_CLASS_FMISC
operator|||
name|dep_class
operator|==
name|ITANIUM_CLASS_FCVTFX
operator|||
name|dep_class
operator|==
name|ITANIUM_CLASS_XMPY
operator|)
operator|&&
name|insn_class
operator|==
name|ITANIUM_CLASS_STF
condition|)
return|return
literal|8
return|;
if|if
condition|(
operator|(
name|dep_class
operator|==
name|ITANIUM_CLASS_MMMUL
operator|||
name|dep_class
operator|==
name|ITANIUM_CLASS_MMSHF
operator|||
name|dep_class
operator|==
name|ITANIUM_CLASS_MMSHFI
operator|)
operator|&&
operator|(
name|insn_class
operator|==
name|ITANIUM_CLASS_LD
operator|||
name|insn_class
operator|==
name|ITANIUM_CLASS_ST
operator|||
name|insn_class
operator|==
name|ITANIUM_CLASS_IALU
operator|||
name|insn_class
operator|==
name|ITANIUM_CLASS_ILOG
operator|||
name|insn_class
operator|==
name|ITANIUM_CLASS_ISHF
operator|)
condition|)
return|return
literal|4
return|;
return|return
name|cost
return|;
block|}
end_function

begin_comment
comment|/* Describe the current state of the Itanium pipeline.  */
end_comment

begin_struct
specifier|static
struct|struct
block|{
comment|/* The first slot that is used in the current cycle.  */
name|int
name|first_slot
decl_stmt|;
comment|/* The next slot to fill.  */
name|int
name|cur
decl_stmt|;
comment|/* The packet we have selected for the current issue window.  */
specifier|const
name|struct
name|ia64_packet
modifier|*
name|packet
decl_stmt|;
comment|/* The position of the split issue that occurs due to issue width      limitations (6 if there's no split issue).  */
name|int
name|split
decl_stmt|;
comment|/* Record data about the insns scheduled so far in the same issue      window.  The elements up to but not including FIRST_SLOT belong      to the previous cycle, the ones starting with FIRST_SLOT belong      to the current cycle.  */
name|enum
name|attr_type
name|types
index|[
literal|6
index|]
decl_stmt|;
name|rtx
name|insns
index|[
literal|6
index|]
decl_stmt|;
name|int
name|stopbit
index|[
literal|6
index|]
decl_stmt|;
comment|/* Nonzero if we decided to schedule a stop bit.  */
name|int
name|last_was_stop
decl_stmt|;
block|}
name|sched_data
struct|;
end_struct

begin_comment
comment|/* Temporary arrays; they have enough elements to hold all insns that    can be ready at the same time while scheduling of the current block.    SCHED_READY can hold ready insns, SCHED_TYPES their types.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|sched_ready
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|attr_type
modifier|*
name|sched_types
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Determine whether an insn INSN of type ITYPE can fit into slot SLOT    of packet P.  */
end_comment

begin_function
specifier|static
name|int
name|insn_matches_slot
parameter_list|(
name|p
parameter_list|,
name|itype
parameter_list|,
name|slot
parameter_list|,
name|insn
parameter_list|)
specifier|const
name|struct
name|ia64_packet
modifier|*
name|p
decl_stmt|;
name|enum
name|attr_type
name|itype
decl_stmt|;
name|int
name|slot
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|enum
name|attr_itanium_requires_unit0
name|u0
decl_stmt|;
name|enum
name|attr_type
name|stype
init|=
name|p
operator|->
name|t
index|[
name|slot
index|]
decl_stmt|;
if|if
condition|(
name|insn
condition|)
block|{
name|u0
operator|=
name|ia64_safe_itanium_requires_unit0
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|u0
operator|==
name|ITANIUM_REQUIRES_UNIT0_YES
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|sched_data
operator|.
name|first_slot
init|;
name|i
operator|<
name|slot
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|p
operator|->
name|t
index|[
name|i
index|]
operator|==
name|stype
operator|||
operator|(
name|stype
operator|==
name|TYPE_F
operator|&&
name|p
operator|->
name|t
index|[
name|i
index|]
operator|==
name|TYPE_L
operator|)
operator|||
operator|(
name|stype
operator|==
name|TYPE_I
operator|&&
name|p
operator|->
name|t
index|[
name|i
index|]
operator|==
name|TYPE_X
operator|)
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
comment|/* Reject calls in multiway branch packets.  We want to limit 	     the number of multiway branches we generate (since the branch 	     predictor is limited), and this seems to work fairly well. 	     (If we didn't do this, we'd have to add another test here to 	     force calls into the third slot of the bundle.)  */
if|if
condition|(
name|slot
operator|<
literal|3
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|t
index|[
literal|1
index|]
operator|==
name|TYPE_B
condition|)
return|return
literal|0
return|;
block|}
else|else
block|{
if|if
condition|(
name|p
operator|->
name|t
index|[
literal|4
index|]
operator|==
name|TYPE_B
condition|)
return|return
literal|0
return|;
block|}
block|}
block|}
if|if
condition|(
name|itype
operator|==
name|stype
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|itype
operator|==
name|TYPE_A
condition|)
return|return
name|stype
operator|==
name|TYPE_M
operator|||
name|stype
operator|==
name|TYPE_I
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Like emit_insn_before, but skip cycle_display insns.  This makes the    assembly output a bit prettier.  */
end_comment

begin_function
specifier|static
name|void
name|ia64_emit_insn_before
parameter_list|(
name|insn
parameter_list|,
name|before
parameter_list|)
name|rtx
name|insn
decl_stmt|,
name|before
decl_stmt|;
block|{
name|rtx
name|prev
init|=
name|PREV_INSN
argument_list|(
name|before
argument_list|)
decl_stmt|;
if|if
condition|(
name|prev
operator|&&
name|GET_CODE
argument_list|(
name|prev
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|prev
argument_list|)
argument_list|)
operator|==
name|UNSPEC
operator|&&
name|XINT
argument_list|(
name|PATTERN
argument_list|(
name|prev
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
literal|23
condition|)
name|before
operator|=
name|prev
expr_stmt|;
name|emit_insn_before
argument_list|(
name|insn
argument_list|,
name|before
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Generate a nop insn of the given type.  Note we never generate L type    nops.  */
end_comment

begin_endif
unit|static rtx gen_nop_type (t)      enum attr_type t; {   switch (t)     {     case TYPE_M:       return gen_nop_m ();     case TYPE_I:       return gen_nop_i ();     case TYPE_B:       return gen_nop_b ();     case TYPE_F:       return gen_nop_f ();     case TYPE_X:       return gen_nop_x ();     default:       abort ();     } }
endif|#
directive|endif
end_endif

begin_comment
comment|/* When rotating a bundle out of the issue window, insert a bundle selector    insn in front of it.  DUMP is the scheduling dump file or NULL.  START    is either 0 or 3, depending on whether we want to emit a bundle selector    for the first bundle or the second bundle in the current issue window.     The selector insns are emitted this late because the selected packet can    be changed until parts of it get rotated out.  */
end_comment

begin_function
specifier|static
name|void
name|finish_last_head
parameter_list|(
name|dump
parameter_list|,
name|start
parameter_list|)
name|FILE
modifier|*
name|dump
decl_stmt|;
name|int
name|start
decl_stmt|;
block|{
specifier|const
name|struct
name|ia64_packet
modifier|*
name|p
init|=
name|sched_data
operator|.
name|packet
decl_stmt|;
specifier|const
name|struct
name|bundle
modifier|*
name|b
init|=
name|start
operator|==
literal|0
condition|?
name|p
operator|->
name|t1
else|:
name|p
operator|->
name|t2
decl_stmt|;
name|int
name|bundle_type
init|=
name|b
operator|-
name|bundle
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|ia64_final_schedule
condition|)
return|return;
for|for
control|(
name|i
operator|=
name|start
init|;
name|sched_data
operator|.
name|insns
index|[
name|i
index|]
operator|==
literal|0
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|i
operator|==
name|start
operator|+
literal|3
condition|)
name|abort
argument_list|()
expr_stmt|;
name|insn
operator|=
name|sched_data
operator|.
name|insns
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|dump
condition|)
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"//    Emitting template before %d: %s\n"
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|,
name|b
operator|->
name|name
argument_list|)
expr_stmt|;
name|ia64_emit_insn_before
argument_list|(
name|gen_bundle_selector
argument_list|(
name|GEN_INT
argument_list|(
name|bundle_type
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We can't schedule more insns this cycle.  Fix up the scheduling state    and advance FIRST_SLOT and CUR.    We have to distribute the insns that are currently found between    FIRST_SLOT and CUR into the slots of the packet we have selected.  So    far, they are stored successively in the fields starting at FIRST_SLOT;    now they must be moved to the correct slots.    DUMP is the current scheduling dump file, or NULL.  */
end_comment

begin_function
specifier|static
name|void
name|cycle_end_fill_slots
parameter_list|(
name|dump
parameter_list|)
name|FILE
modifier|*
name|dump
decl_stmt|;
block|{
specifier|const
name|struct
name|ia64_packet
modifier|*
name|packet
init|=
name|sched_data
operator|.
name|packet
decl_stmt|;
name|int
name|slot
decl_stmt|,
name|i
decl_stmt|;
name|enum
name|attr_type
name|tmp_types
index|[
literal|6
index|]
decl_stmt|;
name|rtx
name|tmp_insns
index|[
literal|6
index|]
decl_stmt|;
name|memcpy
argument_list|(
name|tmp_types
argument_list|,
name|sched_data
operator|.
name|types
argument_list|,
literal|6
operator|*
sizeof|sizeof
argument_list|(
expr|enum
name|attr_type
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|tmp_insns
argument_list|,
name|sched_data
operator|.
name|insns
argument_list|,
literal|6
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|slot
operator|=
name|sched_data
operator|.
name|first_slot
init|;
name|i
operator|<
name|sched_data
operator|.
name|cur
condition|;
name|i
operator|++
control|)
block|{
name|enum
name|attr_type
name|t
init|=
name|tmp_types
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|t
operator|!=
name|ia64_safe_type
argument_list|(
name|tmp_insns
index|[
name|i
index|]
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
while|while
condition|(
operator|!
name|insn_matches_slot
argument_list|(
name|packet
argument_list|,
name|t
argument_list|,
name|slot
argument_list|,
name|tmp_insns
index|[
name|i
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|slot
operator|>
name|sched_data
operator|.
name|split
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|dump
condition|)
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"// Packet needs %s, have %s\n"
argument_list|,
name|type_names
index|[
name|packet
operator|->
name|t
index|[
name|slot
index|]
index|]
argument_list|,
name|type_names
index|[
name|t
index|]
argument_list|)
expr_stmt|;
name|sched_data
operator|.
name|types
index|[
name|slot
index|]
operator|=
name|packet
operator|->
name|t
index|[
name|slot
index|]
expr_stmt|;
name|sched_data
operator|.
name|insns
index|[
name|slot
index|]
operator|=
literal|0
expr_stmt|;
name|sched_data
operator|.
name|stopbit
index|[
name|slot
index|]
operator|=
literal|0
expr_stmt|;
comment|/* ??? TYPE_L instructions always fill up two slots, but we don't 	     support TYPE_L nops.  */
if|if
condition|(
name|packet
operator|->
name|t
index|[
name|slot
index|]
operator|==
name|TYPE_L
condition|)
name|abort
argument_list|()
expr_stmt|;
name|slot
operator|++
expr_stmt|;
block|}
comment|/* Do _not_ use T here.  If T == TYPE_A, then we'd risk changing the 	 actual slot type later.  */
name|sched_data
operator|.
name|types
index|[
name|slot
index|]
operator|=
name|packet
operator|->
name|t
index|[
name|slot
index|]
expr_stmt|;
name|sched_data
operator|.
name|insns
index|[
name|slot
index|]
operator|=
name|tmp_insns
index|[
name|i
index|]
expr_stmt|;
name|sched_data
operator|.
name|stopbit
index|[
name|slot
index|]
operator|=
literal|0
expr_stmt|;
name|slot
operator|++
expr_stmt|;
comment|/* TYPE_L instructions always fill up two slots.  */
if|if
condition|(
name|t
operator|==
name|TYPE_L
condition|)
name|slot
operator|++
expr_stmt|;
block|}
comment|/* This isn't right - there's no need to pad out until the forced split;      the CPU will automatically split if an insn isn't ready.  */
if|#
directive|if
literal|0
block|while (slot< sched_data.split)     {       sched_data.types[slot] = packet->t[slot];       sched_data.insns[slot] = 0;       sched_data.stopbit[slot] = 0;       slot++;     }
endif|#
directive|endif
name|sched_data
operator|.
name|first_slot
operator|=
name|sched_data
operator|.
name|cur
operator|=
name|slot
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Bundle rotations, as described in the Itanium optimization manual.    We can rotate either one or both bundles out of the issue window.    DUMP is the current scheduling dump file, or NULL.  */
end_comment

begin_function
specifier|static
name|void
name|rotate_one_bundle
parameter_list|(
name|dump
parameter_list|)
name|FILE
modifier|*
name|dump
decl_stmt|;
block|{
if|if
condition|(
name|dump
condition|)
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"// Rotating one bundle.\n"
argument_list|)
expr_stmt|;
name|finish_last_head
argument_list|(
name|dump
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sched_data
operator|.
name|cur
operator|>
literal|3
condition|)
block|{
name|sched_data
operator|.
name|cur
operator|-=
literal|3
expr_stmt|;
name|sched_data
operator|.
name|first_slot
operator|-=
literal|3
expr_stmt|;
name|memmove
argument_list|(
name|sched_data
operator|.
name|types
argument_list|,
name|sched_data
operator|.
name|types
operator|+
literal|3
argument_list|,
name|sched_data
operator|.
name|cur
operator|*
sizeof|sizeof
expr|*
name|sched_data
operator|.
name|types
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|sched_data
operator|.
name|stopbit
argument_list|,
name|sched_data
operator|.
name|stopbit
operator|+
literal|3
argument_list|,
name|sched_data
operator|.
name|cur
operator|*
sizeof|sizeof
expr|*
name|sched_data
operator|.
name|stopbit
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|sched_data
operator|.
name|insns
argument_list|,
name|sched_data
operator|.
name|insns
operator|+
literal|3
argument_list|,
name|sched_data
operator|.
name|cur
operator|*
sizeof|sizeof
expr|*
name|sched_data
operator|.
name|insns
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sched_data
operator|.
name|cur
operator|=
literal|0
expr_stmt|;
name|sched_data
operator|.
name|first_slot
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|rotate_two_bundles
parameter_list|(
name|dump
parameter_list|)
name|FILE
modifier|*
name|dump
decl_stmt|;
block|{
if|if
condition|(
name|dump
condition|)
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"// Rotating two bundles.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sched_data
operator|.
name|cur
operator|==
literal|0
condition|)
return|return;
name|finish_last_head
argument_list|(
name|dump
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sched_data
operator|.
name|cur
operator|>
literal|3
condition|)
name|finish_last_head
argument_list|(
name|dump
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|sched_data
operator|.
name|cur
operator|=
literal|0
expr_stmt|;
name|sched_data
operator|.
name|first_slot
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We're beginning a new block.  Initialize data structures as necessary.  */
end_comment

begin_function
specifier|static
name|void
name|ia64_sched_init
parameter_list|(
name|dump
parameter_list|,
name|sched_verbose
parameter_list|,
name|max_ready
parameter_list|)
name|FILE
modifier|*
name|dump
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|sched_verbose
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|max_ready
decl_stmt|;
block|{
specifier|static
name|int
name|initialized
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
name|int
name|b1
decl_stmt|,
name|b2
decl_stmt|,
name|i
decl_stmt|;
name|initialized
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|b1
operator|=
literal|0
init|;
name|b1
operator|<
name|NR_BUNDLES
condition|;
name|b1
operator|++
control|)
block|{
specifier|const
name|struct
name|bundle
modifier|*
name|t1
init|=
name|bundle
operator|+
name|b1
decl_stmt|;
for|for
control|(
name|b2
operator|=
literal|0
init|;
name|b2
operator|<
name|NR_BUNDLES
condition|;
name|b2
operator|++
operator|,
name|i
operator|++
control|)
block|{
specifier|const
name|struct
name|bundle
modifier|*
name|t2
init|=
name|bundle
operator|+
name|b2
decl_stmt|;
name|packets
index|[
name|i
index|]
operator|.
name|t1
operator|=
name|t1
expr_stmt|;
name|packets
index|[
name|i
index|]
operator|.
name|t2
operator|=
name|t2
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NR_PACKETS
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|3
condition|;
name|j
operator|++
control|)
name|packets
index|[
name|i
index|]
operator|.
name|t
index|[
name|j
index|]
operator|=
name|packets
index|[
name|i
index|]
operator|.
name|t1
operator|->
name|t
index|[
name|j
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|3
condition|;
name|j
operator|++
control|)
name|packets
index|[
name|i
index|]
operator|.
name|t
index|[
name|j
operator|+
literal|3
index|]
operator|=
name|packets
index|[
name|i
index|]
operator|.
name|t2
operator|->
name|t
index|[
name|j
index|]
expr_stmt|;
name|packets
index|[
name|i
index|]
operator|.
name|first_split
operator|=
name|itanium_split_issue
argument_list|(
name|packets
operator|+
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|init_insn_group_barriers
argument_list|()
expr_stmt|;
name|memset
argument_list|(
operator|&
name|sched_data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|sched_data
argument_list|)
expr_stmt|;
name|sched_types
operator|=
operator|(
expr|enum
name|attr_type
operator|*
operator|)
name|xmalloc
argument_list|(
name|max_ready
operator|*
sizeof|sizeof
argument_list|(
expr|enum
name|attr_type
argument_list|)
argument_list|)
expr_stmt|;
name|sched_ready
operator|=
operator|(
name|rtx
operator|*
operator|)
name|xmalloc
argument_list|(
name|max_ready
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* See if the packet P can match the insns we have already scheduled.  Return    nonzero if so.  In *PSLOT, we store the first slot that is available for    more instructions if we choose this packet.    SPLIT holds the last slot we can use, there's a split issue after it so    scheduling beyond it would cause us to use more than one cycle.  */
end_comment

begin_function
specifier|static
name|int
name|packet_matches_p
parameter_list|(
name|p
parameter_list|,
name|split
parameter_list|,
name|pslot
parameter_list|)
specifier|const
name|struct
name|ia64_packet
modifier|*
name|p
decl_stmt|;
name|int
name|split
decl_stmt|;
name|int
modifier|*
name|pslot
decl_stmt|;
block|{
name|int
name|filled
init|=
name|sched_data
operator|.
name|cur
decl_stmt|;
name|int
name|first
init|=
name|sched_data
operator|.
name|first_slot
decl_stmt|;
name|int
name|i
decl_stmt|,
name|slot
decl_stmt|;
comment|/* First, check if the first of the two bundles must be a specific one (due      to stop bits).  */
if|if
condition|(
name|first
operator|>
literal|0
operator|&&
name|sched_data
operator|.
name|stopbit
index|[
literal|0
index|]
operator|&&
name|p
operator|->
name|t1
operator|->
name|possible_stop
operator|!=
literal|1
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|first
operator|>
literal|1
operator|&&
name|sched_data
operator|.
name|stopbit
index|[
literal|1
index|]
operator|&&
name|p
operator|->
name|t1
operator|->
name|possible_stop
operator|!=
literal|2
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|first
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|insn_matches_slot
argument_list|(
name|p
argument_list|,
name|sched_data
operator|.
name|types
index|[
name|i
index|]
argument_list|,
name|i
argument_list|,
name|sched_data
operator|.
name|insns
index|[
name|i
index|]
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
name|slot
operator|=
name|first
init|;
name|i
operator|<
name|filled
condition|;
name|i
operator|++
control|)
block|{
while|while
condition|(
name|slot
operator|<
name|split
condition|)
block|{
if|if
condition|(
name|insn_matches_slot
argument_list|(
name|p
argument_list|,
name|sched_data
operator|.
name|types
index|[
name|i
index|]
argument_list|,
name|slot
argument_list|,
name|sched_data
operator|.
name|insns
index|[
name|i
index|]
argument_list|)
condition|)
break|break;
name|slot
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|slot
operator|==
name|split
condition|)
return|return
literal|0
return|;
name|slot
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|pslot
condition|)
operator|*
name|pslot
operator|=
name|slot
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* A frontend for itanium_split_issue.  For a packet P and a slot    number FIRST that describes the start of the current clock cycle,    return the slot number of the first split issue.  This function    uses the cached number found in P if possible.  */
end_comment

begin_function
specifier|static
name|int
name|get_split
parameter_list|(
name|p
parameter_list|,
name|first
parameter_list|)
specifier|const
name|struct
name|ia64_packet
modifier|*
name|p
decl_stmt|;
name|int
name|first
decl_stmt|;
block|{
if|if
condition|(
name|first
operator|==
literal|0
condition|)
return|return
name|p
operator|->
name|first_split
return|;
return|return
name|itanium_split_issue
argument_list|(
name|p
argument_list|,
name|first
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given N_READY insns in the array READY, whose types are found in the    corresponding array TYPES, return the insn that is best suited to be    scheduled in slot SLOT of packet P.  */
end_comment

begin_function
specifier|static
name|int
name|find_best_insn
parameter_list|(
name|ready
parameter_list|,
name|types
parameter_list|,
name|n_ready
parameter_list|,
name|p
parameter_list|,
name|slot
parameter_list|)
name|rtx
modifier|*
name|ready
decl_stmt|;
name|enum
name|attr_type
modifier|*
name|types
decl_stmt|;
name|int
name|n_ready
decl_stmt|;
specifier|const
name|struct
name|ia64_packet
modifier|*
name|p
decl_stmt|;
name|int
name|slot
decl_stmt|;
block|{
name|int
name|best
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|best_pri
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|n_ready
operator|--
operator|>
literal|0
condition|)
block|{
name|rtx
name|insn
init|=
name|ready
index|[
name|n_ready
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|insn
condition|)
continue|continue;
if|if
condition|(
name|best
operator|>=
literal|0
operator|&&
name|INSN_PRIORITY
argument_list|(
name|ready
index|[
name|n_ready
index|]
argument_list|)
operator|<
name|best_pri
condition|)
break|break;
comment|/* If we have equally good insns, one of which has a stricter 	 slot requirement, prefer the one with the stricter requirement.  */
if|if
condition|(
name|best
operator|>=
literal|0
operator|&&
name|types
index|[
name|n_ready
index|]
operator|==
name|TYPE_A
condition|)
continue|continue;
if|if
condition|(
name|insn_matches_slot
argument_list|(
name|p
argument_list|,
name|types
index|[
name|n_ready
index|]
argument_list|,
name|slot
argument_list|,
name|insn
argument_list|)
condition|)
block|{
name|best
operator|=
name|n_ready
expr_stmt|;
name|best_pri
operator|=
name|INSN_PRIORITY
argument_list|(
name|ready
index|[
name|best
index|]
argument_list|)
expr_stmt|;
comment|/* If there's no way we could get a stricter requirement, stop 	     looking now.  */
if|if
condition|(
name|types
index|[
name|n_ready
index|]
operator|!=
name|TYPE_A
operator|&&
name|ia64_safe_itanium_requires_unit0
argument_list|(
name|ready
index|[
name|n_ready
index|]
argument_list|)
condition|)
break|break;
break|break;
block|}
block|}
return|return
name|best
return|;
block|}
end_function

begin_comment
comment|/* Select the best packet to use given the current scheduler state and the    current ready list.    READY is an array holding N_READY ready insns; TYPES is a corresponding    array that holds their types.  Store the best packet in *PPACKET and the    number of insns that can be scheduled in the current cycle in *PBEST.  */
end_comment

begin_function
specifier|static
name|void
name|find_best_packet
parameter_list|(
name|pbest
parameter_list|,
name|ppacket
parameter_list|,
name|ready
parameter_list|,
name|types
parameter_list|,
name|n_ready
parameter_list|)
name|int
modifier|*
name|pbest
decl_stmt|;
specifier|const
name|struct
name|ia64_packet
modifier|*
modifier|*
name|ppacket
decl_stmt|;
name|rtx
modifier|*
name|ready
decl_stmt|;
name|enum
name|attr_type
modifier|*
name|types
decl_stmt|;
name|int
name|n_ready
decl_stmt|;
block|{
name|int
name|first
init|=
name|sched_data
operator|.
name|first_slot
decl_stmt|;
name|int
name|best
init|=
literal|0
decl_stmt|;
name|int
name|lowest_end
init|=
literal|6
decl_stmt|;
specifier|const
name|struct
name|ia64_packet
modifier|*
name|best_packet
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NR_PACKETS
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|struct
name|ia64_packet
modifier|*
name|p
init|=
name|packets
operator|+
name|i
decl_stmt|;
name|int
name|slot
decl_stmt|;
name|int
name|split
init|=
name|get_split
argument_list|(
name|p
argument_list|,
name|first
argument_list|)
decl_stmt|;
name|int
name|win
init|=
literal|0
decl_stmt|;
name|int
name|first_slot
decl_stmt|,
name|last_slot
decl_stmt|;
name|int
name|b_nops
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|packet_matches_p
argument_list|(
name|p
argument_list|,
name|split
argument_list|,
operator|&
name|first_slot
argument_list|)
condition|)
continue|continue;
name|memcpy
argument_list|(
name|sched_ready
argument_list|,
name|ready
argument_list|,
name|n_ready
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|win
operator|=
literal|0
expr_stmt|;
name|last_slot
operator|=
literal|6
expr_stmt|;
for|for
control|(
name|slot
operator|=
name|first_slot
init|;
name|slot
operator|<
name|split
condition|;
name|slot
operator|++
control|)
block|{
name|int
name|insn_nr
decl_stmt|;
comment|/* Disallow a degenerate case where the first bundle doesn't 	     contain anything but NOPs!  */
if|if
condition|(
name|first_slot
operator|==
literal|0
operator|&&
name|win
operator|==
literal|0
operator|&&
name|slot
operator|==
literal|3
condition|)
block|{
name|win
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
name|insn_nr
operator|=
name|find_best_insn
argument_list|(
name|sched_ready
argument_list|,
name|types
argument_list|,
name|n_ready
argument_list|,
name|p
argument_list|,
name|slot
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn_nr
operator|>=
literal|0
condition|)
block|{
name|sched_ready
index|[
name|insn_nr
index|]
operator|=
literal|0
expr_stmt|;
name|last_slot
operator|=
name|slot
expr_stmt|;
name|win
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|t
index|[
name|slot
index|]
operator|==
name|TYPE_B
condition|)
name|b_nops
operator|++
expr_stmt|;
block|}
comment|/* We must disallow MBB/BBB packets if any of their B slots would be 	 filled with nops.  */
if|if
condition|(
name|last_slot
operator|<
literal|3
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|t
index|[
literal|1
index|]
operator|==
name|TYPE_B
operator|&&
operator|(
name|b_nops
operator|||
name|last_slot
operator|<
literal|2
operator|)
condition|)
name|win
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|p
operator|->
name|t
index|[
literal|4
index|]
operator|==
name|TYPE_B
operator|&&
operator|(
name|b_nops
operator|||
name|last_slot
operator|<
literal|5
operator|)
condition|)
name|win
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|win
operator|>
name|best
operator|||
operator|(
name|win
operator|==
name|best
operator|&&
name|last_slot
operator|<
name|lowest_end
operator|)
condition|)
block|{
name|best
operator|=
name|win
expr_stmt|;
name|lowest_end
operator|=
name|last_slot
expr_stmt|;
name|best_packet
operator|=
name|p
expr_stmt|;
block|}
block|}
operator|*
name|pbest
operator|=
name|best
expr_stmt|;
operator|*
name|ppacket
operator|=
name|best_packet
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Reorder the ready list so that the insns that can be issued in this cycle    are found in the correct order at the end of the list.    DUMP is the scheduling dump file, or NULL.  READY points to the start,    E_READY to the end of the ready list.  MAY_FAIL determines what should be    done if no insns can be scheduled in this cycle: if it is zero, we abort,    otherwise we return 0.    Return 1 if any insns can be scheduled in this cycle.  */
end_comment

begin_function
specifier|static
name|int
name|itanium_reorder
parameter_list|(
name|dump
parameter_list|,
name|ready
parameter_list|,
name|e_ready
parameter_list|,
name|may_fail
parameter_list|)
name|FILE
modifier|*
name|dump
decl_stmt|;
name|rtx
modifier|*
name|ready
decl_stmt|;
name|rtx
modifier|*
name|e_ready
decl_stmt|;
name|int
name|may_fail
decl_stmt|;
block|{
specifier|const
name|struct
name|ia64_packet
modifier|*
name|best_packet
decl_stmt|;
name|int
name|n_ready
init|=
name|e_ready
operator|-
name|ready
decl_stmt|;
name|int
name|first
init|=
name|sched_data
operator|.
name|first_slot
decl_stmt|;
name|int
name|i
decl_stmt|,
name|best
decl_stmt|,
name|best_split
decl_stmt|,
name|filled
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_ready
condition|;
name|i
operator|++
control|)
name|sched_types
index|[
name|i
index|]
operator|=
name|ia64_safe_type
argument_list|(
name|ready
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|find_best_packet
argument_list|(
operator|&
name|best
argument_list|,
operator|&
name|best_packet
argument_list|,
name|ready
argument_list|,
name|sched_types
argument_list|,
name|n_ready
argument_list|)
expr_stmt|;
if|if
condition|(
name|best
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|may_fail
condition|)
return|return
literal|0
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|dump
condition|)
block|{
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"// Selected bundles: %s %s (%d insns)\n"
argument_list|,
name|best_packet
operator|->
name|t1
operator|->
name|name
argument_list|,
name|best_packet
operator|->
name|t2
condition|?
name|best_packet
operator|->
name|t2
operator|->
name|name
else|:
name|NULL
argument_list|,
name|best
argument_list|)
expr_stmt|;
block|}
name|best_split
operator|=
name|itanium_split_issue
argument_list|(
name|best_packet
argument_list|,
name|first
argument_list|)
expr_stmt|;
name|packet_matches_p
argument_list|(
name|best_packet
argument_list|,
name|best_split
argument_list|,
operator|&
name|filled
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|filled
init|;
name|i
operator|<
name|best_split
condition|;
name|i
operator|++
control|)
block|{
name|int
name|insn_nr
decl_stmt|;
name|insn_nr
operator|=
name|find_best_insn
argument_list|(
name|ready
argument_list|,
name|sched_types
argument_list|,
name|n_ready
argument_list|,
name|best_packet
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn_nr
operator|>=
literal|0
condition|)
block|{
name|rtx
name|insn
init|=
name|ready
index|[
name|insn_nr
index|]
decl_stmt|;
name|memmove
argument_list|(
name|ready
operator|+
name|insn_nr
argument_list|,
name|ready
operator|+
name|insn_nr
operator|+
literal|1
argument_list|,
operator|(
name|n_ready
operator|-
name|insn_nr
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|sched_types
operator|+
name|insn_nr
argument_list|,
name|sched_types
operator|+
name|insn_nr
operator|+
literal|1
argument_list|,
operator|(
name|n_ready
operator|-
name|insn_nr
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|enum
name|attr_type
argument_list|)
argument_list|)
expr_stmt|;
name|ready
index|[
operator|--
name|n_ready
index|]
operator|=
name|insn
expr_stmt|;
block|}
block|}
name|sched_data
operator|.
name|packet
operator|=
name|best_packet
expr_stmt|;
name|sched_data
operator|.
name|split
operator|=
name|best_split
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Dump information about the current scheduling state to file DUMP.  */
end_comment

begin_function
specifier|static
name|void
name|dump_current_packet
parameter_list|(
name|dump
parameter_list|)
name|FILE
modifier|*
name|dump
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"//    %d slots filled:"
argument_list|,
name|sched_data
operator|.
name|cur
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sched_data
operator|.
name|first_slot
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|insn
init|=
name|sched_data
operator|.
name|insns
index|[
name|i
index|]
decl_stmt|;
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|" %s"
argument_list|,
name|type_names
index|[
name|sched_data
operator|.
name|types
index|[
name|i
index|]
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
condition|)
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"/%s"
argument_list|,
name|type_names
index|[
name|ia64_safe_type
argument_list|(
name|insn
argument_list|)
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sched_data
operator|.
name|stopbit
index|[
name|i
index|]
condition|)
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|" ;;"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|" :::"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|sched_data
operator|.
name|first_slot
init|;
name|i
operator|<
name|sched_data
operator|.
name|cur
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|insn
init|=
name|sched_data
operator|.
name|insns
index|[
name|i
index|]
decl_stmt|;
name|enum
name|attr_type
name|t
init|=
name|ia64_safe_type
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|" (%d) %s"
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|,
name|type_names
index|[
name|t
index|]
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Schedule a stop bit.  DUMP is the current scheduling dump file, or    NULL.  */
end_comment

begin_function
specifier|static
name|void
name|schedule_stop
parameter_list|(
name|dump
parameter_list|)
name|FILE
modifier|*
name|dump
decl_stmt|;
block|{
specifier|const
name|struct
name|ia64_packet
modifier|*
name|best
init|=
name|sched_data
operator|.
name|packet
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|best_stop
init|=
literal|6
decl_stmt|;
if|if
condition|(
name|dump
condition|)
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"// Stop bit, cur = %d.\n"
argument_list|,
name|sched_data
operator|.
name|cur
argument_list|)
expr_stmt|;
if|if
condition|(
name|sched_data
operator|.
name|cur
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|dump
condition|)
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"//   At start of bundle, so nothing to do.\n"
argument_list|)
expr_stmt|;
name|rotate_two_bundles
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
operator|-
literal|1
init|;
name|i
operator|<
name|NR_PACKETS
condition|;
name|i
operator|++
control|)
block|{
comment|/* This is a slight hack to give the current packet the first chance. 	 This is done to avoid e.g. switching from MIB to MBB bundles.  */
specifier|const
name|struct
name|ia64_packet
modifier|*
name|p
init|=
operator|(
name|i
operator|>=
literal|0
condition|?
name|packets
operator|+
name|i
else|:
name|sched_data
operator|.
name|packet
operator|)
decl_stmt|;
name|int
name|split
init|=
name|get_split
argument_list|(
name|p
argument_list|,
name|sched_data
operator|.
name|first_slot
argument_list|)
decl_stmt|;
specifier|const
name|struct
name|bundle
modifier|*
name|compare
decl_stmt|;
name|int
name|next
decl_stmt|,
name|stoppos
decl_stmt|;
if|if
condition|(
operator|!
name|packet_matches_p
argument_list|(
name|p
argument_list|,
name|split
argument_list|,
operator|&
name|next
argument_list|)
condition|)
continue|continue;
name|compare
operator|=
name|next
operator|>
literal|3
condition|?
name|p
operator|->
name|t2
else|:
name|p
operator|->
name|t1
expr_stmt|;
name|stoppos
operator|=
literal|3
expr_stmt|;
if|if
condition|(
name|compare
operator|->
name|possible_stop
condition|)
name|stoppos
operator|=
name|compare
operator|->
name|possible_stop
expr_stmt|;
if|if
condition|(
name|next
operator|>
literal|3
condition|)
name|stoppos
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
name|stoppos
operator|<
name|next
operator|||
name|stoppos
operator|>=
name|best_stop
condition|)
block|{
if|if
condition|(
name|compare
operator|->
name|possible_stop
operator|==
literal|0
condition|)
continue|continue;
name|stoppos
operator|=
operator|(
name|next
operator|>
literal|3
condition|?
literal|6
else|:
literal|3
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|stoppos
operator|<
name|next
operator|||
name|stoppos
operator|>=
name|best_stop
condition|)
continue|continue;
if|if
condition|(
name|dump
condition|)
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"//   switching from %s %s to %s %s (stop at %d)\n"
argument_list|,
name|best
operator|->
name|t1
operator|->
name|name
argument_list|,
name|best
operator|->
name|t2
operator|->
name|name
argument_list|,
name|p
operator|->
name|t1
operator|->
name|name
argument_list|,
name|p
operator|->
name|t2
operator|->
name|name
argument_list|,
name|stoppos
argument_list|)
expr_stmt|;
name|best_stop
operator|=
name|stoppos
expr_stmt|;
name|best
operator|=
name|p
expr_stmt|;
block|}
name|sched_data
operator|.
name|packet
operator|=
name|best
expr_stmt|;
name|cycle_end_fill_slots
argument_list|(
name|dump
argument_list|)
expr_stmt|;
while|while
condition|(
name|sched_data
operator|.
name|cur
operator|<
name|best_stop
condition|)
block|{
name|sched_data
operator|.
name|types
index|[
name|sched_data
operator|.
name|cur
index|]
operator|=
name|best
operator|->
name|t
index|[
name|sched_data
operator|.
name|cur
index|]
expr_stmt|;
name|sched_data
operator|.
name|insns
index|[
name|sched_data
operator|.
name|cur
index|]
operator|=
literal|0
expr_stmt|;
name|sched_data
operator|.
name|stopbit
index|[
name|sched_data
operator|.
name|cur
index|]
operator|=
literal|0
expr_stmt|;
name|sched_data
operator|.
name|cur
operator|++
expr_stmt|;
block|}
name|sched_data
operator|.
name|stopbit
index|[
name|sched_data
operator|.
name|cur
operator|-
literal|1
index|]
operator|=
literal|1
expr_stmt|;
name|sched_data
operator|.
name|first_slot
operator|=
name|best_stop
expr_stmt|;
if|if
condition|(
name|dump
condition|)
name|dump_current_packet
argument_list|(
name|dump
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If necessary, perform one or two rotations on the scheduling state.      This should only be called if we are starting a new cycle.  */
end_comment

begin_function
specifier|static
name|void
name|maybe_rotate
parameter_list|(
name|dump
parameter_list|)
name|FILE
modifier|*
name|dump
decl_stmt|;
block|{
if|if
condition|(
name|sched_data
operator|.
name|cur
operator|==
literal|6
condition|)
name|rotate_two_bundles
argument_list|(
name|dump
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sched_data
operator|.
name|cur
operator|>=
literal|3
condition|)
name|rotate_one_bundle
argument_list|(
name|dump
argument_list|)
expr_stmt|;
name|sched_data
operator|.
name|first_slot
operator|=
name|sched_data
operator|.
name|cur
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The clock cycle when ia64_sched_reorder was last called.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|prev_cycle
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The first insn scheduled in the previous cycle.  This is the saved    value of sched_data.first_slot.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|prev_first
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The last insn that has been scheduled.  At the start of a new cycle    we know that we can emit new insns after it; the main scheduling code    has already emitted a cycle_display insn after it and is using that    as its current last insn.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|last_issued
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Emit NOPs to fill the delay between PREV_CYCLE and CLOCK_VAR.  Used to    pad out the delay between MM (shifts, etc.) and integer operations.  */
end_comment

begin_function
specifier|static
name|void
name|nop_cycles_until
parameter_list|(
name|clock_var
parameter_list|,
name|dump
parameter_list|)
name|int
name|clock_var
decl_stmt|;
name|FILE
modifier|*
name|dump
decl_stmt|;
block|{
name|int
name|prev_clock
init|=
name|prev_cycle
decl_stmt|;
name|int
name|cycles_left
init|=
name|clock_var
operator|-
name|prev_clock
decl_stmt|;
comment|/* Finish the previous cycle; pad it out with NOPs.  */
if|if
condition|(
name|sched_data
operator|.
name|cur
operator|==
literal|3
condition|)
block|{
name|rtx
name|t
init|=
name|gen_insn_group_barrier
argument_list|(
name|GEN_INT
argument_list|(
literal|3
argument_list|)
argument_list|)
decl_stmt|;
name|last_issued
operator|=
name|emit_insn_after
argument_list|(
name|t
argument_list|,
name|last_issued
argument_list|)
expr_stmt|;
name|maybe_rotate
argument_list|(
name|dump
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sched_data
operator|.
name|cur
operator|>
literal|0
condition|)
block|{
name|int
name|need_stop
init|=
literal|0
decl_stmt|;
name|int
name|split
init|=
name|itanium_split_issue
argument_list|(
name|sched_data
operator|.
name|packet
argument_list|,
name|prev_first
argument_list|)
decl_stmt|;
if|if
condition|(
name|sched_data
operator|.
name|cur
operator|<
literal|3
operator|&&
name|split
operator|>
literal|3
condition|)
block|{
name|split
operator|=
literal|3
expr_stmt|;
name|need_stop
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|split
operator|>
name|sched_data
operator|.
name|cur
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|sched_data
operator|.
name|cur
init|;
name|i
operator|<
name|split
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|t
decl_stmt|;
name|t
operator|=
name|gen_nop_type
argument_list|(
name|sched_data
operator|.
name|packet
operator|->
name|t
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|last_issued
operator|=
name|emit_insn_after
argument_list|(
name|t
argument_list|,
name|last_issued
argument_list|)
expr_stmt|;
name|sched_data
operator|.
name|types
index|[
name|i
index|]
operator|=
name|sched_data
operator|.
name|packet
operator|->
name|t
index|[
name|sched_data
operator|.
name|cur
index|]
expr_stmt|;
name|sched_data
operator|.
name|insns
index|[
name|i
index|]
operator|=
name|last_issued
expr_stmt|;
name|sched_data
operator|.
name|stopbit
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|sched_data
operator|.
name|cur
operator|=
name|split
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|need_stop
operator|&&
name|sched_data
operator|.
name|cur
operator|>
literal|0
operator|&&
name|sched_data
operator|.
name|cur
operator|<
literal|6
operator|&&
name|cycles_left
operator|>
literal|1
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|sched_data
operator|.
name|cur
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|t
decl_stmt|;
name|t
operator|=
name|gen_nop_type
argument_list|(
name|sched_data
operator|.
name|packet
operator|->
name|t
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|last_issued
operator|=
name|emit_insn_after
argument_list|(
name|t
argument_list|,
name|last_issued
argument_list|)
expr_stmt|;
name|sched_data
operator|.
name|types
index|[
name|i
index|]
operator|=
name|sched_data
operator|.
name|packet
operator|->
name|t
index|[
name|sched_data
operator|.
name|cur
index|]
expr_stmt|;
name|sched_data
operator|.
name|insns
index|[
name|i
index|]
operator|=
name|last_issued
expr_stmt|;
name|sched_data
operator|.
name|stopbit
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|sched_data
operator|.
name|cur
operator|=
literal|6
expr_stmt|;
name|cycles_left
operator|--
expr_stmt|;
name|need_stop
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|need_stop
operator|||
name|sched_data
operator|.
name|cur
operator|==
literal|6
condition|)
block|{
name|rtx
name|t
init|=
name|gen_insn_group_barrier
argument_list|(
name|GEN_INT
argument_list|(
literal|3
argument_list|)
argument_list|)
decl_stmt|;
name|last_issued
operator|=
name|emit_insn_after
argument_list|(
name|t
argument_list|,
name|last_issued
argument_list|)
expr_stmt|;
block|}
name|maybe_rotate
argument_list|(
name|dump
argument_list|)
expr_stmt|;
block|}
name|cycles_left
operator|--
expr_stmt|;
while|while
condition|(
name|cycles_left
operator|>
literal|0
condition|)
block|{
name|rtx
name|t
init|=
name|gen_bundle_selector
argument_list|(
name|GEN_INT
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|last_issued
operator|=
name|emit_insn_after
argument_list|(
name|t
argument_list|,
name|last_issued
argument_list|)
expr_stmt|;
name|t
operator|=
name|gen_nop_type
argument_list|(
name|TYPE_M
argument_list|)
expr_stmt|;
name|last_issued
operator|=
name|emit_insn_after
argument_list|(
name|t
argument_list|,
name|last_issued
argument_list|)
expr_stmt|;
name|t
operator|=
name|gen_nop_type
argument_list|(
name|TYPE_I
argument_list|)
expr_stmt|;
name|last_issued
operator|=
name|emit_insn_after
argument_list|(
name|t
argument_list|,
name|last_issued
argument_list|)
expr_stmt|;
if|if
condition|(
name|cycles_left
operator|>
literal|1
condition|)
block|{
name|t
operator|=
name|gen_insn_group_barrier
argument_list|(
name|GEN_INT
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|last_issued
operator|=
name|emit_insn_after
argument_list|(
name|t
argument_list|,
name|last_issued
argument_list|)
expr_stmt|;
name|cycles_left
operator|--
expr_stmt|;
block|}
name|t
operator|=
name|gen_nop_type
argument_list|(
name|TYPE_I
argument_list|)
expr_stmt|;
name|last_issued
operator|=
name|emit_insn_after
argument_list|(
name|t
argument_list|,
name|last_issued
argument_list|)
expr_stmt|;
name|t
operator|=
name|gen_insn_group_barrier
argument_list|(
name|GEN_INT
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|last_issued
operator|=
name|emit_insn_after
argument_list|(
name|t
argument_list|,
name|last_issued
argument_list|)
expr_stmt|;
name|cycles_left
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* We are about to being issuing insns for this clock cycle.    Override the default sort algorithm to better slot instructions.  */
end_comment

begin_function
specifier|static
name|int
name|ia64_internal_sched_reorder
parameter_list|(
name|dump
parameter_list|,
name|sched_verbose
parameter_list|,
name|ready
parameter_list|,
name|pn_ready
parameter_list|,
name|reorder_type
parameter_list|,
name|clock_var
parameter_list|)
name|FILE
modifier|*
name|dump
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|sched_verbose
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|rtx
modifier|*
name|ready
decl_stmt|;
name|int
modifier|*
name|pn_ready
decl_stmt|;
name|int
name|reorder_type
decl_stmt|,
name|clock_var
decl_stmt|;
block|{
name|int
name|n_asms
decl_stmt|;
name|int
name|n_ready
init|=
operator|*
name|pn_ready
decl_stmt|;
name|rtx
modifier|*
name|e_ready
init|=
name|ready
operator|+
name|n_ready
decl_stmt|;
name|rtx
modifier|*
name|insnp
decl_stmt|;
if|if
condition|(
name|sched_verbose
condition|)
block|{
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"// ia64_sched_reorder (type %d):\n"
argument_list|,
name|reorder_type
argument_list|)
expr_stmt|;
name|dump_current_packet
argument_list|(
name|dump
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reorder_type
operator|==
literal|0
operator|&&
name|clock_var
operator|>
literal|0
operator|&&
name|ia64_final_schedule
condition|)
block|{
for|for
control|(
name|insnp
operator|=
name|ready
init|;
name|insnp
operator|<
name|e_ready
condition|;
name|insnp
operator|++
control|)
block|{
name|rtx
name|insn
init|=
operator|*
name|insnp
decl_stmt|;
name|enum
name|attr_itanium_class
name|t
init|=
name|ia64_safe_itanium_class
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|ITANIUM_CLASS_IALU
operator|||
name|t
operator|==
name|ITANIUM_CLASS_ISHF
operator|||
name|t
operator|==
name|ITANIUM_CLASS_ILOG
operator|||
name|t
operator|==
name|ITANIUM_CLASS_LD
operator|||
name|t
operator|==
name|ITANIUM_CLASS_ST
condition|)
block|{
name|rtx
name|link
decl_stmt|;
for|for
control|(
name|link
operator|=
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|!=
name|REG_DEP_OUTPUT
operator|&&
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|!=
name|REG_DEP_ANTI
condition|)
block|{
name|rtx
name|other
init|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|enum
name|attr_itanium_class
name|t0
init|=
name|ia64_safe_itanium_class
argument_list|(
name|other
argument_list|)
decl_stmt|;
if|if
condition|(
name|t0
operator|==
name|ITANIUM_CLASS_MMSHF
operator|||
name|t0
operator|==
name|ITANIUM_CLASS_MMMUL
condition|)
block|{
name|nop_cycles_until
argument_list|(
name|clock_var
argument_list|,
name|sched_verbose
condition|?
name|dump
else|:
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
block|}
block|}
block|}
name|out
label|:
name|prev_first
operator|=
name|sched_data
operator|.
name|first_slot
expr_stmt|;
name|prev_cycle
operator|=
name|clock_var
expr_stmt|;
if|if
condition|(
name|reorder_type
operator|==
literal|0
condition|)
name|maybe_rotate
argument_list|(
name|sched_verbose
condition|?
name|dump
else|:
name|NULL
argument_list|)
expr_stmt|;
comment|/* First, move all USEs, CLOBBERs and other crud out of the way.  */
name|n_asms
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|insnp
operator|=
name|ready
init|;
name|insnp
operator|<
name|e_ready
condition|;
name|insnp
operator|++
control|)
if|if
condition|(
name|insnp
operator|<
name|e_ready
condition|)
block|{
name|rtx
name|insn
init|=
operator|*
name|insnp
decl_stmt|;
name|enum
name|attr_type
name|t
init|=
name|ia64_safe_type
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|TYPE_UNKNOWN
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ASM_INPUT
operator|||
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|rtx
name|lowest
init|=
name|ready
index|[
name|n_asms
index|]
decl_stmt|;
name|ready
index|[
name|n_asms
index|]
operator|=
name|insn
expr_stmt|;
operator|*
name|insnp
operator|=
name|lowest
expr_stmt|;
name|n_asms
operator|++
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|highest
init|=
name|ready
index|[
name|n_ready
operator|-
literal|1
index|]
decl_stmt|;
name|ready
index|[
name|n_ready
operator|-
literal|1
index|]
operator|=
name|insn
expr_stmt|;
operator|*
name|insnp
operator|=
name|highest
expr_stmt|;
if|if
condition|(
name|ia64_final_schedule
operator|&&
name|group_barrier_needed_p
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|schedule_stop
argument_list|(
name|sched_verbose
condition|?
name|dump
else|:
name|NULL
argument_list|)
expr_stmt|;
name|sched_data
operator|.
name|last_was_stop
operator|=
literal|1
expr_stmt|;
name|maybe_rotate
argument_list|(
name|sched_verbose
condition|?
name|dump
else|:
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
block|}
block|}
if|if
condition|(
name|n_asms
operator|<
name|n_ready
condition|)
block|{
comment|/* Some normal insns to process.  Skip the asms.  */
name|ready
operator|+=
name|n_asms
expr_stmt|;
name|n_ready
operator|-=
name|n_asms
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n_ready
operator|>
literal|0
condition|)
block|{
comment|/* Only asm insns left.  */
if|if
condition|(
name|ia64_final_schedule
operator|&&
name|group_barrier_needed_p
argument_list|(
name|ready
index|[
name|n_ready
operator|-
literal|1
index|]
argument_list|)
condition|)
block|{
name|schedule_stop
argument_list|(
name|sched_verbose
condition|?
name|dump
else|:
name|NULL
argument_list|)
expr_stmt|;
name|sched_data
operator|.
name|last_was_stop
operator|=
literal|1
expr_stmt|;
name|maybe_rotate
argument_list|(
name|sched_verbose
condition|?
name|dump
else|:
name|NULL
argument_list|)
expr_stmt|;
block|}
name|cycle_end_fill_slots
argument_list|(
name|sched_verbose
condition|?
name|dump
else|:
name|NULL
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|ia64_final_schedule
condition|)
block|{
name|int
name|nr_need_stop
init|=
literal|0
decl_stmt|;
for|for
control|(
name|insnp
operator|=
name|ready
init|;
name|insnp
operator|<
name|e_ready
condition|;
name|insnp
operator|++
control|)
if|if
condition|(
name|safe_group_barrier_needed_p
argument_list|(
operator|*
name|insnp
argument_list|)
condition|)
name|nr_need_stop
operator|++
expr_stmt|;
comment|/* Schedule a stop bit if           - all insns require a stop bit, or           - we are starting a new cycle and _any_ insns require a stop bit.          The reason for the latter is that if our schedule is accurate, then          the additional stop won't decrease performance at this point (since 	 there's a split issue at this point anyway), but it gives us more          freedom when scheduling the currently ready insns.  */
if|if
condition|(
operator|(
name|reorder_type
operator|==
literal|0
operator|&&
name|nr_need_stop
operator|)
operator|||
operator|(
name|reorder_type
operator|==
literal|1
operator|&&
name|n_ready
operator|==
name|nr_need_stop
operator|)
condition|)
block|{
name|schedule_stop
argument_list|(
name|sched_verbose
condition|?
name|dump
else|:
name|NULL
argument_list|)
expr_stmt|;
name|sched_data
operator|.
name|last_was_stop
operator|=
literal|1
expr_stmt|;
name|maybe_rotate
argument_list|(
name|sched_verbose
condition|?
name|dump
else|:
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|reorder_type
operator|==
literal|1
condition|)
return|return
literal|0
return|;
block|}
else|else
block|{
name|int
name|deleted
init|=
literal|0
decl_stmt|;
name|insnp
operator|=
name|e_ready
expr_stmt|;
comment|/* Move down everything that needs a stop bit, preserving relative 	     order.  */
while|while
condition|(
name|insnp
operator|--
operator|>
name|ready
operator|+
name|deleted
condition|)
while|while
condition|(
name|insnp
operator|>=
name|ready
operator|+
name|deleted
condition|)
block|{
name|rtx
name|insn
init|=
operator|*
name|insnp
decl_stmt|;
if|if
condition|(
operator|!
name|safe_group_barrier_needed_p
argument_list|(
name|insn
argument_list|)
condition|)
break|break;
name|memmove
argument_list|(
name|ready
operator|+
literal|1
argument_list|,
name|ready
argument_list|,
operator|(
name|insnp
operator|-
name|ready
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|ready
operator|=
name|insn
expr_stmt|;
name|deleted
operator|++
expr_stmt|;
block|}
name|n_ready
operator|-=
name|deleted
expr_stmt|;
name|ready
operator|+=
name|deleted
expr_stmt|;
if|if
condition|(
name|deleted
operator|!=
name|nr_need_stop
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|itanium_reorder
argument_list|(
name|sched_verbose
condition|?
name|dump
else|:
name|NULL
argument_list|,
name|ready
argument_list|,
name|e_ready
argument_list|,
name|reorder_type
operator|==
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ia64_sched_reorder
parameter_list|(
name|dump
parameter_list|,
name|sched_verbose
parameter_list|,
name|ready
parameter_list|,
name|pn_ready
parameter_list|,
name|clock_var
parameter_list|)
name|FILE
modifier|*
name|dump
decl_stmt|;
name|int
name|sched_verbose
decl_stmt|;
name|rtx
modifier|*
name|ready
decl_stmt|;
name|int
modifier|*
name|pn_ready
decl_stmt|;
name|int
name|clock_var
decl_stmt|;
block|{
return|return
name|ia64_internal_sched_reorder
argument_list|(
name|dump
argument_list|,
name|sched_verbose
argument_list|,
name|ready
argument_list|,
name|pn_ready
argument_list|,
literal|0
argument_list|,
name|clock_var
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Like ia64_sched_reorder, but called after issuing each insn.    Override the default sort algorithm to better slot instructions.  */
end_comment

begin_function
specifier|static
name|int
name|ia64_sched_reorder2
parameter_list|(
name|dump
parameter_list|,
name|sched_verbose
parameter_list|,
name|ready
parameter_list|,
name|pn_ready
parameter_list|,
name|clock_var
parameter_list|)
name|FILE
modifier|*
name|dump
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|sched_verbose
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|rtx
modifier|*
name|ready
decl_stmt|;
name|int
modifier|*
name|pn_ready
decl_stmt|;
name|int
name|clock_var
decl_stmt|;
block|{
if|if
condition|(
name|sched_data
operator|.
name|last_was_stop
condition|)
return|return
literal|0
return|;
comment|/* Detect one special case and try to optimize it.      If we have 1.M;;MI 2.MIx, and slots 2.1 (M) and 2.2 (I) are both NOPs,      then we can get better code by transforming this to 1.MFB;; 2.MIx.  */
if|if
condition|(
name|sched_data
operator|.
name|first_slot
operator|==
literal|1
operator|&&
name|sched_data
operator|.
name|stopbit
index|[
literal|0
index|]
operator|&&
operator|(
operator|(
name|sched_data
operator|.
name|cur
operator|==
literal|4
operator|&&
operator|(
name|sched_data
operator|.
name|types
index|[
literal|1
index|]
operator|==
name|TYPE_M
operator|||
name|sched_data
operator|.
name|types
index|[
literal|1
index|]
operator|==
name|TYPE_A
operator|)
operator|&&
operator|(
name|sched_data
operator|.
name|types
index|[
literal|2
index|]
operator|==
name|TYPE_I
operator|||
name|sched_data
operator|.
name|types
index|[
literal|2
index|]
operator|==
name|TYPE_A
operator|)
operator|&&
operator|(
name|sched_data
operator|.
name|types
index|[
literal|3
index|]
operator|!=
name|TYPE_M
operator|&&
name|sched_data
operator|.
name|types
index|[
literal|3
index|]
operator|!=
name|TYPE_A
operator|)
operator|)
operator|||
operator|(
name|sched_data
operator|.
name|cur
operator|==
literal|3
operator|&&
operator|(
name|sched_data
operator|.
name|types
index|[
literal|1
index|]
operator|==
name|TYPE_M
operator|||
name|sched_data
operator|.
name|types
index|[
literal|1
index|]
operator|==
name|TYPE_A
operator|)
operator|&&
operator|(
name|sched_data
operator|.
name|types
index|[
literal|2
index|]
operator|!=
name|TYPE_M
operator|&&
name|sched_data
operator|.
name|types
index|[
literal|2
index|]
operator|!=
name|TYPE_I
operator|&&
name|sched_data
operator|.
name|types
index|[
literal|2
index|]
operator|!=
name|TYPE_A
operator|)
operator|)
operator|)
condition|)
block|{
name|int
name|i
decl_stmt|,
name|best
decl_stmt|;
name|rtx
name|stop
init|=
name|sched_data
operator|.
name|insns
index|[
literal|1
index|]
decl_stmt|;
comment|/* Search backward for the stop bit that must be there.  */
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|insn_code
decl_stmt|;
name|stop
operator|=
name|PREV_INSN
argument_list|(
name|stop
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|stop
argument_list|)
operator|!=
name|INSN
condition|)
name|abort
argument_list|()
expr_stmt|;
name|insn_code
operator|=
name|recog_memoized
argument_list|(
name|stop
argument_list|)
expr_stmt|;
comment|/* Ignore cycle displays and .pred.rel.mutex.  */
if|if
condition|(
name|insn_code
operator|==
name|CODE_FOR_cycle_display
operator|||
name|insn_code
operator|==
name|CODE_FOR_pred_rel_mutex
operator|||
name|insn_code
operator|==
name|CODE_FOR_prologue_use
condition|)
continue|continue;
if|if
condition|(
name|insn_code
operator|==
name|CODE_FOR_insn_group_barrier
condition|)
break|break;
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Adjust the stop bit's slot selector.  */
if|if
condition|(
name|INTVAL
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|stop
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|stop
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|=
name|GEN_INT
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|sched_data
operator|.
name|stopbit
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|sched_data
operator|.
name|stopbit
index|[
literal|2
index|]
operator|=
literal|1
expr_stmt|;
name|sched_data
operator|.
name|types
index|[
literal|5
index|]
operator|=
name|sched_data
operator|.
name|types
index|[
literal|3
index|]
expr_stmt|;
name|sched_data
operator|.
name|types
index|[
literal|4
index|]
operator|=
name|sched_data
operator|.
name|types
index|[
literal|2
index|]
expr_stmt|;
name|sched_data
operator|.
name|types
index|[
literal|3
index|]
operator|=
name|sched_data
operator|.
name|types
index|[
literal|1
index|]
expr_stmt|;
name|sched_data
operator|.
name|insns
index|[
literal|5
index|]
operator|=
name|sched_data
operator|.
name|insns
index|[
literal|3
index|]
expr_stmt|;
name|sched_data
operator|.
name|insns
index|[
literal|4
index|]
operator|=
name|sched_data
operator|.
name|insns
index|[
literal|2
index|]
expr_stmt|;
name|sched_data
operator|.
name|insns
index|[
literal|3
index|]
operator|=
name|sched_data
operator|.
name|insns
index|[
literal|1
index|]
expr_stmt|;
name|sched_data
operator|.
name|stopbit
index|[
literal|5
index|]
operator|=
name|sched_data
operator|.
name|stopbit
index|[
literal|4
index|]
operator|=
name|sched_data
operator|.
name|stopbit
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|sched_data
operator|.
name|cur
operator|+=
literal|2
expr_stmt|;
name|sched_data
operator|.
name|first_slot
operator|=
literal|3
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NR_PACKETS
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|struct
name|ia64_packet
modifier|*
name|p
init|=
name|packets
operator|+
name|i
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|t
index|[
literal|0
index|]
operator|==
name|TYPE_M
operator|&&
name|p
operator|->
name|t
index|[
literal|1
index|]
operator|==
name|TYPE_F
operator|&&
name|p
operator|->
name|t
index|[
literal|2
index|]
operator|==
name|TYPE_B
condition|)
block|{
name|sched_data
operator|.
name|packet
operator|=
name|p
expr_stmt|;
break|break;
block|}
block|}
name|rotate_one_bundle
argument_list|(
name|sched_verbose
condition|?
name|dump
else|:
name|NULL
argument_list|)
expr_stmt|;
name|best
operator|=
literal|6
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NR_PACKETS
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|struct
name|ia64_packet
modifier|*
name|p
init|=
name|packets
operator|+
name|i
decl_stmt|;
name|int
name|split
init|=
name|get_split
argument_list|(
name|p
argument_list|,
name|sched_data
operator|.
name|first_slot
argument_list|)
decl_stmt|;
name|int
name|next
decl_stmt|;
comment|/* Disallow multiway branches here.  */
if|if
condition|(
name|p
operator|->
name|t
index|[
literal|1
index|]
operator|==
name|TYPE_B
condition|)
continue|continue;
if|if
condition|(
name|packet_matches_p
argument_list|(
name|p
argument_list|,
name|split
argument_list|,
operator|&
name|next
argument_list|)
operator|&&
name|next
operator|<
name|best
condition|)
block|{
name|best
operator|=
name|next
expr_stmt|;
name|sched_data
operator|.
name|packet
operator|=
name|p
expr_stmt|;
name|sched_data
operator|.
name|split
operator|=
name|split
expr_stmt|;
block|}
block|}
if|if
condition|(
name|best
operator|==
literal|6
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|pn_ready
operator|>
literal|0
condition|)
block|{
name|int
name|more
init|=
name|ia64_internal_sched_reorder
argument_list|(
name|dump
argument_list|,
name|sched_verbose
argument_list|,
name|ready
argument_list|,
name|pn_ready
argument_list|,
literal|1
argument_list|,
name|clock_var
argument_list|)
decl_stmt|;
if|if
condition|(
name|more
condition|)
return|return
name|more
return|;
comment|/* Did we schedule a stop?  If so, finish this cycle.  */
if|if
condition|(
name|sched_data
operator|.
name|cur
operator|==
name|sched_data
operator|.
name|first_slot
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|sched_verbose
condition|)
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"//   Can't issue more this cycle; updating type array.\n"
argument_list|)
expr_stmt|;
name|cycle_end_fill_slots
argument_list|(
name|sched_verbose
condition|?
name|dump
else|:
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sched_verbose
condition|)
name|dump_current_packet
argument_list|(
name|dump
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* We are about to issue INSN.  Return the number of insns left on the    ready queue that can be issued this cycle.  */
end_comment

begin_function
specifier|static
name|int
name|ia64_variable_issue
parameter_list|(
name|dump
parameter_list|,
name|sched_verbose
parameter_list|,
name|insn
parameter_list|,
name|can_issue_more
parameter_list|)
name|FILE
modifier|*
name|dump
decl_stmt|;
name|int
name|sched_verbose
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|can_issue_more
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|enum
name|attr_type
name|t
init|=
name|ia64_safe_type
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|last_issued
operator|=
name|insn
expr_stmt|;
if|if
condition|(
name|sched_data
operator|.
name|last_was_stop
condition|)
block|{
name|int
name|t
init|=
name|sched_data
operator|.
name|first_slot
decl_stmt|;
if|if
condition|(
name|t
operator|==
literal|0
condition|)
name|t
operator|=
literal|3
expr_stmt|;
name|ia64_emit_insn_before
argument_list|(
name|gen_insn_group_barrier
argument_list|(
name|GEN_INT
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|init_insn_group_barriers
argument_list|()
expr_stmt|;
name|sched_data
operator|.
name|last_was_stop
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|==
name|TYPE_UNKNOWN
condition|)
block|{
if|if
condition|(
name|sched_verbose
condition|)
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"// Ignoring type %s\n"
argument_list|,
name|type_names
index|[
name|t
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ASM_INPUT
operator|||
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
block|{
comment|/* This must be some kind of asm.  Clear the scheduling state.  */
name|rotate_two_bundles
argument_list|(
name|sched_verbose
condition|?
name|dump
else|:
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ia64_final_schedule
condition|)
name|group_barrier_needed_p
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
comment|/* This is _not_ just a sanity check.  group_barrier_needed_p will update      important state info.  Don't delete this test.  */
if|if
condition|(
name|ia64_final_schedule
operator|&&
name|group_barrier_needed_p
argument_list|(
name|insn
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|sched_data
operator|.
name|stopbit
index|[
name|sched_data
operator|.
name|cur
index|]
operator|=
literal|0
expr_stmt|;
name|sched_data
operator|.
name|insns
index|[
name|sched_data
operator|.
name|cur
index|]
operator|=
name|insn
expr_stmt|;
name|sched_data
operator|.
name|types
index|[
name|sched_data
operator|.
name|cur
index|]
operator|=
name|t
expr_stmt|;
name|sched_data
operator|.
name|cur
operator|++
expr_stmt|;
if|if
condition|(
name|sched_verbose
condition|)
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"// Scheduling insn %d of type %s\n"
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|,
name|type_names
index|[
name|t
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|&&
name|ia64_final_schedule
condition|)
block|{
name|schedule_stop
argument_list|(
name|sched_verbose
condition|?
name|dump
else|:
name|NULL
argument_list|)
expr_stmt|;
name|sched_data
operator|.
name|last_was_stop
operator|=
literal|1
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Free data allocated by ia64_sched_init.  */
end_comment

begin_function
specifier|static
name|void
name|ia64_sched_finish
parameter_list|(
name|dump
parameter_list|,
name|sched_verbose
parameter_list|)
name|FILE
modifier|*
name|dump
decl_stmt|;
name|int
name|sched_verbose
decl_stmt|;
block|{
if|if
condition|(
name|sched_verbose
condition|)
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"// Finishing schedule.\n"
argument_list|)
expr_stmt|;
name|rotate_two_bundles
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sched_types
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sched_ready
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|ia64_cycle_display
parameter_list|(
name|clock
parameter_list|,
name|last
parameter_list|)
name|int
name|clock
decl_stmt|;
name|rtx
name|last
decl_stmt|;
block|{
if|if
condition|(
name|ia64_final_schedule
condition|)
return|return
name|emit_insn_after
argument_list|(
name|gen_cycle_display
argument_list|(
name|GEN_INT
argument_list|(
name|clock
argument_list|)
argument_list|)
argument_list|,
name|last
argument_list|)
return|;
else|else
return|return
name|last
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit pseudo-ops for the assembler to describe predicate relations.    At present this assumes that we only consider predicate pairs to    be mutex, and that the assembler can deduce proper values from    straight-line code.  */
end_comment

begin_function
specifier|static
name|void
name|emit_predicate_relation_info
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|n_basic_blocks
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|basic_block
name|bb
init|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|int
name|r
decl_stmt|;
name|rtx
name|head
init|=
name|bb
operator|->
name|head
decl_stmt|;
comment|/* We only need such notes at code labels.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|head
argument_list|)
operator|!=
name|CODE_LABEL
condition|)
continue|continue;
if|if
condition|(
name|GET_CODE
argument_list|(
name|NEXT_INSN
argument_list|(
name|head
argument_list|)
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|NEXT_INSN
argument_list|(
name|head
argument_list|)
argument_list|)
operator|==
name|NOTE_INSN_BASIC_BLOCK
condition|)
name|head
operator|=
name|NEXT_INSN
argument_list|(
name|head
argument_list|)
expr_stmt|;
for|for
control|(
name|r
operator|=
name|PR_REG
argument_list|(
literal|0
argument_list|)
init|;
name|r
operator|<
name|PR_REG
argument_list|(
literal|64
argument_list|)
condition|;
name|r
operator|+=
literal|2
control|)
if|if
condition|(
name|REGNO_REG_SET_P
argument_list|(
name|bb
operator|->
name|global_live_at_start
argument_list|,
name|r
argument_list|)
condition|)
block|{
name|rtx
name|p
init|=
name|gen_rtx_REG
argument_list|(
name|BImode
argument_list|,
name|r
argument_list|)
decl_stmt|;
name|rtx
name|n
init|=
name|emit_insn_after
argument_list|(
name|gen_pred_rel_mutex
argument_list|(
name|p
argument_list|)
argument_list|,
name|head
argument_list|)
decl_stmt|;
if|if
condition|(
name|head
operator|==
name|bb
operator|->
name|end
condition|)
name|bb
operator|->
name|end
operator|=
name|n
expr_stmt|;
name|head
operator|=
name|n
expr_stmt|;
block|}
block|}
comment|/* Look for conditional calls that do not return, and protect predicate      relations around them.  Otherwise the assembler will assume the call      returns, and complain about uses of call-clobbered predicates after      the call.  */
for|for
control|(
name|i
operator|=
name|n_basic_blocks
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|basic_block
name|bb
init|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|rtx
name|insn
init|=
name|bb
operator|->
name|head
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|COND_EXEC
operator|&&
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_NORETURN
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
block|{
name|rtx
name|b
init|=
name|emit_insn_before
argument_list|(
name|gen_safe_across_calls_all
argument_list|()
argument_list|,
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|a
init|=
name|emit_insn_after
argument_list|(
name|gen_safe_across_calls_normal
argument_list|()
argument_list|,
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|bb
operator|->
name|head
operator|==
name|insn
condition|)
name|bb
operator|->
name|head
operator|=
name|b
expr_stmt|;
if|if
condition|(
name|bb
operator|->
name|end
operator|==
name|insn
condition|)
name|bb
operator|->
name|end
operator|=
name|a
expr_stmt|;
block|}
if|if
condition|(
name|insn
operator|==
name|bb
operator|->
name|end
condition|)
break|break;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Generate a NOP instruction of type T.  We will never generate L type    nops.  */
end_comment

begin_function
specifier|static
name|rtx
name|gen_nop_type
parameter_list|(
name|t
parameter_list|)
name|enum
name|attr_type
name|t
decl_stmt|;
block|{
switch|switch
condition|(
name|t
condition|)
block|{
case|case
name|TYPE_M
case|:
return|return
name|gen_nop_m
argument_list|()
return|;
case|case
name|TYPE_I
case|:
return|return
name|gen_nop_i
argument_list|()
return|;
case|case
name|TYPE_B
case|:
return|return
name|gen_nop_b
argument_list|()
return|;
case|case
name|TYPE_F
case|:
return|return
name|gen_nop_f
argument_list|()
return|;
case|case
name|TYPE_X
case|:
return|return
name|gen_nop_x
argument_list|()
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* After the last scheduling pass, fill in NOPs.  It's easier to do this    here than while scheduling.  */
end_comment

begin_function
specifier|static
name|void
name|ia64_emit_nops
parameter_list|()
block|{
name|rtx
name|insn
decl_stmt|;
specifier|const
name|struct
name|bundle
modifier|*
name|b
init|=
literal|0
decl_stmt|;
name|int
name|bundle_pos
init|=
literal|0
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|rtx
name|pat
decl_stmt|;
name|enum
name|attr_type
name|t
decl_stmt|;
name|pat
operator|=
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|?
name|PATTERN
argument_list|(
name|insn
argument_list|)
else|:
name|const0_rtx
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|CLOBBER
condition|)
continue|continue;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|UNSPEC
operator|&&
name|XINT
argument_list|(
name|pat
argument_list|,
literal|1
argument_list|)
operator|==
literal|22
operator|)
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
block|{
if|if
condition|(
name|b
condition|)
while|while
condition|(
name|bundle_pos
operator|<
literal|3
condition|)
block|{
name|emit_insn_before
argument_list|(
name|gen_nop_type
argument_list|(
name|b
operator|->
name|t
index|[
name|bundle_pos
index|]
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|bundle_pos
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|CODE_LABEL
condition|)
name|b
operator|=
name|bundle
operator|+
name|INTVAL
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|b
operator|=
literal|0
expr_stmt|;
name|bundle_pos
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|UNSPEC_VOLATILE
operator|&&
name|XINT
argument_list|(
name|pat
argument_list|,
literal|1
argument_list|)
operator|==
literal|2
condition|)
block|{
name|int
name|t
init|=
name|INTVAL
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|b
condition|)
while|while
condition|(
name|bundle_pos
operator|<
name|t
condition|)
block|{
name|emit_insn_before
argument_list|(
name|gen_nop_type
argument_list|(
name|b
operator|->
name|t
index|[
name|bundle_pos
index|]
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|bundle_pos
operator|++
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|bundle_pos
operator|==
literal|3
condition|)
name|b
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|b
operator|&&
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|t
operator|=
name|ia64_safe_type
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|>=
literal|0
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ASM_INPUT
condition|)
block|{
while|while
condition|(
name|bundle_pos
operator|<
literal|3
condition|)
block|{
name|emit_insn_before
argument_list|(
name|gen_nop_type
argument_list|(
name|b
operator|->
name|t
index|[
name|bundle_pos
index|]
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|bundle_pos
operator|++
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|t
operator|==
name|TYPE_UNKNOWN
condition|)
continue|continue;
while|while
condition|(
name|bundle_pos
operator|<
literal|3
condition|)
block|{
if|if
condition|(
name|t
operator|==
name|b
operator|->
name|t
index|[
name|bundle_pos
index|]
operator|||
operator|(
name|t
operator|==
name|TYPE_A
operator|&&
operator|(
name|b
operator|->
name|t
index|[
name|bundle_pos
index|]
operator|==
name|TYPE_M
operator|||
name|b
operator|->
name|t
index|[
name|bundle_pos
index|]
operator|==
name|TYPE_I
operator|)
operator|)
condition|)
break|break;
name|emit_insn_before
argument_list|(
name|gen_nop_type
argument_list|(
name|b
operator|->
name|t
index|[
name|bundle_pos
index|]
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|bundle_pos
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|bundle_pos
operator|<
literal|3
condition|)
name|bundle_pos
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Perform machine dependent operations on the rtl chain INSNS.  */
end_comment

begin_function
name|void
name|ia64_reorg
parameter_list|(
name|insns
parameter_list|)
name|rtx
name|insns
decl_stmt|;
block|{
comment|/* If optimizing, we'll have split before scheduling.  */
if|if
condition|(
name|optimize
operator|==
literal|0
condition|)
name|split_all_insns_noflow
argument_list|()
expr_stmt|;
comment|/* Make sure the CFG and global_live_at_start are correct      for emit_predicate_relation_info.  */
name|find_basic_blocks
argument_list|(
name|insns
argument_list|,
name|max_reg_num
argument_list|()
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|life_analysis
argument_list|(
name|insns
argument_list|,
name|NULL
argument_list|,
name|PROP_DEATH_NOTES
argument_list|)
expr_stmt|;
if|if
condition|(
name|ia64_flag_schedule_insns2
condition|)
block|{
name|timevar_push
argument_list|(
name|TV_SCHED2
argument_list|)
expr_stmt|;
name|ia64_final_schedule
operator|=
literal|1
expr_stmt|;
name|schedule_ebbs
argument_list|(
name|rtl_dump_file
argument_list|)
expr_stmt|;
name|ia64_final_schedule
operator|=
literal|0
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_SCHED2
argument_list|)
expr_stmt|;
comment|/* This relies on the NOTE_INSN_BASIC_BLOCK notes to be in the same 	 place as they were during scheduling.  */
name|emit_insn_group_barriers
argument_list|(
name|rtl_dump_file
argument_list|,
name|insns
argument_list|)
expr_stmt|;
name|ia64_emit_nops
argument_list|()
expr_stmt|;
block|}
else|else
name|emit_all_insn_group_barriers
argument_list|(
name|rtl_dump_file
argument_list|,
name|insns
argument_list|)
expr_stmt|;
comment|/* A call must not be the last instruction in a function, so that the      return address is still within the function, so that unwinding works      properly.  Note that IA-64 differs from dwarf2 on this point.  */
if|if
condition|(
name|flag_unwind_tables
operator|||
operator|(
name|flag_exceptions
operator|&&
operator|!
name|USING_SJLJ_EXCEPTIONS
operator|)
condition|)
block|{
name|rtx
name|insn
decl_stmt|;
name|int
name|saw_stop
init|=
literal|0
decl_stmt|;
name|insn
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
name|insn
operator|=
name|prev_active_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|UNSPEC_VOLATILE
operator|&&
name|XINT
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
literal|2
condition|)
block|{
name|saw_stop
operator|=
literal|1
expr_stmt|;
name|insn
operator|=
name|prev_active_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
if|if
condition|(
operator|!
name|saw_stop
condition|)
name|emit_insn
argument_list|(
name|gen_insn_group_barrier
argument_list|(
name|GEN_INT
argument_list|(
literal|3
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_break_f
argument_list|()
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_insn_group_barrier
argument_list|(
name|GEN_INT
argument_list|(
literal|3
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|fixup_errata
argument_list|()
expr_stmt|;
name|emit_predicate_relation_info
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return true if REGNO is used by the epilogue.  */
end_comment

begin_function
name|int
name|ia64_epilogue_uses
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
switch|switch
condition|(
name|regno
condition|)
block|{
case|case
name|R_GR
argument_list|(
literal|1
argument_list|)
case|:
comment|/* When a function makes a call through a function descriptor, we          will write a (potentially) new value to "gp".  After returning          from such a call, we need to make sure the function restores the          original gp-value, even if the function itself does not use the          gp anymore.  */
return|return
operator|(
name|TARGET_CONST_GP
operator|&&
operator|!
operator|(
name|TARGET_AUTO_PIC
operator|||
name|TARGET_NO_PIC
operator|)
operator|)
return|;
case|case
name|IN_REG
argument_list|(
literal|0
argument_list|)
case|:
case|case
name|IN_REG
argument_list|(
literal|1
argument_list|)
case|:
case|case
name|IN_REG
argument_list|(
literal|2
argument_list|)
case|:
case|case
name|IN_REG
argument_list|(
literal|3
argument_list|)
case|:
case|case
name|IN_REG
argument_list|(
literal|4
argument_list|)
case|:
case|case
name|IN_REG
argument_list|(
literal|5
argument_list|)
case|:
case|case
name|IN_REG
argument_list|(
literal|6
argument_list|)
case|:
case|case
name|IN_REG
argument_list|(
literal|7
argument_list|)
case|:
comment|/* For functions defined with the syscall_linkage attribute, all 	 input registers are marked as live at all function exits.  This 	 prevents the register allocator from using the input registers, 	 which in turn makes it possible to restart a system call after 	 an interrupt without having to save/restore the input registers. 	 This also prevents kernel data from leaking to application code.  */
return|return
name|lookup_attribute
argument_list|(
literal|"syscall_linkage"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|NULL
return|;
case|case
name|R_BR
argument_list|(
literal|0
argument_list|)
case|:
comment|/* Conditional return patterns can't represent the use of `b0' as          the return address, so we force the value live this way.  */
return|return
literal|1
return|;
case|case
name|AR_PFS_REGNUM
case|:
comment|/* Likewise for ar.pfs, which is used by br.ret.  */
return|return
literal|1
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Table of valid machine attributes.  */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|attribute_spec
name|ia64_attribute_table
index|[]
init|=
block|{
comment|/* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */
block|{
literal|"syscall_linkage"
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|true
block|,
name|true
block|,
name|NULL
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* For ia64, SYMBOL_REF_FLAG set means that it is a function.     We add @ to the name if this goes in small data/bss.  We can only put    a variable in small data/bss if it is defined in this module or a module    that we are statically linked with.  We can't check the second condition,    but TREE_STATIC gives us the first one.  */
end_comment

begin_comment
comment|/* ??? If we had IPA, we could check the second condition.  We could support    programmer added section attributes if the variable is not defined in this    module.  */
end_comment

begin_comment
comment|/* ??? See the v850 port for a cleaner way to do this.  */
end_comment

begin_comment
comment|/* ??? We could also support own long data here.  Generating movl/add/ld8    instead of addl,ld8/ld8.  This makes the code bigger, but should make the    code faster because there is one less load.  This also includes incomplete    types which can't go in sdata/sbss.  */
end_comment

begin_comment
comment|/* ??? See select_section.  We must put short own readonly variables in    sdata/sbss instead of the more natural rodata, because we can't perform    the DECL_READONLY_SECTION test here.  */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|obstack
modifier|*
name|saveable_obstack
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|ia64_encode_section_info
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|symbol_str
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|SYMBOL_REF_FLAG
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return;
block|}
comment|/* Careful not to prod global register variables.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|VAR_DECL
operator|||
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|MEM
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|SYMBOL_REF
condition|)
return|return;
name|symbol_str
operator|=
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* We assume that -fpic is used only to create a shared library (dso).      With -fpic, no global data can ever be sdata.      Without -fpic, global common uninitialized data can never be sdata, since      it can unify with a real definition in a dso.  */
comment|/* ??? Actually, we can put globals in sdata, as long as we don't use gprel      to access them.  The linker may then be able to do linker relaxation to      optimize references to them.  Currently sdata implies use of gprel.  */
comment|/* We need the DECL_EXTERNAL check for C++.  static class data members get      both TREE_STATIC and DECL_EXTERNAL set, to indicate that they are      statically allocated, but the space is allocated somewhere else.  Such      decls can not be own data.  */
if|if
condition|(
operator|!
name|TARGET_NO_SDATA
operator|&&
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
operator|(
name|DECL_ONE_ONLY
argument_list|(
name|decl
argument_list|)
operator|||
name|DECL_WEAK
argument_list|(
name|decl
argument_list|)
operator|)
operator|&&
operator|!
operator|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|(
name|flag_pic
operator|||
operator|(
name|DECL_COMMON
argument_list|(
name|decl
argument_list|)
operator|&&
operator|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|||
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|error_mark_node
operator|)
operator|)
operator|)
operator|)
comment|/* Either the variable must be declared without a section attribute, 	 or the section must be sdata or sbss.  */
operator|&&
operator|(
name|DECL_SECTION_NAME
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|||
operator|!
name|strcmp
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|DECL_SECTION_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
literal|".sdata"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|DECL_SECTION_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
literal|".sbss"
argument_list|)
operator|)
condition|)
block|{
name|HOST_WIDE_INT
name|size
init|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
comment|/* If the variable has already been defined in the output file, then it 	 is too late to put it in sdata if it wasn't put there in the first 	 place.  The test is here rather than above, because if it is already 	 in sdata, then it can stay there.  */
if|if
condition|(
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
condition|)
empty_stmt|;
comment|/* If this is an incomplete type with size 0, then we can't put it in 	 sdata because it might be too big when completed.  */
elseif|else
if|if
condition|(
name|size
operator|>
literal|0
operator|&&
name|size
operator|<=
operator|(
name|HOST_WIDE_INT
operator|)
name|ia64_section_threshold
operator|&&
name|symbol_str
index|[
literal|0
index|]
operator|!=
name|SDATA_NAME_FLAG_CHAR
condition|)
block|{
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|symbol_str
argument_list|)
decl_stmt|;
name|char
modifier|*
name|newstr
init|=
name|alloca
argument_list|(
name|len
operator|+
literal|1
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
operator|*
name|newstr
operator|=
name|SDATA_NAME_FLAG_CHAR
expr_stmt|;
name|memcpy
argument_list|(
name|newstr
operator|+
literal|1
argument_list|,
name|symbol_str
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|string
operator|=
name|ggc_alloc_string
argument_list|(
name|newstr
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|=
name|string
expr_stmt|;
block|}
block|}
comment|/* This decl is marked as being in small data/bss but it shouldn't      be; one likely explanation for this is that the decl has been      moved into a different section from the one it was in when      ENCODE_SECTION_INFO was first called.  Remove the '@'.  */
elseif|else
if|if
condition|(
name|symbol_str
index|[
literal|0
index|]
operator|==
name|SDATA_NAME_FLAG_CHAR
condition|)
block|{
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|=
name|ggc_strdup
argument_list|(
name|symbol_str
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output assembly directives for prologue regions.  */
end_comment

begin_comment
comment|/* The current basic block number.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|block_num
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True if we need a copy_state command at the start of the next block.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|need_copy_state
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The function emits unwind directives for the start of an epilogue.  */
end_comment

begin_function
specifier|static
name|void
name|process_epilogue
parameter_list|()
block|{
comment|/* If this isn't the last block of the function, then we need to label the      current state, and copy it back in at the start of the next block.  */
if|if
condition|(
name|block_num
operator|!=
name|n_basic_blocks
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.label_state 1\n"
argument_list|)
expr_stmt|;
name|need_copy_state
operator|=
literal|1
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.restore sp\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function processes a SET pattern looking for specific patterns    which result in emitting an assembly directive required for unwinding.  */
end_comment

begin_function
specifier|static
name|int
name|process_set
parameter_list|(
name|asm_out_file
parameter_list|,
name|pat
parameter_list|)
name|FILE
modifier|*
name|asm_out_file
decl_stmt|;
name|rtx
name|pat
decl_stmt|;
block|{
name|rtx
name|src
init|=
name|SET_SRC
argument_list|(
name|pat
argument_list|)
decl_stmt|;
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|pat
argument_list|)
decl_stmt|;
name|int
name|src_regno
decl_stmt|,
name|dest_regno
decl_stmt|;
comment|/* Look for the ALLOC insn.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|UNSPEC_VOLATILE
operator|&&
name|XINT
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
condition|)
block|{
name|dest_regno
operator|=
name|REGNO
argument_list|(
name|dest
argument_list|)
expr_stmt|;
comment|/* If this isn't the final destination for ar.pfs, the alloc 	 shouldn't have been marked frame related.  */
if|if
condition|(
name|dest_regno
operator|!=
name|current_frame_info
operator|.
name|reg_save_ar_pfs
condition|)
name|abort
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.save ar.pfs, r%d\n"
argument_list|,
name|ia64_dbx_register_number
argument_list|(
name|dest_regno
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Look for SP = ....  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|dest
argument_list|)
operator|==
name|STACK_POINTER_REGNUM
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|rtx
name|op0
init|=
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|op0
operator|==
name|dest
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fputs
argument_list|(
literal|"\t.fframe "
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
operator|-
name|INTVAL
argument_list|(
name|op1
argument_list|)
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
else|else
name|process_epilogue
argument_list|()
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|src
argument_list|)
operator|==
name|HARD_FRAME_POINTER_REGNUM
condition|)
name|process_epilogue
argument_list|()
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Register move we need to look at.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|REG
condition|)
block|{
name|src_regno
operator|=
name|REGNO
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|dest_regno
operator|=
name|REGNO
argument_list|(
name|dest
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|src_regno
condition|)
block|{
case|case
name|BR_REG
argument_list|(
literal|0
argument_list|)
case|:
comment|/* Saving return address pointer.  */
if|if
condition|(
name|dest_regno
operator|!=
name|current_frame_info
operator|.
name|reg_save_b0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.save rp, r%d\n"
argument_list|,
name|ia64_dbx_register_number
argument_list|(
name|dest_regno
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|PR_REG
argument_list|(
literal|0
argument_list|)
case|:
if|if
condition|(
name|dest_regno
operator|!=
name|current_frame_info
operator|.
name|reg_save_pr
condition|)
name|abort
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.save pr, r%d\n"
argument_list|,
name|ia64_dbx_register_number
argument_list|(
name|dest_regno
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|AR_UNAT_REGNUM
case|:
if|if
condition|(
name|dest_regno
operator|!=
name|current_frame_info
operator|.
name|reg_save_ar_unat
condition|)
name|abort
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.save ar.unat, r%d\n"
argument_list|,
name|ia64_dbx_register_number
argument_list|(
name|dest_regno
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|AR_LC_REGNUM
case|:
if|if
condition|(
name|dest_regno
operator|!=
name|current_frame_info
operator|.
name|reg_save_ar_lc
condition|)
name|abort
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.save ar.lc, r%d\n"
argument_list|,
name|ia64_dbx_register_number
argument_list|(
name|dest_regno
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|STACK_POINTER_REGNUM
case|:
if|if
condition|(
name|dest_regno
operator|!=
name|HARD_FRAME_POINTER_REGNUM
operator|||
operator|!
name|frame_pointer_needed
condition|)
name|abort
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.vframe r%d\n"
argument_list|,
name|ia64_dbx_register_number
argument_list|(
name|dest_regno
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
default|default:
comment|/* Everything else should indicate being stored to memory.  */
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Memory store we need to look at.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|REG
condition|)
block|{
name|long
name|off
decl_stmt|;
name|rtx
name|base
decl_stmt|;
specifier|const
name|char
modifier|*
name|saveop
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|base
operator|=
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|off
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|base
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|off
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|base
operator|==
name|hard_frame_pointer_rtx
condition|)
block|{
name|saveop
operator|=
literal|".savepsp"
expr_stmt|;
name|off
operator|=
operator|-
name|off
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|base
operator|==
name|stack_pointer_rtx
condition|)
name|saveop
operator|=
literal|".savesp"
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
name|src_regno
operator|=
name|REGNO
argument_list|(
name|src
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|src_regno
condition|)
block|{
case|case
name|BR_REG
argument_list|(
literal|0
argument_list|)
case|:
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_b0
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s rp, %ld\n"
argument_list|,
name|saveop
argument_list|,
name|off
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|PR_REG
argument_list|(
literal|0
argument_list|)
case|:
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_pr
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s pr, %ld\n"
argument_list|,
name|saveop
argument_list|,
name|off
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|AR_LC_REGNUM
case|:
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_ar_lc
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s ar.lc, %ld\n"
argument_list|,
name|saveop
argument_list|,
name|off
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|AR_PFS_REGNUM
case|:
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_ar_pfs
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s ar.pfs, %ld\n"
argument_list|,
name|saveop
argument_list|,
name|off
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|AR_UNAT_REGNUM
case|:
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_ar_unat
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s ar.unat, %ld\n"
argument_list|,
name|saveop
argument_list|,
name|off
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|GR_REG
argument_list|(
literal|4
argument_list|)
case|:
case|case
name|GR_REG
argument_list|(
literal|5
argument_list|)
case|:
case|case
name|GR_REG
argument_list|(
literal|6
argument_list|)
case|:
case|case
name|GR_REG
argument_list|(
literal|7
argument_list|)
case|:
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.save.g 0x%x\n"
argument_list|,
literal|1
operator|<<
operator|(
name|src_regno
operator|-
name|GR_REG
argument_list|(
literal|4
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|BR_REG
argument_list|(
literal|1
argument_list|)
case|:
case|case
name|BR_REG
argument_list|(
literal|2
argument_list|)
case|:
case|case
name|BR_REG
argument_list|(
literal|3
argument_list|)
case|:
case|case
name|BR_REG
argument_list|(
literal|4
argument_list|)
case|:
case|case
name|BR_REG
argument_list|(
literal|5
argument_list|)
case|:
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.save.b 0x%x\n"
argument_list|,
literal|1
operator|<<
operator|(
name|src_regno
operator|-
name|BR_REG
argument_list|(
literal|1
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|FR_REG
argument_list|(
literal|2
argument_list|)
case|:
case|case
name|FR_REG
argument_list|(
literal|3
argument_list|)
case|:
case|case
name|FR_REG
argument_list|(
literal|4
argument_list|)
case|:
case|case
name|FR_REG
argument_list|(
literal|5
argument_list|)
case|:
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.save.f 0x%x\n"
argument_list|,
literal|1
operator|<<
operator|(
name|src_regno
operator|-
name|FR_REG
argument_list|(
literal|2
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|FR_REG
argument_list|(
literal|16
argument_list|)
case|:
case|case
name|FR_REG
argument_list|(
literal|17
argument_list|)
case|:
case|case
name|FR_REG
argument_list|(
literal|18
argument_list|)
case|:
case|case
name|FR_REG
argument_list|(
literal|19
argument_list|)
case|:
case|case
name|FR_REG
argument_list|(
literal|20
argument_list|)
case|:
case|case
name|FR_REG
argument_list|(
literal|21
argument_list|)
case|:
case|case
name|FR_REG
argument_list|(
literal|22
argument_list|)
case|:
case|case
name|FR_REG
argument_list|(
literal|23
argument_list|)
case|:
case|case
name|FR_REG
argument_list|(
literal|24
argument_list|)
case|:
case|case
name|FR_REG
argument_list|(
literal|25
argument_list|)
case|:
case|case
name|FR_REG
argument_list|(
literal|26
argument_list|)
case|:
case|case
name|FR_REG
argument_list|(
literal|27
argument_list|)
case|:
case|case
name|FR_REG
argument_list|(
literal|28
argument_list|)
case|:
case|case
name|FR_REG
argument_list|(
literal|29
argument_list|)
case|:
case|case
name|FR_REG
argument_list|(
literal|30
argument_list|)
case|:
case|case
name|FR_REG
argument_list|(
literal|31
argument_list|)
case|:
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.save.gf 0x0, 0x%x\n"
argument_list|,
literal|1
operator|<<
operator|(
name|src_regno
operator|-
name|FR_REG
argument_list|(
literal|12
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* This function looks at a single insn and emits any directives    required to unwind this insn.  */
end_comment

begin_function
name|void
name|process_for_unwind_directive
parameter_list|(
name|asm_out_file
parameter_list|,
name|insn
parameter_list|)
name|FILE
modifier|*
name|asm_out_file
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
if|if
condition|(
name|flag_unwind_tables
operator|||
operator|(
name|flag_exceptions
operator|&&
operator|!
name|USING_SJLJ_EXCEPTIONS
operator|)
condition|)
block|{
name|rtx
name|pat
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_BASIC_BLOCK
condition|)
block|{
name|block_num
operator|=
name|NOTE_BASIC_BLOCK
argument_list|(
name|insn
argument_list|)
operator|->
name|index
expr_stmt|;
comment|/* Restore unwind state from immediately before the epilogue.  */
if|if
condition|(
name|need_copy_state
condition|)
block|{
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.body\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.copy_state 1\n"
argument_list|)
expr_stmt|;
name|need_copy_state
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return;
name|pat
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_FRAME_RELATED_EXPR
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
condition|)
name|pat
operator|=
name|XEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|pat
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
condition|)
block|{
case|case
name|SET
case|:
name|process_set
argument_list|(
name|asm_out_file
argument_list|,
name|pat
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARALLEL
case|:
block|{
name|int
name|par_index
decl_stmt|;
name|int
name|limit
init|=
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|par_index
operator|=
literal|0
init|;
name|par_index
operator|<
name|limit
condition|;
name|par_index
operator|++
control|)
block|{
name|rtx
name|x
init|=
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|par_index
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SET
condition|)
name|process_set
argument_list|(
name|asm_out_file
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|ia64_init_builtins
parameter_list|()
block|{
name|tree
name|psi_type_node
init|=
name|build_pointer_type
argument_list|(
name|integer_type_node
argument_list|)
decl_stmt|;
name|tree
name|pdi_type_node
init|=
name|build_pointer_type
argument_list|(
name|long_integer_type_node
argument_list|)
decl_stmt|;
name|tree
name|endlink
init|=
name|void_list_node
decl_stmt|;
comment|/* __sync_val_compare_and_swap_si, __sync_bool_compare_and_swap_si */
name|tree
name|si_ftype_psi_si_si
init|=
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|psi_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* __sync_val_compare_and_swap_di, __sync_bool_compare_and_swap_di */
name|tree
name|di_ftype_pdi_di_di
init|=
name|build_function_type
argument_list|(
name|long_integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|pdi_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|long_integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|long_integer_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* __sync_synchronize */
name|tree
name|void_ftype_void
init|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|endlink
argument_list|)
decl_stmt|;
comment|/* __sync_lock_test_and_set_si */
name|tree
name|si_ftype_psi_si
init|=
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|psi_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* __sync_lock_test_and_set_di */
name|tree
name|di_ftype_pdi_di
init|=
name|build_function_type
argument_list|(
name|long_integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|pdi_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|long_integer_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* __sync_lock_release_si */
name|tree
name|void_ftype_psi
init|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|psi_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
decl_stmt|;
comment|/* __sync_lock_release_di */
name|tree
name|void_ftype_pdi
init|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|pdi_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
decl_stmt|;
define|#
directive|define
name|def_builtin
parameter_list|(
name|name
parameter_list|,
name|type
parameter_list|,
name|code
parameter_list|)
define|\
value|builtin_function ((name), (type), (code), BUILT_IN_MD, NULL)
name|def_builtin
argument_list|(
literal|"__sync_val_compare_and_swap_si"
argument_list|,
name|si_ftype_psi_si_si
argument_list|,
name|IA64_BUILTIN_VAL_COMPARE_AND_SWAP_SI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__sync_val_compare_and_swap_di"
argument_list|,
name|di_ftype_pdi_di_di
argument_list|,
name|IA64_BUILTIN_VAL_COMPARE_AND_SWAP_DI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__sync_bool_compare_and_swap_si"
argument_list|,
name|si_ftype_psi_si_si
argument_list|,
name|IA64_BUILTIN_BOOL_COMPARE_AND_SWAP_SI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__sync_bool_compare_and_swap_di"
argument_list|,
name|di_ftype_pdi_di_di
argument_list|,
name|IA64_BUILTIN_BOOL_COMPARE_AND_SWAP_DI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__sync_synchronize"
argument_list|,
name|void_ftype_void
argument_list|,
name|IA64_BUILTIN_SYNCHRONIZE
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__sync_lock_test_and_set_si"
argument_list|,
name|si_ftype_psi_si
argument_list|,
name|IA64_BUILTIN_LOCK_TEST_AND_SET_SI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__sync_lock_test_and_set_di"
argument_list|,
name|di_ftype_pdi_di
argument_list|,
name|IA64_BUILTIN_LOCK_TEST_AND_SET_DI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__sync_lock_release_si"
argument_list|,
name|void_ftype_psi
argument_list|,
name|IA64_BUILTIN_LOCK_RELEASE_SI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__sync_lock_release_di"
argument_list|,
name|void_ftype_pdi
argument_list|,
name|IA64_BUILTIN_LOCK_RELEASE_DI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__builtin_ia64_bsp"
argument_list|,
name|build_function_type
argument_list|(
name|ptr_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|,
name|IA64_BUILTIN_BSP
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__builtin_ia64_flushrs"
argument_list|,
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|,
name|IA64_BUILTIN_FLUSHRS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__sync_fetch_and_add_si"
argument_list|,
name|si_ftype_psi_si
argument_list|,
name|IA64_BUILTIN_FETCH_AND_ADD_SI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__sync_fetch_and_sub_si"
argument_list|,
name|si_ftype_psi_si
argument_list|,
name|IA64_BUILTIN_FETCH_AND_SUB_SI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__sync_fetch_and_or_si"
argument_list|,
name|si_ftype_psi_si
argument_list|,
name|IA64_BUILTIN_FETCH_AND_OR_SI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__sync_fetch_and_and_si"
argument_list|,
name|si_ftype_psi_si
argument_list|,
name|IA64_BUILTIN_FETCH_AND_AND_SI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__sync_fetch_and_xor_si"
argument_list|,
name|si_ftype_psi_si
argument_list|,
name|IA64_BUILTIN_FETCH_AND_XOR_SI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__sync_fetch_and_nand_si"
argument_list|,
name|si_ftype_psi_si
argument_list|,
name|IA64_BUILTIN_FETCH_AND_NAND_SI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__sync_add_and_fetch_si"
argument_list|,
name|si_ftype_psi_si
argument_list|,
name|IA64_BUILTIN_ADD_AND_FETCH_SI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__sync_sub_and_fetch_si"
argument_list|,
name|si_ftype_psi_si
argument_list|,
name|IA64_BUILTIN_SUB_AND_FETCH_SI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__sync_or_and_fetch_si"
argument_list|,
name|si_ftype_psi_si
argument_list|,
name|IA64_BUILTIN_OR_AND_FETCH_SI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__sync_and_and_fetch_si"
argument_list|,
name|si_ftype_psi_si
argument_list|,
name|IA64_BUILTIN_AND_AND_FETCH_SI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__sync_xor_and_fetch_si"
argument_list|,
name|si_ftype_psi_si
argument_list|,
name|IA64_BUILTIN_XOR_AND_FETCH_SI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__sync_nand_and_fetch_si"
argument_list|,
name|si_ftype_psi_si
argument_list|,
name|IA64_BUILTIN_NAND_AND_FETCH_SI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__sync_fetch_and_add_di"
argument_list|,
name|di_ftype_pdi_di
argument_list|,
name|IA64_BUILTIN_FETCH_AND_ADD_DI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__sync_fetch_and_sub_di"
argument_list|,
name|di_ftype_pdi_di
argument_list|,
name|IA64_BUILTIN_FETCH_AND_SUB_DI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__sync_fetch_and_or_di"
argument_list|,
name|di_ftype_pdi_di
argument_list|,
name|IA64_BUILTIN_FETCH_AND_OR_DI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__sync_fetch_and_and_di"
argument_list|,
name|di_ftype_pdi_di
argument_list|,
name|IA64_BUILTIN_FETCH_AND_AND_DI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__sync_fetch_and_xor_di"
argument_list|,
name|di_ftype_pdi_di
argument_list|,
name|IA64_BUILTIN_FETCH_AND_XOR_DI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__sync_fetch_and_nand_di"
argument_list|,
name|di_ftype_pdi_di
argument_list|,
name|IA64_BUILTIN_FETCH_AND_NAND_DI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__sync_add_and_fetch_di"
argument_list|,
name|di_ftype_pdi_di
argument_list|,
name|IA64_BUILTIN_ADD_AND_FETCH_DI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__sync_sub_and_fetch_di"
argument_list|,
name|di_ftype_pdi_di
argument_list|,
name|IA64_BUILTIN_SUB_AND_FETCH_DI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__sync_or_and_fetch_di"
argument_list|,
name|di_ftype_pdi_di
argument_list|,
name|IA64_BUILTIN_OR_AND_FETCH_DI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__sync_and_and_fetch_di"
argument_list|,
name|di_ftype_pdi_di
argument_list|,
name|IA64_BUILTIN_AND_AND_FETCH_DI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__sync_xor_and_fetch_di"
argument_list|,
name|di_ftype_pdi_di
argument_list|,
name|IA64_BUILTIN_XOR_AND_FETCH_DI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__sync_nand_and_fetch_di"
argument_list|,
name|di_ftype_pdi_di
argument_list|,
name|IA64_BUILTIN_NAND_AND_FETCH_DI
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|def_builtin
block|}
end_function

begin_comment
comment|/* Expand fetch_and_op intrinsics.  The basic code sequence is:       mf      tmp = [ptr];      do {        ret = tmp;        ar.ccv = tmp;        tmp<op>= value;        cmpxchgsz.acq tmp = [ptr], tmp      } while (tmp != ret) */
end_comment

begin_function
specifier|static
name|rtx
name|ia64_expand_fetch_and_op
parameter_list|(
name|binoptab
parameter_list|,
name|mode
parameter_list|,
name|arglist
parameter_list|,
name|target
parameter_list|)
name|optab
name|binoptab
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|arglist
decl_stmt|;
name|rtx
name|target
decl_stmt|;
block|{
name|rtx
name|ret
decl_stmt|,
name|label
decl_stmt|,
name|tmp
decl_stmt|,
name|ccv
decl_stmt|,
name|insn
decl_stmt|,
name|mem
decl_stmt|,
name|value
decl_stmt|;
name|tree
name|arg0
decl_stmt|,
name|arg1
decl_stmt|;
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|mem
operator|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|Pmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|value
operator|=
name|expand_expr
argument_list|(
name|arg1
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode
argument_list|,
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|mem
argument_list|)
argument_list|)
expr_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|mem
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|target
operator|&&
name|register_operand
argument_list|(
name|target
argument_list|,
name|mode
argument_list|)
condition|)
name|ret
operator|=
name|target
expr_stmt|;
else|else
name|ret
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_mf
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Special case for fetchadd instructions.  */
if|if
condition|(
name|binoptab
operator|==
name|add_optab
operator|&&
name|fetchadd_operand
argument_list|(
name|value
argument_list|,
name|VOIDmode
argument_list|)
condition|)
block|{
if|if
condition|(
name|mode
operator|==
name|SImode
condition|)
name|insn
operator|=
name|gen_fetchadd_acq_si
argument_list|(
name|ret
argument_list|,
name|mem
argument_list|,
name|value
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|gen_fetchadd_acq_di
argument_list|(
name|ret
argument_list|,
name|mem
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|tmp
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|ccv
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|AR_CCV_REGNUM
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|tmp
argument_list|,
name|mem
argument_list|)
expr_stmt|;
name|label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|ret
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|ccv
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* Perform the specific operation.  Special case NAND by noticing      one_cmpl_optab instead.  */
if|if
condition|(
name|binoptab
operator|==
name|one_cmpl_optab
condition|)
block|{
name|tmp
operator|=
name|expand_unop
argument_list|(
name|mode
argument_list|,
name|binoptab
argument_list|,
name|tmp
argument_list|,
name|NULL
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
name|binoptab
operator|=
name|and_optab
expr_stmt|;
block|}
name|tmp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|binoptab
argument_list|,
name|tmp
argument_list|,
name|value
argument_list|,
name|tmp
argument_list|,
literal|1
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|SImode
condition|)
name|insn
operator|=
name|gen_cmpxchg_acq_si
argument_list|(
name|tmp
argument_list|,
name|mem
argument_list|,
name|tmp
argument_list|,
name|ccv
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|gen_cmpxchg_acq_di
argument_list|(
name|tmp
argument_list|,
name|mem
argument_list|,
name|tmp
argument_list|,
name|ccv
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|tmp
argument_list|,
name|ret
argument_list|,
name|NE
argument_list|,
literal|0
argument_list|,
name|mode
argument_list|,
literal|1
argument_list|,
name|label
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Expand op_and_fetch intrinsics.  The basic code sequence is:       mf      tmp = [ptr];      do {        old = tmp;        ar.ccv = tmp;        ret = tmp + value;        cmpxchgsz.acq tmp = [ptr], ret      } while (tmp != old) */
end_comment

begin_function
specifier|static
name|rtx
name|ia64_expand_op_and_fetch
parameter_list|(
name|binoptab
parameter_list|,
name|mode
parameter_list|,
name|arglist
parameter_list|,
name|target
parameter_list|)
name|optab
name|binoptab
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|arglist
decl_stmt|;
name|rtx
name|target
decl_stmt|;
block|{
name|rtx
name|old
decl_stmt|,
name|label
decl_stmt|,
name|tmp
decl_stmt|,
name|ret
decl_stmt|,
name|ccv
decl_stmt|,
name|insn
decl_stmt|,
name|mem
decl_stmt|,
name|value
decl_stmt|;
name|tree
name|arg0
decl_stmt|,
name|arg1
decl_stmt|;
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|mem
operator|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|Pmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|value
operator|=
name|expand_expr
argument_list|(
name|arg1
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode
argument_list|,
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|mem
argument_list|)
argument_list|)
expr_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|mem
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|target
operator|&&
operator|!
name|register_operand
argument_list|(
name|target
argument_list|,
name|mode
argument_list|)
condition|)
name|target
operator|=
name|NULL_RTX
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_mf
argument_list|()
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|old
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|ccv
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|AR_CCV_REGNUM
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|tmp
argument_list|,
name|mem
argument_list|)
expr_stmt|;
name|label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|old
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|ccv
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* Perform the specific operation.  Special case NAND by noticing      one_cmpl_optab instead.  */
if|if
condition|(
name|binoptab
operator|==
name|one_cmpl_optab
condition|)
block|{
name|tmp
operator|=
name|expand_unop
argument_list|(
name|mode
argument_list|,
name|binoptab
argument_list|,
name|tmp
argument_list|,
name|NULL
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
name|binoptab
operator|=
name|and_optab
expr_stmt|;
block|}
name|ret
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|binoptab
argument_list|,
name|tmp
argument_list|,
name|value
argument_list|,
name|target
argument_list|,
literal|1
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|SImode
condition|)
name|insn
operator|=
name|gen_cmpxchg_acq_si
argument_list|(
name|tmp
argument_list|,
name|mem
argument_list|,
name|ret
argument_list|,
name|ccv
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|gen_cmpxchg_acq_di
argument_list|(
name|tmp
argument_list|,
name|mem
argument_list|,
name|ret
argument_list|,
name|ccv
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|tmp
argument_list|,
name|old
argument_list|,
name|NE
argument_list|,
literal|0
argument_list|,
name|mode
argument_list|,
literal|1
argument_list|,
name|label
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Expand val_ and bool_compare_and_swap.  For val_ we want:       ar.ccv = oldval      mf      cmpxchgsz.acq ret = [ptr], newval, ar.ccv      return ret     For bool_ it's the same except return ret == oldval. */
end_comment

begin_function
specifier|static
name|rtx
name|ia64_expand_compare_and_swap
parameter_list|(
name|mode
parameter_list|,
name|boolp
parameter_list|,
name|arglist
parameter_list|,
name|target
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|boolp
decl_stmt|;
name|tree
name|arglist
decl_stmt|;
name|rtx
name|target
decl_stmt|;
block|{
name|tree
name|arg0
decl_stmt|,
name|arg1
decl_stmt|,
name|arg2
decl_stmt|;
name|rtx
name|mem
decl_stmt|,
name|old
decl_stmt|,
name|new
decl_stmt|,
name|ccv
decl_stmt|,
name|tmp
decl_stmt|,
name|insn
decl_stmt|;
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|mem
operator|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|Pmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|old
operator|=
name|expand_expr
argument_list|(
name|arg1
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|new
operator|=
name|expand_expr
argument_list|(
name|arg2
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode
argument_list|,
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|mem
argument_list|)
argument_list|)
expr_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|mem
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|register_operand
argument_list|(
name|old
argument_list|,
name|mode
argument_list|)
condition|)
name|old
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode
argument_list|,
name|old
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|register_operand
argument_list|(
name|new
argument_list|,
name|mode
argument_list|)
condition|)
name|new
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode
argument_list|,
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|boolp
operator|&&
name|target
operator|&&
name|register_operand
argument_list|(
name|target
argument_list|,
name|mode
argument_list|)
condition|)
name|tmp
operator|=
name|target
expr_stmt|;
else|else
name|tmp
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|ccv
operator|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|AR_CCV_REGNUM
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|ccv
argument_list|,
name|old
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_mf
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|SImode
condition|)
name|insn
operator|=
name|gen_cmpxchg_acq_si
argument_list|(
name|tmp
argument_list|,
name|mem
argument_list|,
name|new
argument_list|,
name|ccv
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|gen_cmpxchg_acq_di
argument_list|(
name|tmp
argument_list|,
name|mem
argument_list|,
name|new
argument_list|,
name|ccv
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|boolp
condition|)
block|{
if|if
condition|(
operator|!
name|target
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
return|return
name|emit_store_flag_force
argument_list|(
name|target
argument_list|,
name|EQ
argument_list|,
name|tmp
argument_list|,
name|old
argument_list|,
name|mode
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
return|;
block|}
else|else
return|return
name|tmp
return|;
block|}
end_function

begin_comment
comment|/* Expand lock_test_and_set.  I.e. `xchgsz ret = [ptr], new'.  */
end_comment

begin_function
specifier|static
name|rtx
name|ia64_expand_lock_test_and_set
parameter_list|(
name|mode
parameter_list|,
name|arglist
parameter_list|,
name|target
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|arglist
decl_stmt|;
name|rtx
name|target
decl_stmt|;
block|{
name|tree
name|arg0
decl_stmt|,
name|arg1
decl_stmt|;
name|rtx
name|mem
decl_stmt|,
name|new
decl_stmt|,
name|ret
decl_stmt|,
name|insn
decl_stmt|;
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|mem
operator|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|Pmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|new
operator|=
name|expand_expr
argument_list|(
name|arg1
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode
argument_list|,
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|mem
argument_list|)
argument_list|)
expr_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|mem
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|register_operand
argument_list|(
name|new
argument_list|,
name|mode
argument_list|)
condition|)
name|new
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode
argument_list|,
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|&&
name|register_operand
argument_list|(
name|target
argument_list|,
name|mode
argument_list|)
condition|)
name|ret
operator|=
name|target
expr_stmt|;
else|else
name|ret
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|SImode
condition|)
name|insn
operator|=
name|gen_xchgsi
argument_list|(
name|ret
argument_list|,
name|mem
argument_list|,
name|new
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|gen_xchgdi
argument_list|(
name|ret
argument_list|,
name|mem
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Expand lock_release.  I.e. `stsz.rel [ptr] = r0'.  */
end_comment

begin_function
specifier|static
name|rtx
name|ia64_expand_lock_release
parameter_list|(
name|mode
parameter_list|,
name|arglist
parameter_list|,
name|target
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|arglist
decl_stmt|;
name|rtx
name|target
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|tree
name|arg0
decl_stmt|;
name|rtx
name|mem
decl_stmt|;
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|mem
operator|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|Pmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode
argument_list|,
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|mem
argument_list|)
argument_list|)
expr_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|mem
argument_list|)
operator|=
literal|1
expr_stmt|;
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
end_function

begin_function
name|rtx
name|ia64_expand_builtin
parameter_list|(
name|exp
parameter_list|,
name|target
parameter_list|,
name|subtarget
parameter_list|,
name|mode
parameter_list|,
name|ignore
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|rtx
name|subtarget
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|tree
name|fndecl
init|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|fcode
init|=
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|fcode
condition|)
block|{
case|case
name|IA64_BUILTIN_BOOL_COMPARE_AND_SWAP_SI
case|:
case|case
name|IA64_BUILTIN_VAL_COMPARE_AND_SWAP_SI
case|:
case|case
name|IA64_BUILTIN_LOCK_TEST_AND_SET_SI
case|:
case|case
name|IA64_BUILTIN_LOCK_RELEASE_SI
case|:
case|case
name|IA64_BUILTIN_FETCH_AND_ADD_SI
case|:
case|case
name|IA64_BUILTIN_FETCH_AND_SUB_SI
case|:
case|case
name|IA64_BUILTIN_FETCH_AND_OR_SI
case|:
case|case
name|IA64_BUILTIN_FETCH_AND_AND_SI
case|:
case|case
name|IA64_BUILTIN_FETCH_AND_XOR_SI
case|:
case|case
name|IA64_BUILTIN_FETCH_AND_NAND_SI
case|:
case|case
name|IA64_BUILTIN_ADD_AND_FETCH_SI
case|:
case|case
name|IA64_BUILTIN_SUB_AND_FETCH_SI
case|:
case|case
name|IA64_BUILTIN_OR_AND_FETCH_SI
case|:
case|case
name|IA64_BUILTIN_AND_AND_FETCH_SI
case|:
case|case
name|IA64_BUILTIN_XOR_AND_FETCH_SI
case|:
case|case
name|IA64_BUILTIN_NAND_AND_FETCH_SI
case|:
name|mode
operator|=
name|SImode
expr_stmt|;
break|break;
case|case
name|IA64_BUILTIN_BOOL_COMPARE_AND_SWAP_DI
case|:
case|case
name|IA64_BUILTIN_VAL_COMPARE_AND_SWAP_DI
case|:
case|case
name|IA64_BUILTIN_LOCK_TEST_AND_SET_DI
case|:
case|case
name|IA64_BUILTIN_LOCK_RELEASE_DI
case|:
case|case
name|IA64_BUILTIN_FETCH_AND_ADD_DI
case|:
case|case
name|IA64_BUILTIN_FETCH_AND_SUB_DI
case|:
case|case
name|IA64_BUILTIN_FETCH_AND_OR_DI
case|:
case|case
name|IA64_BUILTIN_FETCH_AND_AND_DI
case|:
case|case
name|IA64_BUILTIN_FETCH_AND_XOR_DI
case|:
case|case
name|IA64_BUILTIN_FETCH_AND_NAND_DI
case|:
case|case
name|IA64_BUILTIN_ADD_AND_FETCH_DI
case|:
case|case
name|IA64_BUILTIN_SUB_AND_FETCH_DI
case|:
case|case
name|IA64_BUILTIN_OR_AND_FETCH_DI
case|:
case|case
name|IA64_BUILTIN_AND_AND_FETCH_DI
case|:
case|case
name|IA64_BUILTIN_XOR_AND_FETCH_DI
case|:
case|case
name|IA64_BUILTIN_NAND_AND_FETCH_DI
case|:
name|mode
operator|=
name|DImode
expr_stmt|;
break|break;
default|default:
break|break;
block|}
switch|switch
condition|(
name|fcode
condition|)
block|{
case|case
name|IA64_BUILTIN_BOOL_COMPARE_AND_SWAP_SI
case|:
case|case
name|IA64_BUILTIN_BOOL_COMPARE_AND_SWAP_DI
case|:
return|return
name|ia64_expand_compare_and_swap
argument_list|(
name|mode
argument_list|,
literal|1
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IA64_BUILTIN_VAL_COMPARE_AND_SWAP_SI
case|:
case|case
name|IA64_BUILTIN_VAL_COMPARE_AND_SWAP_DI
case|:
return|return
name|ia64_expand_compare_and_swap
argument_list|(
name|mode
argument_list|,
literal|0
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IA64_BUILTIN_SYNCHRONIZE
case|:
name|emit_insn
argument_list|(
name|gen_mf
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
case|case
name|IA64_BUILTIN_LOCK_TEST_AND_SET_SI
case|:
case|case
name|IA64_BUILTIN_LOCK_TEST_AND_SET_DI
case|:
return|return
name|ia64_expand_lock_test_and_set
argument_list|(
name|mode
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IA64_BUILTIN_LOCK_RELEASE_SI
case|:
case|case
name|IA64_BUILTIN_LOCK_RELEASE_DI
case|:
return|return
name|ia64_expand_lock_release
argument_list|(
name|mode
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IA64_BUILTIN_BSP
case|:
if|if
condition|(
operator|!
name|target
operator|||
operator|!
name|register_operand
argument_list|(
name|target
argument_list|,
name|DImode
argument_list|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_bsp_value
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|target
return|;
case|case
name|IA64_BUILTIN_FLUSHRS
case|:
name|emit_insn
argument_list|(
name|gen_flushrs
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
case|case
name|IA64_BUILTIN_FETCH_AND_ADD_SI
case|:
case|case
name|IA64_BUILTIN_FETCH_AND_ADD_DI
case|:
return|return
name|ia64_expand_fetch_and_op
argument_list|(
name|add_optab
argument_list|,
name|mode
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IA64_BUILTIN_FETCH_AND_SUB_SI
case|:
case|case
name|IA64_BUILTIN_FETCH_AND_SUB_DI
case|:
return|return
name|ia64_expand_fetch_and_op
argument_list|(
name|sub_optab
argument_list|,
name|mode
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IA64_BUILTIN_FETCH_AND_OR_SI
case|:
case|case
name|IA64_BUILTIN_FETCH_AND_OR_DI
case|:
return|return
name|ia64_expand_fetch_and_op
argument_list|(
name|ior_optab
argument_list|,
name|mode
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IA64_BUILTIN_FETCH_AND_AND_SI
case|:
case|case
name|IA64_BUILTIN_FETCH_AND_AND_DI
case|:
return|return
name|ia64_expand_fetch_and_op
argument_list|(
name|and_optab
argument_list|,
name|mode
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IA64_BUILTIN_FETCH_AND_XOR_SI
case|:
case|case
name|IA64_BUILTIN_FETCH_AND_XOR_DI
case|:
return|return
name|ia64_expand_fetch_and_op
argument_list|(
name|xor_optab
argument_list|,
name|mode
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IA64_BUILTIN_FETCH_AND_NAND_SI
case|:
case|case
name|IA64_BUILTIN_FETCH_AND_NAND_DI
case|:
return|return
name|ia64_expand_fetch_and_op
argument_list|(
name|one_cmpl_optab
argument_list|,
name|mode
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IA64_BUILTIN_ADD_AND_FETCH_SI
case|:
case|case
name|IA64_BUILTIN_ADD_AND_FETCH_DI
case|:
return|return
name|ia64_expand_op_and_fetch
argument_list|(
name|add_optab
argument_list|,
name|mode
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IA64_BUILTIN_SUB_AND_FETCH_SI
case|:
case|case
name|IA64_BUILTIN_SUB_AND_FETCH_DI
case|:
return|return
name|ia64_expand_op_and_fetch
argument_list|(
name|sub_optab
argument_list|,
name|mode
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IA64_BUILTIN_OR_AND_FETCH_SI
case|:
case|case
name|IA64_BUILTIN_OR_AND_FETCH_DI
case|:
return|return
name|ia64_expand_op_and_fetch
argument_list|(
name|ior_optab
argument_list|,
name|mode
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IA64_BUILTIN_AND_AND_FETCH_SI
case|:
case|case
name|IA64_BUILTIN_AND_AND_FETCH_DI
case|:
return|return
name|ia64_expand_op_and_fetch
argument_list|(
name|and_optab
argument_list|,
name|mode
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IA64_BUILTIN_XOR_AND_FETCH_SI
case|:
case|case
name|IA64_BUILTIN_XOR_AND_FETCH_DI
case|:
return|return
name|ia64_expand_op_and_fetch
argument_list|(
name|xor_optab
argument_list|,
name|mode
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IA64_BUILTIN_NAND_AND_FETCH_SI
case|:
case|case
name|IA64_BUILTIN_NAND_AND_FETCH_DI
case|:
return|return
name|ia64_expand_op_and_fetch
argument_list|(
name|one_cmpl_optab
argument_list|,
name|mode
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
default|default:
break|break;
block|}
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_comment
comment|/* For the HP-UX IA64 aggregate parameters are passed stored in the    most significant bits of the stack slot.  */
end_comment

begin_function
name|enum
name|direction
name|ia64_hpux_function_arg_padding
parameter_list|(
name|mode
parameter_list|,
name|type
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
comment|/* Exception to normal case for structures/unions/etc.  */
if|if
condition|(
name|type
operator|&&
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
operator|<
name|UNITS_PER_WORD
condition|)
return|return
name|upward
return|;
comment|/* This is the standard FUNCTION_ARG_PADDING with !BYTES_BIG_ENDIAN       hardwired to be true.  */
return|return
operator|(
operator|(
name|mode
operator|==
name|BLKmode
condition|?
operator|(
name|type
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
operator|<
operator|(
name|PARM_BOUNDARY
operator|/
name|BITS_PER_UNIT
operator|)
operator|)
else|:
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<
name|PARM_BOUNDARY
operator|)
condition|?
name|downward
else|:
name|upward
operator|)
return|;
block|}
end_function

end_unit

