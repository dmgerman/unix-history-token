begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Definitions of target machine for GNU compiler.    Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004    Free Software Foundation, Inc.    Contributed by James E. Wilson<wilson@cygnus.com> and 		  David Mosberger<davidm@hpl.hp.com>.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"conditions.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"optabs.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"sched-int.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"target-def.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"cfglayout.h"
end_include

begin_comment
comment|/* This is used for communication between ASM_OUTPUT_LABEL and    ASM_OUTPUT_LABELREF.  */
end_comment

begin_decl_stmt
name|int
name|ia64_asm_output_label
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Define the information needed to generate branch and scc insns.  This is    stored from the compare operation.  */
end_comment

begin_decl_stmt
name|struct
name|rtx_def
modifier|*
name|ia64_compare_op0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rtx_def
modifier|*
name|ia64_compare_op1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Register names for ia64_expand_prologue.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|ia64_reg_numbers
index|[
literal|96
index|]
init|=
block|{
literal|"r32"
block|,
literal|"r33"
block|,
literal|"r34"
block|,
literal|"r35"
block|,
literal|"r36"
block|,
literal|"r37"
block|,
literal|"r38"
block|,
literal|"r39"
block|,
literal|"r40"
block|,
literal|"r41"
block|,
literal|"r42"
block|,
literal|"r43"
block|,
literal|"r44"
block|,
literal|"r45"
block|,
literal|"r46"
block|,
literal|"r47"
block|,
literal|"r48"
block|,
literal|"r49"
block|,
literal|"r50"
block|,
literal|"r51"
block|,
literal|"r52"
block|,
literal|"r53"
block|,
literal|"r54"
block|,
literal|"r55"
block|,
literal|"r56"
block|,
literal|"r57"
block|,
literal|"r58"
block|,
literal|"r59"
block|,
literal|"r60"
block|,
literal|"r61"
block|,
literal|"r62"
block|,
literal|"r63"
block|,
literal|"r64"
block|,
literal|"r65"
block|,
literal|"r66"
block|,
literal|"r67"
block|,
literal|"r68"
block|,
literal|"r69"
block|,
literal|"r70"
block|,
literal|"r71"
block|,
literal|"r72"
block|,
literal|"r73"
block|,
literal|"r74"
block|,
literal|"r75"
block|,
literal|"r76"
block|,
literal|"r77"
block|,
literal|"r78"
block|,
literal|"r79"
block|,
literal|"r80"
block|,
literal|"r81"
block|,
literal|"r82"
block|,
literal|"r83"
block|,
literal|"r84"
block|,
literal|"r85"
block|,
literal|"r86"
block|,
literal|"r87"
block|,
literal|"r88"
block|,
literal|"r89"
block|,
literal|"r90"
block|,
literal|"r91"
block|,
literal|"r92"
block|,
literal|"r93"
block|,
literal|"r94"
block|,
literal|"r95"
block|,
literal|"r96"
block|,
literal|"r97"
block|,
literal|"r98"
block|,
literal|"r99"
block|,
literal|"r100"
block|,
literal|"r101"
block|,
literal|"r102"
block|,
literal|"r103"
block|,
literal|"r104"
block|,
literal|"r105"
block|,
literal|"r106"
block|,
literal|"r107"
block|,
literal|"r108"
block|,
literal|"r109"
block|,
literal|"r110"
block|,
literal|"r111"
block|,
literal|"r112"
block|,
literal|"r113"
block|,
literal|"r114"
block|,
literal|"r115"
block|,
literal|"r116"
block|,
literal|"r117"
block|,
literal|"r118"
block|,
literal|"r119"
block|,
literal|"r120"
block|,
literal|"r121"
block|,
literal|"r122"
block|,
literal|"r123"
block|,
literal|"r124"
block|,
literal|"r125"
block|,
literal|"r126"
block|,
literal|"r127"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ??? These strings could be shared with REGISTER_NAMES.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|ia64_input_reg_names
index|[
literal|8
index|]
init|=
block|{
literal|"in0"
block|,
literal|"in1"
block|,
literal|"in2"
block|,
literal|"in3"
block|,
literal|"in4"
block|,
literal|"in5"
block|,
literal|"in6"
block|,
literal|"in7"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ??? These strings could be shared with REGISTER_NAMES.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|ia64_local_reg_names
index|[
literal|80
index|]
init|=
block|{
literal|"loc0"
block|,
literal|"loc1"
block|,
literal|"loc2"
block|,
literal|"loc3"
block|,
literal|"loc4"
block|,
literal|"loc5"
block|,
literal|"loc6"
block|,
literal|"loc7"
block|,
literal|"loc8"
block|,
literal|"loc9"
block|,
literal|"loc10"
block|,
literal|"loc11"
block|,
literal|"loc12"
block|,
literal|"loc13"
block|,
literal|"loc14"
block|,
literal|"loc15"
block|,
literal|"loc16"
block|,
literal|"loc17"
block|,
literal|"loc18"
block|,
literal|"loc19"
block|,
literal|"loc20"
block|,
literal|"loc21"
block|,
literal|"loc22"
block|,
literal|"loc23"
block|,
literal|"loc24"
block|,
literal|"loc25"
block|,
literal|"loc26"
block|,
literal|"loc27"
block|,
literal|"loc28"
block|,
literal|"loc29"
block|,
literal|"loc30"
block|,
literal|"loc31"
block|,
literal|"loc32"
block|,
literal|"loc33"
block|,
literal|"loc34"
block|,
literal|"loc35"
block|,
literal|"loc36"
block|,
literal|"loc37"
block|,
literal|"loc38"
block|,
literal|"loc39"
block|,
literal|"loc40"
block|,
literal|"loc41"
block|,
literal|"loc42"
block|,
literal|"loc43"
block|,
literal|"loc44"
block|,
literal|"loc45"
block|,
literal|"loc46"
block|,
literal|"loc47"
block|,
literal|"loc48"
block|,
literal|"loc49"
block|,
literal|"loc50"
block|,
literal|"loc51"
block|,
literal|"loc52"
block|,
literal|"loc53"
block|,
literal|"loc54"
block|,
literal|"loc55"
block|,
literal|"loc56"
block|,
literal|"loc57"
block|,
literal|"loc58"
block|,
literal|"loc59"
block|,
literal|"loc60"
block|,
literal|"loc61"
block|,
literal|"loc62"
block|,
literal|"loc63"
block|,
literal|"loc64"
block|,
literal|"loc65"
block|,
literal|"loc66"
block|,
literal|"loc67"
block|,
literal|"loc68"
block|,
literal|"loc69"
block|,
literal|"loc70"
block|,
literal|"loc71"
block|,
literal|"loc72"
block|,
literal|"loc73"
block|,
literal|"loc74"
block|,
literal|"loc75"
block|,
literal|"loc76"
block|,
literal|"loc77"
block|,
literal|"loc78"
block|,
literal|"loc79"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ??? These strings could be shared with REGISTER_NAMES.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|ia64_output_reg_names
index|[
literal|8
index|]
init|=
block|{
literal|"out0"
block|,
literal|"out1"
block|,
literal|"out2"
block|,
literal|"out3"
block|,
literal|"out4"
block|,
literal|"out5"
block|,
literal|"out6"
block|,
literal|"out7"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* String used with the -mfixed-range= option.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|ia64_fixed_range_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Determines whether we use adds, addl, or movl to generate our    TLS immediate offsets.  */
end_comment

begin_decl_stmt
name|int
name|ia64_tls_size
init|=
literal|22
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* String used with the -mtls-size= option.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|ia64_tls_size_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Which cpu are we scheduling for.  */
end_comment

begin_decl_stmt
name|enum
name|processor_type
name|ia64_tune
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* String used with the -tune= option.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|ia64_tune_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Determines whether we run our final scheduling pass or not.  We always    avoid the normal second scheduling pass.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ia64_flag_schedule_insns2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Variables which are this size or smaller are put in the sdata/sbss    sections.  */
end_comment

begin_decl_stmt
name|unsigned
name|int
name|ia64_section_threshold
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following variable is used by the DFA insn scheduler.  The value is    TRUE if we do insn bundling instead of insn scheduling.  */
end_comment

begin_decl_stmt
name|int
name|bundling_p
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Structure to be filled in by ia64_compute_frame_size with register    save masks and offsets for the current function.  */
end_comment

begin_struct
struct|struct
name|ia64_frame_info
block|{
name|HOST_WIDE_INT
name|total_size
decl_stmt|;
comment|/* size of the stack frame, not including 				   the caller's scratch area.  */
name|HOST_WIDE_INT
name|spill_cfa_off
decl_stmt|;
comment|/* top of the reg spill area from the cfa.  */
name|HOST_WIDE_INT
name|spill_size
decl_stmt|;
comment|/* size of the gr/br/fr spill area.  */
name|HOST_WIDE_INT
name|extra_spill_size
decl_stmt|;
comment|/* size of spill area for others.  */
name|HARD_REG_SET
name|mask
decl_stmt|;
comment|/* mask of saved registers.  */
name|unsigned
name|int
name|gr_used_mask
decl_stmt|;
comment|/* mask of registers in use as gr spill 				   registers or long-term scratches.  */
name|int
name|n_spilled
decl_stmt|;
comment|/* number of spilled registers.  */
name|int
name|reg_fp
decl_stmt|;
comment|/* register for fp.  */
name|int
name|reg_save_b0
decl_stmt|;
comment|/* save register for b0.  */
name|int
name|reg_save_pr
decl_stmt|;
comment|/* save register for prs.  */
name|int
name|reg_save_ar_pfs
decl_stmt|;
comment|/* save register for ar.pfs.  */
name|int
name|reg_save_ar_unat
decl_stmt|;
comment|/* save register for ar.unat.  */
name|int
name|reg_save_ar_lc
decl_stmt|;
comment|/* save register for ar.lc.  */
name|int
name|reg_save_gp
decl_stmt|;
comment|/* save register for gp.  */
name|int
name|n_input_regs
decl_stmt|;
comment|/* number of input registers used.  */
name|int
name|n_local_regs
decl_stmt|;
comment|/* number of local registers used.  */
name|int
name|n_output_regs
decl_stmt|;
comment|/* number of output registers used.  */
name|int
name|n_rotate_regs
decl_stmt|;
comment|/* number of rotating registers used.  */
name|char
name|need_regstk
decl_stmt|;
comment|/* true if a .regstk directive needed.  */
name|char
name|initialized
decl_stmt|;
comment|/* true if the data is finalized.  */
block|}
struct|;
end_struct

begin_comment
comment|/* Current frame information calculated by ia64_compute_frame_size.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ia64_frame_info
name|current_frame_info
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function_decl
specifier|static
name|int
name|ia64_use_dfa_pipeline_interface
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ia64_first_cycle_multipass_dfa_lookahead
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ia64_dependencies_evaluation_hook
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ia64_init_dfa_pre_cycle_insn
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|ia64_dfa_pre_cycle_insn
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ia64_first_cycle_multipass_dfa_lookahead_guard
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ia64_dfa_new_cycle
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|gen_tls_get_addr
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|gen_thread_pointer
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|ia64_expand_tls_address
parameter_list|(
name|enum
name|tls_model
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|find_gr_spill
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|next_scratch_gr_reg
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mark_reg_gr_used_mask
parameter_list|(
name|rtx
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ia64_compute_frame_size
parameter_list|(
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|setup_spill_pointers
parameter_list|(
name|int
parameter_list|,
name|rtx
parameter_list|,
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|finish_spill_pointers
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|spill_restore_mem
parameter_list|(
name|rtx
parameter_list|,
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_spill
parameter_list|(
name|rtx
function_decl|(
modifier|*
function_decl|)
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
parameter_list|,
name|rtx
parameter_list|,
name|HOST_WIDE_INT
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_restore
parameter_list|(
name|rtx
function_decl|(
modifier|*
function_decl|)
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
parameter_list|,
name|rtx
parameter_list|,
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|gen_movdi_x
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|gen_fr_spill_x
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|gen_fr_restore_x
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|machine_mode
name|hfa_element_mode
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|ia64_function_ok_for_sibcall
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|ia64_rtx_costs
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fix_range
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|machine_function
modifier|*
name|ia64_init_machine_status
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|emit_insn_group_barriers
parameter_list|(
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|emit_all_insn_group_barriers
parameter_list|(
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|final_emit_insn_group_barriers
parameter_list|(
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|emit_predicate_relation_info
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ia64_reorg
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|ia64_in_small_data_p
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|process_epilogue
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|process_set
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|ia64_expand_fetch_and_op
parameter_list|(
name|optab
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|tree
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|ia64_expand_op_and_fetch
parameter_list|(
name|optab
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|tree
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|ia64_expand_compare_and_swap
parameter_list|(
name|enum
name|machine_mode
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|int
parameter_list|,
name|tree
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|ia64_expand_lock_test_and_set
parameter_list|(
name|enum
name|machine_mode
parameter_list|,
name|tree
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|ia64_expand_lock_release
parameter_list|(
name|enum
name|machine_mode
parameter_list|,
name|tree
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|ia64_assemble_integer
parameter_list|(
name|rtx
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ia64_output_function_prologue
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ia64_output_function_epilogue
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ia64_output_function_end_prologue
parameter_list|(
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ia64_issue_rate
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ia64_adjust_cost
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ia64_sched_init
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ia64_sched_finish
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ia64_dfa_sched_reorder
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|,
name|rtx
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ia64_sched_reorder
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|,
name|rtx
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ia64_sched_reorder2
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|,
name|rtx
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ia64_variable_issue
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|bundle_state
modifier|*
name|get_free_bundle_state
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_bundle_state
parameter_list|(
name|struct
name|bundle_state
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|initiate_bundle_states
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|finish_bundle_states
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|bundle_state_hash
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bundle_state_eq_p
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|insert_bundle_state
parameter_list|(
name|struct
name|bundle_state
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|initiate_bundle_state_table
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|finish_bundle_state_table
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|try_issue_nops
parameter_list|(
name|struct
name|bundle_state
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|try_issue_insn
parameter_list|(
name|struct
name|bundle_state
modifier|*
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|issue_nops_and_insn
parameter_list|(
name|struct
name|bundle_state
modifier|*
parameter_list|,
name|int
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_max_pos
parameter_list|(
name|state_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_template
parameter_list|(
name|state_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|get_next_important_insn
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bundling
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ia64_output_mi_thunk
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|HOST_WIDE_INT
parameter_list|,
name|HOST_WIDE_INT
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ia64_file_start
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ia64_select_rtx_section
parameter_list|(
name|enum
name|machine_mode
parameter_list|,
name|rtx
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|ia64_rwreloc_select_section
argument_list|(
name|tree
argument_list|,
name|int
argument_list|,
name|unsigned
name|HOST_WIDE_INT
argument_list|)
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ia64_rwreloc_unique_section
argument_list|(
name|tree
argument_list|,
name|int
argument_list|)
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ia64_rwreloc_select_rtx_section
argument_list|(
expr|enum
name|machine_mode
argument_list|,
name|rtx
argument_list|,
name|unsigned
name|HOST_WIDE_INT
argument_list|)
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|ia64_rwreloc_section_type_flags
argument_list|(
name|tree
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|int
argument_list|)
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ia64_hpux_add_extern_decl
argument_list|(
name|tree
name|decl
argument_list|)
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ia64_hpux_file_end
argument_list|(
name|void
argument_list|)
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ia64_hpux_init_libfuncs
argument_list|(
name|void
argument_list|)
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ia64_vms_init_libfuncs
argument_list|(
name|void
argument_list|)
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|tree
name|ia64_handle_model_attribute
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ia64_encode_section_info
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|ia64_struct_value_rtx
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Table of valid machine attributes.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|attribute_spec
name|ia64_attribute_table
index|[]
init|=
block|{
comment|/* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */
block|{
literal|"syscall_linkage"
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|true
block|,
name|true
block|,
name|NULL
block|}
block|,
block|{
literal|"model"
block|,
literal|1
block|,
literal|1
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|ia64_handle_model_attribute
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize the GCC target structure.  */
end_comment

begin_undef
undef|#
directive|undef
name|TARGET_ATTRIBUTE_TABLE
end_undef

begin_define
define|#
directive|define
name|TARGET_ATTRIBUTE_TABLE
value|ia64_attribute_table
end_define

begin_undef
undef|#
directive|undef
name|TARGET_INIT_BUILTINS
end_undef

begin_define
define|#
directive|define
name|TARGET_INIT_BUILTINS
value|ia64_init_builtins
end_define

begin_undef
undef|#
directive|undef
name|TARGET_EXPAND_BUILTIN
end_undef

begin_define
define|#
directive|define
name|TARGET_EXPAND_BUILTIN
value|ia64_expand_builtin
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_BYTE_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_BYTE_OP
value|"\tdata1\t"
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_ALIGNED_HI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_ALIGNED_HI_OP
value|"\tdata2\t"
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_ALIGNED_SI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_ALIGNED_SI_OP
value|"\tdata4\t"
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_ALIGNED_DI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_ALIGNED_DI_OP
value|"\tdata8\t"
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_UNALIGNED_HI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_UNALIGNED_HI_OP
value|"\tdata2.ua\t"
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_UNALIGNED_SI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_UNALIGNED_SI_OP
value|"\tdata4.ua\t"
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_UNALIGNED_DI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_UNALIGNED_DI_OP
value|"\tdata8.ua\t"
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_INTEGER
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_INTEGER
value|ia64_assemble_integer
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_FUNCTION_PROLOGUE
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_FUNCTION_PROLOGUE
value|ia64_output_function_prologue
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_FUNCTION_END_PROLOGUE
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_FUNCTION_END_PROLOGUE
value|ia64_output_function_end_prologue
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_FUNCTION_EPILOGUE
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_FUNCTION_EPILOGUE
value|ia64_output_function_epilogue
end_define

begin_undef
undef|#
directive|undef
name|TARGET_IN_SMALL_DATA_P
end_undef

begin_define
define|#
directive|define
name|TARGET_IN_SMALL_DATA_P
value|ia64_in_small_data_p
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_ADJUST_COST
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_ADJUST_COST
value|ia64_adjust_cost
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_ISSUE_RATE
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_ISSUE_RATE
value|ia64_issue_rate
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_VARIABLE_ISSUE
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_VARIABLE_ISSUE
value|ia64_variable_issue
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_INIT
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_INIT
value|ia64_sched_init
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_FINISH
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_FINISH
value|ia64_sched_finish
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_REORDER
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_REORDER
value|ia64_sched_reorder
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_REORDER2
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_REORDER2
value|ia64_sched_reorder2
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_DEPENDENCIES_EVALUATION_HOOK
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_DEPENDENCIES_EVALUATION_HOOK
value|ia64_dependencies_evaluation_hook
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE
value|ia64_use_dfa_pipeline_interface
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD
value|ia64_first_cycle_multipass_dfa_lookahead
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_INIT_DFA_PRE_CYCLE_INSN
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_INIT_DFA_PRE_CYCLE_INSN
value|ia64_init_dfa_pre_cycle_insn
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_DFA_PRE_CYCLE_INSN
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_DFA_PRE_CYCLE_INSN
value|ia64_dfa_pre_cycle_insn
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD_GUARD
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD_GUARD
define|\
value|ia64_first_cycle_multipass_dfa_lookahead_guard
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_DFA_NEW_CYCLE
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_DFA_NEW_CYCLE
value|ia64_dfa_new_cycle
end_define

begin_undef
undef|#
directive|undef
name|TARGET_FUNCTION_OK_FOR_SIBCALL
end_undef

begin_define
define|#
directive|define
name|TARGET_FUNCTION_OK_FOR_SIBCALL
value|ia64_function_ok_for_sibcall
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_OUTPUT_MI_THUNK
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_OUTPUT_MI_THUNK
value|ia64_output_mi_thunk
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_CAN_OUTPUT_MI_THUNK
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_CAN_OUTPUT_MI_THUNK
value|hook_bool_tree_hwi_hwi_tree_true
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_FILE_START
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_FILE_START
value|ia64_file_start
end_define

begin_undef
undef|#
directive|undef
name|TARGET_RTX_COSTS
end_undef

begin_define
define|#
directive|define
name|TARGET_RTX_COSTS
value|ia64_rtx_costs
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ADDRESS_COST
end_undef

begin_define
define|#
directive|define
name|TARGET_ADDRESS_COST
value|hook_int_rtx_0
end_define

begin_undef
undef|#
directive|undef
name|TARGET_MACHINE_DEPENDENT_REORG
end_undef

begin_define
define|#
directive|define
name|TARGET_MACHINE_DEPENDENT_REORG
value|ia64_reorg
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ENCODE_SECTION_INFO
end_undef

begin_define
define|#
directive|define
name|TARGET_ENCODE_SECTION_INFO
value|ia64_encode_section_info
end_define

begin_undef
undef|#
directive|undef
name|TARGET_STRUCT_VALUE_RTX
end_undef

begin_define
define|#
directive|define
name|TARGET_STRUCT_VALUE_RTX
value|ia64_struct_value_rtx
end_define

begin_decl_stmt
name|struct
name|gcc_target
name|targetm
init|=
name|TARGET_INITIALIZER
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Return 1 if OP is a valid operand for the MEM of a CALL insn.  */
end_comment

begin_function
name|int
name|call_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP refers to a symbol in the sdata section.  */
end_comment

begin_function
name|int
name|sdata_symbolic_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|HOST_WIDE_INT
name|offset
init|=
literal|0
decl_stmt|,
name|size
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|CONST
case|:
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
break|break;
name|offset
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* FALLTHRU */
case|case
name|SYMBOL_REF
case|:
if|if
condition|(
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|op
argument_list|)
condition|)
block|{
name|size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|get_pool_mode
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|ia64_section_threshold
condition|)
return|return
name|false
return|;
block|}
else|else
block|{
name|tree
name|t
decl_stmt|;
if|if
condition|(
operator|!
name|SYMBOL_REF_LOCAL_P
argument_list|(
name|op
argument_list|)
operator|||
operator|!
name|SYMBOL_REF_SMALL_P
argument_list|(
name|op
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Note that in addition to DECLs, we can get various forms 	     of constants here.  */
name|t
operator|=
name|SYMBOL_REF_DECL
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_P
argument_list|(
name|t
argument_list|)
condition|)
name|t
operator|=
name|DECL_SIZE_UNIT
argument_list|(
name|t
argument_list|)
expr_stmt|;
else|else
name|t
operator|=
name|TYPE_SIZE_UNIT
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|&&
name|host_integerp
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|size
operator|=
name|tree_low_cst
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|0
condition|)
name|size
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Deny the stupid user trick of addressing outside the object.  Such 	 things quickly result in GPREL22 relocation overflows.  Of course, 	 they're also highly undefined.  From a pure pedant's point of view 	 they deserve a slap on the wrist (such as provided by a relocation 	 overflow), but that just leads to bugzilla noise.  */
return|return
operator|(
name|offset
operator|>=
literal|0
operator|&&
name|offset
operator|<=
name|size
operator|)
return|;
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|small_addr_symbolic_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|SYMBOL_REF_SMALL_ADDR_P
argument_list|(
name|op
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP refers to a symbol, and is appropriate for a GOT load.  */
end_comment

begin_function
name|int
name|got_symbolic_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|CONST
case|:
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|PLUS
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|SYMBOL_REF
condition|)
return|return
literal|0
return|;
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
comment|/* Ok if we're not using GOT entries at all.  */
if|if
condition|(
name|TARGET_NO_PIC
operator|||
name|TARGET_AUTO_PIC
condition|)
return|return
literal|1
return|;
comment|/* "Ok" while emitting rtl, since otherwise we won't be provided 	 with the entire offset during emission, which makes it very 	 hard to split the offset into high and low parts.  */
if|if
condition|(
name|rtx_equal_function_value_matters
condition|)
return|return
literal|1
return|;
comment|/* Force the low 14 bits of the constant to zero so that we do not 	 use up so many GOT entries.  */
return|return
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|&
literal|0x3fff
operator|)
operator|==
literal|0
return|;
case|case
name|SYMBOL_REF
case|:
if|if
condition|(
name|SYMBOL_REF_SMALL_ADDR_P
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|0
return|;
case|case
name|LABEL_REF
case|:
return|return
literal|1
return|;
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP refers to a symbol.  */
end_comment

begin_function
name|int
name|symbolic_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|CONST
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
return|return
literal|1
return|;
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return tls_model if OP refers to a TLS symbol.  */
end_comment

begin_function
name|int
name|tls_symbolic_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|SYMBOL_REF
condition|)
return|return
literal|0
return|;
return|return
name|SYMBOL_REF_TLS_MODEL
argument_list|(
name|op
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP refers to a function.  */
end_comment

begin_function
name|int
name|function_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|SYMBOL_REF_FUNCTION_P
argument_list|(
name|op
argument_list|)
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is setjmp or a similar function.  */
end_comment

begin_comment
comment|/* ??? This is an unsatisfying solution.  Should rethink.  */
end_comment

begin_function
name|int
name|setjmp_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|SYMBOL_REF
condition|)
return|return
literal|0
return|;
name|name
operator|=
name|XSTR
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* The following code is borrowed from special_function_p in calls.c.  */
comment|/* Disregard prefix _, __ or __x.  */
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'_'
condition|)
block|{
if|if
condition|(
name|name
index|[
literal|1
index|]
operator|==
literal|'_'
operator|&&
name|name
index|[
literal|2
index|]
operator|==
literal|'x'
condition|)
name|name
operator|+=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|name
index|[
literal|1
index|]
operator|==
literal|'_'
condition|)
name|name
operator|+=
literal|2
expr_stmt|;
else|else
name|name
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'s'
condition|)
block|{
name|retval
operator|=
operator|(
operator|(
name|name
index|[
literal|1
index|]
operator|==
literal|'e'
operator|&&
operator|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"setjmp"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"setjmp_syscall"
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|name
index|[
literal|1
index|]
operator|==
literal|'i'
operator|&&
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"sigsetjmp"
argument_list|)
operator|)
operator|||
operator|(
name|name
index|[
literal|1
index|]
operator|==
literal|'a'
operator|&&
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"savectx"
argument_list|)
operator|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|name
index|[
literal|0
index|]
operator|==
literal|'q'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'s'
operator|&&
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"qsetjmp"
argument_list|)
operator|)
operator|||
operator|(
name|name
index|[
literal|0
index|]
operator|==
literal|'v'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'f'
operator|&&
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"vfork"
argument_list|)
operator|)
condition|)
name|retval
operator|=
literal|1
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a general operand, excluding tls symbolic operands.  */
end_comment

begin_function
name|int
name|move_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
return|return
name|general_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|&&
operator|!
name|tls_symbolic_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a register operand that is (or could be) a GR reg.  */
end_comment

begin_function
name|int
name|gr_register_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
condition|)
block|{
name|unsigned
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
return|return
name|GENERAL_REGNO_P
argument_list|(
name|regno
argument_list|)
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a register operand that is (or could be) an FR reg.  */
end_comment

begin_function
name|int
name|fr_register_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
condition|)
block|{
name|unsigned
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
return|return
name|FR_REGNO_P
argument_list|(
name|regno
argument_list|)
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a register operand that is (or could be) a GR/FR reg.  */
end_comment

begin_function
name|int
name|grfr_register_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
condition|)
block|{
name|unsigned
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
return|return
name|GENERAL_REGNO_P
argument_list|(
name|regno
argument_list|)
operator|||
name|FR_REGNO_P
argument_list|(
name|regno
argument_list|)
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a nonimmediate operand that is (or could be) a GR reg.  */
end_comment

begin_function
name|int
name|gr_nonimmediate_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|nonimmediate_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
condition|)
block|{
name|unsigned
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
return|return
name|GENERAL_REGNO_P
argument_list|(
name|regno
argument_list|)
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a nonimmediate operand that is (or could be) a FR reg.  */
end_comment

begin_function
name|int
name|fr_nonimmediate_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|nonimmediate_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
condition|)
block|{
name|unsigned
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
return|return
name|FR_REGNO_P
argument_list|(
name|regno
argument_list|)
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a nonimmediate operand that is a GR/FR reg.  */
end_comment

begin_function
name|int
name|grfr_nonimmediate_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|nonimmediate_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
condition|)
block|{
name|unsigned
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
return|return
name|GENERAL_REGNO_P
argument_list|(
name|regno
argument_list|)
operator|||
name|FR_REGNO_P
argument_list|(
name|regno
argument_list|)
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a GR register operand, or zero.  */
end_comment

begin_function
name|int
name|gr_reg_or_0_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
return|return
operator|(
name|op
operator|==
name|const0_rtx
operator|||
name|gr_register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a GR register operand, or a 5 bit immediate operand.  */
end_comment

begin_function
name|int
name|gr_reg_or_5bit_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
return|return
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|>=
literal|0
operator|&&
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<
literal|32
operator|)
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONSTANT_P_RTX
operator|||
name|gr_register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a GR register operand, or a 6 bit immediate operand.  */
end_comment

begin_function
name|int
name|gr_reg_or_6bit_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
return|return
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|CONST_OK_FOR_M
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|)
operator|)
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONSTANT_P_RTX
operator|||
name|gr_register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a GR register operand, or an 8 bit immediate operand.  */
end_comment

begin_function
name|int
name|gr_reg_or_8bit_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
return|return
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|CONST_OK_FOR_K
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|)
operator|)
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONSTANT_P_RTX
operator|||
name|gr_register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a GR/FR register operand, or an 8 bit immediate.  */
end_comment

begin_function
name|int
name|grfr_reg_or_8bit_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
return|return
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|CONST_OK_FOR_K
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|)
operator|)
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONSTANT_P_RTX
operator|||
name|grfr_register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a register operand, or an 8 bit adjusted immediate    operand.  */
end_comment

begin_function
name|int
name|gr_reg_or_8bit_adjusted_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
return|return
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|CONST_OK_FOR_L
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|)
operator|)
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONSTANT_P_RTX
operator|||
name|gr_register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a register operand, or is valid for both an 8 bit    immediate and an 8 bit adjusted immediate operand.  This is necessary    because when we emit a compare, we don't know what the condition will be,    so we need the union of the immediates accepted by GT and LT.  */
end_comment

begin_function
name|int
name|gr_reg_or_8bit_and_adjusted_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
return|return
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|CONST_OK_FOR_K
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|)
operator|&&
name|CONST_OK_FOR_L
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|)
operator|)
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONSTANT_P_RTX
operator|||
name|gr_register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a register operand, or a 14 bit immediate operand.  */
end_comment

begin_function
name|int
name|gr_reg_or_14bit_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
return|return
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|CONST_OK_FOR_I
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|)
operator|)
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONSTANT_P_RTX
operator|||
name|gr_register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a register operand, or a 22 bit immediate operand.  */
end_comment

begin_function
name|int
name|gr_reg_or_22bit_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
return|return
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|CONST_OK_FOR_J
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|)
operator|)
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONSTANT_P_RTX
operator|||
name|gr_register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a 6 bit immediate operand.  */
end_comment

begin_function
name|int
name|shift_count_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|CONST_OK_FOR_M
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|)
operator|)
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONSTANT_P_RTX
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a 5 bit immediate operand.  */
end_comment

begin_function
name|int
name|shift_32bit_count_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|>=
literal|0
operator|&&
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<
literal|32
operator|)
operator|)
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONSTANT_P_RTX
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a 2, 4, 8, or 16 immediate operand.  */
end_comment

begin_function
name|int
name|shladd_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|==
literal|2
operator|||
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|==
literal|4
operator|||
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|==
literal|8
operator|||
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|==
literal|16
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a -16, -8, -4, -1, 1, 4, 8, or 16 immediate operand.  */
end_comment

begin_function
name|int
name|fetchadd_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|==
operator|-
literal|16
operator|||
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|==
operator|-
literal|8
operator|||
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|==
operator|-
literal|4
operator|||
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|==
literal|1
operator|||
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|==
literal|4
operator|||
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|==
literal|8
operator|||
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|==
literal|16
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a floating-point constant zero, one, or a register.  */
end_comment

begin_function
name|int
name|fr_reg_or_fp01_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
return|return
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|CONST_DOUBLE_OK_FOR_G
argument_list|(
name|op
argument_list|)
operator|)
operator|||
name|fr_register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Like nonimmediate_operand, but don't allow MEMs that try to use a    POST_MODIFY with a REG as displacement.  */
end_comment

begin_function
name|int
name|destination_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|nonimmediate_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|POST_MODIFY
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Like memory_operand, but don't allow post-increments.  */
end_comment

begin_function
name|int
name|not_postinc_memory_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
return|return
operator|(
name|memory_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
literal|'a'
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if this is a comparison operator, which accepts a normal 8-bit    signed immediate operand.  */
end_comment

begin_function
name|int
name|normal_comparison_operator
parameter_list|(
specifier|register
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
return|return
operator|(
operator|(
name|mode
operator|==
name|VOIDmode
operator|||
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|mode
operator|)
operator|&&
operator|(
name|code
operator|==
name|EQ
operator|||
name|code
operator|==
name|NE
operator|||
name|code
operator|==
name|GT
operator|||
name|code
operator|==
name|LE
operator|||
name|code
operator|==
name|GTU
operator|||
name|code
operator|==
name|LEU
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if this is a comparison operator, which accepts an adjusted 8-bit    signed immediate operand.  */
end_comment

begin_function
name|int
name|adjusted_comparison_operator
parameter_list|(
specifier|register
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
return|return
operator|(
operator|(
name|mode
operator|==
name|VOIDmode
operator|||
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|mode
operator|)
operator|&&
operator|(
name|code
operator|==
name|LT
operator|||
name|code
operator|==
name|GE
operator|||
name|code
operator|==
name|LTU
operator|||
name|code
operator|==
name|GEU
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if this is a signed inequality operator.  */
end_comment

begin_function
name|int
name|signed_inequality_operator
parameter_list|(
specifier|register
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
return|return
operator|(
operator|(
name|mode
operator|==
name|VOIDmode
operator|||
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|mode
operator|)
operator|&&
operator|(
name|code
operator|==
name|GE
operator|||
name|code
operator|==
name|GT
operator|||
name|code
operator|==
name|LE
operator|||
name|code
operator|==
name|LT
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if this operator is valid for predication.  */
end_comment

begin_function
name|int
name|predicate_operator
parameter_list|(
specifier|register
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
return|return
operator|(
operator|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|mode
operator|||
name|mode
operator|==
name|VOIDmode
operator|)
operator|&&
operator|(
name|code
operator|==
name|EQ
operator|||
name|code
operator|==
name|NE
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if this operator can be used in a conditional operation.  */
end_comment

begin_function
name|int
name|condop_operator
parameter_list|(
specifier|register
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
return|return
operator|(
operator|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|mode
operator|||
name|mode
operator|==
name|VOIDmode
operator|)
operator|&&
operator|(
name|code
operator|==
name|PLUS
operator|||
name|code
operator|==
name|MINUS
operator|||
name|code
operator|==
name|AND
operator|||
name|code
operator|==
name|IOR
operator|||
name|code
operator|==
name|XOR
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if this is the ar.lc register.  */
end_comment

begin_function
name|int
name|ar_lc_reg_operand
parameter_list|(
specifier|register
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
return|return
operator|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|DImode
operator|&&
operator|(
name|mode
operator|==
name|DImode
operator|||
name|mode
operator|==
name|VOIDmode
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|==
name|AR_LC_REGNUM
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if this is the ar.ccv register.  */
end_comment

begin_function
name|int
name|ar_ccv_reg_operand
parameter_list|(
specifier|register
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
return|return
operator|(
operator|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|mode
operator|||
name|mode
operator|==
name|VOIDmode
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|==
name|AR_CCV_REGNUM
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if this is the ar.pfs register.  */
end_comment

begin_function
name|int
name|ar_pfs_reg_operand
parameter_list|(
specifier|register
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
return|return
operator|(
operator|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|==
name|mode
operator|||
name|mode
operator|==
name|VOIDmode
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|==
name|AR_PFS_REGNUM
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Like general_operand, but don't allow (mem (addressof)).  */
end_comment

begin_function
name|int
name|general_xfmode_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|general_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ADDRESSOF
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Similarly.  */
end_comment

begin_function
name|int
name|destination_xfmode_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|destination_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ADDRESSOF
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Similarly.  */
end_comment

begin_function
name|int
name|xfreg_or_fp01_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
return|return
literal|0
return|;
return|return
name|fr_reg_or_fp01_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is valid as a base register in a reg + offset address.  */
end_comment

begin_function
name|int
name|basereg_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
comment|/* ??? Should I copy the flag_omit_frame_pointer and cse_not_expected      checks from pa.c basereg_operand as well?  Seems to be OK without them      in test runs.  */
return|return
operator|(
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|&&
name|REG_POINTER
argument_list|(
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
operator|)
condition|?
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
else|:
name|op
argument_list|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_typedef
typedef|typedef
enum|enum
block|{
name|ADDR_AREA_NORMAL
block|,
comment|/* normal address area */
name|ADDR_AREA_SMALL
comment|/* addressable by "addl" (-2MB< addr< 2MB) */
block|}
name|ia64_addr_area
typedef|;
end_typedef

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|small_ident1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|small_ident2
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|init_idents
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|small_ident1
operator|==
literal|0
condition|)
block|{
name|small_ident1
operator|=
name|get_identifier
argument_list|(
literal|"small"
argument_list|)
expr_stmt|;
name|small_ident2
operator|=
name|get_identifier
argument_list|(
literal|"__small__"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Retrieve the address area that has been chosen for the given decl.  */
end_comment

begin_function
specifier|static
name|ia64_addr_area
name|ia64_get_addr_area
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|tree
name|model_attr
decl_stmt|;
name|model_attr
operator|=
name|lookup_attribute
argument_list|(
literal|"model"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|model_attr
condition|)
block|{
name|tree
name|id
decl_stmt|;
name|init_idents
argument_list|()
expr_stmt|;
name|id
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_VALUE
argument_list|(
name|model_attr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|==
name|small_ident1
operator|||
name|id
operator|==
name|small_ident2
condition|)
return|return
name|ADDR_AREA_SMALL
return|;
block|}
return|return
name|ADDR_AREA_NORMAL
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|ia64_handle_model_attribute
parameter_list|(
name|tree
modifier|*
name|node
parameter_list|,
name|tree
name|name
parameter_list|,
name|tree
name|args
parameter_list|,
name|int
name|flags
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bool
modifier|*
name|no_add_attrs
parameter_list|)
block|{
name|ia64_addr_area
name|addr_area
init|=
name|ADDR_AREA_NORMAL
decl_stmt|;
name|ia64_addr_area
name|area
decl_stmt|;
name|tree
name|arg
decl_stmt|,
name|decl
init|=
operator|*
name|node
decl_stmt|;
name|init_idents
argument_list|()
expr_stmt|;
name|arg
operator|=
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|small_ident1
operator|||
name|arg
operator|==
name|small_ident2
condition|)
block|{
name|addr_area
operator|=
name|ADDR_AREA_SMALL
expr_stmt|;
block|}
else|else
block|{
name|warning
argument_list|(
literal|"invalid argument of `%s' attribute"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
case|case
name|VAR_DECL
case|:
if|if
condition|(
operator|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
operator|)
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%Jan address area attribute cannot be specified for "
literal|"local variables"
argument_list|,
name|decl
argument_list|,
name|decl
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
name|area
operator|=
name|ia64_get_addr_area
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|area
operator|!=
name|ADDR_AREA_NORMAL
operator|&&
name|addr_area
operator|!=
name|area
condition|)
block|{
name|error
argument_list|(
literal|"%Jaddress area of '%s' conflicts with previous "
literal|"declaration"
argument_list|,
name|decl
argument_list|,
name|decl
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
break|break;
case|case
name|FUNCTION_DECL
case|:
name|error
argument_list|(
literal|"%Jaddress area attribute cannot be specified for functions"
argument_list|,
name|decl
argument_list|,
name|decl
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
break|break;
default|default:
name|warning
argument_list|(
literal|"`%s' attribute ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
break|break;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ia64_encode_addr_area
parameter_list|(
name|tree
name|decl
parameter_list|,
name|rtx
name|symbol
parameter_list|)
block|{
name|int
name|flags
decl_stmt|;
name|flags
operator|=
name|SYMBOL_REF_FLAGS
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ia64_get_addr_area
argument_list|(
name|decl
argument_list|)
condition|)
block|{
case|case
name|ADDR_AREA_NORMAL
case|:
break|break;
case|case
name|ADDR_AREA_SMALL
case|:
name|flags
operator||=
name|SYMBOL_FLAG_SMALL_ADDR
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|SYMBOL_REF_FLAGS
argument_list|(
name|symbol
argument_list|)
operator|=
name|flags
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ia64_encode_section_info
parameter_list|(
name|tree
name|decl
parameter_list|,
name|rtx
name|rtl
parameter_list|,
name|int
name|first
parameter_list|)
block|{
name|default_encode_section_info
argument_list|(
name|decl
argument_list|,
name|rtl
argument_list|,
name|first
argument_list|)
expr_stmt|;
comment|/* Careful not to prod global register variables.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
operator|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|||
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
name|ia64_encode_addr_area
argument_list|(
name|decl
argument_list|,
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if the operands of a move are ok.  */
end_comment

begin_function
name|int
name|ia64_move_ok
parameter_list|(
name|rtx
name|dst
parameter_list|,
name|rtx
name|src
parameter_list|)
block|{
comment|/* If we're under init_recog_no_volatile, we'll not be able to use      memory_operand.  So check the code directly and don't worry about      the validity of the underlying address, which should have been      checked elsewhere anyway.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|!=
name|MEM
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|MEM
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|register_operand
argument_list|(
name|src
argument_list|,
name|VOIDmode
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Otherwise, this must be a constant, and that either 0 or 0.0 or 1.0.  */
if|if
condition|(
name|INTEGRAL_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|dst
argument_list|)
argument_list|)
condition|)
return|return
name|src
operator|==
name|const0_rtx
return|;
else|else
return|return
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|CONST_DOUBLE_OK_FOR_G
argument_list|(
name|src
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|addp4_optimize_ok
parameter_list|(
name|rtx
name|op1
parameter_list|,
name|rtx
name|op2
parameter_list|)
block|{
return|return
operator|(
name|basereg_operand
argument_list|(
name|op1
argument_list|,
name|GET_MODE
argument_list|(
name|op1
argument_list|)
argument_list|)
operator|!=
name|basereg_operand
argument_list|(
name|op2
argument_list|,
name|GET_MODE
argument_list|(
name|op2
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Check if OP is a mask suitable for use with SHIFT in a dep.z instruction.    Return the length of the field, or<= 0 on failure.  */
end_comment

begin_function
name|int
name|ia64_depz_field_mask
parameter_list|(
name|rtx
name|rop
parameter_list|,
name|rtx
name|rshift
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|op
init|=
name|INTVAL
argument_list|(
name|rop
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|shift
init|=
name|INTVAL
argument_list|(
name|rshift
argument_list|)
decl_stmt|;
comment|/* Get rid of the zero bits we're shifting in.  */
name|op
operator|>>=
name|shift
expr_stmt|;
comment|/* We must now have a solid block of 1's at bit 0.  */
return|return
name|exact_log2
argument_list|(
name|op
operator|+
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Expand a symbolic constant load.  */
end_comment

begin_function
name|void
name|ia64_expand_load_address
parameter_list|(
name|rtx
name|dest
parameter_list|,
name|rtx
name|src
parameter_list|)
block|{
if|if
condition|(
name|tls_symbolic_operand
argument_list|(
name|src
argument_list|,
name|VOIDmode
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|!=
name|REG
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* ILP32 mode still loads 64-bits of data from the GOT.  This avoids      having to pointer-extend the value afterward.  Other forms of address      computation below are also more natural to compute as 64-bit quantities.      If we've been given an SImode destination register, change it.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
operator|!=
name|Pmode
condition|)
name|dest
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|REGNO
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|SYMBOL_REF_SMALL_ADDR_P
argument_list|(
name|src
argument_list|)
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|dest
argument_list|,
name|src
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|TARGET_AUTO_PIC
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_load_gprel64
argument_list|(
name|dest
argument_list|,
name|src
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|SYMBOL_REF_FUNCTION_P
argument_list|(
name|src
argument_list|)
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_load_fptr
argument_list|(
name|dest
argument_list|,
name|src
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|sdata_symbolic_operand
argument_list|(
name|src
argument_list|,
name|VOIDmode
argument_list|)
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_load_gprel
argument_list|(
name|dest
argument_list|,
name|src
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&
literal|0x1fff
operator|)
operator|!=
literal|0
condition|)
block|{
name|rtx
name|sym
init|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|ofs
decl_stmt|,
name|hi
decl_stmt|,
name|lo
decl_stmt|;
comment|/* Split the offset into a sign extended 14-bit low part 	 and a complementary high part.  */
name|ofs
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|lo
operator|=
operator|(
operator|(
name|ofs
operator|&
literal|0x3fff
operator|)
operator|^
literal|0x2000
operator|)
operator|-
literal|0x2000
expr_stmt|;
name|hi
operator|=
name|ofs
operator|-
name|lo
expr_stmt|;
name|ia64_expand_load_address
argument_list|(
name|dest
argument_list|,
name|plus_constant
argument_list|(
name|sym
argument_list|,
name|hi
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|dest
argument_list|,
name|dest
argument_list|,
name|GEN_INT
argument_list|(
name|lo
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|tmp
decl_stmt|;
name|tmp
operator|=
name|gen_rtx_HIGH
argument_list|(
name|Pmode
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|tmp
argument_list|,
name|pic_offset_table_rtx
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|dest
argument_list|,
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_LO_SUM
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|,
name|dest
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|dest
argument_list|,
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|rtx
name|gen_tls_tga
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|rtx
name|gen_tls_get_addr
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|gen_tls_tga
condition|)
name|gen_tls_tga
operator|=
name|init_one_libfunc
argument_list|(
literal|"__tls_get_addr"
argument_list|)
expr_stmt|;
return|return
name|gen_tls_tga
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|rtx
name|thread_pointer_rtx
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|rtx
name|gen_thread_pointer
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|thread_pointer_rtx
condition|)
block|{
name|thread_pointer_rtx
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|13
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|thread_pointer_rtx
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|thread_pointer_rtx
return|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|ia64_expand_tls_address
parameter_list|(
name|enum
name|tls_model
name|tls_kind
parameter_list|,
name|rtx
name|op0
parameter_list|,
name|rtx
name|op1
parameter_list|)
block|{
name|rtx
name|tga_op1
decl_stmt|,
name|tga_op2
decl_stmt|,
name|tga_ret
decl_stmt|,
name|tga_eqv
decl_stmt|,
name|tmp
decl_stmt|,
name|insns
decl_stmt|;
name|rtx
name|orig_op0
init|=
name|op0
decl_stmt|;
switch|switch
condition|(
name|tls_kind
condition|)
block|{
case|case
name|TLS_MODEL_GLOBAL_DYNAMIC
case|:
name|start_sequence
argument_list|()
expr_stmt|;
name|tga_op1
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_load_ltoff_dtpmod
argument_list|(
name|tga_op1
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
name|tga_op1
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|tga_op1
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|tga_op1
argument_list|)
operator|=
literal|1
expr_stmt|;
name|tga_op2
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_load_ltoff_dtprel
argument_list|(
name|tga_op2
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
name|tga_op2
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|tga_op2
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|tga_op2
argument_list|)
operator|=
literal|1
expr_stmt|;
name|tga_ret
operator|=
name|emit_library_call_value
argument_list|(
name|gen_tls_get_addr
argument_list|()
argument_list|,
name|NULL_RTX
argument_list|,
name|LCT_CONST
argument_list|,
name|Pmode
argument_list|,
literal|2
argument_list|,
name|tga_op1
argument_list|,
name|Pmode
argument_list|,
name|tga_op2
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|Pmode
condition|)
name|op0
operator|=
name|tga_ret
expr_stmt|;
name|emit_libcall_block
argument_list|(
name|insns
argument_list|,
name|op0
argument_list|,
name|tga_ret
argument_list|,
name|op1
argument_list|)
expr_stmt|;
break|break;
case|case
name|TLS_MODEL_LOCAL_DYNAMIC
case|:
comment|/* ??? This isn't the completely proper way to do local-dynamic 	 If the call to __tls_get_addr is used only by a single symbol, 	 then we should (somehow) move the dtprel to the second arg 	 to avoid the extra add.  */
name|start_sequence
argument_list|()
expr_stmt|;
name|tga_op1
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_load_ltoff_dtpmod
argument_list|(
name|tga_op1
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
name|tga_op1
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|tga_op1
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|tga_op1
argument_list|)
operator|=
literal|1
expr_stmt|;
name|tga_op2
operator|=
name|const0_rtx
expr_stmt|;
name|tga_ret
operator|=
name|emit_library_call_value
argument_list|(
name|gen_tls_get_addr
argument_list|()
argument_list|,
name|NULL_RTX
argument_list|,
name|LCT_CONST
argument_list|,
name|Pmode
argument_list|,
literal|2
argument_list|,
name|tga_op1
argument_list|,
name|Pmode
argument_list|,
name|tga_op2
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|tga_eqv
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|const0_rtx
argument_list|)
argument_list|,
name|UNSPEC_LD_BASE
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_libcall_block
argument_list|(
name|insns
argument_list|,
name|tmp
argument_list|,
name|tga_ret
argument_list|,
name|tga_eqv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|register_operand
argument_list|(
name|op0
argument_list|,
name|Pmode
argument_list|)
condition|)
name|op0
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_TLS64
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_load_dtprel
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|op0
argument_list|,
name|tmp
argument_list|,
name|op0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|emit_insn
argument_list|(
name|gen_add_dtprel
argument_list|(
name|op0
argument_list|,
name|tmp
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TLS_MODEL_INITIAL_EXEC
case|:
name|tmp
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_load_ltoff_tprel
argument_list|(
name|tmp
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|tmp
argument_list|)
operator|=
literal|1
expr_stmt|;
name|tmp
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|register_operand
argument_list|(
name|op0
argument_list|,
name|Pmode
argument_list|)
condition|)
name|op0
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|op0
argument_list|,
name|tmp
argument_list|,
name|gen_thread_pointer
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TLS_MODEL_LOCAL_EXEC
case|:
if|if
condition|(
operator|!
name|register_operand
argument_list|(
name|op0
argument_list|,
name|Pmode
argument_list|)
condition|)
name|op0
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_TLS64
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_load_tprel
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|op0
argument_list|,
name|gen_thread_pointer
argument_list|()
argument_list|,
name|op0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|emit_insn
argument_list|(
name|gen_add_tprel
argument_list|(
name|op0
argument_list|,
name|gen_thread_pointer
argument_list|()
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|orig_op0
operator|==
name|op0
condition|)
return|return
name|NULL_RTX
return|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|orig_op0
argument_list|)
operator|==
name|Pmode
condition|)
return|return
name|op0
return|;
return|return
name|gen_lowpart
argument_list|(
name|GET_MODE
argument_list|(
name|orig_op0
argument_list|)
argument_list|,
name|op0
argument_list|)
return|;
block|}
end_function

begin_function
name|rtx
name|ia64_expand_move
parameter_list|(
name|rtx
name|op0
parameter_list|,
name|rtx
name|op1
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|op0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|reload_in_progress
operator|&&
operator|!
name|reload_completed
operator|&&
operator|!
name|ia64_move_ok
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
condition|)
name|op1
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mode
operator|==
name|Pmode
operator|||
name|mode
operator|==
name|ptr_mode
operator|)
operator|&&
name|symbolic_operand
argument_list|(
name|op1
argument_list|,
name|VOIDmode
argument_list|)
condition|)
block|{
name|enum
name|tls_model
name|tls_kind
decl_stmt|;
if|if
condition|(
operator|(
name|tls_kind
operator|=
name|tls_symbolic_operand
argument_list|(
name|op1
argument_list|,
name|VOIDmode
argument_list|)
operator|)
condition|)
return|return
name|ia64_expand_tls_address
argument_list|(
name|tls_kind
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
return|;
if|if
condition|(
operator|!
name|TARGET_NO_PIC
operator|&&
name|reload_completed
condition|)
block|{
name|ia64_expand_load_address
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
return|return
name|NULL_RTX
return|;
block|}
block|}
return|return
name|op1
return|;
block|}
end_function

begin_comment
comment|/* Split a move from OP1 to OP0 conditional on COND.  */
end_comment

begin_function
name|void
name|ia64_emit_cond_move
parameter_list|(
name|rtx
name|op0
parameter_list|,
name|rtx
name|op1
parameter_list|,
name|rtx
name|cond
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|,
name|first
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
name|emit_move_insn
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|get_last_insn
argument_list|()
init|;
name|insn
operator|!=
name|first
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_COND_EXEC
argument_list|(
name|VOIDmode
argument_list|,
name|copy_rtx
argument_list|(
name|cond
argument_list|)
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Split a post-reload TImode or TFmode reference into two DImode    components.  This is made extra difficult by the fact that we do    not get any scratch registers to work with, because reload cannot    be prevented from giving us a scratch that overlaps the register    pair involved.  So instead, when addressing memory, we tweak the    pointer register up and back down with POST_INCs.  Or up and not    back down when we can get away with it.     REVERSED is true when the loads must be done in reversed order    (high word first) for correctness.  DEAD is true when the pointer    dies with the second insn we generate and therefore the second    address must not carry a postmodify.     May return an insn which is to be emitted after the moves.  */
end_comment

begin_function
specifier|static
name|rtx
name|ia64_split_tmode
parameter_list|(
name|rtx
name|out
index|[
literal|2
index|]
parameter_list|,
name|rtx
name|in
parameter_list|,
name|bool
name|reversed
parameter_list|,
name|bool
name|dead
parameter_list|)
block|{
name|rtx
name|fixup
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|in
argument_list|)
condition|)
block|{
case|case
name|REG
case|:
name|out
index|[
name|reversed
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|REGNO
argument_list|(
name|in
argument_list|)
argument_list|)
expr_stmt|;
name|out
index|[
operator|!
name|reversed
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|REGNO
argument_list|(
name|in
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
comment|/* Cannot occur reversed.  */
if|if
condition|(
name|reversed
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|in
argument_list|)
operator|!=
name|TFmode
condition|)
name|split_double
argument_list|(
name|in
argument_list|,
operator|&
name|out
index|[
literal|0
index|]
argument_list|,
operator|&
name|out
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
comment|/* split_double does not understand how to split a TFmode 	   quantity into a pair of DImode constants.  */
block|{
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|p
index|[
literal|2
index|]
decl_stmt|;
name|long
name|l
index|[
literal|4
index|]
decl_stmt|;
comment|/* TFmode is 128 bits */
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|r
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|real_to_target
argument_list|(
name|l
argument_list|,
operator|&
name|r
argument_list|,
name|TFmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|FLOAT_WORDS_BIG_ENDIAN
condition|)
block|{
name|p
index|[
literal|0
index|]
operator|=
operator|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|l
index|[
literal|0
index|]
operator|)
operator|<<
literal|32
operator|)
operator|+
name|l
index|[
literal|1
index|]
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
operator|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|l
index|[
literal|2
index|]
operator|)
operator|<<
literal|32
operator|)
operator|+
name|l
index|[
literal|3
index|]
expr_stmt|;
block|}
else|else
block|{
name|p
index|[
literal|0
index|]
operator|=
operator|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|l
index|[
literal|3
index|]
operator|)
operator|<<
literal|32
operator|)
operator|+
name|l
index|[
literal|2
index|]
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
operator|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|l
index|[
literal|1
index|]
operator|)
operator|<<
literal|32
operator|)
operator|+
name|l
index|[
literal|0
index|]
expr_stmt|;
block|}
name|out
index|[
literal|0
index|]
operator|=
name|GEN_INT
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|=
name|GEN_INT
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|MEM
case|:
block|{
name|rtx
name|base
init|=
name|XEXP
argument_list|(
name|in
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|offset
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
condition|)
block|{
case|case
name|REG
case|:
if|if
condition|(
operator|!
name|reversed
condition|)
block|{
name|out
index|[
literal|0
index|]
operator|=
name|adjust_automodify_address
argument_list|(
name|in
argument_list|,
name|DImode
argument_list|,
name|gen_rtx_POST_INC
argument_list|(
name|Pmode
argument_list|,
name|base
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|=
name|adjust_automodify_address
argument_list|(
name|in
argument_list|,
name|DImode
argument_list|,
name|dead
condition|?
literal|0
else|:
name|gen_rtx_POST_DEC
argument_list|(
name|Pmode
argument_list|,
name|base
argument_list|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Reversal requires a pre-increment, which can only 		   be done as a separate insn.  */
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|base
argument_list|,
name|base
argument_list|,
name|GEN_INT
argument_list|(
literal|8
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|out
index|[
literal|0
index|]
operator|=
name|adjust_automodify_address
argument_list|(
name|in
argument_list|,
name|DImode
argument_list|,
name|gen_rtx_POST_DEC
argument_list|(
name|Pmode
argument_list|,
name|base
argument_list|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|=
name|adjust_address
argument_list|(
name|in
argument_list|,
name|DImode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|POST_INC
case|:
if|if
condition|(
name|reversed
operator|||
name|dead
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Just do the increment in two steps.  */
name|out
index|[
literal|0
index|]
operator|=
name|adjust_automodify_address
argument_list|(
name|in
argument_list|,
name|DImode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|=
name|adjust_automodify_address
argument_list|(
name|in
argument_list|,
name|DImode
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|)
expr_stmt|;
break|break;
case|case
name|POST_DEC
case|:
if|if
condition|(
name|reversed
operator|||
name|dead
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Add 8, subtract 24.  */
name|base
operator|=
name|XEXP
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|out
index|[
literal|0
index|]
operator|=
name|adjust_automodify_address
argument_list|(
name|in
argument_list|,
name|DImode
argument_list|,
name|gen_rtx_POST_INC
argument_list|(
name|Pmode
argument_list|,
name|base
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|out
index|[
literal|1
index|]
operator|=
name|adjust_automodify_address
argument_list|(
name|in
argument_list|,
name|DImode
argument_list|,
name|gen_rtx_POST_MODIFY
argument_list|(
name|Pmode
argument_list|,
name|base
argument_list|,
name|plus_constant
argument_list|(
name|base
argument_list|,
operator|-
literal|24
argument_list|)
argument_list|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
break|break;
case|case
name|POST_MODIFY
case|:
if|if
condition|(
name|reversed
operator|||
name|dead
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Extract and adjust the modification.  This case is 	       trickier than the others, because we might have an 	       index register, or we might have a combined offset that 	       doesn't fit a signed 9-bit displacement field.  We can 	       assume the incoming expression is already legitimate.  */
name|offset
operator|=
name|XEXP
argument_list|(
name|base
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|base
operator|=
name|XEXP
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|out
index|[
literal|0
index|]
operator|=
name|adjust_automodify_address
argument_list|(
name|in
argument_list|,
name|DImode
argument_list|,
name|gen_rtx_POST_INC
argument_list|(
name|Pmode
argument_list|,
name|base
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|offset
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
comment|/* Can't adjust the postmodify to match.  Emit the 		   original, then a separate addition insn.  */
name|out
index|[
literal|1
index|]
operator|=
name|adjust_automodify_address
argument_list|(
name|in
argument_list|,
name|DImode
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|fixup
operator|=
name|gen_adddi3
argument_list|(
name|base
argument_list|,
name|base
argument_list|,
name|GEN_INT
argument_list|(
operator|-
literal|8
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|offset
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|abort
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|offset
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
operator|-
literal|256
operator|+
literal|8
condition|)
block|{
comment|/* Again the postmodify cannot be made to match, but 		   in this case it's more efficient to get rid of the 		   postmodify entirely and fix up with an add insn. */
name|out
index|[
literal|1
index|]
operator|=
name|adjust_automodify_address
argument_list|(
name|in
argument_list|,
name|DImode
argument_list|,
name|base
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|fixup
operator|=
name|gen_adddi3
argument_list|(
name|base
argument_list|,
name|base
argument_list|,
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|offset
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|-
literal|8
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Combined offset still fits in the displacement field. 		   (We cannot overflow it at the high end.)  */
name|out
index|[
literal|1
index|]
operator|=
name|adjust_automodify_address
argument_list|(
name|in
argument_list|,
name|DImode
argument_list|,
name|gen_rtx_POST_MODIFY
argument_list|(
name|Pmode
argument_list|,
name|base
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|base
argument_list|,
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|offset
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|-
literal|8
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
block|}
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|fixup
return|;
block|}
end_function

begin_comment
comment|/* Split a TImode or TFmode move instruction after reload.    This is used by *movtf_internal and *movti_internal.  */
end_comment

begin_function
name|void
name|ia64_split_tmode_move
parameter_list|(
name|rtx
name|operands
index|[]
parameter_list|)
block|{
name|rtx
name|in
index|[
literal|2
index|]
decl_stmt|,
name|out
index|[
literal|2
index|]
decl_stmt|,
name|insn
decl_stmt|;
name|rtx
name|fixup
index|[
literal|2
index|]
decl_stmt|;
name|bool
name|dead
init|=
name|false
decl_stmt|;
name|bool
name|reversed
init|=
name|false
decl_stmt|;
comment|/* It is possible for reload to decide to overwrite a pointer with      the value it points to.  In that case we have to do the loads in      the appropriate order so that the pointer is not destroyed too      early.  Also we must not generate a postmodify for that second      load, or rws_access_regno will abort.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|MEM
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|rtx
name|base
init|=
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
decl_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|!=
name|REG
condition|)
name|base
operator|=
name|XEXP
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|REGNO
argument_list|(
name|base
argument_list|)
operator|==
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
name|reversed
operator|=
name|true
expr_stmt|;
name|dead
operator|=
name|true
expr_stmt|;
block|}
comment|/* Another reason to do the moves in reversed order is if the first      element of the target register pair is also the second element of      the source register pair.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|+
literal|1
condition|)
name|reversed
operator|=
name|true
expr_stmt|;
name|fixup
index|[
literal|0
index|]
operator|=
name|ia64_split_tmode
argument_list|(
name|in
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|,
name|reversed
argument_list|,
name|dead
argument_list|)
expr_stmt|;
name|fixup
index|[
literal|1
index|]
operator|=
name|ia64_split_tmode
argument_list|(
name|out
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
name|reversed
argument_list|,
name|dead
argument_list|)
expr_stmt|;
define|#
directive|define
name|MAYBE_ADD_REG_INC_NOTE
parameter_list|(
name|INSN
parameter_list|,
name|EXP
parameter_list|)
define|\
value|if (GET_CODE (EXP) == MEM						\&& (GET_CODE (XEXP (EXP, 0)) == POST_MODIFY			\ 	  || GET_CODE (XEXP (EXP, 0)) == POST_INC			\ 	  || GET_CODE (XEXP (EXP, 0)) == POST_DEC))			\     REG_NOTES (INSN) = gen_rtx_EXPR_LIST (REG_INC,			\ 					  XEXP (XEXP (EXP, 0), 0),	\ 					  REG_NOTES (INSN))
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|out
index|[
literal|0
index|]
argument_list|,
name|in
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|MAYBE_ADD_REG_INC_NOTE
argument_list|(
name|insn
argument_list|,
name|in
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|MAYBE_ADD_REG_INC_NOTE
argument_list|(
name|insn
argument_list|,
name|out
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|out
index|[
literal|1
index|]
argument_list|,
name|in
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|MAYBE_ADD_REG_INC_NOTE
argument_list|(
name|insn
argument_list|,
name|in
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|MAYBE_ADD_REG_INC_NOTE
argument_list|(
name|insn
argument_list|,
name|out
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|fixup
index|[
literal|0
index|]
condition|)
name|emit_insn
argument_list|(
name|fixup
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|fixup
index|[
literal|1
index|]
condition|)
name|emit_insn
argument_list|(
name|fixup
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|MAYBE_ADD_REG_INC_NOTE
block|}
end_function

begin_comment
comment|/* ??? Fixing GR->FR XFmode moves during reload is hard.  You need to go    through memory plus an extra GR scratch register.  Except that you can    either get the first from SECONDARY_MEMORY_NEEDED or the second from    SECONDARY_RELOAD_CLASS, but not both.     We got into problems in the first place by allowing a construct like    (subreg:XF (reg:TI)), which we got from a union containing a long double.    This solution attempts to prevent this situation from occurring.  When    we see something like the above, we spill the inner register to memory.  */
end_comment

begin_function
name|rtx
name|spill_xfmode_operand
parameter_list|(
name|rtx
name|in
parameter_list|,
name|int
name|force
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|in
argument_list|)
argument_list|)
operator|==
name|TImode
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|in
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|rtx
name|mem
init|=
name|gen_mem_addressof
argument_list|(
name|SUBREG_REG
argument_list|(
name|in
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
comment|/*rescan=*/
name|true
argument_list|)
decl_stmt|;
return|return
name|gen_rtx_MEM
argument_list|(
name|XFmode
argument_list|,
name|copy_to_reg
argument_list|(
name|XEXP
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|force
operator|&&
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|REG
condition|)
block|{
name|rtx
name|mem
init|=
name|gen_mem_addressof
argument_list|(
name|in
argument_list|,
name|NULL_TREE
argument_list|,
comment|/*rescan=*/
name|true
argument_list|)
decl_stmt|;
return|return
name|gen_rtx_MEM
argument_list|(
name|XFmode
argument_list|,
name|copy_to_reg
argument_list|(
name|XEXP
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|in
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|in
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ADDRESSOF
condition|)
return|return
name|change_address
argument_list|(
name|in
argument_list|,
name|XFmode
argument_list|,
name|copy_to_reg
argument_list|(
name|XEXP
argument_list|(
name|in
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
else|else
return|return
name|in
return|;
block|}
end_function

begin_comment
comment|/* Emit comparison instruction if necessary, returning the expression    that holds the compare result in the proper mode.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|rtx
name|cmptf_libfunc
expr_stmt|;
end_expr_stmt

begin_function
name|rtx
name|ia64_expand_compare
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|rtx
name|op0
init|=
name|ia64_compare_op0
decl_stmt|,
name|op1
init|=
name|ia64_compare_op1
decl_stmt|;
name|rtx
name|cmp
decl_stmt|;
comment|/* If we have a BImode input, then we already have a compare result, and      do not need to emit another comparison.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
name|BImode
condition|)
block|{
if|if
condition|(
operator|(
name|code
operator|==
name|NE
operator|||
name|code
operator|==
name|EQ
operator|)
operator|&&
name|op1
operator|==
name|const0_rtx
condition|)
name|cmp
operator|=
name|op0
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* HPUX TFmode compare requires a library call to _U_Qfcmp, which takes a      magic number as its third argument, that indicates what to do.      The return value is an integer to be compared against zero.  */
elseif|else
if|if
condition|(
name|TARGET_HPUX
operator|&&
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
name|TFmode
condition|)
block|{
enum|enum
name|qfcmp_magic
block|{
name|QCMP_INV
init|=
literal|1
block|,
comment|/* Raise FP_INVALID on SNaN as a side effect.  */
name|QCMP_UNORD
init|=
literal|2
block|,
name|QCMP_EQ
init|=
literal|4
block|,
name|QCMP_LT
init|=
literal|8
block|,
name|QCMP_GT
init|=
literal|16
block|}
name|magic
enum|;
name|enum
name|rtx_code
name|ncode
decl_stmt|;
name|rtx
name|ret
decl_stmt|,
name|insns
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|TFmode
condition|)
name|abort
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
comment|/* 1 = equal, 0 = not equal.  Equality operators do 	     not raise FP_INVALID when given an SNaN operand.  */
case|case
name|EQ
case|:
name|magic
operator|=
name|QCMP_EQ
expr_stmt|;
name|ncode
operator|=
name|NE
expr_stmt|;
break|break;
case|case
name|NE
case|:
name|magic
operator|=
name|QCMP_EQ
expr_stmt|;
name|ncode
operator|=
name|EQ
expr_stmt|;
break|break;
comment|/* isunordered() from C99.  */
case|case
name|UNORDERED
case|:
name|magic
operator|=
name|QCMP_UNORD
expr_stmt|;
name|ncode
operator|=
name|NE
expr_stmt|;
break|break;
comment|/* Relational operators raise FP_INVALID when given 	     an SNaN operand.  */
case|case
name|LT
case|:
name|magic
operator|=
name|QCMP_LT
operator||
name|QCMP_INV
expr_stmt|;
name|ncode
operator|=
name|NE
expr_stmt|;
break|break;
case|case
name|LE
case|:
name|magic
operator|=
name|QCMP_LT
operator||
name|QCMP_EQ
operator||
name|QCMP_INV
expr_stmt|;
name|ncode
operator|=
name|NE
expr_stmt|;
break|break;
case|case
name|GT
case|:
name|magic
operator|=
name|QCMP_GT
operator||
name|QCMP_INV
expr_stmt|;
name|ncode
operator|=
name|NE
expr_stmt|;
break|break;
case|case
name|GE
case|:
name|magic
operator|=
name|QCMP_GT
operator||
name|QCMP_EQ
operator||
name|QCMP_INV
expr_stmt|;
name|ncode
operator|=
name|NE
expr_stmt|;
break|break;
comment|/* FUTURE: Implement UNEQ, UNLT, UNLE, UNGT, UNGE, LTGT. 	     Expanders for buneq etc. weuld have to be added to ia64.md 	     for this to be useful.  */
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|start_sequence
argument_list|()
expr_stmt|;
name|ret
operator|=
name|emit_library_call_value
argument_list|(
name|cmptf_libfunc
argument_list|,
literal|0
argument_list|,
name|LCT_CONST
argument_list|,
name|DImode
argument_list|,
literal|3
argument_list|,
name|op0
argument_list|,
name|TFmode
argument_list|,
name|op1
argument_list|,
name|TFmode
argument_list|,
name|GEN_INT
argument_list|(
name|magic
argument_list|)
argument_list|,
name|DImode
argument_list|)
expr_stmt|;
name|cmp
operator|=
name|gen_reg_rtx
argument_list|(
name|BImode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|cmp
argument_list|,
name|gen_rtx_fmt_ee
argument_list|(
name|ncode
argument_list|,
name|BImode
argument_list|,
name|ret
argument_list|,
name|const0_rtx
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_libcall_block
argument_list|(
name|insns
argument_list|,
name|cmp
argument_list|,
name|cmp
argument_list|,
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|BImode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|=
name|NE
expr_stmt|;
block|}
else|else
block|{
name|cmp
operator|=
name|gen_reg_rtx
argument_list|(
name|BImode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|cmp
argument_list|,
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|BImode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|=
name|NE
expr_stmt|;
block|}
return|return
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|cmp
argument_list|,
name|const0_rtx
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Emit the appropriate sequence for a call.  */
end_comment

begin_function
name|void
name|ia64_expand_call
parameter_list|(
name|rtx
name|retval
parameter_list|,
name|rtx
name|addr
parameter_list|,
name|rtx
name|nextarg
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|sibcall_p
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|,
name|b0
decl_stmt|;
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addr
operator|=
name|convert_memory_address
argument_list|(
name|DImode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|b0
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|R_BR
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ??? Should do this for functions known to bind local too.  */
if|if
condition|(
name|TARGET_NO_PIC
operator|||
name|TARGET_AUTO_PIC
condition|)
block|{
if|if
condition|(
name|sibcall_p
condition|)
name|insn
operator|=
name|gen_sibcall_nogp
argument_list|(
name|addr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|retval
condition|)
name|insn
operator|=
name|gen_call_nogp
argument_list|(
name|addr
argument_list|,
name|b0
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|gen_call_value_nogp
argument_list|(
name|retval
argument_list|,
name|addr
argument_list|,
name|b0
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_call_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sibcall_p
condition|)
name|insn
operator|=
name|gen_sibcall_gp
argument_list|(
name|addr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|retval
condition|)
name|insn
operator|=
name|gen_call_gp
argument_list|(
name|addr
argument_list|,
name|b0
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|gen_call_value_gp
argument_list|(
name|retval
argument_list|,
name|addr
argument_list|,
name|b0
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_call_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|use_reg
argument_list|(
operator|&
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
argument_list|,
name|pic_offset_table_rtx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sibcall_p
condition|)
name|use_reg
argument_list|(
operator|&
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
argument_list|,
name|b0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ia64_reload_gp
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|tmp
decl_stmt|;
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_gp
condition|)
name|tmp
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|current_frame_info
operator|.
name|reg_save_gp
argument_list|)
expr_stmt|;
else|else
block|{
name|HOST_WIDE_INT
name|offset
decl_stmt|;
name|offset
operator|=
operator|(
name|current_frame_info
operator|.
name|spill_cfa_off
operator|+
name|current_frame_info
operator|.
name|spill_size
operator|)
expr_stmt|;
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
name|tmp
operator|=
name|hard_frame_pointer_rtx
expr_stmt|;
name|offset
operator|=
operator|-
name|offset
expr_stmt|;
block|}
else|else
block|{
name|tmp
operator|=
name|stack_pointer_rtx
expr_stmt|;
name|offset
operator|=
name|current_frame_info
operator|.
name|total_size
operator|-
name|offset
expr_stmt|;
block|}
if|if
condition|(
name|CONST_OK_FOR_I
argument_list|(
name|offset
argument_list|)
condition|)
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|pic_offset_table_rtx
argument_list|,
name|tmp
argument_list|,
name|GEN_INT
argument_list|(
name|offset
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|emit_move_insn
argument_list|(
name|pic_offset_table_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|pic_offset_table_rtx
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|tmp
operator|=
name|gen_rtx_MEM
argument_list|(
name|DImode
argument_list|,
name|pic_offset_table_rtx
argument_list|)
expr_stmt|;
block|}
name|emit_move_insn
argument_list|(
name|pic_offset_table_rtx
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ia64_split_call
parameter_list|(
name|rtx
name|retval
parameter_list|,
name|rtx
name|addr
parameter_list|,
name|rtx
name|retaddr
parameter_list|,
name|rtx
name|scratch_r
parameter_list|,
name|rtx
name|scratch_b
parameter_list|,
name|int
name|noreturn_p
parameter_list|,
name|int
name|sibcall_p
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
name|bool
name|is_desc
init|=
name|false
decl_stmt|;
comment|/* If we find we're calling through a register, then we're actually      calling through a descriptor, so load up the values.  */
if|if
condition|(
name|REG_P
argument_list|(
name|addr
argument_list|)
operator|&&
name|GR_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|addr
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|tmp
decl_stmt|;
name|bool
name|addr_dead_p
decl_stmt|;
comment|/* ??? We are currently constrained to *not* use peep2, because 	 we can legitimately change the global lifetime of the GP 	 (in the form of killing where previously live).  This is 	 because a call through a descriptor doesn't use the previous 	 value of the GP, while a direct call does, and we do not 	 commit to either form until the split here.  	 That said, this means that we lack precise life info for 	 whether ADDR is dead after this call.  This is not terribly 	 important, since we can fix things up essentially for free 	 with the POST_DEC below, but it's nice to not use it when we 	 can immediately tell it's not necessary.  */
name|addr_dead_p
operator|=
operator|(
operator|(
name|noreturn_p
operator|||
name|sibcall_p
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|regs_invalidated_by_call
argument_list|,
name|REGNO
argument_list|(
name|addr
argument_list|)
argument_list|)
operator|)
operator|&&
operator|!
name|FUNCTION_ARG_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|addr
argument_list|)
argument_list|)
operator|)
expr_stmt|;
comment|/* Load the code address into scratch_b.  */
name|tmp
operator|=
name|gen_rtx_POST_INC
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|scratch_r
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|scratch_b
argument_list|,
name|scratch_r
argument_list|)
expr_stmt|;
comment|/* Load the GP address.  If ADDR is not dead here, then we must 	 revert the change made above via the POST_INCREMENT.  */
if|if
condition|(
operator|!
name|addr_dead_p
condition|)
name|tmp
operator|=
name|gen_rtx_POST_DEC
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
else|else
name|tmp
operator|=
name|addr
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|pic_offset_table_rtx
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|is_desc
operator|=
name|true
expr_stmt|;
name|addr
operator|=
name|scratch_b
expr_stmt|;
block|}
if|if
condition|(
name|sibcall_p
condition|)
name|insn
operator|=
name|gen_sibcall_nogp
argument_list|(
name|addr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|retval
condition|)
name|insn
operator|=
name|gen_call_value_nogp
argument_list|(
name|retval
argument_list|,
name|addr
argument_list|,
name|retaddr
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|gen_call_nogp
argument_list|(
name|addr
argument_list|,
name|retaddr
argument_list|)
expr_stmt|;
name|emit_call_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|TARGET_CONST_GP
operator|||
name|is_desc
operator|)
operator|&&
operator|!
name|noreturn_p
operator|&&
operator|!
name|sibcall_p
condition|)
name|ia64_reload_gp
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Begin the assembly file.  */
end_comment

begin_function
specifier|static
name|void
name|ia64_file_start
parameter_list|(
name|void
parameter_list|)
block|{
name|default_file_start
argument_list|()
expr_stmt|;
name|emit_safe_across_calls
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|emit_safe_across_calls
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|int
name|rs
decl_stmt|,
name|re
decl_stmt|;
name|int
name|out_state
decl_stmt|;
name|rs
operator|=
literal|1
expr_stmt|;
name|out_state
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
while|while
condition|(
name|rs
operator|<
literal|64
operator|&&
name|call_used_regs
index|[
name|PR_REG
argument_list|(
name|rs
argument_list|)
index|]
condition|)
name|rs
operator|++
expr_stmt|;
if|if
condition|(
name|rs
operator|>=
literal|64
condition|)
break|break;
for|for
control|(
name|re
operator|=
name|rs
operator|+
literal|1
init|;
name|re
operator|<
literal|64
operator|&&
operator|!
name|call_used_regs
index|[
name|PR_REG
argument_list|(
name|re
argument_list|)
index|]
condition|;
name|re
operator|++
control|)
continue|continue;
if|if
condition|(
name|out_state
operator|==
literal|0
condition|)
block|{
name|fputs
argument_list|(
literal|"\t.pred.safe_across_calls "
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|out_state
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|fputc
argument_list|(
literal|','
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|re
operator|==
name|rs
operator|+
literal|1
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"p%u"
argument_list|,
name|rs
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"p%u-p%u"
argument_list|,
name|rs
argument_list|,
name|re
operator|-
literal|1
argument_list|)
expr_stmt|;
name|rs
operator|=
name|re
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|out_state
condition|)
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Helper function for ia64_compute_frame_size: find an appropriate general    register to spill some special register to.  SPECIAL_SPILL_MASK contains    bits in GR0 to GR31 that have already been allocated by this routine.    TRY_LOCALS is true if we should attempt to locate a local regnum.  */
end_comment

begin_function
specifier|static
name|int
name|find_gr_spill
parameter_list|(
name|int
name|try_locals
parameter_list|)
block|{
name|int
name|regno
decl_stmt|;
comment|/* If this is a leaf function, first try an otherwise unused      call-clobbered register.  */
if|if
condition|(
name|current_function_is_leaf
condition|)
block|{
for|for
control|(
name|regno
operator|=
name|GR_REG
argument_list|(
literal|1
argument_list|)
init|;
name|regno
operator|<=
name|GR_REG
argument_list|(
literal|31
argument_list|)
condition|;
name|regno
operator|++
control|)
if|if
condition|(
operator|!
name|regs_ever_live
index|[
name|regno
index|]
operator|&&
name|call_used_regs
index|[
name|regno
index|]
operator|&&
operator|!
name|fixed_regs
index|[
name|regno
index|]
operator|&&
operator|!
name|global_regs
index|[
name|regno
index|]
operator|&&
operator|(
operator|(
name|current_frame_info
operator|.
name|gr_used_mask
operator|>>
name|regno
operator|)
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
name|current_frame_info
operator|.
name|gr_used_mask
operator||=
literal|1
operator|<<
name|regno
expr_stmt|;
return|return
name|regno
return|;
block|}
block|}
if|if
condition|(
name|try_locals
condition|)
block|{
name|regno
operator|=
name|current_frame_info
operator|.
name|n_local_regs
expr_stmt|;
comment|/* If there is a frame pointer, then we can't use loc79, because 	 that is HARD_FRAME_POINTER_REGNUM.  In particular, see the 	 reg_name switching code in ia64_expand_prologue.  */
if|if
condition|(
name|regno
operator|<
operator|(
literal|80
operator|-
name|frame_pointer_needed
operator|)
condition|)
block|{
name|current_frame_info
operator|.
name|n_local_regs
operator|=
name|regno
operator|+
literal|1
expr_stmt|;
return|return
name|LOC_REG
argument_list|(
literal|0
argument_list|)
operator|+
name|regno
return|;
block|}
block|}
comment|/* Failed to find a general register to spill to.  Must use stack.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* In order to make for nice schedules, we try to allocate every temporary    to a different register.  We must of course stay away from call-saved,    fixed, and global registers.  We must also stay away from registers    allocated in current_frame_info.gr_used_mask, since those include regs    used all through the prologue.     Any register allocated here must be used immediately.  The idea is to    aid scheduling, not to solve data flow problems.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|last_scratch_gr_reg
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|next_scratch_gr_reg
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|regno
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
operator|++
name|i
control|)
block|{
name|regno
operator|=
operator|(
name|last_scratch_gr_reg
operator|+
name|i
operator|+
literal|1
operator|)
operator|&
literal|31
expr_stmt|;
if|if
condition|(
name|call_used_regs
index|[
name|regno
index|]
operator|&&
operator|!
name|fixed_regs
index|[
name|regno
index|]
operator|&&
operator|!
name|global_regs
index|[
name|regno
index|]
operator|&&
operator|(
operator|(
name|current_frame_info
operator|.
name|gr_used_mask
operator|>>
name|regno
operator|)
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
name|last_scratch_gr_reg
operator|=
name|regno
expr_stmt|;
return|return
name|regno
return|;
block|}
block|}
comment|/* There must be _something_ available.  */
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Helper function for ia64_compute_frame_size, called through    diddle_return_value.  Mark REG in current_frame_info.gr_used_mask.  */
end_comment

begin_function
specifier|static
name|void
name|mark_reg_gr_used_mask
parameter_list|(
name|rtx
name|reg
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|unsigned
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|reg
argument_list|)
decl_stmt|;
if|if
condition|(
name|regno
operator|<
literal|32
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|n
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
name|current_frame_info
operator|.
name|gr_used_mask
operator||=
literal|1
operator|<<
operator|(
name|regno
operator|+
name|i
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Returns the number of bytes offset between the frame pointer and the stack    pointer for the current function.  SIZE is the number of bytes of space    needed for local variables.  */
end_comment

begin_function
specifier|static
name|void
name|ia64_compute_frame_size
parameter_list|(
name|HOST_WIDE_INT
name|size
parameter_list|)
block|{
name|HOST_WIDE_INT
name|total_size
decl_stmt|;
name|HOST_WIDE_INT
name|spill_size
init|=
literal|0
decl_stmt|;
name|HOST_WIDE_INT
name|extra_spill_size
init|=
literal|0
decl_stmt|;
name|HOST_WIDE_INT
name|pretend_args_size
decl_stmt|;
name|HARD_REG_SET
name|mask
decl_stmt|;
name|int
name|n_spilled
init|=
literal|0
decl_stmt|;
name|int
name|spilled_gr_p
init|=
literal|0
decl_stmt|;
name|int
name|spilled_fr_p
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|regno
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|current_frame_info
operator|.
name|initialized
condition|)
return|return;
name|memset
argument_list|(
operator|&
name|current_frame_info
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|current_frame_info
argument_list|)
expr_stmt|;
name|CLEAR_HARD_REG_SET
argument_list|(
name|mask
argument_list|)
expr_stmt|;
comment|/* Don't allocate scratches to the return register.  */
name|diddle_return_value
argument_list|(
name|mark_reg_gr_used_mask
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Don't allocate scratches to the EH scratch registers.  */
if|if
condition|(
name|cfun
operator|->
name|machine
operator|->
name|ia64_eh_epilogue_sp
condition|)
name|mark_reg_gr_used_mask
argument_list|(
name|cfun
operator|->
name|machine
operator|->
name|ia64_eh_epilogue_sp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfun
operator|->
name|machine
operator|->
name|ia64_eh_epilogue_bsp
condition|)
name|mark_reg_gr_used_mask
argument_list|(
name|cfun
operator|->
name|machine
operator|->
name|ia64_eh_epilogue_bsp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Find the size of the register stack frame.  We have only 80 local      registers, because we reserve 8 for the inputs and 8 for the      outputs.  */
comment|/* Skip HARD_FRAME_POINTER_REGNUM (loc79) when frame_pointer_needed,      since we'll be adjusting that down later.  */
name|regno
operator|=
name|LOC_REG
argument_list|(
literal|78
argument_list|)
operator|+
operator|!
name|frame_pointer_needed
expr_stmt|;
for|for
control|(
init|;
name|regno
operator|>=
name|LOC_REG
argument_list|(
literal|0
argument_list|)
condition|;
name|regno
operator|--
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|regno
index|]
condition|)
break|break;
name|current_frame_info
operator|.
name|n_local_regs
operator|=
name|regno
operator|-
name|LOC_REG
argument_list|(
literal|0
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* For functions marked with the syscall_linkage attribute, we must mark      all eight input registers as in use, so that locals aren't visible to      the caller.  */
if|if
condition|(
name|cfun
operator|->
name|machine
operator|->
name|n_varargs
operator|>
literal|0
operator|||
name|lookup_attribute
argument_list|(
literal|"syscall_linkage"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
argument_list|)
condition|)
name|current_frame_info
operator|.
name|n_input_regs
operator|=
literal|8
expr_stmt|;
else|else
block|{
for|for
control|(
name|regno
operator|=
name|IN_REG
argument_list|(
literal|7
argument_list|)
init|;
name|regno
operator|>=
name|IN_REG
argument_list|(
literal|0
argument_list|)
condition|;
name|regno
operator|--
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|regno
index|]
condition|)
break|break;
name|current_frame_info
operator|.
name|n_input_regs
operator|=
name|regno
operator|-
name|IN_REG
argument_list|(
literal|0
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
for|for
control|(
name|regno
operator|=
name|OUT_REG
argument_list|(
literal|7
argument_list|)
init|;
name|regno
operator|>=
name|OUT_REG
argument_list|(
literal|0
argument_list|)
condition|;
name|regno
operator|--
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|regno
index|]
condition|)
break|break;
name|i
operator|=
name|regno
operator|-
name|OUT_REG
argument_list|(
literal|0
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* When -p profiling, we need one output register for the mcount argument.      Likewise for -a profiling for the bb_init_func argument.  For -ax      profiling, we need two output registers for the two bb_init_trace_func      arguments.  */
if|if
condition|(
name|current_function_profile
condition|)
name|i
operator|=
name|MAX
argument_list|(
name|i
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|current_frame_info
operator|.
name|n_output_regs
operator|=
name|i
expr_stmt|;
comment|/* ??? No rotating register support yet.  */
name|current_frame_info
operator|.
name|n_rotate_regs
operator|=
literal|0
expr_stmt|;
comment|/* Discover which registers need spilling, and how much room that      will take.  Begin with floating point and general registers,      which will always wind up on the stack.  */
for|for
control|(
name|regno
operator|=
name|FR_REG
argument_list|(
literal|2
argument_list|)
init|;
name|regno
operator|<=
name|FR_REG
argument_list|(
literal|127
argument_list|)
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|regno
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|regno
index|]
condition|)
block|{
name|SET_HARD_REG_BIT
argument_list|(
name|mask
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|spill_size
operator|+=
literal|16
expr_stmt|;
name|n_spilled
operator|+=
literal|1
expr_stmt|;
name|spilled_fr_p
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|regno
operator|=
name|GR_REG
argument_list|(
literal|1
argument_list|)
init|;
name|regno
operator|<=
name|GR_REG
argument_list|(
literal|31
argument_list|)
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|regno
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|regno
index|]
condition|)
block|{
name|SET_HARD_REG_BIT
argument_list|(
name|mask
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|spill_size
operator|+=
literal|8
expr_stmt|;
name|n_spilled
operator|+=
literal|1
expr_stmt|;
name|spilled_gr_p
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|regno
operator|=
name|BR_REG
argument_list|(
literal|1
argument_list|)
init|;
name|regno
operator|<=
name|BR_REG
argument_list|(
literal|7
argument_list|)
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|regno
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|regno
index|]
condition|)
block|{
name|SET_HARD_REG_BIT
argument_list|(
name|mask
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|spill_size
operator|+=
literal|8
expr_stmt|;
name|n_spilled
operator|+=
literal|1
expr_stmt|;
block|}
comment|/* Now come all special registers that might get saved in other      general registers.  */
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
name|current_frame_info
operator|.
name|reg_fp
operator|=
name|find_gr_spill
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* If we did not get a register, then we take LOC79.  This is guaranteed 	 to be free, even if regs_ever_live is already set, because this is 	 HARD_FRAME_POINTER_REGNUM.  This requires incrementing n_local_regs, 	 as we don't count loc79 above.  */
if|if
condition|(
name|current_frame_info
operator|.
name|reg_fp
operator|==
literal|0
condition|)
block|{
name|current_frame_info
operator|.
name|reg_fp
operator|=
name|LOC_REG
argument_list|(
literal|79
argument_list|)
expr_stmt|;
name|current_frame_info
operator|.
name|n_local_regs
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|current_function_is_leaf
condition|)
block|{
comment|/* Emit a save of BR0 if we call other functions.  Do this even 	 if this function doesn't return, as EH depends on this to be 	 able to unwind the stack.  */
name|SET_HARD_REG_BIT
argument_list|(
name|mask
argument_list|,
name|BR_REG
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|current_frame_info
operator|.
name|reg_save_b0
operator|=
name|find_gr_spill
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_b0
operator|==
literal|0
condition|)
block|{
name|spill_size
operator|+=
literal|8
expr_stmt|;
name|n_spilled
operator|+=
literal|1
expr_stmt|;
block|}
comment|/* Similarly for ar.pfs.  */
name|SET_HARD_REG_BIT
argument_list|(
name|mask
argument_list|,
name|AR_PFS_REGNUM
argument_list|)
expr_stmt|;
name|current_frame_info
operator|.
name|reg_save_ar_pfs
operator|=
name|find_gr_spill
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_ar_pfs
operator|==
literal|0
condition|)
block|{
name|extra_spill_size
operator|+=
literal|8
expr_stmt|;
name|n_spilled
operator|+=
literal|1
expr_stmt|;
block|}
comment|/* Similarly for gp.  Note that if we're calling setjmp, the stacked 	 registers are clobbered, so we fall back to the stack.  */
name|current_frame_info
operator|.
name|reg_save_gp
operator|=
operator|(
name|current_function_calls_setjmp
condition|?
literal|0
else|:
name|find_gr_spill
argument_list|(
literal|1
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_gp
operator|==
literal|0
condition|)
block|{
name|SET_HARD_REG_BIT
argument_list|(
name|mask
argument_list|,
name|GR_REG
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|spill_size
operator|+=
literal|8
expr_stmt|;
name|n_spilled
operator|+=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|regs_ever_live
index|[
name|BR_REG
argument_list|(
literal|0
argument_list|)
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|BR_REG
argument_list|(
literal|0
argument_list|)
index|]
condition|)
block|{
name|SET_HARD_REG_BIT
argument_list|(
name|mask
argument_list|,
name|BR_REG
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|spill_size
operator|+=
literal|8
expr_stmt|;
name|n_spilled
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|regs_ever_live
index|[
name|AR_PFS_REGNUM
index|]
condition|)
block|{
name|SET_HARD_REG_BIT
argument_list|(
name|mask
argument_list|,
name|AR_PFS_REGNUM
argument_list|)
expr_stmt|;
name|current_frame_info
operator|.
name|reg_save_ar_pfs
operator|=
name|find_gr_spill
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_ar_pfs
operator|==
literal|0
condition|)
block|{
name|extra_spill_size
operator|+=
literal|8
expr_stmt|;
name|n_spilled
operator|+=
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/* Unwind descriptor hackery: things are most efficient if we allocate      consecutive GR save registers for RP, PFS, FP in that order. However,      it is absolutely critical that FP get the only hard register that's      guaranteed to be free, so we allocated it first.  If all three did      happen to be allocated hard regs, and are consecutive, rearrange them      into the preferred order now.  */
if|if
condition|(
name|current_frame_info
operator|.
name|reg_fp
operator|!=
literal|0
operator|&&
name|current_frame_info
operator|.
name|reg_save_b0
operator|==
name|current_frame_info
operator|.
name|reg_fp
operator|+
literal|1
operator|&&
name|current_frame_info
operator|.
name|reg_save_ar_pfs
operator|==
name|current_frame_info
operator|.
name|reg_fp
operator|+
literal|2
condition|)
block|{
name|current_frame_info
operator|.
name|reg_save_b0
operator|=
name|current_frame_info
operator|.
name|reg_fp
expr_stmt|;
name|current_frame_info
operator|.
name|reg_save_ar_pfs
operator|=
name|current_frame_info
operator|.
name|reg_fp
operator|+
literal|1
expr_stmt|;
name|current_frame_info
operator|.
name|reg_fp
operator|=
name|current_frame_info
operator|.
name|reg_fp
operator|+
literal|2
expr_stmt|;
block|}
comment|/* See if we need to store the predicate register block.  */
for|for
control|(
name|regno
operator|=
name|PR_REG
argument_list|(
literal|0
argument_list|)
init|;
name|regno
operator|<=
name|PR_REG
argument_list|(
literal|63
argument_list|)
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|regno
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|regno
index|]
condition|)
break|break;
if|if
condition|(
name|regno
operator|<=
name|PR_REG
argument_list|(
literal|63
argument_list|)
condition|)
block|{
name|SET_HARD_REG_BIT
argument_list|(
name|mask
argument_list|,
name|PR_REG
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|current_frame_info
operator|.
name|reg_save_pr
operator|=
name|find_gr_spill
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_pr
operator|==
literal|0
condition|)
block|{
name|extra_spill_size
operator|+=
literal|8
expr_stmt|;
name|n_spilled
operator|+=
literal|1
expr_stmt|;
block|}
comment|/* ??? Mark them all as used so that register renaming and such 	 are free to use them.  */
for|for
control|(
name|regno
operator|=
name|PR_REG
argument_list|(
literal|0
argument_list|)
init|;
name|regno
operator|<=
name|PR_REG
argument_list|(
literal|63
argument_list|)
condition|;
name|regno
operator|++
control|)
name|regs_ever_live
index|[
name|regno
index|]
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If we're forced to use st8.spill, we're forced to save and restore      ar.unat as well.  The check for existing liveness allows inline asm      to touch ar.unat.  */
if|if
condition|(
name|spilled_gr_p
operator|||
name|cfun
operator|->
name|machine
operator|->
name|n_varargs
operator|||
name|regs_ever_live
index|[
name|AR_UNAT_REGNUM
index|]
condition|)
block|{
name|regs_ever_live
index|[
name|AR_UNAT_REGNUM
index|]
operator|=
literal|1
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|mask
argument_list|,
name|AR_UNAT_REGNUM
argument_list|)
expr_stmt|;
name|current_frame_info
operator|.
name|reg_save_ar_unat
operator|=
name|find_gr_spill
argument_list|(
name|spill_size
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_ar_unat
operator|==
literal|0
condition|)
block|{
name|extra_spill_size
operator|+=
literal|8
expr_stmt|;
name|n_spilled
operator|+=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|regs_ever_live
index|[
name|AR_LC_REGNUM
index|]
condition|)
block|{
name|SET_HARD_REG_BIT
argument_list|(
name|mask
argument_list|,
name|AR_LC_REGNUM
argument_list|)
expr_stmt|;
name|current_frame_info
operator|.
name|reg_save_ar_lc
operator|=
name|find_gr_spill
argument_list|(
name|spill_size
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_ar_lc
operator|==
literal|0
condition|)
block|{
name|extra_spill_size
operator|+=
literal|8
expr_stmt|;
name|n_spilled
operator|+=
literal|1
expr_stmt|;
block|}
block|}
comment|/* If we have an odd number of words of pretend arguments written to      the stack, then the FR save area will be unaligned.  We round the      size of this area up to keep things 16 byte aligned.  */
if|if
condition|(
name|spilled_fr_p
condition|)
name|pretend_args_size
operator|=
name|IA64_STACK_ALIGN
argument_list|(
name|current_function_pretend_args_size
argument_list|)
expr_stmt|;
else|else
name|pretend_args_size
operator|=
name|current_function_pretend_args_size
expr_stmt|;
name|total_size
operator|=
operator|(
name|spill_size
operator|+
name|extra_spill_size
operator|+
name|size
operator|+
name|pretend_args_size
operator|+
name|current_function_outgoing_args_size
operator|)
expr_stmt|;
name|total_size
operator|=
name|IA64_STACK_ALIGN
argument_list|(
name|total_size
argument_list|)
expr_stmt|;
comment|/* We always use the 16-byte scratch area provided by the caller, but      if we are a leaf function, there's no one to which we need to provide      a scratch area.  */
if|if
condition|(
name|current_function_is_leaf
condition|)
name|total_size
operator|=
name|MAX
argument_list|(
literal|0
argument_list|,
name|total_size
operator|-
literal|16
argument_list|)
expr_stmt|;
name|current_frame_info
operator|.
name|total_size
operator|=
name|total_size
expr_stmt|;
name|current_frame_info
operator|.
name|spill_cfa_off
operator|=
name|pretend_args_size
operator|-
literal|16
expr_stmt|;
name|current_frame_info
operator|.
name|spill_size
operator|=
name|spill_size
expr_stmt|;
name|current_frame_info
operator|.
name|extra_spill_size
operator|=
name|extra_spill_size
expr_stmt|;
name|COPY_HARD_REG_SET
argument_list|(
name|current_frame_info
operator|.
name|mask
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|current_frame_info
operator|.
name|n_spilled
operator|=
name|n_spilled
expr_stmt|;
name|current_frame_info
operator|.
name|initialized
operator|=
name|reload_completed
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute the initial difference between the specified pair of registers.  */
end_comment

begin_function
name|HOST_WIDE_INT
name|ia64_initial_elimination_offset
parameter_list|(
name|int
name|from
parameter_list|,
name|int
name|to
parameter_list|)
block|{
name|HOST_WIDE_INT
name|offset
decl_stmt|;
name|ia64_compute_frame_size
argument_list|(
name|get_frame_size
argument_list|()
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|from
condition|)
block|{
case|case
name|FRAME_POINTER_REGNUM
case|:
if|if
condition|(
name|to
operator|==
name|HARD_FRAME_POINTER_REGNUM
condition|)
block|{
if|if
condition|(
name|current_function_is_leaf
condition|)
name|offset
operator|=
operator|-
name|current_frame_info
operator|.
name|total_size
expr_stmt|;
else|else
name|offset
operator|=
operator|-
operator|(
name|current_frame_info
operator|.
name|total_size
operator|-
name|current_function_outgoing_args_size
operator|-
literal|16
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|to
operator|==
name|STACK_POINTER_REGNUM
condition|)
block|{
if|if
condition|(
name|current_function_is_leaf
condition|)
name|offset
operator|=
literal|0
expr_stmt|;
else|else
name|offset
operator|=
literal|16
operator|+
name|current_function_outgoing_args_size
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
break|break;
case|case
name|ARG_POINTER_REGNUM
case|:
comment|/* Arguments start above the 16 byte save area, unless stdarg 	 in which case we store through the 16 byte save area.  */
if|if
condition|(
name|to
operator|==
name|HARD_FRAME_POINTER_REGNUM
condition|)
name|offset
operator|=
literal|16
operator|-
name|current_function_pretend_args_size
expr_stmt|;
elseif|else
if|if
condition|(
name|to
operator|==
name|STACK_POINTER_REGNUM
condition|)
name|offset
operator|=
operator|(
name|current_frame_info
operator|.
name|total_size
operator|+
literal|16
operator|-
name|current_function_pretend_args_size
operator|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|offset
return|;
block|}
end_function

begin_comment
comment|/* If there are more than a trivial number of register spills, we use    two interleaved iterators so that we can get two memory references    per insn group.     In order to simplify things in the prologue and epilogue expanders,    we use helper functions to fix up the memory references after the    fact with the appropriate offsets to a POST_MODIFY memory mode.    The following data structure tracks the state of the two iterators    while insns are being emitted.  */
end_comment

begin_struct
struct|struct
name|spill_fill_data
block|{
name|rtx
name|init_after
decl_stmt|;
comment|/* point at which to emit initializations */
name|rtx
name|init_reg
index|[
literal|2
index|]
decl_stmt|;
comment|/* initial base register */
name|rtx
name|iter_reg
index|[
literal|2
index|]
decl_stmt|;
comment|/* the iterator registers */
name|rtx
modifier|*
name|prev_addr
index|[
literal|2
index|]
decl_stmt|;
comment|/* address of last memory use */
name|rtx
name|prev_insn
index|[
literal|2
index|]
decl_stmt|;
comment|/* the insn corresponding to prev_addr */
name|HOST_WIDE_INT
name|prev_off
index|[
literal|2
index|]
decl_stmt|;
comment|/* last offset */
name|int
name|n_iter
decl_stmt|;
comment|/* number of iterators in use */
name|int
name|next_iter
decl_stmt|;
comment|/* next iterator to use */
name|unsigned
name|int
name|save_gr_used_mask
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|spill_fill_data
name|spill_fill_data
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|setup_spill_pointers
parameter_list|(
name|int
name|n_spills
parameter_list|,
name|rtx
name|init_reg
parameter_list|,
name|HOST_WIDE_INT
name|cfa_off
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|spill_fill_data
operator|.
name|init_after
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|spill_fill_data
operator|.
name|init_reg
index|[
literal|0
index|]
operator|=
name|init_reg
expr_stmt|;
name|spill_fill_data
operator|.
name|init_reg
index|[
literal|1
index|]
operator|=
name|init_reg
expr_stmt|;
name|spill_fill_data
operator|.
name|prev_addr
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
name|spill_fill_data
operator|.
name|prev_addr
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|spill_fill_data
operator|.
name|prev_insn
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
name|spill_fill_data
operator|.
name|prev_insn
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|spill_fill_data
operator|.
name|prev_off
index|[
literal|0
index|]
operator|=
name|cfa_off
expr_stmt|;
name|spill_fill_data
operator|.
name|prev_off
index|[
literal|1
index|]
operator|=
name|cfa_off
expr_stmt|;
name|spill_fill_data
operator|.
name|next_iter
operator|=
literal|0
expr_stmt|;
name|spill_fill_data
operator|.
name|save_gr_used_mask
operator|=
name|current_frame_info
operator|.
name|gr_used_mask
expr_stmt|;
name|spill_fill_data
operator|.
name|n_iter
operator|=
literal|1
operator|+
operator|(
name|n_spills
operator|>
literal|2
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|spill_fill_data
operator|.
name|n_iter
condition|;
operator|++
name|i
control|)
block|{
name|int
name|regno
init|=
name|next_scratch_gr_reg
argument_list|()
decl_stmt|;
name|spill_fill_data
operator|.
name|iter_reg
index|[
name|i
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|current_frame_info
operator|.
name|gr_used_mask
operator||=
literal|1
operator|<<
name|regno
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|finish_spill_pointers
parameter_list|(
name|void
parameter_list|)
block|{
name|current_frame_info
operator|.
name|gr_used_mask
operator|=
name|spill_fill_data
operator|.
name|save_gr_used_mask
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|spill_restore_mem
parameter_list|(
name|rtx
name|reg
parameter_list|,
name|HOST_WIDE_INT
name|cfa_off
parameter_list|)
block|{
name|int
name|iter
init|=
name|spill_fill_data
operator|.
name|next_iter
decl_stmt|;
name|HOST_WIDE_INT
name|disp
init|=
name|spill_fill_data
operator|.
name|prev_off
index|[
name|iter
index|]
operator|-
name|cfa_off
decl_stmt|;
name|rtx
name|disp_rtx
init|=
name|GEN_INT
argument_list|(
name|disp
argument_list|)
decl_stmt|;
name|rtx
name|mem
decl_stmt|;
if|if
condition|(
name|spill_fill_data
operator|.
name|prev_addr
index|[
name|iter
index|]
condition|)
block|{
if|if
condition|(
name|CONST_OK_FOR_N
argument_list|(
name|disp
argument_list|)
condition|)
block|{
operator|*
name|spill_fill_data
operator|.
name|prev_addr
index|[
name|iter
index|]
operator|=
name|gen_rtx_POST_MODIFY
argument_list|(
name|DImode
argument_list|,
name|spill_fill_data
operator|.
name|iter_reg
index|[
name|iter
index|]
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|DImode
argument_list|,
name|spill_fill_data
operator|.
name|iter_reg
index|[
name|iter
index|]
argument_list|,
name|disp_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|spill_fill_data
operator|.
name|prev_insn
index|[
name|iter
index|]
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_INC
argument_list|,
name|spill_fill_data
operator|.
name|iter_reg
index|[
name|iter
index|]
argument_list|,
name|REG_NOTES
argument_list|(
name|spill_fill_data
operator|.
name|prev_insn
index|[
name|iter
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* ??? Could use register post_modify for loads.  */
if|if
condition|(
operator|!
name|CONST_OK_FOR_I
argument_list|(
name|disp
argument_list|)
condition|)
block|{
name|rtx
name|tmp
init|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|next_scratch_gr_reg
argument_list|()
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|tmp
argument_list|,
name|disp_rtx
argument_list|)
expr_stmt|;
name|disp_rtx
operator|=
name|tmp
expr_stmt|;
block|}
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|spill_fill_data
operator|.
name|iter_reg
index|[
name|iter
index|]
argument_list|,
name|spill_fill_data
operator|.
name|iter_reg
index|[
name|iter
index|]
argument_list|,
name|disp_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Micro-optimization: if we've created a frame pointer, it's at      CFA 0, which may allow the real iterator to be initialized lower,      slightly increasing parallelism.  Also, if there are few saves      it may eliminate the iterator entirely.  */
elseif|else
if|if
condition|(
name|disp
operator|==
literal|0
operator|&&
name|spill_fill_data
operator|.
name|init_reg
index|[
name|iter
index|]
operator|==
name|stack_pointer_rtx
operator|&&
name|frame_pointer_needed
condition|)
block|{
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|hard_frame_pointer_rtx
argument_list|)
expr_stmt|;
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|get_varargs_alias_set
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|mem
return|;
block|}
else|else
block|{
name|rtx
name|seq
decl_stmt|,
name|insn
decl_stmt|;
if|if
condition|(
name|disp
operator|==
literal|0
condition|)
name|seq
operator|=
name|gen_movdi
argument_list|(
name|spill_fill_data
operator|.
name|iter_reg
index|[
name|iter
index|]
argument_list|,
name|spill_fill_data
operator|.
name|init_reg
index|[
name|iter
index|]
argument_list|)
expr_stmt|;
else|else
block|{
name|start_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|CONST_OK_FOR_I
argument_list|(
name|disp
argument_list|)
condition|)
block|{
name|rtx
name|tmp
init|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|next_scratch_gr_reg
argument_list|()
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|tmp
argument_list|,
name|disp_rtx
argument_list|)
expr_stmt|;
name|disp_rtx
operator|=
name|tmp
expr_stmt|;
block|}
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|spill_fill_data
operator|.
name|iter_reg
index|[
name|iter
index|]
argument_list|,
name|spill_fill_data
operator|.
name|init_reg
index|[
name|iter
index|]
argument_list|,
name|disp_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
block|}
comment|/* Careful for being the first insn in a sequence.  */
if|if
condition|(
name|spill_fill_data
operator|.
name|init_after
condition|)
name|insn
operator|=
name|emit_insn_after
argument_list|(
name|seq
argument_list|,
name|spill_fill_data
operator|.
name|init_after
argument_list|)
expr_stmt|;
else|else
block|{
name|rtx
name|first
init|=
name|get_insns
argument_list|()
decl_stmt|;
if|if
condition|(
name|first
condition|)
name|insn
operator|=
name|emit_insn_before
argument_list|(
name|seq
argument_list|,
name|first
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|emit_insn
argument_list|(
name|seq
argument_list|)
expr_stmt|;
block|}
name|spill_fill_data
operator|.
name|init_after
operator|=
name|insn
expr_stmt|;
comment|/* If DISP is 0, we may or may not have a further adjustment 	 afterward.  If we do, then the load/store insn may be modified 	 to be a post-modify.  If we don't, then this copy may be 	 eliminated by copyprop_hardreg_forward, which makes this 	 insn garbage, which runs afoul of the sanity check in 	 propagate_one_insn.  So mark this insn as legal to delete.  */
if|if
condition|(
name|disp
operator|==
literal|0
condition|)
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_MAYBE_DEAD
argument_list|,
name|const0_rtx
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|spill_fill_data
operator|.
name|iter_reg
index|[
name|iter
index|]
argument_list|)
expr_stmt|;
comment|/* ??? Not all of the spills are for varargs, but some of them are.      The rest of the spills belong in an alias set of their own.  But      it doesn't actually hurt to include them here.  */
name|set_mem_alias_set
argument_list|(
name|mem
argument_list|,
name|get_varargs_alias_set
argument_list|()
argument_list|)
expr_stmt|;
name|spill_fill_data
operator|.
name|prev_addr
index|[
name|iter
index|]
operator|=
operator|&
name|XEXP
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|spill_fill_data
operator|.
name|prev_off
index|[
name|iter
index|]
operator|=
name|cfa_off
expr_stmt|;
if|if
condition|(
operator|++
name|iter
operator|>=
name|spill_fill_data
operator|.
name|n_iter
condition|)
name|iter
operator|=
literal|0
expr_stmt|;
name|spill_fill_data
operator|.
name|next_iter
operator|=
name|iter
expr_stmt|;
return|return
name|mem
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_spill
parameter_list|(
name|rtx
function_decl|(
modifier|*
name|move_fn
function_decl|)
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
parameter_list|,
name|rtx
name|reg
parameter_list|,
name|HOST_WIDE_INT
name|cfa_off
parameter_list|,
name|rtx
name|frame_reg
parameter_list|)
block|{
name|int
name|iter
init|=
name|spill_fill_data
operator|.
name|next_iter
decl_stmt|;
name|rtx
name|mem
decl_stmt|,
name|insn
decl_stmt|;
name|mem
operator|=
name|spill_restore_mem
argument_list|(
name|reg
argument_list|,
name|cfa_off
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
call|(
modifier|*
name|move_fn
call|)
argument_list|(
name|mem
argument_list|,
name|reg
argument_list|,
name|GEN_INT
argument_list|(
name|cfa_off
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|spill_fill_data
operator|.
name|prev_insn
index|[
name|iter
index|]
operator|=
name|insn
expr_stmt|;
if|if
condition|(
name|frame_reg
condition|)
block|{
name|rtx
name|base
decl_stmt|;
name|HOST_WIDE_INT
name|off
decl_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Don't even pretend that the unwind code can intuit its way 	 through a pair of interleaved post_modify iterators.  Just 	 provide the correct answer.  */
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
name|base
operator|=
name|hard_frame_pointer_rtx
expr_stmt|;
name|off
operator|=
operator|-
name|cfa_off
expr_stmt|;
block|}
else|else
block|{
name|base
operator|=
name|stack_pointer_rtx
expr_stmt|;
name|off
operator|=
name|current_frame_info
operator|.
name|total_size
operator|-
name|cfa_off
expr_stmt|;
block|}
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_FRAME_RELATED_EXPR
argument_list|,
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|plus_constant
argument_list|(
name|base
argument_list|,
name|off
argument_list|)
argument_list|)
argument_list|,
name|frame_reg
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|do_restore
parameter_list|(
name|rtx
function_decl|(
modifier|*
name|move_fn
function_decl|)
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
parameter_list|,
name|rtx
name|reg
parameter_list|,
name|HOST_WIDE_INT
name|cfa_off
parameter_list|)
block|{
name|int
name|iter
init|=
name|spill_fill_data
operator|.
name|next_iter
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
call|(
modifier|*
name|move_fn
call|)
argument_list|(
name|reg
argument_list|,
name|spill_restore_mem
argument_list|(
name|reg
argument_list|,
name|cfa_off
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|cfa_off
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|spill_fill_data
operator|.
name|prev_insn
index|[
name|iter
index|]
operator|=
name|insn
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Wrapper functions that discards the CONST_INT spill offset.  These    exist so that we can give gr_spill/gr_fill the offset they need and    use a consistent function interface.  */
end_comment

begin_function
specifier|static
name|rtx
name|gen_movdi_x
parameter_list|(
name|rtx
name|dest
parameter_list|,
name|rtx
name|src
parameter_list|,
name|rtx
name|offset
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|gen_movdi
argument_list|(
name|dest
argument_list|,
name|src
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|gen_fr_spill_x
parameter_list|(
name|rtx
name|dest
parameter_list|,
name|rtx
name|src
parameter_list|,
name|rtx
name|offset
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|gen_fr_spill
argument_list|(
name|dest
argument_list|,
name|src
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|gen_fr_restore_x
parameter_list|(
name|rtx
name|dest
parameter_list|,
name|rtx
name|src
parameter_list|,
name|rtx
name|offset
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|gen_fr_restore
argument_list|(
name|dest
argument_list|,
name|src
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Called after register allocation to add any instructions needed for the    prologue.  Using a prologue insn is favored compared to putting all of the    instructions in output_function_prologue(), since it allows the scheduler    to intermix instructions with the saves of the caller saved registers.  In    some cases, it might be necessary to emit a barrier instruction as the last    insn to prevent such scheduling.     Also any insns generated here should have RTX_FRAME_RELATED_P(insn) = 1    so that the debug info generation code can handle them properly.     The register save area is layed out like so:    cfa+16 	[ varargs spill area ] 	[ fr register spill area ] 	[ br register spill area ] 	[ ar register spill area ] 	[ pr register spill area ] 	[ gr register spill area ] */
end_comment

begin_comment
comment|/* ??? Get inefficient code when the frame size is larger than can fit in an    adds instruction.  */
end_comment

begin_function
name|void
name|ia64_expand_prologue
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|,
name|ar_pfs_save_reg
decl_stmt|,
name|ar_unat_save_reg
decl_stmt|;
name|int
name|i
decl_stmt|,
name|epilogue_p
decl_stmt|,
name|regno
decl_stmt|,
name|alt_regno
decl_stmt|,
name|cfa_off
decl_stmt|,
name|n_varargs
decl_stmt|;
name|rtx
name|reg
decl_stmt|,
name|alt_reg
decl_stmt|;
name|ia64_compute_frame_size
argument_list|(
name|get_frame_size
argument_list|()
argument_list|)
expr_stmt|;
name|last_scratch_gr_reg
operator|=
literal|15
expr_stmt|;
comment|/* If there is no epilogue, then we don't need some prologue insns.      We need to avoid emitting the dead prologue insns, because flow      will complain about them.  */
if|if
condition|(
name|optimize
condition|)
block|{
name|edge
name|e
decl_stmt|;
for|for
control|(
name|e
operator|=
name|EXIT_BLOCK_PTR
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
if|if
condition|(
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FAKE
operator|)
operator|==
literal|0
operator|&&
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
operator|)
operator|!=
literal|0
condition|)
break|break;
name|epilogue_p
operator|=
operator|(
name|e
operator|!=
name|NULL
operator|)
expr_stmt|;
block|}
else|else
name|epilogue_p
operator|=
literal|1
expr_stmt|;
comment|/* Set the local, input, and output register names.  We need to do this      for GNU libc, which creates crti.S/crtn.S by splitting initfini.c in      half.  If we use in/loc/out register names, then we get assembler errors      in crtn.S because there is no alloc insn or regstk directive in there.  */
if|if
condition|(
operator|!
name|TARGET_REG_NAMES
condition|)
block|{
name|int
name|inputs
init|=
name|current_frame_info
operator|.
name|n_input_regs
decl_stmt|;
name|int
name|locals
init|=
name|current_frame_info
operator|.
name|n_local_regs
decl_stmt|;
name|int
name|outputs
init|=
name|current_frame_info
operator|.
name|n_output_regs
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|inputs
condition|;
name|i
operator|++
control|)
name|reg_names
index|[
name|IN_REG
argument_list|(
name|i
argument_list|)
index|]
operator|=
name|ia64_reg_numbers
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|locals
condition|;
name|i
operator|++
control|)
name|reg_names
index|[
name|LOC_REG
argument_list|(
name|i
argument_list|)
index|]
operator|=
name|ia64_reg_numbers
index|[
name|inputs
operator|+
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|outputs
condition|;
name|i
operator|++
control|)
name|reg_names
index|[
name|OUT_REG
argument_list|(
name|i
argument_list|)
index|]
operator|=
name|ia64_reg_numbers
index|[
name|inputs
operator|+
name|locals
operator|+
name|i
index|]
expr_stmt|;
block|}
comment|/* Set the frame pointer register name.  The regnum is logically loc79,      but of course we'll not have allocated that many locals.  Rather than      worrying about renumbering the existing rtxs, we adjust the name.  */
comment|/* ??? This code means that we can never use one local register when      there is a frame pointer.  loc79 gets wasted in this case, as it is      renamed to a register that will never be used.  See also the try_locals      code in find_gr_spill.  */
if|if
condition|(
name|current_frame_info
operator|.
name|reg_fp
condition|)
block|{
specifier|const
name|char
modifier|*
name|tmp
init|=
name|reg_names
index|[
name|HARD_FRAME_POINTER_REGNUM
index|]
decl_stmt|;
name|reg_names
index|[
name|HARD_FRAME_POINTER_REGNUM
index|]
operator|=
name|reg_names
index|[
name|current_frame_info
operator|.
name|reg_fp
index|]
expr_stmt|;
name|reg_names
index|[
name|current_frame_info
operator|.
name|reg_fp
index|]
operator|=
name|tmp
expr_stmt|;
block|}
comment|/* We don't need an alloc instruction if we've used no outputs or locals.  */
if|if
condition|(
name|current_frame_info
operator|.
name|n_local_regs
operator|==
literal|0
operator|&&
name|current_frame_info
operator|.
name|n_output_regs
operator|==
literal|0
operator|&&
name|current_frame_info
operator|.
name|n_input_regs
operator|<=
name|current_function_args_info
operator|.
name|int_regs
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|current_frame_info
operator|.
name|mask
argument_list|,
name|AR_PFS_REGNUM
argument_list|)
condition|)
block|{
comment|/* If there is no alloc, but there are input registers used, then we 	 need a .regstk directive.  */
name|current_frame_info
operator|.
name|need_regstk
operator|=
operator|(
name|TARGET_REG_NAMES
operator|!=
literal|0
operator|)
expr_stmt|;
name|ar_pfs_save_reg
operator|=
name|NULL_RTX
expr_stmt|;
block|}
else|else
block|{
name|current_frame_info
operator|.
name|need_regstk
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_ar_pfs
condition|)
name|regno
operator|=
name|current_frame_info
operator|.
name|reg_save_ar_pfs
expr_stmt|;
else|else
name|regno
operator|=
name|next_scratch_gr_reg
argument_list|()
expr_stmt|;
name|ar_pfs_save_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_alloc
argument_list|(
name|ar_pfs_save_reg
argument_list|,
name|GEN_INT
argument_list|(
name|current_frame_info
operator|.
name|n_input_regs
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|current_frame_info
operator|.
name|n_local_regs
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|current_frame_info
operator|.
name|n_output_regs
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|current_frame_info
operator|.
name|n_rotate_regs
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
operator|(
name|current_frame_info
operator|.
name|reg_save_ar_pfs
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
comment|/* Set up frame pointer, stack pointer, and spill iterators.  */
name|n_varargs
operator|=
name|cfun
operator|->
name|machine
operator|->
name|n_varargs
expr_stmt|;
name|setup_spill_pointers
argument_list|(
name|current_frame_info
operator|.
name|n_spilled
operator|+
name|n_varargs
argument_list|,
name|stack_pointer_rtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|current_frame_info
operator|.
name|total_size
operator|!=
literal|0
condition|)
block|{
name|rtx
name|frame_size_rtx
init|=
name|GEN_INT
argument_list|(
operator|-
name|current_frame_info
operator|.
name|total_size
argument_list|)
decl_stmt|;
name|rtx
name|offset
decl_stmt|;
if|if
condition|(
name|CONST_OK_FOR_I
argument_list|(
operator|-
name|current_frame_info
operator|.
name|total_size
argument_list|)
condition|)
name|offset
operator|=
name|frame_size_rtx
expr_stmt|;
else|else
block|{
name|regno
operator|=
name|next_scratch_gr_reg
argument_list|()
expr_stmt|;
name|offset
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|offset
argument_list|,
name|frame_size_rtx
argument_list|)
expr_stmt|;
block|}
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|frame_pointer_needed
condition|)
block|{
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|offset
argument_list|)
operator|!=
name|CONST_INT
condition|)
block|{
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_FRAME_RELATED_EXPR
argument_list|,
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|DImode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|frame_size_rtx
argument_list|)
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* ??? At this point we must generate a magic insn that appears to 	 modify the stack pointer, the frame pointer, and all spill 	 iterators.  This would allow the most scheduling freedom.  For 	 now, just hard stop.  */
name|emit_insn
argument_list|(
name|gen_blockage
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/* Must copy out ar.unat before doing any integer spills.  */
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|current_frame_info
operator|.
name|mask
argument_list|,
name|AR_UNAT_REGNUM
argument_list|)
condition|)
block|{
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_ar_unat
condition|)
name|ar_unat_save_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|current_frame_info
operator|.
name|reg_save_ar_unat
argument_list|)
expr_stmt|;
else|else
block|{
name|alt_regno
operator|=
name|next_scratch_gr_reg
argument_list|()
expr_stmt|;
name|ar_unat_save_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|alt_regno
argument_list|)
expr_stmt|;
name|current_frame_info
operator|.
name|gr_used_mask
operator||=
literal|1
operator|<<
name|alt_regno
expr_stmt|;
block|}
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|AR_UNAT_REGNUM
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|ar_unat_save_reg
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
operator|(
name|current_frame_info
operator|.
name|reg_save_ar_unat
operator|!=
literal|0
operator|)
expr_stmt|;
comment|/* Even if we're not going to generate an epilogue, we still 	 need to save the register so that EH works.  */
if|if
condition|(
operator|!
name|epilogue_p
operator|&&
name|current_frame_info
operator|.
name|reg_save_ar_unat
condition|)
name|emit_insn
argument_list|(
name|gen_prologue_use
argument_list|(
name|ar_unat_save_reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|ar_unat_save_reg
operator|=
name|NULL_RTX
expr_stmt|;
comment|/* Spill all varargs registers.  Do this before spilling any GR registers,      since we want the UNAT bits for the GR registers to override the UNAT      bits from varargs, which we don't care about.  */
name|cfa_off
operator|=
operator|-
literal|16
expr_stmt|;
for|for
control|(
name|regno
operator|=
name|GR_ARG_FIRST
operator|+
literal|7
init|;
name|n_varargs
operator|>
literal|0
condition|;
operator|--
name|n_varargs
operator|,
operator|--
name|regno
control|)
block|{
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|do_spill
argument_list|(
name|gen_gr_spill
argument_list|,
name|reg
argument_list|,
name|cfa_off
operator|+=
literal|8
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
comment|/* Locate the bottom of the register save area.  */
name|cfa_off
operator|=
operator|(
name|current_frame_info
operator|.
name|spill_cfa_off
operator|+
name|current_frame_info
operator|.
name|spill_size
operator|+
name|current_frame_info
operator|.
name|extra_spill_size
operator|)
expr_stmt|;
comment|/* Save the predicate register block either in a register or in memory.  */
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|current_frame_info
operator|.
name|mask
argument_list|,
name|PR_REG
argument_list|(
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|PR_REG
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_pr
operator|!=
literal|0
condition|)
block|{
name|alt_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|current_frame_info
operator|.
name|reg_save_pr
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|alt_reg
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* ??? Denote pr spill/fill by a DImode move that modifies all 	     64 hard registers.  */
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_FRAME_RELATED_EXPR
argument_list|,
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|alt_reg
argument_list|,
name|reg
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Even if we're not going to generate an epilogue, we still 	     need to save the register so that EH works.  */
if|if
condition|(
operator|!
name|epilogue_p
condition|)
name|emit_insn
argument_list|(
name|gen_prologue_use
argument_list|(
name|alt_reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|alt_regno
operator|=
name|next_scratch_gr_reg
argument_list|()
expr_stmt|;
name|alt_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|alt_regno
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|alt_reg
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|do_spill
argument_list|(
name|gen_movdi_x
argument_list|,
name|alt_reg
argument_list|,
name|cfa_off
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|cfa_off
operator|-=
literal|8
expr_stmt|;
block|}
block|}
comment|/* Handle AR regs in numerical order.  All of them get special handling.  */
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|current_frame_info
operator|.
name|mask
argument_list|,
name|AR_UNAT_REGNUM
argument_list|)
operator|&&
name|current_frame_info
operator|.
name|reg_save_ar_unat
operator|==
literal|0
condition|)
block|{
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|AR_UNAT_REGNUM
argument_list|)
expr_stmt|;
name|do_spill
argument_list|(
name|gen_movdi_x
argument_list|,
name|ar_unat_save_reg
argument_list|,
name|cfa_off
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|cfa_off
operator|-=
literal|8
expr_stmt|;
block|}
comment|/* The alloc insn already copied ar.pfs into a general register.  The      only thing we have to do now is copy that register to a stack slot      if we'd not allocated a local register for the job.  */
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|current_frame_info
operator|.
name|mask
argument_list|,
name|AR_PFS_REGNUM
argument_list|)
operator|&&
name|current_frame_info
operator|.
name|reg_save_ar_pfs
operator|==
literal|0
condition|)
block|{
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|AR_PFS_REGNUM
argument_list|)
expr_stmt|;
name|do_spill
argument_list|(
name|gen_movdi_x
argument_list|,
name|ar_pfs_save_reg
argument_list|,
name|cfa_off
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|cfa_off
operator|-=
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|current_frame_info
operator|.
name|mask
argument_list|,
name|AR_LC_REGNUM
argument_list|)
condition|)
block|{
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|AR_LC_REGNUM
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_ar_lc
operator|!=
literal|0
condition|)
block|{
name|alt_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|current_frame_info
operator|.
name|reg_save_ar_lc
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|alt_reg
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Even if we're not going to generate an epilogue, we still 	     need to save the register so that EH works.  */
if|if
condition|(
operator|!
name|epilogue_p
condition|)
name|emit_insn
argument_list|(
name|gen_prologue_use
argument_list|(
name|alt_reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|alt_regno
operator|=
name|next_scratch_gr_reg
argument_list|()
expr_stmt|;
name|alt_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|alt_regno
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|alt_reg
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|do_spill
argument_list|(
name|gen_movdi_x
argument_list|,
name|alt_reg
argument_list|,
name|cfa_off
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|cfa_off
operator|-=
literal|8
expr_stmt|;
block|}
block|}
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_gp
condition|)
block|{
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|current_frame_info
operator|.
name|reg_save_gp
argument_list|)
argument_list|,
name|pic_offset_table_rtx
argument_list|)
expr_stmt|;
comment|/* We don't know for sure yet if this is actually needed, since 	 we've not split the PIC call patterns.  If all of the calls 	 are indirect, and not followed by any uses of the gp, then 	 this save is dead.  Allow it to go away.  */
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_MAYBE_DEAD
argument_list|,
name|const0_rtx
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* We should now be at the base of the gr/br/fr spill area.  */
if|if
condition|(
name|cfa_off
operator|!=
operator|(
name|current_frame_info
operator|.
name|spill_cfa_off
operator|+
name|current_frame_info
operator|.
name|spill_size
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Spill all general registers.  */
for|for
control|(
name|regno
operator|=
name|GR_REG
argument_list|(
literal|1
argument_list|)
init|;
name|regno
operator|<=
name|GR_REG
argument_list|(
literal|31
argument_list|)
condition|;
operator|++
name|regno
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|current_frame_info
operator|.
name|mask
argument_list|,
name|regno
argument_list|)
condition|)
block|{
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|do_spill
argument_list|(
name|gen_gr_spill
argument_list|,
name|reg
argument_list|,
name|cfa_off
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|cfa_off
operator|-=
literal|8
expr_stmt|;
block|}
comment|/* Handle BR0 specially -- it may be getting stored permanently in      some GR register.  */
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|current_frame_info
operator|.
name|mask
argument_list|,
name|BR_REG
argument_list|(
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|BR_REG
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_b0
operator|!=
literal|0
condition|)
block|{
name|alt_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|current_frame_info
operator|.
name|reg_save_b0
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|alt_reg
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Even if we're not going to generate an epilogue, we still 	     need to save the register so that EH works.  */
if|if
condition|(
operator|!
name|epilogue_p
condition|)
name|emit_insn
argument_list|(
name|gen_prologue_use
argument_list|(
name|alt_reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|alt_regno
operator|=
name|next_scratch_gr_reg
argument_list|()
expr_stmt|;
name|alt_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|alt_regno
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|alt_reg
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|do_spill
argument_list|(
name|gen_movdi_x
argument_list|,
name|alt_reg
argument_list|,
name|cfa_off
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|cfa_off
operator|-=
literal|8
expr_stmt|;
block|}
block|}
comment|/* Spill the rest of the BR registers.  */
for|for
control|(
name|regno
operator|=
name|BR_REG
argument_list|(
literal|1
argument_list|)
init|;
name|regno
operator|<=
name|BR_REG
argument_list|(
literal|7
argument_list|)
condition|;
operator|++
name|regno
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|current_frame_info
operator|.
name|mask
argument_list|,
name|regno
argument_list|)
condition|)
block|{
name|alt_regno
operator|=
name|next_scratch_gr_reg
argument_list|()
expr_stmt|;
name|alt_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|alt_regno
argument_list|)
expr_stmt|;
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|alt_reg
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|do_spill
argument_list|(
name|gen_movdi_x
argument_list|,
name|alt_reg
argument_list|,
name|cfa_off
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|cfa_off
operator|-=
literal|8
expr_stmt|;
block|}
comment|/* Align the frame and spill all FR registers.  */
for|for
control|(
name|regno
operator|=
name|FR_REG
argument_list|(
literal|2
argument_list|)
init|;
name|regno
operator|<=
name|FR_REG
argument_list|(
literal|127
argument_list|)
condition|;
operator|++
name|regno
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|current_frame_info
operator|.
name|mask
argument_list|,
name|regno
argument_list|)
condition|)
block|{
if|if
condition|(
name|cfa_off
operator|&
literal|15
condition|)
name|abort
argument_list|()
expr_stmt|;
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|XFmode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|do_spill
argument_list|(
name|gen_fr_spill_x
argument_list|,
name|reg
argument_list|,
name|cfa_off
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|cfa_off
operator|-=
literal|16
expr_stmt|;
block|}
if|if
condition|(
name|cfa_off
operator|!=
name|current_frame_info
operator|.
name|spill_cfa_off
condition|)
name|abort
argument_list|()
expr_stmt|;
name|finish_spill_pointers
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called after register allocation to add any instructions needed for the    epilogue.  Using an epilogue insn is favored compared to putting all of the    instructions in output_function_prologue(), since it allows the scheduler    to intermix instructions with the saves of the caller saved registers.  In    some cases, it might be necessary to emit a barrier instruction as the last    insn to prevent such scheduling.  */
end_comment

begin_function
name|void
name|ia64_expand_epilogue
parameter_list|(
name|int
name|sibcall_p
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|,
name|reg
decl_stmt|,
name|alt_reg
decl_stmt|,
name|ar_unat_save_reg
decl_stmt|;
name|int
name|regno
decl_stmt|,
name|alt_regno
decl_stmt|,
name|cfa_off
decl_stmt|;
name|ia64_compute_frame_size
argument_list|(
name|get_frame_size
argument_list|()
argument_list|)
expr_stmt|;
comment|/* If there is a frame pointer, then we use it instead of the stack      pointer, so that the stack pointer does not need to be valid when      the epilogue starts.  See EXIT_IGNORE_STACK.  */
if|if
condition|(
name|frame_pointer_needed
condition|)
name|setup_spill_pointers
argument_list|(
name|current_frame_info
operator|.
name|n_spilled
argument_list|,
name|hard_frame_pointer_rtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|setup_spill_pointers
argument_list|(
name|current_frame_info
operator|.
name|n_spilled
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|current_frame_info
operator|.
name|total_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_frame_info
operator|.
name|total_size
operator|!=
literal|0
condition|)
block|{
comment|/* ??? At this point we must generate a magic insn that appears to          modify the spill iterators and the frame pointer.  This would 	 allow the most scheduling freedom.  For now, just hard stop.  */
name|emit_insn
argument_list|(
name|gen_blockage
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/* Locate the bottom of the register save area.  */
name|cfa_off
operator|=
operator|(
name|current_frame_info
operator|.
name|spill_cfa_off
operator|+
name|current_frame_info
operator|.
name|spill_size
operator|+
name|current_frame_info
operator|.
name|extra_spill_size
operator|)
expr_stmt|;
comment|/* Restore the predicate registers.  */
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|current_frame_info
operator|.
name|mask
argument_list|,
name|PR_REG
argument_list|(
literal|0
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_pr
operator|!=
literal|0
condition|)
name|alt_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|current_frame_info
operator|.
name|reg_save_pr
argument_list|)
expr_stmt|;
else|else
block|{
name|alt_regno
operator|=
name|next_scratch_gr_reg
argument_list|()
expr_stmt|;
name|alt_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|alt_regno
argument_list|)
expr_stmt|;
name|do_restore
argument_list|(
name|gen_movdi_x
argument_list|,
name|alt_reg
argument_list|,
name|cfa_off
argument_list|)
expr_stmt|;
name|cfa_off
operator|-=
literal|8
expr_stmt|;
block|}
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|PR_REG
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|alt_reg
argument_list|)
expr_stmt|;
block|}
comment|/* Restore the application registers.  */
comment|/* Load the saved unat from the stack, but do not restore it until      after the GRs have been restored.  */
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|current_frame_info
operator|.
name|mask
argument_list|,
name|AR_UNAT_REGNUM
argument_list|)
condition|)
block|{
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_ar_unat
operator|!=
literal|0
condition|)
name|ar_unat_save_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|current_frame_info
operator|.
name|reg_save_ar_unat
argument_list|)
expr_stmt|;
else|else
block|{
name|alt_regno
operator|=
name|next_scratch_gr_reg
argument_list|()
expr_stmt|;
name|ar_unat_save_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|alt_regno
argument_list|)
expr_stmt|;
name|current_frame_info
operator|.
name|gr_used_mask
operator||=
literal|1
operator|<<
name|alt_regno
expr_stmt|;
name|do_restore
argument_list|(
name|gen_movdi_x
argument_list|,
name|ar_unat_save_reg
argument_list|,
name|cfa_off
argument_list|)
expr_stmt|;
name|cfa_off
operator|-=
literal|8
expr_stmt|;
block|}
block|}
else|else
name|ar_unat_save_reg
operator|=
name|NULL_RTX
expr_stmt|;
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_ar_pfs
operator|!=
literal|0
condition|)
block|{
name|alt_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|current_frame_info
operator|.
name|reg_save_ar_pfs
argument_list|)
expr_stmt|;
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|AR_PFS_REGNUM
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|alt_reg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|current_frame_info
operator|.
name|mask
argument_list|,
name|AR_PFS_REGNUM
argument_list|)
condition|)
block|{
name|alt_regno
operator|=
name|next_scratch_gr_reg
argument_list|()
expr_stmt|;
name|alt_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|alt_regno
argument_list|)
expr_stmt|;
name|do_restore
argument_list|(
name|gen_movdi_x
argument_list|,
name|alt_reg
argument_list|,
name|cfa_off
argument_list|)
expr_stmt|;
name|cfa_off
operator|-=
literal|8
expr_stmt|;
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|AR_PFS_REGNUM
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|alt_reg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|current_frame_info
operator|.
name|mask
argument_list|,
name|AR_LC_REGNUM
argument_list|)
condition|)
block|{
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_ar_lc
operator|!=
literal|0
condition|)
name|alt_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|current_frame_info
operator|.
name|reg_save_ar_lc
argument_list|)
expr_stmt|;
else|else
block|{
name|alt_regno
operator|=
name|next_scratch_gr_reg
argument_list|()
expr_stmt|;
name|alt_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|alt_regno
argument_list|)
expr_stmt|;
name|do_restore
argument_list|(
name|gen_movdi_x
argument_list|,
name|alt_reg
argument_list|,
name|cfa_off
argument_list|)
expr_stmt|;
name|cfa_off
operator|-=
literal|8
expr_stmt|;
block|}
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|AR_LC_REGNUM
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|alt_reg
argument_list|)
expr_stmt|;
block|}
comment|/* We should now be at the base of the gr/br/fr spill area.  */
if|if
condition|(
name|cfa_off
operator|!=
operator|(
name|current_frame_info
operator|.
name|spill_cfa_off
operator|+
name|current_frame_info
operator|.
name|spill_size
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* The GP may be stored on the stack in the prologue, but it's      never restored in the epilogue.  Skip the stack slot.  */
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|current_frame_info
operator|.
name|mask
argument_list|,
name|GR_REG
argument_list|(
literal|1
argument_list|)
argument_list|)
condition|)
name|cfa_off
operator|-=
literal|8
expr_stmt|;
comment|/* Restore all general registers.  */
for|for
control|(
name|regno
operator|=
name|GR_REG
argument_list|(
literal|2
argument_list|)
init|;
name|regno
operator|<=
name|GR_REG
argument_list|(
literal|31
argument_list|)
condition|;
operator|++
name|regno
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|current_frame_info
operator|.
name|mask
argument_list|,
name|regno
argument_list|)
condition|)
block|{
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|do_restore
argument_list|(
name|gen_gr_restore
argument_list|,
name|reg
argument_list|,
name|cfa_off
argument_list|)
expr_stmt|;
name|cfa_off
operator|-=
literal|8
expr_stmt|;
block|}
comment|/* Restore the branch registers.  Handle B0 specially, as it may      have gotten stored in some GR register.  */
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|current_frame_info
operator|.
name|mask
argument_list|,
name|BR_REG
argument_list|(
literal|0
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_b0
operator|!=
literal|0
condition|)
name|alt_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|current_frame_info
operator|.
name|reg_save_b0
argument_list|)
expr_stmt|;
else|else
block|{
name|alt_regno
operator|=
name|next_scratch_gr_reg
argument_list|()
expr_stmt|;
name|alt_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|alt_regno
argument_list|)
expr_stmt|;
name|do_restore
argument_list|(
name|gen_movdi_x
argument_list|,
name|alt_reg
argument_list|,
name|cfa_off
argument_list|)
expr_stmt|;
name|cfa_off
operator|-=
literal|8
expr_stmt|;
block|}
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|BR_REG
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|alt_reg
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|regno
operator|=
name|BR_REG
argument_list|(
literal|1
argument_list|)
init|;
name|regno
operator|<=
name|BR_REG
argument_list|(
literal|7
argument_list|)
condition|;
operator|++
name|regno
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|current_frame_info
operator|.
name|mask
argument_list|,
name|regno
argument_list|)
condition|)
block|{
name|alt_regno
operator|=
name|next_scratch_gr_reg
argument_list|()
expr_stmt|;
name|alt_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|alt_regno
argument_list|)
expr_stmt|;
name|do_restore
argument_list|(
name|gen_movdi_x
argument_list|,
name|alt_reg
argument_list|,
name|cfa_off
argument_list|)
expr_stmt|;
name|cfa_off
operator|-=
literal|8
expr_stmt|;
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|alt_reg
argument_list|)
expr_stmt|;
block|}
comment|/* Restore floating point registers.  */
for|for
control|(
name|regno
operator|=
name|FR_REG
argument_list|(
literal|2
argument_list|)
init|;
name|regno
operator|<=
name|FR_REG
argument_list|(
literal|127
argument_list|)
condition|;
operator|++
name|regno
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|current_frame_info
operator|.
name|mask
argument_list|,
name|regno
argument_list|)
condition|)
block|{
if|if
condition|(
name|cfa_off
operator|&
literal|15
condition|)
name|abort
argument_list|()
expr_stmt|;
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|XFmode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|do_restore
argument_list|(
name|gen_fr_restore_x
argument_list|,
name|reg
argument_list|,
name|cfa_off
argument_list|)
expr_stmt|;
name|cfa_off
operator|-=
literal|16
expr_stmt|;
block|}
comment|/* Restore ar.unat for real.  */
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|current_frame_info
operator|.
name|mask
argument_list|,
name|AR_UNAT_REGNUM
argument_list|)
condition|)
block|{
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|AR_UNAT_REGNUM
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|ar_unat_save_reg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cfa_off
operator|!=
name|current_frame_info
operator|.
name|spill_cfa_off
condition|)
name|abort
argument_list|()
expr_stmt|;
name|finish_spill_pointers
argument_list|()
expr_stmt|;
if|if
condition|(
name|current_frame_info
operator|.
name|total_size
operator|||
name|cfun
operator|->
name|machine
operator|->
name|ia64_eh_epilogue_sp
condition|)
block|{
comment|/* ??? At this point we must generate a magic insn that appears to          modify the spill iterators, the stack pointer, and the frame 	 pointer.  This would allow the most scheduling freedom.  For now, 	 just hard stop.  */
name|emit_insn
argument_list|(
name|gen_blockage
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cfun
operator|->
name|machine
operator|->
name|ia64_eh_epilogue_sp
condition|)
name|emit_move_insn
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|cfun
operator|->
name|machine
operator|->
name|ia64_eh_epilogue_sp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|hard_frame_pointer_rtx
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|current_frame_info
operator|.
name|total_size
condition|)
block|{
name|rtx
name|offset
decl_stmt|,
name|frame_size_rtx
decl_stmt|;
name|frame_size_rtx
operator|=
name|GEN_INT
argument_list|(
name|current_frame_info
operator|.
name|total_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONST_OK_FOR_I
argument_list|(
name|current_frame_info
operator|.
name|total_size
argument_list|)
condition|)
name|offset
operator|=
name|frame_size_rtx
expr_stmt|;
else|else
block|{
name|regno
operator|=
name|next_scratch_gr_reg
argument_list|()
expr_stmt|;
name|offset
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|offset
argument_list|,
name|frame_size_rtx
argument_list|)
expr_stmt|;
block|}
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|offset
argument_list|)
operator|!=
name|CONST_INT
condition|)
block|{
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_FRAME_RELATED_EXPR
argument_list|,
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|DImode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|frame_size_rtx
argument_list|)
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cfun
operator|->
name|machine
operator|->
name|ia64_eh_epilogue_bsp
condition|)
name|emit_insn
argument_list|(
name|gen_set_bsp
argument_list|(
name|cfun
operator|->
name|machine
operator|->
name|ia64_eh_epilogue_bsp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sibcall_p
condition|)
name|emit_jump_insn
argument_list|(
name|gen_return_internal
argument_list|(
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|BR_REG
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|fp
init|=
name|GR_REG
argument_list|(
literal|2
argument_list|)
decl_stmt|;
comment|/* We need a throw away register here, r0 and r1 are reserved, so r2 is the 	 first available call clobbered register.  If there was a frame_pointer 	 register, we may have swapped the names of r2 and HARD_FRAME_POINTER_REGNUM, 	 so we have to make sure we're using the string "r2" when emitting 	 the register name for the assembler.  */
if|if
condition|(
name|current_frame_info
operator|.
name|reg_fp
operator|&&
name|current_frame_info
operator|.
name|reg_fp
operator|==
name|GR_REG
argument_list|(
literal|2
argument_list|)
condition|)
name|fp
operator|=
name|HARD_FRAME_POINTER_REGNUM
expr_stmt|;
comment|/* We must emit an alloc to force the input registers to become output 	 registers.  Otherwise, if the callee tries to pass its parameters 	 through to another call without an intervening alloc, then these 	 values get lost.  */
comment|/* ??? We don't need to preserve all input registers.  We only need to 	 preserve those input registers used as arguments to the sibling call. 	 It is unclear how to compute that number here.  */
if|if
condition|(
name|current_frame_info
operator|.
name|n_input_regs
operator|!=
literal|0
condition|)
block|{
name|rtx
name|n_inputs
init|=
name|GEN_INT
argument_list|(
name|current_frame_info
operator|.
name|n_input_regs
argument_list|)
decl_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_alloc
argument_list|(
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|fp
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|const0_rtx
argument_list|,
name|n_inputs
argument_list|,
name|const0_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Return 1 if br.ret can do all the work required to return from a    function.  */
end_comment

begin_function
name|int
name|ia64_direct_return
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|reload_completed
operator|&&
operator|!
name|frame_pointer_needed
condition|)
block|{
name|ia64_compute_frame_size
argument_list|(
name|get_frame_size
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|(
name|current_frame_info
operator|.
name|total_size
operator|==
literal|0
operator|&&
name|current_frame_info
operator|.
name|n_spilled
operator|==
literal|0
operator|&&
name|current_frame_info
operator|.
name|reg_save_b0
operator|==
literal|0
operator|&&
name|current_frame_info
operator|.
name|reg_save_pr
operator|==
literal|0
operator|&&
name|current_frame_info
operator|.
name|reg_save_ar_pfs
operator|==
literal|0
operator|&&
name|current_frame_info
operator|.
name|reg_save_ar_unat
operator|==
literal|0
operator|&&
name|current_frame_info
operator|.
name|reg_save_ar_lc
operator|==
literal|0
operator|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the magic cookie that we use to hold the return address    during early compilation.  */
end_comment

begin_function
name|rtx
name|ia64_return_addr_rtx
parameter_list|(
name|HOST_WIDE_INT
name|count
parameter_list|,
name|rtx
name|frame
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
return|return
name|NULL
return|;
return|return
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|const0_rtx
argument_list|)
argument_list|,
name|UNSPEC_RET_ADDR
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Split this value after reload, now that we know where the return    address is saved.  */
end_comment

begin_function
name|void
name|ia64_split_return_addr_rtx
parameter_list|(
name|rtx
name|dest
parameter_list|)
block|{
name|rtx
name|src
decl_stmt|;
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|current_frame_info
operator|.
name|mask
argument_list|,
name|BR_REG
argument_list|(
literal|0
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_b0
operator|!=
literal|0
condition|)
name|src
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|current_frame_info
operator|.
name|reg_save_b0
argument_list|)
expr_stmt|;
else|else
block|{
name|HOST_WIDE_INT
name|off
decl_stmt|;
name|unsigned
name|int
name|regno
decl_stmt|;
comment|/* Compute offset from CFA for BR0.  */
comment|/* ??? Must be kept in sync with ia64_expand_prologue.  */
name|off
operator|=
operator|(
name|current_frame_info
operator|.
name|spill_cfa_off
operator|+
name|current_frame_info
operator|.
name|spill_size
operator|)
expr_stmt|;
for|for
control|(
name|regno
operator|=
name|GR_REG
argument_list|(
literal|1
argument_list|)
init|;
name|regno
operator|<=
name|GR_REG
argument_list|(
literal|31
argument_list|)
condition|;
operator|++
name|regno
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|current_frame_info
operator|.
name|mask
argument_list|,
name|regno
argument_list|)
condition|)
name|off
operator|-=
literal|8
expr_stmt|;
comment|/* Convert CFA offset to a register based offset.  */
if|if
condition|(
name|frame_pointer_needed
condition|)
name|src
operator|=
name|hard_frame_pointer_rtx
expr_stmt|;
else|else
block|{
name|src
operator|=
name|stack_pointer_rtx
expr_stmt|;
name|off
operator|+=
name|current_frame_info
operator|.
name|total_size
expr_stmt|;
block|}
comment|/* Load address into scratch register.  */
if|if
condition|(
name|CONST_OK_FOR_I
argument_list|(
name|off
argument_list|)
condition|)
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|GEN_INT
argument_list|(
name|off
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|GEN_INT
argument_list|(
name|off
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|dest
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|src
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|dest
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|src
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|BR_REG
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|src
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ia64_hard_regno_rename_ok
parameter_list|(
name|int
name|from
parameter_list|,
name|int
name|to
parameter_list|)
block|{
comment|/* Don't clobber any of the registers we reserved for the prologue.  */
if|if
condition|(
name|to
operator|==
name|current_frame_info
operator|.
name|reg_fp
operator|||
name|to
operator|==
name|current_frame_info
operator|.
name|reg_save_b0
operator|||
name|to
operator|==
name|current_frame_info
operator|.
name|reg_save_pr
operator|||
name|to
operator|==
name|current_frame_info
operator|.
name|reg_save_ar_pfs
operator|||
name|to
operator|==
name|current_frame_info
operator|.
name|reg_save_ar_unat
operator|||
name|to
operator|==
name|current_frame_info
operator|.
name|reg_save_ar_lc
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|from
operator|==
name|current_frame_info
operator|.
name|reg_fp
operator|||
name|from
operator|==
name|current_frame_info
operator|.
name|reg_save_b0
operator|||
name|from
operator|==
name|current_frame_info
operator|.
name|reg_save_pr
operator|||
name|from
operator|==
name|current_frame_info
operator|.
name|reg_save_ar_pfs
operator|||
name|from
operator|==
name|current_frame_info
operator|.
name|reg_save_ar_unat
operator|||
name|from
operator|==
name|current_frame_info
operator|.
name|reg_save_ar_lc
condition|)
return|return
literal|0
return|;
comment|/* Don't use output registers outside the register frame.  */
if|if
condition|(
name|OUT_REGNO_P
argument_list|(
name|to
argument_list|)
operator|&&
name|to
operator|>=
name|OUT_REG
argument_list|(
name|current_frame_info
operator|.
name|n_output_regs
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Retain even/oddness on predicate register pairs.  */
if|if
condition|(
name|PR_REGNO_P
argument_list|(
name|from
argument_list|)
operator|&&
name|PR_REGNO_P
argument_list|(
name|to
argument_list|)
condition|)
return|return
operator|(
name|from
operator|&
literal|1
operator|)
operator|==
operator|(
name|to
operator|&
literal|1
operator|)
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Target hook for assembling integer objects.  Handle word-sized    aligned objects and detect the cases when @fptr is needed.  */
end_comment

begin_function
specifier|static
name|bool
name|ia64_assemble_integer
parameter_list|(
name|rtx
name|x
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|,
name|int
name|aligned_p
parameter_list|)
block|{
if|if
condition|(
name|size
operator|==
name|POINTER_SIZE
operator|/
name|BITS_PER_UNIT
operator|&&
operator|!
operator|(
name|TARGET_NO_PIC
operator|||
name|TARGET_AUTO_PIC
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|SYMBOL_REF_FUNCTION_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|directive
index|[
literal|2
index|]
index|[
literal|2
index|]
init|=
block|{
comment|/* 64-bit pointer */
comment|/* 32-bit pointer */
block|{
literal|"\tdata8.ua\t@fptr("
block|,
literal|"\tdata4.ua\t@fptr("
block|}
block|,
comment|/* unaligned */
block|{
literal|"\tdata8\t@fptr("
block|,
literal|"\tdata4\t@fptr("
block|}
comment|/* aligned */
block|}
decl_stmt|;
name|fputs
argument_list|(
name|directive
index|[
operator|(
name|aligned_p
operator|!=
literal|0
operator|)
index|]
index|[
name|POINTER_SIZE
operator|==
literal|32
index|]
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|asm_out_file
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|")\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|default_assemble_integer
argument_list|(
name|x
argument_list|,
name|size
argument_list|,
name|aligned_p
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Emit the function prologue.  */
end_comment

begin_function
specifier|static
name|void
name|ia64_output_function_prologue
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|HOST_WIDE_INT
name|size
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
name|mask
decl_stmt|,
name|grsave
decl_stmt|,
name|grsave_prev
decl_stmt|;
if|if
condition|(
name|current_frame_info
operator|.
name|need_regstk
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.regstk %d, %d, %d, %d\n"
argument_list|,
name|current_frame_info
operator|.
name|n_input_regs
argument_list|,
name|current_frame_info
operator|.
name|n_local_regs
argument_list|,
name|current_frame_info
operator|.
name|n_output_regs
argument_list|,
name|current_frame_info
operator|.
name|n_rotate_regs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flag_unwind_tables
operator|&&
operator|(
operator|!
name|flag_exceptions
operator|||
name|USING_SJLJ_EXCEPTIONS
operator|)
condition|)
return|return;
comment|/* Emit the .prologue directive.  */
name|mask
operator|=
literal|0
expr_stmt|;
name|grsave
operator|=
name|grsave_prev
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_b0
operator|!=
literal|0
condition|)
block|{
name|mask
operator||=
literal|8
expr_stmt|;
name|grsave
operator|=
name|grsave_prev
operator|=
name|current_frame_info
operator|.
name|reg_save_b0
expr_stmt|;
block|}
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_ar_pfs
operator|!=
literal|0
operator|&&
operator|(
name|grsave_prev
operator|==
literal|0
operator|||
name|current_frame_info
operator|.
name|reg_save_ar_pfs
operator|==
name|grsave_prev
operator|+
literal|1
operator|)
condition|)
block|{
name|mask
operator||=
literal|4
expr_stmt|;
if|if
condition|(
name|grsave_prev
operator|==
literal|0
condition|)
name|grsave
operator|=
name|current_frame_info
operator|.
name|reg_save_ar_pfs
expr_stmt|;
name|grsave_prev
operator|=
name|current_frame_info
operator|.
name|reg_save_ar_pfs
expr_stmt|;
block|}
if|if
condition|(
name|current_frame_info
operator|.
name|reg_fp
operator|!=
literal|0
operator|&&
operator|(
name|grsave_prev
operator|==
literal|0
operator|||
name|current_frame_info
operator|.
name|reg_fp
operator|==
name|grsave_prev
operator|+
literal|1
operator|)
condition|)
block|{
name|mask
operator||=
literal|2
expr_stmt|;
if|if
condition|(
name|grsave_prev
operator|==
literal|0
condition|)
name|grsave
operator|=
name|HARD_FRAME_POINTER_REGNUM
expr_stmt|;
name|grsave_prev
operator|=
name|current_frame_info
operator|.
name|reg_fp
expr_stmt|;
block|}
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_pr
operator|!=
literal|0
operator|&&
operator|(
name|grsave_prev
operator|==
literal|0
operator|||
name|current_frame_info
operator|.
name|reg_save_pr
operator|==
name|grsave_prev
operator|+
literal|1
operator|)
condition|)
block|{
name|mask
operator||=
literal|1
expr_stmt|;
if|if
condition|(
name|grsave_prev
operator|==
literal|0
condition|)
name|grsave
operator|=
name|current_frame_info
operator|.
name|reg_save_pr
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&&
name|TARGET_GNU_AS
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.prologue %d, %d\n"
argument_list|,
name|mask
argument_list|,
name|ia64_dbx_register_number
argument_list|(
name|grsave
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
literal|"\t.prologue\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
comment|/* Emit a .spill directive, if necessary, to relocate the base of      the register spill area.  */
if|if
condition|(
name|current_frame_info
operator|.
name|spill_cfa_off
operator|!=
operator|-
literal|16
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t.spill %ld\n"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|current_frame_info
operator|.
name|spill_cfa_off
operator|+
name|current_frame_info
operator|.
name|spill_size
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit the .body directive at the scheduled end of the prologue.  */
end_comment

begin_function
specifier|static
name|void
name|ia64_output_function_end_prologue
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
if|if
condition|(
operator|!
name|flag_unwind_tables
operator|&&
operator|(
operator|!
name|flag_exceptions
operator|||
name|USING_SJLJ_EXCEPTIONS
operator|)
condition|)
return|return;
name|fputs
argument_list|(
literal|"\t.body\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit the function epilogue.  */
end_comment

begin_function
specifier|static
name|void
name|ia64_output_function_epilogue
parameter_list|(
name|FILE
modifier|*
name|file
name|ATTRIBUTE_UNUSED
parameter_list|,
name|HOST_WIDE_INT
name|size
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|current_frame_info
operator|.
name|reg_fp
condition|)
block|{
specifier|const
name|char
modifier|*
name|tmp
init|=
name|reg_names
index|[
name|HARD_FRAME_POINTER_REGNUM
index|]
decl_stmt|;
name|reg_names
index|[
name|HARD_FRAME_POINTER_REGNUM
index|]
operator|=
name|reg_names
index|[
name|current_frame_info
operator|.
name|reg_fp
index|]
expr_stmt|;
name|reg_names
index|[
name|current_frame_info
operator|.
name|reg_fp
index|]
operator|=
name|tmp
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TARGET_REG_NAMES
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|current_frame_info
operator|.
name|n_input_regs
condition|;
name|i
operator|++
control|)
name|reg_names
index|[
name|IN_REG
argument_list|(
name|i
argument_list|)
index|]
operator|=
name|ia64_input_reg_names
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|current_frame_info
operator|.
name|n_local_regs
condition|;
name|i
operator|++
control|)
name|reg_names
index|[
name|LOC_REG
argument_list|(
name|i
argument_list|)
index|]
operator|=
name|ia64_local_reg_names
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|current_frame_info
operator|.
name|n_output_regs
condition|;
name|i
operator|++
control|)
name|reg_names
index|[
name|OUT_REG
argument_list|(
name|i
argument_list|)
index|]
operator|=
name|ia64_output_reg_names
index|[
name|i
index|]
expr_stmt|;
block|}
name|current_frame_info
operator|.
name|initialized
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ia64_dbx_register_number
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
comment|/* In ia64_expand_prologue we quite literally renamed the frame pointer      from its home at loc79 to something inside the register frame.  We      must perform the same renumbering here for the debug info.  */
if|if
condition|(
name|current_frame_info
operator|.
name|reg_fp
condition|)
block|{
if|if
condition|(
name|regno
operator|==
name|HARD_FRAME_POINTER_REGNUM
condition|)
name|regno
operator|=
name|current_frame_info
operator|.
name|reg_fp
expr_stmt|;
elseif|else
if|if
condition|(
name|regno
operator|==
name|current_frame_info
operator|.
name|reg_fp
condition|)
name|regno
operator|=
name|HARD_FRAME_POINTER_REGNUM
expr_stmt|;
block|}
if|if
condition|(
name|IN_REGNO_P
argument_list|(
name|regno
argument_list|)
condition|)
return|return
literal|32
operator|+
name|regno
operator|-
name|IN_REG
argument_list|(
literal|0
argument_list|)
return|;
elseif|else
if|if
condition|(
name|LOC_REGNO_P
argument_list|(
name|regno
argument_list|)
condition|)
return|return
literal|32
operator|+
name|current_frame_info
operator|.
name|n_input_regs
operator|+
name|regno
operator|-
name|LOC_REG
argument_list|(
literal|0
argument_list|)
return|;
elseif|else
if|if
condition|(
name|OUT_REGNO_P
argument_list|(
name|regno
argument_list|)
condition|)
return|return
operator|(
literal|32
operator|+
name|current_frame_info
operator|.
name|n_input_regs
operator|+
name|current_frame_info
operator|.
name|n_local_regs
operator|+
name|regno
operator|-
name|OUT_REG
argument_list|(
literal|0
argument_list|)
operator|)
return|;
else|else
return|return
name|regno
return|;
block|}
end_function

begin_function
name|void
name|ia64_initialize_trampoline
parameter_list|(
name|rtx
name|addr
parameter_list|,
name|rtx
name|fnaddr
parameter_list|,
name|rtx
name|static_chain
parameter_list|)
block|{
name|rtx
name|addr_reg
decl_stmt|,
name|eight
init|=
name|GEN_INT
argument_list|(
literal|8
argument_list|)
decl_stmt|;
comment|/* The Intel assembler requires that the global __ia64_trampoline symbol      be declared explicitly */
if|if
condition|(
operator|!
name|TARGET_GNU_AS
condition|)
block|{
specifier|static
name|bool
name|declared_ia64_trampoline
init|=
name|false
decl_stmt|;
if|if
condition|(
operator|!
name|declared_ia64_trampoline
condition|)
block|{
name|declared_ia64_trampoline
operator|=
name|true
expr_stmt|;
call|(
modifier|*
name|targetm
operator|.
name|asm_out
operator|.
name|globalize_label
call|)
argument_list|(
name|asm_out_file
argument_list|,
literal|"__ia64_trampoline"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Load up our iterator.  */
name|addr_reg
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|addr_reg
argument_list|,
name|addr
argument_list|)
expr_stmt|;
comment|/* The first two words are the fake descriptor:      __ia64_trampoline, ADDR+16.  */
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|addr_reg
argument_list|)
argument_list|,
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
literal|"__ia64_trampoline"
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|addr_reg
argument_list|,
name|addr_reg
argument_list|,
name|eight
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|addr_reg
argument_list|)
argument_list|,
name|copy_to_reg
argument_list|(
name|plus_constant
argument_list|(
name|addr
argument_list|,
literal|16
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|addr_reg
argument_list|,
name|addr_reg
argument_list|,
name|eight
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The third word is the target descriptor.  */
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|addr_reg
argument_list|)
argument_list|,
name|fnaddr
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|addr_reg
argument_list|,
name|addr_reg
argument_list|,
name|eight
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The fourth word is the static chain.  */
name|emit_move_insn
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|addr_reg
argument_list|)
argument_list|,
name|static_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Do any needed setup for a variadic function.  CUM has not been updated    for the last named argument which has type TYPE and mode MODE.     We generate the actual spill instructions during prologue generation.  */
end_comment

begin_function
name|void
name|ia64_setup_incoming_varargs
parameter_list|(
name|CUMULATIVE_ARGS
name|cum
parameter_list|,
name|int
name|int_mode
parameter_list|,
name|tree
name|type
parameter_list|,
name|int
modifier|*
name|pretend_size
parameter_list|,
name|int
name|second_time
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* Skip the current argument.  */
name|ia64_function_arg_advance
argument_list|(
operator|&
name|cum
argument_list|,
name|int_mode
argument_list|,
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cum
operator|.
name|words
operator|<
name|MAX_ARGUMENT_SLOTS
condition|)
block|{
name|int
name|n
init|=
name|MAX_ARGUMENT_SLOTS
operator|-
name|cum
operator|.
name|words
decl_stmt|;
operator|*
name|pretend_size
operator|=
name|n
operator|*
name|UNITS_PER_WORD
expr_stmt|;
name|cfun
operator|->
name|machine
operator|->
name|n_varargs
operator|=
name|n
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Check whether TYPE is a homogeneous floating point aggregate.  If    it is, return the mode of the floating point type that appears    in all leafs.  If it is not, return VOIDmode.     An aggregate is a homogeneous floating point aggregate is if all    fields/elements in it have the same floating point type (e.g,    SFmode).  128-bit quad-precision floats are excluded.  */
end_comment

begin_function
specifier|static
name|enum
name|machine_mode
name|hfa_element_mode
parameter_list|(
name|tree
name|type
parameter_list|,
name|int
name|nested
parameter_list|)
block|{
name|enum
name|machine_mode
name|element_mode
init|=
name|VOIDmode
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|know_element_mode
init|=
literal|0
decl_stmt|;
name|tree
name|t
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|VOID_TYPE
case|:
case|case
name|INTEGER_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
case|case
name|BOOLEAN_TYPE
case|:
case|case
name|CHAR_TYPE
case|:
case|case
name|POINTER_TYPE
case|:
case|case
name|OFFSET_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
case|case
name|METHOD_TYPE
case|:
case|case
name|FILE_TYPE
case|:
case|case
name|SET_TYPE
case|:
case|case
name|LANG_TYPE
case|:
case|case
name|FUNCTION_TYPE
case|:
return|return
name|VOIDmode
return|;
comment|/* Fortran complex types are supposed to be HFAs, so we need to handle 	 gcc's COMPLEX_TYPEs as HFAs.  We need to exclude the integral complex 	 types though.  */
case|case
name|COMPLEX_TYPE
case|:
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|MODE_COMPLEX_FLOAT
operator|&&
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TCmode
condition|)
return|return
name|GET_MODE_INNER
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
else|else
return|return
name|VOIDmode
return|;
case|case
name|REAL_TYPE
case|:
comment|/* We want to return VOIDmode for raw REAL_TYPEs, but the actual 	 mode if this is contained within an aggregate.  */
if|if
condition|(
name|nested
operator|&&
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TFmode
condition|)
return|return
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
return|;
else|else
return|return
name|VOIDmode
return|;
case|case
name|ARRAY_TYPE
case|:
return|return
name|hfa_element_mode
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
return|;
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|QUAL_UNION_TYPE
case|:
for|for
control|(
name|t
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
continue|continue;
name|mode
operator|=
name|hfa_element_mode
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|know_element_mode
condition|)
block|{
if|if
condition|(
name|mode
operator|!=
name|element_mode
condition|)
return|return
name|VOIDmode
return|;
block|}
elseif|else
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_FLOAT
condition|)
return|return
name|VOIDmode
return|;
else|else
block|{
name|know_element_mode
operator|=
literal|1
expr_stmt|;
name|element_mode
operator|=
name|mode
expr_stmt|;
block|}
block|}
return|return
name|element_mode
return|;
default|default:
comment|/* If we reach here, we probably have some front-end specific type 	 that the backend doesn't know about.  This can happen via the 	 aggregate_value_p call in init_function_start.  All we can do is 	 ignore unknown tree types.  */
return|return
name|VOIDmode
return|;
block|}
return|return
name|VOIDmode
return|;
block|}
end_function

begin_comment
comment|/* Return the number of words required to hold a quantity of TYPE and MODE    when passed as an argument.  */
end_comment

begin_function
specifier|static
name|int
name|ia64_function_arg_words
parameter_list|(
name|tree
name|type
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|int
name|words
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|BLKmode
condition|)
name|words
operator|=
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
expr_stmt|;
else|else
name|words
operator|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
return|return
operator|(
name|words
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
return|;
comment|/* round up */
block|}
end_function

begin_comment
comment|/* Return the number of registers that should be skipped so the current    argument (described by TYPE and WORDS) will be properly aligned.     Integer and float arguments larger than 8 bytes start at the next    even boundary.  Aggregates larger than 8 bytes start at the next    even boundary if the aggregate has 16 byte alignment.  Note that    in the 32-bit ABI, TImode and TFmode have only 8-byte alignment    but are still to be aligned in registers.     ??? The ABI does not specify how to handle aggregates with    alignment from 9 to 15 bytes, or greater than 16.  We handle them    all as if they had 16 byte alignment.  Such aggregates can occur    only if gcc extensions are used.  */
end_comment

begin_function
specifier|static
name|int
name|ia64_function_arg_offset
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
name|cum
parameter_list|,
name|tree
name|type
parameter_list|,
name|int
name|words
parameter_list|)
block|{
if|if
condition|(
operator|(
name|cum
operator|->
name|words
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|type
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|INTEGER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|REAL_TYPE
condition|)
return|return
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|>
literal|8
operator|*
name|BITS_PER_UNIT
return|;
else|else
return|return
name|words
operator|>
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return rtx for register where argument is passed, or zero if it is passed    on the stack.  */
end_comment

begin_comment
comment|/* ??? 128-bit quad-precision floats are always passed in general    registers.  */
end_comment

begin_function
name|rtx
name|ia64_function_arg
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
name|cum
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|type
parameter_list|,
name|int
name|named
parameter_list|,
name|int
name|incoming
parameter_list|)
block|{
name|int
name|basereg
init|=
operator|(
name|incoming
condition|?
name|GR_ARG_FIRST
else|:
name|AR_ARG_FIRST
operator|)
decl_stmt|;
name|int
name|words
init|=
name|ia64_function_arg_words
argument_list|(
name|type
argument_list|,
name|mode
argument_list|)
decl_stmt|;
name|int
name|offset
init|=
name|ia64_function_arg_offset
argument_list|(
name|cum
argument_list|,
name|type
argument_list|,
name|words
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|hfa_mode
init|=
name|VOIDmode
decl_stmt|;
comment|/* If all argument slots are used, then it must go on the stack.  */
if|if
condition|(
name|cum
operator|->
name|words
operator|+
name|offset
operator|>=
name|MAX_ARGUMENT_SLOTS
condition|)
return|return
literal|0
return|;
comment|/* Check for and handle homogeneous FP aggregates.  */
if|if
condition|(
name|type
condition|)
name|hfa_mode
operator|=
name|hfa_element_mode
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Unnamed prototyped hfas are passed as usual.  Named prototyped hfas      and unprototyped hfas are passed specially.  */
if|if
condition|(
name|hfa_mode
operator|!=
name|VOIDmode
operator|&&
operator|(
operator|!
name|cum
operator|->
name|prototype
operator|||
name|named
operator|)
condition|)
block|{
name|rtx
name|loc
index|[
literal|16
index|]
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|fp_regs
init|=
name|cum
operator|->
name|fp_regs
decl_stmt|;
name|int
name|int_regs
init|=
name|cum
operator|->
name|words
operator|+
name|offset
decl_stmt|;
name|int
name|hfa_size
init|=
name|GET_MODE_SIZE
argument_list|(
name|hfa_mode
argument_list|)
decl_stmt|;
name|int
name|byte_size
decl_stmt|;
name|int
name|args_byte_size
decl_stmt|;
comment|/* If prototyped, pass it in FR regs then GR regs. 	 If not prototyped, pass it in both FR and GR regs.  	 If this is an SFmode aggregate, then it is possible to run out of 	 FR regs while GR regs are still left.  In that case, we pass the 	 remaining part in the GR regs.  */
comment|/* Fill the FP regs.  We do this always.  We stop if we reach the end 	 of the argument, the last FP register, or the last argument slot.  */
name|byte_size
operator|=
operator|(
operator|(
name|mode
operator|==
name|BLKmode
operator|)
condition|?
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
else|:
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|)
expr_stmt|;
name|args_byte_size
operator|=
name|int_regs
operator|*
name|UNITS_PER_WORD
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
operator|(
name|offset
operator|<
name|byte_size
operator|&&
name|fp_regs
operator|<
name|MAX_ARGUMENT_SLOTS
operator|&&
name|args_byte_size
operator|<
operator|(
name|MAX_ARGUMENT_SLOTS
operator|*
name|UNITS_PER_WORD
operator|)
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|loc
index|[
name|i
index|]
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|hfa_mode
argument_list|,
operator|(
name|FR_ARG_FIRST
operator|+
name|fp_regs
operator|)
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|hfa_size
expr_stmt|;
name|args_byte_size
operator|+=
name|hfa_size
expr_stmt|;
name|fp_regs
operator|++
expr_stmt|;
block|}
comment|/* If no prototype, then the whole thing must go in GR regs.  */
if|if
condition|(
operator|!
name|cum
operator|->
name|prototype
condition|)
name|offset
operator|=
literal|0
expr_stmt|;
comment|/* If this is an SFmode aggregate, then we might have some left over 	 that needs to go in GR regs.  */
elseif|else
if|if
condition|(
name|byte_size
operator|!=
name|offset
condition|)
name|int_regs
operator|+=
name|offset
operator|/
name|UNITS_PER_WORD
expr_stmt|;
comment|/* Fill in the GR regs.  We must use DImode here, not the hfa mode.  */
for|for
control|(
init|;
name|offset
operator|<
name|byte_size
operator|&&
name|int_regs
operator|<
name|MAX_ARGUMENT_SLOTS
condition|;
name|i
operator|++
control|)
block|{
name|enum
name|machine_mode
name|gr_mode
init|=
name|DImode
decl_stmt|;
name|unsigned
name|int
name|gr_size
decl_stmt|;
comment|/* If we have an odd 4 byte hunk because we ran out of FR regs, 	     then this goes in a GR reg left adjusted/little endian, right 	     adjusted/big endian.  */
comment|/* ??? Currently this is handled wrong, because 4-byte hunks are 	     always right adjusted/little endian.  */
if|if
condition|(
name|offset
operator|&
literal|0x4
condition|)
name|gr_mode
operator|=
name|SImode
expr_stmt|;
comment|/* If we have an even 4 byte hunk because the aggregate is a 	     multiple of 4 bytes in size, then this goes in a GR reg right 	     adjusted/little endian.  */
elseif|else
if|if
condition|(
name|byte_size
operator|-
name|offset
operator|==
literal|4
condition|)
name|gr_mode
operator|=
name|SImode
expr_stmt|;
name|loc
index|[
name|i
index|]
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|gr_mode
argument_list|,
operator|(
name|basereg
operator|+
name|int_regs
operator|)
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|gr_size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|gr_mode
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|gr_size
expr_stmt|;
if|if
condition|(
name|gr_size
operator|==
name|UNITS_PER_WORD
operator|||
operator|(
name|gr_size
operator|<
name|UNITS_PER_WORD
operator|&&
name|offset
operator|%
name|UNITS_PER_WORD
operator|==
literal|0
operator|)
condition|)
name|int_regs
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|gr_size
operator|>
name|UNITS_PER_WORD
condition|)
name|int_regs
operator|+=
name|gr_size
operator|/
name|UNITS_PER_WORD
expr_stmt|;
block|}
comment|/* If we ended up using just one location, just return that one loc, but 	 change the mode back to the argument mode.  */
if|if
condition|(
name|i
operator|==
literal|1
condition|)
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|loc
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
else|else
return|return
name|gen_rtx_PARALLEL
argument_list|(
name|mode
argument_list|,
name|gen_rtvec_v
argument_list|(
name|i
argument_list|,
name|loc
argument_list|)
argument_list|)
return|;
block|}
comment|/* Integral and aggregates go in general registers.  If we have run out of      FR registers, then FP values must also go in general registers.  This can      happen when we have a SFmode HFA.  */
elseif|else
if|if
condition|(
name|mode
operator|==
name|TFmode
operator|||
name|mode
operator|==
name|TCmode
operator|||
operator|(
operator|!
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
operator|||
name|cum
operator|->
name|fp_regs
operator|==
name|MAX_ARGUMENT_SLOTS
operator|)
condition|)
block|{
name|int
name|byte_size
init|=
operator|(
operator|(
name|mode
operator|==
name|BLKmode
operator|)
condition|?
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
else|:
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
operator|&&
operator|(
name|mode
operator|==
name|BLKmode
operator|||
operator|(
name|type
operator|&&
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
operator|)
operator|)
operator|&&
name|byte_size
operator|<
name|UNITS_PER_WORD
operator|&&
name|byte_size
operator|>
literal|0
condition|)
block|{
name|rtx
name|gr_reg
init|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
operator|(
name|basereg
operator|+
name|cum
operator|->
name|words
operator|+
name|offset
operator|)
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
decl_stmt|;
return|return
name|gen_rtx_PARALLEL
argument_list|(
name|mode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|gr_reg
argument_list|)
argument_list|)
return|;
block|}
else|else
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|basereg
operator|+
name|cum
operator|->
name|words
operator|+
name|offset
argument_list|)
return|;
block|}
comment|/* If there is a prototype, then FP values go in a FR register when      named, and in a GR register when unnamed.  */
elseif|else
if|if
condition|(
name|cum
operator|->
name|prototype
condition|)
block|{
if|if
condition|(
name|named
condition|)
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|FR_ARG_FIRST
operator|+
name|cum
operator|->
name|fp_regs
argument_list|)
return|;
comment|/* In big-endian mode, an anonymous SFmode value must be represented          as (parallel:SF [(expr_list (reg:DI n) (const_int 0))]) to force 	 the value into the high half of the general register.  */
elseif|else
if|if
condition|(
name|BYTES_BIG_ENDIAN
operator|&&
name|mode
operator|==
name|SFmode
condition|)
return|return
name|gen_rtx_PARALLEL
argument_list|(
name|mode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|basereg
operator|+
name|cum
operator|->
name|words
operator|+
name|offset
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
argument_list|)
argument_list|)
return|;
else|else
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|basereg
operator|+
name|cum
operator|->
name|words
operator|+
name|offset
argument_list|)
return|;
block|}
comment|/* If there is no prototype, then FP values go in both FR and GR      registers.  */
else|else
block|{
comment|/* See comment above.  */
name|enum
name|machine_mode
name|inner_mode
init|=
operator|(
name|BYTES_BIG_ENDIAN
operator|&&
name|mode
operator|==
name|SFmode
operator|)
condition|?
name|DImode
else|:
name|mode
decl_stmt|;
name|rtx
name|fp_reg
init|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
operator|(
name|FR_ARG_FIRST
operator|+
name|cum
operator|->
name|fp_regs
operator|)
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
decl_stmt|;
name|rtx
name|gr_reg
init|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|inner_mode
argument_list|,
operator|(
name|basereg
operator|+
name|cum
operator|->
name|words
operator|+
name|offset
operator|)
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
decl_stmt|;
return|return
name|gen_rtx_PARALLEL
argument_list|(
name|mode
argument_list|,
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|fp_reg
argument_list|,
name|gr_reg
argument_list|)
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return number of words, at the beginning of the argument, that must be    put in registers.  0 is the argument is entirely in registers or entirely    in memory.  */
end_comment

begin_function
name|int
name|ia64_function_arg_partial_nregs
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
name|cum
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|type
parameter_list|,
name|int
name|named
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
name|words
init|=
name|ia64_function_arg_words
argument_list|(
name|type
argument_list|,
name|mode
argument_list|)
decl_stmt|;
name|int
name|offset
init|=
name|ia64_function_arg_offset
argument_list|(
name|cum
argument_list|,
name|type
argument_list|,
name|words
argument_list|)
decl_stmt|;
comment|/* If all argument slots are used, then it must go on the stack.  */
if|if
condition|(
name|cum
operator|->
name|words
operator|+
name|offset
operator|>=
name|MAX_ARGUMENT_SLOTS
condition|)
return|return
literal|0
return|;
comment|/* It doesn't matter whether the argument goes in FR or GR regs.  If      it fits within the 8 argument slots, then it goes entirely in      registers.  If it extends past the last argument slot, then the rest      goes on the stack.  */
if|if
condition|(
name|words
operator|+
name|cum
operator|->
name|words
operator|+
name|offset
operator|<=
name|MAX_ARGUMENT_SLOTS
condition|)
return|return
literal|0
return|;
return|return
name|MAX_ARGUMENT_SLOTS
operator|-
name|cum
operator|->
name|words
operator|-
name|offset
return|;
block|}
end_function

begin_comment
comment|/* Update CUM to point after this argument.  This is patterned after    ia64_function_arg.  */
end_comment

begin_function
name|void
name|ia64_function_arg_advance
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
name|cum
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|type
parameter_list|,
name|int
name|named
parameter_list|)
block|{
name|int
name|words
init|=
name|ia64_function_arg_words
argument_list|(
name|type
argument_list|,
name|mode
argument_list|)
decl_stmt|;
name|int
name|offset
init|=
name|ia64_function_arg_offset
argument_list|(
name|cum
argument_list|,
name|type
argument_list|,
name|words
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|hfa_mode
init|=
name|VOIDmode
decl_stmt|;
comment|/* If all arg slots are already full, then there is nothing to do.  */
if|if
condition|(
name|cum
operator|->
name|words
operator|>=
name|MAX_ARGUMENT_SLOTS
condition|)
return|return;
name|cum
operator|->
name|words
operator|+=
name|words
operator|+
name|offset
expr_stmt|;
comment|/* Check for and handle homogeneous FP aggregates.  */
if|if
condition|(
name|type
condition|)
name|hfa_mode
operator|=
name|hfa_element_mode
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Unnamed prototyped hfas are passed as usual.  Named prototyped hfas      and unprototyped hfas are passed specially.  */
if|if
condition|(
name|hfa_mode
operator|!=
name|VOIDmode
operator|&&
operator|(
operator|!
name|cum
operator|->
name|prototype
operator|||
name|named
operator|)
condition|)
block|{
name|int
name|fp_regs
init|=
name|cum
operator|->
name|fp_regs
decl_stmt|;
comment|/* This is the original value of cum->words + offset.  */
name|int
name|int_regs
init|=
name|cum
operator|->
name|words
operator|-
name|words
decl_stmt|;
name|int
name|hfa_size
init|=
name|GET_MODE_SIZE
argument_list|(
name|hfa_mode
argument_list|)
decl_stmt|;
name|int
name|byte_size
decl_stmt|;
name|int
name|args_byte_size
decl_stmt|;
comment|/* If prototyped, pass it in FR regs then GR regs. 	 If not prototyped, pass it in both FR and GR regs.  	 If this is an SFmode aggregate, then it is possible to run out of 	 FR regs while GR regs are still left.  In that case, we pass the 	 remaining part in the GR regs.  */
comment|/* Fill the FP regs.  We do this always.  We stop if we reach the end 	 of the argument, the last FP register, or the last argument slot.  */
name|byte_size
operator|=
operator|(
operator|(
name|mode
operator|==
name|BLKmode
operator|)
condition|?
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
else|:
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|)
expr_stmt|;
name|args_byte_size
operator|=
name|int_regs
operator|*
name|UNITS_PER_WORD
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
operator|(
name|offset
operator|<
name|byte_size
operator|&&
name|fp_regs
operator|<
name|MAX_ARGUMENT_SLOTS
operator|&&
name|args_byte_size
operator|<
operator|(
name|MAX_ARGUMENT_SLOTS
operator|*
name|UNITS_PER_WORD
operator|)
operator|)
condition|;
control|)
block|{
name|offset
operator|+=
name|hfa_size
expr_stmt|;
name|args_byte_size
operator|+=
name|hfa_size
expr_stmt|;
name|fp_regs
operator|++
expr_stmt|;
block|}
name|cum
operator|->
name|fp_regs
operator|=
name|fp_regs
expr_stmt|;
block|}
comment|/* Integral and aggregates go in general registers.  If we have run out of      FR registers, then FP values must also go in general registers.  This can      happen when we have a SFmode HFA.  */
elseif|else
if|if
condition|(
operator|!
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
operator|||
name|cum
operator|->
name|fp_regs
operator|==
name|MAX_ARGUMENT_SLOTS
condition|)
name|cum
operator|->
name|int_regs
operator|=
name|cum
operator|->
name|words
expr_stmt|;
comment|/* If there is a prototype, then FP values go in a FR register when      named, and in a GR register when unnamed.  */
elseif|else
if|if
condition|(
name|cum
operator|->
name|prototype
condition|)
block|{
if|if
condition|(
operator|!
name|named
condition|)
name|cum
operator|->
name|int_regs
operator|=
name|cum
operator|->
name|words
expr_stmt|;
else|else
comment|/* ??? Complex types should not reach here.  */
name|cum
operator|->
name|fp_regs
operator|+=
operator|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_COMPLEX_FLOAT
condition|?
literal|2
else|:
literal|1
operator|)
expr_stmt|;
block|}
comment|/* If there is no prototype, then FP values go in both FR and GR      registers.  */
else|else
block|{
comment|/* ??? Complex types should not reach here.  */
name|cum
operator|->
name|fp_regs
operator|+=
operator|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_COMPLEX_FLOAT
condition|?
literal|2
else|:
literal|1
operator|)
expr_stmt|;
name|cum
operator|->
name|int_regs
operator|=
name|cum
operator|->
name|words
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Variable sized types are passed by reference.  */
end_comment

begin_comment
comment|/* ??? At present this is a GCC extension to the IA-64 ABI.  */
end_comment

begin_function
name|int
name|ia64_function_arg_pass_by_reference
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
name|cum
name|ATTRIBUTE_UNUSED
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|,
name|tree
name|type
parameter_list|,
name|int
name|named
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|type
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
return|;
block|}
end_function

begin_comment
comment|/* True if it is OK to do sibling call optimization for the specified    call expression EXP.  DECL will be the called function, or NULL if    this is an indirect call.  */
end_comment

begin_function
specifier|static
name|bool
name|ia64_function_ok_for_sibcall
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|exp
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* We can't perform a sibcall if the current function has the syscall_linkage      attribute.  */
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"syscall_linkage"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* We must always return with our current GP.  This means we can      only sibcall to functions defined in the current module.  */
return|return
name|decl
operator|&&
call|(
modifier|*
name|targetm
operator|.
name|binds_local_p
call|)
argument_list|(
name|decl
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Implement va_arg.  */
end_comment

begin_function
name|rtx
name|ia64_va_arg
parameter_list|(
name|tree
name|valist
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
comment|/* Variable sized types are passed by reference.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
name|rtx
name|addr
init|=
name|force_reg
argument_list|(
name|ptr_mode
argument_list|,
name|std_expand_builtin_va_arg
argument_list|(
name|valist
argument_list|,
name|build_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|POINTERS_EXTEND_UNSIGNED
name|addr
operator|=
name|convert_memory_address
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|gen_rtx_MEM
argument_list|(
name|ptr_mode
argument_list|,
name|addr
argument_list|)
return|;
block|}
comment|/* Aggregate arguments with alignment larger than 8 bytes start at      the next even boundary.  Integer and floating point arguments      do so if they are larger than 8 bytes, whether or not they are      also aligned larger than 8 bytes.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REAL_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|)
condition|?
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
operator|>
literal|8
else|:
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|>
literal|8
operator|*
name|BITS_PER_UNIT
condition|)
block|{
name|t
operator|=
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|valist
argument_list|)
argument_list|,
name|valist
argument_list|,
name|build_int_2
argument_list|(
literal|2
operator|*
name|UNITS_PER_WORD
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|t
argument_list|,
name|build_int_2
argument_list|(
operator|-
literal|2
operator|*
name|UNITS_PER_WORD
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|valist
argument_list|)
argument_list|,
name|valist
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|expand_expr
argument_list|(
name|t
argument_list|,
name|const0_rtx
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_NORMAL
argument_list|)
expr_stmt|;
block|}
return|return
name|std_expand_builtin_va_arg
argument_list|(
name|valist
argument_list|,
name|type
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if function return value returned in memory.  Return 0 if it is    in a register.  */
end_comment

begin_function
name|int
name|ia64_return_in_memory
parameter_list|(
name|tree
name|valtype
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|hfa_mode
decl_stmt|;
name|HOST_WIDE_INT
name|byte_size
decl_stmt|;
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|valtype
argument_list|)
expr_stmt|;
name|byte_size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|BLKmode
condition|)
block|{
name|byte_size
operator|=
name|int_size_in_bytes
argument_list|(
name|valtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|byte_size
operator|<
literal|0
condition|)
return|return
literal|1
return|;
block|}
comment|/* Hfa's with up to 8 elements are returned in the FP argument registers.  */
name|hfa_mode
operator|=
name|hfa_element_mode
argument_list|(
name|valtype
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|hfa_mode
operator|!=
name|VOIDmode
condition|)
block|{
name|int
name|hfa_size
init|=
name|GET_MODE_SIZE
argument_list|(
name|hfa_mode
argument_list|)
decl_stmt|;
if|if
condition|(
name|byte_size
operator|/
name|hfa_size
operator|>
name|MAX_ARGUMENT_SLOTS
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|byte_size
operator|>
name|UNITS_PER_WORD
operator|*
name|MAX_INT_RETURN_SLOTS
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return rtx for register that holds the function return value.  */
end_comment

begin_function
name|rtx
name|ia64_function_value
parameter_list|(
name|tree
name|valtype
parameter_list|,
name|tree
name|func
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|hfa_mode
decl_stmt|;
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|valtype
argument_list|)
expr_stmt|;
name|hfa_mode
operator|=
name|hfa_element_mode
argument_list|(
name|valtype
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|hfa_mode
operator|!=
name|VOIDmode
condition|)
block|{
name|rtx
name|loc
index|[
literal|8
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|hfa_size
decl_stmt|;
name|int
name|byte_size
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|hfa_size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|hfa_mode
argument_list|)
expr_stmt|;
name|byte_size
operator|=
operator|(
operator|(
name|mode
operator|==
name|BLKmode
operator|)
condition|?
name|int_size_in_bytes
argument_list|(
name|valtype
argument_list|)
else|:
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|)
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|offset
operator|<
name|byte_size
condition|;
name|i
operator|++
control|)
block|{
name|loc
index|[
name|i
index|]
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|hfa_mode
argument_list|,
name|FR_ARG_FIRST
operator|+
name|i
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|hfa_size
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|1
condition|)
return|return
name|XEXP
argument_list|(
name|loc
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
return|;
else|else
return|return
name|gen_rtx_PARALLEL
argument_list|(
name|mode
argument_list|,
name|gen_rtvec_v
argument_list|(
name|i
argument_list|,
name|loc
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|FLOAT_TYPE_P
argument_list|(
name|valtype
argument_list|)
operator|&&
name|mode
operator|!=
name|TFmode
operator|&&
name|mode
operator|!=
name|TCmode
condition|)
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|FR_ARG_FIRST
argument_list|)
return|;
else|else
block|{
if|if
condition|(
name|BYTES_BIG_ENDIAN
operator|&&
operator|(
name|mode
operator|==
name|BLKmode
operator|||
operator|(
name|valtype
operator|&&
name|AGGREGATE_TYPE_P
argument_list|(
name|valtype
argument_list|)
operator|)
operator|)
condition|)
block|{
name|rtx
name|loc
index|[
literal|8
index|]
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|int
name|bytesize
decl_stmt|;
name|int
name|i
decl_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
name|bytesize
operator|=
name|int_size_in_bytes
argument_list|(
name|valtype
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|offset
operator|<
name|bytesize
condition|;
name|i
operator|++
control|)
block|{
name|loc
index|[
name|i
index|]
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|GR_RET_FIRST
operator|+
name|i
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|UNITS_PER_WORD
expr_stmt|;
block|}
return|return
name|gen_rtx_PARALLEL
argument_list|(
name|mode
argument_list|,
name|gen_rtvec_v
argument_list|(
name|i
argument_list|,
name|loc
argument_list|)
argument_list|)
return|;
block|}
else|else
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|GR_RET_FIRST
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* This is called from dwarf2out.c via ASM_OUTPUT_DWARF_DTPREL.    We need to emit DTP-relative relocations.  */
end_comment

begin_function
name|void
name|ia64_output_dwarf_dtprel
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|int
name|size
parameter_list|,
name|rtx
name|x
parameter_list|)
block|{
if|if
condition|(
name|size
operator|!=
literal|8
condition|)
name|abort
argument_list|()
expr_stmt|;
name|fputs
argument_list|(
literal|"\tdata8.ua\t@dtprel("
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|")"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print a memory address as an operand to reference that memory location.  */
end_comment

begin_comment
comment|/* ??? Do we need this?  It gets used only for 'a' operands.  We could perhaps    also call this from ia64_print_operand for memory addresses.  */
end_comment

begin_function
name|void
name|ia64_print_operand_address
parameter_list|(
name|FILE
modifier|*
name|stream
name|ATTRIBUTE_UNUSED
parameter_list|,
name|rtx
name|address
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{ }
end_function

begin_comment
comment|/* Print an operand to an assembler instruction.    C	Swap and print a comparison operator.    D	Print an FP comparison operator.    E    Print 32 - constant, for SImode shifts as extract.    e    Print 64 - constant, for DImode rotates.    F	A floating point constant 0.0 emitted as f0, or 1.0 emitted as f1, or         a floating point register emitted normally.    I	Invert a predicate register by adding 1.    J    Select the proper predicate register for a condition.    j    Select the inverse predicate register for a condition.    O	Append .acq for volatile load.    P	Postincrement of a MEM.    Q	Append .rel for volatile store.    S	Shift amount for shladd instruction.    T	Print an 8-bit sign extended number (K) as a 32-bit unsigned number 	for Intel assembler.    U	Print an 8-bit sign extended number (K) as a 64-bit unsigned number 	for Intel assembler.    r	Print register name, or constant 0 as r0.  HP compatibility for 	Linux kernel.  */
end_comment

begin_function
name|void
name|ia64_print_operand
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|rtx
name|x
parameter_list|,
name|int
name|code
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
literal|0
case|:
comment|/* Handled below.  */
break|break;
case|case
literal|'C'
case|:
block|{
name|enum
name|rtx_code
name|c
init|=
name|swap_condition
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
name|fputs
argument_list|(
name|GET_RTX_NAME
argument_list|(
name|c
argument_list|)
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
literal|'D'
case|:
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|NE
case|:
name|str
operator|=
literal|"neq"
expr_stmt|;
break|break;
case|case
name|UNORDERED
case|:
name|str
operator|=
literal|"unord"
expr_stmt|;
break|break;
case|case
name|ORDERED
case|:
name|str
operator|=
literal|"ord"
expr_stmt|;
break|break;
default|default:
name|str
operator|=
name|GET_RTX_NAME
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|fputs
argument_list|(
name|str
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'E'
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
literal|32
operator|-
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'e'
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
literal|64
operator|-
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'F'
case|:
if|if
condition|(
name|x
operator|==
name|CONST0_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|str
operator|=
name|reg_names
index|[
name|FR_REG
argument_list|(
literal|0
argument_list|)
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|x
operator|==
name|CONST1_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|str
operator|=
name|reg_names
index|[
name|FR_REG
argument_list|(
literal|1
argument_list|)
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
name|str
operator|=
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
name|fputs
argument_list|(
name|str
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'I'
case|:
name|fputs
argument_list|(
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
operator|+
literal|1
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'J'
case|:
case|case
literal|'j'
case|:
block|{
name|unsigned
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|EQ
condition|)
name|regno
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|code
operator|==
literal|'j'
condition|)
name|regno
operator|^=
literal|1
expr_stmt|;
name|fputs
argument_list|(
name|reg_names
index|[
name|regno
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
literal|'O'
case|:
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
condition|)
name|fputs
argument_list|(
literal|".acq"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'P'
case|:
block|{
name|HOST_WIDE_INT
name|value
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
default|default:
return|return;
case|case
name|POST_MODIFY
case|:
name|x
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
condition|)
name|value
operator|=
name|INTVAL
argument_list|(
name|x
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|", %s"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
break|break;
case|case
name|POST_INC
case|:
name|value
operator|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|POST_DEC
case|:
name|value
operator|=
operator|-
operator|(
name|HOST_WIDE_INT
operator|)
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|", "
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
literal|'Q'
case|:
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
condition|)
name|fputs
argument_list|(
literal|".rel"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'S'
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|exact_log2
argument_list|(
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'T'
case|:
if|if
condition|(
operator|!
name|TARGET_GNU_AS
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0x%x"
argument_list|,
operator|(
name|int
operator|)
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
literal|'U'
case|:
if|if
condition|(
operator|!
name|TARGET_GNU_AS
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
specifier|const
name|char
modifier|*
name|prefix
init|=
literal|"0x"
decl_stmt|;
if|if
condition|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
literal|0x80000000
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0xffffffff"
argument_list|)
expr_stmt|;
name|prefix
operator|=
literal|""
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s%x"
argument_list|,
name|prefix
argument_list|,
operator|(
name|int
operator|)
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
literal|'r'
case|:
comment|/* If this operand is the constant zero, write it as register zero. 	 Any register, zero, or CONST_INT value is OK here.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
name|fputs
argument_list|(
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|x
operator|==
name|CONST0_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|fputs
argument_list|(
literal|"r0"
argument_list|,
name|file
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
condition|)
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
else|else
name|output_operand_lossage
argument_list|(
literal|"invalid %%r value"
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'+'
case|:
block|{
specifier|const
name|char
modifier|*
name|which
decl_stmt|;
comment|/* For conditional branches, returns or calls, substitute 	   sptk, dptk, dpnt, or spnt for %s.  */
name|x
operator|=
name|find_reg_note
argument_list|(
name|current_output_insn
argument_list|,
name|REG_BR_PROB
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
condition|)
block|{
name|int
name|pred_val
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Guess top and bottom 10% statically predicted.  */
if|if
condition|(
name|pred_val
operator|<
name|REG_BR_PROB_BASE
operator|/
literal|50
condition|)
name|which
operator|=
literal|".spnt"
expr_stmt|;
elseif|else
if|if
condition|(
name|pred_val
operator|<
name|REG_BR_PROB_BASE
operator|/
literal|2
condition|)
name|which
operator|=
literal|".dpnt"
expr_stmt|;
elseif|else
if|if
condition|(
name|pred_val
operator|<
name|REG_BR_PROB_BASE
operator|/
literal|100
operator|*
literal|98
condition|)
name|which
operator|=
literal|".dptk"
expr_stmt|;
else|else
name|which
operator|=
literal|".sptk"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|current_output_insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
name|which
operator|=
literal|".sptk"
expr_stmt|;
else|else
name|which
operator|=
literal|".dptk"
expr_stmt|;
name|fputs
argument_list|(
name|which
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
literal|','
case|:
name|x
operator|=
name|current_insn_predicate
expr_stmt|;
if|if
condition|(
name|x
condition|)
block|{
name|unsigned
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|EQ
condition|)
name|regno
operator|+=
literal|1
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"(%s) "
argument_list|,
name|reg_names
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
block|}
return|return;
default|default:
name|output_operand_lossage
argument_list|(
literal|"ia64_print_operand: unknown code"
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
comment|/* This happens for the spill/restore instructions.  */
case|case
name|POST_INC
case|:
case|case
name|POST_DEC
case|:
case|case
name|POST_MODIFY
case|:
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* ... fall through ...  */
case|case
name|REG
case|:
name|fputs
argument_list|(
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEM
case|:
block|{
name|rtx
name|addr
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
argument_list|)
operator|==
literal|'a'
condition|)
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"[%s]"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|addr
argument_list|)
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|output_addr_const
argument_list|(
name|file
argument_list|,
name|x
argument_list|)
expr_stmt|;
break|break;
block|}
return|return;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compute a (partial) cost for rtx X.  Return true if the complete    cost has been computed, and false if subexpressions should be    scanned.  In either case, *TOTAL contains the cost result.  */
end_comment

begin_comment
comment|/* ??? This is incomplete.  */
end_comment

begin_function
specifier|static
name|bool
name|ia64_rtx_costs
parameter_list|(
name|rtx
name|x
parameter_list|,
name|int
name|code
parameter_list|,
name|int
name|outer_code
parameter_list|,
name|int
modifier|*
name|total
parameter_list|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONST_INT
case|:
switch|switch
condition|(
name|outer_code
condition|)
block|{
case|case
name|SET
case|:
operator|*
name|total
operator|=
name|CONST_OK_FOR_J
argument_list|(
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
condition|?
literal|0
else|:
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|true
return|;
case|case
name|PLUS
case|:
if|if
condition|(
name|CONST_OK_FOR_I
argument_list|(
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
operator|*
name|total
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|CONST_OK_FOR_J
argument_list|(
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
operator|*
name|total
operator|=
literal|1
expr_stmt|;
else|else
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|true
return|;
default|default:
if|if
condition|(
name|CONST_OK_FOR_K
argument_list|(
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
operator|||
name|CONST_OK_FOR_L
argument_list|(
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
operator|*
name|total
operator|=
literal|0
expr_stmt|;
else|else
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
case|case
name|CONST_DOUBLE
case|:
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|true
return|;
case|case
name|CONST
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
expr_stmt|;
return|return
name|true
return|;
case|case
name|MULT
case|:
comment|/* For multiplies wider than HImode, we have to go to the FPU,          which normally involves copies.  Plus there's the latency          of the multiply itself, and the latency of the instructions to          transfer integer regs to FP regs.  */
comment|/* ??? Check for FP mode.  */
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|>
literal|2
condition|)
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|10
argument_list|)
expr_stmt|;
else|else
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
expr_stmt|;
return|return
name|true
return|;
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
case|case
name|ASHIFT
case|:
case|case
name|ASHIFTRT
case|:
case|case
name|LSHIFTRT
case|:
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|true
return|;
case|case
name|DIV
case|:
case|case
name|UDIV
case|:
case|case
name|MOD
case|:
case|case
name|UMOD
case|:
comment|/* We make divide expensive, so that divide-by-constant will be          optimized to a multiply.  */
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|60
argument_list|)
expr_stmt|;
return|return
name|true
return|;
default|default:
return|return
name|false
return|;
block|}
block|}
end_function

begin_comment
comment|/* Calculate the cost of moving data from a register in class FROM to    one in class TO, using MODE.  */
end_comment

begin_function
name|int
name|ia64_register_move_cost
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|enum
name|reg_class
name|from
parameter_list|,
name|enum
name|reg_class
name|to
parameter_list|)
block|{
comment|/* ADDL_REGS is the same as GR_REGS for movement purposes.  */
if|if
condition|(
name|to
operator|==
name|ADDL_REGS
condition|)
name|to
operator|=
name|GR_REGS
expr_stmt|;
if|if
condition|(
name|from
operator|==
name|ADDL_REGS
condition|)
name|from
operator|=
name|GR_REGS
expr_stmt|;
comment|/* All costs are symmetric, so reduce cases by putting the      lower number class as the destination.  */
if|if
condition|(
name|from
operator|<
name|to
condition|)
block|{
name|enum
name|reg_class
name|tmp
init|=
name|to
decl_stmt|;
name|to
operator|=
name|from
operator|,
name|from
operator|=
name|tmp
expr_stmt|;
block|}
comment|/* Moving from FR<->GR in XFmode must be more expensive than 2,      so that we get secondary memory reloads.  Between FR_REGS,      we have to make this at least as expensive as MEMORY_MOVE_COST      to avoid spectacularly poor register class preferencing.  */
if|if
condition|(
name|mode
operator|==
name|XFmode
condition|)
block|{
if|if
condition|(
name|to
operator|!=
name|GR_REGS
operator|||
name|from
operator|!=
name|GR_REGS
condition|)
return|return
name|MEMORY_MOVE_COST
argument_list|(
name|mode
argument_list|,
name|to
argument_list|,
literal|0
argument_list|)
return|;
else|else
return|return
literal|3
return|;
block|}
switch|switch
condition|(
name|to
condition|)
block|{
case|case
name|PR_REGS
case|:
comment|/* Moving between PR registers takes two insns.  */
if|if
condition|(
name|from
operator|==
name|PR_REGS
condition|)
return|return
literal|3
return|;
comment|/* Moving between PR and anything but GR is impossible.  */
if|if
condition|(
name|from
operator|!=
name|GR_REGS
condition|)
return|return
name|MEMORY_MOVE_COST
argument_list|(
name|mode
argument_list|,
name|to
argument_list|,
literal|0
argument_list|)
return|;
break|break;
case|case
name|BR_REGS
case|:
comment|/* Moving between BR and anything but GR is impossible.  */
if|if
condition|(
name|from
operator|!=
name|GR_REGS
operator|&&
name|from
operator|!=
name|GR_AND_BR_REGS
condition|)
return|return
name|MEMORY_MOVE_COST
argument_list|(
name|mode
argument_list|,
name|to
argument_list|,
literal|0
argument_list|)
return|;
break|break;
case|case
name|AR_I_REGS
case|:
case|case
name|AR_M_REGS
case|:
comment|/* Moving between AR and anything but GR is impossible.  */
if|if
condition|(
name|from
operator|!=
name|GR_REGS
condition|)
return|return
name|MEMORY_MOVE_COST
argument_list|(
name|mode
argument_list|,
name|to
argument_list|,
literal|0
argument_list|)
return|;
break|break;
case|case
name|GR_REGS
case|:
case|case
name|FR_REGS
case|:
case|case
name|GR_AND_FR_REGS
case|:
case|case
name|GR_AND_BR_REGS
case|:
case|case
name|ALL_REGS
case|:
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
literal|2
return|;
block|}
end_function

begin_comment
comment|/* This function returns the register class required for a secondary    register when copying between one of the registers in CLASS, and X,    using MODE.  A return value of NO_REGS means that no secondary register    is required.  */
end_comment

begin_function
name|enum
name|reg_class
name|ia64_secondary_reload_class
parameter_list|(
name|enum
name|reg_class
name|class
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|,
name|rtx
name|x
parameter_list|)
block|{
name|int
name|regno
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
condition|)
name|regno
operator|=
name|true_regnum
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|class
condition|)
block|{
case|case
name|BR_REGS
case|:
case|case
name|AR_M_REGS
case|:
case|case
name|AR_I_REGS
case|:
comment|/* ??? BR<->BR register copies can happen due to a bad gcse/cse/global 	 interaction.  We end up with two pseudos with overlapping lifetimes 	 both of which are equiv to the same constant, and both which need 	 to be in BR_REGS.  This seems to be a cse bug.  cse_basic_block_end 	 changes depending on the path length, which means the qty_first_reg 	 check in make_regs_eqv can give different answers at different times. 	 At some point I'll probably need a reload_indi pattern to handle 	 this.  	 We can also get GR_AND_FR_REGS to BR_REGS/AR_REGS copies, where we 	 wound up with a FP register from GR_AND_FR_REGS.  Extend that to all 	 non-general registers for good measure.  */
if|if
condition|(
name|regno
operator|>=
literal|0
operator|&&
operator|!
name|GENERAL_REGNO_P
argument_list|(
name|regno
argument_list|)
condition|)
return|return
name|GR_REGS
return|;
comment|/* This is needed if a pseudo used as a call_operand gets spilled to a 	 stack slot.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
return|return
name|GR_REGS
return|;
break|break;
case|case
name|FR_REGS
case|:
comment|/* Need to go through general registers to get to other class regs.  */
if|if
condition|(
name|regno
operator|>=
literal|0
operator|&&
operator|!
operator|(
name|FR_REGNO_P
argument_list|(
name|regno
argument_list|)
operator|||
name|GENERAL_REGNO_P
argument_list|(
name|regno
argument_list|)
operator|)
condition|)
return|return
name|GR_REGS
return|;
comment|/* This can happen when a paradoxical subreg is an operand to the 	 muldi3 pattern.  */
comment|/* ??? This shouldn't be necessary after instruction scheduling is 	 enabled, because paradoxical subregs are not accepted by 	 register_operand when INSN_SCHEDULING is defined.  Or alternatively, 	 stop the paradoxical subreg stupidity in the *_operand functions 	 in recog.c.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|SImode
operator|||
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|HImode
operator|||
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|QImode
operator|)
condition|)
return|return
name|GR_REGS
return|;
comment|/* This can happen because of the ior/and/etc patterns that accept FP 	 registers as operands.  If the third operand is a constant, then it 	 needs to be reloaded into a FP register.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|GR_REGS
return|;
comment|/* This can happen because of register elimination in a muldi3 insn. 	 E.g. `26107 * (unsigned long)&u'.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
condition|)
return|return
name|GR_REGS
return|;
break|break;
case|case
name|PR_REGS
case|:
comment|/* ??? This happens if we cse/gcse a BImode value across a call, 	 and the function has a nonlocal goto.  This is because global 	 does not allocate call crossing pseudos to hard registers when 	 current_function_has_nonlocal_goto is true.  This is relatively 	 common for C++ programs that use exceptions.  To reproduce, 	 return NO_REGS and compile libstdc++.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
return|return
name|GR_REGS
return|;
comment|/* This can happen when we take a BImode subreg of a DImode value, 	 and that DImode value winds up in some non-GR register.  */
if|if
condition|(
name|regno
operator|>=
literal|0
operator|&&
operator|!
name|GENERAL_REGNO_P
argument_list|(
name|regno
argument_list|)
operator|&&
operator|!
name|PR_REGNO_P
argument_list|(
name|regno
argument_list|)
condition|)
return|return
name|GR_REGS
return|;
break|break;
default|default:
break|break;
block|}
return|return
name|NO_REGS
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit text to declare externally defined variables and functions, because    the Intel assembler does not support undefined externals.  */
end_comment

begin_function
name|void
name|ia64_asm_output_external
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|tree
name|decl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|save_referenced
decl_stmt|;
comment|/* GNU as does not need anything here, but the HP linker does need      something for external functions.  */
if|if
condition|(
name|TARGET_GNU_AS
operator|&&
operator|(
operator|!
name|TARGET_HPUX_LD
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|||
name|strstr
argument_list|(
name|name
argument_list|,
literal|"__builtin_"
argument_list|)
operator|==
name|name
operator|)
condition|)
return|return;
comment|/* ??? The Intel assembler creates a reference that needs to be satisfied by      the linker when we do this, so we need to be careful not to do this for      builtin functions which have no library equivalent.  Unfortunately, we      can't tell here whether or not a function will actually be called by      expand_expr, so we pull in library functions even if we may not need      them later.  */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"__builtin_next_arg"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"alloca"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"__builtin_constant_p"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"__builtin_args_info"
argument_list|)
condition|)
return|return;
if|if
condition|(
name|TARGET_HPUX_LD
condition|)
name|ia64_hpux_add_extern_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* assemble_name will set TREE_SYMBOL_REFERENCED, so we must save and          restore it.  */
name|save_referenced
operator|=
name|TREE_SYMBOL_REFERENCED
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|ASM_OUTPUT_TYPE_DIRECTIVE
argument_list|(
name|file
argument_list|,
name|name
argument_list|,
literal|"function"
argument_list|)
expr_stmt|;
call|(
modifier|*
name|targetm
operator|.
name|asm_out
operator|.
name|globalize_label
call|)
argument_list|(
name|file
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|TREE_SYMBOL_REFERENCED
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
name|save_referenced
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Parse the -mfixed-range= option string.  */
end_comment

begin_function
specifier|static
name|void
name|fix_range
parameter_list|(
specifier|const
name|char
modifier|*
name|const_str
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|first
decl_stmt|,
name|last
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|,
modifier|*
name|dash
decl_stmt|,
modifier|*
name|comma
decl_stmt|;
comment|/* str must be of the form REG1'-'REG2{,REG1'-'REG} where REG1 and      REG2 are either register names or register numbers.  The effect      of this option is to mark the registers in the range from REG1 to      REG2 as ``fixed'' so they won't be used by the compiler.  This is      used, e.g., to ensure that kernel mode code doesn't use f32-f127.  */
name|i
operator|=
name|strlen
argument_list|(
name|const_str
argument_list|)
expr_stmt|;
name|str
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|str
argument_list|,
name|const_str
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|dash
operator|=
name|strchr
argument_list|(
name|str
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dash
condition|)
block|{
name|warning
argument_list|(
literal|"value of -mfixed-range must have form REG1-REG2"
argument_list|)
expr_stmt|;
return|return;
block|}
operator|*
name|dash
operator|=
literal|'\0'
expr_stmt|;
name|comma
operator|=
name|strchr
argument_list|(
name|dash
operator|+
literal|1
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|comma
condition|)
operator|*
name|comma
operator|=
literal|'\0'
expr_stmt|;
name|first
operator|=
name|decode_reg_name
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|first
operator|<
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"unknown register name: %s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
name|last
operator|=
name|decode_reg_name
argument_list|(
name|dash
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|last
operator|<
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"unknown register name: %s"
argument_list|,
name|dash
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
operator|*
name|dash
operator|=
literal|'-'
expr_stmt|;
if|if
condition|(
name|first
operator|>
name|last
condition|)
block|{
name|warning
argument_list|(
literal|"%s-%s is an empty range"
argument_list|,
name|str
argument_list|,
name|dash
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
name|first
init|;
name|i
operator|<=
name|last
condition|;
operator|++
name|i
control|)
name|fixed_regs
index|[
name|i
index|]
operator|=
name|call_used_regs
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|comma
condition|)
break|break;
operator|*
name|comma
operator|=
literal|','
expr_stmt|;
name|str
operator|=
name|comma
operator|+
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|machine_function
modifier|*
name|ia64_init_machine_status
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|ggc_alloc_cleared
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|machine_function
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Handle TARGET_OPTIONS switches.  */
end_comment

begin_function
name|void
name|ia64_override_options
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
struct|struct
name|pta
block|{
specifier|const
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
comment|/* processor name or nickname.  */
specifier|const
name|enum
name|processor_type
name|processor
decl_stmt|;
block|}
decl|const
name|processor_alias_table
index|[]
init|=
block|{
block|{
literal|"itanium"
block|,
name|PROCESSOR_ITANIUM
block|}
block|,
block|{
literal|"itanium1"
block|,
name|PROCESSOR_ITANIUM
block|}
block|,
block|{
literal|"merced"
block|,
name|PROCESSOR_ITANIUM
block|}
block|,
block|{
literal|"itanium2"
block|,
name|PROCESSOR_ITANIUM2
block|}
block|,
block|{
literal|"mckinley"
block|,
name|PROCESSOR_ITANIUM2
block|}
block|,     }
struct|;
name|int
specifier|const
name|pta_size
init|=
name|ARRAY_SIZE
argument_list|(
name|processor_alias_table
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|TARGET_AUTO_PIC
condition|)
name|target_flags
operator||=
name|MASK_CONST_GP
expr_stmt|;
if|if
condition|(
name|TARGET_INLINE_FLOAT_DIV_LAT
operator|&&
name|TARGET_INLINE_FLOAT_DIV_THR
condition|)
block|{
name|warning
argument_list|(
literal|"cannot optimize floating point division for both latency and throughput"
argument_list|)
expr_stmt|;
name|target_flags
operator|&=
operator|~
name|MASK_INLINE_FLOAT_DIV_THR
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_INLINE_INT_DIV_LAT
operator|&&
name|TARGET_INLINE_INT_DIV_THR
condition|)
block|{
name|warning
argument_list|(
literal|"cannot optimize integer division for both latency and throughput"
argument_list|)
expr_stmt|;
name|target_flags
operator|&=
operator|~
name|MASK_INLINE_INT_DIV_THR
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_INLINE_SQRT_LAT
operator|&&
name|TARGET_INLINE_SQRT_THR
condition|)
block|{
name|warning
argument_list|(
literal|"cannot optimize square root for both latency and throughput"
argument_list|)
expr_stmt|;
name|target_flags
operator|&=
operator|~
name|MASK_INLINE_SQRT_THR
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_INLINE_SQRT_LAT
condition|)
block|{
name|warning
argument_list|(
literal|"not yet implemented: latency-optimized inline square root"
argument_list|)
expr_stmt|;
name|target_flags
operator|&=
operator|~
name|MASK_INLINE_SQRT_LAT
expr_stmt|;
block|}
if|if
condition|(
name|ia64_fixed_range_string
condition|)
name|fix_range
argument_list|(
name|ia64_fixed_range_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|ia64_tls_size_string
condition|)
block|{
name|char
modifier|*
name|end
decl_stmt|;
name|unsigned
name|long
name|tmp
init|=
name|strtoul
argument_list|(
name|ia64_tls_size_string
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|end
operator|||
operator|(
name|tmp
operator|!=
literal|14
operator|&&
name|tmp
operator|!=
literal|22
operator|&&
name|tmp
operator|!=
literal|64
operator|)
condition|)
name|error
argument_list|(
literal|"bad value (%s) for -mtls-size= switch"
argument_list|,
name|ia64_tls_size_string
argument_list|)
expr_stmt|;
else|else
name|ia64_tls_size
operator|=
name|tmp
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ia64_tune_string
condition|)
name|ia64_tune_string
operator|=
literal|"itanium2"
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pta_size
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ia64_tune_string
argument_list|,
name|processor_alias_table
index|[
name|i
index|]
operator|.
name|name
argument_list|)
condition|)
block|{
name|ia64_tune
operator|=
name|processor_alias_table
index|[
name|i
index|]
operator|.
name|processor
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|pta_size
condition|)
name|error
argument_list|(
literal|"bad value (%s) for -tune= switch"
argument_list|,
name|ia64_tune_string
argument_list|)
expr_stmt|;
name|ia64_flag_schedule_insns2
operator|=
name|flag_schedule_insns_after_reload
expr_stmt|;
name|flag_schedule_insns_after_reload
operator|=
literal|0
expr_stmt|;
name|ia64_section_threshold
operator|=
name|g_switch_set
condition|?
name|g_switch_value
else|:
name|IA64_DEFAULT_GVALUE
expr_stmt|;
name|init_machine_status
operator|=
name|ia64_init_machine_status
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function_decl
specifier|static
name|enum
name|attr_itanium_class
name|ia64_safe_itanium_class
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|attr_type
name|ia64_safe_type
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|enum
name|attr_itanium_class
name|ia64_safe_itanium_class
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
if|if
condition|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|>=
literal|0
condition|)
return|return
name|get_attr_itanium_class
argument_list|(
name|insn
argument_list|)
return|;
else|else
return|return
name|ITANIUM_CLASS_UNKNOWN
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|attr_type
name|ia64_safe_type
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
if|if
condition|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|>=
literal|0
condition|)
return|return
name|get_attr_type
argument_list|(
name|insn
argument_list|)
return|;
else|else
return|return
name|TYPE_UNKNOWN
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The following collection of routines emit instruction group stop bits as    necessary to avoid dependencies.  */
end_comment

begin_comment
comment|/* Need to track some additional registers as far as serialization is    concerned so we can properly handle br.call and br.ret.  We could    make these registers visible to gcc, but since these registers are    never explicitly used in gcc generated code, it seems wasteful to    do so (plus it would make the call and return patterns needlessly    complex).  */
end_comment

begin_define
define|#
directive|define
name|REG_GP
value|(GR_REG (1))
end_define

begin_define
define|#
directive|define
name|REG_RP
value|(BR_REG (0))
end_define

begin_define
define|#
directive|define
name|REG_AR_CFM
value|(FIRST_PSEUDO_REGISTER + 1)
end_define

begin_comment
comment|/* This is used for volatile asms which may require a stop bit immediately    before and after them.  */
end_comment

begin_define
define|#
directive|define
name|REG_VOLATILE
value|(FIRST_PSEUDO_REGISTER + 2)
end_define

begin_define
define|#
directive|define
name|AR_UNAT_BIT_0
value|(FIRST_PSEUDO_REGISTER + 3)
end_define

begin_define
define|#
directive|define
name|NUM_REGS
value|(AR_UNAT_BIT_0 + 64)
end_define

begin_comment
comment|/* For each register, we keep track of how it has been written in the    current instruction group.     If a register is written unconditionally (no qualifying predicate),    WRITE_COUNT is set to 2 and FIRST_PRED is ignored.     If a register is written if its qualifying predicate P is true, we    set WRITE_COUNT to 1 and FIRST_PRED to P.  Later on, the same register    may be written again by the complement of P (P^1) and when this happens,    WRITE_COUNT gets set to 2.     The result of this is that whenever an insn attempts to write a register    whose WRITE_COUNT is two, we need to issue an insn group barrier first.     If a predicate register is written by a floating-point insn, we set    WRITTEN_BY_FP to true.     If a predicate register is written by an AND.ORCM we set WRITTEN_BY_AND    to true; if it was written by an OR.ANDCM we set WRITTEN_BY_OR to true.  */
end_comment

begin_struct
struct|struct
name|reg_write_state
block|{
name|unsigned
name|int
name|write_count
range|:
literal|2
decl_stmt|;
name|unsigned
name|int
name|first_pred
range|:
literal|16
decl_stmt|;
name|unsigned
name|int
name|written_by_fp
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|written_by_and
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|written_by_or
range|:
literal|1
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Cumulative info for the current instruction group.  */
end_comment

begin_decl_stmt
name|struct
name|reg_write_state
name|rws_sum
index|[
name|NUM_REGS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Info for the current instruction.  This gets copied to rws_sum after a    stop bit is emitted.  */
end_comment

begin_decl_stmt
name|struct
name|reg_write_state
name|rws_insn
index|[
name|NUM_REGS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indicates whether this is the first instruction after a stop bit,    in which case we don't need another stop bit.  Without this, we hit    the abort in ia64_variable_issue when scheduling an alloc.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|first_instruction
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Misc flags needed to compute RAW/WAW dependencies while we are traversing    RTL for one instruction.  */
end_comment

begin_struct
struct|struct
name|reg_flags
block|{
name|unsigned
name|int
name|is_write
range|:
literal|1
decl_stmt|;
comment|/* Is register being written?  */
name|unsigned
name|int
name|is_fp
range|:
literal|1
decl_stmt|;
comment|/* Is register used as part of an fp op?  */
name|unsigned
name|int
name|is_branch
range|:
literal|1
decl_stmt|;
comment|/* Is register used as part of a branch?  */
name|unsigned
name|int
name|is_and
range|:
literal|1
decl_stmt|;
comment|/* Is register used as part of and.orcm?  */
name|unsigned
name|int
name|is_or
range|:
literal|1
decl_stmt|;
comment|/* Is register used as part of or.andcm?  */
name|unsigned
name|int
name|is_sibcall
range|:
literal|1
decl_stmt|;
comment|/* Is this a sibling or normal call?  */
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|void
name|rws_update
parameter_list|(
name|struct
name|reg_write_state
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|reg_flags
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rws_access_regno
parameter_list|(
name|int
parameter_list|,
name|struct
name|reg_flags
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rws_access_reg
parameter_list|(
name|rtx
parameter_list|,
name|struct
name|reg_flags
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|update_set_flags
parameter_list|(
name|rtx
parameter_list|,
name|struct
name|reg_flags
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|rtx
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set_src_needs_barrier
parameter_list|(
name|rtx
parameter_list|,
name|struct
name|reg_flags
parameter_list|,
name|int
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rtx_needs_barrier
parameter_list|(
name|rtx
parameter_list|,
name|struct
name|reg_flags
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|init_insn_group_barriers
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|group_barrier_needed_p
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|safe_group_barrier_needed_p
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Update *RWS for REGNO, which is being written by the current instruction,    with predicate PRED, and associated register flags in FLAGS.  */
end_comment

begin_function
specifier|static
name|void
name|rws_update
parameter_list|(
name|struct
name|reg_write_state
modifier|*
name|rws
parameter_list|,
name|int
name|regno
parameter_list|,
name|struct
name|reg_flags
name|flags
parameter_list|,
name|int
name|pred
parameter_list|)
block|{
if|if
condition|(
name|pred
condition|)
name|rws
index|[
name|regno
index|]
operator|.
name|write_count
operator|++
expr_stmt|;
else|else
name|rws
index|[
name|regno
index|]
operator|.
name|write_count
operator|=
literal|2
expr_stmt|;
name|rws
index|[
name|regno
index|]
operator|.
name|written_by_fp
operator||=
name|flags
operator|.
name|is_fp
expr_stmt|;
comment|/* ??? Not tracking and/or across differing predicates.  */
name|rws
index|[
name|regno
index|]
operator|.
name|written_by_and
operator|=
name|flags
operator|.
name|is_and
expr_stmt|;
name|rws
index|[
name|regno
index|]
operator|.
name|written_by_or
operator|=
name|flags
operator|.
name|is_or
expr_stmt|;
name|rws
index|[
name|regno
index|]
operator|.
name|first_pred
operator|=
name|pred
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle an access to register REGNO of type FLAGS using predicate register    PRED.  Update rws_insn and rws_sum arrays.  Return 1 if this access creates    a dependency with an earlier instruction in the same group.  */
end_comment

begin_function
specifier|static
name|int
name|rws_access_regno
parameter_list|(
name|int
name|regno
parameter_list|,
name|struct
name|reg_flags
name|flags
parameter_list|,
name|int
name|pred
parameter_list|)
block|{
name|int
name|need_barrier
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|regno
operator|>=
name|NUM_REGS
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|PR_REGNO_P
argument_list|(
name|regno
argument_list|)
condition|)
name|flags
operator|.
name|is_and
operator|=
name|flags
operator|.
name|is_or
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flags
operator|.
name|is_write
condition|)
block|{
name|int
name|write_count
decl_stmt|;
comment|/* One insn writes same reg multiple times?  */
if|if
condition|(
name|rws_insn
index|[
name|regno
index|]
operator|.
name|write_count
operator|>
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Update info for current instruction.  */
name|rws_update
argument_list|(
name|rws_insn
argument_list|,
name|regno
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
name|write_count
operator|=
name|rws_sum
index|[
name|regno
index|]
operator|.
name|write_count
expr_stmt|;
switch|switch
condition|(
name|write_count
condition|)
block|{
case|case
literal|0
case|:
comment|/* The register has not been written yet.  */
name|rws_update
argument_list|(
name|rws_sum
argument_list|,
name|regno
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* The register has been written via a predicate.  If this is 	     not a complementary predicate, then we need a barrier.  */
comment|/* ??? This assumes that P and P+1 are always complementary 	     predicates for P even.  */
if|if
condition|(
name|flags
operator|.
name|is_and
operator|&&
name|rws_sum
index|[
name|regno
index|]
operator|.
name|written_by_and
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|.
name|is_or
operator|&&
name|rws_sum
index|[
name|regno
index|]
operator|.
name|written_by_or
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|(
name|rws_sum
index|[
name|regno
index|]
operator|.
name|first_pred
operator|^
literal|1
operator|)
operator|!=
name|pred
condition|)
name|need_barrier
operator|=
literal|1
expr_stmt|;
name|rws_update
argument_list|(
name|rws_sum
argument_list|,
name|regno
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* The register has been unconditionally written already.  We 	     need a barrier.  */
if|if
condition|(
name|flags
operator|.
name|is_and
operator|&&
name|rws_sum
index|[
name|regno
index|]
operator|.
name|written_by_and
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|.
name|is_or
operator|&&
name|rws_sum
index|[
name|regno
index|]
operator|.
name|written_by_or
condition|)
empty_stmt|;
else|else
name|need_barrier
operator|=
literal|1
expr_stmt|;
name|rws_sum
index|[
name|regno
index|]
operator|.
name|written_by_and
operator|=
name|flags
operator|.
name|is_and
expr_stmt|;
name|rws_sum
index|[
name|regno
index|]
operator|.
name|written_by_or
operator|=
name|flags
operator|.
name|is_or
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|flags
operator|.
name|is_branch
condition|)
block|{
comment|/* Branches have several RAW exceptions that allow to avoid 	     barriers.  */
if|if
condition|(
name|REGNO_REG_CLASS
argument_list|(
name|regno
argument_list|)
operator|==
name|BR_REGS
operator|||
name|regno
operator|==
name|AR_PFS_REGNUM
condition|)
comment|/* RAW dependencies on branch regs are permissible as long 	       as the writer is a non-branch instruction.  Since we 	       never generate code that uses a branch register written 	       by a branch instruction, handling this case is 	       easy.  */
return|return
literal|0
return|;
if|if
condition|(
name|REGNO_REG_CLASS
argument_list|(
name|regno
argument_list|)
operator|==
name|PR_REGS
operator|&&
operator|!
name|rws_sum
index|[
name|regno
index|]
operator|.
name|written_by_fp
condition|)
comment|/* The predicates of a branch are available within the 	       same insn group as long as the predicate was written by 	       something other than a floating-point instruction.  */
return|return
literal|0
return|;
block|}
if|if
condition|(
name|flags
operator|.
name|is_and
operator|&&
name|rws_sum
index|[
name|regno
index|]
operator|.
name|written_by_and
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|flags
operator|.
name|is_or
operator|&&
name|rws_sum
index|[
name|regno
index|]
operator|.
name|written_by_or
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|rws_sum
index|[
name|regno
index|]
operator|.
name|write_count
condition|)
block|{
case|case
literal|0
case|:
comment|/* The register has not been written yet.  */
break|break;
case|case
literal|1
case|:
comment|/* The register has been written via a predicate.  If this is 	     not a complementary predicate, then we need a barrier.  */
comment|/* ??? This assumes that P and P+1 are always complementary 	     predicates for P even.  */
if|if
condition|(
operator|(
name|rws_sum
index|[
name|regno
index|]
operator|.
name|first_pred
operator|^
literal|1
operator|)
operator|!=
name|pred
condition|)
name|need_barrier
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* The register has been unconditionally written already.  We 	     need a barrier.  */
name|need_barrier
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|need_barrier
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|rws_access_reg
parameter_list|(
name|rtx
name|reg
parameter_list|,
name|struct
name|reg_flags
name|flags
parameter_list|,
name|int
name|pred
parameter_list|)
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|reg
argument_list|)
decl_stmt|;
name|int
name|n
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|==
literal|1
condition|)
return|return
name|rws_access_regno
argument_list|(
name|regno
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
return|;
else|else
block|{
name|int
name|need_barrier
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
name|need_barrier
operator||=
name|rws_access_regno
argument_list|(
name|regno
operator|+
name|n
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
return|return
name|need_barrier
return|;
block|}
block|}
end_function

begin_comment
comment|/* Examine X, which is a SET rtx, and update the flags, the predicate, and    the condition, stored in *PFLAGS, *PPRED and *PCOND.  */
end_comment

begin_function
specifier|static
name|void
name|update_set_flags
parameter_list|(
name|rtx
name|x
parameter_list|,
name|struct
name|reg_flags
modifier|*
name|pflags
parameter_list|,
name|int
modifier|*
name|ppred
parameter_list|,
name|rtx
modifier|*
name|pcond
parameter_list|)
block|{
name|rtx
name|src
init|=
name|SET_SRC
argument_list|(
name|x
argument_list|)
decl_stmt|;
operator|*
name|pcond
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
condition|)
block|{
case|case
name|CALL
case|:
return|return;
case|case
name|IF_THEN_ELSE
case|:
if|if
condition|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|==
name|pc_rtx
condition|)
comment|/* X is a conditional branch.  */
return|return;
else|else
block|{
name|int
name|is_complemented
init|=
literal|0
decl_stmt|;
comment|/* X is a conditional move.  */
name|rtx
name|cond
init|=
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|EQ
condition|)
name|is_complemented
operator|=
literal|1
expr_stmt|;
name|cond
operator|=
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|cond
argument_list|)
operator|!=
name|REG
operator|&&
name|REGNO_REG_CLASS
argument_list|(
name|REGNO
argument_list|(
name|cond
argument_list|)
argument_list|)
operator|!=
name|PR_REGS
condition|)
name|abort
argument_list|()
expr_stmt|;
operator|*
name|pcond
operator|=
name|cond
expr_stmt|;
if|if
condition|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
operator|==
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|||
name|XEXP
argument_list|(
name|src
argument_list|,
literal|2
argument_list|)
operator|==
name|SET_DEST
argument_list|(
name|x
argument_list|)
condition|)
block|{
comment|/* X is a conditional move that conditionally writes the 		 destination.  */
comment|/* We need another complement in this case.  */
if|if
condition|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
operator|==
name|SET_DEST
argument_list|(
name|x
argument_list|)
condition|)
name|is_complemented
operator|=
operator|!
name|is_complemented
expr_stmt|;
operator|*
name|ppred
operator|=
name|REGNO
argument_list|(
name|cond
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_complemented
condition|)
operator|++
operator|*
name|ppred
expr_stmt|;
block|}
comment|/* ??? If this is a conditional write to the dest, then this 	     instruction does not actually read one source.  This probably 	     doesn't matter, because that source is also the dest.  */
comment|/* ??? Multiple writes to predicate registers are allowed 	     if they are all AND type compares, or if they are all OR 	     type compares.  We do not generate such instructions 	     currently.  */
block|}
comment|/* ... fall through ...  */
default|default:
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
argument_list|)
operator|==
literal|'<'
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
comment|/* Set pflags->is_fp to 1 so that we know we're dealing 	   with a floating point comparison when processing the 	   destination of the SET.  */
name|pflags
operator|->
name|is_fp
operator|=
literal|1
expr_stmt|;
comment|/* Discover if this is a parallel comparison.  We only handle 	 and.orcm and or.andcm at present, since we must retain a 	 strict inverse on the predicate pair.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|AND
condition|)
name|pflags
operator|->
name|is_and
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|IOR
condition|)
name|pflags
operator|->
name|is_or
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Subroutine of rtx_needs_barrier; this function determines whether the    source of a given SET rtx found in X needs a barrier.  FLAGS and PRED    are as in rtx_needs_barrier.  COND is an rtx that holds the condition    for this insn.  */
end_comment

begin_function
specifier|static
name|int
name|set_src_needs_barrier
parameter_list|(
name|rtx
name|x
parameter_list|,
name|struct
name|reg_flags
name|flags
parameter_list|,
name|int
name|pred
parameter_list|,
name|rtx
name|cond
parameter_list|)
block|{
name|int
name|need_barrier
init|=
literal|0
decl_stmt|;
name|rtx
name|dst
decl_stmt|;
name|rtx
name|src
init|=
name|SET_SRC
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|CALL
condition|)
comment|/* We don't need to worry about the result registers that        get written by subroutine call.  */
return|return
name|rtx_needs_barrier
argument_list|(
name|src
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
return|;
elseif|else
if|if
condition|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|==
name|pc_rtx
condition|)
block|{
comment|/* X is a conditional branch.  */
comment|/* ??? This seems redundant, as the caller sets this bit for 	 all JUMP_INSNs.  */
name|flags
operator|.
name|is_branch
operator|=
literal|1
expr_stmt|;
return|return
name|rtx_needs_barrier
argument_list|(
name|src
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
return|;
block|}
name|need_barrier
operator|=
name|rtx_needs_barrier
argument_list|(
name|src
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
comment|/* This instruction unconditionally uses a predicate register.  */
if|if
condition|(
name|cond
condition|)
name|need_barrier
operator||=
name|rws_access_reg
argument_list|(
name|cond
argument_list|,
name|flags
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dst
operator|=
name|SET_DEST
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|==
name|ZERO_EXTRACT
condition|)
block|{
name|need_barrier
operator||=
name|rtx_needs_barrier
argument_list|(
name|XEXP
argument_list|(
name|dst
argument_list|,
literal|1
argument_list|)
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
name|need_barrier
operator||=
name|rtx_needs_barrier
argument_list|(
name|XEXP
argument_list|(
name|dst
argument_list|,
literal|2
argument_list|)
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
name|dst
operator|=
name|XEXP
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|need_barrier
return|;
block|}
end_function

begin_comment
comment|/* Handle an access to rtx X of type FLAGS using predicate register    PRED.  Return 1 if this access creates a dependency with an earlier    instruction in the same group.  */
end_comment

begin_function
specifier|static
name|int
name|rtx_needs_barrier
parameter_list|(
name|rtx
name|x
parameter_list|,
name|struct
name|reg_flags
name|flags
parameter_list|,
name|int
name|pred
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|is_complemented
init|=
literal|0
decl_stmt|;
name|int
name|need_barrier
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|format_ptr
decl_stmt|;
name|struct
name|reg_flags
name|new_flags
decl_stmt|;
name|rtx
name|cond
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|x
condition|)
return|return
literal|0
return|;
name|new_flags
operator|=
name|flags
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|SET
case|:
name|update_set_flags
argument_list|(
name|x
argument_list|,
operator|&
name|new_flags
argument_list|,
operator|&
name|pred
argument_list|,
operator|&
name|cond
argument_list|)
expr_stmt|;
name|need_barrier
operator|=
name|set_src_needs_barrier
argument_list|(
name|x
argument_list|,
name|new_flags
argument_list|,
name|pred
argument_list|,
name|cond
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|CALL
condition|)
block|{
name|new_flags
operator|.
name|is_write
operator|=
literal|1
expr_stmt|;
name|need_barrier
operator||=
name|rtx_needs_barrier
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|new_flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CALL
case|:
name|new_flags
operator|.
name|is_write
operator|=
literal|0
expr_stmt|;
name|need_barrier
operator||=
name|rws_access_regno
argument_list|(
name|AR_EC_REGNUM
argument_list|,
name|new_flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
comment|/* Avoid multiple register writes, in case this is a pattern with 	 multiple CALL rtx.  This avoids an abort in rws_access_reg.  */
if|if
condition|(
operator|!
name|flags
operator|.
name|is_sibcall
operator|&&
operator|!
name|rws_insn
index|[
name|REG_AR_CFM
index|]
operator|.
name|write_count
condition|)
block|{
name|new_flags
operator|.
name|is_write
operator|=
literal|1
expr_stmt|;
name|need_barrier
operator||=
name|rws_access_regno
argument_list|(
name|REG_RP
argument_list|,
name|new_flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
name|need_barrier
operator||=
name|rws_access_regno
argument_list|(
name|AR_PFS_REGNUM
argument_list|,
name|new_flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
name|need_barrier
operator||=
name|rws_access_regno
argument_list|(
name|REG_AR_CFM
argument_list|,
name|new_flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|COND_EXEC
case|:
comment|/* X is a predicated instruction.  */
name|cond
operator|=
name|COND_EXEC_TEST
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|pred
condition|)
name|abort
argument_list|()
expr_stmt|;
name|need_barrier
operator|=
name|rtx_needs_barrier
argument_list|(
name|cond
argument_list|,
name|flags
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|EQ
condition|)
name|is_complemented
operator|=
literal|1
expr_stmt|;
name|cond
operator|=
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|cond
argument_list|)
operator|!=
name|REG
operator|&&
name|REGNO_REG_CLASS
argument_list|(
name|REGNO
argument_list|(
name|cond
argument_list|)
argument_list|)
operator|!=
name|PR_REGS
condition|)
name|abort
argument_list|()
expr_stmt|;
name|pred
operator|=
name|REGNO
argument_list|(
name|cond
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_complemented
condition|)
operator|++
name|pred
expr_stmt|;
name|need_barrier
operator||=
name|rtx_needs_barrier
argument_list|(
name|COND_EXEC_CODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
return|return
name|need_barrier
return|;
case|case
name|CLOBBER
case|:
case|case
name|USE
case|:
comment|/* Clobber& use are for earlier compiler-phases only.  */
break|break;
case|case
name|ASM_OPERANDS
case|:
case|case
name|ASM_INPUT
case|:
comment|/* We always emit stop bits for traditional asms.  We emit stop bits 	 for volatile extended asms if TARGET_VOL_ASM_STOP is true.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|ASM_OPERANDS
operator|||
operator|(
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
operator|&&
name|TARGET_VOL_ASM_STOP
operator|)
condition|)
block|{
comment|/* Avoid writing the register multiple times if we have multiple 	     asm outputs.  This avoids an abort in rws_access_reg.  */
if|if
condition|(
operator|!
name|rws_insn
index|[
name|REG_VOLATILE
index|]
operator|.
name|write_count
condition|)
block|{
name|new_flags
operator|.
name|is_write
operator|=
literal|1
expr_stmt|;
name|rws_access_regno
argument_list|(
name|REG_VOLATILE
argument_list|,
name|new_flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
comment|/* For all ASM_OPERANDS, we must traverse the vector of input operands. 	 We can not just fall through here since then we would be confused 	 by the ASM_INPUT rtx inside ASM_OPERANDS, which do not indicate 	 traditional asms unlike their normal usage.  */
for|for
control|(
name|i
operator|=
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|x
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
if|if
condition|(
name|rtx_needs_barrier
argument_list|(
name|ASM_OPERANDS_INPUT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
condition|)
name|need_barrier
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|PARALLEL
case|:
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|rtx
name|pat
init|=
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SET
condition|)
block|{
name|update_set_flags
argument_list|(
name|pat
argument_list|,
operator|&
name|new_flags
argument_list|,
operator|&
name|pred
argument_list|,
operator|&
name|cond
argument_list|)
expr_stmt|;
name|need_barrier
operator||=
name|set_src_needs_barrier
argument_list|(
name|pat
argument_list|,
name|new_flags
argument_list|,
name|pred
argument_list|,
name|cond
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|CALL
operator|||
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|ASM_OPERANDS
condition|)
name|need_barrier
operator||=
name|rtx_needs_barrier
argument_list|(
name|pat
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|!=
name|CLOBBER
operator|&&
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|!=
name|RETURN
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|rtx
name|pat
init|=
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SET
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|!=
name|CALL
condition|)
block|{
name|new_flags
operator|.
name|is_write
operator|=
literal|1
expr_stmt|;
name|need_barrier
operator||=
name|rtx_needs_barrier
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|,
name|new_flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|CLOBBER
operator|||
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|RETURN
condition|)
name|need_barrier
operator||=
name|rtx_needs_barrier
argument_list|(
name|pat
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SUBREG
case|:
name|x
operator|=
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* FALLTHRU */
case|case
name|REG
case|:
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|==
name|AR_UNAT_REGNUM
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
operator|++
name|i
control|)
name|need_barrier
operator||=
name|rws_access_regno
argument_list|(
name|AR_UNAT_BIT_0
operator|+
name|i
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
block|}
else|else
name|need_barrier
operator|=
name|rws_access_reg
argument_list|(
name|x
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEM
case|:
comment|/* Find the regs used in memory address computation.  */
name|new_flags
operator|.
name|is_write
operator|=
literal|0
expr_stmt|;
name|need_barrier
operator|=
name|rtx_needs_barrier
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|new_flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|CONST
case|:
break|break;
comment|/* Operators with side-effects.  */
case|case
name|POST_INC
case|:
case|case
name|POST_DEC
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
name|abort
argument_list|()
expr_stmt|;
name|new_flags
operator|.
name|is_write
operator|=
literal|0
expr_stmt|;
name|need_barrier
operator|=
name|rws_access_reg
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|new_flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
name|new_flags
operator|.
name|is_write
operator|=
literal|1
expr_stmt|;
name|need_barrier
operator||=
name|rws_access_reg
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|new_flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
break|break;
case|case
name|POST_MODIFY
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
name|abort
argument_list|()
expr_stmt|;
name|new_flags
operator|.
name|is_write
operator|=
literal|0
expr_stmt|;
name|need_barrier
operator|=
name|rws_access_reg
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|new_flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
name|need_barrier
operator||=
name|rtx_needs_barrier
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|new_flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
name|new_flags
operator|.
name|is_write
operator|=
literal|1
expr_stmt|;
name|need_barrier
operator||=
name|rws_access_reg
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|new_flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
break|break;
comment|/* Handle common unary and binary ops for efficiency.  */
case|case
name|COMPARE
case|:
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
case|case
name|MULT
case|:
case|case
name|DIV
case|:
case|case
name|MOD
case|:
case|case
name|UDIV
case|:
case|case
name|UMOD
case|:
case|case
name|AND
case|:
case|case
name|IOR
case|:
case|case
name|XOR
case|:
case|case
name|ASHIFT
case|:
case|case
name|ROTATE
case|:
case|case
name|ASHIFTRT
case|:
case|case
name|LSHIFTRT
case|:
case|case
name|ROTATERT
case|:
case|case
name|SMIN
case|:
case|case
name|SMAX
case|:
case|case
name|UMIN
case|:
case|case
name|UMAX
case|:
case|case
name|NE
case|:
case|case
name|EQ
case|:
case|case
name|GE
case|:
case|case
name|GT
case|:
case|case
name|LE
case|:
case|case
name|LT
case|:
case|case
name|GEU
case|:
case|case
name|GTU
case|:
case|case
name|LEU
case|:
case|case
name|LTU
case|:
name|need_barrier
operator|=
name|rtx_needs_barrier
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|new_flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
name|need_barrier
operator||=
name|rtx_needs_barrier
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|new_flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
break|break;
case|case
name|NEG
case|:
case|case
name|NOT
case|:
case|case
name|SIGN_EXTEND
case|:
case|case
name|ZERO_EXTEND
case|:
case|case
name|TRUNCATE
case|:
case|case
name|FLOAT_EXTEND
case|:
case|case
name|FLOAT_TRUNCATE
case|:
case|case
name|FLOAT
case|:
case|case
name|FIX
case|:
case|case
name|UNSIGNED_FLOAT
case|:
case|case
name|UNSIGNED_FIX
case|:
case|case
name|ABS
case|:
case|case
name|SQRT
case|:
case|case
name|FFS
case|:
case|case
name|POPCOUNT
case|:
name|need_barrier
operator|=
name|rtx_needs_barrier
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSPEC
case|:
switch|switch
condition|(
name|XINT
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|)
block|{
case|case
name|UNSPEC_LTOFF_DTPMOD
case|:
case|case
name|UNSPEC_LTOFF_DTPREL
case|:
case|case
name|UNSPEC_DTPREL
case|:
case|case
name|UNSPEC_LTOFF_TPREL
case|:
case|case
name|UNSPEC_TPREL
case|:
case|case
name|UNSPEC_PRED_REL_MUTEX
case|:
case|case
name|UNSPEC_PIC_CALL
case|:
case|case
name|UNSPEC_MF
case|:
case|case
name|UNSPEC_FETCHADD_ACQ
case|:
case|case
name|UNSPEC_BSP_VALUE
case|:
case|case
name|UNSPEC_FLUSHRS
case|:
case|case
name|UNSPEC_BUNDLE_SELECTOR
case|:
break|break;
case|case
name|UNSPEC_GR_SPILL
case|:
case|case
name|UNSPEC_GR_RESTORE
case|:
block|{
name|HOST_WIDE_INT
name|offset
init|=
name|INTVAL
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|bit
init|=
operator|(
name|offset
operator|>>
literal|3
operator|)
operator|&
literal|63
decl_stmt|;
name|need_barrier
operator|=
name|rtx_needs_barrier
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
name|new_flags
operator|.
name|is_write
operator|=
operator|(
name|XINT
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|==
literal|1
operator|)
expr_stmt|;
name|need_barrier
operator||=
name|rws_access_regno
argument_list|(
name|AR_UNAT_BIT_0
operator|+
name|bit
argument_list|,
name|new_flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|UNSPEC_FR_SPILL
case|:
case|case
name|UNSPEC_FR_RESTORE
case|:
case|case
name|UNSPEC_GETF_EXP
case|:
case|case
name|UNSPEC_SETF_EXP
case|:
case|case
name|UNSPEC_ADDP4
case|:
case|case
name|UNSPEC_FR_SQRT_RECIP_APPROX
case|:
name|need_barrier
operator|=
name|rtx_needs_barrier
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSPEC_FR_RECIP_APPROX
case|:
name|need_barrier
operator|=
name|rtx_needs_barrier
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
name|need_barrier
operator||=
name|rtx_needs_barrier
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNSPEC_CMPXCHG_ACQ
case|:
name|need_barrier
operator|=
name|rtx_needs_barrier
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
name|need_barrier
operator||=
name|rtx_needs_barrier
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|UNSPEC_VOLATILE
case|:
switch|switch
condition|(
name|XINT
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|)
block|{
case|case
name|UNSPECV_ALLOC
case|:
comment|/* Alloc must always be the first instruction of a group. 	     We force this by always returning true.  */
comment|/* ??? We might get better scheduling if we explicitly check for 	     input/local/output register dependencies, and modify the 	     scheduler so that alloc is always reordered to the start of 	     the current group.  We could then eliminate all of the 	     first_instruction code.  */
name|rws_access_regno
argument_list|(
name|AR_PFS_REGNUM
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
name|new_flags
operator|.
name|is_write
operator|=
literal|1
expr_stmt|;
name|rws_access_regno
argument_list|(
name|REG_AR_CFM
argument_list|,
name|new_flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|UNSPECV_SET_BSP
case|:
name|need_barrier
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|UNSPECV_BLOCKAGE
case|:
case|case
name|UNSPECV_INSN_GROUP_BARRIER
case|:
case|case
name|UNSPECV_BREAK
case|:
case|case
name|UNSPECV_PSAC_ALL
case|:
case|case
name|UNSPECV_PSAC_NORMAL
case|:
return|return
literal|0
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|RETURN
case|:
name|new_flags
operator|.
name|is_write
operator|=
literal|0
expr_stmt|;
name|need_barrier
operator|=
name|rws_access_regno
argument_list|(
name|REG_RP
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
name|need_barrier
operator||=
name|rws_access_regno
argument_list|(
name|AR_PFS_REGNUM
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
name|new_flags
operator|.
name|is_write
operator|=
literal|1
expr_stmt|;
name|need_barrier
operator||=
name|rws_access_regno
argument_list|(
name|AR_EC_REGNUM
argument_list|,
name|new_flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
name|need_barrier
operator||=
name|rws_access_regno
argument_list|(
name|REG_AR_CFM
argument_list|,
name|new_flags
argument_list|,
name|pred
argument_list|)
expr_stmt|;
break|break;
default|default:
name|format_ptr
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
switch|switch
condition|(
name|format_ptr
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'0'
case|:
comment|/* unused field */
case|case
literal|'i'
case|:
comment|/* integer */
case|case
literal|'n'
case|:
comment|/* note */
case|case
literal|'w'
case|:
comment|/* wide integer */
case|case
literal|'s'
case|:
comment|/* pointer to string */
case|case
literal|'S'
case|:
comment|/* optional pointer to string */
break|break;
case|case
literal|'e'
case|:
if|if
condition|(
name|rtx_needs_barrier
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
condition|)
name|need_barrier
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
operator|--
name|j
control|)
if|if
condition|(
name|rtx_needs_barrier
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|flags
argument_list|,
name|pred
argument_list|)
condition|)
name|need_barrier
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
block|}
return|return
name|need_barrier
return|;
block|}
end_function

begin_comment
comment|/* Clear out the state for group_barrier_needed_p at the start of a    sequence of insns.  */
end_comment

begin_function
specifier|static
name|void
name|init_insn_group_barriers
parameter_list|(
name|void
parameter_list|)
block|{
name|memset
argument_list|(
name|rws_sum
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|rws_sum
argument_list|)
argument_list|)
expr_stmt|;
name|first_instruction
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given the current state, recorded by previous calls to this function,    determine whether a group barrier (a stop bit) is necessary before INSN.    Return nonzero if so.  */
end_comment

begin_function
specifier|static
name|int
name|group_barrier_needed_p
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|pat
decl_stmt|;
name|int
name|need_barrier
init|=
literal|0
decl_stmt|;
name|struct
name|reg_flags
name|flags
decl_stmt|;
name|memset
argument_list|(
operator|&
name|flags
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|flags
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|NOTE
case|:
break|break;
case|case
name|BARRIER
case|:
comment|/* A barrier doesn't imply an instruction group boundary.  */
break|break;
case|case
name|CODE_LABEL
case|:
name|memset
argument_list|(
name|rws_insn
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|rws_insn
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|CALL_INSN
case|:
name|flags
operator|.
name|is_branch
operator|=
literal|1
expr_stmt|;
name|flags
operator|.
name|is_sibcall
operator|=
name|SIBLING_CALL_P
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|rws_insn
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|rws_insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Don't bundle a call following another call.  */
if|if
condition|(
operator|(
name|pat
operator|=
name|prev_active_insn
argument_list|(
name|insn
argument_list|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|need_barrier
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|need_barrier
operator|=
name|rtx_needs_barrier
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|flags
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|JUMP_INSN
case|:
name|flags
operator|.
name|is_branch
operator|=
literal|1
expr_stmt|;
comment|/* Don't bundle a jump following a call.  */
if|if
condition|(
operator|(
name|pat
operator|=
name|prev_active_insn
argument_list|(
name|insn
argument_list|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|need_barrier
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* FALLTHRU */
case|case
name|INSN
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
comment|/* Don't care about USE and CLOBBER "insns"---those are used to 	   indicate to the optimizer that it shouldn't get rid of 	   certain operations.  */
break|break;
name|pat
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Ug.  Hack hacks hacked elsewhere.  */
switch|switch
condition|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
condition|)
block|{
comment|/* We play dependency tricks with the epilogue in order 	     to get proper schedules.  Undo this for dv analysis.  */
case|case
name|CODE_FOR_epilogue_deallocate_stack
case|:
case|case
name|CODE_FOR_prologue_allocate_stack
case|:
name|pat
operator|=
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
comment|/* The pattern we use for br.cloop confuses the code above. 	     The second element of the vector is representative.  */
case|case
name|CODE_FOR_doloop_end_internal
case|:
name|pat
operator|=
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
comment|/* Doesn't generate code.  */
case|case
name|CODE_FOR_pred_rel_mutex
case|:
case|case
name|CODE_FOR_prologue_use
case|:
return|return
literal|0
return|;
default|default:
break|break;
block|}
name|memset
argument_list|(
name|rws_insn
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|rws_insn
argument_list|)
argument_list|)
expr_stmt|;
name|need_barrier
operator|=
name|rtx_needs_barrier
argument_list|(
name|pat
argument_list|,
name|flags
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Check to see if the previous instruction was a volatile 	 asm.  */
if|if
condition|(
operator|!
name|need_barrier
condition|)
name|need_barrier
operator|=
name|rws_access_regno
argument_list|(
name|REG_VOLATILE
argument_list|,
name|flags
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|first_instruction
operator|&&
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|ia64_safe_itanium_class
argument_list|(
name|insn
argument_list|)
operator|!=
name|ITANIUM_CLASS_IGNORE
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|CLOBBER
condition|)
block|{
name|need_barrier
operator|=
literal|0
expr_stmt|;
name|first_instruction
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|need_barrier
return|;
block|}
end_function

begin_comment
comment|/* Like group_barrier_needed_p, but do not clobber the current state.  */
end_comment

begin_function
specifier|static
name|int
name|safe_group_barrier_needed_p
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|struct
name|reg_write_state
name|rws_saved
index|[
name|NUM_REGS
index|]
decl_stmt|;
name|int
name|saved_first_instruction
decl_stmt|;
name|int
name|t
decl_stmt|;
name|memcpy
argument_list|(
name|rws_saved
argument_list|,
name|rws_sum
argument_list|,
name|NUM_REGS
operator|*
sizeof|sizeof
expr|*
name|rws_saved
argument_list|)
expr_stmt|;
name|saved_first_instruction
operator|=
name|first_instruction
expr_stmt|;
name|t
operator|=
name|group_barrier_needed_p
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|rws_sum
argument_list|,
name|rws_saved
argument_list|,
name|NUM_REGS
operator|*
sizeof|sizeof
expr|*
name|rws_saved
argument_list|)
expr_stmt|;
name|first_instruction
operator|=
name|saved_first_instruction
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Scan the current function and insert stop bits as necessary to    eliminate dependencies.  This function assumes that a final    instruction scheduling pass has been run which has already    inserted most of the necessary stop bits.  This function only    inserts new ones at basic block boundaries, since these are    invisible to the scheduler.  */
end_comment

begin_function
specifier|static
name|void
name|emit_insn_group_barriers
parameter_list|(
name|FILE
modifier|*
name|dump
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
name|rtx
name|last_label
init|=
literal|0
decl_stmt|;
name|int
name|insns_since_last_label
init|=
literal|0
decl_stmt|;
name|init_insn_group_barriers
argument_list|()
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
block|{
if|if
condition|(
name|insns_since_last_label
condition|)
name|last_label
operator|=
name|insn
expr_stmt|;
name|insns_since_last_label
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_BASIC_BLOCK
condition|)
block|{
if|if
condition|(
name|insns_since_last_label
condition|)
name|last_label
operator|=
name|insn
expr_stmt|;
name|insns_since_last_label
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|UNSPEC_VOLATILE
operator|&&
name|XINT
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPECV_INSN_GROUP_BARRIER
condition|)
block|{
name|init_insn_group_barriers
argument_list|()
expr_stmt|;
name|last_label
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|insns_since_last_label
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|group_barrier_needed_p
argument_list|(
name|insn
argument_list|)
condition|)
block|{
if|if
condition|(
name|last_label
condition|)
block|{
if|if
condition|(
name|dump
condition|)
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"Emitting stop before label %d\n"
argument_list|,
name|INSN_UID
argument_list|(
name|last_label
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn_before
argument_list|(
name|gen_insn_group_barrier
argument_list|(
name|GEN_INT
argument_list|(
literal|3
argument_list|)
argument_list|)
argument_list|,
name|last_label
argument_list|)
expr_stmt|;
name|insn
operator|=
name|last_label
expr_stmt|;
name|init_insn_group_barriers
argument_list|()
expr_stmt|;
name|last_label
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Like emit_insn_group_barriers, but run if no final scheduling pass was run.    This function has to emit all necessary group barriers.  */
end_comment

begin_function
specifier|static
name|void
name|emit_all_insn_group_barriers
parameter_list|(
name|FILE
modifier|*
name|dump
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
name|init_insn_group_barriers
argument_list|()
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|BARRIER
condition|)
block|{
name|rtx
name|last
init|=
name|prev_active_insn
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|last
condition|)
continue|continue;
if|if
condition|(
name|GET_CODE
argument_list|(
name|last
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|last
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
condition|)
name|last
operator|=
name|prev_active_insn
argument_list|(
name|last
argument_list|)
expr_stmt|;
if|if
condition|(
name|recog_memoized
argument_list|(
name|last
argument_list|)
operator|!=
name|CODE_FOR_insn_group_barrier
condition|)
name|emit_insn_after
argument_list|(
name|gen_insn_group_barrier
argument_list|(
name|GEN_INT
argument_list|(
literal|3
argument_list|)
argument_list|)
argument_list|,
name|last
argument_list|)
expr_stmt|;
name|init_insn_group_barriers
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
if|if
condition|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_FOR_insn_group_barrier
condition|)
name|init_insn_group_barriers
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|group_barrier_needed_p
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|emit_insn_before
argument_list|(
name|gen_insn_group_barrier
argument_list|(
name|GEN_INT
argument_list|(
literal|3
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|init_insn_group_barriers
argument_list|()
expr_stmt|;
name|group_barrier_needed_p
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_function_decl
specifier|static
name|int
name|errata_find_address_regs
parameter_list|(
name|rtx
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|errata_emit_nops
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fixup_errata
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* This structure is used to track some details about the previous insns    groups so we can determine if it may be necessary to insert NOPs to    workaround hardware errata.  */
end_comment

begin_struct
specifier|static
struct|struct
name|group
block|{
name|HARD_REG_SET
name|p_reg_set
decl_stmt|;
name|HARD_REG_SET
name|gr_reg_conditionally_set
decl_stmt|;
block|}
name|last_group
index|[
literal|2
index|]
struct|;
end_struct

begin_comment
comment|/* Index into the last_group array.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|group_idx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Called through for_each_rtx; determines if a hard register that was    conditionally set in the previous group is used as an address register.    It ensures that for_each_rtx returns 1 in that case.  */
end_comment

begin_function
specifier|static
name|int
name|errata_find_address_regs
parameter_list|(
name|rtx
modifier|*
name|xp
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|rtx
name|x
init|=
operator|*
name|xp
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM
condition|)
return|return
literal|0
return|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|POST_MODIFY
condition|)
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
block|{
name|struct
name|group
modifier|*
name|prev_group
init|=
name|last_group
operator|+
operator|(
name|group_idx
operator|^
literal|1
operator|)
decl_stmt|;
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|prev_group
operator|->
name|gr_reg_conditionally_set
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Called for each insn; this function keeps track of the state in    last_group and emits additional NOPs if necessary to work around    an Itanium A/B step erratum.  */
end_comment

begin_function
specifier|static
name|void
name|errata_emit_nops
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|struct
name|group
modifier|*
name|this_group
init|=
name|last_group
operator|+
name|group_idx
decl_stmt|;
name|struct
name|group
modifier|*
name|prev_group
init|=
name|last_group
operator|+
operator|(
name|group_idx
operator|^
literal|1
operator|)
decl_stmt|;
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|cond
init|=
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|COND_EXEC
condition|?
name|COND_EXEC_TEST
argument_list|(
name|pat
argument_list|)
else|:
literal|0
decl_stmt|;
name|rtx
name|real_pat
init|=
name|cond
condition|?
name|COND_EXEC_CODE
argument_list|(
name|pat
argument_list|)
else|:
name|pat
decl_stmt|;
name|enum
name|attr_type
name|type
decl_stmt|;
name|rtx
name|set
init|=
name|real_pat
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|real_pat
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|real_pat
argument_list|)
operator|==
name|CLOBBER
operator|||
name|GET_CODE
argument_list|(
name|real_pat
argument_list|)
operator|==
name|ASM_INPUT
operator|||
name|GET_CODE
argument_list|(
name|real_pat
argument_list|)
operator|==
name|ADDR_VEC
operator|||
name|GET_CODE
argument_list|(
name|real_pat
argument_list|)
operator|==
name|ADDR_DIFF_VEC
operator|||
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
return|return;
comment|/* single_set doesn't work for COND_EXEC insns, so we have to duplicate      parts of it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|set
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|i
decl_stmt|;
name|set
operator|=
name|XVECEXP
argument_list|(
name|real_pat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|real_pat
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|real_pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|!=
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|real_pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|!=
name|CLOBBER
condition|)
block|{
name|set
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|set
operator|&&
name|GET_CODE
argument_list|(
name|set
argument_list|)
operator|!=
name|SET
condition|)
name|set
operator|=
literal|0
expr_stmt|;
name|type
operator|=
name|get_attr_type
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|TYPE_F
operator|&&
name|set
operator|&&
name|REG_P
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|&&
name|PR_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|)
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|this_group
operator|->
name|p_reg_set
argument_list|,
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|==
name|TYPE_M
operator|||
name|type
operator|==
name|TYPE_A
operator|)
operator|&&
name|cond
operator|&&
name|set
operator|&&
name|REG_P
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|!=
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|!=
name|MINUS
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|!=
name|ASHIFT
operator|||
operator|!
name|shladd_operand
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|VOIDmode
argument_list|)
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|!=
name|MEM
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|POST_MODIFY
operator|)
operator|&&
name|GENERAL_REGNO_P
argument_list|(
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|cond
argument_list|)
argument_list|)
operator|!=
literal|'<'
operator|||
operator|!
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|prev_group
operator|->
name|p_reg_set
argument_list|,
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|this_group
operator|->
name|gr_reg_conditionally_set
argument_list|,
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|for_each_rtx
argument_list|(
operator|&
name|real_pat
argument_list|,
name|errata_find_address_regs
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|emit_insn_before
argument_list|(
name|gen_insn_group_barrier
argument_list|(
name|GEN_INT
argument_list|(
literal|3
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|emit_insn_before
argument_list|(
name|gen_nop
argument_list|()
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|emit_insn_before
argument_list|(
name|gen_insn_group_barrier
argument_list|(
name|GEN_INT
argument_list|(
literal|3
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|group_idx
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|last_group
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|last_group
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Emit extra nops if they are required to work around hardware errata.  */
end_comment

begin_function
specifier|static
name|void
name|fixup_errata
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
operator|!
name|TARGET_B_STEP
condition|)
return|return;
name|group_idx
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|last_group
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|last_group
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|ia64_safe_type
argument_list|(
name|insn
argument_list|)
operator|==
name|TYPE_S
condition|)
block|{
name|group_idx
operator|^=
literal|1
expr_stmt|;
name|memset
argument_list|(
name|last_group
operator|+
name|group_idx
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|last_group
index|[
name|group_idx
index|]
argument_list|)
expr_stmt|;
block|}
else|else
name|errata_emit_nops
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Instruction scheduling support.  */
end_comment

begin_define
define|#
directive|define
name|NR_BUNDLES
value|10
end_define

begin_comment
comment|/* A list of names of all available bundles.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|bundle_name
index|[
name|NR_BUNDLES
index|]
init|=
block|{
literal|".mii"
block|,
literal|".mmi"
block|,
literal|".mfi"
block|,
literal|".mmf"
block|,
if|#
directive|if
name|NR_BUNDLES
operator|==
literal|10
literal|".bbb"
block|,
literal|".mbb"
block|,
endif|#
directive|endif
literal|".mib"
block|,
literal|".mmb"
block|,
literal|".mfb"
block|,
literal|".mlx"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we should insert stop bits into the schedule.  */
end_comment

begin_decl_stmt
name|int
name|ia64_final_schedule
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Codes of the corresponding quieryied units: */
end_comment

begin_decl_stmt
specifier|static
name|int
name|_0mii_
decl_stmt|,
name|_0mmi_
decl_stmt|,
name|_0mfi_
decl_stmt|,
name|_0mmf_
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|_0bbb_
decl_stmt|,
name|_0mbb_
decl_stmt|,
name|_0mib_
decl_stmt|,
name|_0mmb_
decl_stmt|,
name|_0mfb_
decl_stmt|,
name|_0mlx_
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|_1mii_
decl_stmt|,
name|_1mmi_
decl_stmt|,
name|_1mfi_
decl_stmt|,
name|_1mmf_
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|_1bbb_
decl_stmt|,
name|_1mbb_
decl_stmt|,
name|_1mib_
decl_stmt|,
name|_1mmb_
decl_stmt|,
name|_1mfb_
decl_stmt|,
name|_1mlx_
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pos_1
decl_stmt|,
name|pos_2
decl_stmt|,
name|pos_3
decl_stmt|,
name|pos_4
decl_stmt|,
name|pos_5
decl_stmt|,
name|pos_6
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following variable value is an insn group barrier.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|dfa_stop_insn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following variable value is the last issued insn.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|last_scheduled_insn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following variable value is size of the DFA state.  */
end_comment

begin_decl_stmt
specifier|static
name|size_t
name|dfa_state_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following variable value is pointer to a DFA state used as    temporary variable.  */
end_comment

begin_decl_stmt
specifier|static
name|state_t
name|temp_dfa_state
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following variable value is DFA state after issuing the last    insn.  */
end_comment

begin_decl_stmt
specifier|static
name|state_t
name|prev_cycle_state
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following array element values are TRUE if the corresponding    insn requires to add stop bits before it.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|stops_p
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following variable is used to set up the mentioned above array.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|stop_before_p
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following variable value is length of the arrays `clocks' and    `add_cycles'. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|clocks_length
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following array element values are cycles on which the    corresponding insn will be issued.  The array is used only for    Itanium1.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|clocks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following array element values are numbers of cycles should be    added to improve insn scheduling for MM_insns for Itanium1.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|add_cycles
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|rtx
name|ia64_single_set
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ia64_emit_insn_before
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Map a bundle number to its pseudo-op.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|get_bundle_name
parameter_list|(
name|int
name|b
parameter_list|)
block|{
return|return
name|bundle_name
index|[
name|b
index|]
return|;
block|}
end_function

begin_comment
comment|/* Return the maximum number of instructions a cpu can issue.  */
end_comment

begin_function
specifier|static
name|int
name|ia64_issue_rate
parameter_list|(
name|void
parameter_list|)
block|{
return|return
literal|6
return|;
block|}
end_function

begin_comment
comment|/* Helper function - like single_set, but look inside COND_EXEC.  */
end_comment

begin_function
specifier|static
name|rtx
name|ia64_single_set
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|x
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|,
name|ret
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|COND_EXEC
condition|)
name|x
operator|=
name|COND_EXEC_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SET
condition|)
return|return
name|x
return|;
comment|/* Special case here prologue_allocate_stack and epilogue_deallocate_stack.      Although they are not classical single set, the second set is there just      to protect it from moving past FP-relative stack accesses.  */
switch|switch
condition|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|CODE_FOR_prologue_allocate_stack
case|:
case|case
name|CODE_FOR_epilogue_deallocate_stack
case|:
name|ret
operator|=
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ret
operator|=
name|single_set_2
argument_list|(
name|insn
argument_list|,
name|x
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Adjust the cost of a scheduling dependency.  Return the new cost of    a dependency LINK or INSN on DEP_INSN.  COST is the current cost.  */
end_comment

begin_function
specifier|static
name|int
name|ia64_adjust_cost
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|link
parameter_list|,
name|rtx
name|dep_insn
parameter_list|,
name|int
name|cost
parameter_list|)
block|{
name|enum
name|attr_itanium_class
name|dep_class
decl_stmt|;
name|enum
name|attr_itanium_class
name|insn_class
decl_stmt|;
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|!=
name|REG_DEP_OUTPUT
condition|)
return|return
name|cost
return|;
name|insn_class
operator|=
name|ia64_safe_itanium_class
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|dep_class
operator|=
name|ia64_safe_itanium_class
argument_list|(
name|dep_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|dep_class
operator|==
name|ITANIUM_CLASS_ST
operator|||
name|dep_class
operator|==
name|ITANIUM_CLASS_STF
operator|||
name|insn_class
operator|==
name|ITANIUM_CLASS_ST
operator|||
name|insn_class
operator|==
name|ITANIUM_CLASS_STF
condition|)
return|return
literal|0
return|;
return|return
name|cost
return|;
block|}
end_function

begin_comment
comment|/* Like emit_insn_before, but skip cycle_display notes.    ??? When cycle display notes are implemented, update this.  */
end_comment

begin_function
specifier|static
name|void
name|ia64_emit_insn_before
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|before
parameter_list|)
block|{
name|emit_insn_before
argument_list|(
name|insn
argument_list|,
name|before
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The following function marks insns who produce addresses for load    and store insns.  Such insns will be placed into M slots because it    decrease latency time for Itanium1 (see function    `ia64_produce_address_p' and the DFA descriptions).  */
end_comment

begin_function
specifier|static
name|void
name|ia64_dependencies_evaluation_hook
parameter_list|(
name|rtx
name|head
parameter_list|,
name|rtx
name|tail
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|,
name|link
decl_stmt|,
name|next
decl_stmt|,
name|next_tail
decl_stmt|;
name|next_tail
operator|=
name|NEXT_INSN
argument_list|(
name|tail
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|head
init|;
name|insn
operator|!=
name|next_tail
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
name|insn
operator|->
name|call
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|head
init|;
name|insn
operator|!=
name|next_tail
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|ia64_safe_itanium_class
argument_list|(
name|insn
argument_list|)
operator|==
name|ITANIUM_CLASS_IALU
condition|)
block|{
for|for
control|(
name|link
operator|=
name|INSN_DEPEND
argument_list|(
name|insn
argument_list|)
init|;
name|link
operator|!=
literal|0
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|next
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ia64_safe_itanium_class
argument_list|(
name|next
argument_list|)
operator|==
name|ITANIUM_CLASS_ST
operator|||
name|ia64_safe_itanium_class
argument_list|(
name|next
argument_list|)
operator|==
name|ITANIUM_CLASS_STF
operator|)
operator|&&
name|ia64_st_address_bypass_p
argument_list|(
name|insn
argument_list|,
name|next
argument_list|)
condition|)
break|break;
elseif|else
if|if
condition|(
operator|(
name|ia64_safe_itanium_class
argument_list|(
name|next
argument_list|)
operator|==
name|ITANIUM_CLASS_LD
operator|||
name|ia64_safe_itanium_class
argument_list|(
name|next
argument_list|)
operator|==
name|ITANIUM_CLASS_FLD
operator|)
operator|&&
name|ia64_ld_address_bypass_p
argument_list|(
name|insn
argument_list|,
name|next
argument_list|)
condition|)
break|break;
block|}
name|insn
operator|->
name|call
operator|=
name|link
operator|!=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* We're beginning a new block.  Initialize data structures as necessary.  */
end_comment

begin_function
specifier|static
name|void
name|ia64_sched_init
parameter_list|(
name|FILE
modifier|*
name|dump
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|sched_verbose
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|max_ready
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
name|reload_completed
condition|)
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|current_sched_info
operator|->
name|prev_head
argument_list|)
init|;
name|insn
operator|!=
name|current_sched_info
operator|->
name|next_tail
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|SCHED_GROUP_P
argument_list|(
name|insn
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|last_scheduled_insn
operator|=
name|NULL_RTX
expr_stmt|;
name|init_insn_group_barriers
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We are about to being issuing insns for this clock cycle.    Override the default sort algorithm to better slot instructions.  */
end_comment

begin_function
specifier|static
name|int
name|ia64_dfa_sched_reorder
parameter_list|(
name|FILE
modifier|*
name|dump
parameter_list|,
name|int
name|sched_verbose
parameter_list|,
name|rtx
modifier|*
name|ready
parameter_list|,
name|int
modifier|*
name|pn_ready
parameter_list|,
name|int
name|clock_var
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|reorder_type
parameter_list|)
block|{
name|int
name|n_asms
decl_stmt|;
name|int
name|n_ready
init|=
operator|*
name|pn_ready
decl_stmt|;
name|rtx
modifier|*
name|e_ready
init|=
name|ready
operator|+
name|n_ready
decl_stmt|;
name|rtx
modifier|*
name|insnp
decl_stmt|;
if|if
condition|(
name|sched_verbose
condition|)
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"// ia64_dfa_sched_reorder (type %d):\n"
argument_list|,
name|reorder_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|reorder_type
operator|==
literal|0
condition|)
block|{
comment|/* First, move all USEs, CLOBBERs and other crud out of the way.  */
name|n_asms
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|insnp
operator|=
name|ready
init|;
name|insnp
operator|<
name|e_ready
condition|;
name|insnp
operator|++
control|)
if|if
condition|(
name|insnp
operator|<
name|e_ready
condition|)
block|{
name|rtx
name|insn
init|=
operator|*
name|insnp
decl_stmt|;
name|enum
name|attr_type
name|t
init|=
name|ia64_safe_type
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|TYPE_UNKNOWN
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ASM_INPUT
operator|||
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|rtx
name|lowest
init|=
name|ready
index|[
name|n_asms
index|]
decl_stmt|;
name|ready
index|[
name|n_asms
index|]
operator|=
name|insn
expr_stmt|;
operator|*
name|insnp
operator|=
name|lowest
expr_stmt|;
name|n_asms
operator|++
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|highest
init|=
name|ready
index|[
name|n_ready
operator|-
literal|1
index|]
decl_stmt|;
name|ready
index|[
name|n_ready
operator|-
literal|1
index|]
operator|=
name|insn
expr_stmt|;
operator|*
name|insnp
operator|=
name|highest
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
block|}
if|if
condition|(
name|n_asms
operator|<
name|n_ready
condition|)
block|{
comment|/* Some normal insns to process.  Skip the asms.  */
name|ready
operator|+=
name|n_asms
expr_stmt|;
name|n_ready
operator|-=
name|n_asms
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n_ready
operator|>
literal|0
condition|)
return|return
literal|1
return|;
block|}
if|if
condition|(
name|ia64_final_schedule
condition|)
block|{
name|int
name|deleted
init|=
literal|0
decl_stmt|;
name|int
name|nr_need_stop
init|=
literal|0
decl_stmt|;
for|for
control|(
name|insnp
operator|=
name|ready
init|;
name|insnp
operator|<
name|e_ready
condition|;
name|insnp
operator|++
control|)
if|if
condition|(
name|safe_group_barrier_needed_p
argument_list|(
operator|*
name|insnp
argument_list|)
condition|)
name|nr_need_stop
operator|++
expr_stmt|;
if|if
condition|(
name|reorder_type
operator|==
literal|1
operator|&&
name|n_ready
operator|==
name|nr_need_stop
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|reorder_type
operator|==
literal|0
condition|)
return|return
literal|1
return|;
name|insnp
operator|=
name|e_ready
expr_stmt|;
comment|/* Move down everything that needs a stop bit, preserving 	 relative order.  */
while|while
condition|(
name|insnp
operator|--
operator|>
name|ready
operator|+
name|deleted
condition|)
while|while
condition|(
name|insnp
operator|>=
name|ready
operator|+
name|deleted
condition|)
block|{
name|rtx
name|insn
init|=
operator|*
name|insnp
decl_stmt|;
if|if
condition|(
operator|!
name|safe_group_barrier_needed_p
argument_list|(
name|insn
argument_list|)
condition|)
break|break;
name|memmove
argument_list|(
name|ready
operator|+
literal|1
argument_list|,
name|ready
argument_list|,
operator|(
name|insnp
operator|-
name|ready
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|ready
operator|=
name|insn
expr_stmt|;
name|deleted
operator|++
expr_stmt|;
block|}
name|n_ready
operator|-=
name|deleted
expr_stmt|;
name|ready
operator|+=
name|deleted
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* We are about to being issuing insns for this clock cycle.  Override    the default sort algorithm to better slot instructions.  */
end_comment

begin_function
specifier|static
name|int
name|ia64_sched_reorder
parameter_list|(
name|FILE
modifier|*
name|dump
parameter_list|,
name|int
name|sched_verbose
parameter_list|,
name|rtx
modifier|*
name|ready
parameter_list|,
name|int
modifier|*
name|pn_ready
parameter_list|,
name|int
name|clock_var
parameter_list|)
block|{
return|return
name|ia64_dfa_sched_reorder
argument_list|(
name|dump
argument_list|,
name|sched_verbose
argument_list|,
name|ready
argument_list|,
name|pn_ready
argument_list|,
name|clock_var
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Like ia64_sched_reorder, but called after issuing each insn.    Override the default sort algorithm to better slot instructions.  */
end_comment

begin_function
specifier|static
name|int
name|ia64_sched_reorder2
parameter_list|(
name|FILE
modifier|*
name|dump
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|sched_verbose
name|ATTRIBUTE_UNUSED
parameter_list|,
name|rtx
modifier|*
name|ready
parameter_list|,
name|int
modifier|*
name|pn_ready
parameter_list|,
name|int
name|clock_var
parameter_list|)
block|{
if|if
condition|(
name|ia64_tune
operator|==
name|PROCESSOR_ITANIUM
operator|&&
name|reload_completed
operator|&&
name|last_scheduled_insn
condition|)
name|clocks
index|[
name|INSN_UID
argument_list|(
name|last_scheduled_insn
argument_list|)
index|]
operator|=
name|clock_var
expr_stmt|;
return|return
name|ia64_dfa_sched_reorder
argument_list|(
name|dump
argument_list|,
name|sched_verbose
argument_list|,
name|ready
argument_list|,
name|pn_ready
argument_list|,
name|clock_var
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* We are about to issue INSN.  Return the number of insns left on the    ready queue that can be issued this cycle.  */
end_comment

begin_function
specifier|static
name|int
name|ia64_variable_issue
parameter_list|(
name|FILE
modifier|*
name|dump
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|sched_verbose
name|ATTRIBUTE_UNUSED
parameter_list|,
name|rtx
name|insn
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|can_issue_more
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|last_scheduled_insn
operator|=
name|insn
expr_stmt|;
name|memcpy
argument_list|(
name|prev_cycle_state
argument_list|,
name|curr_state
argument_list|,
name|dfa_state_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|reload_completed
condition|)
block|{
if|if
condition|(
name|group_barrier_needed_p
argument_list|(
name|insn
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
name|init_insn_group_barriers
argument_list|()
expr_stmt|;
name|stops_p
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
operator|=
name|stop_before_p
expr_stmt|;
name|stop_before_p
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* We are choosing insn from the ready queue.  Return nonzero if INSN    can be chosen.  */
end_comment

begin_function
specifier|static
name|int
name|ia64_first_cycle_multipass_dfa_lookahead_guard
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
if|if
condition|(
name|insn
operator|==
name|NULL_RTX
operator|||
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
operator|(
operator|!
name|reload_completed
operator|||
operator|!
name|safe_group_barrier_needed_p
argument_list|(
name|insn
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* The following variable value is pseudo-insn used by the DFA insn    scheduler to change the DFA state when the simulated clock is    increased.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|dfa_pre_cycle_insn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We are about to being issuing INSN.  Return nonzero if we can not    issue it on given cycle CLOCK and return zero if we should not sort    the ready queue on the next clock start.  */
end_comment

begin_function
specifier|static
name|int
name|ia64_dfa_new_cycle
parameter_list|(
name|FILE
modifier|*
name|dump
parameter_list|,
name|int
name|verbose
parameter_list|,
name|rtx
name|insn
parameter_list|,
name|int
name|last_clock
parameter_list|,
name|int
name|clock
parameter_list|,
name|int
modifier|*
name|sort_p
parameter_list|)
block|{
name|int
name|setup_clocks_p
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|insn
operator|==
name|NULL_RTX
operator|||
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|reload_completed
operator|&&
name|safe_group_barrier_needed_p
argument_list|(
name|insn
argument_list|)
operator|)
operator|||
operator|(
name|last_scheduled_insn
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|last_scheduled_insn
argument_list|)
operator|==
name|CALL_INSN
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|last_scheduled_insn
argument_list|)
argument_list|)
operator|==
name|ASM_INPUT
operator|||
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|last_scheduled_insn
argument_list|)
argument_list|)
operator|>=
literal|0
operator|)
operator|)
condition|)
block|{
name|init_insn_group_barriers
argument_list|()
expr_stmt|;
if|if
condition|(
name|verbose
operator|&&
name|dump
condition|)
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"//    Stop should be before %d%s\n"
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|,
name|last_clock
operator|==
name|clock
condition|?
literal|" + cycle advance"
else|:
literal|""
argument_list|)
expr_stmt|;
name|stop_before_p
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|last_clock
operator|==
name|clock
condition|)
block|{
name|state_transition
argument_list|(
name|curr_state
argument_list|,
name|dfa_stop_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_EARLY_STOP_BITS
condition|)
operator|*
name|sort_p
operator|=
operator|(
name|last_scheduled_insn
operator|==
name|NULL_RTX
operator|||
name|GET_CODE
argument_list|(
name|last_scheduled_insn
argument_list|)
operator|!=
name|CALL_INSN
operator|)
expr_stmt|;
else|else
operator|*
name|sort_p
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|reload_completed
condition|)
name|setup_clocks_p
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|last_scheduled_insn
argument_list|)
argument_list|)
operator|==
name|ASM_INPUT
operator|||
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|last_scheduled_insn
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
name|state_reset
argument_list|(
name|curr_state
argument_list|)
expr_stmt|;
else|else
block|{
name|memcpy
argument_list|(
name|curr_state
argument_list|,
name|prev_cycle_state
argument_list|,
name|dfa_state_size
argument_list|)
expr_stmt|;
name|state_transition
argument_list|(
name|curr_state
argument_list|,
name|dfa_stop_insn
argument_list|)
expr_stmt|;
name|state_transition
argument_list|(
name|curr_state
argument_list|,
name|dfa_pre_cycle_insn
argument_list|)
expr_stmt|;
name|state_transition
argument_list|(
name|curr_state
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|reload_completed
condition|)
name|setup_clocks_p
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|setup_clocks_p
operator|&&
name|ia64_tune
operator|==
name|PROCESSOR_ITANIUM
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|ASM_INPUT
operator|&&
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|enum
name|attr_itanium_class
name|c
init|=
name|ia64_safe_itanium_class
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|!=
name|ITANIUM_CLASS_MMMUL
operator|&&
name|c
operator|!=
name|ITANIUM_CLASS_MMSHF
condition|)
block|{
name|rtx
name|link
decl_stmt|;
name|int
name|d
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|link
operator|=
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
literal|0
condition|)
block|{
name|enum
name|attr_itanium_class
name|dep_class
decl_stmt|;
name|rtx
name|dep_insn
init|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|dep_class
operator|=
name|ia64_safe_itanium_class
argument_list|(
name|dep_insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dep_class
operator|==
name|ITANIUM_CLASS_MMMUL
operator|||
name|dep_class
operator|==
name|ITANIUM_CLASS_MMSHF
operator|)
operator|&&
name|last_clock
operator|-
name|clocks
index|[
name|INSN_UID
argument_list|(
name|dep_insn
argument_list|)
index|]
operator|<
literal|4
operator|&&
operator|(
name|d
operator|<
literal|0
operator|||
name|last_clock
operator|-
name|clocks
index|[
name|INSN_UID
argument_list|(
name|dep_insn
argument_list|)
index|]
operator|<
name|d
operator|)
condition|)
name|d
operator|=
name|last_clock
operator|-
name|clocks
index|[
name|INSN_UID
argument_list|(
name|dep_insn
argument_list|)
index|]
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|>=
literal|0
condition|)
name|add_cycles
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
operator|=
literal|3
operator|-
name|d
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The following page contains abstract data `bundle states' which are    used for bundling insns (inserting nops and template generation).  */
end_comment

begin_comment
comment|/* The following describes state of insn bundling.  */
end_comment

begin_struct
struct|struct
name|bundle_state
block|{
comment|/* Unique bundle state number to identify them in the debugging      output  */
name|int
name|unique_num
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
comment|/* corresponding insn, NULL for the 1st and the last state  */
comment|/* number nops before and after the insn  */
name|short
name|before_nops_num
decl_stmt|,
name|after_nops_num
decl_stmt|;
name|int
name|insn_num
decl_stmt|;
comment|/* insn number (0 - for initial state, 1 - for the 1st                    insn */
name|int
name|cost
decl_stmt|;
comment|/* cost of the state in cycles */
name|int
name|accumulated_insns_num
decl_stmt|;
comment|/* number of all previous insns including 				nops.  L is considered as 2 insns */
name|int
name|branch_deviation
decl_stmt|;
comment|/* deviation of previous branches from 3rd slots  */
name|struct
name|bundle_state
modifier|*
name|next
decl_stmt|;
comment|/* next state with the same insn_num  */
name|struct
name|bundle_state
modifier|*
name|originator
decl_stmt|;
comment|/* originator (previous insn state)  */
comment|/* All bundle states are in the following chain.  */
name|struct
name|bundle_state
modifier|*
name|allocated_states_chain
decl_stmt|;
comment|/* The DFA State after issuing the insn and the nops.  */
name|state_t
name|dfa_state
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The following is map insn number to the corresponding bundle state.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|bundle_state
modifier|*
modifier|*
name|index_to_bundle_states
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The unique number of next bundle state.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|bundle_states_num
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* All allocated bundle states are in the following chain.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|bundle_state
modifier|*
name|allocated_bundle_states_chain
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* All allocated but not used bundle states are in the following    chain.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|bundle_state
modifier|*
name|free_bundle_state_chain
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following function returns a free bundle state.  */
end_comment

begin_function
specifier|static
name|struct
name|bundle_state
modifier|*
name|get_free_bundle_state
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|bundle_state
modifier|*
name|result
decl_stmt|;
if|if
condition|(
name|free_bundle_state_chain
operator|!=
name|NULL
condition|)
block|{
name|result
operator|=
name|free_bundle_state_chain
expr_stmt|;
name|free_bundle_state_chain
operator|=
name|result
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|bundle_state
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|->
name|dfa_state
operator|=
name|xmalloc
argument_list|(
name|dfa_state_size
argument_list|)
expr_stmt|;
name|result
operator|->
name|allocated_states_chain
operator|=
name|allocated_bundle_states_chain
expr_stmt|;
name|allocated_bundle_states_chain
operator|=
name|result
expr_stmt|;
block|}
name|result
operator|->
name|unique_num
operator|=
name|bundle_states_num
operator|++
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* The following function frees given bundle state.  */
end_comment

begin_function
specifier|static
name|void
name|free_bundle_state
parameter_list|(
name|struct
name|bundle_state
modifier|*
name|state
parameter_list|)
block|{
name|state
operator|->
name|next
operator|=
name|free_bundle_state_chain
expr_stmt|;
name|free_bundle_state_chain
operator|=
name|state
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Start work with abstract data `bundle states'.  */
end_comment

begin_function
specifier|static
name|void
name|initiate_bundle_states
parameter_list|(
name|void
parameter_list|)
block|{
name|bundle_states_num
operator|=
literal|0
expr_stmt|;
name|free_bundle_state_chain
operator|=
name|NULL
expr_stmt|;
name|allocated_bundle_states_chain
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish work with abstract data `bundle states'.  */
end_comment

begin_function
specifier|static
name|void
name|finish_bundle_states
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|bundle_state
modifier|*
name|curr_state
decl_stmt|,
modifier|*
name|next_state
decl_stmt|;
for|for
control|(
name|curr_state
operator|=
name|allocated_bundle_states_chain
init|;
name|curr_state
operator|!=
name|NULL
condition|;
name|curr_state
operator|=
name|next_state
control|)
block|{
name|next_state
operator|=
name|curr_state
operator|->
name|allocated_states_chain
expr_stmt|;
name|free
argument_list|(
name|curr_state
operator|->
name|dfa_state
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|curr_state
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Hash table of the bundle states.  The key is dfa_state and insn_num    of the bundle states.  */
end_comment

begin_decl_stmt
specifier|static
name|htab_t
name|bundle_state_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The function returns hash of BUNDLE_STATE.  */
end_comment

begin_function
specifier|static
name|unsigned
name|bundle_state_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|bundle_state
parameter_list|)
block|{
specifier|const
name|struct
name|bundle_state
modifier|*
name|state
init|=
operator|(
expr|struct
name|bundle_state
operator|*
operator|)
name|bundle_state
decl_stmt|;
name|unsigned
name|result
decl_stmt|,
name|i
decl_stmt|;
for|for
control|(
name|result
operator|=
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dfa_state_size
condition|;
name|i
operator|++
control|)
name|result
operator|+=
operator|(
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|state
operator|->
name|dfa_state
operator|)
index|[
name|i
index|]
operator|<<
operator|(
operator|(
name|i
operator|%
name|CHAR_BIT
operator|)
operator|*
literal|3
operator|+
name|CHAR_BIT
operator|)
operator|)
expr_stmt|;
return|return
name|result
operator|+
name|state
operator|->
name|insn_num
return|;
block|}
end_function

begin_comment
comment|/* The function returns nonzero if the bundle state keys are equal.  */
end_comment

begin_function
specifier|static
name|int
name|bundle_state_eq_p
parameter_list|(
specifier|const
name|void
modifier|*
name|bundle_state_1
parameter_list|,
specifier|const
name|void
modifier|*
name|bundle_state_2
parameter_list|)
block|{
specifier|const
name|struct
name|bundle_state
modifier|*
name|state1
init|=
operator|(
expr|struct
name|bundle_state
operator|*
operator|)
name|bundle_state_1
decl_stmt|;
specifier|const
name|struct
name|bundle_state
modifier|*
name|state2
init|=
operator|(
expr|struct
name|bundle_state
operator|*
operator|)
name|bundle_state_2
decl_stmt|;
return|return
operator|(
name|state1
operator|->
name|insn_num
operator|==
name|state2
operator|->
name|insn_num
operator|&&
name|memcmp
argument_list|(
name|state1
operator|->
name|dfa_state
argument_list|,
name|state2
operator|->
name|dfa_state
argument_list|,
name|dfa_state_size
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* The function inserts the BUNDLE_STATE into the hash table.  The    function returns nonzero if the bundle has been inserted into the    table.  The table contains the best bundle state with given key.  */
end_comment

begin_function
specifier|static
name|int
name|insert_bundle_state
parameter_list|(
name|struct
name|bundle_state
modifier|*
name|bundle_state
parameter_list|)
block|{
name|void
modifier|*
modifier|*
name|entry_ptr
decl_stmt|;
name|entry_ptr
operator|=
name|htab_find_slot
argument_list|(
name|bundle_state_table
argument_list|,
name|bundle_state
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|entry_ptr
operator|==
name|NULL
condition|)
block|{
name|bundle_state
operator|->
name|next
operator|=
name|index_to_bundle_states
index|[
name|bundle_state
operator|->
name|insn_num
index|]
expr_stmt|;
name|index_to_bundle_states
index|[
name|bundle_state
operator|->
name|insn_num
index|]
operator|=
name|bundle_state
expr_stmt|;
operator|*
name|entry_ptr
operator|=
operator|(
name|void
operator|*
operator|)
name|bundle_state
expr_stmt|;
return|return
name|TRUE
return|;
block|}
elseif|else
if|if
condition|(
name|bundle_state
operator|->
name|cost
operator|<
operator|(
operator|(
expr|struct
name|bundle_state
operator|*
operator|)
operator|*
name|entry_ptr
operator|)
operator|->
name|cost
operator|||
operator|(
name|bundle_state
operator|->
name|cost
operator|==
operator|(
operator|(
expr|struct
name|bundle_state
operator|*
operator|)
operator|*
name|entry_ptr
operator|)
operator|->
name|cost
operator|&&
operator|(
operator|(
operator|(
expr|struct
name|bundle_state
operator|*
operator|)
operator|*
name|entry_ptr
operator|)
operator|->
name|accumulated_insns_num
operator|>
name|bundle_state
operator|->
name|accumulated_insns_num
operator|||
operator|(
operator|(
operator|(
expr|struct
name|bundle_state
operator|*
operator|)
operator|*
name|entry_ptr
operator|)
operator|->
name|accumulated_insns_num
operator|==
name|bundle_state
operator|->
name|accumulated_insns_num
operator|&&
operator|(
operator|(
expr|struct
name|bundle_state
operator|*
operator|)
operator|*
name|entry_ptr
operator|)
operator|->
name|branch_deviation
operator|>
name|bundle_state
operator|->
name|branch_deviation
operator|)
operator|)
operator|)
condition|)
block|{
name|struct
name|bundle_state
name|temp
decl_stmt|;
name|temp
operator|=
operator|*
operator|(
expr|struct
name|bundle_state
operator|*
operator|)
operator|*
name|entry_ptr
expr_stmt|;
operator|*
operator|(
expr|struct
name|bundle_state
operator|*
operator|)
operator|*
name|entry_ptr
operator|=
operator|*
name|bundle_state
expr_stmt|;
operator|(
operator|(
expr|struct
name|bundle_state
operator|*
operator|)
operator|*
name|entry_ptr
operator|)
operator|->
name|next
operator|=
name|temp
operator|.
name|next
expr_stmt|;
operator|*
name|bundle_state
operator|=
name|temp
expr_stmt|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Start work with the hash table.  */
end_comment

begin_function
specifier|static
name|void
name|initiate_bundle_state_table
parameter_list|(
name|void
parameter_list|)
block|{
name|bundle_state_table
operator|=
name|htab_create
argument_list|(
literal|50
argument_list|,
name|bundle_state_hash
argument_list|,
name|bundle_state_eq_p
argument_list|,
operator|(
name|htab_del
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish work with the hash table.  */
end_comment

begin_function
specifier|static
name|void
name|finish_bundle_state_table
parameter_list|(
name|void
parameter_list|)
block|{
name|htab_delete
argument_list|(
name|bundle_state_table
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The following variable is a insn `nop' used to check bundle states    with different number of inserted nops.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|ia64_nop
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following function tries to issue NOPS_NUM nops for the current    state without advancing processor cycle.  If it failed, the    function returns FALSE and frees the current state.  */
end_comment

begin_function
specifier|static
name|int
name|try_issue_nops
parameter_list|(
name|struct
name|bundle_state
modifier|*
name|curr_state
parameter_list|,
name|int
name|nops_num
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nops_num
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|state_transition
argument_list|(
name|curr_state
operator|->
name|dfa_state
argument_list|,
name|ia64_nop
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|free_bundle_state
argument_list|(
name|curr_state
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* The following function tries to issue INSN for the current    state without advancing processor cycle.  If it failed, the    function returns FALSE and frees the current state.  */
end_comment

begin_function
specifier|static
name|int
name|try_issue_insn
parameter_list|(
name|struct
name|bundle_state
modifier|*
name|curr_state
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
if|if
condition|(
name|insn
operator|&&
name|state_transition
argument_list|(
name|curr_state
operator|->
name|dfa_state
argument_list|,
name|insn
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|free_bundle_state
argument_list|(
name|curr_state
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* The following function tries to issue BEFORE_NOPS_NUM nops and INSN    starting with ORIGINATOR without advancing processor cycle.  If    TRY_BUNDLE_END_P is TRUE, the function also/only (if    ONLY_BUNDLE_END_P is TRUE) tries to issue nops to fill all bundle.    If it was successful, the function creates new bundle state and    insert into the hash table and into `index_to_bundle_states'.  */
end_comment

begin_function
specifier|static
name|void
name|issue_nops_and_insn
parameter_list|(
name|struct
name|bundle_state
modifier|*
name|originator
parameter_list|,
name|int
name|before_nops_num
parameter_list|,
name|rtx
name|insn
parameter_list|,
name|int
name|try_bundle_end_p
parameter_list|,
name|int
name|only_bundle_end_p
parameter_list|)
block|{
name|struct
name|bundle_state
modifier|*
name|curr_state
decl_stmt|;
name|curr_state
operator|=
name|get_free_bundle_state
argument_list|()
expr_stmt|;
name|memcpy
argument_list|(
name|curr_state
operator|->
name|dfa_state
argument_list|,
name|originator
operator|->
name|dfa_state
argument_list|,
name|dfa_state_size
argument_list|)
expr_stmt|;
name|curr_state
operator|->
name|insn
operator|=
name|insn
expr_stmt|;
name|curr_state
operator|->
name|insn_num
operator|=
name|originator
operator|->
name|insn_num
operator|+
literal|1
expr_stmt|;
name|curr_state
operator|->
name|cost
operator|=
name|originator
operator|->
name|cost
expr_stmt|;
name|curr_state
operator|->
name|originator
operator|=
name|originator
expr_stmt|;
name|curr_state
operator|->
name|before_nops_num
operator|=
name|before_nops_num
expr_stmt|;
name|curr_state
operator|->
name|after_nops_num
operator|=
literal|0
expr_stmt|;
name|curr_state
operator|->
name|accumulated_insns_num
operator|=
name|originator
operator|->
name|accumulated_insns_num
operator|+
name|before_nops_num
expr_stmt|;
name|curr_state
operator|->
name|branch_deviation
operator|=
name|originator
operator|->
name|branch_deviation
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|NULL_RTX
condition|)
name|abort
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_FOR_insn_group_barrier
condition|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|insn
argument_list|)
operator|==
name|TImode
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|try_issue_nops
argument_list|(
name|curr_state
argument_list|,
name|before_nops_num
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|try_issue_insn
argument_list|(
name|curr_state
argument_list|,
name|insn
argument_list|)
condition|)
return|return;
name|memcpy
argument_list|(
name|temp_dfa_state
argument_list|,
name|curr_state
operator|->
name|dfa_state
argument_list|,
name|dfa_state_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|state_transition
argument_list|(
name|temp_dfa_state
argument_list|,
name|dfa_pre_cycle_insn
argument_list|)
operator|>=
literal|0
operator|&&
name|curr_state
operator|->
name|accumulated_insns_num
operator|%
literal|3
operator|!=
literal|0
condition|)
block|{
name|free_bundle_state
argument_list|(
name|curr_state
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|TImode
condition|)
block|{
if|if
condition|(
operator|!
name|try_issue_nops
argument_list|(
name|curr_state
argument_list|,
name|before_nops_num
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|try_issue_insn
argument_list|(
name|curr_state
argument_list|,
name|insn
argument_list|)
condition|)
return|return;
name|curr_state
operator|->
name|accumulated_insns_num
operator|++
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ASM_INPUT
operator|||
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|ia64_safe_type
argument_list|(
name|insn
argument_list|)
operator|==
name|TYPE_L
condition|)
name|curr_state
operator|->
name|accumulated_insns_num
operator|++
expr_stmt|;
block|}
else|else
block|{
name|state_transition
argument_list|(
name|curr_state
operator|->
name|dfa_state
argument_list|,
name|dfa_pre_cycle_insn
argument_list|)
expr_stmt|;
name|state_transition
argument_list|(
name|curr_state
operator|->
name|dfa_state
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|curr_state
operator|->
name|cost
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|try_issue_nops
argument_list|(
name|curr_state
argument_list|,
name|before_nops_num
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|try_issue_insn
argument_list|(
name|curr_state
argument_list|,
name|insn
argument_list|)
condition|)
return|return;
name|curr_state
operator|->
name|accumulated_insns_num
operator|++
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ASM_INPUT
operator|||
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
block|{
comment|/* Finish bundle containing asm insn.  */
name|curr_state
operator|->
name|after_nops_num
operator|=
literal|3
operator|-
name|curr_state
operator|->
name|accumulated_insns_num
operator|%
literal|3
expr_stmt|;
name|curr_state
operator|->
name|accumulated_insns_num
operator|+=
literal|3
operator|-
name|curr_state
operator|->
name|accumulated_insns_num
operator|%
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ia64_safe_type
argument_list|(
name|insn
argument_list|)
operator|==
name|TYPE_L
condition|)
name|curr_state
operator|->
name|accumulated_insns_num
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|ia64_safe_type
argument_list|(
name|insn
argument_list|)
operator|==
name|TYPE_B
condition|)
name|curr_state
operator|->
name|branch_deviation
operator|+=
literal|2
operator|-
operator|(
name|curr_state
operator|->
name|accumulated_insns_num
operator|-
literal|1
operator|)
operator|%
literal|3
expr_stmt|;
if|if
condition|(
name|try_bundle_end_p
operator|&&
name|curr_state
operator|->
name|accumulated_insns_num
operator|%
literal|3
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|only_bundle_end_p
operator|&&
name|insert_bundle_state
argument_list|(
name|curr_state
argument_list|)
condition|)
block|{
name|state_t
name|dfa_state
decl_stmt|;
name|struct
name|bundle_state
modifier|*
name|curr_state1
decl_stmt|;
name|struct
name|bundle_state
modifier|*
name|allocated_states_chain
decl_stmt|;
name|curr_state1
operator|=
name|get_free_bundle_state
argument_list|()
expr_stmt|;
name|dfa_state
operator|=
name|curr_state1
operator|->
name|dfa_state
expr_stmt|;
name|allocated_states_chain
operator|=
name|curr_state1
operator|->
name|allocated_states_chain
expr_stmt|;
operator|*
name|curr_state1
operator|=
operator|*
name|curr_state
expr_stmt|;
name|curr_state1
operator|->
name|dfa_state
operator|=
name|dfa_state
expr_stmt|;
name|curr_state1
operator|->
name|allocated_states_chain
operator|=
name|allocated_states_chain
expr_stmt|;
name|memcpy
argument_list|(
name|curr_state1
operator|->
name|dfa_state
argument_list|,
name|curr_state
operator|->
name|dfa_state
argument_list|,
name|dfa_state_size
argument_list|)
expr_stmt|;
name|curr_state
operator|=
name|curr_state1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|try_issue_nops
argument_list|(
name|curr_state
argument_list|,
literal|3
operator|-
name|curr_state
operator|->
name|accumulated_insns_num
operator|%
literal|3
argument_list|)
condition|)
return|return;
name|curr_state
operator|->
name|after_nops_num
operator|=
literal|3
operator|-
name|curr_state
operator|->
name|accumulated_insns_num
operator|%
literal|3
expr_stmt|;
name|curr_state
operator|->
name|accumulated_insns_num
operator|+=
literal|3
operator|-
name|curr_state
operator|->
name|accumulated_insns_num
operator|%
literal|3
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|insert_bundle_state
argument_list|(
name|curr_state
argument_list|)
condition|)
name|free_bundle_state
argument_list|(
name|curr_state
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* The following function returns position in the two window bundle    for given STATE.  */
end_comment

begin_function
specifier|static
name|int
name|get_max_pos
parameter_list|(
name|state_t
name|state
parameter_list|)
block|{
if|if
condition|(
name|cpu_unit_reservation_p
argument_list|(
name|state
argument_list|,
name|pos_6
argument_list|)
condition|)
return|return
literal|6
return|;
elseif|else
if|if
condition|(
name|cpu_unit_reservation_p
argument_list|(
name|state
argument_list|,
name|pos_5
argument_list|)
condition|)
return|return
literal|5
return|;
elseif|else
if|if
condition|(
name|cpu_unit_reservation_p
argument_list|(
name|state
argument_list|,
name|pos_4
argument_list|)
condition|)
return|return
literal|4
return|;
elseif|else
if|if
condition|(
name|cpu_unit_reservation_p
argument_list|(
name|state
argument_list|,
name|pos_3
argument_list|)
condition|)
return|return
literal|3
return|;
elseif|else
if|if
condition|(
name|cpu_unit_reservation_p
argument_list|(
name|state
argument_list|,
name|pos_2
argument_list|)
condition|)
return|return
literal|2
return|;
elseif|else
if|if
condition|(
name|cpu_unit_reservation_p
argument_list|(
name|state
argument_list|,
name|pos_1
argument_list|)
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* The function returns code of a possible template for given position    and state.  The function should be called only with 2 values of    position equal to 3 or 6.  */
end_comment

begin_function
specifier|static
name|int
name|get_template
parameter_list|(
name|state_t
name|state
parameter_list|,
name|int
name|pos
parameter_list|)
block|{
switch|switch
condition|(
name|pos
condition|)
block|{
case|case
literal|3
case|:
if|if
condition|(
name|cpu_unit_reservation_p
argument_list|(
name|state
argument_list|,
name|_0mii_
argument_list|)
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|cpu_unit_reservation_p
argument_list|(
name|state
argument_list|,
name|_0mmi_
argument_list|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|cpu_unit_reservation_p
argument_list|(
name|state
argument_list|,
name|_0mfi_
argument_list|)
condition|)
return|return
literal|2
return|;
elseif|else
if|if
condition|(
name|cpu_unit_reservation_p
argument_list|(
name|state
argument_list|,
name|_0mmf_
argument_list|)
condition|)
return|return
literal|3
return|;
elseif|else
if|if
condition|(
name|cpu_unit_reservation_p
argument_list|(
name|state
argument_list|,
name|_0bbb_
argument_list|)
condition|)
return|return
literal|4
return|;
elseif|else
if|if
condition|(
name|cpu_unit_reservation_p
argument_list|(
name|state
argument_list|,
name|_0mbb_
argument_list|)
condition|)
return|return
literal|5
return|;
elseif|else
if|if
condition|(
name|cpu_unit_reservation_p
argument_list|(
name|state
argument_list|,
name|_0mib_
argument_list|)
condition|)
return|return
literal|6
return|;
elseif|else
if|if
condition|(
name|cpu_unit_reservation_p
argument_list|(
name|state
argument_list|,
name|_0mmb_
argument_list|)
condition|)
return|return
literal|7
return|;
elseif|else
if|if
condition|(
name|cpu_unit_reservation_p
argument_list|(
name|state
argument_list|,
name|_0mfb_
argument_list|)
condition|)
return|return
literal|8
return|;
elseif|else
if|if
condition|(
name|cpu_unit_reservation_p
argument_list|(
name|state
argument_list|,
name|_0mlx_
argument_list|)
condition|)
return|return
literal|9
return|;
else|else
name|abort
argument_list|()
expr_stmt|;
case|case
literal|6
case|:
if|if
condition|(
name|cpu_unit_reservation_p
argument_list|(
name|state
argument_list|,
name|_1mii_
argument_list|)
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|cpu_unit_reservation_p
argument_list|(
name|state
argument_list|,
name|_1mmi_
argument_list|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|cpu_unit_reservation_p
argument_list|(
name|state
argument_list|,
name|_1mfi_
argument_list|)
condition|)
return|return
literal|2
return|;
elseif|else
if|if
condition|(
name|_1mmf_
operator|>=
literal|0
operator|&&
name|cpu_unit_reservation_p
argument_list|(
name|state
argument_list|,
name|_1mmf_
argument_list|)
condition|)
return|return
literal|3
return|;
elseif|else
if|if
condition|(
name|cpu_unit_reservation_p
argument_list|(
name|state
argument_list|,
name|_1bbb_
argument_list|)
condition|)
return|return
literal|4
return|;
elseif|else
if|if
condition|(
name|cpu_unit_reservation_p
argument_list|(
name|state
argument_list|,
name|_1mbb_
argument_list|)
condition|)
return|return
literal|5
return|;
elseif|else
if|if
condition|(
name|cpu_unit_reservation_p
argument_list|(
name|state
argument_list|,
name|_1mib_
argument_list|)
condition|)
return|return
literal|6
return|;
elseif|else
if|if
condition|(
name|cpu_unit_reservation_p
argument_list|(
name|state
argument_list|,
name|_1mmb_
argument_list|)
condition|)
return|return
literal|7
return|;
elseif|else
if|if
condition|(
name|cpu_unit_reservation_p
argument_list|(
name|state
argument_list|,
name|_1mfb_
argument_list|)
condition|)
return|return
literal|8
return|;
elseif|else
if|if
condition|(
name|cpu_unit_reservation_p
argument_list|(
name|state
argument_list|,
name|_1mlx_
argument_list|)
condition|)
return|return
literal|9
return|;
else|else
name|abort
argument_list|()
expr_stmt|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The following function returns an insn important for insn bundling    followed by INSN and before TAIL.  */
end_comment

begin_function
specifier|static
name|rtx
name|get_next_important_insn
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|tail
parameter_list|)
block|{
for|for
control|(
init|;
name|insn
operator|&&
name|insn
operator|!=
name|tail
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|ia64_safe_itanium_class
argument_list|(
name|insn
argument_list|)
operator|!=
name|ITANIUM_CLASS_IGNORE
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|CLOBBER
condition|)
return|return
name|insn
return|;
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_comment
comment|/* The following function does insn bundling.  Bundling means    inserting templates and nop insns to fit insn groups into permitted    templates.  Instruction scheduling uses NDFA (non-deterministic    finite automata) encoding informations about the templates and the    inserted nops.  Nondeterminism of the automata permits follows    all possible insn sequences very fast.     Unfortunately it is not possible to get information about inserting    nop insns and used templates from the automata states.  The    automata only says that we can issue an insn possibly inserting    some nops before it and using some template.  Therefore insn    bundling in this function is implemented by using DFA    (deterministic finite automata).  We follows all possible insn    sequences by inserting 0-2 nops (that is what the NDFA describe for    insn scheduling) before/after each insn being bundled.  We know the    start of simulated processor cycle from insn scheduling (insn    starting a new cycle has TImode).     Simple implementation of insn bundling would create enormous    number of possible insn sequences satisfying information about new    cycle ticks taken from the insn scheduling.  To make the algorithm    practical we use dynamic programming.  Each decision (about    inserting nops and implicitly about previous decisions) is described    by structure bundle_state (see above).  If we generate the same    bundle state (key is automaton state after issuing the insns and    nops for it), we reuse already generated one.  As consequence we    reject some decisions which can not improve the solution and    reduce memory for the algorithm.     When we reach the end of EBB (extended basic block), we choose the    best sequence and then, moving back in EBB, insert templates for    the best alternative.  The templates are taken from querying    automaton state for each insn in chosen bundle states.     So the algorithm makes two (forward and backward) passes through    EBB.  There is an additional forward pass through EBB for Itanium1    processor.  This pass inserts more nops to make dependency between    a producer insn and MMMUL/MMSHF at least 4 cycles long.  */
end_comment

begin_function
specifier|static
name|void
name|bundling
parameter_list|(
name|FILE
modifier|*
name|dump
parameter_list|,
name|int
name|verbose
parameter_list|,
name|rtx
name|prev_head_insn
parameter_list|,
name|rtx
name|tail
parameter_list|)
block|{
name|struct
name|bundle_state
modifier|*
name|curr_state
decl_stmt|,
modifier|*
name|next_state
decl_stmt|,
modifier|*
name|best_state
decl_stmt|;
name|rtx
name|insn
decl_stmt|,
name|next_insn
decl_stmt|;
name|int
name|insn_num
decl_stmt|;
name|int
name|i
decl_stmt|,
name|bundle_end_p
decl_stmt|,
name|only_bundle_end_p
decl_stmt|,
name|asm_p
decl_stmt|;
name|int
name|pos
init|=
literal|0
decl_stmt|,
name|max_pos
decl_stmt|,
name|template0
decl_stmt|,
name|template1
decl_stmt|;
name|rtx
name|b
decl_stmt|;
name|rtx
name|nop
decl_stmt|;
name|enum
name|attr_type
name|type
decl_stmt|;
name|insn_num
operator|=
literal|0
expr_stmt|;
comment|/* Count insns in the EBB.  */
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|prev_head_insn
argument_list|)
init|;
name|insn
operator|&&
name|insn
operator|!=
name|tail
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
name|insn_num
operator|++
expr_stmt|;
if|if
condition|(
name|insn_num
operator|==
literal|0
condition|)
return|return;
name|bundling_p
operator|=
literal|1
expr_stmt|;
name|dfa_clean_insn_cache
argument_list|()
expr_stmt|;
name|initiate_bundle_state_table
argument_list|()
expr_stmt|;
name|index_to_bundle_states
operator|=
name|xmalloc
argument_list|(
operator|(
name|insn_num
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|bundle_state
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* First (forward) pass -- generation of bundle states. */
name|curr_state
operator|=
name|get_free_bundle_state
argument_list|()
expr_stmt|;
name|curr_state
operator|->
name|insn
operator|=
name|NULL
expr_stmt|;
name|curr_state
operator|->
name|before_nops_num
operator|=
literal|0
expr_stmt|;
name|curr_state
operator|->
name|after_nops_num
operator|=
literal|0
expr_stmt|;
name|curr_state
operator|->
name|insn_num
operator|=
literal|0
expr_stmt|;
name|curr_state
operator|->
name|cost
operator|=
literal|0
expr_stmt|;
name|curr_state
operator|->
name|accumulated_insns_num
operator|=
literal|0
expr_stmt|;
name|curr_state
operator|->
name|branch_deviation
operator|=
literal|0
expr_stmt|;
name|curr_state
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|curr_state
operator|->
name|originator
operator|=
name|NULL
expr_stmt|;
name|state_reset
argument_list|(
name|curr_state
operator|->
name|dfa_state
argument_list|)
expr_stmt|;
name|index_to_bundle_states
index|[
literal|0
index|]
operator|=
name|curr_state
expr_stmt|;
name|insn_num
operator|=
literal|0
expr_stmt|;
comment|/* Shift cycle mark if it is put on insn which could be ignored.  */
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|prev_head_insn
argument_list|)
init|;
name|insn
operator|!=
name|tail
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
operator|(
name|ia64_safe_itanium_class
argument_list|(
name|insn
argument_list|)
operator|==
name|ITANIUM_CLASS_IGNORE
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
operator|)
operator|&&
name|GET_MODE
argument_list|(
name|insn
argument_list|)
operator|==
name|TImode
condition|)
block|{
name|PUT_MODE
argument_list|(
name|insn
argument_list|,
name|VOIDmode
argument_list|)
expr_stmt|;
for|for
control|(
name|next_insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
init|;
name|next_insn
operator|!=
name|tail
condition|;
name|next_insn
operator|=
name|NEXT_INSN
argument_list|(
name|next_insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|next_insn
argument_list|)
operator|&&
name|ia64_safe_itanium_class
argument_list|(
name|next_insn
argument_list|)
operator|!=
name|ITANIUM_CLASS_IGNORE
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|next_insn
argument_list|)
argument_list|)
operator|!=
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|next_insn
argument_list|)
argument_list|)
operator|!=
name|CLOBBER
condition|)
block|{
name|PUT_MODE
argument_list|(
name|next_insn
argument_list|,
name|TImode
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* Froward pass: generation of bundle states.  */
for|for
control|(
name|insn
operator|=
name|get_next_important_insn
argument_list|(
name|NEXT_INSN
argument_list|(
name|prev_head_insn
argument_list|)
argument_list|,
name|tail
argument_list|)
init|;
name|insn
operator|!=
name|NULL_RTX
condition|;
name|insn
operator|=
name|next_insn
control|)
block|{
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|||
name|ia64_safe_itanium_class
argument_list|(
name|insn
argument_list|)
operator|==
name|ITANIUM_CLASS_IGNORE
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
name|abort
argument_list|()
expr_stmt|;
name|type
operator|=
name|ia64_safe_type
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|next_insn
operator|=
name|get_next_important_insn
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|tail
argument_list|)
expr_stmt|;
name|insn_num
operator|++
expr_stmt|;
name|index_to_bundle_states
index|[
name|insn_num
index|]
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|curr_state
operator|=
name|index_to_bundle_states
index|[
name|insn_num
operator|-
literal|1
index|]
init|;
name|curr_state
operator|!=
name|NULL
condition|;
name|curr_state
operator|=
name|next_state
control|)
block|{
name|pos
operator|=
name|curr_state
operator|->
name|accumulated_insns_num
operator|%
literal|3
expr_stmt|;
name|next_state
operator|=
name|curr_state
operator|->
name|next
expr_stmt|;
comment|/* We must fill up the current bundle in order to start a 	     subsequent asm insn in a new bundle.  Asm insn is always 	     placed in a separate bundle.  */
name|only_bundle_end_p
operator|=
operator|(
name|next_insn
operator|!=
name|NULL_RTX
operator|&&
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_FOR_insn_group_barrier
operator|&&
name|ia64_safe_type
argument_list|(
name|next_insn
argument_list|)
operator|==
name|TYPE_UNKNOWN
operator|)
expr_stmt|;
comment|/* We may fill up the current bundle if it is the cycle end 	     without a group barrier.  */
name|bundle_end_p
operator|=
operator|(
name|only_bundle_end_p
operator|||
name|next_insn
operator|==
name|NULL_RTX
operator|||
operator|(
name|GET_MODE
argument_list|(
name|next_insn
argument_list|)
operator|==
name|TImode
operator|&&
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|CODE_FOR_insn_group_barrier
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|TYPE_F
operator|||
name|type
operator|==
name|TYPE_B
operator|||
name|type
operator|==
name|TYPE_L
operator|||
name|type
operator|==
name|TYPE_S
comment|/* We need to insert 2 nops for cases like M_MII.  To 		 guarantee issuing all insns on the same cycle for 		 Itanium 1, we need to issue 2 nops after the first M 		 insn (MnnMII where n is a nop insn).  */
operator|||
operator|(
operator|(
name|type
operator|==
name|TYPE_M
operator|||
name|type
operator|==
name|TYPE_A
operator|)
operator|&&
name|ia64_tune
operator|==
name|PROCESSOR_ITANIUM
operator|&&
operator|!
name|bundle_end_p
operator|&&
name|pos
operator|==
literal|1
operator|)
condition|)
name|issue_nops_and_insn
argument_list|(
name|curr_state
argument_list|,
literal|2
argument_list|,
name|insn
argument_list|,
name|bundle_end_p
argument_list|,
name|only_bundle_end_p
argument_list|)
expr_stmt|;
name|issue_nops_and_insn
argument_list|(
name|curr_state
argument_list|,
literal|1
argument_list|,
name|insn
argument_list|,
name|bundle_end_p
argument_list|,
name|only_bundle_end_p
argument_list|)
expr_stmt|;
name|issue_nops_and_insn
argument_list|(
name|curr_state
argument_list|,
literal|0
argument_list|,
name|insn
argument_list|,
name|bundle_end_p
argument_list|,
name|only_bundle_end_p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|index_to_bundle_states
index|[
name|insn_num
index|]
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
for|for
control|(
name|curr_state
operator|=
name|index_to_bundle_states
index|[
name|insn_num
index|]
init|;
name|curr_state
operator|!=
name|NULL
condition|;
name|curr_state
operator|=
name|curr_state
operator|->
name|next
control|)
if|if
condition|(
name|verbose
operator|>=
literal|2
operator|&&
name|dump
condition|)
block|{
comment|/* This structure is taken from generated code of the 	       pipeline hazard recognizer (see file insn-attrtab.c). 	       Please don't forget to change the structure if a new 	       automaton is added to .md file.  */
struct|struct
name|DFA_chip
block|{
name|unsigned
name|short
name|one_automaton_state
decl_stmt|;
name|unsigned
name|short
name|oneb_automaton_state
decl_stmt|;
name|unsigned
name|short
name|two_automaton_state
decl_stmt|;
name|unsigned
name|short
name|twob_automaton_state
decl_stmt|;
block|}
struct|;
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"//    Bundle state %d (orig %d, cost %d, nops %d/%d, insns %d, branch %d, state %d) for %d\n"
argument_list|,
name|curr_state
operator|->
name|unique_num
argument_list|,
operator|(
name|curr_state
operator|->
name|originator
operator|==
name|NULL
condition|?
operator|-
literal|1
else|:
name|curr_state
operator|->
name|originator
operator|->
name|unique_num
operator|)
argument_list|,
name|curr_state
operator|->
name|cost
argument_list|,
name|curr_state
operator|->
name|before_nops_num
argument_list|,
name|curr_state
operator|->
name|after_nops_num
argument_list|,
name|curr_state
operator|->
name|accumulated_insns_num
argument_list|,
name|curr_state
operator|->
name|branch_deviation
argument_list|,
operator|(
name|ia64_tune
operator|==
name|PROCESSOR_ITANIUM
condition|?
operator|(
operator|(
expr|struct
name|DFA_chip
operator|*
operator|)
name|curr_state
operator|->
name|dfa_state
operator|)
operator|->
name|oneb_automaton_state
else|:
operator|(
operator|(
expr|struct
name|DFA_chip
operator|*
operator|)
name|curr_state
operator|->
name|dfa_state
operator|)
operator|->
name|twob_automaton_state
operator|)
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|index_to_bundle_states
index|[
name|insn_num
index|]
operator|==
name|NULL
condition|)
comment|/* We should find a solution because the 2nd insn scheduling has        found one.  */
name|abort
argument_list|()
expr_stmt|;
comment|/* Find a state corresponding to the best insn sequence.  */
name|best_state
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|curr_state
operator|=
name|index_to_bundle_states
index|[
name|insn_num
index|]
init|;
name|curr_state
operator|!=
name|NULL
condition|;
name|curr_state
operator|=
name|curr_state
operator|->
name|next
control|)
comment|/* We are just looking at the states with fully filled up last        bundle.  The first we prefer insn sequences with minimal cost        then with minimal inserted nops and finally with branch insns        placed in the 3rd slots.  */
if|if
condition|(
name|curr_state
operator|->
name|accumulated_insns_num
operator|%
literal|3
operator|==
literal|0
operator|&&
operator|(
name|best_state
operator|==
name|NULL
operator|||
name|best_state
operator|->
name|cost
operator|>
name|curr_state
operator|->
name|cost
operator|||
operator|(
name|best_state
operator|->
name|cost
operator|==
name|curr_state
operator|->
name|cost
operator|&&
operator|(
name|curr_state
operator|->
name|accumulated_insns_num
operator|<
name|best_state
operator|->
name|accumulated_insns_num
operator|||
operator|(
name|curr_state
operator|->
name|accumulated_insns_num
operator|==
name|best_state
operator|->
name|accumulated_insns_num
operator|&&
name|curr_state
operator|->
name|branch_deviation
operator|<
name|best_state
operator|->
name|branch_deviation
operator|)
operator|)
operator|)
operator|)
condition|)
name|best_state
operator|=
name|curr_state
expr_stmt|;
comment|/* Second (backward) pass: adding nops and templates.  */
name|insn_num
operator|=
name|best_state
operator|->
name|before_nops_num
expr_stmt|;
name|template0
operator|=
name|template1
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|curr_state
operator|=
name|best_state
init|;
name|curr_state
operator|->
name|originator
operator|!=
name|NULL
condition|;
name|curr_state
operator|=
name|curr_state
operator|->
name|originator
control|)
block|{
name|insn
operator|=
name|curr_state
operator|->
name|insn
expr_stmt|;
name|asm_p
operator|=
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ASM_INPUT
operator|||
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|>=
literal|0
operator|)
expr_stmt|;
name|insn_num
operator|++
expr_stmt|;
if|if
condition|(
name|verbose
operator|>=
literal|2
operator|&&
name|dump
condition|)
block|{
struct|struct
name|DFA_chip
block|{
name|unsigned
name|short
name|one_automaton_state
decl_stmt|;
name|unsigned
name|short
name|oneb_automaton_state
decl_stmt|;
name|unsigned
name|short
name|two_automaton_state
decl_stmt|;
name|unsigned
name|short
name|twob_automaton_state
decl_stmt|;
block|}
struct|;
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"//    Best %d (orig %d, cost %d, nops %d/%d, insns %d, branch %d, state %d) for %d\n"
argument_list|,
name|curr_state
operator|->
name|unique_num
argument_list|,
operator|(
name|curr_state
operator|->
name|originator
operator|==
name|NULL
condition|?
operator|-
literal|1
else|:
name|curr_state
operator|->
name|originator
operator|->
name|unique_num
operator|)
argument_list|,
name|curr_state
operator|->
name|cost
argument_list|,
name|curr_state
operator|->
name|before_nops_num
argument_list|,
name|curr_state
operator|->
name|after_nops_num
argument_list|,
name|curr_state
operator|->
name|accumulated_insns_num
argument_list|,
name|curr_state
operator|->
name|branch_deviation
argument_list|,
operator|(
name|ia64_tune
operator|==
name|PROCESSOR_ITANIUM
condition|?
operator|(
operator|(
expr|struct
name|DFA_chip
operator|*
operator|)
name|curr_state
operator|->
name|dfa_state
operator|)
operator|->
name|oneb_automaton_state
else|:
operator|(
operator|(
expr|struct
name|DFA_chip
operator|*
operator|)
name|curr_state
operator|->
name|dfa_state
operator|)
operator|->
name|twob_automaton_state
operator|)
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Find the position in the current bundle window.  The window can 	 contain at most two bundles.  Two bundle window means that 	 the processor will make two bundle rotation.  */
name|max_pos
operator|=
name|get_max_pos
argument_list|(
name|curr_state
operator|->
name|dfa_state
argument_list|)
expr_stmt|;
if|if
condition|(
name|max_pos
operator|==
literal|6
comment|/* The following (negative template number) means that the 	     processor did one bundle rotation.  */
operator|||
operator|(
name|max_pos
operator|==
literal|3
operator|&&
name|template0
operator|<
literal|0
operator|)
condition|)
block|{
comment|/* We are at the end of the window -- find template(s) for 	     its bundle(s).  */
name|pos
operator|=
name|max_pos
expr_stmt|;
if|if
condition|(
name|max_pos
operator|==
literal|3
condition|)
name|template0
operator|=
name|get_template
argument_list|(
name|curr_state
operator|->
name|dfa_state
argument_list|,
literal|3
argument_list|)
expr_stmt|;
else|else
block|{
name|template1
operator|=
name|get_template
argument_list|(
name|curr_state
operator|->
name|dfa_state
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|template0
operator|=
name|get_template
argument_list|(
name|curr_state
operator|->
name|dfa_state
argument_list|,
literal|6
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|max_pos
operator|>
literal|3
operator|&&
name|template1
operator|<
literal|0
condition|)
comment|/* It may happen when we have the stop inside a bundle.  */
block|{
if|if
condition|(
name|pos
operator|>
literal|3
condition|)
name|abort
argument_list|()
expr_stmt|;
name|template1
operator|=
name|get_template
argument_list|(
name|curr_state
operator|->
name|dfa_state
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|pos
operator|+=
literal|3
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|asm_p
condition|)
comment|/* Emit nops after the current insn.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|curr_state
operator|->
name|after_nops_num
condition|;
name|i
operator|++
control|)
block|{
name|nop
operator|=
name|gen_nop
argument_list|()
expr_stmt|;
name|emit_insn_after
argument_list|(
name|nop
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|pos
operator|--
expr_stmt|;
if|if
condition|(
name|pos
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|pos
operator|%
literal|3
operator|==
literal|0
condition|)
block|{
comment|/* We are at the start of a bundle: emit the template 		   (it should be defined).  */
if|if
condition|(
name|template0
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|b
operator|=
name|gen_bundle_selector
argument_list|(
name|GEN_INT
argument_list|(
name|template0
argument_list|)
argument_list|)
expr_stmt|;
name|ia64_emit_insn_before
argument_list|(
name|b
argument_list|,
name|nop
argument_list|)
expr_stmt|;
comment|/* If we have two bundle window, we make one bundle 		   rotation.  Otherwise template0 will be undefined 		   (negative value).  */
name|template0
operator|=
name|template1
expr_stmt|;
name|template1
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
comment|/* Move the position backward in the window.  Group barrier has 	 no slot.  Asm insn takes all bundle.  */
if|if
condition|(
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|CODE_FOR_insn_group_barrier
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|ASM_INPUT
operator|&&
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|pos
operator|--
expr_stmt|;
comment|/* Long insn takes 2 slots.  */
if|if
condition|(
name|ia64_safe_type
argument_list|(
name|insn
argument_list|)
operator|==
name|TYPE_L
condition|)
name|pos
operator|--
expr_stmt|;
if|if
condition|(
name|pos
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|pos
operator|%
literal|3
operator|==
literal|0
operator|&&
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|CODE_FOR_insn_group_barrier
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|ASM_INPUT
operator|&&
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* The current insn is at the bundle start: emit the 	     template.  */
if|if
condition|(
name|template0
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|b
operator|=
name|gen_bundle_selector
argument_list|(
name|GEN_INT
argument_list|(
name|template0
argument_list|)
argument_list|)
expr_stmt|;
name|ia64_emit_insn_before
argument_list|(
name|b
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|b
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|insn
operator|=
name|b
expr_stmt|;
comment|/* See comment above in analogous place for emiting nops 	     after the insn.  */
name|template0
operator|=
name|template1
expr_stmt|;
name|template1
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Emit nops after the current insn.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|curr_state
operator|->
name|before_nops_num
condition|;
name|i
operator|++
control|)
block|{
name|nop
operator|=
name|gen_nop
argument_list|()
expr_stmt|;
name|ia64_emit_insn_before
argument_list|(
name|nop
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|nop
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|insn
operator|=
name|nop
expr_stmt|;
name|pos
operator|--
expr_stmt|;
if|if
condition|(
name|pos
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|pos
operator|%
literal|3
operator|==
literal|0
condition|)
block|{
comment|/* See comment above in analogous place for emiting nops 		 after the insn.  */
if|if
condition|(
name|template0
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|b
operator|=
name|gen_bundle_selector
argument_list|(
name|GEN_INT
argument_list|(
name|template0
argument_list|)
argument_list|)
expr_stmt|;
name|ia64_emit_insn_before
argument_list|(
name|b
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|b
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|insn
operator|=
name|b
expr_stmt|;
name|template0
operator|=
name|template1
expr_stmt|;
name|template1
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|ia64_tune
operator|==
name|PROCESSOR_ITANIUM
condition|)
comment|/* Insert additional cycles for MM-insns (MMMUL and MMSHF).        Itanium1 has a strange design, if the distance between an insn        and dependent MM-insn is less 4 then we have a 6 additional        cycles stall.  So we make the distance equal to 4 cycles if it        is less.  */
for|for
control|(
name|insn
operator|=
name|get_next_important_insn
argument_list|(
name|NEXT_INSN
argument_list|(
name|prev_head_insn
argument_list|)
argument_list|,
name|tail
argument_list|)
init|;
name|insn
operator|!=
name|NULL_RTX
condition|;
name|insn
operator|=
name|next_insn
control|)
block|{
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|||
name|ia64_safe_itanium_class
argument_list|(
name|insn
argument_list|)
operator|==
name|ITANIUM_CLASS_IGNORE
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
name|abort
argument_list|()
expr_stmt|;
name|next_insn
operator|=
name|get_next_important_insn
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|tail
argument_list|)
expr_stmt|;
if|if
condition|(
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|<
name|clocks_length
operator|&&
name|add_cycles
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
condition|)
comment|/* We found a MM-insn which needs additional cycles.  */
block|{
name|rtx
name|last
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|n
decl_stmt|;
name|int
name|pred_stop_p
decl_stmt|;
comment|/* Now we are searching for a template of the bundle in 	       which the MM-insn is placed and the position of the 	       insn in the bundle (0, 1, 2).  Also we are searching 	       for that there is a stop before the insn.  */
name|last
operator|=
name|prev_active_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|pred_stop_p
operator|=
name|recog_memoized
argument_list|(
name|last
argument_list|)
operator|==
name|CODE_FOR_insn_group_barrier
expr_stmt|;
if|if
condition|(
name|pred_stop_p
condition|)
name|last
operator|=
name|prev_active_insn
argument_list|(
name|last
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
name|last
operator|=
name|prev_active_insn
argument_list|(
name|last
argument_list|)
control|)
if|if
condition|(
name|recog_memoized
argument_list|(
name|last
argument_list|)
operator|==
name|CODE_FOR_bundle_selector
condition|)
block|{
name|template0
operator|=
name|XINT
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|last
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|template0
operator|==
literal|9
condition|)
comment|/* The insn is in MLX bundle.  Change the template 		       onto MFI because we will add nops before the 		       insn.  It simplifies subsequent code a lot.  */
name|PATTERN
argument_list|(
name|last
argument_list|)
operator|=
name|gen_bundle_selector
argument_list|(
name|GEN_INT
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* -> MFI */
break|break;
block|}
elseif|else
if|if
condition|(
name|recog_memoized
argument_list|(
name|last
argument_list|)
operator|!=
name|CODE_FOR_insn_group_barrier
operator|&&
operator|(
name|ia64_safe_itanium_class
argument_list|(
name|last
argument_list|)
operator|!=
name|ITANIUM_CLASS_IGNORE
operator|)
condition|)
name|n
operator|++
expr_stmt|;
comment|/* Some check of correctness: the stop is not at the 	       bundle start, there are no more 3 insns in the bundle, 	       and the MM-insn is not at the start of bundle with 	       template MLX.  */
if|if
condition|(
operator|(
name|pred_stop_p
operator|&&
name|n
operator|==
literal|0
operator|)
operator|||
name|n
operator|>
literal|2
operator|||
operator|(
name|template0
operator|==
literal|9
operator|&&
name|n
operator|!=
literal|0
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Put nops after the insn in the bundle.  */
for|for
control|(
name|j
operator|=
literal|3
operator|-
name|n
init|;
name|j
operator|>
literal|0
condition|;
name|j
operator|--
control|)
name|ia64_emit_insn_before
argument_list|(
name|gen_nop
argument_list|()
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* It takes into account that we will add more N nops 	       before the insn lately -- please see code below.  */
name|add_cycles
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|pred_stop_p
operator|||
name|add_cycles
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
condition|)
name|ia64_emit_insn_before
argument_list|(
name|gen_insn_group_barrier
argument_list|(
name|GEN_INT
argument_list|(
literal|3
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|pred_stop_p
condition|)
name|add_cycles
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
operator|--
expr_stmt|;
for|for
control|(
name|i
operator|=
name|add_cycles
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
comment|/* Insert "MII;" template.  */
name|ia64_emit_insn_before
argument_list|(
name|gen_bundle_selector
argument_list|(
name|GEN_INT
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|ia64_emit_insn_before
argument_list|(
name|gen_nop
argument_list|()
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|ia64_emit_insn_before
argument_list|(
name|gen_nop
argument_list|()
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|1
condition|)
block|{
comment|/* To decrease code size, we use "MI;I;" 		       template.  */
name|ia64_emit_insn_before
argument_list|(
name|gen_insn_group_barrier
argument_list|(
name|GEN_INT
argument_list|(
literal|3
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|i
operator|--
expr_stmt|;
block|}
name|ia64_emit_insn_before
argument_list|(
name|gen_nop
argument_list|()
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|ia64_emit_insn_before
argument_list|(
name|gen_insn_group_barrier
argument_list|(
name|GEN_INT
argument_list|(
literal|3
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* Put the MM-insn in the same slot of a bundle with the 	       same template as the original one.  */
name|ia64_emit_insn_before
argument_list|(
name|gen_bundle_selector
argument_list|(
name|GEN_INT
argument_list|(
name|template0
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* To put the insn in the same slot, add necessary number 	       of nops.  */
for|for
control|(
name|j
operator|=
name|n
init|;
name|j
operator|>
literal|0
condition|;
name|j
operator|--
control|)
name|ia64_emit_insn_before
argument_list|(
name|gen_nop
argument_list|()
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* Put the stop if the original bundle had it.  */
if|if
condition|(
name|pred_stop_p
condition|)
name|ia64_emit_insn_before
argument_list|(
name|gen_insn_group_barrier
argument_list|(
name|GEN_INT
argument_list|(
literal|3
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|index_to_bundle_states
argument_list|)
expr_stmt|;
name|finish_bundle_state_table
argument_list|()
expr_stmt|;
name|bundling_p
operator|=
literal|0
expr_stmt|;
name|dfa_clean_insn_cache
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The following function is called at the end of scheduling BB or    EBB.  After reload, it inserts stop bits and does insn bundling.  */
end_comment

begin_function
specifier|static
name|void
name|ia64_sched_finish
parameter_list|(
name|FILE
modifier|*
name|dump
parameter_list|,
name|int
name|sched_verbose
parameter_list|)
block|{
if|if
condition|(
name|sched_verbose
condition|)
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"// Finishing schedule.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reload_completed
condition|)
return|return;
if|if
condition|(
name|reload_completed
condition|)
block|{
name|final_emit_insn_group_barriers
argument_list|(
name|dump
argument_list|)
expr_stmt|;
name|bundling
argument_list|(
name|dump
argument_list|,
name|sched_verbose
argument_list|,
name|current_sched_info
operator|->
name|prev_head
argument_list|,
name|current_sched_info
operator|->
name|next_tail
argument_list|)
expr_stmt|;
if|if
condition|(
name|sched_verbose
operator|&&
name|dump
condition|)
name|fprintf
argument_list|(
name|dump
argument_list|,
literal|"//    finishing %d-%d\n"
argument_list|,
name|INSN_UID
argument_list|(
name|NEXT_INSN
argument_list|(
name|current_sched_info
operator|->
name|prev_head
argument_list|)
argument_list|)
argument_list|,
name|INSN_UID
argument_list|(
name|PREV_INSN
argument_list|(
name|current_sched_info
operator|->
name|next_tail
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_comment
comment|/* The following function inserts stop bits in scheduled BB or EBB.  */
end_comment

begin_function
specifier|static
name|void
name|final_emit_insn_group_barriers
parameter_list|(
name|FILE
modifier|*
name|dump
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
name|int
name|need_barrier_p
init|=
literal|0
decl_stmt|;
name|rtx
name|prev_insn
init|=
name|NULL_RTX
decl_stmt|;
name|init_insn_group_barriers
argument_list|()
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|current_sched_info
operator|->
name|prev_head
argument_list|)
init|;
name|insn
operator|!=
name|current_sched_info
operator|->
name|next_tail
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|BARRIER
condition|)
block|{
name|rtx
name|last
init|=
name|prev_active_insn
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|last
condition|)
continue|continue;
if|if
condition|(
name|GET_CODE
argument_list|(
name|last
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|last
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
condition|)
name|last
operator|=
name|prev_active_insn
argument_list|(
name|last
argument_list|)
expr_stmt|;
if|if
condition|(
name|recog_memoized
argument_list|(
name|last
argument_list|)
operator|!=
name|CODE_FOR_insn_group_barrier
condition|)
name|emit_insn_after
argument_list|(
name|gen_insn_group_barrier
argument_list|(
name|GEN_INT
argument_list|(
literal|3
argument_list|)
argument_list|)
argument_list|,
name|last
argument_list|)
expr_stmt|;
name|init_insn_group_barriers
argument_list|()
expr_stmt|;
name|need_barrier_p
operator|=
literal|0
expr_stmt|;
name|prev_insn
operator|=
name|NULL_RTX
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
if|if
condition|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_FOR_insn_group_barrier
condition|)
block|{
name|init_insn_group_barriers
argument_list|()
expr_stmt|;
name|need_barrier_p
operator|=
literal|0
expr_stmt|;
name|prev_insn
operator|=
name|NULL_RTX
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|need_barrier_p
operator|||
name|group_barrier_needed_p
argument_list|(
name|insn
argument_list|)
condition|)
block|{
if|if
condition|(
name|TARGET_EARLY_STOP_BITS
condition|)
block|{
name|rtx
name|last
decl_stmt|;
for|for
control|(
name|last
operator|=
name|insn
init|;
name|last
operator|!=
name|current_sched_info
operator|->
name|prev_head
condition|;
name|last
operator|=
name|PREV_INSN
argument_list|(
name|last
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|last
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|last
argument_list|)
operator|==
name|TImode
operator|&&
name|stops_p
index|[
name|INSN_UID
argument_list|(
name|last
argument_list|)
index|]
condition|)
break|break;
if|if
condition|(
name|last
operator|==
name|current_sched_info
operator|->
name|prev_head
condition|)
name|last
operator|=
name|insn
expr_stmt|;
name|last
operator|=
name|prev_active_insn
argument_list|(
name|last
argument_list|)
expr_stmt|;
if|if
condition|(
name|last
operator|&&
name|recog_memoized
argument_list|(
name|last
argument_list|)
operator|!=
name|CODE_FOR_insn_group_barrier
condition|)
name|emit_insn_after
argument_list|(
name|gen_insn_group_barrier
argument_list|(
name|GEN_INT
argument_list|(
literal|3
argument_list|)
argument_list|)
argument_list|,
name|last
argument_list|)
expr_stmt|;
name|init_insn_group_barriers
argument_list|()
expr_stmt|;
for|for
control|(
name|last
operator|=
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
init|;
name|last
operator|!=
name|insn
condition|;
name|last
operator|=
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|last
argument_list|)
condition|)
name|group_barrier_needed_p
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|emit_insn_before
argument_list|(
name|gen_insn_group_barrier
argument_list|(
name|GEN_INT
argument_list|(
literal|3
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|init_insn_group_barriers
argument_list|()
expr_stmt|;
block|}
name|group_barrier_needed_p
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|prev_insn
operator|=
name|NULL_RTX
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|>=
literal|0
condition|)
name|prev_insn
operator|=
name|insn
expr_stmt|;
name|need_barrier_p
operator|=
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ASM_INPUT
operator|||
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|>=
literal|0
operator|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If the following function returns TRUE, we will use the the DFA    insn scheduler.  */
end_comment

begin_function
specifier|static
name|int
name|ia64_use_dfa_pipeline_interface
parameter_list|(
name|void
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* If the following function returns TRUE, we will use the the DFA    insn scheduler.  */
end_comment

begin_function
specifier|static
name|int
name|ia64_first_cycle_multipass_dfa_lookahead
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|reload_completed
condition|?
literal|6
else|:
literal|4
operator|)
return|;
block|}
end_function

begin_comment
comment|/* The following function initiates variable `dfa_pre_cycle_insn'.  */
end_comment

begin_function
specifier|static
name|void
name|ia64_init_dfa_pre_cycle_insn
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|temp_dfa_state
operator|==
name|NULL
condition|)
block|{
name|dfa_state_size
operator|=
name|state_size
argument_list|()
expr_stmt|;
name|temp_dfa_state
operator|=
name|xmalloc
argument_list|(
name|dfa_state_size
argument_list|)
expr_stmt|;
name|prev_cycle_state
operator|=
name|xmalloc
argument_list|(
name|dfa_state_size
argument_list|)
expr_stmt|;
block|}
name|dfa_pre_cycle_insn
operator|=
name|make_insn_raw
argument_list|(
name|gen_pre_cycle
argument_list|()
argument_list|)
expr_stmt|;
name|PREV_INSN
argument_list|(
name|dfa_pre_cycle_insn
argument_list|)
operator|=
name|NEXT_INSN
argument_list|(
name|dfa_pre_cycle_insn
argument_list|)
operator|=
name|NULL_RTX
expr_stmt|;
name|recog_memoized
argument_list|(
name|dfa_pre_cycle_insn
argument_list|)
expr_stmt|;
name|dfa_stop_insn
operator|=
name|make_insn_raw
argument_list|(
name|gen_insn_group_barrier
argument_list|(
name|GEN_INT
argument_list|(
literal|3
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|PREV_INSN
argument_list|(
name|dfa_stop_insn
argument_list|)
operator|=
name|NEXT_INSN
argument_list|(
name|dfa_stop_insn
argument_list|)
operator|=
name|NULL_RTX
expr_stmt|;
name|recog_memoized
argument_list|(
name|dfa_stop_insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The following function returns the pseudo insn DFA_PRE_CYCLE_INSN    used by the DFA insn scheduler.  */
end_comment

begin_function
specifier|static
name|rtx
name|ia64_dfa_pre_cycle_insn
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|dfa_pre_cycle_insn
return|;
block|}
end_function

begin_comment
comment|/* The following function returns TRUE if PRODUCER (of type ilog or    ld) produces address for CONSUMER (of type st or stf). */
end_comment

begin_function
name|int
name|ia64_st_address_bypass_p
parameter_list|(
name|rtx
name|producer
parameter_list|,
name|rtx
name|consumer
parameter_list|)
block|{
name|rtx
name|dest
decl_stmt|,
name|reg
decl_stmt|,
name|mem
decl_stmt|;
if|if
condition|(
name|producer
operator|==
name|NULL_RTX
operator|||
name|consumer
operator|==
name|NULL_RTX
condition|)
name|abort
argument_list|()
expr_stmt|;
name|dest
operator|=
name|ia64_single_set
argument_list|(
name|producer
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest
operator|==
name|NULL_RTX
operator|||
operator|(
name|reg
operator|=
name|SET_DEST
argument_list|(
name|dest
argument_list|)
operator|)
operator|==
name|NULL_RTX
operator|||
operator|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|!=
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|!=
name|SUBREG
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
condition|)
name|reg
operator|=
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|dest
operator|=
name|ia64_single_set
argument_list|(
name|consumer
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest
operator|==
name|NULL_RTX
operator|||
operator|(
name|mem
operator|=
name|SET_DEST
argument_list|(
name|dest
argument_list|)
operator|)
operator|==
name|NULL_RTX
operator|||
name|GET_CODE
argument_list|(
name|mem
argument_list|)
operator|!=
name|MEM
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|reg_mentioned_p
argument_list|(
name|reg
argument_list|,
name|mem
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The following function returns TRUE if PRODUCER (of type ilog or    ld) produces address for CONSUMER (of type ld or fld). */
end_comment

begin_function
name|int
name|ia64_ld_address_bypass_p
parameter_list|(
name|rtx
name|producer
parameter_list|,
name|rtx
name|consumer
parameter_list|)
block|{
name|rtx
name|dest
decl_stmt|,
name|src
decl_stmt|,
name|reg
decl_stmt|,
name|mem
decl_stmt|;
if|if
condition|(
name|producer
operator|==
name|NULL_RTX
operator|||
name|consumer
operator|==
name|NULL_RTX
condition|)
name|abort
argument_list|()
expr_stmt|;
name|dest
operator|=
name|ia64_single_set
argument_list|(
name|producer
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest
operator|==
name|NULL_RTX
operator|||
operator|(
name|reg
operator|=
name|SET_DEST
argument_list|(
name|dest
argument_list|)
operator|)
operator|==
name|NULL_RTX
operator|||
operator|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|!=
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|!=
name|SUBREG
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
condition|)
name|reg
operator|=
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|src
operator|=
name|ia64_single_set
argument_list|(
name|consumer
argument_list|)
expr_stmt|;
if|if
condition|(
name|src
operator|==
name|NULL_RTX
operator|||
operator|(
name|mem
operator|=
name|SET_SRC
argument_list|(
name|src
argument_list|)
operator|)
operator|==
name|NULL_RTX
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|mem
argument_list|)
operator|==
name|UNSPEC
operator|&&
name|XVECLEN
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
operator|>
literal|0
condition|)
name|mem
operator|=
name|XVECEXP
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|mem
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|mem
argument_list|)
operator|==
name|ZERO_EXTEND
condition|)
name|mem
operator|=
name|XEXP
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Note that LO_SUM is used for GOT loads.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|mem
argument_list|)
operator|!=
name|LO_SUM
operator|&&
name|GET_CODE
argument_list|(
name|mem
argument_list|)
operator|!=
name|MEM
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|reg_mentioned_p
argument_list|(
name|reg
argument_list|,
name|mem
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The following function returns TRUE if INSN produces address for a    load/store insn.  We will place such insns into M slot because it    decreases its latency time. */
end_comment

begin_function
name|int
name|ia64_produce_address_p
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
return|return
name|insn
operator|->
name|call
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit pseudo-ops for the assembler to describe predicate relations.    At present this assumes that we only consider predicate pairs to    be mutex, and that the assembler can deduce proper values from    straight-line code.  */
end_comment

begin_function
specifier|static
name|void
name|emit_predicate_relation_info
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|FOR_EACH_BB_REVERSE
argument_list|(
argument|bb
argument_list|)
block|{
name|int
name|r
decl_stmt|;
name|rtx
name|head
init|=
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
decl_stmt|;
comment|/* We only need such notes at code labels.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|head
argument_list|)
operator|!=
name|CODE_LABEL
condition|)
continue|continue;
if|if
condition|(
name|GET_CODE
argument_list|(
name|NEXT_INSN
argument_list|(
name|head
argument_list|)
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|NEXT_INSN
argument_list|(
name|head
argument_list|)
argument_list|)
operator|==
name|NOTE_INSN_BASIC_BLOCK
condition|)
name|head
operator|=
name|NEXT_INSN
argument_list|(
name|head
argument_list|)
expr_stmt|;
for|for
control|(
name|r
operator|=
name|PR_REG
argument_list|(
literal|0
argument_list|)
init|;
name|r
operator|<
name|PR_REG
argument_list|(
literal|64
argument_list|)
condition|;
name|r
operator|+=
literal|2
control|)
if|if
condition|(
name|REGNO_REG_SET_P
argument_list|(
name|bb
operator|->
name|global_live_at_start
argument_list|,
name|r
argument_list|)
condition|)
block|{
name|rtx
name|p
init|=
name|gen_rtx_REG
argument_list|(
name|BImode
argument_list|,
name|r
argument_list|)
decl_stmt|;
name|rtx
name|n
init|=
name|emit_insn_after
argument_list|(
name|gen_pred_rel_mutex
argument_list|(
name|p
argument_list|)
argument_list|,
name|head
argument_list|)
decl_stmt|;
if|if
condition|(
name|head
operator|==
name|BB_END
argument_list|(
name|bb
argument_list|)
condition|)
name|BB_END
argument_list|(
name|bb
argument_list|)
operator|=
name|n
expr_stmt|;
name|head
operator|=
name|n
expr_stmt|;
block|}
block|}
comment|/* Look for conditional calls that do not return, and protect predicate      relations around them.  Otherwise the assembler will assume the call      returns, and complain about uses of call-clobbered predicates after      the call.  */
name|FOR_EACH_BB_REVERSE
argument_list|(
argument|bb
argument_list|)
block|{
name|rtx
name|insn
init|=
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|COND_EXEC
operator|&&
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_NORETURN
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
block|{
name|rtx
name|b
init|=
name|emit_insn_before
argument_list|(
name|gen_safe_across_calls_all
argument_list|()
argument_list|,
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|a
init|=
name|emit_insn_after
argument_list|(
name|gen_safe_across_calls_normal
argument_list|()
argument_list|,
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
operator|==
name|insn
condition|)
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
operator|=
name|b
expr_stmt|;
if|if
condition|(
name|BB_END
argument_list|(
name|bb
argument_list|)
operator|==
name|insn
condition|)
name|BB_END
argument_list|(
name|bb
argument_list|)
operator|=
name|a
expr_stmt|;
block|}
if|if
condition|(
name|insn
operator|==
name|BB_END
argument_list|(
name|bb
argument_list|)
condition|)
break|break;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Perform machine dependent operations on the rtl chain INSNS.  */
end_comment

begin_function
specifier|static
name|void
name|ia64_reorg
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* We are freeing block_for_insn in the toplev to keep compatibility      with old MDEP_REORGS that are not CFG based.  Recompute it now.  */
name|compute_bb_for_insn
argument_list|()
expr_stmt|;
comment|/* If optimizing, we'll have split before scheduling.  */
if|if
condition|(
name|optimize
operator|==
literal|0
condition|)
name|split_all_insns
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* ??? update_life_info_in_dirty_blocks fails to terminate during      non-optimizing bootstrap.  */
name|update_life_info
argument_list|(
name|NULL
argument_list|,
name|UPDATE_LIFE_GLOBAL_RM_NOTES
argument_list|,
name|PROP_DEATH_NOTES
argument_list|)
expr_stmt|;
if|if
condition|(
name|ia64_flag_schedule_insns2
condition|)
block|{
name|timevar_push
argument_list|(
name|TV_SCHED2
argument_list|)
expr_stmt|;
name|ia64_final_schedule
operator|=
literal|1
expr_stmt|;
name|initiate_bundle_states
argument_list|()
expr_stmt|;
name|ia64_nop
operator|=
name|make_insn_raw
argument_list|(
name|gen_nop
argument_list|()
argument_list|)
expr_stmt|;
name|PREV_INSN
argument_list|(
name|ia64_nop
argument_list|)
operator|=
name|NEXT_INSN
argument_list|(
name|ia64_nop
argument_list|)
operator|=
name|NULL_RTX
expr_stmt|;
name|recog_memoized
argument_list|(
name|ia64_nop
argument_list|)
expr_stmt|;
name|clocks_length
operator|=
name|get_max_uid
argument_list|()
operator|+
literal|1
expr_stmt|;
name|stops_p
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
name|clocks_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|ia64_tune
operator|==
name|PROCESSOR_ITANIUM
condition|)
block|{
name|clocks
operator|=
name|xcalloc
argument_list|(
name|clocks_length
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|add_cycles
operator|=
name|xcalloc
argument_list|(
name|clocks_length
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ia64_tune
operator|==
name|PROCESSOR_ITANIUM2
condition|)
block|{
name|pos_1
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"2_1"
argument_list|)
expr_stmt|;
name|pos_2
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"2_2"
argument_list|)
expr_stmt|;
name|pos_3
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"2_3"
argument_list|)
expr_stmt|;
name|pos_4
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"2_4"
argument_list|)
expr_stmt|;
name|pos_5
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"2_5"
argument_list|)
expr_stmt|;
name|pos_6
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"2_6"
argument_list|)
expr_stmt|;
name|_0mii_
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"2b_0mii."
argument_list|)
expr_stmt|;
name|_0mmi_
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"2b_0mmi."
argument_list|)
expr_stmt|;
name|_0mfi_
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"2b_0mfi."
argument_list|)
expr_stmt|;
name|_0mmf_
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"2b_0mmf."
argument_list|)
expr_stmt|;
name|_0bbb_
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"2b_0bbb."
argument_list|)
expr_stmt|;
name|_0mbb_
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"2b_0mbb."
argument_list|)
expr_stmt|;
name|_0mib_
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"2b_0mib."
argument_list|)
expr_stmt|;
name|_0mmb_
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"2b_0mmb."
argument_list|)
expr_stmt|;
name|_0mfb_
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"2b_0mfb."
argument_list|)
expr_stmt|;
name|_0mlx_
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"2b_0mlx."
argument_list|)
expr_stmt|;
name|_1mii_
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"2b_1mii."
argument_list|)
expr_stmt|;
name|_1mmi_
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"2b_1mmi."
argument_list|)
expr_stmt|;
name|_1mfi_
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"2b_1mfi."
argument_list|)
expr_stmt|;
name|_1mmf_
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"2b_1mmf."
argument_list|)
expr_stmt|;
name|_1bbb_
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"2b_1bbb."
argument_list|)
expr_stmt|;
name|_1mbb_
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"2b_1mbb."
argument_list|)
expr_stmt|;
name|_1mib_
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"2b_1mib."
argument_list|)
expr_stmt|;
name|_1mmb_
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"2b_1mmb."
argument_list|)
expr_stmt|;
name|_1mfb_
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"2b_1mfb."
argument_list|)
expr_stmt|;
name|_1mlx_
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"2b_1mlx."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pos_1
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"1_1"
argument_list|)
expr_stmt|;
name|pos_2
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"1_2"
argument_list|)
expr_stmt|;
name|pos_3
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"1_3"
argument_list|)
expr_stmt|;
name|pos_4
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"1_4"
argument_list|)
expr_stmt|;
name|pos_5
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"1_5"
argument_list|)
expr_stmt|;
name|pos_6
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"1_6"
argument_list|)
expr_stmt|;
name|_0mii_
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"1b_0mii."
argument_list|)
expr_stmt|;
name|_0mmi_
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"1b_0mmi."
argument_list|)
expr_stmt|;
name|_0mfi_
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"1b_0mfi."
argument_list|)
expr_stmt|;
name|_0mmf_
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"1b_0mmf."
argument_list|)
expr_stmt|;
name|_0bbb_
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"1b_0bbb."
argument_list|)
expr_stmt|;
name|_0mbb_
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"1b_0mbb."
argument_list|)
expr_stmt|;
name|_0mib_
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"1b_0mib."
argument_list|)
expr_stmt|;
name|_0mmb_
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"1b_0mmb."
argument_list|)
expr_stmt|;
name|_0mfb_
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"1b_0mfb."
argument_list|)
expr_stmt|;
name|_0mlx_
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"1b_0mlx."
argument_list|)
expr_stmt|;
name|_1mii_
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"1b_1mii."
argument_list|)
expr_stmt|;
name|_1mmi_
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"1b_1mmi."
argument_list|)
expr_stmt|;
name|_1mfi_
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"1b_1mfi."
argument_list|)
expr_stmt|;
name|_1mmf_
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"1b_1mmf."
argument_list|)
expr_stmt|;
name|_1bbb_
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"1b_1bbb."
argument_list|)
expr_stmt|;
name|_1mbb_
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"1b_1mbb."
argument_list|)
expr_stmt|;
name|_1mib_
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"1b_1mib."
argument_list|)
expr_stmt|;
name|_1mmb_
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"1b_1mmb."
argument_list|)
expr_stmt|;
name|_1mfb_
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"1b_1mfb."
argument_list|)
expr_stmt|;
name|_1mlx_
operator|=
name|get_cpu_unit_code
argument_list|(
literal|"1b_1mlx."
argument_list|)
expr_stmt|;
block|}
name|schedule_ebbs
argument_list|(
name|rtl_dump_file
argument_list|)
expr_stmt|;
name|finish_bundle_states
argument_list|()
expr_stmt|;
if|if
condition|(
name|ia64_tune
operator|==
name|PROCESSOR_ITANIUM
condition|)
block|{
name|free
argument_list|(
name|add_cycles
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|clocks
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|stops_p
argument_list|)
expr_stmt|;
name|emit_insn_group_barriers
argument_list|(
name|rtl_dump_file
argument_list|)
expr_stmt|;
name|ia64_final_schedule
operator|=
literal|0
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_SCHED2
argument_list|)
expr_stmt|;
block|}
else|else
name|emit_all_insn_group_barriers
argument_list|(
name|rtl_dump_file
argument_list|)
expr_stmt|;
comment|/* A call must not be the last instruction in a function, so that the      return address is still within the function, so that unwinding works      properly.  Note that IA-64 differs from dwarf2 on this point.  */
if|if
condition|(
name|flag_unwind_tables
operator|||
operator|(
name|flag_exceptions
operator|&&
operator|!
name|USING_SJLJ_EXCEPTIONS
operator|)
condition|)
block|{
name|rtx
name|insn
decl_stmt|;
name|int
name|saw_stop
init|=
literal|0
decl_stmt|;
name|insn
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
name|insn
operator|=
name|prev_active_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Skip over insns that expand to nothing.  */
while|while
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|get_attr_empty
argument_list|(
name|insn
argument_list|)
operator|==
name|EMPTY_YES
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|UNSPEC_VOLATILE
operator|&&
name|XINT
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPECV_INSN_GROUP_BARRIER
condition|)
name|saw_stop
operator|=
literal|1
expr_stmt|;
name|insn
operator|=
name|prev_active_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
if|if
condition|(
operator|!
name|saw_stop
condition|)
name|emit_insn
argument_list|(
name|gen_insn_group_barrier
argument_list|(
name|GEN_INT
argument_list|(
literal|3
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_break_f
argument_list|()
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_insn_group_barrier
argument_list|(
name|GEN_INT
argument_list|(
literal|3
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|fixup_errata
argument_list|()
expr_stmt|;
name|emit_predicate_relation_info
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return true if REGNO is used by the epilogue.  */
end_comment

begin_function
name|int
name|ia64_epilogue_uses
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
switch|switch
condition|(
name|regno
condition|)
block|{
case|case
name|R_GR
argument_list|(
literal|1
argument_list|)
case|:
comment|/* With a call to a function in another module, we will write a new 	 value to "gp".  After returning from such a call, we need to make 	 sure the function restores the original gp-value, even if the 	 function itself does not use the gp anymore.  */
return|return
operator|!
operator|(
name|TARGET_AUTO_PIC
operator|||
name|TARGET_NO_PIC
operator|)
return|;
case|case
name|IN_REG
argument_list|(
literal|0
argument_list|)
case|:
case|case
name|IN_REG
argument_list|(
literal|1
argument_list|)
case|:
case|case
name|IN_REG
argument_list|(
literal|2
argument_list|)
case|:
case|case
name|IN_REG
argument_list|(
literal|3
argument_list|)
case|:
case|case
name|IN_REG
argument_list|(
literal|4
argument_list|)
case|:
case|case
name|IN_REG
argument_list|(
literal|5
argument_list|)
case|:
case|case
name|IN_REG
argument_list|(
literal|6
argument_list|)
case|:
case|case
name|IN_REG
argument_list|(
literal|7
argument_list|)
case|:
comment|/* For functions defined with the syscall_linkage attribute, all 	 input registers are marked as live at all function exits.  This 	 prevents the register allocator from using the input registers, 	 which in turn makes it possible to restart a system call after 	 an interrupt without having to save/restore the input registers. 	 This also prevents kernel data from leaking to application code.  */
return|return
name|lookup_attribute
argument_list|(
literal|"syscall_linkage"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|NULL
return|;
case|case
name|R_BR
argument_list|(
literal|0
argument_list|)
case|:
comment|/* Conditional return patterns can't represent the use of `b0' as          the return address, so we force the value live this way.  */
return|return
literal|1
return|;
case|case
name|AR_PFS_REGNUM
case|:
comment|/* Likewise for ar.pfs, which is used by br.ret.  */
return|return
literal|1
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return true if REGNO is used by the frame unwinder.  */
end_comment

begin_function
name|int
name|ia64_eh_uses
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
if|if
condition|(
operator|!
name|reload_completed
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_b0
operator|&&
name|regno
operator|==
name|current_frame_info
operator|.
name|reg_save_b0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_pr
operator|&&
name|regno
operator|==
name|current_frame_info
operator|.
name|reg_save_pr
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_ar_pfs
operator|&&
name|regno
operator|==
name|current_frame_info
operator|.
name|reg_save_ar_pfs
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_ar_unat
operator|&&
name|regno
operator|==
name|current_frame_info
operator|.
name|reg_save_ar_unat
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_ar_lc
operator|&&
name|regno
operator|==
name|current_frame_info
operator|.
name|reg_save_ar_lc
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return true if this goes in small data/bss.  */
end_comment

begin_comment
comment|/* ??? We could also support own long data here.  Generating movl/add/ld8    instead of addl,ld8/ld8.  This makes the code bigger, but should make the    code faster because there is one less load.  This also includes incomplete    types which can't go in sdata/sbss.  */
end_comment

begin_function
specifier|static
name|bool
name|ia64_in_small_data_p
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
if|if
condition|(
name|TARGET_NO_SDATA
condition|)
return|return
name|false
return|;
comment|/* We want to merge strings, so we never consider them small data.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|STRING_CST
condition|)
return|return
name|false
return|;
comment|/* Functions are never small data.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
return|return
name|false
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_SECTION_NAME
argument_list|(
name|exp
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|section
init|=
name|TREE_STRING_POINTER
argument_list|(
name|DECL_SECTION_NAME
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|section
argument_list|,
literal|".sdata"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|section
argument_list|,
literal|".sbss"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|true
return|;
block|}
else|else
block|{
name|HOST_WIDE_INT
name|size
init|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
comment|/* If this is an incomplete type with size 0, then we can't put it 	 in sdata because it might be too big when completed.  */
if|if
condition|(
name|size
operator|>
literal|0
operator|&&
name|size
operator|<=
name|ia64_section_threshold
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output assembly directives for prologue regions.  */
end_comment

begin_comment
comment|/* The current basic block number.  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|last_block
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True if we need a copy_state command at the start of the next block.  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|need_copy_state
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The function emits unwind directives for the start of an epilogue.  */
end_comment

begin_function
specifier|static
name|void
name|process_epilogue
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* If this isn't the last block of the function, then we need to label the      current state, and copy it back in at the start of the next block.  */
if|if
condition|(
operator|!
name|last_block
condition|)
block|{
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.label_state 1\n"
argument_list|)
expr_stmt|;
name|need_copy_state
operator|=
name|true
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.restore sp\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function processes a SET pattern looking for specific patterns    which result in emitting an assembly directive required for unwinding.  */
end_comment

begin_function
specifier|static
name|int
name|process_set
parameter_list|(
name|FILE
modifier|*
name|asm_out_file
parameter_list|,
name|rtx
name|pat
parameter_list|)
block|{
name|rtx
name|src
init|=
name|SET_SRC
argument_list|(
name|pat
argument_list|)
decl_stmt|;
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|pat
argument_list|)
decl_stmt|;
name|int
name|src_regno
decl_stmt|,
name|dest_regno
decl_stmt|;
comment|/* Look for the ALLOC insn.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|UNSPEC_VOLATILE
operator|&&
name|XINT
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPECV_ALLOC
operator|&&
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
condition|)
block|{
name|dest_regno
operator|=
name|REGNO
argument_list|(
name|dest
argument_list|)
expr_stmt|;
comment|/* If this is the final destination for ar.pfs, then this must 	 be the alloc in the prologue.  */
if|if
condition|(
name|dest_regno
operator|==
name|current_frame_info
operator|.
name|reg_save_ar_pfs
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.save ar.pfs, r%d\n"
argument_list|,
name|ia64_dbx_register_number
argument_list|(
name|dest_regno
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* This must be an alloc before a sibcall.  We must drop the 	     old frame info.  The easiest way to drop the old frame 	     info is to ensure we had a ".restore sp" directive 	     followed by a new prologue.  If the procedure doesn't 	     have a memory-stack frame, we'll issue a dummy ".restore 	     sp" now.  */
if|if
condition|(
name|current_frame_info
operator|.
name|total_size
operator|==
literal|0
operator|&&
operator|!
name|frame_pointer_needed
condition|)
comment|/* if haven't done process_epilogue() yet, do it now */
name|process_epilogue
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.prologue\n"
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
comment|/* Look for SP = ....  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|dest
argument_list|)
operator|==
name|STACK_POINTER_REGNUM
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|rtx
name|op0
init|=
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|op0
operator|==
name|dest
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.fframe "
name|HOST_WIDE_INT_PRINT_DEC
literal|"\n"
argument_list|,
operator|-
name|INTVAL
argument_list|(
name|op1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|process_epilogue
argument_list|()
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|src
argument_list|)
operator|==
name|HARD_FRAME_POINTER_REGNUM
condition|)
name|process_epilogue
argument_list|()
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Register move we need to look at.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|REG
condition|)
block|{
name|src_regno
operator|=
name|REGNO
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|dest_regno
operator|=
name|REGNO
argument_list|(
name|dest
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|src_regno
condition|)
block|{
case|case
name|BR_REG
argument_list|(
literal|0
argument_list|)
case|:
comment|/* Saving return address pointer.  */
if|if
condition|(
name|dest_regno
operator|!=
name|current_frame_info
operator|.
name|reg_save_b0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.save rp, r%d\n"
argument_list|,
name|ia64_dbx_register_number
argument_list|(
name|dest_regno
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|PR_REG
argument_list|(
literal|0
argument_list|)
case|:
if|if
condition|(
name|dest_regno
operator|!=
name|current_frame_info
operator|.
name|reg_save_pr
condition|)
name|abort
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.save pr, r%d\n"
argument_list|,
name|ia64_dbx_register_number
argument_list|(
name|dest_regno
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|AR_UNAT_REGNUM
case|:
if|if
condition|(
name|dest_regno
operator|!=
name|current_frame_info
operator|.
name|reg_save_ar_unat
condition|)
name|abort
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.save ar.unat, r%d\n"
argument_list|,
name|ia64_dbx_register_number
argument_list|(
name|dest_regno
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|AR_LC_REGNUM
case|:
if|if
condition|(
name|dest_regno
operator|!=
name|current_frame_info
operator|.
name|reg_save_ar_lc
condition|)
name|abort
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.save ar.lc, r%d\n"
argument_list|,
name|ia64_dbx_register_number
argument_list|(
name|dest_regno
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|STACK_POINTER_REGNUM
case|:
if|if
condition|(
name|dest_regno
operator|!=
name|HARD_FRAME_POINTER_REGNUM
operator|||
operator|!
name|frame_pointer_needed
condition|)
name|abort
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.vframe r%d\n"
argument_list|,
name|ia64_dbx_register_number
argument_list|(
name|dest_regno
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
default|default:
comment|/* Everything else should indicate being stored to memory.  */
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Memory store we need to look at.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|REG
condition|)
block|{
name|long
name|off
decl_stmt|;
name|rtx
name|base
decl_stmt|;
specifier|const
name|char
modifier|*
name|saveop
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|base
operator|=
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|off
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|base
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|off
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|base
operator|==
name|hard_frame_pointer_rtx
condition|)
block|{
name|saveop
operator|=
literal|".savepsp"
expr_stmt|;
name|off
operator|=
operator|-
name|off
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|base
operator|==
name|stack_pointer_rtx
condition|)
name|saveop
operator|=
literal|".savesp"
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
name|src_regno
operator|=
name|REGNO
argument_list|(
name|src
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|src_regno
condition|)
block|{
case|case
name|BR_REG
argument_list|(
literal|0
argument_list|)
case|:
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_b0
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s rp, %ld\n"
argument_list|,
name|saveop
argument_list|,
name|off
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|PR_REG
argument_list|(
literal|0
argument_list|)
case|:
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_pr
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s pr, %ld\n"
argument_list|,
name|saveop
argument_list|,
name|off
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|AR_LC_REGNUM
case|:
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_ar_lc
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s ar.lc, %ld\n"
argument_list|,
name|saveop
argument_list|,
name|off
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|AR_PFS_REGNUM
case|:
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_ar_pfs
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s ar.pfs, %ld\n"
argument_list|,
name|saveop
argument_list|,
name|off
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|AR_UNAT_REGNUM
case|:
if|if
condition|(
name|current_frame_info
operator|.
name|reg_save_ar_unat
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s ar.unat, %ld\n"
argument_list|,
name|saveop
argument_list|,
name|off
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|GR_REG
argument_list|(
literal|4
argument_list|)
case|:
case|case
name|GR_REG
argument_list|(
literal|5
argument_list|)
case|:
case|case
name|GR_REG
argument_list|(
literal|6
argument_list|)
case|:
case|case
name|GR_REG
argument_list|(
literal|7
argument_list|)
case|:
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.save.g 0x%x\n"
argument_list|,
literal|1
operator|<<
operator|(
name|src_regno
operator|-
name|GR_REG
argument_list|(
literal|4
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|BR_REG
argument_list|(
literal|1
argument_list|)
case|:
case|case
name|BR_REG
argument_list|(
literal|2
argument_list|)
case|:
case|case
name|BR_REG
argument_list|(
literal|3
argument_list|)
case|:
case|case
name|BR_REG
argument_list|(
literal|4
argument_list|)
case|:
case|case
name|BR_REG
argument_list|(
literal|5
argument_list|)
case|:
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.save.b 0x%x\n"
argument_list|,
literal|1
operator|<<
operator|(
name|src_regno
operator|-
name|BR_REG
argument_list|(
literal|1
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|FR_REG
argument_list|(
literal|2
argument_list|)
case|:
case|case
name|FR_REG
argument_list|(
literal|3
argument_list|)
case|:
case|case
name|FR_REG
argument_list|(
literal|4
argument_list|)
case|:
case|case
name|FR_REG
argument_list|(
literal|5
argument_list|)
case|:
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.save.f 0x%x\n"
argument_list|,
literal|1
operator|<<
operator|(
name|src_regno
operator|-
name|FR_REG
argument_list|(
literal|2
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|FR_REG
argument_list|(
literal|16
argument_list|)
case|:
case|case
name|FR_REG
argument_list|(
literal|17
argument_list|)
case|:
case|case
name|FR_REG
argument_list|(
literal|18
argument_list|)
case|:
case|case
name|FR_REG
argument_list|(
literal|19
argument_list|)
case|:
case|case
name|FR_REG
argument_list|(
literal|20
argument_list|)
case|:
case|case
name|FR_REG
argument_list|(
literal|21
argument_list|)
case|:
case|case
name|FR_REG
argument_list|(
literal|22
argument_list|)
case|:
case|case
name|FR_REG
argument_list|(
literal|23
argument_list|)
case|:
case|case
name|FR_REG
argument_list|(
literal|24
argument_list|)
case|:
case|case
name|FR_REG
argument_list|(
literal|25
argument_list|)
case|:
case|case
name|FR_REG
argument_list|(
literal|26
argument_list|)
case|:
case|case
name|FR_REG
argument_list|(
literal|27
argument_list|)
case|:
case|case
name|FR_REG
argument_list|(
literal|28
argument_list|)
case|:
case|case
name|FR_REG
argument_list|(
literal|29
argument_list|)
case|:
case|case
name|FR_REG
argument_list|(
literal|30
argument_list|)
case|:
case|case
name|FR_REG
argument_list|(
literal|31
argument_list|)
case|:
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.save.gf 0x0, 0x%x\n"
argument_list|,
literal|1
operator|<<
operator|(
name|src_regno
operator|-
name|FR_REG
argument_list|(
literal|12
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* This function looks at a single insn and emits any directives    required to unwind this insn.  */
end_comment

begin_function
name|void
name|process_for_unwind_directive
parameter_list|(
name|FILE
modifier|*
name|asm_out_file
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
if|if
condition|(
name|flag_unwind_tables
operator|||
operator|(
name|flag_exceptions
operator|&&
operator|!
name|USING_SJLJ_EXCEPTIONS
operator|)
condition|)
block|{
name|rtx
name|pat
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_BASIC_BLOCK
condition|)
block|{
name|last_block
operator|=
name|NOTE_BASIC_BLOCK
argument_list|(
name|insn
argument_list|)
operator|->
name|next_bb
operator|==
name|EXIT_BLOCK_PTR
expr_stmt|;
comment|/* Restore unwind state from immediately before the epilogue.  */
if|if
condition|(
name|need_copy_state
condition|)
block|{
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.body\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.copy_state 1\n"
argument_list|)
expr_stmt|;
name|need_copy_state
operator|=
name|false
expr_stmt|;
block|}
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|||
operator|!
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return;
name|pat
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_FRAME_RELATED_EXPR
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
condition|)
name|pat
operator|=
name|XEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|pat
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
condition|)
block|{
case|case
name|SET
case|:
name|process_set
argument_list|(
name|asm_out_file
argument_list|,
name|pat
argument_list|)
expr_stmt|;
break|break;
case|case
name|PARALLEL
case|:
block|{
name|int
name|par_index
decl_stmt|;
name|int
name|limit
init|=
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|par_index
operator|=
literal|0
init|;
name|par_index
operator|<
name|limit
condition|;
name|par_index
operator|++
control|)
block|{
name|rtx
name|x
init|=
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|par_index
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SET
condition|)
name|process_set
argument_list|(
name|asm_out_file
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|ia64_init_builtins
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|psi_type_node
init|=
name|build_pointer_type
argument_list|(
name|integer_type_node
argument_list|)
decl_stmt|;
name|tree
name|pdi_type_node
init|=
name|build_pointer_type
argument_list|(
name|long_integer_type_node
argument_list|)
decl_stmt|;
comment|/* __sync_val_compare_and_swap_si, __sync_bool_compare_and_swap_si */
name|tree
name|si_ftype_psi_si_si
init|=
name|build_function_type_list
argument_list|(
name|integer_type_node
argument_list|,
name|psi_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
comment|/* __sync_val_compare_and_swap_di */
name|tree
name|di_ftype_pdi_di_di
init|=
name|build_function_type_list
argument_list|(
name|long_integer_type_node
argument_list|,
name|pdi_type_node
argument_list|,
name|long_integer_type_node
argument_list|,
name|long_integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
comment|/* __sync_bool_compare_and_swap_di */
name|tree
name|si_ftype_pdi_di_di
init|=
name|build_function_type_list
argument_list|(
name|integer_type_node
argument_list|,
name|pdi_type_node
argument_list|,
name|long_integer_type_node
argument_list|,
name|long_integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
comment|/* __sync_synchronize */
name|tree
name|void_ftype_void
init|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|void_list_node
argument_list|)
decl_stmt|;
comment|/* __sync_lock_test_and_set_si */
name|tree
name|si_ftype_psi_si
init|=
name|build_function_type_list
argument_list|(
name|integer_type_node
argument_list|,
name|psi_type_node
argument_list|,
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
comment|/* __sync_lock_test_and_set_di */
name|tree
name|di_ftype_pdi_di
init|=
name|build_function_type_list
argument_list|(
name|long_integer_type_node
argument_list|,
name|pdi_type_node
argument_list|,
name|long_integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
comment|/* __sync_lock_release_si */
name|tree
name|void_ftype_psi
init|=
name|build_function_type_list
argument_list|(
name|void_type_node
argument_list|,
name|psi_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
comment|/* __sync_lock_release_di */
name|tree
name|void_ftype_pdi
init|=
name|build_function_type_list
argument_list|(
name|void_type_node
argument_list|,
name|pdi_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|fpreg_type
decl_stmt|;
name|tree
name|float80_type
decl_stmt|;
comment|/* The __fpreg type.  */
name|fpreg_type
operator|=
name|make_node
argument_list|(
name|REAL_TYPE
argument_list|)
expr_stmt|;
comment|/* ??? The back end should know to load/save __fpreg variables using      the ldf.fill and stf.spill instructions.  */
name|TYPE_PRECISION
argument_list|(
name|fpreg_type
argument_list|)
operator|=
literal|96
expr_stmt|;
name|layout_type
argument_list|(
name|fpreg_type
argument_list|)
expr_stmt|;
call|(
modifier|*
name|lang_hooks
operator|.
name|types
operator|.
name|register_builtin_type
call|)
argument_list|(
name|fpreg_type
argument_list|,
literal|"__fpreg"
argument_list|)
expr_stmt|;
comment|/* The __float80 type.  */
name|float80_type
operator|=
name|make_node
argument_list|(
name|REAL_TYPE
argument_list|)
expr_stmt|;
name|TYPE_PRECISION
argument_list|(
name|float80_type
argument_list|)
operator|=
literal|96
expr_stmt|;
name|layout_type
argument_list|(
name|float80_type
argument_list|)
expr_stmt|;
call|(
modifier|*
name|lang_hooks
operator|.
name|types
operator|.
name|register_builtin_type
call|)
argument_list|(
name|float80_type
argument_list|,
literal|"__float80"
argument_list|)
expr_stmt|;
comment|/* The __float128 type.  */
if|if
condition|(
operator|!
name|TARGET_HPUX
condition|)
block|{
name|tree
name|float128_type
init|=
name|make_node
argument_list|(
name|REAL_TYPE
argument_list|)
decl_stmt|;
name|TYPE_PRECISION
argument_list|(
name|float128_type
argument_list|)
operator|=
literal|128
expr_stmt|;
name|layout_type
argument_list|(
name|float128_type
argument_list|)
expr_stmt|;
call|(
modifier|*
name|lang_hooks
operator|.
name|types
operator|.
name|register_builtin_type
call|)
argument_list|(
name|float128_type
argument_list|,
literal|"__float128"
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Under HPUX, this is a synonym for "long double".  */
call|(
modifier|*
name|lang_hooks
operator|.
name|types
operator|.
name|register_builtin_type
call|)
argument_list|(
name|long_double_type_node
argument_list|,
literal|"__float128"
argument_list|)
expr_stmt|;
define|#
directive|define
name|def_builtin
parameter_list|(
name|name
parameter_list|,
name|type
parameter_list|,
name|code
parameter_list|)
define|\
value|builtin_function ((name), (type), (code), BUILT_IN_MD, NULL, NULL_TREE)
name|def_builtin
argument_list|(
literal|"__sync_val_compare_and_swap_si"
argument_list|,
name|si_ftype_psi_si_si
argument_list|,
name|IA64_BUILTIN_VAL_COMPARE_AND_SWAP_SI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__sync_val_compare_and_swap_di"
argument_list|,
name|di_ftype_pdi_di_di
argument_list|,
name|IA64_BUILTIN_VAL_COMPARE_AND_SWAP_DI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__sync_bool_compare_and_swap_si"
argument_list|,
name|si_ftype_psi_si_si
argument_list|,
name|IA64_BUILTIN_BOOL_COMPARE_AND_SWAP_SI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__sync_bool_compare_and_swap_di"
argument_list|,
name|si_ftype_pdi_di_di
argument_list|,
name|IA64_BUILTIN_BOOL_COMPARE_AND_SWAP_DI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__sync_synchronize"
argument_list|,
name|void_ftype_void
argument_list|,
name|IA64_BUILTIN_SYNCHRONIZE
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__sync_lock_test_and_set_si"
argument_list|,
name|si_ftype_psi_si
argument_list|,
name|IA64_BUILTIN_LOCK_TEST_AND_SET_SI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__sync_lock_test_and_set_di"
argument_list|,
name|di_ftype_pdi_di
argument_list|,
name|IA64_BUILTIN_LOCK_TEST_AND_SET_DI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__sync_lock_release_si"
argument_list|,
name|void_ftype_psi
argument_list|,
name|IA64_BUILTIN_LOCK_RELEASE_SI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__sync_lock_release_di"
argument_list|,
name|void_ftype_pdi
argument_list|,
name|IA64_BUILTIN_LOCK_RELEASE_DI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__builtin_ia64_bsp"
argument_list|,
name|build_function_type
argument_list|(
name|ptr_type_node
argument_list|,
name|void_list_node
argument_list|)
argument_list|,
name|IA64_BUILTIN_BSP
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__builtin_ia64_flushrs"
argument_list|,
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|void_list_node
argument_list|)
argument_list|,
name|IA64_BUILTIN_FLUSHRS
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__sync_fetch_and_add_si"
argument_list|,
name|si_ftype_psi_si
argument_list|,
name|IA64_BUILTIN_FETCH_AND_ADD_SI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__sync_fetch_and_sub_si"
argument_list|,
name|si_ftype_psi_si
argument_list|,
name|IA64_BUILTIN_FETCH_AND_SUB_SI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__sync_fetch_and_or_si"
argument_list|,
name|si_ftype_psi_si
argument_list|,
name|IA64_BUILTIN_FETCH_AND_OR_SI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__sync_fetch_and_and_si"
argument_list|,
name|si_ftype_psi_si
argument_list|,
name|IA64_BUILTIN_FETCH_AND_AND_SI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__sync_fetch_and_xor_si"
argument_list|,
name|si_ftype_psi_si
argument_list|,
name|IA64_BUILTIN_FETCH_AND_XOR_SI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__sync_fetch_and_nand_si"
argument_list|,
name|si_ftype_psi_si
argument_list|,
name|IA64_BUILTIN_FETCH_AND_NAND_SI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__sync_add_and_fetch_si"
argument_list|,
name|si_ftype_psi_si
argument_list|,
name|IA64_BUILTIN_ADD_AND_FETCH_SI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__sync_sub_and_fetch_si"
argument_list|,
name|si_ftype_psi_si
argument_list|,
name|IA64_BUILTIN_SUB_AND_FETCH_SI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__sync_or_and_fetch_si"
argument_list|,
name|si_ftype_psi_si
argument_list|,
name|IA64_BUILTIN_OR_AND_FETCH_SI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__sync_and_and_fetch_si"
argument_list|,
name|si_ftype_psi_si
argument_list|,
name|IA64_BUILTIN_AND_AND_FETCH_SI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__sync_xor_and_fetch_si"
argument_list|,
name|si_ftype_psi_si
argument_list|,
name|IA64_BUILTIN_XOR_AND_FETCH_SI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__sync_nand_and_fetch_si"
argument_list|,
name|si_ftype_psi_si
argument_list|,
name|IA64_BUILTIN_NAND_AND_FETCH_SI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__sync_fetch_and_add_di"
argument_list|,
name|di_ftype_pdi_di
argument_list|,
name|IA64_BUILTIN_FETCH_AND_ADD_DI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__sync_fetch_and_sub_di"
argument_list|,
name|di_ftype_pdi_di
argument_list|,
name|IA64_BUILTIN_FETCH_AND_SUB_DI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__sync_fetch_and_or_di"
argument_list|,
name|di_ftype_pdi_di
argument_list|,
name|IA64_BUILTIN_FETCH_AND_OR_DI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__sync_fetch_and_and_di"
argument_list|,
name|di_ftype_pdi_di
argument_list|,
name|IA64_BUILTIN_FETCH_AND_AND_DI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__sync_fetch_and_xor_di"
argument_list|,
name|di_ftype_pdi_di
argument_list|,
name|IA64_BUILTIN_FETCH_AND_XOR_DI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__sync_fetch_and_nand_di"
argument_list|,
name|di_ftype_pdi_di
argument_list|,
name|IA64_BUILTIN_FETCH_AND_NAND_DI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__sync_add_and_fetch_di"
argument_list|,
name|di_ftype_pdi_di
argument_list|,
name|IA64_BUILTIN_ADD_AND_FETCH_DI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__sync_sub_and_fetch_di"
argument_list|,
name|di_ftype_pdi_di
argument_list|,
name|IA64_BUILTIN_SUB_AND_FETCH_DI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__sync_or_and_fetch_di"
argument_list|,
name|di_ftype_pdi_di
argument_list|,
name|IA64_BUILTIN_OR_AND_FETCH_DI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__sync_and_and_fetch_di"
argument_list|,
name|di_ftype_pdi_di
argument_list|,
name|IA64_BUILTIN_AND_AND_FETCH_DI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__sync_xor_and_fetch_di"
argument_list|,
name|di_ftype_pdi_di
argument_list|,
name|IA64_BUILTIN_XOR_AND_FETCH_DI
argument_list|)
expr_stmt|;
name|def_builtin
argument_list|(
literal|"__sync_nand_and_fetch_di"
argument_list|,
name|di_ftype_pdi_di
argument_list|,
name|IA64_BUILTIN_NAND_AND_FETCH_DI
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|def_builtin
block|}
end_function

begin_comment
comment|/* Expand fetch_and_op intrinsics.  The basic code sequence is:       mf      tmp = [ptr];      do {        ret = tmp;        ar.ccv = tmp;        tmp<op>= value;        cmpxchgsz.acq tmp = [ptr], tmp      } while (tmp != ret) */
end_comment

begin_function
specifier|static
name|rtx
name|ia64_expand_fetch_and_op
parameter_list|(
name|optab
name|binoptab
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|arglist
parameter_list|,
name|rtx
name|target
parameter_list|)
block|{
name|rtx
name|ret
decl_stmt|,
name|label
decl_stmt|,
name|tmp
decl_stmt|,
name|ccv
decl_stmt|,
name|insn
decl_stmt|,
name|mem
decl_stmt|,
name|value
decl_stmt|;
name|tree
name|arg0
decl_stmt|,
name|arg1
decl_stmt|;
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|mem
operator|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|Pmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|POINTERS_EXTEND_UNSIGNED
if|if
condition|(
name|GET_MODE
argument_list|(
name|mem
argument_list|)
operator|!=
name|Pmode
condition|)
name|mem
operator|=
name|convert_memory_address
argument_list|(
name|Pmode
argument_list|,
name|mem
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|value
operator|=
name|expand_expr
argument_list|(
name|arg1
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode
argument_list|,
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|mem
argument_list|)
argument_list|)
expr_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|mem
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|target
operator|&&
name|register_operand
argument_list|(
name|target
argument_list|,
name|mode
argument_list|)
condition|)
name|ret
operator|=
name|target
expr_stmt|;
else|else
name|ret
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_mf
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Special case for fetchadd instructions.  */
if|if
condition|(
name|binoptab
operator|==
name|add_optab
operator|&&
name|fetchadd_operand
argument_list|(
name|value
argument_list|,
name|VOIDmode
argument_list|)
condition|)
block|{
if|if
condition|(
name|mode
operator|==
name|SImode
condition|)
name|insn
operator|=
name|gen_fetchadd_acq_si
argument_list|(
name|ret
argument_list|,
name|mem
argument_list|,
name|value
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|gen_fetchadd_acq_di
argument_list|(
name|ret
argument_list|,
name|mem
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|tmp
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
comment|/* ar.ccv must always be loaded with a zero-extended DImode value.  */
name|ccv
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|AR_CCV_REGNUM
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|tmp
argument_list|,
name|mem
argument_list|)
expr_stmt|;
name|label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|ret
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|ccv
argument_list|,
name|tmp
argument_list|,
comment|/*unsignedp=*/
literal|1
argument_list|)
expr_stmt|;
comment|/* Perform the specific operation.  Special case NAND by noticing      one_cmpl_optab instead.  */
if|if
condition|(
name|binoptab
operator|==
name|one_cmpl_optab
condition|)
block|{
name|tmp
operator|=
name|expand_unop
argument_list|(
name|mode
argument_list|,
name|binoptab
argument_list|,
name|tmp
argument_list|,
name|NULL
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
name|binoptab
operator|=
name|and_optab
expr_stmt|;
block|}
name|tmp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|binoptab
argument_list|,
name|tmp
argument_list|,
name|value
argument_list|,
name|tmp
argument_list|,
literal|1
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|SImode
condition|)
name|insn
operator|=
name|gen_cmpxchg_acq_si
argument_list|(
name|tmp
argument_list|,
name|mem
argument_list|,
name|tmp
argument_list|,
name|ccv
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|gen_cmpxchg_acq_di
argument_list|(
name|tmp
argument_list|,
name|mem
argument_list|,
name|tmp
argument_list|,
name|ccv
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|tmp
argument_list|,
name|ret
argument_list|,
name|NE
argument_list|,
literal|0
argument_list|,
name|mode
argument_list|,
literal|1
argument_list|,
name|label
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Expand op_and_fetch intrinsics.  The basic code sequence is:       mf      tmp = [ptr];      do {        old = tmp;        ar.ccv = tmp;        ret = tmp<op> value;        cmpxchgsz.acq tmp = [ptr], ret      } while (tmp != old) */
end_comment

begin_function
specifier|static
name|rtx
name|ia64_expand_op_and_fetch
parameter_list|(
name|optab
name|binoptab
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|arglist
parameter_list|,
name|rtx
name|target
parameter_list|)
block|{
name|rtx
name|old
decl_stmt|,
name|label
decl_stmt|,
name|tmp
decl_stmt|,
name|ret
decl_stmt|,
name|ccv
decl_stmt|,
name|insn
decl_stmt|,
name|mem
decl_stmt|,
name|value
decl_stmt|;
name|tree
name|arg0
decl_stmt|,
name|arg1
decl_stmt|;
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|mem
operator|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|Pmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|POINTERS_EXTEND_UNSIGNED
if|if
condition|(
name|GET_MODE
argument_list|(
name|mem
argument_list|)
operator|!=
name|Pmode
condition|)
name|mem
operator|=
name|convert_memory_address
argument_list|(
name|Pmode
argument_list|,
name|mem
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|value
operator|=
name|expand_expr
argument_list|(
name|arg1
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode
argument_list|,
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|mem
argument_list|)
argument_list|)
expr_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|mem
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|target
operator|&&
operator|!
name|register_operand
argument_list|(
name|target
argument_list|,
name|mode
argument_list|)
condition|)
name|target
operator|=
name|NULL_RTX
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_mf
argument_list|()
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|old
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
comment|/* ar.ccv must always be loaded with a zero-extended DImode value.  */
name|ccv
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|AR_CCV_REGNUM
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|tmp
argument_list|,
name|mem
argument_list|)
expr_stmt|;
name|label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|old
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|ccv
argument_list|,
name|tmp
argument_list|,
comment|/*unsignedp=*/
literal|1
argument_list|)
expr_stmt|;
comment|/* Perform the specific operation.  Special case NAND by noticing      one_cmpl_optab instead.  */
if|if
condition|(
name|binoptab
operator|==
name|one_cmpl_optab
condition|)
block|{
name|tmp
operator|=
name|expand_unop
argument_list|(
name|mode
argument_list|,
name|binoptab
argument_list|,
name|tmp
argument_list|,
name|NULL
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
name|binoptab
operator|=
name|and_optab
expr_stmt|;
block|}
name|ret
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|binoptab
argument_list|,
name|tmp
argument_list|,
name|value
argument_list|,
name|target
argument_list|,
literal|1
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|SImode
condition|)
name|insn
operator|=
name|gen_cmpxchg_acq_si
argument_list|(
name|tmp
argument_list|,
name|mem
argument_list|,
name|ret
argument_list|,
name|ccv
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|gen_cmpxchg_acq_di
argument_list|(
name|tmp
argument_list|,
name|mem
argument_list|,
name|ret
argument_list|,
name|ccv
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|emit_cmp_and_jump_insns
argument_list|(
name|tmp
argument_list|,
name|old
argument_list|,
name|NE
argument_list|,
literal|0
argument_list|,
name|mode
argument_list|,
literal|1
argument_list|,
name|label
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Expand val_ and bool_compare_and_swap.  For val_ we want:       ar.ccv = oldval      mf      cmpxchgsz.acq ret = [ptr], newval, ar.ccv      return ret     For bool_ it's the same except return ret == oldval. */
end_comment

begin_function
specifier|static
name|rtx
name|ia64_expand_compare_and_swap
parameter_list|(
name|enum
name|machine_mode
name|rmode
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|int
name|boolp
parameter_list|,
name|tree
name|arglist
parameter_list|,
name|rtx
name|target
parameter_list|)
block|{
name|tree
name|arg0
decl_stmt|,
name|arg1
decl_stmt|,
name|arg2
decl_stmt|;
name|rtx
name|mem
decl_stmt|,
name|old
decl_stmt|,
name|new
decl_stmt|,
name|ccv
decl_stmt|,
name|tmp
decl_stmt|,
name|insn
decl_stmt|;
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|mem
operator|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|ptr_mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|old
operator|=
name|expand_expr
argument_list|(
name|arg1
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|new
operator|=
name|expand_expr
argument_list|(
name|arg2
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode
argument_list|,
name|force_reg
argument_list|(
name|ptr_mode
argument_list|,
name|mem
argument_list|)
argument_list|)
expr_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|mem
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|old
argument_list|)
operator|!=
name|mode
condition|)
name|old
operator|=
name|convert_to_mode
argument_list|(
name|mode
argument_list|,
name|old
argument_list|,
comment|/*unsignedp=*/
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|new
argument_list|)
operator|!=
name|mode
condition|)
name|new
operator|=
name|convert_to_mode
argument_list|(
name|mode
argument_list|,
name|new
argument_list|,
comment|/*unsignedp=*/
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|register_operand
argument_list|(
name|old
argument_list|,
name|mode
argument_list|)
condition|)
name|old
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode
argument_list|,
name|old
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|register_operand
argument_list|(
name|new
argument_list|,
name|mode
argument_list|)
condition|)
name|new
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode
argument_list|,
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|boolp
operator|&&
name|target
operator|&&
name|register_operand
argument_list|(
name|target
argument_list|,
name|mode
argument_list|)
condition|)
name|tmp
operator|=
name|target
expr_stmt|;
else|else
name|tmp
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|ccv
operator|=
name|gen_rtx_REG
argument_list|(
name|DImode
argument_list|,
name|AR_CCV_REGNUM
argument_list|)
expr_stmt|;
name|convert_move
argument_list|(
name|ccv
argument_list|,
name|old
argument_list|,
comment|/*unsignedp=*/
literal|1
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_mf
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|SImode
condition|)
name|insn
operator|=
name|gen_cmpxchg_acq_si
argument_list|(
name|tmp
argument_list|,
name|mem
argument_list|,
name|new
argument_list|,
name|ccv
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|gen_cmpxchg_acq_di
argument_list|(
name|tmp
argument_list|,
name|mem
argument_list|,
name|new
argument_list|,
name|ccv
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|boolp
condition|)
block|{
if|if
condition|(
operator|!
name|target
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|rmode
argument_list|)
expr_stmt|;
return|return
name|emit_store_flag_force
argument_list|(
name|target
argument_list|,
name|EQ
argument_list|,
name|tmp
argument_list|,
name|old
argument_list|,
name|mode
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
return|;
block|}
else|else
return|return
name|tmp
return|;
block|}
end_function

begin_comment
comment|/* Expand lock_test_and_set.  I.e. `xchgsz ret = [ptr], new'.  */
end_comment

begin_function
specifier|static
name|rtx
name|ia64_expand_lock_test_and_set
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|arglist
parameter_list|,
name|rtx
name|target
parameter_list|)
block|{
name|tree
name|arg0
decl_stmt|,
name|arg1
decl_stmt|;
name|rtx
name|mem
decl_stmt|,
name|new
decl_stmt|,
name|ret
decl_stmt|,
name|insn
decl_stmt|;
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|mem
operator|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|ptr_mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|new
operator|=
name|expand_expr
argument_list|(
name|arg1
argument_list|,
name|NULL_RTX
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode
argument_list|,
name|force_reg
argument_list|(
name|ptr_mode
argument_list|,
name|mem
argument_list|)
argument_list|)
expr_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|mem
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|register_operand
argument_list|(
name|new
argument_list|,
name|mode
argument_list|)
condition|)
name|new
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode
argument_list|,
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|&&
name|register_operand
argument_list|(
name|target
argument_list|,
name|mode
argument_list|)
condition|)
name|ret
operator|=
name|target
expr_stmt|;
else|else
name|ret
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|SImode
condition|)
name|insn
operator|=
name|gen_xchgsi
argument_list|(
name|ret
argument_list|,
name|mem
argument_list|,
name|new
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|gen_xchgdi
argument_list|(
name|ret
argument_list|,
name|mem
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Expand lock_release.  I.e. `stsz.rel [ptr] = r0'.  */
end_comment

begin_function
specifier|static
name|rtx
name|ia64_expand_lock_release
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|arglist
parameter_list|,
name|rtx
name|target
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|tree
name|arg0
decl_stmt|;
name|rtx
name|mem
decl_stmt|;
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|mem
operator|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|ptr_mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode
argument_list|,
name|force_reg
argument_list|(
name|ptr_mode
argument_list|,
name|mem
argument_list|)
argument_list|)
expr_stmt|;
name|MEM_VOLATILE_P
argument_list|(
name|mem
argument_list|)
operator|=
literal|1
expr_stmt|;
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
end_function

begin_function
name|rtx
name|ia64_expand_builtin
parameter_list|(
name|tree
name|exp
parameter_list|,
name|rtx
name|target
parameter_list|,
name|rtx
name|subtarget
name|ATTRIBUTE_UNUSED
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|tree
name|fndecl
init|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|fcode
init|=
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|rmode
init|=
name|VOIDmode
decl_stmt|;
switch|switch
condition|(
name|fcode
condition|)
block|{
case|case
name|IA64_BUILTIN_BOOL_COMPARE_AND_SWAP_SI
case|:
case|case
name|IA64_BUILTIN_VAL_COMPARE_AND_SWAP_SI
case|:
name|mode
operator|=
name|SImode
expr_stmt|;
name|rmode
operator|=
name|SImode
expr_stmt|;
break|break;
case|case
name|IA64_BUILTIN_LOCK_TEST_AND_SET_SI
case|:
case|case
name|IA64_BUILTIN_LOCK_RELEASE_SI
case|:
case|case
name|IA64_BUILTIN_FETCH_AND_ADD_SI
case|:
case|case
name|IA64_BUILTIN_FETCH_AND_SUB_SI
case|:
case|case
name|IA64_BUILTIN_FETCH_AND_OR_SI
case|:
case|case
name|IA64_BUILTIN_FETCH_AND_AND_SI
case|:
case|case
name|IA64_BUILTIN_FETCH_AND_XOR_SI
case|:
case|case
name|IA64_BUILTIN_FETCH_AND_NAND_SI
case|:
case|case
name|IA64_BUILTIN_ADD_AND_FETCH_SI
case|:
case|case
name|IA64_BUILTIN_SUB_AND_FETCH_SI
case|:
case|case
name|IA64_BUILTIN_OR_AND_FETCH_SI
case|:
case|case
name|IA64_BUILTIN_AND_AND_FETCH_SI
case|:
case|case
name|IA64_BUILTIN_XOR_AND_FETCH_SI
case|:
case|case
name|IA64_BUILTIN_NAND_AND_FETCH_SI
case|:
name|mode
operator|=
name|SImode
expr_stmt|;
break|break;
case|case
name|IA64_BUILTIN_BOOL_COMPARE_AND_SWAP_DI
case|:
name|mode
operator|=
name|DImode
expr_stmt|;
name|rmode
operator|=
name|SImode
expr_stmt|;
break|break;
case|case
name|IA64_BUILTIN_VAL_COMPARE_AND_SWAP_DI
case|:
name|mode
operator|=
name|DImode
expr_stmt|;
name|rmode
operator|=
name|DImode
expr_stmt|;
break|break;
case|case
name|IA64_BUILTIN_LOCK_TEST_AND_SET_DI
case|:
case|case
name|IA64_BUILTIN_LOCK_RELEASE_DI
case|:
case|case
name|IA64_BUILTIN_FETCH_AND_ADD_DI
case|:
case|case
name|IA64_BUILTIN_FETCH_AND_SUB_DI
case|:
case|case
name|IA64_BUILTIN_FETCH_AND_OR_DI
case|:
case|case
name|IA64_BUILTIN_FETCH_AND_AND_DI
case|:
case|case
name|IA64_BUILTIN_FETCH_AND_XOR_DI
case|:
case|case
name|IA64_BUILTIN_FETCH_AND_NAND_DI
case|:
case|case
name|IA64_BUILTIN_ADD_AND_FETCH_DI
case|:
case|case
name|IA64_BUILTIN_SUB_AND_FETCH_DI
case|:
case|case
name|IA64_BUILTIN_OR_AND_FETCH_DI
case|:
case|case
name|IA64_BUILTIN_AND_AND_FETCH_DI
case|:
case|case
name|IA64_BUILTIN_XOR_AND_FETCH_DI
case|:
case|case
name|IA64_BUILTIN_NAND_AND_FETCH_DI
case|:
name|mode
operator|=
name|DImode
expr_stmt|;
break|break;
default|default:
break|break;
block|}
switch|switch
condition|(
name|fcode
condition|)
block|{
case|case
name|IA64_BUILTIN_BOOL_COMPARE_AND_SWAP_SI
case|:
case|case
name|IA64_BUILTIN_BOOL_COMPARE_AND_SWAP_DI
case|:
return|return
name|ia64_expand_compare_and_swap
argument_list|(
name|rmode
argument_list|,
name|mode
argument_list|,
literal|1
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IA64_BUILTIN_VAL_COMPARE_AND_SWAP_SI
case|:
case|case
name|IA64_BUILTIN_VAL_COMPARE_AND_SWAP_DI
case|:
return|return
name|ia64_expand_compare_and_swap
argument_list|(
name|rmode
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IA64_BUILTIN_SYNCHRONIZE
case|:
name|emit_insn
argument_list|(
name|gen_mf
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
case|case
name|IA64_BUILTIN_LOCK_TEST_AND_SET_SI
case|:
case|case
name|IA64_BUILTIN_LOCK_TEST_AND_SET_DI
case|:
return|return
name|ia64_expand_lock_test_and_set
argument_list|(
name|mode
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IA64_BUILTIN_LOCK_RELEASE_SI
case|:
case|case
name|IA64_BUILTIN_LOCK_RELEASE_DI
case|:
return|return
name|ia64_expand_lock_release
argument_list|(
name|mode
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IA64_BUILTIN_BSP
case|:
if|if
condition|(
operator|!
name|target
operator|||
operator|!
name|register_operand
argument_list|(
name|target
argument_list|,
name|DImode
argument_list|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_bsp_value
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|POINTERS_EXTEND_UNSIGNED
name|target
operator|=
name|convert_memory_address
argument_list|(
name|ptr_mode
argument_list|,
name|target
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|target
return|;
case|case
name|IA64_BUILTIN_FLUSHRS
case|:
name|emit_insn
argument_list|(
name|gen_flushrs
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
case|case
name|IA64_BUILTIN_FETCH_AND_ADD_SI
case|:
case|case
name|IA64_BUILTIN_FETCH_AND_ADD_DI
case|:
return|return
name|ia64_expand_fetch_and_op
argument_list|(
name|add_optab
argument_list|,
name|mode
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IA64_BUILTIN_FETCH_AND_SUB_SI
case|:
case|case
name|IA64_BUILTIN_FETCH_AND_SUB_DI
case|:
return|return
name|ia64_expand_fetch_and_op
argument_list|(
name|sub_optab
argument_list|,
name|mode
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IA64_BUILTIN_FETCH_AND_OR_SI
case|:
case|case
name|IA64_BUILTIN_FETCH_AND_OR_DI
case|:
return|return
name|ia64_expand_fetch_and_op
argument_list|(
name|ior_optab
argument_list|,
name|mode
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IA64_BUILTIN_FETCH_AND_AND_SI
case|:
case|case
name|IA64_BUILTIN_FETCH_AND_AND_DI
case|:
return|return
name|ia64_expand_fetch_and_op
argument_list|(
name|and_optab
argument_list|,
name|mode
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IA64_BUILTIN_FETCH_AND_XOR_SI
case|:
case|case
name|IA64_BUILTIN_FETCH_AND_XOR_DI
case|:
return|return
name|ia64_expand_fetch_and_op
argument_list|(
name|xor_optab
argument_list|,
name|mode
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IA64_BUILTIN_FETCH_AND_NAND_SI
case|:
case|case
name|IA64_BUILTIN_FETCH_AND_NAND_DI
case|:
return|return
name|ia64_expand_fetch_and_op
argument_list|(
name|one_cmpl_optab
argument_list|,
name|mode
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IA64_BUILTIN_ADD_AND_FETCH_SI
case|:
case|case
name|IA64_BUILTIN_ADD_AND_FETCH_DI
case|:
return|return
name|ia64_expand_op_and_fetch
argument_list|(
name|add_optab
argument_list|,
name|mode
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IA64_BUILTIN_SUB_AND_FETCH_SI
case|:
case|case
name|IA64_BUILTIN_SUB_AND_FETCH_DI
case|:
return|return
name|ia64_expand_op_and_fetch
argument_list|(
name|sub_optab
argument_list|,
name|mode
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IA64_BUILTIN_OR_AND_FETCH_SI
case|:
case|case
name|IA64_BUILTIN_OR_AND_FETCH_DI
case|:
return|return
name|ia64_expand_op_and_fetch
argument_list|(
name|ior_optab
argument_list|,
name|mode
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IA64_BUILTIN_AND_AND_FETCH_SI
case|:
case|case
name|IA64_BUILTIN_AND_AND_FETCH_DI
case|:
return|return
name|ia64_expand_op_and_fetch
argument_list|(
name|and_optab
argument_list|,
name|mode
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IA64_BUILTIN_XOR_AND_FETCH_SI
case|:
case|case
name|IA64_BUILTIN_XOR_AND_FETCH_DI
case|:
return|return
name|ia64_expand_op_and_fetch
argument_list|(
name|xor_optab
argument_list|,
name|mode
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|IA64_BUILTIN_NAND_AND_FETCH_SI
case|:
case|case
name|IA64_BUILTIN_NAND_AND_FETCH_DI
case|:
return|return
name|ia64_expand_op_and_fetch
argument_list|(
name|one_cmpl_optab
argument_list|,
name|mode
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
default|default:
break|break;
block|}
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_comment
comment|/* For the HP-UX IA64 aggregate parameters are passed stored in the    most significant bits of the stack slot.  */
end_comment

begin_function
name|enum
name|direction
name|ia64_hpux_function_arg_padding
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
comment|/* Exception to normal case for structures/unions/etc.  */
if|if
condition|(
name|type
operator|&&
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
operator|<
name|UNITS_PER_WORD
condition|)
return|return
name|upward
return|;
comment|/* Fall back to the default.  */
return|return
name|DEFAULT_FUNCTION_ARG_PADDING
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Linked list of all external functions that are to be emitted by GCC.    We output the name if and only if TREE_SYMBOL_REFERENCED is set in    order to avoid putting out names that are never really used.  */
end_comment

begin_decl_stmt
name|struct
name|extern_func_list
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
name|struct
name|extern_func_list
modifier|*
name|next
decl_stmt|;
name|tree
name|decl
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
expr|struct
name|extern_func_list
operator|*
name|extern_func_head
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|ia64_hpux_add_extern_decl
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|struct
name|extern_func_list
modifier|*
name|p
init|=
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|extern_func_list
argument_list|)
argument_list|)
decl_stmt|;
name|p
operator|->
name|decl
operator|=
name|decl
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|extern_func_head
expr_stmt|;
name|extern_func_head
operator|=
name|p
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print out the list of used global functions.  */
end_comment

begin_function
specifier|static
name|void
name|ia64_hpux_file_end
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|extern_func_list
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|extern_func_head
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|tree
name|decl
init|=
name|p
operator|->
name|decl
decl_stmt|;
name|tree
name|id
init|=
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|id
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_SYMBOL_REFERENCED
argument_list|(
name|id
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
call|(
modifier|*
name|targetm
operator|.
name|asm_out
operator|.
name|globalize_label
call|)
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|TYPE_ASM_OP
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|","
name|TYPE_OPERAND_FMT
literal|"\n"
argument_list|,
literal|"function"
argument_list|)
expr_stmt|;
block|}
block|}
name|extern_func_head
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Rename all the TFmode libfuncs using the HPUX conventions.  */
end_comment

begin_function
specifier|static
name|void
name|ia64_hpux_init_libfuncs
parameter_list|(
name|void
parameter_list|)
block|{
name|set_optab_libfunc
argument_list|(
name|add_optab
argument_list|,
name|TFmode
argument_list|,
literal|"_U_Qfadd"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|sub_optab
argument_list|,
name|TFmode
argument_list|,
literal|"_U_Qfsub"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|smul_optab
argument_list|,
name|TFmode
argument_list|,
literal|"_U_Qfmpy"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|sdiv_optab
argument_list|,
name|TFmode
argument_list|,
literal|"_U_Qfdiv"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|smin_optab
argument_list|,
name|TFmode
argument_list|,
literal|"_U_Qfmin"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|smax_optab
argument_list|,
name|TFmode
argument_list|,
literal|"_U_Qfmax"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|abs_optab
argument_list|,
name|TFmode
argument_list|,
literal|"_U_Qfabs"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|neg_optab
argument_list|,
name|TFmode
argument_list|,
literal|"_U_Qfneg"
argument_list|)
expr_stmt|;
comment|/* ia64_expand_compare uses this.  */
name|cmptf_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"_U_Qfcmp"
argument_list|)
expr_stmt|;
comment|/* These should never be used.  */
name|set_optab_libfunc
argument_list|(
name|eq_optab
argument_list|,
name|TFmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|ne_optab
argument_list|,
name|TFmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|gt_optab
argument_list|,
name|TFmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|ge_optab
argument_list|,
name|TFmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|lt_optab
argument_list|,
name|TFmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|le_optab
argument_list|,
name|TFmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|sext_optab
argument_list|,
name|TFmode
argument_list|,
name|SFmode
argument_list|,
literal|"_U_Qfcnvff_sgl_to_quad"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|sext_optab
argument_list|,
name|TFmode
argument_list|,
name|DFmode
argument_list|,
literal|"_U_Qfcnvff_dbl_to_quad"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|sext_optab
argument_list|,
name|TFmode
argument_list|,
name|XFmode
argument_list|,
literal|"_U_Qfcnvff_f80_to_quad"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|trunc_optab
argument_list|,
name|SFmode
argument_list|,
name|TFmode
argument_list|,
literal|"_U_Qfcnvff_quad_to_sgl"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|trunc_optab
argument_list|,
name|DFmode
argument_list|,
name|TFmode
argument_list|,
literal|"_U_Qfcnvff_quad_to_dbl"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|trunc_optab
argument_list|,
name|XFmode
argument_list|,
name|TFmode
argument_list|,
literal|"_U_Qfcnvff_quad_to_f80"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|sfix_optab
argument_list|,
name|SImode
argument_list|,
name|TFmode
argument_list|,
literal|"_U_Qfcnvfxt_quad_to_sgl"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|sfix_optab
argument_list|,
name|DImode
argument_list|,
name|TFmode
argument_list|,
literal|"_U_Qfcnvfxt_quad_to_dbl"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|ufix_optab
argument_list|,
name|SImode
argument_list|,
name|TFmode
argument_list|,
literal|"_U_Qfcnvfxut_quad_to_sgl"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|ufix_optab
argument_list|,
name|DImode
argument_list|,
name|TFmode
argument_list|,
literal|"_U_Qfcnvfxut_quad_to_dbl"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|sfloat_optab
argument_list|,
name|TFmode
argument_list|,
name|SImode
argument_list|,
literal|"_U_Qfcnvxf_sgl_to_quad"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|sfloat_optab
argument_list|,
name|TFmode
argument_list|,
name|DImode
argument_list|,
literal|"_U_Qfcnvxf_dbl_to_quad"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Rename the division and modulus functions in VMS.  */
end_comment

begin_function
specifier|static
name|void
name|ia64_vms_init_libfuncs
parameter_list|(
name|void
parameter_list|)
block|{
name|set_optab_libfunc
argument_list|(
name|sdiv_optab
argument_list|,
name|SImode
argument_list|,
literal|"OTS$DIV_I"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|sdiv_optab
argument_list|,
name|DImode
argument_list|,
literal|"OTS$DIV_L"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|udiv_optab
argument_list|,
name|SImode
argument_list|,
literal|"OTS$DIV_UI"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|udiv_optab
argument_list|,
name|DImode
argument_list|,
literal|"OTS$DIV_UL"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|smod_optab
argument_list|,
name|SImode
argument_list|,
literal|"OTS$REM_I"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|smod_optab
argument_list|,
name|DImode
argument_list|,
literal|"OTS$REM_L"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|umod_optab
argument_list|,
name|SImode
argument_list|,
literal|"OTS$REM_UI"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|umod_optab
argument_list|,
name|DImode
argument_list|,
literal|"OTS$REM_UL"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Switch to the section to which we should output X.  The only thing    special we do here is to honor small data.  */
end_comment

begin_function
specifier|static
name|void
name|ia64_select_rtx_section
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|x
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|align
parameter_list|)
block|{
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|>
literal|0
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|ia64_section_threshold
condition|)
name|sdata_section
argument_list|()
expr_stmt|;
else|else
name|default_elf_select_rtx_section
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
name|align
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* It is illegal to have relocations in shared segments on AIX and HPUX.    Pretend flag_pic is always set.  */
end_comment

begin_function
specifier|static
name|void
name|ia64_rwreloc_select_section
parameter_list|(
name|tree
name|exp
parameter_list|,
name|int
name|reloc
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|align
parameter_list|)
block|{
name|default_elf_select_section_1
argument_list|(
name|exp
argument_list|,
name|reloc
argument_list|,
name|align
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ia64_rwreloc_unique_section
parameter_list|(
name|tree
name|decl
parameter_list|,
name|int
name|reloc
parameter_list|)
block|{
name|default_unique_section_1
argument_list|(
name|decl
argument_list|,
name|reloc
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ia64_rwreloc_select_rtx_section
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|x
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|align
parameter_list|)
block|{
name|int
name|save_pic
init|=
name|flag_pic
decl_stmt|;
name|flag_pic
operator|=
literal|1
expr_stmt|;
name|ia64_select_rtx_section
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
name|align
argument_list|)
expr_stmt|;
name|flag_pic
operator|=
name|save_pic
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|ia64_rwreloc_section_type_flags
parameter_list|(
name|tree
name|decl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|reloc
parameter_list|)
block|{
return|return
name|default_section_type_flags_1
argument_list|(
name|decl
argument_list|,
name|name
argument_list|,
name|reloc
argument_list|,
name|true
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns true if FNTYPE (a FUNCTION_TYPE or a METHOD_TYPE) returns a    structure type and that the address of that type should be passed    in out0, rather than in r8.  */
end_comment

begin_function
specifier|static
name|bool
name|ia64_struct_retval_addr_is_first_parm_p
parameter_list|(
name|tree
name|fntype
parameter_list|)
block|{
name|tree
name|ret_type
init|=
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
decl_stmt|;
comment|/* The Itanium C++ ABI requires that out0, rather than r8, be used      as the structure return address parameter, if the return value      type has a non-trivial copy constructor or destructor.  It is not      clear if this same convention should be used for other      programming languages.  Until G++ 3.4, we incorrectly used r8 for      these return values.  */
return|return
operator|(
name|abi_version_at_least
argument_list|(
literal|2
argument_list|)
operator|&&
name|ret_type
operator|&&
name|TYPE_MODE
argument_list|(
name|ret_type
argument_list|)
operator|==
name|BLKmode
operator|&&
name|TREE_ADDRESSABLE
argument_list|(
name|ret_type
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|lang_hooks
operator|.
name|name
argument_list|,
literal|"GNU C++"
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Output the assembler code for a thunk function.  THUNK_DECL is the    declaration for the thunk function itself, FUNCTION is the decl for    the target function.  DELTA is an immediate constant offset to be    added to THIS.  If VCALL_OFFSET is nonzero, the word at    *(*this + vcall_offset) should be added to THIS.  */
end_comment

begin_function
specifier|static
name|void
name|ia64_output_mi_thunk
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|tree
name|thunk
name|ATTRIBUTE_UNUSED
parameter_list|,
name|HOST_WIDE_INT
name|delta
parameter_list|,
name|HOST_WIDE_INT
name|vcall_offset
parameter_list|,
name|tree
name|function
parameter_list|)
block|{
name|rtx
name|this
decl_stmt|,
name|insn
decl_stmt|,
name|funexp
decl_stmt|;
name|unsigned
name|int
name|this_parmno
decl_stmt|;
name|unsigned
name|int
name|this_regno
decl_stmt|;
name|reload_completed
operator|=
literal|1
expr_stmt|;
name|epilogue_completed
operator|=
literal|1
expr_stmt|;
name|no_new_pseudos
operator|=
literal|1
expr_stmt|;
comment|/* Set things up as ia64_expand_prologue might.  */
name|last_scratch_gr_reg
operator|=
literal|15
expr_stmt|;
name|memset
argument_list|(
operator|&
name|current_frame_info
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|current_frame_info
argument_list|)
argument_list|)
expr_stmt|;
name|current_frame_info
operator|.
name|spill_cfa_off
operator|=
operator|-
literal|16
expr_stmt|;
name|current_frame_info
operator|.
name|n_input_regs
operator|=
literal|1
expr_stmt|;
name|current_frame_info
operator|.
name|need_regstk
operator|=
operator|(
name|TARGET_REG_NAMES
operator|!=
literal|0
operator|)
expr_stmt|;
comment|/* Mark the end of the (empty) prologue.  */
name|emit_note
argument_list|(
name|NOTE_INSN_PROLOGUE_END
argument_list|)
expr_stmt|;
comment|/* Figure out whether "this" will be the first parameter (the      typical case) or the second parameter (as happens when the      virtual function returns certain class objects).  */
name|this_parmno
operator|=
operator|(
name|ia64_struct_retval_addr_is_first_parm_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|thunk
argument_list|)
argument_list|)
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
name|this_regno
operator|=
name|IN_REG
argument_list|(
name|this_parmno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TARGET_REG_NAMES
condition|)
name|reg_names
index|[
name|this_regno
index|]
operator|=
name|ia64_reg_numbers
index|[
name|this_parmno
index|]
expr_stmt|;
name|this
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|this_regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_ILP32
condition|)
block|{
name|rtx
name|tmp
init|=
name|gen_rtx_REG
argument_list|(
name|ptr_mode
argument_list|,
name|this_regno
argument_list|)
decl_stmt|;
name|REG_POINTER
argument_list|(
name|tmp
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|delta
operator|&&
name|CONST_OK_FOR_I
argument_list|(
name|delta
argument_list|)
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_ptr_extend_plus_imm
argument_list|(
name|this
argument_list|,
name|tmp
argument_list|,
name|GEN_INT
argument_list|(
name|delta
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|delta
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|emit_insn
argument_list|(
name|gen_ptr_extend
argument_list|(
name|this
argument_list|,
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Apply the constant offset, if required.  */
if|if
condition|(
name|delta
condition|)
block|{
name|rtx
name|delta_rtx
init|=
name|GEN_INT
argument_list|(
name|delta
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|CONST_OK_FOR_I
argument_list|(
name|delta
argument_list|)
condition|)
block|{
name|rtx
name|tmp
init|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|tmp
argument_list|,
name|delta_rtx
argument_list|)
expr_stmt|;
name|delta_rtx
operator|=
name|tmp
expr_stmt|;
block|}
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|this
argument_list|,
name|this
argument_list|,
name|delta_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Apply the offset from the vtable, if required.  */
if|if
condition|(
name|vcall_offset
condition|)
block|{
name|rtx
name|vcall_offset_rtx
init|=
name|GEN_INT
argument_list|(
name|vcall_offset
argument_list|)
decl_stmt|;
name|rtx
name|tmp
init|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
name|TARGET_ILP32
condition|)
block|{
name|rtx
name|t
init|=
name|gen_rtx_REG
argument_list|(
name|ptr_mode
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|REG_POINTER
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|emit_move_insn
argument_list|(
name|t
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|ptr_mode
argument_list|,
name|this
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONST_OK_FOR_I
argument_list|(
name|vcall_offset
argument_list|)
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_ptr_extend_plus_imm
argument_list|(
name|tmp
argument_list|,
name|t
argument_list|,
name|vcall_offset_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|vcall_offset
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|emit_insn
argument_list|(
name|gen_ptr_extend
argument_list|(
name|tmp
argument_list|,
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|emit_move_insn
argument_list|(
name|tmp
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|this
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vcall_offset
condition|)
block|{
if|if
condition|(
operator|!
name|CONST_OK_FOR_J
argument_list|(
name|vcall_offset
argument_list|)
condition|)
block|{
name|rtx
name|tmp2
init|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|next_scratch_gr_reg
argument_list|()
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|tmp2
argument_list|,
name|vcall_offset_rtx
argument_list|)
expr_stmt|;
name|vcall_offset_rtx
operator|=
name|tmp2
expr_stmt|;
block|}
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|tmp
argument_list|,
name|tmp
argument_list|,
name|vcall_offset_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_ILP32
condition|)
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|ptr_mode
argument_list|,
literal|2
argument_list|)
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|ptr_mode
argument_list|,
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_move_insn
argument_list|(
name|tmp
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_adddi3
argument_list|(
name|this
argument_list|,
name|this
argument_list|,
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Generate a tail call to the target function.  */
if|if
condition|(
operator|!
name|TREE_USED
argument_list|(
name|function
argument_list|)
condition|)
block|{
name|assemble_external
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|function
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|funexp
operator|=
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|function
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|funexp
operator|=
name|gen_rtx_MEM
argument_list|(
name|FUNCTION_MODE
argument_list|,
name|funexp
argument_list|)
expr_stmt|;
name|ia64_expand_call
argument_list|(
name|NULL_RTX
argument_list|,
name|funexp
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|insn
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|SIBLING_CALL_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Code generation for calls relies on splitting.  */
name|reload_completed
operator|=
literal|1
expr_stmt|;
name|epilogue_completed
operator|=
literal|1
expr_stmt|;
name|try_split
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_barrier
argument_list|()
expr_stmt|;
comment|/* Run just enough of rest_of_compilation to get the insns emitted.      There's not really enough bulk here to make other passes such as      instruction scheduling worth while.  Note that use_thunk calls      assemble_start_function and assemble_end_function.  */
name|insn_locators_initialize
argument_list|()
expr_stmt|;
name|emit_all_insn_group_barriers
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|insn
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|shorten_branches
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|final_start_function
argument_list|(
name|insn
argument_list|,
name|file
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|final
argument_list|(
name|insn
argument_list|,
name|file
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|final_end_function
argument_list|()
expr_stmt|;
name|reload_completed
operator|=
literal|0
expr_stmt|;
name|epilogue_completed
operator|=
literal|0
expr_stmt|;
name|no_new_pseudos
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Worker function for TARGET_STRUCT_VALUE_RTX.  */
end_comment

begin_function
specifier|static
name|rtx
name|ia64_struct_value_rtx
parameter_list|(
name|tree
name|fntype
parameter_list|,
name|int
name|incoming
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|fntype
operator|&&
name|ia64_struct_retval_addr_is_first_parm_p
argument_list|(
name|fntype
argument_list|)
condition|)
return|return
name|NULL_RTX
return|;
return|return
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|GR_REG
argument_list|(
literal|8
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_include
include|#
directive|include
file|"gt-ia64.h"
end_include

end_unit

