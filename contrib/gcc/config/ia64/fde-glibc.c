begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 2000, 2001 Free Software Foundation, Inc.    Contributed by Richard Henderson<rth@cygnus.com>.     This file is part of GNU CC.     GNU CC is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GNU CC is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GNU CC; see the file COPYING.  If not, write to    the Free Software Foundation, 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* As a special exception, if you link this library with other files,    some of which are compiled with GCC, to produce an executable,    this library does not by itself cause the resulting executable    to be covered by the GNU General Public License.    This exception does not however invalidate any other reasons why    the executable file might be covered by the GNU General Public License.  */
end_comment

begin_comment
comment|/* Locate the FDE entry for a given address, using glibc ld.so routines    to avoid register/deregister calls at DSO load/unload.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_GNU_SOURCE
end_ifndef

begin_define
define|#
directive|define
name|_GNU_SOURCE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<link.h>
end_include

begin_include
include|#
directive|include
file|"unwind-ia64.h"
end_include

begin_if
if|#
directive|if
name|__GLIBC__
operator|<
literal|2
operator|||
operator|(
name|__GLIBC__
operator|==
literal|2
operator|&&
name|__GLIBC_MINOR__
operator|<
literal|2
operator|)
expr|\
operator|||
operator|(
name|__GLIBC__
operator|==
literal|2
operator|&&
name|__GLIBC_MINOR__
operator|==
literal|2
operator|&&
operator|!
name|defined
argument_list|(
name|DT_CONFIG
argument_list|)
operator|)
end_if

begin_error
error|#
directive|error
error|You need GLIBC 2.2.4 or later on IA-64 Linux
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|unw_ia64_callback_data
block|{
name|Elf64_Addr
name|pc
decl_stmt|;
name|unsigned
name|long
modifier|*
name|segment_base
decl_stmt|;
name|unsigned
name|long
modifier|*
name|gp
decl_stmt|;
name|struct
name|unw_table_entry
modifier|*
name|ret
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|_Unwind_IteratePhdrCallback
parameter_list|(
name|struct
name|dl_phdr_info
modifier|*
name|info
parameter_list|,
name|size_t
name|size
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|struct
name|unw_ia64_callback_data
modifier|*
name|data
init|=
operator|(
expr|struct
name|unw_ia64_callback_data
operator|*
operator|)
name|ptr
decl_stmt|;
specifier|const
name|Elf64_Phdr
modifier|*
name|phdr
decl_stmt|,
modifier|*
name|p_unwind
decl_stmt|,
modifier|*
name|p_dynamic
decl_stmt|;
name|long
name|n
decl_stmt|,
name|match
decl_stmt|;
name|Elf64_Addr
name|load_base
decl_stmt|,
name|seg_base
decl_stmt|;
name|struct
name|unw_table_entry
modifier|*
name|f_base
decl_stmt|,
modifier|*
name|f
decl_stmt|;
name|size_t
name|lo
decl_stmt|,
name|hi
decl_stmt|;
comment|/* Make sure struct dl_phdr_info is at least as big as we need.  */
if|if
condition|(
name|size
operator|<
name|offsetof
argument_list|(
expr|struct
name|dl_phdr_info
argument_list|,
name|dlpi_phnum
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|info
operator|->
name|dlpi_phnum
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|match
operator|=
literal|0
expr_stmt|;
name|phdr
operator|=
name|info
operator|->
name|dlpi_phdr
expr_stmt|;
name|load_base
operator|=
name|info
operator|->
name|dlpi_addr
expr_stmt|;
name|p_unwind
operator|=
name|NULL
expr_stmt|;
name|p_dynamic
operator|=
name|NULL
expr_stmt|;
name|seg_base
operator|=
operator|~
operator|(
name|Elf64_Addr
operator|)
literal|0
expr_stmt|;
comment|/* See if PC falls into one of the loaded segments.  Find the unwind      segment at the same time.  */
for|for
control|(
name|n
operator|=
name|info
operator|->
name|dlpi_phnum
init|;
operator|--
name|n
operator|>=
literal|0
condition|;
name|phdr
operator|++
control|)
block|{
if|if
condition|(
name|phdr
operator|->
name|p_type
operator|==
name|PT_LOAD
condition|)
block|{
name|Elf64_Addr
name|vaddr
init|=
name|phdr
operator|->
name|p_vaddr
operator|+
name|load_base
decl_stmt|;
if|if
condition|(
name|data
operator|->
name|pc
operator|>=
name|vaddr
operator|&&
name|data
operator|->
name|pc
operator|<
name|vaddr
operator|+
name|phdr
operator|->
name|p_memsz
condition|)
name|match
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|vaddr
operator|<
name|seg_base
condition|)
name|seg_base
operator|=
name|vaddr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|phdr
operator|->
name|p_type
operator|==
name|PT_IA_64_UNWIND
condition|)
name|p_unwind
operator|=
name|phdr
expr_stmt|;
elseif|else
if|if
condition|(
name|phdr
operator|->
name|p_type
operator|==
name|PT_DYNAMIC
condition|)
name|p_dynamic
operator|=
name|phdr
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|match
operator|||
operator|!
name|p_unwind
condition|)
return|return
literal|0
return|;
comment|/* Search for the FDE within the unwind segment.  */
name|f_base
operator|=
operator|(
expr|struct
name|unw_table_entry
operator|*
operator|)
operator|(
name|p_unwind
operator|->
name|p_vaddr
operator|+
name|load_base
operator|)
expr_stmt|;
name|lo
operator|=
literal|0
expr_stmt|;
name|hi
operator|=
name|p_unwind
operator|->
name|p_memsz
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|unw_table_entry
argument_list|)
expr_stmt|;
while|while
condition|(
name|lo
operator|<
name|hi
condition|)
block|{
name|size_t
name|mid
init|=
operator|(
name|lo
operator|+
name|hi
operator|)
operator|/
literal|2
decl_stmt|;
name|f
operator|=
name|f_base
operator|+
name|mid
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|pc
operator|<
name|f
operator|->
name|start_offset
operator|+
name|seg_base
condition|)
name|hi
operator|=
name|mid
expr_stmt|;
elseif|else
if|if
condition|(
name|data
operator|->
name|pc
operator|>=
name|f
operator|->
name|end_offset
operator|+
name|seg_base
condition|)
name|lo
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
else|else
goto|goto
name|found
goto|;
block|}
comment|/* No need to search for further libraries when we know pc is contained      in this library.  */
return|return
literal|1
return|;
name|found
label|:
operator|*
name|data
operator|->
name|segment_base
operator|=
name|seg_base
expr_stmt|;
operator|*
name|data
operator|->
name|gp
operator|=
literal|0
expr_stmt|;
name|data
operator|->
name|ret
operator|=
name|f
expr_stmt|;
if|if
condition|(
name|p_dynamic
condition|)
block|{
comment|/* For dynamicly linked executables and shared libraries, 	 DT_PLTGOT is the gp value for that object.  */
name|Elf64_Dyn
modifier|*
name|dyn
init|=
operator|(
name|Elf64_Dyn
operator|*
operator|)
operator|(
name|p_dynamic
operator|->
name|p_vaddr
operator|+
name|load_base
operator|)
decl_stmt|;
for|for
control|(
init|;
name|dyn
operator|->
name|d_tag
operator|!=
name|DT_NULL
condition|;
name|dyn
operator|++
control|)
if|if
condition|(
name|dyn
operator|->
name|d_tag
operator|==
name|DT_PLTGOT
condition|)
block|{
comment|/* On IA-64, _DYNAMIC is writable and GLIBC has relocated it.  */
operator|*
name|data
operator|->
name|gp
operator|=
name|dyn
operator|->
name|d_un
operator|.
name|d_ptr
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* Otherwise this is a static executable with no _DYNAMIC. 	 The gp is constant program-wide.  */
specifier|register
name|unsigned
name|long
name|gp
name|__asm__
argument_list|(
literal|"gp"
argument_list|)
decl_stmt|;
operator|*
name|data
operator|->
name|gp
operator|=
name|gp
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return a pointer to the unwind table entry for the function    containing PC.  */
end_comment

begin_function
name|struct
name|unw_table_entry
modifier|*
name|_Unwind_FindTableEntry
parameter_list|(
name|void
modifier|*
name|pc
parameter_list|,
name|unsigned
name|long
modifier|*
name|segment_base
parameter_list|,
name|unsigned
name|long
modifier|*
name|gp
parameter_list|)
block|{
name|struct
name|unw_ia64_callback_data
name|data
decl_stmt|;
name|data
operator|.
name|pc
operator|=
operator|(
name|Elf64_Addr
operator|)
name|pc
expr_stmt|;
name|data
operator|.
name|segment_base
operator|=
name|segment_base
expr_stmt|;
name|data
operator|.
name|gp
operator|=
name|gp
expr_stmt|;
name|data
operator|.
name|ret
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|dl_iterate_phdr
argument_list|(
name|_Unwind_IteratePhdrCallback
argument_list|,
operator|&
name|data
argument_list|)
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
return|return
name|data
operator|.
name|ret
return|;
block|}
end_function

end_unit

