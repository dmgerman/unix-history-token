begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Subroutines needed for unwinding IA-64 standard format stack frame    info for exception handling.    Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002    Free Software Foundation, Inc.    Contributed by Andrew MacLeod<amacleod@cygnus.com> 	          Andrew Haley<aph@cygnus.com> 		  David Mosberger-Tang<davidm@hpl.hp.com>     This file is part of GCC.     GCC is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GCC is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GCC; see the file COPYING.  If not, write to    the Free Software Foundation, 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* As a special exception, if you link this library with other files,    some of which are compiled with GCC, to produce an executable,    this library does not by itself cause the resulting executable    to be covered by the GNU General Public License.    This exception does not however invalidate any other reasons why    the executable file might be covered by the GNU General Public License.  */
end_comment

begin_include
include|#
directive|include
file|"tconfig.h"
end_include

begin_include
include|#
directive|include
file|"tsystem.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"unwind.h"
end_include

begin_include
include|#
directive|include
file|"unwind-ia64.h"
end_include

begin_include
include|#
directive|include
file|"unwind-compat.h"
end_include

begin_include
include|#
directive|include
file|"ia64intrin.h"
end_include

begin_comment
comment|/* This isn't thread safe, but nice for occasional tests.  */
end_comment

begin_undef
undef|#
directive|undef
name|ENABLE_MALLOC_CHECKING
end_undef

begin_ifndef
ifndef|#
directive|ifndef
name|__USING_SJLJ_EXCEPTIONS__
end_ifndef

begin_define
define|#
directive|define
name|UNW_VER
parameter_list|(
name|x
parameter_list|)
value|((x)>> 48)
end_define

begin_define
define|#
directive|define
name|UNW_FLAG_MASK
value|0x0000ffff00000000
end_define

begin_define
define|#
directive|define
name|UNW_FLAG_OSMASK
value|0x0000f00000000000
end_define

begin_define
define|#
directive|define
name|UNW_FLAG_EHANDLER
parameter_list|(
name|x
parameter_list|)
value|((x)& 0x0000000100000000L)
end_define

begin_define
define|#
directive|define
name|UNW_FLAG_UHANDLER
parameter_list|(
name|x
parameter_list|)
value|((x)& 0x0000000200000000L)
end_define

begin_define
define|#
directive|define
name|UNW_LENGTH
parameter_list|(
name|x
parameter_list|)
value|((x)& 0x00000000ffffffffL)
end_define

begin_enum
enum|enum
name|unw_application_register
block|{
name|UNW_AR_BSP
block|,
name|UNW_AR_BSPSTORE
block|,
name|UNW_AR_PFS
block|,
name|UNW_AR_RNAT
block|,
name|UNW_AR_UNAT
block|,
name|UNW_AR_LC
block|,
name|UNW_AR_EC
block|,
name|UNW_AR_FPSR
block|,
name|UNW_AR_RSC
block|,
name|UNW_AR_CCV
block|}
enum|;
end_enum

begin_enum
enum|enum
name|unw_register_index
block|{
comment|/* Primary UNAT.  */
name|UNW_REG_PRI_UNAT_GR
block|,
name|UNW_REG_PRI_UNAT_MEM
block|,
comment|/* Memory Stack.  */
name|UNW_REG_PSP
block|,
comment|/* previous memory stack pointer */
comment|/* Register Stack.  */
name|UNW_REG_BSP
block|,
comment|/* register stack pointer */
name|UNW_REG_BSPSTORE
block|,
name|UNW_REG_PFS
block|,
comment|/* previous function state */
name|UNW_REG_RNAT
block|,
comment|/* Return Pointer.  */
name|UNW_REG_RP
block|,
comment|/* Special preserved registers.  */
name|UNW_REG_UNAT
block|,
name|UNW_REG_PR
block|,
name|UNW_REG_LC
block|,
name|UNW_REG_FPSR
block|,
comment|/* Non-stacked general registers.  */
name|UNW_REG_R2
block|,
name|UNW_REG_R4
init|=
name|UNW_REG_R2
operator|+
literal|2
block|,
name|UNW_REG_R7
init|=
name|UNW_REG_R2
operator|+
literal|5
block|,
name|UNW_REG_R31
init|=
name|UNW_REG_R2
operator|+
literal|29
block|,
comment|/* Non-stacked floating point registers.  */
name|UNW_REG_F2
block|,
name|UNW_REG_F5
init|=
name|UNW_REG_F2
operator|+
literal|3
block|,
name|UNW_REG_F16
init|=
name|UNW_REG_F2
operator|+
literal|14
block|,
name|UNW_REG_F31
init|=
name|UNW_REG_F2
operator|+
literal|29
block|,
comment|/* Branch registers.  */
name|UNW_REG_B0
block|,
name|UNW_REG_B1
block|,
name|UNW_REG_B5
init|=
name|UNW_REG_B1
operator|+
literal|4
block|,
name|UNW_NUM_REGS
block|}
enum|;
end_enum

begin_enum
enum|enum
name|unw_where
block|{
name|UNW_WHERE_NONE
block|,
comment|/* register isn't saved at all */
name|UNW_WHERE_GR
block|,
comment|/* register is saved in a general register */
name|UNW_WHERE_FR
block|,
comment|/* register is saved in a floating-point register */
name|UNW_WHERE_BR
block|,
comment|/* register is saved in a branch register */
name|UNW_WHERE_SPREL
block|,
comment|/* register is saved on memstack (sp-relative) */
name|UNW_WHERE_PSPREL
block|,
comment|/* register is saved on memstack (psp-relative) */
comment|/* At the end of each prologue these locations get resolved to      UNW_WHERE_PSPREL and UNW_WHERE_GR, respectively.  */
name|UNW_WHERE_SPILL_HOME
block|,
comment|/* register is saved in its spill home */
name|UNW_WHERE_GR_SAVE
comment|/* register is saved in next general register */
block|}
enum|;
end_enum

begin_define
define|#
directive|define
name|UNW_WHEN_NEVER
value|0x7fffffff
end_define

begin_struct
struct|struct
name|unw_reg_info
block|{
name|unsigned
name|long
name|val
decl_stmt|;
comment|/* save location: register number or offset */
name|enum
name|unw_where
name|where
decl_stmt|;
comment|/* where the register gets saved */
name|int
name|when
decl_stmt|;
comment|/* when the register gets saved */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|unw_reg_state
block|{
name|struct
name|unw_reg_state
modifier|*
name|next
decl_stmt|;
comment|/* next (outer) element on state stack */
name|struct
name|unw_reg_info
name|reg
index|[
name|UNW_NUM_REGS
index|]
decl_stmt|;
comment|/* register save locations */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|unw_labeled_state
block|{
name|struct
name|unw_labeled_state
modifier|*
name|next
decl_stmt|;
comment|/* next labeled state (or NULL) */
name|unsigned
name|long
name|label
decl_stmt|;
comment|/* label for this state */
name|struct
name|unw_reg_state
name|saved_state
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
struct|struct
name|unw_state_record
block|{
name|unsigned
name|int
name|first_region
range|:
literal|1
decl_stmt|;
comment|/* is this the first region? */
name|unsigned
name|int
name|done
range|:
literal|1
decl_stmt|;
comment|/* are we done scanning descriptors? */
name|unsigned
name|int
name|any_spills
range|:
literal|1
decl_stmt|;
comment|/* got any register spills? */
name|unsigned
name|int
name|in_body
range|:
literal|1
decl_stmt|;
comment|/* are we inside a body? */
name|unsigned
name|int
name|no_reg_stack_frame
range|:
literal|1
decl_stmt|;
comment|/* Don't adjust bsp for i&l regs */
name|unsigned
name|char
modifier|*
name|imask
decl_stmt|;
comment|/* imask of spill_mask record or NULL */
name|unsigned
name|long
name|pr_val
decl_stmt|;
comment|/* predicate values */
name|unsigned
name|long
name|pr_mask
decl_stmt|;
comment|/* predicate mask */
name|long
name|spill_offset
decl_stmt|;
comment|/* psp-relative offset for spill base */
name|int
name|region_start
decl_stmt|;
name|int
name|region_len
decl_stmt|;
name|int
name|epilogue_start
decl_stmt|;
name|int
name|epilogue_count
decl_stmt|;
name|int
name|when_target
decl_stmt|;
name|unsigned
name|char
name|gr_save_loc
decl_stmt|;
comment|/* next general register to use for saving */
name|unsigned
name|char
name|return_link_reg
decl_stmt|;
comment|/* branch register for return link */
name|unsigned
name|short
name|unwabi
decl_stmt|;
name|struct
name|unw_labeled_state
modifier|*
name|labeled_states
decl_stmt|;
comment|/* list of all labeled states */
name|struct
name|unw_reg_state
name|curr
decl_stmt|;
comment|/* current state */
name|_Unwind_Personality_Fn
name|personality
decl_stmt|;
block|}
name|_Unwind_FrameState
typedef|;
end_typedef

begin_enum
enum|enum
name|unw_nat_type
block|{
name|UNW_NAT_NONE
block|,
comment|/* NaT not represented */
name|UNW_NAT_VAL
block|,
comment|/* NaT represented by NaT value (fp reg) */
name|UNW_NAT_MEMSTK
block|,
comment|/* NaT value is in unat word at offset OFF  */
name|UNW_NAT_REGSTK
comment|/* NaT is in rnat */
block|}
enum|;
end_enum

begin_struct
struct|struct
name|unw_stack
block|{
name|unsigned
name|long
name|limit
decl_stmt|;
name|unsigned
name|long
name|top
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|_Unwind_Context
block|{
comment|/* Initial frame info.  */
name|unsigned
name|long
name|rnat
decl_stmt|;
comment|/* rse nat collection */
name|unsigned
name|long
name|regstk_top
decl_stmt|;
comment|/* lowest address of rbs stored register 				   which uses context->rnat collection */
comment|/* Current frame info.  */
name|unsigned
name|long
name|bsp
decl_stmt|;
comment|/* backing store pointer value 				   corresponding to psp.  */
name|unsigned
name|long
name|sp
decl_stmt|;
comment|/* stack pointer value */
name|unsigned
name|long
name|psp
decl_stmt|;
comment|/* previous sp value */
name|unsigned
name|long
name|rp
decl_stmt|;
comment|/* return pointer */
name|unsigned
name|long
name|pr
decl_stmt|;
comment|/* predicate collection */
name|unsigned
name|long
name|region_start
decl_stmt|;
comment|/* start of unwind region */
name|unsigned
name|long
name|gp
decl_stmt|;
comment|/* global pointer value */
name|void
modifier|*
name|lsda
decl_stmt|;
comment|/* language specific data area */
comment|/* Preserved state.  */
name|unsigned
name|long
modifier|*
name|bsp_loc
decl_stmt|;
comment|/* previous bsp save location   				   Appears to be write-only?	*/
name|unsigned
name|long
modifier|*
name|bspstore_loc
decl_stmt|;
name|unsigned
name|long
modifier|*
name|pfs_loc
decl_stmt|;
comment|/* Save location for pfs in current   				   (corr. to sp) frame.  Target   				   contains cfm for caller.	*/
name|unsigned
name|long
modifier|*
name|pri_unat_loc
decl_stmt|;
name|unsigned
name|long
modifier|*
name|unat_loc
decl_stmt|;
name|unsigned
name|long
modifier|*
name|lc_loc
decl_stmt|;
name|unsigned
name|long
modifier|*
name|fpsr_loc
decl_stmt|;
name|unsigned
name|long
name|eh_data
index|[
literal|4
index|]
decl_stmt|;
struct|struct
name|unw_ireg
block|{
name|unsigned
name|long
modifier|*
name|loc
decl_stmt|;
struct|struct
name|unw_ireg_nat
block|{
name|enum
name|unw_nat_type
name|type
range|:
literal|3
decl_stmt|;
name|signed
name|long
name|off
range|:
literal|61
decl_stmt|;
comment|/* NaT word is at loc+nat.off */
block|}
name|nat
struct|;
block|}
name|ireg
index|[
literal|32
operator|-
literal|2
index|]
struct|;
comment|/* Indexed by<register number> - 2 */
name|unsigned
name|long
modifier|*
name|br_loc
index|[
literal|8
index|]
decl_stmt|;
name|void
modifier|*
name|fr_loc
index|[
literal|32
operator|-
literal|2
index|]
decl_stmt|;
comment|/* ??? We initially point pri_unat_loc here.  The entire NAT bit      logic needs work.  */
name|unsigned
name|long
name|initial_unat
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|unsigned
name|long
name|unw_word
typedef|;
end_typedef

begin_comment
comment|/* Implicit register save order.  See section 11.4.2.3 Rules for Using    Unwind Descriptors, rule 3.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|char
specifier|const
name|save_order
index|[]
init|=
block|{
name|UNW_REG_RP
block|,
name|UNW_REG_PFS
block|,
name|UNW_REG_PSP
block|,
name|UNW_REG_PR
block|,
name|UNW_REG_UNAT
block|,
name|UNW_REG_LC
block|,
name|UNW_REG_FPSR
block|,
name|UNW_REG_PRI_UNAT_GR
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_define
define|#
directive|define
name|MIN
parameter_list|(
name|X
parameter_list|,
name|Y
parameter_list|)
value|((X)< (Y) ? (X) : (Y))
end_define

begin_comment
comment|/* MASK is a bitmap describing the allocation state of emergency buffers,    with bit set indicating free. Return>= 0 if allocation is successful;< 0 if failure.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|atomic_alloc
parameter_list|(
name|unsigned
name|int
modifier|*
name|mask
parameter_list|)
block|{
name|unsigned
name|int
name|old
init|=
operator|*
name|mask
decl_stmt|,
name|ret
decl_stmt|,
name|new
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|old
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|ret
operator|=
name|old
operator|&
operator|-
name|old
expr_stmt|;
name|new
operator|=
name|old
operator|&
operator|~
name|ret
expr_stmt|;
name|new
operator|=
name|__sync_val_compare_and_swap
argument_list|(
name|mask
argument_list|,
name|old
argument_list|,
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|==
name|new
condition|)
break|break;
name|old
operator|=
name|new
expr_stmt|;
block|}
return|return
name|__builtin_ffs
argument_list|(
name|ret
argument_list|)
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Similarly, free an emergency buffer.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|atomic_free
parameter_list|(
name|unsigned
name|int
modifier|*
name|mask
parameter_list|,
name|int
name|bit
parameter_list|)
block|{
name|__sync_xor_and_fetch
argument_list|(
name|mask
argument_list|,
literal|1
operator|<<
name|bit
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|SIZE
parameter_list|(
name|X
parameter_list|)
value|(sizeof(X) / sizeof(*(X)))
end_define

begin_define
define|#
directive|define
name|MASK_FOR
parameter_list|(
name|X
parameter_list|)
value|((2U<< (SIZE (X) - 1)) - 1)
end_define

begin_define
define|#
directive|define
name|PTR_IN
parameter_list|(
name|X
parameter_list|,
name|P
parameter_list|)
value|((P)>= (X)&& (P)< (X) + SIZE (X))
end_define

begin_decl_stmt
specifier|static
name|struct
name|unw_reg_state
name|emergency_reg_state
index|[
literal|32
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|emergency_reg_state_free
init|=
name|MASK_FOR
argument_list|(
name|emergency_reg_state
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|unw_labeled_state
name|emergency_labeled_state
index|[
literal|8
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|emergency_labeled_state_free
init|=
name|MASK_FOR
argument_list|(
name|emergency_labeled_state
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|ENABLE_MALLOC_CHECKING
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|reg_state_alloced
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|labeled_state_alloced
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Allocation and deallocation of structures.  */
end_comment

begin_function
specifier|static
name|struct
name|unw_reg_state
modifier|*
name|alloc_reg_state
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|unw_reg_state
modifier|*
name|rs
decl_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_MALLOC_CHECKING
name|reg_state_alloced
operator|++
expr_stmt|;
endif|#
directive|endif
name|rs
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|unw_reg_state
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rs
condition|)
block|{
name|int
name|n
init|=
name|atomic_alloc
argument_list|(
operator|&
name|emergency_reg_state_free
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|>=
literal|0
condition|)
name|rs
operator|=
operator|&
name|emergency_reg_state
index|[
name|n
index|]
expr_stmt|;
block|}
return|return
name|rs
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_reg_state
parameter_list|(
name|struct
name|unw_reg_state
modifier|*
name|rs
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ENABLE_MALLOC_CHECKING
name|reg_state_alloced
operator|--
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|PTR_IN
argument_list|(
name|emergency_reg_state
argument_list|,
name|rs
argument_list|)
condition|)
name|atomic_free
argument_list|(
operator|&
name|emergency_reg_state_free
argument_list|,
name|rs
operator|-
name|emergency_reg_state
argument_list|)
expr_stmt|;
else|else
name|free
argument_list|(
name|rs
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|unw_labeled_state
modifier|*
name|alloc_label_state
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|unw_labeled_state
modifier|*
name|ls
decl_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_MALLOC_CHECKING
name|labeled_state_alloced
operator|++
expr_stmt|;
endif|#
directive|endif
name|ls
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|unw_labeled_state
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ls
condition|)
block|{
name|int
name|n
init|=
name|atomic_alloc
argument_list|(
operator|&
name|emergency_labeled_state_free
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|>=
literal|0
condition|)
name|ls
operator|=
operator|&
name|emergency_labeled_state
index|[
name|n
index|]
expr_stmt|;
block|}
return|return
name|ls
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_label_state
parameter_list|(
name|struct
name|unw_labeled_state
modifier|*
name|ls
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ENABLE_MALLOC_CHECKING
name|labeled_state_alloced
operator|--
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|PTR_IN
argument_list|(
name|emergency_labeled_state
argument_list|,
name|ls
argument_list|)
condition|)
name|atomic_free
argument_list|(
operator|&
name|emergency_labeled_state_free
argument_list|,
name|emergency_labeled_state
operator|-
name|ls
argument_list|)
expr_stmt|;
else|else
name|free
argument_list|(
name|ls
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Routines to manipulate the state stack.  */
end_comment

begin_function
specifier|static
name|void
name|push
parameter_list|(
name|struct
name|unw_state_record
modifier|*
name|sr
parameter_list|)
block|{
name|struct
name|unw_reg_state
modifier|*
name|rs
init|=
name|alloc_reg_state
argument_list|()
decl_stmt|;
name|memcpy
argument_list|(
name|rs
argument_list|,
operator|&
name|sr
operator|->
name|curr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rs
argument_list|)
argument_list|)
expr_stmt|;
name|sr
operator|->
name|curr
operator|.
name|next
operator|=
name|rs
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pop
parameter_list|(
name|struct
name|unw_state_record
modifier|*
name|sr
parameter_list|)
block|{
name|struct
name|unw_reg_state
modifier|*
name|rs
init|=
name|sr
operator|->
name|curr
operator|.
name|next
decl_stmt|;
if|if
condition|(
operator|!
name|rs
condition|)
name|abort
argument_list|()
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|sr
operator|->
name|curr
argument_list|,
name|rs
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rs
argument_list|)
argument_list|)
expr_stmt|;
name|free_reg_state
argument_list|(
name|rs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make a copy of the state stack.  Non-recursive to avoid stack overflows.  */
end_comment

begin_function
specifier|static
name|struct
name|unw_reg_state
modifier|*
name|dup_state_stack
parameter_list|(
name|struct
name|unw_reg_state
modifier|*
name|rs
parameter_list|)
block|{
name|struct
name|unw_reg_state
modifier|*
name|copy
decl_stmt|,
modifier|*
name|prev
init|=
name|NULL
decl_stmt|,
modifier|*
name|first
init|=
name|NULL
decl_stmt|;
while|while
condition|(
name|rs
condition|)
block|{
name|copy
operator|=
name|alloc_reg_state
argument_list|()
expr_stmt|;
name|memcpy
argument_list|(
name|copy
argument_list|,
name|rs
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|copy
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|first
condition|)
name|prev
operator|->
name|next
operator|=
name|copy
expr_stmt|;
else|else
name|first
operator|=
name|copy
expr_stmt|;
name|rs
operator|=
name|rs
operator|->
name|next
expr_stmt|;
name|prev
operator|=
name|copy
expr_stmt|;
block|}
return|return
name|first
return|;
block|}
end_function

begin_comment
comment|/* Free all stacked register states (but not RS itself).  */
end_comment

begin_function
specifier|static
name|void
name|free_state_stack
parameter_list|(
name|struct
name|unw_reg_state
modifier|*
name|rs
parameter_list|)
block|{
name|struct
name|unw_reg_state
modifier|*
name|p
decl_stmt|,
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|p
operator|=
name|rs
operator|->
name|next
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|next
control|)
block|{
name|next
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|free_reg_state
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|rs
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free all labeled states.  */
end_comment

begin_function
specifier|static
name|void
name|free_label_states
parameter_list|(
name|struct
name|unw_labeled_state
modifier|*
name|ls
parameter_list|)
block|{
name|struct
name|unw_labeled_state
modifier|*
name|next
decl_stmt|;
for|for
control|(
init|;
name|ls
condition|;
name|ls
operator|=
name|next
control|)
block|{
name|next
operator|=
name|ls
operator|->
name|next
expr_stmt|;
name|free_state_stack
argument_list|(
operator|&
name|ls
operator|->
name|saved_state
argument_list|)
expr_stmt|;
name|free_label_state
argument_list|(
name|ls
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Unwind decoder routines */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|unw_register_index
name|__attribute__
argument_list|(
operator|(
specifier|const
operator|)
argument_list|)
name|decode_abreg
argument_list|(
name|unsigned
name|char
name|abreg
argument_list|,
name|int
name|memory
argument_list|)
block|{
switch|switch
condition|(
name|abreg
condition|)
block|{
case|case
literal|0x04
operator|...
literal|0x07
case|:
return|return
name|UNW_REG_R4
operator|+
operator|(
name|abreg
operator|-
literal|0x04
operator|)
return|;
case|case
literal|0x22
operator|...
literal|0x25
case|:
return|return
name|UNW_REG_F2
operator|+
operator|(
name|abreg
operator|-
literal|0x22
operator|)
return|;
case|case
literal|0x30
operator|...
literal|0x3f
case|:
return|return
name|UNW_REG_F16
operator|+
operator|(
name|abreg
operator|-
literal|0x30
operator|)
return|;
case|case
literal|0x41
operator|...
literal|0x45
case|:
return|return
name|UNW_REG_B1
operator|+
operator|(
name|abreg
operator|-
literal|0x41
operator|)
return|;
case|case
literal|0x60
case|:
return|return
name|UNW_REG_PR
return|;
case|case
literal|0x61
case|:
return|return
name|UNW_REG_PSP
return|;
case|case
literal|0x62
case|:
return|return
name|memory
condition|?
name|UNW_REG_PRI_UNAT_MEM
else|:
name|UNW_REG_PRI_UNAT_GR
return|;
case|case
literal|0x63
case|:
return|return
name|UNW_REG_RP
return|;
case|case
literal|0x64
case|:
return|return
name|UNW_REG_BSP
return|;
case|case
literal|0x65
case|:
return|return
name|UNW_REG_BSPSTORE
return|;
case|case
literal|0x66
case|:
return|return
name|UNW_REG_RNAT
return|;
case|case
literal|0x67
case|:
return|return
name|UNW_REG_UNAT
return|;
case|case
literal|0x68
case|:
return|return
name|UNW_REG_FPSR
return|;
case|case
literal|0x69
case|:
return|return
name|UNW_REG_PFS
return|;
case|case
literal|0x6a
case|:
return|return
name|UNW_REG_LC
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_function
specifier|static
name|void
name|set_reg
parameter_list|(
name|struct
name|unw_reg_info
modifier|*
name|reg
parameter_list|,
name|enum
name|unw_where
name|where
parameter_list|,
name|int
name|when
parameter_list|,
name|unsigned
name|long
name|val
parameter_list|)
block|{
name|reg
operator|->
name|val
operator|=
name|val
expr_stmt|;
name|reg
operator|->
name|where
operator|=
name|where
expr_stmt|;
if|if
condition|(
name|reg
operator|->
name|when
operator|==
name|UNW_WHEN_NEVER
condition|)
name|reg
operator|->
name|when
operator|=
name|when
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|alloc_spill_area
parameter_list|(
name|unsigned
name|long
modifier|*
name|offp
parameter_list|,
name|unsigned
name|long
name|regsize
parameter_list|,
name|struct
name|unw_reg_info
modifier|*
name|lo
parameter_list|,
name|struct
name|unw_reg_info
modifier|*
name|hi
parameter_list|)
block|{
name|struct
name|unw_reg_info
modifier|*
name|reg
decl_stmt|;
for|for
control|(
name|reg
operator|=
name|hi
init|;
name|reg
operator|>=
name|lo
condition|;
operator|--
name|reg
control|)
block|{
if|if
condition|(
name|reg
operator|->
name|where
operator|==
name|UNW_WHERE_SPILL_HOME
condition|)
block|{
name|reg
operator|->
name|where
operator|=
name|UNW_WHERE_PSPREL
expr_stmt|;
operator|*
name|offp
operator|-=
name|regsize
expr_stmt|;
name|reg
operator|->
name|val
operator|=
operator|*
name|offp
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|spill_next_when
parameter_list|(
name|struct
name|unw_reg_info
modifier|*
modifier|*
name|regp
parameter_list|,
name|struct
name|unw_reg_info
modifier|*
name|lim
parameter_list|,
name|unw_word
name|t
parameter_list|)
block|{
name|struct
name|unw_reg_info
modifier|*
name|reg
decl_stmt|;
for|for
control|(
name|reg
operator|=
operator|*
name|regp
init|;
name|reg
operator|<=
name|lim
condition|;
operator|++
name|reg
control|)
block|{
if|if
condition|(
name|reg
operator|->
name|where
operator|==
name|UNW_WHERE_SPILL_HOME
condition|)
block|{
name|reg
operator|->
name|when
operator|=
name|t
expr_stmt|;
operator|*
name|regp
operator|=
name|reg
operator|+
literal|1
expr_stmt|;
return|return;
block|}
block|}
comment|/* Excess spill.  */
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|finish_prologue
parameter_list|(
name|struct
name|unw_state_record
modifier|*
name|sr
parameter_list|)
block|{
name|struct
name|unw_reg_info
modifier|*
name|reg
decl_stmt|;
name|unsigned
name|long
name|off
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* First, resolve implicit register save locations      (see Section "11.4.2.3 Rules for Using Unwind Descriptors", rule 3).  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|save_order
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|reg
operator|=
name|sr
operator|->
name|curr
operator|.
name|reg
operator|+
name|save_order
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|reg
operator|->
name|where
operator|==
name|UNW_WHERE_GR_SAVE
condition|)
block|{
name|reg
operator|->
name|where
operator|=
name|UNW_WHERE_GR
expr_stmt|;
name|reg
operator|->
name|val
operator|=
name|sr
operator|->
name|gr_save_loc
operator|++
expr_stmt|;
block|}
block|}
comment|/* Next, compute when the fp, general, and branch registers get saved.      This must come before alloc_spill_area() because we need to know      which registers are spilled to their home locations.  */
if|if
condition|(
name|sr
operator|->
name|imask
condition|)
block|{
specifier|static
name|unsigned
name|char
specifier|const
name|limit
index|[
literal|3
index|]
init|=
block|{
name|UNW_REG_F31
block|,
name|UNW_REG_R7
block|,
name|UNW_REG_B5
block|}
decl_stmt|;
name|unsigned
name|char
name|kind
decl_stmt|,
name|mask
init|=
literal|0
decl_stmt|,
modifier|*
name|cp
init|=
name|sr
operator|->
name|imask
decl_stmt|;
name|int
name|t
decl_stmt|;
name|struct
name|unw_reg_info
modifier|*
argument_list|(
name|regs
index|[
literal|3
index|]
argument_list|)
decl_stmt|;
name|regs
index|[
literal|0
index|]
operator|=
name|sr
operator|->
name|curr
operator|.
name|reg
operator|+
name|UNW_REG_F2
expr_stmt|;
name|regs
index|[
literal|1
index|]
operator|=
name|sr
operator|->
name|curr
operator|.
name|reg
operator|+
name|UNW_REG_R4
expr_stmt|;
name|regs
index|[
literal|2
index|]
operator|=
name|sr
operator|->
name|curr
operator|.
name|reg
operator|+
name|UNW_REG_B1
expr_stmt|;
for|for
control|(
name|t
operator|=
literal|0
init|;
name|t
operator|<
name|sr
operator|->
name|region_len
condition|;
operator|++
name|t
control|)
block|{
if|if
condition|(
operator|(
name|t
operator|&
literal|3
operator|)
operator|==
literal|0
condition|)
name|mask
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
name|kind
operator|=
operator|(
name|mask
operator|>>
literal|2
operator|*
operator|(
literal|3
operator|-
operator|(
name|t
operator|&
literal|3
operator|)
operator|)
operator|)
operator|&
literal|3
expr_stmt|;
if|if
condition|(
name|kind
operator|>
literal|0
condition|)
name|spill_next_when
argument_list|(
operator|&
name|regs
index|[
name|kind
operator|-
literal|1
index|]
argument_list|,
name|sr
operator|->
name|curr
operator|.
name|reg
operator|+
name|limit
index|[
name|kind
operator|-
literal|1
index|]
argument_list|,
name|sr
operator|->
name|region_start
operator|+
name|t
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Next, lay out the memory stack spill area.  */
if|if
condition|(
name|sr
operator|->
name|any_spills
condition|)
block|{
name|off
operator|=
name|sr
operator|->
name|spill_offset
expr_stmt|;
name|alloc_spill_area
argument_list|(
operator|&
name|off
argument_list|,
literal|16
argument_list|,
name|sr
operator|->
name|curr
operator|.
name|reg
operator|+
name|UNW_REG_F2
argument_list|,
name|sr
operator|->
name|curr
operator|.
name|reg
operator|+
name|UNW_REG_F31
argument_list|)
expr_stmt|;
name|alloc_spill_area
argument_list|(
operator|&
name|off
argument_list|,
literal|8
argument_list|,
name|sr
operator|->
name|curr
operator|.
name|reg
operator|+
name|UNW_REG_B1
argument_list|,
name|sr
operator|->
name|curr
operator|.
name|reg
operator|+
name|UNW_REG_B5
argument_list|)
expr_stmt|;
name|alloc_spill_area
argument_list|(
operator|&
name|off
argument_list|,
literal|8
argument_list|,
name|sr
operator|->
name|curr
operator|.
name|reg
operator|+
name|UNW_REG_R4
argument_list|,
name|sr
operator|->
name|curr
operator|.
name|reg
operator|+
name|UNW_REG_R7
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Region header descriptors.  */
end_comment

begin_function
specifier|static
name|void
name|desc_prologue
parameter_list|(
name|int
name|body
parameter_list|,
name|unw_word
name|rlen
parameter_list|,
name|unsigned
name|char
name|mask
parameter_list|,
name|unsigned
name|char
name|grsave
parameter_list|,
name|struct
name|unw_state_record
modifier|*
name|sr
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|sr
operator|->
name|in_body
operator|||
name|sr
operator|->
name|first_region
operator|)
condition|)
name|finish_prologue
argument_list|(
name|sr
argument_list|)
expr_stmt|;
name|sr
operator|->
name|first_region
operator|=
literal|0
expr_stmt|;
comment|/* Check if we're done.  */
if|if
condition|(
name|sr
operator|->
name|when_target
operator|<
name|sr
operator|->
name|region_start
operator|+
name|sr
operator|->
name|region_len
condition|)
block|{
name|sr
operator|->
name|done
operator|=
literal|1
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sr
operator|->
name|epilogue_count
condition|;
operator|++
name|i
control|)
name|pop
argument_list|(
name|sr
argument_list|)
expr_stmt|;
name|sr
operator|->
name|epilogue_count
operator|=
literal|0
expr_stmt|;
name|sr
operator|->
name|epilogue_start
operator|=
name|UNW_WHEN_NEVER
expr_stmt|;
if|if
condition|(
operator|!
name|body
condition|)
name|push
argument_list|(
name|sr
argument_list|)
expr_stmt|;
name|sr
operator|->
name|region_start
operator|+=
name|sr
operator|->
name|region_len
expr_stmt|;
name|sr
operator|->
name|region_len
operator|=
name|rlen
expr_stmt|;
name|sr
operator|->
name|in_body
operator|=
name|body
expr_stmt|;
if|if
condition|(
operator|!
name|body
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|mask
operator|&
literal|0x8
condition|)
name|set_reg
argument_list|(
name|sr
operator|->
name|curr
operator|.
name|reg
operator|+
name|save_order
index|[
name|i
index|]
argument_list|,
name|UNW_WHERE_GR
argument_list|,
name|sr
operator|->
name|region_start
operator|+
name|sr
operator|->
name|region_len
operator|-
literal|1
argument_list|,
name|grsave
operator|++
argument_list|)
expr_stmt|;
name|mask
operator|<<=
literal|1
expr_stmt|;
block|}
name|sr
operator|->
name|gr_save_loc
operator|=
name|grsave
expr_stmt|;
name|sr
operator|->
name|any_spills
operator|=
literal|0
expr_stmt|;
name|sr
operator|->
name|imask
operator|=
literal|0
expr_stmt|;
name|sr
operator|->
name|spill_offset
operator|=
literal|0x10
expr_stmt|;
comment|/* default to psp+16 */
block|}
block|}
end_function

begin_comment
comment|/*  * Prologue descriptors.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|desc_abi
parameter_list|(
name|unsigned
name|char
name|abi
parameter_list|,
name|unsigned
name|char
name|context
parameter_list|,
name|struct
name|unw_state_record
modifier|*
name|sr
parameter_list|)
block|{
name|sr
operator|->
name|unwabi
operator|=
operator|(
name|abi
operator|<<
literal|8
operator|)
operator||
name|context
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|desc_br_gr
parameter_list|(
name|unsigned
name|char
name|brmask
parameter_list|,
name|unsigned
name|char
name|gr
parameter_list|,
name|struct
name|unw_state_record
modifier|*
name|sr
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|brmask
operator|&
literal|1
condition|)
name|set_reg
argument_list|(
name|sr
operator|->
name|curr
operator|.
name|reg
operator|+
name|UNW_REG_B1
operator|+
name|i
argument_list|,
name|UNW_WHERE_GR
argument_list|,
name|sr
operator|->
name|region_start
operator|+
name|sr
operator|->
name|region_len
operator|-
literal|1
argument_list|,
name|gr
operator|++
argument_list|)
expr_stmt|;
name|brmask
operator|>>=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|desc_br_mem
parameter_list|(
name|unsigned
name|char
name|brmask
parameter_list|,
name|struct
name|unw_state_record
modifier|*
name|sr
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|brmask
operator|&
literal|1
condition|)
block|{
name|set_reg
argument_list|(
name|sr
operator|->
name|curr
operator|.
name|reg
operator|+
name|UNW_REG_B1
operator|+
name|i
argument_list|,
name|UNW_WHERE_SPILL_HOME
argument_list|,
name|sr
operator|->
name|region_start
operator|+
name|sr
operator|->
name|region_len
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sr
operator|->
name|any_spills
operator|=
literal|1
expr_stmt|;
block|}
name|brmask
operator|>>=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|desc_frgr_mem
parameter_list|(
name|unsigned
name|char
name|grmask
parameter_list|,
name|unw_word
name|frmask
parameter_list|,
name|struct
name|unw_state_record
modifier|*
name|sr
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|(
name|grmask
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
name|set_reg
argument_list|(
name|sr
operator|->
name|curr
operator|.
name|reg
operator|+
name|UNW_REG_R4
operator|+
name|i
argument_list|,
name|UNW_WHERE_SPILL_HOME
argument_list|,
name|sr
operator|->
name|region_start
operator|+
name|sr
operator|->
name|region_len
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sr
operator|->
name|any_spills
operator|=
literal|1
expr_stmt|;
block|}
name|grmask
operator|>>=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|20
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|(
name|frmask
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
name|enum
name|unw_register_index
name|base
init|=
name|i
operator|<
literal|4
condition|?
name|UNW_REG_F2
else|:
name|UNW_REG_F16
operator|-
literal|4
decl_stmt|;
name|set_reg
argument_list|(
name|sr
operator|->
name|curr
operator|.
name|reg
operator|+
name|base
operator|+
name|i
argument_list|,
name|UNW_WHERE_SPILL_HOME
argument_list|,
name|sr
operator|->
name|region_start
operator|+
name|sr
operator|->
name|region_len
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sr
operator|->
name|any_spills
operator|=
literal|1
expr_stmt|;
block|}
name|frmask
operator|>>=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|desc_fr_mem
parameter_list|(
name|unsigned
name|char
name|frmask
parameter_list|,
name|struct
name|unw_state_record
modifier|*
name|sr
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|(
name|frmask
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
name|set_reg
argument_list|(
name|sr
operator|->
name|curr
operator|.
name|reg
operator|+
name|UNW_REG_F2
operator|+
name|i
argument_list|,
name|UNW_WHERE_SPILL_HOME
argument_list|,
name|sr
operator|->
name|region_start
operator|+
name|sr
operator|->
name|region_len
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sr
operator|->
name|any_spills
operator|=
literal|1
expr_stmt|;
block|}
name|frmask
operator|>>=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|desc_gr_gr
parameter_list|(
name|unsigned
name|char
name|grmask
parameter_list|,
name|unsigned
name|char
name|gr
parameter_list|,
name|struct
name|unw_state_record
modifier|*
name|sr
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|(
name|grmask
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|set_reg
argument_list|(
name|sr
operator|->
name|curr
operator|.
name|reg
operator|+
name|UNW_REG_R4
operator|+
name|i
argument_list|,
name|UNW_WHERE_GR
argument_list|,
name|sr
operator|->
name|region_start
operator|+
name|sr
operator|->
name|region_len
operator|-
literal|1
argument_list|,
name|gr
operator|++
argument_list|)
expr_stmt|;
name|grmask
operator|>>=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|desc_gr_mem
parameter_list|(
name|unsigned
name|char
name|grmask
parameter_list|,
name|struct
name|unw_state_record
modifier|*
name|sr
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|(
name|grmask
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
name|set_reg
argument_list|(
name|sr
operator|->
name|curr
operator|.
name|reg
operator|+
name|UNW_REG_R4
operator|+
name|i
argument_list|,
name|UNW_WHERE_SPILL_HOME
argument_list|,
name|sr
operator|->
name|region_start
operator|+
name|sr
operator|->
name|region_len
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sr
operator|->
name|any_spills
operator|=
literal|1
expr_stmt|;
block|}
name|grmask
operator|>>=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|desc_mem_stack_f
parameter_list|(
name|unw_word
name|t
parameter_list|,
name|unw_word
name|size
parameter_list|,
name|struct
name|unw_state_record
modifier|*
name|sr
parameter_list|)
block|{
name|set_reg
argument_list|(
name|sr
operator|->
name|curr
operator|.
name|reg
operator|+
name|UNW_REG_PSP
argument_list|,
name|UNW_WHERE_NONE
argument_list|,
name|sr
operator|->
name|region_start
operator|+
name|MIN
argument_list|(
operator|(
name|int
operator|)
name|t
argument_list|,
name|sr
operator|->
name|region_len
operator|-
literal|1
argument_list|)
argument_list|,
literal|16
operator|*
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|desc_mem_stack_v
parameter_list|(
name|unw_word
name|t
parameter_list|,
name|struct
name|unw_state_record
modifier|*
name|sr
parameter_list|)
block|{
name|sr
operator|->
name|curr
operator|.
name|reg
index|[
name|UNW_REG_PSP
index|]
operator|.
name|when
operator|=
name|sr
operator|->
name|region_start
operator|+
name|MIN
argument_list|(
operator|(
name|int
operator|)
name|t
argument_list|,
name|sr
operator|->
name|region_len
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|desc_reg_gr
parameter_list|(
name|unsigned
name|char
name|reg
parameter_list|,
name|unsigned
name|char
name|dst
parameter_list|,
name|struct
name|unw_state_record
modifier|*
name|sr
parameter_list|)
block|{
name|set_reg
argument_list|(
name|sr
operator|->
name|curr
operator|.
name|reg
operator|+
name|reg
argument_list|,
name|UNW_WHERE_GR
argument_list|,
name|sr
operator|->
name|region_start
operator|+
name|sr
operator|->
name|region_len
operator|-
literal|1
argument_list|,
name|dst
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|desc_reg_psprel
parameter_list|(
name|unsigned
name|char
name|reg
parameter_list|,
name|unw_word
name|pspoff
parameter_list|,
name|struct
name|unw_state_record
modifier|*
name|sr
parameter_list|)
block|{
name|set_reg
argument_list|(
name|sr
operator|->
name|curr
operator|.
name|reg
operator|+
name|reg
argument_list|,
name|UNW_WHERE_PSPREL
argument_list|,
name|sr
operator|->
name|region_start
operator|+
name|sr
operator|->
name|region_len
operator|-
literal|1
argument_list|,
literal|0x10
operator|-
literal|4
operator|*
name|pspoff
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|desc_reg_sprel
parameter_list|(
name|unsigned
name|char
name|reg
parameter_list|,
name|unw_word
name|spoff
parameter_list|,
name|struct
name|unw_state_record
modifier|*
name|sr
parameter_list|)
block|{
name|set_reg
argument_list|(
name|sr
operator|->
name|curr
operator|.
name|reg
operator|+
name|reg
argument_list|,
name|UNW_WHERE_SPREL
argument_list|,
name|sr
operator|->
name|region_start
operator|+
name|sr
operator|->
name|region_len
operator|-
literal|1
argument_list|,
literal|4
operator|*
name|spoff
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|desc_rp_br
parameter_list|(
name|unsigned
name|char
name|dst
parameter_list|,
name|struct
name|unw_state_record
modifier|*
name|sr
parameter_list|)
block|{
name|sr
operator|->
name|return_link_reg
operator|=
name|dst
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|desc_reg_when
parameter_list|(
name|unsigned
name|char
name|regnum
parameter_list|,
name|unw_word
name|t
parameter_list|,
name|struct
name|unw_state_record
modifier|*
name|sr
parameter_list|)
block|{
name|struct
name|unw_reg_info
modifier|*
name|reg
init|=
name|sr
operator|->
name|curr
operator|.
name|reg
operator|+
name|regnum
decl_stmt|;
if|if
condition|(
name|reg
operator|->
name|where
operator|==
name|UNW_WHERE_NONE
condition|)
name|reg
operator|->
name|where
operator|=
name|UNW_WHERE_GR_SAVE
expr_stmt|;
name|reg
operator|->
name|when
operator|=
name|sr
operator|->
name|region_start
operator|+
name|MIN
argument_list|(
operator|(
name|int
operator|)
name|t
argument_list|,
name|sr
operator|->
name|region_len
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|desc_spill_base
parameter_list|(
name|unw_word
name|pspoff
parameter_list|,
name|struct
name|unw_state_record
modifier|*
name|sr
parameter_list|)
block|{
name|sr
operator|->
name|spill_offset
operator|=
literal|0x10
operator|-
literal|4
operator|*
name|pspoff
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|unsigned
name|char
modifier|*
name|desc_spill_mask
parameter_list|(
name|unsigned
name|char
modifier|*
name|imaskp
parameter_list|,
name|struct
name|unw_state_record
modifier|*
name|sr
parameter_list|)
block|{
name|sr
operator|->
name|imask
operator|=
name|imaskp
expr_stmt|;
return|return
name|imaskp
operator|+
operator|(
literal|2
operator|*
name|sr
operator|->
name|region_len
operator|+
literal|7
operator|)
operator|/
literal|8
return|;
block|}
end_function

begin_comment
comment|/*  * Body descriptors.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|desc_epilogue
parameter_list|(
name|unw_word
name|t
parameter_list|,
name|unw_word
name|ecount
parameter_list|,
name|struct
name|unw_state_record
modifier|*
name|sr
parameter_list|)
block|{
name|sr
operator|->
name|epilogue_start
operator|=
name|sr
operator|->
name|region_start
operator|+
name|sr
operator|->
name|region_len
operator|-
literal|1
operator|-
name|t
expr_stmt|;
name|sr
operator|->
name|epilogue_count
operator|=
name|ecount
operator|+
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|desc_copy_state
parameter_list|(
name|unw_word
name|label
parameter_list|,
name|struct
name|unw_state_record
modifier|*
name|sr
parameter_list|)
block|{
name|struct
name|unw_labeled_state
modifier|*
name|ls
decl_stmt|;
for|for
control|(
name|ls
operator|=
name|sr
operator|->
name|labeled_states
init|;
name|ls
condition|;
name|ls
operator|=
name|ls
operator|->
name|next
control|)
block|{
if|if
condition|(
name|ls
operator|->
name|label
operator|==
name|label
condition|)
block|{
name|free_state_stack
argument_list|(
operator|&
name|sr
operator|->
name|curr
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|sr
operator|->
name|curr
argument_list|,
operator|&
name|ls
operator|->
name|saved_state
argument_list|,
sizeof|sizeof
argument_list|(
name|sr
operator|->
name|curr
argument_list|)
argument_list|)
expr_stmt|;
name|sr
operator|->
name|curr
operator|.
name|next
operator|=
name|dup_state_stack
argument_list|(
name|ls
operator|->
name|saved_state
operator|.
name|next
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|desc_label_state
parameter_list|(
name|unw_word
name|label
parameter_list|,
name|struct
name|unw_state_record
modifier|*
name|sr
parameter_list|)
block|{
name|struct
name|unw_labeled_state
modifier|*
name|ls
init|=
name|alloc_label_state
argument_list|()
decl_stmt|;
name|ls
operator|->
name|label
operator|=
name|label
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|ls
operator|->
name|saved_state
argument_list|,
operator|&
name|sr
operator|->
name|curr
argument_list|,
sizeof|sizeof
argument_list|(
name|ls
operator|->
name|saved_state
argument_list|)
argument_list|)
expr_stmt|;
name|ls
operator|->
name|saved_state
operator|.
name|next
operator|=
name|dup_state_stack
argument_list|(
name|sr
operator|->
name|curr
operator|.
name|next
argument_list|)
expr_stmt|;
comment|/* Insert into list of labeled states.  */
name|ls
operator|->
name|next
operator|=
name|sr
operator|->
name|labeled_states
expr_stmt|;
name|sr
operator|->
name|labeled_states
operator|=
name|ls
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * General descriptors.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|desc_is_active
parameter_list|(
name|unsigned
name|char
name|qp
parameter_list|,
name|unw_word
name|t
parameter_list|,
name|struct
name|unw_state_record
modifier|*
name|sr
parameter_list|)
block|{
if|if
condition|(
name|sr
operator|->
name|when_target
operator|<=
name|sr
operator|->
name|region_start
operator|+
name|MIN
argument_list|(
operator|(
name|int
operator|)
name|t
argument_list|,
name|sr
operator|->
name|region_len
operator|-
literal|1
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|qp
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|sr
operator|->
name|pr_val
operator|&
operator|(
literal|1UL
operator|<<
name|qp
operator|)
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|sr
operator|->
name|pr_mask
operator||=
operator|(
literal|1UL
operator|<<
name|qp
operator|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|desc_restore_p
parameter_list|(
name|unsigned
name|char
name|qp
parameter_list|,
name|unw_word
name|t
parameter_list|,
name|unsigned
name|char
name|abreg
parameter_list|,
name|struct
name|unw_state_record
modifier|*
name|sr
parameter_list|)
block|{
name|struct
name|unw_reg_info
modifier|*
name|r
decl_stmt|;
if|if
condition|(
operator|!
name|desc_is_active
argument_list|(
name|qp
argument_list|,
name|t
argument_list|,
name|sr
argument_list|)
condition|)
return|return;
name|r
operator|=
name|sr
operator|->
name|curr
operator|.
name|reg
operator|+
name|decode_abreg
argument_list|(
name|abreg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|r
operator|->
name|where
operator|=
name|UNW_WHERE_NONE
expr_stmt|;
name|r
operator|->
name|when
operator|=
name|sr
operator|->
name|region_start
operator|+
name|MIN
argument_list|(
operator|(
name|int
operator|)
name|t
argument_list|,
name|sr
operator|->
name|region_len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|r
operator|->
name|val
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|desc_spill_reg_p
parameter_list|(
name|unsigned
name|char
name|qp
parameter_list|,
name|unw_word
name|t
parameter_list|,
name|unsigned
name|char
name|abreg
parameter_list|,
name|unsigned
name|char
name|x
parameter_list|,
name|unsigned
name|char
name|ytreg
parameter_list|,
name|struct
name|unw_state_record
modifier|*
name|sr
parameter_list|)
block|{
name|enum
name|unw_where
name|where
init|=
name|UNW_WHERE_GR
decl_stmt|;
name|struct
name|unw_reg_info
modifier|*
name|r
decl_stmt|;
if|if
condition|(
operator|!
name|desc_is_active
argument_list|(
name|qp
argument_list|,
name|t
argument_list|,
name|sr
argument_list|)
condition|)
return|return;
if|if
condition|(
name|x
condition|)
name|where
operator|=
name|UNW_WHERE_BR
expr_stmt|;
elseif|else
if|if
condition|(
name|ytreg
operator|&
literal|0x80
condition|)
name|where
operator|=
name|UNW_WHERE_FR
expr_stmt|;
name|r
operator|=
name|sr
operator|->
name|curr
operator|.
name|reg
operator|+
name|decode_abreg
argument_list|(
name|abreg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|r
operator|->
name|where
operator|=
name|where
expr_stmt|;
name|r
operator|->
name|when
operator|=
name|sr
operator|->
name|region_start
operator|+
name|MIN
argument_list|(
operator|(
name|int
operator|)
name|t
argument_list|,
name|sr
operator|->
name|region_len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|r
operator|->
name|val
operator|=
name|ytreg
operator|&
literal|0x7f
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|desc_spill_psprel_p
parameter_list|(
name|unsigned
name|char
name|qp
parameter_list|,
name|unw_word
name|t
parameter_list|,
name|unsigned
name|char
name|abreg
parameter_list|,
name|unw_word
name|pspoff
parameter_list|,
name|struct
name|unw_state_record
modifier|*
name|sr
parameter_list|)
block|{
name|struct
name|unw_reg_info
modifier|*
name|r
decl_stmt|;
if|if
condition|(
operator|!
name|desc_is_active
argument_list|(
name|qp
argument_list|,
name|t
argument_list|,
name|sr
argument_list|)
condition|)
return|return;
name|r
operator|=
name|sr
operator|->
name|curr
operator|.
name|reg
operator|+
name|decode_abreg
argument_list|(
name|abreg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|r
operator|->
name|where
operator|=
name|UNW_WHERE_PSPREL
expr_stmt|;
name|r
operator|->
name|when
operator|=
name|sr
operator|->
name|region_start
operator|+
name|MIN
argument_list|(
operator|(
name|int
operator|)
name|t
argument_list|,
name|sr
operator|->
name|region_len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|r
operator|->
name|val
operator|=
literal|0x10
operator|-
literal|4
operator|*
name|pspoff
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|desc_spill_sprel_p
parameter_list|(
name|unsigned
name|char
name|qp
parameter_list|,
name|unw_word
name|t
parameter_list|,
name|unsigned
name|char
name|abreg
parameter_list|,
name|unw_word
name|spoff
parameter_list|,
name|struct
name|unw_state_record
modifier|*
name|sr
parameter_list|)
block|{
name|struct
name|unw_reg_info
modifier|*
name|r
decl_stmt|;
if|if
condition|(
operator|!
name|desc_is_active
argument_list|(
name|qp
argument_list|,
name|t
argument_list|,
name|sr
argument_list|)
condition|)
return|return;
name|r
operator|=
name|sr
operator|->
name|curr
operator|.
name|reg
operator|+
name|decode_abreg
argument_list|(
name|abreg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|r
operator|->
name|where
operator|=
name|UNW_WHERE_SPREL
expr_stmt|;
name|r
operator|->
name|when
operator|=
name|sr
operator|->
name|region_start
operator|+
name|MIN
argument_list|(
operator|(
name|int
operator|)
name|t
argument_list|,
name|sr
operator|->
name|region_len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|r
operator|->
name|val
operator|=
literal|4
operator|*
name|spoff
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_define
define|#
directive|define
name|UNW_DEC_BAD_CODE
parameter_list|(
name|code
parameter_list|)
value|abort ();
end_define

begin_comment
comment|/* Region headers.  */
end_comment

begin_define
define|#
directive|define
name|UNW_DEC_PROLOGUE_GR
parameter_list|(
name|fmt
parameter_list|,
name|r
parameter_list|,
name|m
parameter_list|,
name|gr
parameter_list|,
name|arg
parameter_list|)
value|desc_prologue(0,r,m,gr,arg)
end_define

begin_define
define|#
directive|define
name|UNW_DEC_PROLOGUE
parameter_list|(
name|fmt
parameter_list|,
name|b
parameter_list|,
name|r
parameter_list|,
name|arg
parameter_list|)
value|desc_prologue(b,r,0,32,arg)
end_define

begin_comment
comment|/* Prologue descriptors.  */
end_comment

begin_define
define|#
directive|define
name|UNW_DEC_ABI
parameter_list|(
name|fmt
parameter_list|,
name|a
parameter_list|,
name|c
parameter_list|,
name|arg
parameter_list|)
value|desc_abi(a,c,arg)
end_define

begin_define
define|#
directive|define
name|UNW_DEC_BR_GR
parameter_list|(
name|fmt
parameter_list|,
name|b
parameter_list|,
name|g
parameter_list|,
name|arg
parameter_list|)
value|desc_br_gr(b,g,arg)
end_define

begin_define
define|#
directive|define
name|UNW_DEC_BR_MEM
parameter_list|(
name|fmt
parameter_list|,
name|b
parameter_list|,
name|arg
parameter_list|)
value|desc_br_mem(b,arg)
end_define

begin_define
define|#
directive|define
name|UNW_DEC_FRGR_MEM
parameter_list|(
name|fmt
parameter_list|,
name|g
parameter_list|,
name|f
parameter_list|,
name|arg
parameter_list|)
value|desc_frgr_mem(g,f,arg)
end_define

begin_define
define|#
directive|define
name|UNW_DEC_FR_MEM
parameter_list|(
name|fmt
parameter_list|,
name|f
parameter_list|,
name|arg
parameter_list|)
value|desc_fr_mem(f,arg)
end_define

begin_define
define|#
directive|define
name|UNW_DEC_GR_GR
parameter_list|(
name|fmt
parameter_list|,
name|m
parameter_list|,
name|g
parameter_list|,
name|arg
parameter_list|)
value|desc_gr_gr(m,g,arg)
end_define

begin_define
define|#
directive|define
name|UNW_DEC_GR_MEM
parameter_list|(
name|fmt
parameter_list|,
name|m
parameter_list|,
name|arg
parameter_list|)
value|desc_gr_mem(m,arg)
end_define

begin_define
define|#
directive|define
name|UNW_DEC_MEM_STACK_F
parameter_list|(
name|fmt
parameter_list|,
name|t
parameter_list|,
name|s
parameter_list|,
name|arg
parameter_list|)
value|desc_mem_stack_f(t,s,arg)
end_define

begin_define
define|#
directive|define
name|UNW_DEC_MEM_STACK_V
parameter_list|(
name|fmt
parameter_list|,
name|t
parameter_list|,
name|arg
parameter_list|)
value|desc_mem_stack_v(t,arg)
end_define

begin_define
define|#
directive|define
name|UNW_DEC_REG_GR
parameter_list|(
name|fmt
parameter_list|,
name|r
parameter_list|,
name|d
parameter_list|,
name|arg
parameter_list|)
value|desc_reg_gr(r,d,arg)
end_define

begin_define
define|#
directive|define
name|UNW_DEC_REG_PSPREL
parameter_list|(
name|fmt
parameter_list|,
name|r
parameter_list|,
name|o
parameter_list|,
name|arg
parameter_list|)
value|desc_reg_psprel(r,o,arg)
end_define

begin_define
define|#
directive|define
name|UNW_DEC_REG_SPREL
parameter_list|(
name|fmt
parameter_list|,
name|r
parameter_list|,
name|o
parameter_list|,
name|arg
parameter_list|)
value|desc_reg_sprel(r,o,arg)
end_define

begin_define
define|#
directive|define
name|UNW_DEC_REG_WHEN
parameter_list|(
name|fmt
parameter_list|,
name|r
parameter_list|,
name|t
parameter_list|,
name|arg
parameter_list|)
value|desc_reg_when(r,t,arg)
end_define

begin_define
define|#
directive|define
name|UNW_DEC_PRIUNAT_WHEN_GR
parameter_list|(
name|fmt
parameter_list|,
name|t
parameter_list|,
name|arg
parameter_list|)
value|desc_reg_when(UNW_REG_PRI_UNAT_GR,t,arg)
end_define

begin_define
define|#
directive|define
name|UNW_DEC_PRIUNAT_WHEN_MEM
parameter_list|(
name|fmt
parameter_list|,
name|t
parameter_list|,
name|arg
parameter_list|)
value|desc_reg_when(UNW_REG_PRI_UNAT_MEM,t,arg)
end_define

begin_define
define|#
directive|define
name|UNW_DEC_PRIUNAT_GR
parameter_list|(
name|fmt
parameter_list|,
name|r
parameter_list|,
name|arg
parameter_list|)
value|desc_reg_gr(UNW_REG_PRI_UNAT_GR,r,arg)
end_define

begin_define
define|#
directive|define
name|UNW_DEC_PRIUNAT_PSPREL
parameter_list|(
name|fmt
parameter_list|,
name|o
parameter_list|,
name|arg
parameter_list|)
value|desc_reg_psprel(UNW_REG_PRI_UNAT_MEM,o,arg)
end_define

begin_define
define|#
directive|define
name|UNW_DEC_PRIUNAT_SPREL
parameter_list|(
name|fmt
parameter_list|,
name|o
parameter_list|,
name|arg
parameter_list|)
value|desc_reg_sprel(UNW_REG_PRI_UNAT_MEM,o,arg)
end_define

begin_define
define|#
directive|define
name|UNW_DEC_RP_BR
parameter_list|(
name|fmt
parameter_list|,
name|d
parameter_list|,
name|arg
parameter_list|)
value|desc_rp_br(d,arg)
end_define

begin_define
define|#
directive|define
name|UNW_DEC_SPILL_BASE
parameter_list|(
name|fmt
parameter_list|,
name|o
parameter_list|,
name|arg
parameter_list|)
value|desc_spill_base(o,arg)
end_define

begin_define
define|#
directive|define
name|UNW_DEC_SPILL_MASK
parameter_list|(
name|fmt
parameter_list|,
name|m
parameter_list|,
name|arg
parameter_list|)
value|(m = desc_spill_mask(m,arg))
end_define

begin_comment
comment|/* Body descriptors.  */
end_comment

begin_define
define|#
directive|define
name|UNW_DEC_EPILOGUE
parameter_list|(
name|fmt
parameter_list|,
name|t
parameter_list|,
name|c
parameter_list|,
name|arg
parameter_list|)
value|desc_epilogue(t,c,arg)
end_define

begin_define
define|#
directive|define
name|UNW_DEC_COPY_STATE
parameter_list|(
name|fmt
parameter_list|,
name|l
parameter_list|,
name|arg
parameter_list|)
value|desc_copy_state(l,arg)
end_define

begin_define
define|#
directive|define
name|UNW_DEC_LABEL_STATE
parameter_list|(
name|fmt
parameter_list|,
name|l
parameter_list|,
name|arg
parameter_list|)
value|desc_label_state(l,arg)
end_define

begin_comment
comment|/* General unwind descriptors.  */
end_comment

begin_define
define|#
directive|define
name|UNW_DEC_SPILL_REG_P
parameter_list|(
name|f
parameter_list|,
name|p
parameter_list|,
name|t
parameter_list|,
name|a
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|,
name|arg
parameter_list|)
value|desc_spill_reg_p(p,t,a,x,y,arg)
end_define

begin_define
define|#
directive|define
name|UNW_DEC_SPILL_REG
parameter_list|(
name|f
parameter_list|,
name|t
parameter_list|,
name|a
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|,
name|arg
parameter_list|)
value|desc_spill_reg_p(0,t,a,x,y,arg)
end_define

begin_define
define|#
directive|define
name|UNW_DEC_SPILL_PSPREL_P
parameter_list|(
name|f
parameter_list|,
name|p
parameter_list|,
name|t
parameter_list|,
name|a
parameter_list|,
name|o
parameter_list|,
name|arg
parameter_list|)
value|desc_spill_psprel_p(p,t,a,o,arg)
end_define

begin_define
define|#
directive|define
name|UNW_DEC_SPILL_PSPREL
parameter_list|(
name|f
parameter_list|,
name|t
parameter_list|,
name|a
parameter_list|,
name|o
parameter_list|,
name|arg
parameter_list|)
value|desc_spill_psprel_p(0,t,a,o,arg)
end_define

begin_define
define|#
directive|define
name|UNW_DEC_SPILL_SPREL_P
parameter_list|(
name|f
parameter_list|,
name|p
parameter_list|,
name|t
parameter_list|,
name|a
parameter_list|,
name|o
parameter_list|,
name|arg
parameter_list|)
value|desc_spill_sprel_p(p,t,a,o,arg)
end_define

begin_define
define|#
directive|define
name|UNW_DEC_SPILL_SPREL
parameter_list|(
name|f
parameter_list|,
name|t
parameter_list|,
name|a
parameter_list|,
name|o
parameter_list|,
name|arg
parameter_list|)
value|desc_spill_sprel_p(0,t,a,o,arg)
end_define

begin_define
define|#
directive|define
name|UNW_DEC_RESTORE_P
parameter_list|(
name|f
parameter_list|,
name|p
parameter_list|,
name|t
parameter_list|,
name|a
parameter_list|,
name|arg
parameter_list|)
value|desc_restore_p(p,t,a,arg)
end_define

begin_define
define|#
directive|define
name|UNW_DEC_RESTORE
parameter_list|(
name|f
parameter_list|,
name|t
parameter_list|,
name|a
parameter_list|,
name|arg
parameter_list|)
value|desc_restore_p(0,t,a,arg)
end_define

begin_escape
end_escape

begin_comment
comment|/*  * Generic IA-64 unwind info decoder.  *  * This file is used both by the Linux kernel and objdump.  Please keep  * the copies of this file in sync.  *  * You need to customize the decoder by defining the following  * macros/constants before including this file:  *  *  Types:  *	unw_word	Unsigned integer type with at least 64 bits   *  *  Register names:  *	UNW_REG_BSP  *	UNW_REG_BSPSTORE  *	UNW_REG_FPSR  *	UNW_REG_LC  *	UNW_REG_PFS  *	UNW_REG_PR  *	UNW_REG_RNAT  *	UNW_REG_PSP  *	UNW_REG_RP  *	UNW_REG_UNAT  *  *  Decoder action macros:  *	UNW_DEC_BAD_CODE(code)  *	UNW_DEC_ABI(fmt,abi,context,arg)  *	UNW_DEC_BR_GR(fmt,brmask,gr,arg)  *	UNW_DEC_BR_MEM(fmt,brmask,arg)  *	UNW_DEC_COPY_STATE(fmt,label,arg)  *	UNW_DEC_EPILOGUE(fmt,t,ecount,arg)  *	UNW_DEC_FRGR_MEM(fmt,grmask,frmask,arg)  *	UNW_DEC_FR_MEM(fmt,frmask,arg)  *	UNW_DEC_GR_GR(fmt,grmask,gr,arg)  *	UNW_DEC_GR_MEM(fmt,grmask,arg)  *	UNW_DEC_LABEL_STATE(fmt,label,arg)  *	UNW_DEC_MEM_STACK_F(fmt,t,size,arg)  *	UNW_DEC_MEM_STACK_V(fmt,t,arg)  *	UNW_DEC_PRIUNAT_GR(fmt,r,arg)  *	UNW_DEC_PRIUNAT_WHEN_GR(fmt,t,arg)  *	UNW_DEC_PRIUNAT_WHEN_MEM(fmt,t,arg)  *	UNW_DEC_PRIUNAT_WHEN_PSPREL(fmt,pspoff,arg)  *	UNW_DEC_PRIUNAT_WHEN_SPREL(fmt,spoff,arg)  *	UNW_DEC_PROLOGUE(fmt,body,rlen,arg)  *	UNW_DEC_PROLOGUE_GR(fmt,rlen,mask,grsave,arg)  *	UNW_DEC_REG_PSPREL(fmt,reg,pspoff,arg)  *	UNW_DEC_REG_REG(fmt,src,dst,arg)  *	UNW_DEC_REG_SPREL(fmt,reg,spoff,arg)  *	UNW_DEC_REG_WHEN(fmt,reg,t,arg)  *	UNW_DEC_RESTORE(fmt,t,abreg,arg)  *	UNW_DEC_RESTORE_P(fmt,qp,t,abreg,arg)  *	UNW_DEC_SPILL_BASE(fmt,pspoff,arg)  *	UNW_DEC_SPILL_MASK(fmt,imaskp,arg)  *	UNW_DEC_SPILL_PSPREL(fmt,t,abreg,pspoff,arg)  *	UNW_DEC_SPILL_PSPREL_P(fmt,qp,t,abreg,pspoff,arg)  *	UNW_DEC_SPILL_REG(fmt,t,abreg,x,ytreg,arg)  *	UNW_DEC_SPILL_REG_P(fmt,qp,t,abreg,x,ytreg,arg)  *	UNW_DEC_SPILL_SPREL(fmt,t,abreg,spoff,arg)  *	UNW_DEC_SPILL_SPREL_P(fmt,qp,t,abreg,pspoff,arg)  */
end_comment

begin_function
specifier|static
name|unw_word
name|unw_decode_uleb128
parameter_list|(
name|unsigned
name|char
modifier|*
modifier|*
name|dpp
parameter_list|)
block|{
name|unsigned
name|shift
init|=
literal|0
decl_stmt|;
name|unw_word
name|byte
decl_stmt|,
name|result
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
modifier|*
name|bp
init|=
operator|*
name|dpp
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|byte
operator|=
operator|*
name|bp
operator|++
expr_stmt|;
name|result
operator||=
operator|(
name|byte
operator|&
literal|0x7f
operator|)
operator|<<
name|shift
expr_stmt|;
if|if
condition|(
operator|(
name|byte
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
break|break;
name|shift
operator|+=
literal|7
expr_stmt|;
block|}
operator|*
name|dpp
operator|=
name|bp
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|unsigned
name|char
modifier|*
name|unw_decode_x1
argument_list|(
name|unsigned
name|char
operator|*
name|dp
argument_list|,
name|unsigned
name|char
name|code
name|__attribute__
argument_list|(
operator|(
name|unused
operator|)
argument_list|)
argument_list|,
name|void
operator|*
name|arg
argument_list|)
block|{
name|unsigned
name|char
name|byte1
decl_stmt|,
name|abreg
decl_stmt|;
name|unw_word
name|t
decl_stmt|,
name|off
decl_stmt|;
name|byte1
operator|=
operator|*
name|dp
operator|++
expr_stmt|;
name|t
operator|=
name|unw_decode_uleb128
argument_list|(
operator|&
name|dp
argument_list|)
expr_stmt|;
name|off
operator|=
name|unw_decode_uleb128
argument_list|(
operator|&
name|dp
argument_list|)
expr_stmt|;
name|abreg
operator|=
operator|(
name|byte1
operator|&
literal|0x7f
operator|)
expr_stmt|;
if|if
condition|(
name|byte1
operator|&
literal|0x80
condition|)
name|UNW_DEC_SPILL_SPREL
argument_list|(
name|X1
argument_list|,
name|t
argument_list|,
name|abreg
argument_list|,
name|off
argument_list|,
name|arg
argument_list|)
expr_stmt|;
else|else
name|UNW_DEC_SPILL_PSPREL
argument_list|(
name|X1
argument_list|,
name|t
argument_list|,
name|abreg
argument_list|,
name|off
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
name|dp
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
modifier|*
name|unw_decode_x2
argument_list|(
name|unsigned
name|char
operator|*
name|dp
argument_list|,
name|unsigned
name|char
name|code
name|__attribute__
argument_list|(
operator|(
name|unused
operator|)
argument_list|)
argument_list|,
name|void
operator|*
name|arg
argument_list|)
block|{
name|unsigned
name|char
name|byte1
decl_stmt|,
name|byte2
decl_stmt|,
name|abreg
decl_stmt|,
name|x
decl_stmt|,
name|ytreg
decl_stmt|;
name|unw_word
name|t
decl_stmt|;
name|byte1
operator|=
operator|*
name|dp
operator|++
expr_stmt|;
name|byte2
operator|=
operator|*
name|dp
operator|++
expr_stmt|;
name|t
operator|=
name|unw_decode_uleb128
argument_list|(
operator|&
name|dp
argument_list|)
expr_stmt|;
name|abreg
operator|=
operator|(
name|byte1
operator|&
literal|0x7f
operator|)
expr_stmt|;
name|ytreg
operator|=
name|byte2
expr_stmt|;
name|x
operator|=
operator|(
name|byte1
operator|>>
literal|7
operator|)
operator|&
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|byte1
operator|&
literal|0x80
operator|)
operator|==
literal|0
operator|&&
name|ytreg
operator|==
literal|0
condition|)
name|UNW_DEC_RESTORE
argument_list|(
name|X2
argument_list|,
name|t
argument_list|,
name|abreg
argument_list|,
name|arg
argument_list|)
expr_stmt|;
else|else
name|UNW_DEC_SPILL_REG
argument_list|(
name|X2
argument_list|,
name|t
argument_list|,
name|abreg
argument_list|,
name|x
argument_list|,
name|ytreg
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
name|dp
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
modifier|*
name|unw_decode_x3
argument_list|(
name|unsigned
name|char
operator|*
name|dp
argument_list|,
name|unsigned
name|char
name|code
name|__attribute__
argument_list|(
operator|(
name|unused
operator|)
argument_list|)
argument_list|,
name|void
operator|*
name|arg
argument_list|)
block|{
name|unsigned
name|char
name|byte1
decl_stmt|,
name|byte2
decl_stmt|,
name|abreg
decl_stmt|,
name|qp
decl_stmt|;
name|unw_word
name|t
decl_stmt|,
name|off
decl_stmt|;
name|byte1
operator|=
operator|*
name|dp
operator|++
expr_stmt|;
name|byte2
operator|=
operator|*
name|dp
operator|++
expr_stmt|;
name|t
operator|=
name|unw_decode_uleb128
argument_list|(
operator|&
name|dp
argument_list|)
expr_stmt|;
name|off
operator|=
name|unw_decode_uleb128
argument_list|(
operator|&
name|dp
argument_list|)
expr_stmt|;
name|qp
operator|=
operator|(
name|byte1
operator|&
literal|0x3f
operator|)
expr_stmt|;
name|abreg
operator|=
operator|(
name|byte2
operator|&
literal|0x7f
operator|)
expr_stmt|;
if|if
condition|(
name|byte1
operator|&
literal|0x80
condition|)
name|UNW_DEC_SPILL_SPREL_P
argument_list|(
name|X3
argument_list|,
name|qp
argument_list|,
name|t
argument_list|,
name|abreg
argument_list|,
name|off
argument_list|,
name|arg
argument_list|)
expr_stmt|;
else|else
name|UNW_DEC_SPILL_PSPREL_P
argument_list|(
name|X3
argument_list|,
name|qp
argument_list|,
name|t
argument_list|,
name|abreg
argument_list|,
name|off
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
name|dp
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
modifier|*
name|unw_decode_x4
argument_list|(
name|unsigned
name|char
operator|*
name|dp
argument_list|,
name|unsigned
name|char
name|code
name|__attribute__
argument_list|(
operator|(
name|unused
operator|)
argument_list|)
argument_list|,
name|void
operator|*
name|arg
argument_list|)
block|{
name|unsigned
name|char
name|byte1
decl_stmt|,
name|byte2
decl_stmt|,
name|byte3
decl_stmt|,
name|qp
decl_stmt|,
name|abreg
decl_stmt|,
name|x
decl_stmt|,
name|ytreg
decl_stmt|;
name|unw_word
name|t
decl_stmt|;
name|byte1
operator|=
operator|*
name|dp
operator|++
expr_stmt|;
name|byte2
operator|=
operator|*
name|dp
operator|++
expr_stmt|;
name|byte3
operator|=
operator|*
name|dp
operator|++
expr_stmt|;
name|t
operator|=
name|unw_decode_uleb128
argument_list|(
operator|&
name|dp
argument_list|)
expr_stmt|;
name|qp
operator|=
operator|(
name|byte1
operator|&
literal|0x3f
operator|)
expr_stmt|;
name|abreg
operator|=
operator|(
name|byte2
operator|&
literal|0x7f
operator|)
expr_stmt|;
name|x
operator|=
operator|(
name|byte2
operator|>>
literal|7
operator|)
operator|&
literal|1
expr_stmt|;
name|ytreg
operator|=
name|byte3
expr_stmt|;
if|if
condition|(
operator|(
name|byte2
operator|&
literal|0x80
operator|)
operator|==
literal|0
operator|&&
name|byte3
operator|==
literal|0
condition|)
name|UNW_DEC_RESTORE_P
argument_list|(
name|X4
argument_list|,
name|qp
argument_list|,
name|t
argument_list|,
name|abreg
argument_list|,
name|arg
argument_list|)
expr_stmt|;
else|else
name|UNW_DEC_SPILL_REG_P
argument_list|(
name|X4
argument_list|,
name|qp
argument_list|,
name|t
argument_list|,
name|abreg
argument_list|,
name|x
argument_list|,
name|ytreg
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
name|dp
return|;
block|}
end_decl_stmt

begin_function
specifier|static
name|unsigned
name|char
modifier|*
name|unw_decode_r1
parameter_list|(
name|unsigned
name|char
modifier|*
name|dp
parameter_list|,
name|unsigned
name|char
name|code
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|body
init|=
operator|(
name|code
operator|&
literal|0x20
operator|)
operator|!=
literal|0
decl_stmt|;
name|unw_word
name|rlen
decl_stmt|;
name|rlen
operator|=
operator|(
name|code
operator|&
literal|0x1f
operator|)
expr_stmt|;
name|UNW_DEC_PROLOGUE
argument_list|(
name|R1
argument_list|,
name|body
argument_list|,
name|rlen
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
name|dp
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|char
modifier|*
name|unw_decode_r2
parameter_list|(
name|unsigned
name|char
modifier|*
name|dp
parameter_list|,
name|unsigned
name|char
name|code
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|unsigned
name|char
name|byte1
decl_stmt|,
name|mask
decl_stmt|,
name|grsave
decl_stmt|;
name|unw_word
name|rlen
decl_stmt|;
name|byte1
operator|=
operator|*
name|dp
operator|++
expr_stmt|;
name|mask
operator|=
operator|(
operator|(
name|code
operator|&
literal|0x7
operator|)
operator|<<
literal|1
operator|)
operator||
operator|(
operator|(
name|byte1
operator|>>
literal|7
operator|)
operator|&
literal|1
operator|)
expr_stmt|;
name|grsave
operator|=
operator|(
name|byte1
operator|&
literal|0x7f
operator|)
expr_stmt|;
name|rlen
operator|=
name|unw_decode_uleb128
argument_list|(
operator|&
name|dp
argument_list|)
expr_stmt|;
name|UNW_DEC_PROLOGUE_GR
argument_list|(
name|R2
argument_list|,
name|rlen
argument_list|,
name|mask
argument_list|,
name|grsave
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
name|dp
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|char
modifier|*
name|unw_decode_r3
parameter_list|(
name|unsigned
name|char
modifier|*
name|dp
parameter_list|,
name|unsigned
name|char
name|code
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|unw_word
name|rlen
decl_stmt|;
name|rlen
operator|=
name|unw_decode_uleb128
argument_list|(
operator|&
name|dp
argument_list|)
expr_stmt|;
name|UNW_DEC_PROLOGUE
argument_list|(
name|R3
argument_list|,
operator|(
operator|(
name|code
operator|&
literal|0x3
operator|)
operator|==
literal|1
operator|)
argument_list|,
name|rlen
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
name|dp
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|char
modifier|*
name|unw_decode_p1
parameter_list|(
name|unsigned
name|char
modifier|*
name|dp
parameter_list|,
name|unsigned
name|char
name|code
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|unsigned
name|char
name|brmask
init|=
operator|(
name|code
operator|&
literal|0x1f
operator|)
decl_stmt|;
name|UNW_DEC_BR_MEM
argument_list|(
name|P1
argument_list|,
name|brmask
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
name|dp
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|char
modifier|*
name|unw_decode_p2_p5
parameter_list|(
name|unsigned
name|char
modifier|*
name|dp
parameter_list|,
name|unsigned
name|char
name|code
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
operator|(
name|code
operator|&
literal|0x10
operator|)
operator|==
literal|0
condition|)
block|{
name|unsigned
name|char
name|byte1
init|=
operator|*
name|dp
operator|++
decl_stmt|;
name|UNW_DEC_BR_GR
argument_list|(
name|P2
argument_list|,
operator|(
operator|(
name|code
operator|&
literal|0xf
operator|)
operator|<<
literal|1
operator|)
operator||
operator|(
operator|(
name|byte1
operator|>>
literal|7
operator|)
operator|&
literal|1
operator|)
argument_list|,
operator|(
name|byte1
operator|&
literal|0x7f
operator|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|code
operator|&
literal|0x08
operator|)
operator|==
literal|0
condition|)
block|{
name|unsigned
name|char
name|byte1
init|=
operator|*
name|dp
operator|++
decl_stmt|,
name|r
decl_stmt|,
name|dst
decl_stmt|;
name|r
operator|=
operator|(
operator|(
name|code
operator|&
literal|0x7
operator|)
operator|<<
literal|1
operator|)
operator||
operator|(
operator|(
name|byte1
operator|>>
literal|7
operator|)
operator|&
literal|1
operator|)
expr_stmt|;
name|dst
operator|=
operator|(
name|byte1
operator|&
literal|0x7f
operator|)
expr_stmt|;
switch|switch
condition|(
name|r
condition|)
block|{
case|case
literal|0
case|:
name|UNW_DEC_REG_GR
argument_list|(
name|P3
argument_list|,
name|UNW_REG_PSP
argument_list|,
name|dst
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|UNW_DEC_REG_GR
argument_list|(
name|P3
argument_list|,
name|UNW_REG_RP
argument_list|,
name|dst
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|UNW_DEC_REG_GR
argument_list|(
name|P3
argument_list|,
name|UNW_REG_PFS
argument_list|,
name|dst
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|UNW_DEC_REG_GR
argument_list|(
name|P3
argument_list|,
name|UNW_REG_PR
argument_list|,
name|dst
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|UNW_DEC_REG_GR
argument_list|(
name|P3
argument_list|,
name|UNW_REG_UNAT
argument_list|,
name|dst
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|UNW_DEC_REG_GR
argument_list|(
name|P3
argument_list|,
name|UNW_REG_LC
argument_list|,
name|dst
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|UNW_DEC_RP_BR
argument_list|(
name|P3
argument_list|,
name|dst
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|7
case|:
name|UNW_DEC_REG_GR
argument_list|(
name|P3
argument_list|,
name|UNW_REG_RNAT
argument_list|,
name|dst
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|UNW_DEC_REG_GR
argument_list|(
name|P3
argument_list|,
name|UNW_REG_BSP
argument_list|,
name|dst
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|9
case|:
name|UNW_DEC_REG_GR
argument_list|(
name|P3
argument_list|,
name|UNW_REG_BSPSTORE
argument_list|,
name|dst
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|10
case|:
name|UNW_DEC_REG_GR
argument_list|(
name|P3
argument_list|,
name|UNW_REG_FPSR
argument_list|,
name|dst
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|11
case|:
name|UNW_DEC_PRIUNAT_GR
argument_list|(
name|P3
argument_list|,
name|dst
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
default|default:
name|UNW_DEC_BAD_CODE
argument_list|(
name|r
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|code
operator|&
literal|0x7
operator|)
operator|==
literal|0
condition|)
name|UNW_DEC_SPILL_MASK
argument_list|(
name|P4
argument_list|,
name|dp
argument_list|,
name|arg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|code
operator|&
literal|0x7
operator|)
operator|==
literal|1
condition|)
block|{
name|unw_word
name|grmask
decl_stmt|,
name|frmask
decl_stmt|,
name|byte1
decl_stmt|,
name|byte2
decl_stmt|,
name|byte3
decl_stmt|;
name|byte1
operator|=
operator|*
name|dp
operator|++
expr_stmt|;
name|byte2
operator|=
operator|*
name|dp
operator|++
expr_stmt|;
name|byte3
operator|=
operator|*
name|dp
operator|++
expr_stmt|;
name|grmask
operator|=
operator|(
operator|(
name|byte1
operator|>>
literal|4
operator|)
operator|&
literal|0xf
operator|)
expr_stmt|;
name|frmask
operator|=
operator|(
operator|(
name|byte1
operator|&
literal|0xf
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
name|byte2
operator|<<
literal|8
operator|)
operator||
name|byte3
expr_stmt|;
name|UNW_DEC_FRGR_MEM
argument_list|(
name|P5
argument_list|,
name|grmask
argument_list|,
name|frmask
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
else|else
name|UNW_DEC_BAD_CODE
argument_list|(
name|code
argument_list|)
expr_stmt|;
return|return
name|dp
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|char
modifier|*
name|unw_decode_p6
parameter_list|(
name|unsigned
name|char
modifier|*
name|dp
parameter_list|,
name|unsigned
name|char
name|code
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|gregs
init|=
operator|(
name|code
operator|&
literal|0x10
operator|)
operator|!=
literal|0
decl_stmt|;
name|unsigned
name|char
name|mask
init|=
operator|(
name|code
operator|&
literal|0x0f
operator|)
decl_stmt|;
if|if
condition|(
name|gregs
condition|)
name|UNW_DEC_GR_MEM
argument_list|(
name|P6
argument_list|,
name|mask
argument_list|,
name|arg
argument_list|)
expr_stmt|;
else|else
name|UNW_DEC_FR_MEM
argument_list|(
name|P6
argument_list|,
name|mask
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
name|dp
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|char
modifier|*
name|unw_decode_p7_p10
parameter_list|(
name|unsigned
name|char
modifier|*
name|dp
parameter_list|,
name|unsigned
name|char
name|code
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|unsigned
name|char
name|r
decl_stmt|,
name|byte1
decl_stmt|,
name|byte2
decl_stmt|;
name|unw_word
name|t
decl_stmt|,
name|size
decl_stmt|;
if|if
condition|(
operator|(
name|code
operator|&
literal|0x10
operator|)
operator|==
literal|0
condition|)
block|{
name|r
operator|=
operator|(
name|code
operator|&
literal|0xf
operator|)
expr_stmt|;
name|t
operator|=
name|unw_decode_uleb128
argument_list|(
operator|&
name|dp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r
condition|)
block|{
case|case
literal|0
case|:
name|size
operator|=
name|unw_decode_uleb128
argument_list|(
operator|&
name|dp
argument_list|)
expr_stmt|;
name|UNW_DEC_MEM_STACK_F
argument_list|(
name|P7
argument_list|,
name|t
argument_list|,
name|size
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|UNW_DEC_MEM_STACK_V
argument_list|(
name|P7
argument_list|,
name|t
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|UNW_DEC_SPILL_BASE
argument_list|(
name|P7
argument_list|,
name|t
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|UNW_DEC_REG_SPREL
argument_list|(
name|P7
argument_list|,
name|UNW_REG_PSP
argument_list|,
name|t
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|UNW_DEC_REG_WHEN
argument_list|(
name|P7
argument_list|,
name|UNW_REG_RP
argument_list|,
name|t
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|UNW_DEC_REG_PSPREL
argument_list|(
name|P7
argument_list|,
name|UNW_REG_RP
argument_list|,
name|t
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|UNW_DEC_REG_WHEN
argument_list|(
name|P7
argument_list|,
name|UNW_REG_PFS
argument_list|,
name|t
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|7
case|:
name|UNW_DEC_REG_PSPREL
argument_list|(
name|P7
argument_list|,
name|UNW_REG_PFS
argument_list|,
name|t
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|UNW_DEC_REG_WHEN
argument_list|(
name|P7
argument_list|,
name|UNW_REG_PR
argument_list|,
name|t
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|9
case|:
name|UNW_DEC_REG_PSPREL
argument_list|(
name|P7
argument_list|,
name|UNW_REG_PR
argument_list|,
name|t
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|10
case|:
name|UNW_DEC_REG_WHEN
argument_list|(
name|P7
argument_list|,
name|UNW_REG_LC
argument_list|,
name|t
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|11
case|:
name|UNW_DEC_REG_PSPREL
argument_list|(
name|P7
argument_list|,
name|UNW_REG_LC
argument_list|,
name|t
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|12
case|:
name|UNW_DEC_REG_WHEN
argument_list|(
name|P7
argument_list|,
name|UNW_REG_UNAT
argument_list|,
name|t
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|13
case|:
name|UNW_DEC_REG_PSPREL
argument_list|(
name|P7
argument_list|,
name|UNW_REG_UNAT
argument_list|,
name|t
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|14
case|:
name|UNW_DEC_REG_WHEN
argument_list|(
name|P7
argument_list|,
name|UNW_REG_FPSR
argument_list|,
name|t
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|15
case|:
name|UNW_DEC_REG_PSPREL
argument_list|(
name|P7
argument_list|,
name|UNW_REG_FPSR
argument_list|,
name|t
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
default|default:
name|UNW_DEC_BAD_CODE
argument_list|(
name|r
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|code
operator|&
literal|0xf
condition|)
block|{
case|case
literal|0x0
case|:
comment|/* p8 */
block|{
name|r
operator|=
operator|*
name|dp
operator|++
expr_stmt|;
name|t
operator|=
name|unw_decode_uleb128
argument_list|(
operator|&
name|dp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r
condition|)
block|{
case|case
literal|1
case|:
name|UNW_DEC_REG_SPREL
argument_list|(
name|P8
argument_list|,
name|UNW_REG_RP
argument_list|,
name|t
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|UNW_DEC_REG_SPREL
argument_list|(
name|P8
argument_list|,
name|UNW_REG_PFS
argument_list|,
name|t
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|UNW_DEC_REG_SPREL
argument_list|(
name|P8
argument_list|,
name|UNW_REG_PR
argument_list|,
name|t
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|UNW_DEC_REG_SPREL
argument_list|(
name|P8
argument_list|,
name|UNW_REG_LC
argument_list|,
name|t
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|UNW_DEC_REG_SPREL
argument_list|(
name|P8
argument_list|,
name|UNW_REG_UNAT
argument_list|,
name|t
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|UNW_DEC_REG_SPREL
argument_list|(
name|P8
argument_list|,
name|UNW_REG_FPSR
argument_list|,
name|t
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|7
case|:
name|UNW_DEC_REG_WHEN
argument_list|(
name|P8
argument_list|,
name|UNW_REG_BSP
argument_list|,
name|t
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|UNW_DEC_REG_PSPREL
argument_list|(
name|P8
argument_list|,
name|UNW_REG_BSP
argument_list|,
name|t
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|9
case|:
name|UNW_DEC_REG_SPREL
argument_list|(
name|P8
argument_list|,
name|UNW_REG_BSP
argument_list|,
name|t
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|10
case|:
name|UNW_DEC_REG_WHEN
argument_list|(
name|P8
argument_list|,
name|UNW_REG_BSPSTORE
argument_list|,
name|t
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|11
case|:
name|UNW_DEC_REG_PSPREL
argument_list|(
name|P8
argument_list|,
name|UNW_REG_BSPSTORE
argument_list|,
name|t
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|12
case|:
name|UNW_DEC_REG_SPREL
argument_list|(
name|P8
argument_list|,
name|UNW_REG_BSPSTORE
argument_list|,
name|t
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|13
case|:
name|UNW_DEC_REG_WHEN
argument_list|(
name|P8
argument_list|,
name|UNW_REG_RNAT
argument_list|,
name|t
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|14
case|:
name|UNW_DEC_REG_PSPREL
argument_list|(
name|P8
argument_list|,
name|UNW_REG_RNAT
argument_list|,
name|t
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|15
case|:
name|UNW_DEC_REG_SPREL
argument_list|(
name|P8
argument_list|,
name|UNW_REG_RNAT
argument_list|,
name|t
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|UNW_DEC_PRIUNAT_WHEN_GR
argument_list|(
name|P8
argument_list|,
name|t
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|17
case|:
name|UNW_DEC_PRIUNAT_PSPREL
argument_list|(
name|P8
argument_list|,
name|t
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|18
case|:
name|UNW_DEC_PRIUNAT_SPREL
argument_list|(
name|P8
argument_list|,
name|t
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|19
case|:
name|UNW_DEC_PRIUNAT_WHEN_MEM
argument_list|(
name|P8
argument_list|,
name|t
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
default|default:
name|UNW_DEC_BAD_CODE
argument_list|(
name|r
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
literal|0x1
case|:
name|byte1
operator|=
operator|*
name|dp
operator|++
expr_stmt|;
name|byte2
operator|=
operator|*
name|dp
operator|++
expr_stmt|;
name|UNW_DEC_GR_GR
argument_list|(
name|P9
argument_list|,
operator|(
name|byte1
operator|&
literal|0xf
operator|)
argument_list|,
operator|(
name|byte2
operator|&
literal|0x7f
operator|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xf
case|:
comment|/* p10 */
name|byte1
operator|=
operator|*
name|dp
operator|++
expr_stmt|;
name|byte2
operator|=
operator|*
name|dp
operator|++
expr_stmt|;
name|UNW_DEC_ABI
argument_list|(
name|P10
argument_list|,
name|byte1
argument_list|,
name|byte2
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x9
case|:
return|return
name|unw_decode_x1
argument_list|(
name|dp
argument_list|,
name|code
argument_list|,
name|arg
argument_list|)
return|;
case|case
literal|0xa
case|:
return|return
name|unw_decode_x2
argument_list|(
name|dp
argument_list|,
name|code
argument_list|,
name|arg
argument_list|)
return|;
case|case
literal|0xb
case|:
return|return
name|unw_decode_x3
argument_list|(
name|dp
argument_list|,
name|code
argument_list|,
name|arg
argument_list|)
return|;
case|case
literal|0xc
case|:
return|return
name|unw_decode_x4
argument_list|(
name|dp
argument_list|,
name|code
argument_list|,
name|arg
argument_list|)
return|;
default|default:
name|UNW_DEC_BAD_CODE
argument_list|(
name|code
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|dp
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|char
modifier|*
name|unw_decode_b1
parameter_list|(
name|unsigned
name|char
modifier|*
name|dp
parameter_list|,
name|unsigned
name|char
name|code
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|unw_word
name|label
init|=
operator|(
name|code
operator|&
literal|0x1f
operator|)
decl_stmt|;
if|if
condition|(
operator|(
name|code
operator|&
literal|0x20
operator|)
operator|!=
literal|0
condition|)
name|UNW_DEC_COPY_STATE
argument_list|(
name|B1
argument_list|,
name|label
argument_list|,
name|arg
argument_list|)
expr_stmt|;
else|else
name|UNW_DEC_LABEL_STATE
argument_list|(
name|B1
argument_list|,
name|label
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
name|dp
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|char
modifier|*
name|unw_decode_b2
parameter_list|(
name|unsigned
name|char
modifier|*
name|dp
parameter_list|,
name|unsigned
name|char
name|code
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|unw_word
name|t
decl_stmt|;
name|t
operator|=
name|unw_decode_uleb128
argument_list|(
operator|&
name|dp
argument_list|)
expr_stmt|;
name|UNW_DEC_EPILOGUE
argument_list|(
name|B2
argument_list|,
name|t
argument_list|,
operator|(
name|code
operator|&
literal|0x1f
operator|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
name|dp
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|char
modifier|*
name|unw_decode_b3_x4
parameter_list|(
name|unsigned
name|char
modifier|*
name|dp
parameter_list|,
name|unsigned
name|char
name|code
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|unw_word
name|t
decl_stmt|,
name|ecount
decl_stmt|,
name|label
decl_stmt|;
if|if
condition|(
operator|(
name|code
operator|&
literal|0x10
operator|)
operator|==
literal|0
condition|)
block|{
name|t
operator|=
name|unw_decode_uleb128
argument_list|(
operator|&
name|dp
argument_list|)
expr_stmt|;
name|ecount
operator|=
name|unw_decode_uleb128
argument_list|(
operator|&
name|dp
argument_list|)
expr_stmt|;
name|UNW_DEC_EPILOGUE
argument_list|(
name|B3
argument_list|,
name|t
argument_list|,
name|ecount
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|code
operator|&
literal|0x07
operator|)
operator|==
literal|0
condition|)
block|{
name|label
operator|=
name|unw_decode_uleb128
argument_list|(
operator|&
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|code
operator|&
literal|0x08
operator|)
operator|!=
literal|0
condition|)
name|UNW_DEC_COPY_STATE
argument_list|(
name|B4
argument_list|,
name|label
argument_list|,
name|arg
argument_list|)
expr_stmt|;
else|else
name|UNW_DEC_LABEL_STATE
argument_list|(
name|B4
argument_list|,
name|label
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
else|else
switch|switch
condition|(
name|code
operator|&
literal|0x7
condition|)
block|{
case|case
literal|1
case|:
return|return
name|unw_decode_x1
argument_list|(
name|dp
argument_list|,
name|code
argument_list|,
name|arg
argument_list|)
return|;
case|case
literal|2
case|:
return|return
name|unw_decode_x2
argument_list|(
name|dp
argument_list|,
name|code
argument_list|,
name|arg
argument_list|)
return|;
case|case
literal|3
case|:
return|return
name|unw_decode_x3
argument_list|(
name|dp
argument_list|,
name|code
argument_list|,
name|arg
argument_list|)
return|;
case|case
literal|4
case|:
return|return
name|unw_decode_x4
argument_list|(
name|dp
argument_list|,
name|code
argument_list|,
name|arg
argument_list|)
return|;
default|default:
name|UNW_DEC_BAD_CODE
argument_list|(
name|code
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|dp
return|;
block|}
end_function

begin_typedef
typedef|typedef
name|unsigned
name|char
modifier|*
function_decl|(
modifier|*
name|unw_decoder
function_decl|)
parameter_list|(
name|unsigned
name|char
modifier|*
parameter_list|,
name|unsigned
name|char
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_decl_stmt
specifier|static
specifier|const
name|unw_decoder
name|unw_decode_table
index|[
literal|2
index|]
index|[
literal|8
index|]
init|=
block|{
comment|/* prologue table: */
block|{
name|unw_decode_r1
block|,
comment|/* 0 */
name|unw_decode_r1
block|,
name|unw_decode_r2
block|,
name|unw_decode_r3
block|,
name|unw_decode_p1
block|,
comment|/* 4 */
name|unw_decode_p2_p5
block|,
name|unw_decode_p6
block|,
name|unw_decode_p7_p10
block|}
block|,
block|{
name|unw_decode_r1
block|,
comment|/* 0 */
name|unw_decode_r1
block|,
name|unw_decode_r2
block|,
name|unw_decode_r3
block|,
name|unw_decode_b1
block|,
comment|/* 4 */
name|unw_decode_b1
block|,
name|unw_decode_b2
block|,
name|unw_decode_b3_x4
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Decode one descriptor and return address of next descriptor.  */
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|char
modifier|*
name|unw_decode
parameter_list|(
name|unsigned
name|char
modifier|*
name|dp
parameter_list|,
name|int
name|inside_body
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|unw_decoder
name|decoder
decl_stmt|;
name|unsigned
name|char
name|code
decl_stmt|;
name|code
operator|=
operator|*
name|dp
operator|++
expr_stmt|;
name|decoder
operator|=
name|unw_decode_table
index|[
name|inside_body
index|]
index|[
name|code
operator|>>
literal|5
index|]
expr_stmt|;
name|dp
operator|=
call|(
modifier|*
name|decoder
call|)
argument_list|(
name|dp
argument_list|,
name|code
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
name|dp
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* RSE helper functions.  */
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|long
name|ia64_rse_slot_num
parameter_list|(
name|unsigned
name|long
modifier|*
name|addr
parameter_list|)
block|{
return|return
operator|(
operator|(
operator|(
name|unsigned
name|long
operator|)
name|addr
operator|)
operator|>>
literal|3
operator|)
operator|&
literal|0x3f
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE if ADDR is the address of an RNAT slot.  */
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|long
name|ia64_rse_is_rnat_slot
parameter_list|(
name|unsigned
name|long
modifier|*
name|addr
parameter_list|)
block|{
return|return
name|ia64_rse_slot_num
argument_list|(
name|addr
argument_list|)
operator|==
literal|0x3f
return|;
block|}
end_function

begin_comment
comment|/* Returns the address of the RNAT slot that covers the slot at    address SLOT_ADDR.  */
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|long
modifier|*
name|ia64_rse_rnat_addr
parameter_list|(
name|unsigned
name|long
modifier|*
name|slot_addr
parameter_list|)
block|{
return|return
operator|(
name|unsigned
name|long
operator|*
operator|)
operator|(
operator|(
name|unsigned
name|long
operator|)
name|slot_addr
operator||
operator|(
literal|0x3f
operator|<<
literal|3
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Calculate the number of registers in the dirty partition starting at    BSPSTORE with a size of DIRTY bytes.  This isn't simply DIRTY    divided by eight because the 64th slot is used to store ar.rnat.  */
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|long
name|ia64_rse_num_regs
parameter_list|(
name|unsigned
name|long
modifier|*
name|bspstore
parameter_list|,
name|unsigned
name|long
modifier|*
name|bsp
parameter_list|)
block|{
name|unsigned
name|long
name|slots
init|=
operator|(
name|bsp
operator|-
name|bspstore
operator|)
decl_stmt|;
return|return
name|slots
operator|-
operator|(
name|ia64_rse_slot_num
argument_list|(
name|bspstore
argument_list|)
operator|+
name|slots
operator|)
operator|/
literal|0x40
return|;
block|}
end_function

begin_comment
comment|/* The inverse of the above: given bspstore and the number of    registers, calculate ar.bsp.  */
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|long
modifier|*
name|ia64_rse_skip_regs
parameter_list|(
name|unsigned
name|long
modifier|*
name|addr
parameter_list|,
name|long
name|num_regs
parameter_list|)
block|{
name|long
name|delta
init|=
name|ia64_rse_slot_num
argument_list|(
name|addr
argument_list|)
operator|+
name|num_regs
decl_stmt|;
if|if
condition|(
name|num_regs
operator|<
literal|0
condition|)
name|delta
operator|-=
literal|0x3e
expr_stmt|;
return|return
name|addr
operator|+
name|num_regs
operator|+
name|delta
operator|/
literal|0x3f
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Copy register backing store from SRC to DST, LEN words    (which include both saved registers and nat collections).    DST_RNAT is a partial nat collection for DST.  SRC and DST    don't have to be equal modulo 64 slots, so it cannot be    done with a simple memcpy as the nat collections will be    at different relative offsets and need to be combined together.  */
end_comment

begin_function
specifier|static
name|void
name|ia64_copy_rbs
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|info
parameter_list|,
name|unsigned
name|long
name|dst
parameter_list|,
name|unsigned
name|long
name|src
parameter_list|,
name|long
name|len
parameter_list|,
name|unsigned
name|long
name|dst_rnat
parameter_list|)
block|{
name|long
name|count
decl_stmt|;
name|unsigned
name|long
name|src_rnat
decl_stmt|;
name|unsigned
name|long
name|shift1
decl_stmt|,
name|shift2
decl_stmt|;
name|len
operator|<<=
literal|3
expr_stmt|;
name|dst_rnat
operator|&=
operator|(
literal|1UL
operator|<<
operator|(
operator|(
name|dst
operator|>>
literal|3
operator|)
operator|&
literal|0x3f
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
name|src_rnat
operator|=
name|src
operator|>=
name|info
operator|->
name|regstk_top
condition|?
name|info
operator|->
name|rnat
else|:
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
operator|(
name|src
operator||
literal|0x1f8
operator|)
expr_stmt|;
name|src_rnat
operator|&=
operator|~
operator|(
operator|(
literal|1UL
operator|<<
operator|(
operator|(
name|src
operator|>>
literal|3
operator|)
operator|&
literal|0x3f
operator|)
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* Just to make sure.  */
name|src_rnat
operator|&=
operator|~
operator|(
literal|1UL
operator|<<
literal|63
operator|)
expr_stmt|;
name|shift1
operator|=
operator|(
operator|(
name|dst
operator|-
name|src
operator|)
operator|>>
literal|3
operator|)
operator|&
literal|0x3f
expr_stmt|;
if|if
condition|(
operator|(
name|dst
operator|&
literal|0x1f8
operator|)
operator|<
operator|(
name|src
operator|&
literal|0x1f8
operator|)
condition|)
name|shift1
operator|--
expr_stmt|;
name|shift2
operator|=
literal|0x3f
operator|-
name|shift1
expr_stmt|;
if|if
condition|(
operator|(
name|dst
operator|&
literal|0x1f8
operator|)
operator|>=
operator|(
name|src
operator|&
literal|0x1f8
operator|)
condition|)
block|{
name|count
operator|=
operator|~
name|dst
operator|&
literal|0x1f8
expr_stmt|;
goto|goto
name|first
goto|;
block|}
name|count
operator|=
operator|~
name|src
operator|&
literal|0x1f8
expr_stmt|;
goto|goto
name|second
goto|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|src_rnat
operator|=
name|src
operator|>=
name|info
operator|->
name|regstk_top
condition|?
name|info
operator|->
name|rnat
else|:
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
operator|(
name|src
operator||
literal|0x1f8
operator|)
expr_stmt|;
comment|/* Just to make sure.  */
name|src_rnat
operator|&=
operator|~
operator|(
literal|1UL
operator|<<
literal|63
operator|)
expr_stmt|;
name|count
operator|=
name|shift2
operator|<<
literal|3
expr_stmt|;
name|first
label|:
if|if
condition|(
name|count
operator|>
name|len
condition|)
name|count
operator|=
name|len
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dst
argument_list|,
operator|(
name|char
operator|*
operator|)
name|src
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|dst
operator|+=
name|count
expr_stmt|;
name|src
operator|+=
name|count
expr_stmt|;
name|len
operator|-=
name|count
expr_stmt|;
name|dst_rnat
operator||=
operator|(
name|src_rnat
operator|<<
name|shift1
operator|)
operator|&
operator|~
operator|(
literal|1UL
operator|<<
literal|63
operator|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
break|break;
operator|*
operator|(
name|long
operator|*
operator|)
name|dst
operator|=
name|dst_rnat
expr_stmt|;
name|dst
operator|+=
literal|8
expr_stmt|;
name|dst_rnat
operator|=
literal|0
expr_stmt|;
name|count
operator|=
name|shift1
operator|<<
literal|3
expr_stmt|;
name|second
label|:
if|if
condition|(
name|count
operator|>
name|len
condition|)
name|count
operator|=
name|len
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dst
argument_list|,
operator|(
name|char
operator|*
operator|)
name|src
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|dst
operator|+=
name|count
expr_stmt|;
name|src
operator|+=
name|count
operator|+
literal|8
expr_stmt|;
name|len
operator|-=
name|count
operator|+
literal|8
expr_stmt|;
name|dst_rnat
operator||=
operator|(
name|src_rnat
operator|>>
name|shift2
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|dst
operator|&
literal|0x1f8
operator|)
operator|==
literal|0x1f8
condition|)
block|{
operator|*
operator|(
name|long
operator|*
operator|)
name|dst
operator|=
name|dst_rnat
expr_stmt|;
name|dst
operator|+=
literal|8
expr_stmt|;
name|dst_rnat
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Set info->regstk_top to lowest rbs address which will use      info->rnat collection.  */
name|info
operator|->
name|regstk_top
operator|=
name|dst
operator|&
operator|~
literal|0x1ffUL
expr_stmt|;
name|info
operator|->
name|rnat
operator|=
name|dst_rnat
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Unwind accessors.  */
end_comment

begin_function
specifier|static
name|void
name|unw_access_gr
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|info
parameter_list|,
name|int
name|regnum
parameter_list|,
name|unsigned
name|long
modifier|*
name|val
parameter_list|,
name|char
modifier|*
name|nat
parameter_list|,
name|int
name|write
parameter_list|)
block|{
name|unsigned
name|long
modifier|*
name|addr
decl_stmt|,
modifier|*
name|nat_addr
init|=
literal|0
decl_stmt|,
name|nat_mask
init|=
literal|0
decl_stmt|,
name|dummy_nat
decl_stmt|;
name|struct
name|unw_ireg
modifier|*
name|ireg
decl_stmt|;
if|if
condition|(
operator|(
name|unsigned
operator|)
name|regnum
operator|-
literal|1
operator|>=
literal|127
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|regnum
operator|<
literal|1
condition|)
block|{
name|nat_addr
operator|=
name|addr
operator|=
operator|&
name|dummy_nat
expr_stmt|;
name|dummy_nat
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regnum
operator|<
literal|32
condition|)
block|{
comment|/* Access a non-stacked register.  */
name|ireg
operator|=
operator|&
name|info
operator|->
name|ireg
index|[
name|regnum
operator|-
literal|2
index|]
expr_stmt|;
name|addr
operator|=
name|ireg
operator|->
name|loc
expr_stmt|;
if|if
condition|(
name|addr
condition|)
block|{
name|nat_addr
operator|=
name|addr
operator|+
name|ireg
operator|->
name|nat
operator|.
name|off
expr_stmt|;
switch|switch
condition|(
name|ireg
operator|->
name|nat
operator|.
name|type
condition|)
block|{
case|case
name|UNW_NAT_VAL
case|:
comment|/* Simulate getf.sig/setf.sig.  */
if|if
condition|(
name|write
condition|)
block|{
if|if
condition|(
operator|*
name|nat
condition|)
block|{
comment|/* Write NaTVal and be done with it.  */
name|addr
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|addr
index|[
literal|1
index|]
operator|=
literal|0x1fffe
expr_stmt|;
return|return;
block|}
name|addr
index|[
literal|1
index|]
operator|=
literal|0x1003e
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|addr
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
name|addr
index|[
literal|1
index|]
operator|==
literal|0x1ffe
condition|)
block|{
comment|/* Return NaT and be done with it.  */
operator|*
name|val
operator|=
literal|0
expr_stmt|;
operator|*
name|nat
operator|=
literal|1
expr_stmt|;
return|return;
block|}
comment|/* FALLTHRU */
case|case
name|UNW_NAT_NONE
case|:
name|dummy_nat
operator|=
literal|0
expr_stmt|;
name|nat_addr
operator|=
operator|&
name|dummy_nat
expr_stmt|;
break|break;
case|case
name|UNW_NAT_MEMSTK
case|:
name|nat_mask
operator|=
literal|1UL
operator|<<
operator|(
operator|(
name|long
operator|)
name|addr
operator|&
literal|0x1f8
operator|)
operator|/
literal|8
expr_stmt|;
break|break;
case|case
name|UNW_NAT_REGSTK
case|:
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|addr
operator|>=
name|info
operator|->
name|regstk_top
condition|)
name|nat_addr
operator|=
operator|&
name|info
operator|->
name|rnat
expr_stmt|;
else|else
name|nat_addr
operator|=
name|ia64_rse_rnat_addr
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|nat_mask
operator|=
literal|1UL
operator|<<
name|ia64_rse_slot_num
argument_list|(
name|addr
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
comment|/* Access a stacked register.  */
name|addr
operator|=
name|ia64_rse_skip_regs
argument_list|(
operator|(
name|unsigned
name|long
operator|*
operator|)
name|info
operator|->
name|bsp
argument_list|,
name|regnum
operator|-
literal|32
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|addr
operator|>=
name|info
operator|->
name|regstk_top
condition|)
name|nat_addr
operator|=
operator|&
name|info
operator|->
name|rnat
expr_stmt|;
else|else
name|nat_addr
operator|=
name|ia64_rse_rnat_addr
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|nat_mask
operator|=
literal|1UL
operator|<<
name|ia64_rse_slot_num
argument_list|(
name|addr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|write
condition|)
block|{
operator|*
name|addr
operator|=
operator|*
name|val
expr_stmt|;
if|if
condition|(
operator|*
name|nat
condition|)
operator|*
name|nat_addr
operator||=
name|nat_mask
expr_stmt|;
else|else
operator|*
name|nat_addr
operator|&=
operator|~
name|nat_mask
expr_stmt|;
block|}
else|else
block|{
operator|*
name|val
operator|=
operator|*
name|addr
expr_stmt|;
operator|*
name|nat
operator|=
operator|(
operator|*
name|nat_addr
operator|&
name|nat_mask
operator|)
operator|!=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Get the value of register REG as saved in CONTEXT.  */
end_comment

begin_function
name|_Unwind_Word
name|_Unwind_GetGR
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|_Unwind_Word
name|ret
decl_stmt|;
name|char
name|nat
decl_stmt|;
if|if
condition|(
name|index
operator|==
literal|1
condition|)
return|return
name|context
operator|->
name|gp
return|;
elseif|else
if|if
condition|(
name|index
operator|>=
literal|15
operator|&&
name|index
operator|<=
literal|18
condition|)
return|return
name|context
operator|->
name|eh_data
index|[
name|index
operator|-
literal|15
index|]
return|;
else|else
name|unw_access_gr
argument_list|(
name|context
argument_list|,
name|index
argument_list|,
operator|&
name|ret
argument_list|,
operator|&
name|nat
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Overwrite the saved value for register REG in CONTEXT with VAL.  */
end_comment

begin_function
name|void
name|_Unwind_SetGR
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|,
name|int
name|index
parameter_list|,
name|_Unwind_Word
name|val
parameter_list|)
block|{
name|char
name|nat
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|index
operator|==
literal|1
condition|)
name|context
operator|->
name|gp
operator|=
name|val
expr_stmt|;
elseif|else
if|if
condition|(
name|index
operator|>=
literal|15
operator|&&
name|index
operator|<=
literal|18
condition|)
name|context
operator|->
name|eh_data
index|[
name|index
operator|-
literal|15
index|]
operator|=
name|val
expr_stmt|;
else|else
name|unw_access_gr
argument_list|(
name|context
argument_list|,
name|index
argument_list|,
operator|&
name|val
argument_list|,
operator|&
name|nat
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Retrieve the return address for CONTEXT.  */
end_comment

begin_function
specifier|inline
name|_Unwind_Ptr
name|_Unwind_GetIP
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|)
block|{
return|return
name|context
operator|->
name|rp
return|;
block|}
end_function

begin_comment
comment|/* Overwrite the return address for CONTEXT with VAL.  */
end_comment

begin_function
specifier|inline
name|void
name|_Unwind_SetIP
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|,
name|_Unwind_Ptr
name|val
parameter_list|)
block|{
name|context
operator|->
name|rp
operator|=
name|val
expr_stmt|;
block|}
end_function

begin_function
name|void
modifier|*
name|_Unwind_GetLanguageSpecificData
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|)
block|{
return|return
name|context
operator|->
name|lsda
return|;
block|}
end_function

begin_function
name|_Unwind_Ptr
name|_Unwind_GetRegionStart
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|)
block|{
return|return
name|context
operator|->
name|region_start
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|_Unwind_FindEnclosingFunction
parameter_list|(
name|void
modifier|*
name|pc
parameter_list|)
block|{
name|struct
name|unw_table_entry
modifier|*
name|ent
decl_stmt|;
name|unsigned
name|long
name|segment_base
decl_stmt|,
name|gp
decl_stmt|;
name|ent
operator|=
name|_Unwind_FindTableEntry
argument_list|(
name|pc
argument_list|,
operator|&
name|segment_base
argument_list|,
operator|&
name|gp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ent
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
else|else
return|return
operator|(
name|void
operator|*
operator|)
operator|(
name|segment_base
operator|+
name|ent
operator|->
name|start_offset
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Get the value of the CFA as saved in CONTEXT.  In GCC/Dwarf2 parlance,    the CFA is the value of the stack pointer on entry; In IA-64 unwind    parlance, this is the PSP.  */
end_comment

begin_function
name|_Unwind_Word
name|_Unwind_GetCFA
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|)
block|{
return|return
operator|(
name|_Unwind_Ptr
operator|)
name|context
operator|->
name|psp
return|;
block|}
end_function

begin_comment
comment|/* Get the value of the Backing Store Pointer as saved in CONTEXT.  */
end_comment

begin_function
name|_Unwind_Word
name|_Unwind_GetBSP
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|)
block|{
return|return
operator|(
name|_Unwind_Ptr
operator|)
name|context
operator|->
name|bsp
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|_Unwind_Reason_Code
name|uw_frame_state_for
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|,
name|_Unwind_FrameState
modifier|*
name|fs
parameter_list|)
block|{
name|struct
name|unw_table_entry
modifier|*
name|ent
decl_stmt|;
name|unsigned
name|long
modifier|*
name|unw
decl_stmt|,
name|header
decl_stmt|,
name|length
decl_stmt|;
name|unsigned
name|char
modifier|*
name|insn
decl_stmt|,
modifier|*
name|insn_end
decl_stmt|;
name|unsigned
name|long
name|segment_base
decl_stmt|;
name|struct
name|unw_reg_info
modifier|*
name|r
decl_stmt|;
name|memset
argument_list|(
name|fs
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fs
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|r
operator|=
name|fs
operator|->
name|curr
operator|.
name|reg
init|;
name|r
operator|<
name|fs
operator|->
name|curr
operator|.
name|reg
operator|+
name|UNW_NUM_REGS
condition|;
operator|++
name|r
control|)
name|r
operator|->
name|when
operator|=
name|UNW_WHEN_NEVER
expr_stmt|;
name|context
operator|->
name|lsda
operator|=
literal|0
expr_stmt|;
name|ent
operator|=
name|_Unwind_FindTableEntry
argument_list|(
operator|(
name|void
operator|*
operator|)
name|context
operator|->
name|rp
argument_list|,
operator|&
name|segment_base
argument_list|,
operator|&
name|context
operator|->
name|gp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ent
operator|==
name|NULL
condition|)
block|{
comment|/* Couldn't find unwind info for this function.  Try an 	 os-specific fallback mechanism.  This will necessarily 	 not provide a personality routine or LSDA.  */
ifdef|#
directive|ifdef
name|MD_FALLBACK_FRAME_STATE_FOR
name|MD_FALLBACK_FRAME_STATE_FOR
argument_list|(
name|context
argument_list|,
name|fs
argument_list|,
name|success
argument_list|)
expr_stmt|;
comment|/* [SCRA 11.4.1] A leaf function with no memory stack, no exception 	 handlers, and which keeps the return value in B0 does not need 	 an unwind table entry.  	 This can only happen in the frame after unwinding through a signal 	 handler.  Avoid infinite looping by requiring that B0 != RP. 	 RP == 0 terminates the chain.  */
if|if
condition|(
name|context
operator|->
name|br_loc
index|[
literal|0
index|]
operator|&&
operator|*
name|context
operator|->
name|br_loc
index|[
literal|0
index|]
operator|!=
name|context
operator|->
name|rp
operator|&&
name|context
operator|->
name|rp
operator|!=
literal|0
condition|)
block|{
name|fs
operator|->
name|curr
operator|.
name|reg
index|[
name|UNW_REG_RP
index|]
operator|.
name|where
operator|=
name|UNW_WHERE_BR
expr_stmt|;
name|fs
operator|->
name|curr
operator|.
name|reg
index|[
name|UNW_REG_RP
index|]
operator|.
name|when
operator|=
operator|-
literal|1
expr_stmt|;
name|fs
operator|->
name|curr
operator|.
name|reg
index|[
name|UNW_REG_RP
index|]
operator|.
name|val
operator|=
literal|0
expr_stmt|;
goto|goto
name|success
goto|;
block|}
return|return
name|_URC_END_OF_STACK
return|;
name|success
label|:
return|return
name|_URC_NO_REASON
return|;
else|#
directive|else
return|return
name|_URC_END_OF_STACK
return|;
endif|#
directive|endif
block|}
name|context
operator|->
name|region_start
operator|=
name|ent
operator|->
name|start_offset
operator|+
name|segment_base
expr_stmt|;
name|fs
operator|->
name|when_target
operator|=
operator|(
operator|(
name|context
operator|->
name|rp
operator|&
operator|-
literal|16
operator|)
operator|-
name|context
operator|->
name|region_start
operator|)
operator|/
literal|16
operator|*
literal|3
operator|+
operator|(
name|context
operator|->
name|rp
operator|&
literal|15
operator|)
expr_stmt|;
name|unw
operator|=
operator|(
name|unsigned
name|long
operator|*
operator|)
operator|(
name|ent
operator|->
name|info_offset
operator|+
name|segment_base
operator|)
expr_stmt|;
name|header
operator|=
operator|*
name|unw
expr_stmt|;
name|length
operator|=
name|UNW_LENGTH
argument_list|(
name|header
argument_list|)
expr_stmt|;
comment|/* ??? Perhaps check UNW_VER / UNW_FLAG_OSMASK.  */
if|if
condition|(
name|UNW_FLAG_EHANDLER
argument_list|(
name|header
argument_list|)
operator||
name|UNW_FLAG_UHANDLER
argument_list|(
name|header
argument_list|)
condition|)
block|{
name|fs
operator|->
name|personality
operator|=
operator|*
operator|(
name|_Unwind_Personality_Fn
operator|*
operator|)
operator|(
name|unw
index|[
name|length
operator|+
literal|1
index|]
operator|+
name|context
operator|->
name|gp
operator|)
expr_stmt|;
name|context
operator|->
name|lsda
operator|=
name|unw
operator|+
name|length
operator|+
literal|2
expr_stmt|;
block|}
name|insn
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
name|unw
operator|+
literal|1
operator|)
expr_stmt|;
name|insn_end
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
name|unw
operator|+
literal|1
operator|+
name|length
operator|)
expr_stmt|;
while|while
condition|(
operator|!
name|fs
operator|->
name|done
operator|&&
name|insn
operator|<
name|insn_end
condition|)
name|insn
operator|=
name|unw_decode
argument_list|(
name|insn
argument_list|,
name|fs
operator|->
name|in_body
argument_list|,
name|fs
argument_list|)
expr_stmt|;
name|free_label_states
argument_list|(
name|fs
operator|->
name|labeled_states
argument_list|)
expr_stmt|;
name|free_state_stack
argument_list|(
operator|&
name|fs
operator|->
name|curr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_MALLOC_CHECKING
if|if
condition|(
name|reg_state_alloced
operator|||
name|labeled_state_alloced
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* If we're in the epilogue, sp has been restored and all values      on the memory stack below psp also have been restored.  */
if|if
condition|(
name|fs
operator|->
name|when_target
operator|>
name|fs
operator|->
name|epilogue_start
condition|)
block|{
name|struct
name|unw_reg_info
modifier|*
name|r
decl_stmt|;
name|fs
operator|->
name|curr
operator|.
name|reg
index|[
name|UNW_REG_PSP
index|]
operator|.
name|where
operator|=
name|UNW_WHERE_NONE
expr_stmt|;
name|fs
operator|->
name|curr
operator|.
name|reg
index|[
name|UNW_REG_PSP
index|]
operator|.
name|val
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|r
operator|=
name|fs
operator|->
name|curr
operator|.
name|reg
init|;
name|r
operator|<
name|fs
operator|->
name|curr
operator|.
name|reg
operator|+
name|UNW_NUM_REGS
condition|;
operator|++
name|r
control|)
if|if
condition|(
operator|(
name|r
operator|->
name|where
operator|==
name|UNW_WHERE_PSPREL
operator|&&
name|r
operator|->
name|val
operator|<=
literal|0x10
operator|)
operator|||
name|r
operator|->
name|where
operator|==
name|UNW_WHERE_SPREL
condition|)
name|r
operator|->
name|where
operator|=
name|UNW_WHERE_NONE
expr_stmt|;
block|}
comment|/* If RP did't get saved, generate entry for the return link register.  */
if|if
condition|(
name|fs
operator|->
name|curr
operator|.
name|reg
index|[
name|UNW_REG_RP
index|]
operator|.
name|when
operator|>=
name|fs
operator|->
name|when_target
condition|)
block|{
name|fs
operator|->
name|curr
operator|.
name|reg
index|[
name|UNW_REG_RP
index|]
operator|.
name|where
operator|=
name|UNW_WHERE_BR
expr_stmt|;
name|fs
operator|->
name|curr
operator|.
name|reg
index|[
name|UNW_REG_RP
index|]
operator|.
name|when
operator|=
operator|-
literal|1
expr_stmt|;
name|fs
operator|->
name|curr
operator|.
name|reg
index|[
name|UNW_REG_RP
index|]
operator|.
name|val
operator|=
name|fs
operator|->
name|return_link_reg
expr_stmt|;
block|}
return|return
name|_URC_NO_REASON
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|uw_update_reg_address
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|,
name|_Unwind_FrameState
modifier|*
name|fs
parameter_list|,
name|enum
name|unw_register_index
name|regno
parameter_list|)
block|{
name|struct
name|unw_reg_info
modifier|*
name|r
init|=
name|fs
operator|->
name|curr
operator|.
name|reg
operator|+
name|regno
decl_stmt|;
name|void
modifier|*
name|addr
decl_stmt|;
name|unsigned
name|long
name|rval
decl_stmt|;
if|if
condition|(
name|r
operator|->
name|where
operator|==
name|UNW_WHERE_NONE
operator|||
name|r
operator|->
name|when
operator|>=
name|fs
operator|->
name|when_target
condition|)
return|return;
name|rval
operator|=
name|r
operator|->
name|val
expr_stmt|;
switch|switch
condition|(
name|r
operator|->
name|where
condition|)
block|{
case|case
name|UNW_WHERE_GR
case|:
if|if
condition|(
name|rval
operator|>=
literal|32
condition|)
name|addr
operator|=
name|ia64_rse_skip_regs
argument_list|(
operator|(
name|unsigned
name|long
operator|*
operator|)
name|context
operator|->
name|bsp
argument_list|,
name|rval
operator|-
literal|32
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rval
operator|>=
literal|2
condition|)
name|addr
operator|=
name|context
operator|->
name|ireg
index|[
name|rval
operator|-
literal|2
index|]
operator|.
name|loc
expr_stmt|;
elseif|else
if|if
condition|(
name|rval
operator|==
literal|0
condition|)
block|{
specifier|static
specifier|const
name|unsigned
name|long
name|dummy
decl_stmt|;
name|addr
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|dummy
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
break|break;
case|case
name|UNW_WHERE_FR
case|:
if|if
condition|(
name|rval
operator|>=
literal|2
operator|&&
name|rval
operator|<
literal|32
condition|)
name|addr
operator|=
name|context
operator|->
name|fr_loc
index|[
name|rval
operator|-
literal|2
index|]
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
break|break;
case|case
name|UNW_WHERE_BR
case|:
comment|/* Note that while RVAL can only be 1-5 from normal descriptors, 	 we can want to look at B0, B6 and B7 due to having manually unwound a 	 signal frame.  */
if|if
condition|(
name|rval
operator|<
literal|8
condition|)
name|addr
operator|=
name|context
operator|->
name|br_loc
index|[
name|rval
index|]
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
break|break;
case|case
name|UNW_WHERE_SPREL
case|:
name|addr
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|context
operator|->
name|sp
operator|+
name|rval
operator|)
expr_stmt|;
break|break;
case|case
name|UNW_WHERE_PSPREL
case|:
name|addr
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|context
operator|->
name|psp
operator|+
name|rval
operator|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
switch|switch
condition|(
name|regno
condition|)
block|{
case|case
name|UNW_REG_R2
operator|...
name|UNW_REG_R31
case|:
name|context
operator|->
name|ireg
index|[
name|regno
operator|-
name|UNW_REG_R2
index|]
operator|.
name|loc
operator|=
name|addr
expr_stmt|;
switch|switch
condition|(
name|r
operator|->
name|where
condition|)
block|{
case|case
name|UNW_WHERE_GR
case|:
if|if
condition|(
name|rval
operator|>=
literal|32
condition|)
block|{
name|context
operator|->
name|ireg
index|[
name|regno
operator|-
name|UNW_REG_R2
index|]
operator|.
name|nat
operator|.
name|type
operator|=
name|UNW_NAT_MEMSTK
expr_stmt|;
name|context
operator|->
name|ireg
index|[
name|regno
operator|-
name|UNW_REG_R2
index|]
operator|.
name|nat
operator|.
name|off
operator|=
name|context
operator|->
name|pri_unat_loc
operator|-
operator|(
name|unsigned
name|long
operator|*
operator|)
name|addr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rval
operator|>=
literal|2
condition|)
block|{
name|context
operator|->
name|ireg
index|[
name|regno
operator|-
name|UNW_REG_R2
index|]
operator|.
name|nat
operator|=
name|context
operator|->
name|ireg
index|[
name|rval
operator|-
literal|2
index|]
operator|.
name|nat
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rval
operator|==
literal|0
condition|)
block|{
name|context
operator|->
name|ireg
index|[
name|regno
operator|-
name|UNW_REG_R2
index|]
operator|.
name|nat
operator|.
name|type
operator|=
name|UNW_NAT_NONE
expr_stmt|;
name|context
operator|->
name|ireg
index|[
name|regno
operator|-
name|UNW_REG_R2
index|]
operator|.
name|nat
operator|.
name|off
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
break|break;
case|case
name|UNW_WHERE_FR
case|:
name|context
operator|->
name|ireg
index|[
name|regno
operator|-
name|UNW_REG_R2
index|]
operator|.
name|nat
operator|.
name|type
operator|=
name|UNW_NAT_VAL
expr_stmt|;
name|context
operator|->
name|ireg
index|[
name|regno
operator|-
name|UNW_REG_R2
index|]
operator|.
name|nat
operator|.
name|off
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|UNW_WHERE_BR
case|:
name|context
operator|->
name|ireg
index|[
name|regno
operator|-
name|UNW_REG_R2
index|]
operator|.
name|nat
operator|.
name|type
operator|=
name|UNW_NAT_NONE
expr_stmt|;
name|context
operator|->
name|ireg
index|[
name|regno
operator|-
name|UNW_REG_R2
index|]
operator|.
name|nat
operator|.
name|off
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|UNW_WHERE_PSPREL
case|:
case|case
name|UNW_WHERE_SPREL
case|:
name|context
operator|->
name|ireg
index|[
name|regno
operator|-
name|UNW_REG_R2
index|]
operator|.
name|nat
operator|.
name|type
operator|=
name|UNW_NAT_MEMSTK
expr_stmt|;
name|context
operator|->
name|ireg
index|[
name|regno
operator|-
name|UNW_REG_R2
index|]
operator|.
name|nat
operator|.
name|off
operator|=
name|context
operator|->
name|pri_unat_loc
operator|-
operator|(
name|unsigned
name|long
operator|*
operator|)
name|addr
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|UNW_REG_F2
operator|...
name|UNW_REG_F31
case|:
name|context
operator|->
name|fr_loc
index|[
name|regno
operator|-
name|UNW_REG_F2
index|]
operator|=
name|addr
expr_stmt|;
break|break;
case|case
name|UNW_REG_B1
operator|...
name|UNW_REG_B5
case|:
name|context
operator|->
name|br_loc
index|[
name|regno
operator|-
name|UNW_REG_B0
index|]
operator|=
name|addr
expr_stmt|;
break|break;
case|case
name|UNW_REG_BSP
case|:
name|context
operator|->
name|bsp_loc
operator|=
name|addr
expr_stmt|;
break|break;
case|case
name|UNW_REG_BSPSTORE
case|:
name|context
operator|->
name|bspstore_loc
operator|=
name|addr
expr_stmt|;
break|break;
case|case
name|UNW_REG_PFS
case|:
name|context
operator|->
name|pfs_loc
operator|=
name|addr
expr_stmt|;
break|break;
case|case
name|UNW_REG_RP
case|:
name|context
operator|->
name|rp
operator|=
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
name|addr
expr_stmt|;
break|break;
case|case
name|UNW_REG_UNAT
case|:
name|context
operator|->
name|unat_loc
operator|=
name|addr
expr_stmt|;
break|break;
case|case
name|UNW_REG_PR
case|:
name|context
operator|->
name|pr
operator|=
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
name|addr
expr_stmt|;
break|break;
case|case
name|UNW_REG_LC
case|:
name|context
operator|->
name|lc_loc
operator|=
name|addr
expr_stmt|;
break|break;
case|case
name|UNW_REG_FPSR
case|:
name|context
operator|->
name|fpsr_loc
operator|=
name|addr
expr_stmt|;
break|break;
case|case
name|UNW_REG_PSP
case|:
name|context
operator|->
name|psp
operator|=
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
name|addr
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|uw_update_context
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|,
name|_Unwind_FrameState
modifier|*
name|fs
parameter_list|)
block|{
name|long
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|MD_HANDLE_UNWABI
name|MD_HANDLE_UNWABI
argument_list|(
name|context
argument_list|,
name|fs
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|context
operator|->
name|sp
operator|=
name|context
operator|->
name|psp
expr_stmt|;
comment|/* First, set PSP.  Subsequent instructions may depend on this value.  */
if|if
condition|(
name|fs
operator|->
name|when_target
operator|>
name|fs
operator|->
name|curr
operator|.
name|reg
index|[
name|UNW_REG_PSP
index|]
operator|.
name|when
condition|)
block|{
if|if
condition|(
name|fs
operator|->
name|curr
operator|.
name|reg
index|[
name|UNW_REG_PSP
index|]
operator|.
name|where
operator|==
name|UNW_WHERE_NONE
condition|)
name|context
operator|->
name|psp
operator|=
name|context
operator|->
name|psp
operator|+
name|fs
operator|->
name|curr
operator|.
name|reg
index|[
name|UNW_REG_PSP
index|]
operator|.
name|val
expr_stmt|;
else|else
name|uw_update_reg_address
argument_list|(
name|context
argument_list|,
name|fs
argument_list|,
name|UNW_REG_PSP
argument_list|)
expr_stmt|;
block|}
comment|/* Determine the location of the primary UNaT.  */
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|fs
operator|->
name|when_target
operator|<
name|fs
operator|->
name|curr
operator|.
name|reg
index|[
name|UNW_REG_PRI_UNAT_GR
index|]
operator|.
name|when
condition|)
name|i
operator|=
name|UNW_REG_PRI_UNAT_MEM
expr_stmt|;
elseif|else
if|if
condition|(
name|fs
operator|->
name|when_target
operator|<
name|fs
operator|->
name|curr
operator|.
name|reg
index|[
name|UNW_REG_PRI_UNAT_MEM
index|]
operator|.
name|when
condition|)
name|i
operator|=
name|UNW_REG_PRI_UNAT_GR
expr_stmt|;
elseif|else
if|if
condition|(
name|fs
operator|->
name|curr
operator|.
name|reg
index|[
name|UNW_REG_PRI_UNAT_MEM
index|]
operator|.
name|when
operator|>
name|fs
operator|->
name|curr
operator|.
name|reg
index|[
name|UNW_REG_PRI_UNAT_GR
index|]
operator|.
name|when
condition|)
name|i
operator|=
name|UNW_REG_PRI_UNAT_MEM
expr_stmt|;
else|else
name|i
operator|=
name|UNW_REG_PRI_UNAT_GR
expr_stmt|;
name|uw_update_reg_address
argument_list|(
name|context
argument_list|,
name|fs
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* Compute the addresses of all registers saved in this frame.  */
for|for
control|(
name|i
operator|=
name|UNW_REG_BSP
init|;
name|i
operator|<
name|UNW_NUM_REGS
condition|;
operator|++
name|i
control|)
name|uw_update_reg_address
argument_list|(
name|context
argument_list|,
name|fs
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Unwind BSP for the local registers allocated this frame.  */
comment|/* ??? What to do with stored BSP or BSPSTORE registers.  */
comment|/* We assert that we are either at a call site, or we have      just unwound through a signal frame.  In either case      pfs_loc is valid.	*/
if|if
condition|(
operator|!
operator|(
name|fs
operator|->
name|no_reg_stack_frame
operator|)
condition|)
block|{
name|unsigned
name|long
name|pfs
init|=
operator|*
name|context
operator|->
name|pfs_loc
decl_stmt|;
name|unsigned
name|long
name|sol
init|=
operator|(
name|pfs
operator|>>
literal|7
operator|)
operator|&
literal|0x7f
decl_stmt|;
name|context
operator|->
name|bsp
operator|=
operator|(
name|unsigned
name|long
operator|)
name|ia64_rse_skip_regs
argument_list|(
operator|(
name|unsigned
name|long
operator|*
operator|)
name|context
operator|->
name|bsp
argument_list|,
operator|-
name|sol
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Fill in CONTEXT for top-of-stack.  The only valid registers at this    level will be the return address and the CFA.  Note that CFA = SP+16.  */
end_comment

begin_define
define|#
directive|define
name|uw_init_context
parameter_list|(
name|CONTEXT
parameter_list|)
define|\
value|do {									\
comment|/* ??? There is a whole lot o code in uw_install_context that	\        tries to avoid spilling the entire machine state here.  We	\        should try to make that work again.  */
value|\     __builtin_unwind_init();						\     uw_init_context_1 (CONTEXT, __builtin_ia64_bsp ());			\   } while (0)
end_define

begin_function
specifier|static
name|void
name|uw_init_context_1
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|,
name|void
modifier|*
name|bsp
parameter_list|)
block|{
name|void
modifier|*
name|rp
init|=
name|__builtin_extract_return_addr
argument_list|(
name|__builtin_return_address
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Set psp to the caller's stack pointer.  */
name|void
modifier|*
name|psp
init|=
name|__builtin_dwarf_cfa
argument_list|()
operator|-
literal|16
decl_stmt|;
name|_Unwind_FrameState
name|fs
decl_stmt|;
name|unsigned
name|long
name|rnat
decl_stmt|,
name|tmp1
decl_stmt|,
name|tmp2
decl_stmt|;
comment|/* Flush the register stack to memory so that we can access it.      Get rse nat collection for the last incomplete rbs chunk of      registers at the same time.  For this RSE needs to be turned      into the mandatory only mode.  */
asm|asm ("mov.m %1 = ar.rsc;;\n\t"        "and %2 = 0x1c, %1;;\n\t"        "mov.m ar.rsc = %2;;\n\t"        "flushrs;;\n\t"        "mov.m %0 = ar.rnat;;\n\t"        "mov.m ar.rsc = %1\n\t"        : "=r" (rnat), "=r" (tmp1), "=r" (tmp2));
name|memset
argument_list|(
name|context
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|_Unwind_Context
argument_list|)
argument_list|)
expr_stmt|;
name|context
operator|->
name|bsp
operator|=
operator|(
name|unsigned
name|long
operator|)
name|bsp
expr_stmt|;
comment|/* Set context->regstk_top to lowest rbs address which will use      context->rnat collection.  */
name|context
operator|->
name|regstk_top
operator|=
name|context
operator|->
name|bsp
operator|&
operator|~
literal|0x1ffULL
expr_stmt|;
name|context
operator|->
name|rnat
operator|=
name|rnat
expr_stmt|;
name|context
operator|->
name|psp
operator|=
operator|(
name|unsigned
name|long
operator|)
name|psp
expr_stmt|;
name|context
operator|->
name|rp
operator|=
operator|(
name|unsigned
name|long
operator|)
name|rp
expr_stmt|;
asm|asm ("mov %0 = sp" : "=r" (context->sp));
asm|asm ("mov %0 = pr" : "=r" (context->pr));
name|context
operator|->
name|pri_unat_loc
operator|=
operator|&
name|context
operator|->
name|initial_unat
expr_stmt|;
comment|/* ??? */
if|if
condition|(
name|uw_frame_state_for
argument_list|(
name|context
argument_list|,
operator|&
name|fs
argument_list|)
operator|!=
name|_URC_NO_REASON
condition|)
name|abort
argument_list|()
expr_stmt|;
name|uw_update_context
argument_list|(
name|context
argument_list|,
operator|&
name|fs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Install (ie longjmp to) the contents of TARGET.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|__attribute__
argument_list|(
operator|(
name|noreturn
operator|)
argument_list|)
name|uw_install_context
argument_list|(
expr|struct
name|_Unwind_Context
operator|*
name|current
name|__attribute__
argument_list|(
operator|(
name|unused
operator|)
argument_list|)
argument_list|,
expr|struct
name|_Unwind_Context
operator|*
name|target
argument_list|)
block|{
name|unsigned
name|long
name|ireg_buf
index|[
literal|4
index|]
decl_stmt|,
name|ireg_nat
init|=
literal|0
decl_stmt|,
name|ireg_pr
init|=
literal|0
decl_stmt|;
name|long
name|i
decl_stmt|;
comment|/* Copy integer register data from the target context to a      temporary buffer.  Do this so that we can frob AR.UNAT      to get the NaT bits for these registers set properly.  */
for|for
control|(
name|i
operator|=
literal|4
init|;
name|i
operator|<=
literal|7
condition|;
operator|++
name|i
control|)
block|{
name|char
name|nat
decl_stmt|;
name|void
modifier|*
name|t
init|=
name|target
operator|->
name|ireg
index|[
name|i
operator|-
literal|2
index|]
operator|.
name|loc
decl_stmt|;
if|if
condition|(
name|t
condition|)
block|{
name|unw_access_gr
argument_list|(
name|target
argument_list|,
name|i
argument_list|,
operator|&
name|ireg_buf
index|[
name|i
operator|-
literal|4
index|]
argument_list|,
operator|&
name|nat
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ireg_nat
operator||=
operator|(
name|long
operator|)
name|nat
operator|<<
operator|(
operator|(
operator|(
name|size_t
operator|)
operator|&
name|ireg_buf
index|[
name|i
operator|-
literal|4
index|]
operator|>>
literal|3
operator|)
operator|&
literal|0x3f
operator|)
expr_stmt|;
comment|/* Set p6 - p9.  */
name|ireg_pr
operator||=
literal|4L
operator|<<
name|i
expr_stmt|;
block|}
block|}
comment|/* The value in uc_bsp that we've computed is that for the       target function.  The value that we install below will be      adjusted by the BR.RET instruction based on the contents      of AR.PFS.  So we must unadjust that here.  */
name|target
operator|->
name|bsp
operator|=
operator|(
name|unsigned
name|long
operator|)
name|ia64_rse_skip_regs
argument_list|(
operator|(
name|unsigned
name|long
operator|*
operator|)
name|target
operator|->
name|bsp
argument_list|,
operator|(
operator|*
name|target
operator|->
name|pfs_loc
operator|>>
literal|7
operator|)
operator|&
literal|0x7f
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|->
name|bsp
operator|<
name|target
operator|->
name|regstk_top
condition|)
name|target
operator|->
name|rnat
operator|=
operator|*
name|ia64_rse_rnat_addr
argument_list|(
operator|(
name|unsigned
name|long
operator|*
operator|)
name|target
operator|->
name|bsp
argument_list|)
expr_stmt|;
comment|/* Provide assembly with the offsets into the _Unwind_Context.  */
asm|asm
specifier|volatile
asm|("uc_rnat = %0" 		: : "i"(offsetof (struct _Unwind_Context, rnat)));
asm|asm
specifier|volatile
asm|("uc_bsp = %0" 		: : "i"(offsetof (struct _Unwind_Context, bsp)));
asm|asm
specifier|volatile
asm|("uc_psp = %0" 		: : "i"(offsetof (struct _Unwind_Context, psp)));
asm|asm
specifier|volatile
asm|("uc_rp = %0" 		: : "i"(offsetof (struct _Unwind_Context, rp)));
asm|asm
specifier|volatile
asm|("uc_pr = %0" 		: : "i"(offsetof (struct _Unwind_Context, pr)));
asm|asm
specifier|volatile
asm|("uc_gp = %0" 		: : "i"(offsetof (struct _Unwind_Context, gp)));
asm|asm
specifier|volatile
asm|("uc_pfs_loc = %0" 		: : "i"(offsetof (struct _Unwind_Context, pfs_loc)));
asm|asm
specifier|volatile
asm|("uc_unat_loc = %0" 		: : "i"(offsetof (struct _Unwind_Context, unat_loc)));
asm|asm
specifier|volatile
asm|("uc_lc_loc = %0" 		: : "i"(offsetof (struct _Unwind_Context, lc_loc)));
asm|asm
specifier|volatile
asm|("uc_fpsr_loc = %0" 		: : "i"(offsetof (struct _Unwind_Context, fpsr_loc)));
asm|asm
specifier|volatile
asm|("uc_eh_data = %0" 		: : "i"(offsetof (struct _Unwind_Context, eh_data)));
asm|asm
specifier|volatile
asm|("uc_br_loc = %0" 		: : "i"(offsetof (struct _Unwind_Context, br_loc)));
asm|asm
specifier|volatile
asm|("uc_fr_loc = %0" 		: : "i"(offsetof (struct _Unwind_Context, fr_loc)));
asm|asm
specifier|volatile
asm|(
comment|/* Load up call-saved non-window integer registers from ireg_buf.  */
asm|"add r20 = 8, %1			\n\t" 	"mov ar.unat = %2			\n\t" 	"mov pr = %3, 0x3c0			\n\t" 	";;					\n\t" 	"(p6) ld8.fill r4 = [%1]		\n\t" 	"(p7) ld8.fill r5 = [r20]		\n\t" 	"add r21 = uc_br_loc + 16, %0		\n\t" 	"adds %1 = 16, %1			\n\t" 	"adds r20 = 16, r20			\n\t" 	";;					\n\t" 	"(p8) ld8.fill r6 = [%1]		\n\t" 	"(p9) ld8.fill r7 = [r20]		\n\t" 	"add r20 = uc_br_loc + 8, %0		\n\t" 	";;					\n\t"
comment|/* Load up call-saved branch registers.  */
asm|"ld8 r22 = [r20], 16			\n\t" 	"ld8 r23 = [r21], 16			\n\t" 	";;					\n\t" 	"ld8 r24 = [r20], 16			\n\t" 	"ld8 r25 = [r21], uc_fr_loc - (uc_br_loc + 32)\n\t" 	";;					\n\t" 	"ld8 r26 = [r20], uc_fr_loc + 8 - (uc_br_loc + 40)\n\t" 	"ld8 r27 = [r21], 24			\n\t" 	"cmp.ne p6, p0 = r0, r22		\n\t" 	";;					\n\t" 	"ld8 r28 = [r20], 8			\n\t" 	"(p6) ld8 r22 = [r22]			\n\t" 	"cmp.ne p7, p0 = r0, r23		\n\t" 	";;					\n\t" 	"(p7) ld8 r23 = [r23]			\n\t" 	"cmp.ne p8, p0 = r0, r24		\n\t" 	";;					\n\t" 	"(p8) ld8 r24 = [r24]			\n\t" 	"(p6) mov b1 = r22			\n\t" 	"cmp.ne p9, p0 = r0, r25		\n\t" 	";;					\n\t" 	"(p9) ld8 r25 = [r25]			\n\t" 	"(p7) mov b2 = r23			\n\t" 	"cmp.ne p6, p0 = r0, r26		\n\t" 	";;					\n\t" 	"(p6) ld8 r26 = [r26]			\n\t" 	"(p8) mov b3 = r24			\n\t" 	"cmp.ne p7, p0 = r0, r27		\n\t" 	";;					\n\t"
comment|/* Load up call-saved fp registers.  */
asm|"(p7) ldf.fill f2 = [r27]		\n\t" 	"(p9) mov b4 = r25			\n\t" 	"cmp.ne p8, p0 = r0, r28		\n\t" 	";;					\n\t" 	"(p8) ldf.fill f3 = [r28]		\n\t" 	"(p6) mov b5 = r26			\n\t" 	";;					\n\t" 	"ld8 r29 = [r20], 16*8 - 4*8		\n\t" 	"ld8 r30 = [r21], 17*8 - 5*8		\n\t" 	";;					\n\t" 	"ld8 r22 = [r20], 16			\n\t" 	"ld8 r23 = [r21], 16			\n\t" 	";;					\n\t" 	"ld8 r24 = [r20], 16			\n\t" 	"ld8 r25 = [r21]			\n\t" 	"cmp.ne p6, p0 = r0, r29		\n\t" 	";;					\n\t" 	"ld8 r26 = [r20], 8			\n\t" 	"(p6) ldf.fill f4 = [r29]		\n\t" 	"cmp.ne p7, p0 = r0, r30		\n\t" 	";;					\n\t" 	"ld8 r27 = [r20], 8			\n\t" 	"(p7) ldf.fill f5 = [r30]		\n\t" 	"cmp.ne p6, p0 = r0, r22		\n\t" 	";;					\n\t" 	"ld8 r28 = [r20], 8			\n\t" 	"(p6) ldf.fill f16 = [r22]		\n\t" 	"cmp.ne p7, p0 = r0, r23		\n\t" 	";;					\n\t" 	"ld8 r29 = [r20], 8			\n\t" 	"(p7) ldf.fill f17 = [r23]		\n\t" 	"cmp.ne p6, p0 = r0, r24		\n\t" 	";;					\n\t" 	"ld8 r22 = [r20], 8			\n\t" 	"(p6) ldf.fill f18 = [r24]		\n\t" 	"cmp.ne p7, p0 = r0, r25		\n\t" 	";;					\n\t" 	"ld8 r23 = [r20], 8			\n\t" 	"(p7) ldf.fill f19 = [r25]		\n\t" 	"cmp.ne p6, p0 = r0, r26		\n\t" 	";;					\n\t" 	"ld8 r24 = [r20], 8			\n\t" 	"(p6) ldf.fill f20 = [r26]		\n\t" 	"cmp.ne p7, p0 = r0, r27		\n\t" 	";;					\n\t" 	"ld8 r25 = [r20], 8			\n\t" 	"(p7) ldf.fill f21 = [r27]		\n\t" 	"cmp.ne p6, p0 = r0, r28		\n\t" 	";;					\n\t" 	"ld8 r26 = [r20], 8			\n\t" 	"(p6) ldf.fill f22 = [r28]		\n\t" 	"cmp.ne p7, p0 = r0, r29		\n\t" 	";;					\n\t" 	"ld8 r27 = [r20], 8			\n\t" 	";;					\n\t" 	"ld8 r28 = [r20], 8			\n\t" 	"(p7) ldf.fill f23 = [r29]		\n\t" 	"cmp.ne p6, p0 = r0, r22		\n\t" 	";;					\n\t" 	"ld8 r29 = [r20], 8			\n\t" 	"(p6) ldf.fill f24 = [r22]		\n\t" 	"cmp.ne p7, p0 = r0, r23		\n\t" 	";;					\n\t" 	"(p7) ldf.fill f25 = [r23]		\n\t" 	"cmp.ne p6, p0 = r0, r24		\n\t" 	"cmp.ne p7, p0 = r0, r25		\n\t" 	";;					\n\t" 	"(p6) ldf.fill f26 = [r24]		\n\t" 	"(p7) ldf.fill f27 = [r25]		\n\t" 	"cmp.ne p6, p0 = r0, r26		\n\t" 	";;					\n\t" 	"(p6) ldf.fill f28 = [r26]		\n\t" 	"cmp.ne p7, p0 = r0, r27		\n\t" 	"cmp.ne p6, p0 = r0, r28		\n\t" 	";;					\n\t" 	"(p7) ldf.fill f29 = [r27]		\n\t" 	"(p6) ldf.fill f30 = [r28]		\n\t" 	"cmp.ne p7, p0 = r0, r29		\n\t" 	";;					\n\t" 	"(p7) ldf.fill f31 = [r29]		\n\t" 	"add r20 = uc_rnat, %0			\n\t" 	"add r21 = uc_bsp, %0			\n\t" 	";;					\n\t"
comment|/* Load the balance of the thread state from the context.  */
asm|"ld8 r22 = [r20], uc_psp - uc_rnat	\n\t" 	"ld8 r23 = [r21], uc_gp - uc_bsp	\n\t" 	";;					\n\t" 	"ld8 r24 = [r20], uc_pfs_loc - uc_psp	\n\t" 	"ld8 r1 = [r21], uc_rp - uc_gp		\n\t" 	";;					\n\t" 	"ld8 r25 = [r20], uc_unat_loc - uc_pfs_loc\n\t" 	"ld8 r26 = [r21], uc_pr - uc_rp		\n\t" 	";;					\n\t" 	"ld8 r27 = [r20], uc_lc_loc - uc_unat_loc\n\t" 	"ld8 r28 = [r21], uc_fpsr_loc - uc_pr	\n\t" 	";;					\n\t" 	"ld8 r29 = [r20], uc_eh_data - uc_lc_loc\n\t" 	"ld8 r30 = [r21], uc_eh_data + 8 - uc_fpsr_loc\n\t" 	";;					\n\t"
comment|/* Load data for the exception handler.  */
asm|"ld8 r15 = [r20], 16			\n\t" 	"ld8 r16 = [r21], 16			\n\t" 	";;					\n\t" 	"ld8 r17 = [r20]			\n\t" 	"ld8 r18 = [r21]			\n\t" 	";;					\n\t"
comment|/* Install the balance of the thread state loaded above.  */
asm|"cmp.ne p6, p0 = r0, r25		\n\t" 	"cmp.ne p7, p0 = r0, r27		\n\t" 	";;					\n\t" 	"(p6) ld8 r25 = [r25]			\n\t" 	"(p7) ld8 r27 = [r27]			\n\t" 	";;					\n\t" 	"(p7) mov.m ar.unat = r27		\n\t" 	"(p6) mov.i ar.pfs = r25		\n\t" 	"cmp.ne p9, p0 = r0, r29		\n\t" 	";;					\n\t" 	"(p9) ld8 r29 = [r29]			\n\t" 	"cmp.ne p6, p0 = r0, r30		\n\t" 	";;					\n\t" 	"(p6) ld8 r30 = [r30]			\n\t"
comment|/* Don't clobber p6-p9, which are in use at present.  */
asm|"mov pr = r28, ~0x3c0			\n\t" 	"(p9) mov.i ar.lc = r29			\n\t" 	";;					\n\t" 	"mov.m r25 = ar.rsc			\n\t" 	"(p6) mov.m ar.fpsr = r30		\n\t" 	";;					\n\t" 	"and r29 = 0x1c, r25			\n\t" 	"mov b0 = r26				\n\t" 	";;					\n\t" 	"mov.m ar.rsc = r29			\n\t" 	";;					\n\t"
comment|/* This must be done before setting AR.BSPSTORE, otherwise  	   AR.BSP will be initialized with a random displacement 	   below the value we want, based on the current number of 	   dirty stacked registers.  */
asm|"loadrs					\n\t" 	"invala					\n\t" 	";;					\n\t" 	"mov.m ar.bspstore = r23		\n\t" 	";;					\n\t" 	"mov.m ar.rnat = r22			\n\t" 	";;					\n\t" 	"mov.m ar.rsc = r25			\n\t" 	"mov sp = r24				\n\t" 	"br.ret.sptk.few b0" 	: : "r"(target), "r"(ireg_buf), "r"(ireg_nat), "r"(ireg_pr) 	: "r15", "r16", "r17", "r18", "r20", "r21", "r22", 	  "r23", "r24", "r25", "r26", "r27", "r28", "r29", 	  "r30", "r31");
comment|/* NOTREACHED */
while|while
condition|(
literal|1
condition|)
empty_stmt|;
block|}
end_decl_stmt

begin_function
specifier|static
specifier|inline
name|_Unwind_Ptr
name|uw_identify_context
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|)
block|{
return|return
name|_Unwind_GetIP
argument_list|(
name|context
argument_list|)
return|;
block|}
end_function

begin_include
include|#
directive|include
file|"unwind.inc"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USE_GAS_SYMVER
argument_list|)
operator|&&
name|defined
argument_list|(
name|SHARED
argument_list|)
operator|&&
name|defined
argument_list|(
name|USE_LIBUNWIND_EXCEPTIONS
argument_list|)
end_if

begin_expr_stmt
name|alias
argument_list|(
name|_Unwind_Backtrace
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|alias
argument_list|(
name|_Unwind_DeleteException
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|alias
argument_list|(
name|_Unwind_FindEnclosingFunction
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|alias
argument_list|(
name|_Unwind_FindTableEntry
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|alias
argument_list|(
name|_Unwind_ForcedUnwind
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|alias
argument_list|(
name|_Unwind_GetBSP
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|alias
argument_list|(
name|_Unwind_GetCFA
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|alias
argument_list|(
name|_Unwind_GetGR
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|alias
argument_list|(
name|_Unwind_GetIP
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|alias
argument_list|(
name|_Unwind_GetLanguageSpecificData
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|alias
argument_list|(
name|_Unwind_GetRegionStart
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|alias
argument_list|(
name|_Unwind_RaiseException
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|alias
argument_list|(
name|_Unwind_Resume
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|alias
argument_list|(
name|_Unwind_Resume_or_Rethrow
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|alias
argument_list|(
name|_Unwind_SetGR
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|alias
argument_list|(
name|_Unwind_SetIP
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

end_unit

