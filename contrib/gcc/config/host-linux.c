begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Linux host-specific hook definitions.    Copyright (C) 2004, 2005 Free Software Foundation, Inc.     This file is part of GCC.     GCC is free software; you can redistribute it and/or modify it    under the terms of the GNU General Public License as published    by the Free Software Foundation; either version 2, or (at your    option) any later version.     GCC is distributed in the hope that it will be useful, but WITHOUT    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public    License for more details.     You should have received a copy of the GNU General Public License    along with GCC; see the file COPYING.  If not, write to the    Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,    MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|"hosthooks.h"
end_include

begin_include
include|#
directive|include
file|"hosthooks-def.h"
end_include

begin_comment
comment|/* Linux has a feature called exec-shield-randomize that perturbs the    address of non-fixed mapped segments by a (relatively) small amount.    The feature is intended to make it harder to attack the system with    buffer overflow attacks, since every invocation of a program will    have its libraries and data segments at slightly different addresses.     This feature causes us problems with PCH because it makes it that    much harder to acquire a stable location at which to map our PCH    data file.     [ The feature causes other points of non-determinism within the      compiler as well, so we'd *really* like to be able to have the      driver disable exec-shield-randomize for the process group, but      that isn't possible at present.  ]     We're going to try several things:        * Select an architecture specific address as "likely" and see 	if that's free.  For our 64-bit hosts, we can easily choose 	an address in Never Never Land.        * If exec-shield-randomize is disabled, then just use the 	address chosen by mmap in step one.        * If exec-shield-randomize is enabled, then temporarily allocate 	32M of memory as a buffer, then allocate PCH memory, then 	free the buffer.  The theory here is that the perturbation is 	no more than 16M, and so by allocating our buffer larger than 	that we make it considerably more likely that the address will 	be free when we want to load the data back. */
end_comment

begin_undef
undef|#
directive|undef
name|HOST_HOOKS_GT_PCH_GET_ADDRESS
end_undef

begin_define
define|#
directive|define
name|HOST_HOOKS_GT_PCH_GET_ADDRESS
value|linux_gt_pch_get_address
end_define

begin_undef
undef|#
directive|undef
name|HOST_HOOKS_GT_PCH_USE_ADDRESS
end_undef

begin_define
define|#
directive|define
name|HOST_HOOKS_GT_PCH_USE_ADDRESS
value|linux_gt_pch_use_address
end_define

begin_comment
comment|/* For various ports, try to guess a fixed spot in the vm space    that's probably free.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__alpha
argument_list|)
end_if

begin_define
define|#
directive|define
name|TRY_EMPTY_VM_SPACE
value|0x10000000000
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__ia64
argument_list|)
end_elif

begin_define
define|#
directive|define
name|TRY_EMPTY_VM_SPACE
value|0x2000000100000000
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__x86_64
argument_list|)
end_elif

begin_define
define|#
directive|define
name|TRY_EMPTY_VM_SPACE
value|0x1000000000
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__i386
argument_list|)
end_elif

begin_define
define|#
directive|define
name|TRY_EMPTY_VM_SPACE
value|0x60000000
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__powerpc__
argument_list|)
end_elif

begin_define
define|#
directive|define
name|TRY_EMPTY_VM_SPACE
value|0x60000000
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__s390x__
argument_list|)
end_elif

begin_define
define|#
directive|define
name|TRY_EMPTY_VM_SPACE
value|0x8000000000
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__s390__
argument_list|)
end_elif

begin_define
define|#
directive|define
name|TRY_EMPTY_VM_SPACE
value|0x60000000
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__sparc__
argument_list|)
operator|&&
name|defined
argument_list|(
name|__LP64__
argument_list|)
end_elif

begin_define
define|#
directive|define
name|TRY_EMPTY_VM_SPACE
value|0x8000000000
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__sparc__
argument_list|)
end_elif

begin_define
define|#
directive|define
name|TRY_EMPTY_VM_SPACE
value|0x60000000
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|TRY_EMPTY_VM_SPACE
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Determine a location where we might be able to reliably allocate SIZE    bytes.  FD is the PCH file, though we should return with the file     unmapped.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|linux_gt_pch_get_address
parameter_list|(
name|size_t
name|size
parameter_list|,
name|int
name|fd
parameter_list|)
block|{
name|size_t
name|buffer_size
init|=
literal|32
operator|*
literal|1024
operator|*
literal|1024
decl_stmt|;
name|void
modifier|*
name|addr
decl_stmt|,
modifier|*
name|buffer
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|bool
name|randomize_on
decl_stmt|;
name|addr
operator|=
name|mmap
argument_list|(
operator|(
name|void
operator|*
operator|)
name|TRY_EMPTY_VM_SPACE
argument_list|,
name|size
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_PRIVATE
argument_list|,
name|fd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If we failed the map, that means there's *no* free space.  */
if|if
condition|(
name|addr
operator|==
operator|(
name|void
operator|*
operator|)
name|MAP_FAILED
condition|)
return|return
name|NULL
return|;
comment|/* Unmap the area before returning.  */
name|munmap
argument_list|(
name|addr
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* If we got the exact area we requested, then that's great.  */
if|if
condition|(
name|TRY_EMPTY_VM_SPACE
operator|&&
name|addr
operator|==
operator|(
name|void
operator|*
operator|)
name|TRY_EMPTY_VM_SPACE
condition|)
return|return
name|addr
return|;
comment|/* If we didn't, then we need to look to see if virtual address      randomization is on.  That is recorded in      kernel.randomize_va_space.  An older implementation used      kernel.exec-shield-randomize.  */
name|f
operator|=
name|fopen
argument_list|(
literal|"/proc/sys/kernel/randomize_va_space"
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
name|f
operator|=
name|fopen
argument_list|(
literal|"/proc/sys/kernel/exec-shield-randomize"
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|randomize_on
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|f
operator|!=
name|NULL
condition|)
block|{
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|size_t
name|c
decl_stmt|;
name|c
operator|=
name|fread
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
name|buf
operator|-
literal|1
argument_list|,
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|>
literal|0
condition|)
block|{
name|buf
index|[
name|c
index|]
operator|=
literal|'\0'
expr_stmt|;
name|randomize_on
operator|=
operator|(
name|atoi
argument_list|(
name|buf
argument_list|)
operator|>
literal|0
operator|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
comment|/* If it isn't, then accept the address that mmap selected as fine.  */
if|if
condition|(
operator|!
name|randomize_on
condition|)
return|return
name|addr
return|;
comment|/* Otherwise, we need to try again with buffer space.  */
name|buffer
operator|=
name|mmap
argument_list|(
literal|0
argument_list|,
name|buffer_size
argument_list|,
name|PROT_NONE
argument_list|,
name|MAP_PRIVATE
operator||
name|MAP_ANON
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addr
operator|=
name|mmap
argument_list|(
literal|0
argument_list|,
name|size
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_PRIVATE
argument_list|,
name|fd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
operator|!=
operator|(
name|void
operator|*
operator|)
name|MAP_FAILED
condition|)
name|munmap
argument_list|(
name|buffer
argument_list|,
name|buffer_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|==
operator|(
name|void
operator|*
operator|)
name|MAP_FAILED
condition|)
return|return
name|NULL
return|;
name|munmap
argument_list|(
name|addr
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|addr
return|;
block|}
end_function

begin_comment
comment|/* Map SIZE bytes of FD+OFFSET at BASE.  Return 1 if we succeeded at    mapping the data at BASE, -1 if we couldn't.     It's not possibly to reliably mmap a file using MAP_PRIVATE to    a specific START address on either hpux or linux.  First we see    if mmap with MAP_PRIVATE works.  If it does, we are off to the    races.  If it doesn't, we try an anonymous private mmap since the    kernel is more likely to honor the BASE address in anonymous maps.    We then copy the data to the anonymous private map.  This assumes    of course that we don't need to change the data in the PCH file    after it is created.     This approach obviously causes a performance penalty but there is    little else we can do given the current PCH implementation.  */
end_comment

begin_function
specifier|static
name|int
name|linux_gt_pch_use_address
parameter_list|(
name|void
modifier|*
name|base
parameter_list|,
name|size_t
name|size
parameter_list|,
name|int
name|fd
parameter_list|,
name|size_t
name|offset
parameter_list|)
block|{
name|void
modifier|*
name|addr
decl_stmt|;
comment|/* We're called with size == 0 if we're not planning to load a PCH      file at all.  This allows the hook to free any static space that      we might have allocated at link time.  */
if|if
condition|(
name|size
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Try to map the file with MAP_PRIVATE.  */
name|addr
operator|=
name|mmap
argument_list|(
name|base
argument_list|,
name|size
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_PRIVATE
argument_list|,
name|fd
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|==
name|base
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|addr
operator|!=
operator|(
name|void
operator|*
operator|)
name|MAP_FAILED
condition|)
name|munmap
argument_list|(
name|addr
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* Try to make an anonymous private mmap at the desired location.  */
name|addr
operator|=
name|mmap
argument_list|(
name|base
argument_list|,
name|size
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_PRIVATE
operator||
name|MAP_ANONYMOUS
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|!=
name|base
condition|)
block|{
if|if
condition|(
name|addr
operator|!=
operator|(
name|void
operator|*
operator|)
name|MAP_FAILED
condition|)
name|munmap
argument_list|(
name|addr
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|lseek
argument_list|(
name|fd
argument_list|,
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|(
name|off_t
operator|)
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
while|while
condition|(
name|size
condition|)
block|{
name|ssize_t
name|nbytes
decl_stmt|;
name|nbytes
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|base
argument_list|,
name|MIN
argument_list|(
name|size
argument_list|,
name|SSIZE_MAX
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbytes
operator|<=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|base
operator|=
operator|(
name|char
operator|*
operator|)
name|base
operator|+
name|nbytes
expr_stmt|;
name|size
operator|-=
name|nbytes
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|const
name|struct
name|host_hooks
name|host_hooks
init|=
name|HOST_HOOKS_INITIALIZER
decl_stmt|;
end_decl_stmt

end_unit

