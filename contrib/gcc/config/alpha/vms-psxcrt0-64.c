begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* VMS 64bit crt0 returning Unix style condition codes .    Copyright (C) 2001 Free Software Foundation, Inc.    Contributed by Douglas B. Rupp (rupp@gnat.com).  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  In addition to the permissions in the GNU General Public License, the Free Software Foundation gives you unlimited permission to link the compiled version of this file into combinations with other programs, and to distribute those combinations without any restriction coming from the use of this file.  (The General Public License restrictions do apply in other respects; for example, they cover modification of the file, and distribution when not linked into a combine executable.)  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__DECC
argument_list|)
end_if

begin_expr_stmt
name|You
name|Lose
operator|!
name|This
name|file
name|can
name|only
name|be
name|compiled
name|with
name|DEC
name|C
operator|.
else|#
directive|else
comment|/* This file can only be compiled with DEC C, due the the call to    lib$establish and the pragmas pointer_size.  */
pragma|#
directive|pragma
name|__pointer_size
name|short
include|#
directive|include
file|<stdlib.h>
include|#
directive|include
file|<string.h>
include|#
directive|include
file|<ssdef.h>
include|#
directive|include
file|<stsdef.h>
include|#
directive|include
file|<errnodef.h>
expr|extern
name|void
name|decc$main
argument_list|()
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|extern
name|int
name|main
parameter_list|()
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|handler
parameter_list|(
name|sigargs
parameter_list|,
name|mechargs
parameter_list|)
name|void
modifier|*
name|sigargs
decl_stmt|;
name|void
modifier|*
name|mechargs
decl_stmt|;
block|{
return|return
name|SS$_RESIGNAL
return|;
block|}
end_function

begin_decl_stmt
name|int
name|__main
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|,
name|image_file_desc
argument_list|,
name|arg5
argument_list|,
name|arg6
argument_list|)
name|void
modifier|*
name|arg1
decl_stmt|,
modifier|*
name|arg2
decl_stmt|,
modifier|*
name|arg3
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
modifier|*
name|image_file_desc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
modifier|*
name|arg5
decl_stmt|,
modifier|*
name|arg6
decl_stmt|)
block|{
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
modifier|*
name|envp
decl_stmt|;
pragma|#
directive|pragma
name|__pointer_size
name|long
name|int
name|i
decl_stmt|;
name|char
modifier|*
modifier|*
name|long_argv
decl_stmt|;
name|char
modifier|*
modifier|*
name|long_envp
decl_stmt|;
name|int
name|status
decl_stmt|;
pragma|#
directive|pragma
name|__pointer_size
name|short
name|lib$establish
argument_list|(
name|handler
argument_list|)
expr_stmt|;
name|decc$main
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|,
name|image_file_desc
argument_list|,
name|arg5
argument_list|,
name|arg6
argument_list|,
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|,
operator|&
name|envp
argument_list|)
expr_stmt|;
pragma|#
directive|pragma
name|__pointer_size
name|long
comment|/* Reallocate argv with 64 bit pointers. */
name|long_argv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
operator|(
name|argc
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
name|long_argv
index|[
name|i
index|]
operator|=
name|strdup
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|long_argv
index|[
name|argc
index|]
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
name|long_envp
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
literal|5
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|envp
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|long_envp
index|[
name|i
index|]
operator|=
name|strdup
argument_list|(
name|envp
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|long_envp
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
pragma|#
directive|pragma
name|__pointer_size
name|short
name|status
operator|=
name|main
argument_list|(
name|argc
argument_list|,
name|long_argv
argument_list|,
name|long_envp
argument_list|)
expr_stmt|;
comment|/* Map into a range of 0 - 255.  */
name|status
operator|=
name|status
operator|&
literal|255
expr_stmt|;
if|if
condition|(
name|status
operator|>
literal|0
condition|)
block|{
name|int
name|save_status
init|=
name|status
decl_stmt|;
name|status
operator|=
name|C$_EXIT1
operator|+
operator|(
operator|(
name|status
operator|-
literal|1
operator|)
operator|<<
name|STS$V_MSG_NO
operator|)
expr_stmt|;
comment|/* An exit failure status requires a "severe" error.  All status values 	 are defined in errno with a successful (1) severity but can be 	 changed to an error (2) severity by adding 1.  In addition for 	 compatibility with UNIX exit() routines we inhibit a run-time error 	 message from being generated on exit(1).  */
if|if
condition|(
name|save_status
operator|==
literal|1
condition|)
block|{
name|status
operator|++
expr_stmt|;
name|status
operator||=
name|STS$M_INHIB_MSG
expr_stmt|;
block|}
block|}
if|if
condition|(
name|status
operator|==
literal|0
condition|)
name|status
operator|=
name|SS$_NORMAL
expr_stmt|;
return|return
name|status
return|;
block|}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

end_unit

